<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="9bd2c2e8eaa4afd48046645ba794fcbca53b28f4" translate="yes" xml:space="preserve">
          <source>The following additional options are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f218f3efdde351da4f071874c06c4afe80e209d" translate="yes" xml:space="preserve">
          <source>The following are all valid &lt;code&gt;json&lt;/code&gt; (or &lt;code&gt;jsonb&lt;/code&gt;) expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c039bfa9f08ddfc0a59acd61d84cddcf4b0d6ac9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to constraint exclusion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed89af6d7b571e68348aa46975289d8d36b6f9e9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to partitioning implemented using inheritance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e533c6b217bf172992ac716839050a2d3fd0b7" translate="yes" xml:space="preserve">
          <source>The following command can be used to create an index on the &lt;code&gt;id&lt;/code&gt; column, as discussed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4545d07872378e0f1220b619c3281f607f171dfb" translate="yes" xml:space="preserve">
          <source>The following command defines a new operator, area-equality, for the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc91b2b085f350c73a66cbdf6d3a5a0c4fb379" translate="yes" xml:space="preserve">
          <source>The following command-line options are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5ca5337b558c5af015478dbbd74c89d07107d2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the content and format of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05475cf2eec87e97d8772a07ec18d9fdca7b5435" translate="yes" xml:space="preserve">
          <source>The following command-line options control the database connection parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220365fea8f99014f431d00f0ea052b58e2c1fcb" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the running of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56b05f8e623fa43fb5bc9f1eeba6d4c3440d581" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output and other replication behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f449555e10b2046b1ccc209c3ef5b6dce0f90612" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a034b5b9d901cf6c0ba2052c558173c4b654b2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90c14e70ab12e4fce9bec3bf939f8e3cd367938" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for GSSAPI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46edfe1841a44936730cc915774b2516fbe1a78a" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for PAM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514923f06896538a2f8d0943aa9139974686a363" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for RADIUS:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf0b28821a566799fd52288a31f3e25a128c408" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSL certificate authentication:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad3bae7c6cb5e9156e0aafc4f4c4d5aa18bfd10" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSPI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be704faf73a86cf08decb39d5cfdd09dedabb81b" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for ident:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd3b16b14e5df4be73c034d0d0a8f2f793213cc" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for peer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cc6138e97e8a814646a47d2cd6ecdb0c1d8d16" translate="yes" xml:space="preserve">
          <source>The following configuration options are used in both modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ae133d649ffad972068d98ba1e0a950ea94086" translate="yes" xml:space="preserve">
          <source>The following containment predicate uses the point syntax, while in fact the second argument is internally represented by a box. This syntax makes it unnecessary to define a separate point type and functions for (box,point) predicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1f58c5086fb9d7dbb2dff29ebf934fc1fd38a7" translate="yes" xml:space="preserve">
          <source>The following example command &amp;ldquo;updates&amp;rdquo; the dictionary's definition without actually changing anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f20cbbdfc0e4abc07d317b7cde01bad2e3188ac" translate="yes" xml:space="preserve">
          <source>The following example command adds cross-data-type operators and support functions to an operator family that already contains B-tree operator classes for data types &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;int2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ce952daa9dd539b9ae5ea67f8fc03311bc7883" translate="yes" xml:space="preserve">
          <source>The following example command changes the language option to &lt;code&gt;dutch&lt;/code&gt;, and removes the stopword option entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0690fd36226cece879c24f85e0b2a34e7740cb2a" translate="yes" xml:space="preserve">
          <source>The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c6101649b45994a81cc07611f7c341ccfd2d4d" translate="yes" xml:space="preserve">
          <source>The following example command creates a Snowball-based dictionary with a nonstandard list of stop words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0540cfecb071eb102ec89874893aeae6b2dac906" translate="yes" xml:space="preserve">
          <source>The following example command defines a GiST index operator class for the data type &lt;code&gt;_int4&lt;/code&gt; (array of &lt;code&gt;int4&lt;/code&gt;). See the &lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt; module for the complete example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3a1ce4208d975ebd37d2a046e1777755826724" translate="yes" xml:space="preserve">
          <source>The following example copies a table to the client using the vertical bar (&lt;code&gt;|&lt;/code&gt;) as the field delimiter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d013459769f3027ad75584e21efea2204848877" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause can be used to specify a list of namespaces used in the XML document as well as in the XPath expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8120020f967b896e9eb5f42600de6773abdc4c59" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0272043332c15e45fca8627b9940585ab0ce4a" translate="yes" xml:space="preserve">
          <source>The following example replaces the &lt;code&gt;english&lt;/code&gt; dictionary with the &lt;code&gt;swedish&lt;/code&gt; dictionary anywhere that &lt;code&gt;english&lt;/code&gt; is used within &lt;code&gt;my_config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86c39babfe81954fe9ebb108b217aea8248e655" translate="yes" xml:space="preserve">
          <source>The following example shows concatenation of multiple text() nodes, usage of the column name as XPath filter, and the treatment of whitespace, XML comments and processing instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54642b031a2227e507d5a953bc0c97aa2f10ca2d" translate="yes" xml:space="preserve">
          <source>The following example shows how the security label of a table might be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d0858a7dd21e2c17fd7d8938ac8b2bda33b78f" translate="yes" xml:space="preserve">
          <source>The following example shows the result of estimating a &lt;code&gt;WHERE&lt;/code&gt; condition on the &lt;code&gt;a&lt;/code&gt; column:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04036b5b20e932a63bf10913615aab08c6e7f9bb" translate="yes" xml:space="preserve">
          <source>The following example traverses a table using a cursor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c8644502b27c5f09c1b2cd46083c907b3859da" translate="yes" xml:space="preserve">
          <source>The following examples will illustrate the usage of all three notations, using the following function definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc2a5eced86eee0d88b99c3c79c239f1015ae7c" translate="yes" xml:space="preserve">
          <source>The following functions allow direct testing of a text search parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0070eaa8f2988c475085144814bd098c68e7d6" translate="yes" xml:space="preserve">
          <source>The following functions are available if libxslt is installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6868f6a5c512b545d6b54882e8a5b465e4040e96" translate="yes" xml:space="preserve">
          <source>The following functions are available to delay execution of the server process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eaa7ab3c8107e57a840871a19a9fd7639ac2e60" translate="yes" xml:space="preserve">
          <source>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99534b0054b1dbaf525bfa83dffbf3dceb4ed5a" translate="yes" xml:space="preserve">
          <source>The following functions produce XML data mappings and the corresponding XML Schema in one document (or forest), linked together. They can be useful where self-contained and self-describing results are wanted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0717a340e1889a17503b962f24442ac075bb61f2" translate="yes" xml:space="preserve">
          <source>The following functions return XML Schema documents describing the mappings performed by the corresponding functions above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e9cfe2ae99c540eae639b3c0d4e7139991c05c" translate="yes" xml:space="preserve">
          <source>The following functions work on bit strings as well as binary strings: &lt;code&gt;get_bit&lt;/code&gt;, &lt;code&gt;set_bit&lt;/code&gt;. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8888d531981405af8909029406e91231d32e3fc" translate="yes" xml:space="preserve">
          <source>The following is an equivalent way of accomplishing the same result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5156ec918109db1c50b00eba83d4a25d3045435" translate="yes" xml:space="preserve">
          <source>The following is divided into three subsections. Different options are used during database initialization and while running benchmarks, but some options are useful in both cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647af377018af1687ed8efb04b9618837aa7790d" translate="yes" xml:space="preserve">
          <source>The following is the same data, output in binary format. The data is shown after filtering through the Unix utility &lt;code&gt;od -c&lt;/code&gt;. The table has three columns; the first has type &lt;code&gt;char(2)&lt;/code&gt;, the second has type &lt;code&gt;text&lt;/code&gt;, and the third has type &lt;code&gt;integer&lt;/code&gt;. All the rows have a null value in the third column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda35f89f366a92b9c1f3ee20bc9ca7f81e63cc1" translate="yes" xml:space="preserve">
          <source>The following less trivial example writes the Russian word &amp;ldquo;slon&amp;rdquo; (elephant) in Cyrillic letters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189e345b5ef4ff87c793abeb8737dfccbc0f04c1" translate="yes" xml:space="preserve">
          <source>The following limitations apply to partitioned tables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e788f5edc12a91d7e7f317a229ad70f5f2729c" translate="yes" xml:space="preserve">
          <source>The following meta-commands are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd608061d746b035415cdac00c81458451b62316" translate="yes" xml:space="preserve">
          <source>The following methods for collecting the write-ahead logs are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56049877daf2d04bdadddbc86e9035f590ef7d4" translate="yes" xml:space="preserve">
          <source>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a441d0a9d0ce26e47c5d9596d3d57e320cb00a5" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e78db2119a951e7a8c9fc8a972d223a3355886" translate="yes" xml:space="preserve">
          <source>The following options are only needed when &lt;code&gt;pg_resetwal&lt;/code&gt; is unable to determine appropriate values by reading &lt;code&gt;pg_control&lt;/code&gt;. Safe values can be determined as described below. For values that take numeric arguments, hexadecimal values can be specified by using the prefix &lt;code&gt;0x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bed63b9b9fa472f1bfef341fe738b22ca2d102" translate="yes" xml:space="preserve">
          <source>The following options are used in search+bind mode only:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a727fc2f66779d9648449bd2ed769b9bf5969532" translate="yes" xml:space="preserve">
          <source>The following options are used in simple bind mode only:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537f6640d02bb24a88ec9d9b40defc6c0eca02e5" translate="yes" xml:space="preserve">
          <source>The following options further specify the recovery target, and affect what happens when the target is reached:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135a7643cb1d0d74cb2e4a970ae91d9faed5be8" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e806d19c35f4be356192bcaf56df7bac7d67cbd" translate="yes" xml:space="preserve">
          <source>The following parameters are intended for work on the PostgreSQL source code, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them on a production database. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. Note that many of these parameters require special source compilation flags to work at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4026e02031547a37479fb9b05f84b97775d5fe92" translate="yes" xml:space="preserve">
          <source>The following query can be used to identify all collations in the current database that need to be refreshed and the objects that depend on them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0122a37523d76103f38f449cd343e0b060ab0d9" translate="yes" xml:space="preserve">
          <source>The following query shows all defined operator classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfe858c80303e50296d8f2a37810c84b510900d" translate="yes" xml:space="preserve">
          <source>The following resources contain additional information about genetic algorithms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327c23aaa47c9cad7b97d5d2a03e766b6d51df50" translate="yes" xml:space="preserve">
          <source>The following sections describe the authentication methods in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb4c79f6ac510d43001882e836e62ac542ea4a4" translate="yes" xml:space="preserve">
          <source>The following sections describe the details of the select list, the table expression, and the sort specification. &lt;code&gt;WITH&lt;/code&gt; queries are treated last since they are an advanced feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ca436eba9354db1bd47061237b54b62f2b67c" translate="yes" xml:space="preserve">
          <source>The following special backslash sequences are recognized by &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f427c4f9638a34d3033435ec6c0132981a12871" translate="yes" xml:space="preserve">
          <source>The following steps occur in a concurrent reindex. Each step is run in a separate transaction. If there are multiple indexes to be rebuilt, then each step loops through all the indexes before moving to the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32c87e22cead595c4cbd93a657097e6823f09e3" translate="yes" xml:space="preserve">
          <source>The following subsections describe the kinds of extended statistics that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542557b3d5f6134bfa542b4b0f72c63ee404d9ac" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 7.3 and is still supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4264d6fcf534ad0d711543bbbad940acfd384f" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 9.0 and is still supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffe77d533e655164667efaec733a8644752fd0c" translate="yes" xml:space="preserve">
          <source>The following table summarizes which types of triggers may be used on tables, views, and foreign tables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dedb03b6c7c1e94159053f8cafdd1b64ee1259" translate="yes" xml:space="preserve">
          <source>The following two examples are identical ways of sorting the individual results according to the contents of the second column (&lt;code&gt;name&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82d287994dca1133e1c905ec21b4420d1348aaa" translate="yes" xml:space="preserve">
          <source>The following types (or spellings thereof) are specified by SQL: &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;bit varying&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; (with or without time zone), &lt;code&gt;timestamp&lt;/code&gt; (with or without time zone), &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008f4840c9bbbc114acf97e5143a54c88f68912b" translate="yes" xml:space="preserve">
          <source>The following types of administration commands are not accepted during recovery mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a4cbf72726623686906a4dfcab95be0271a53f" translate="yes" xml:space="preserve">
          <source>The following types of parallel-aware table scans are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ec767602366e0da0c6d60741f363eda41896e3" translate="yes" xml:space="preserve">
          <source>The foreign server to import from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe288bd62bdf2a35ec4994319ad86594322f65f" translate="yes" xml:space="preserve">
          <source>The foreign-data wrapper name must be unique within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128070d44af946b3f1ecf65ccd252fb06b8cf14f" translate="yes" xml:space="preserve">
          <source>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3c7541e2c4fcc461ec02ccb2547741ee4be834" translate="yes" xml:space="preserve">
          <source>The format of the log is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1adf1c1ec6d1279c3ae3b2793de10b99dbd36d4" translate="yes" xml:space="preserve">
          <source>The formatting function &lt;code&gt;to_char&lt;/code&gt; (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) is also available as a more flexible way to format date/time output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba5e32cb8a2291627c08e67bf1bfb6249955cd8" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt; (without &lt;code&gt;USING INDEX&lt;/code&gt;), &lt;code&gt;DROP [COLUMN]&lt;/code&gt;, &lt;code&gt;DROP IDENTITY&lt;/code&gt;, &lt;code&gt;RESTART&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;SET DATA TYPE&lt;/code&gt; (without &lt;code&gt;USING&lt;/code&gt;), &lt;code&gt;SET GENERATED&lt;/code&gt;, and &lt;code&gt;SET sequence_option&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; command is an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e0a26739b6392b783c8e0781017e51a86f2c82" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, and &lt;code&gt;SET DATA TYPE&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; command is an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb183e300587222b81cf3fc6aa4245c9a8136ea" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;NEXT&lt;/code&gt;, &lt;code&gt;PRIOR&lt;/code&gt;, &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt;, &lt;code&gt;ABSOLUTE&lt;/code&gt;, &lt;code&gt;RELATIVE&lt;/code&gt; fetch a single row after moving the cursor appropriately. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2588add0e86c17b12a1c6aa4f12342731ddacd9b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last-returned row (or after/before all rows, if the &lt;code&gt;count&lt;/code&gt; exceeds the number of rows available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a28d1e90b500392094fc0f5e04fc9e1934bc5b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;{&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; are known as &lt;em&gt;bounds&lt;/em&gt;. The numbers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35372a44df7778273e762917011aca61a01afe9f" translate="yes" xml:space="preserve">
          <source>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5226a0f4072d37673ee94afa6e18b7e80854c8" translate="yes" xml:space="preserve">
          <source>The fourth form changes the default tablespace of the database. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace. This command physically moves any tables or indexes in the database's old default tablespace to the new tablespace. The new default tablespace must be empty for this database, and no one can be connected to the database. Tables and indexes in non-default tablespaces are unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36812cc6bb8478aaca401b63d7fbabaea11a3122" translate="yes" xml:space="preserve">
          <source>The fourth form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new base type (scalar type). To create a new base type, you must be a superuser. (This restriction is made because an erroneous type definition could confuse or even crash the server.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5bc0cc22101b5b7b3dd6dc1462291809c736e9" translate="yes" xml:space="preserve">
          <source>The fourth variant of this command listed in the synopsis can change all of the publication properties specified in &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. Properties not mentioned in the command retain their previous settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea2017c78cbd95284b251ddbea3a7b1e10a923d" translate="yes" xml:space="preserve">
          <source>The fraction of the column's entries that are null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d7567a007c45862dffe28ca10785cde8529aa6" translate="yes" xml:space="preserve">
          <source>The full SQL type syntax is allowed for declaring a function's arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type &lt;code&gt;numeric&lt;/code&gt;) are discarded by &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Thus for example &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; is exactly the same as &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36f659c83072f67d547396d3e51c25042456bdd" translate="yes" xml:space="preserve">
          <source>The full host name (with domain name) of the database server, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket, or &lt;code&gt;[local:/dir/name]&lt;/code&gt;, if the Unix domain socket is not at the compiled in default location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d56119fb00f5592b9aaa01b9f5e760e9ad4329" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa8c22afca8c86aa84834df3d7365a4c4ad70ab" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; yields the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. It corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;. An example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6649ace670e65e10a1490b2ecf7a4829ee526f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;date_trunc&lt;/code&gt; is conceptually similar to the &lt;code&gt;trunc&lt;/code&gt; function for numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246b10543803d9782a161a47909e8e612b910177" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format&lt;/code&gt; produces output formatted according to a format string, in a style similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f972d6e5c3f5f9e5c41c594a5f0d51dc8e13164" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hstore_to_json&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;. Likewise, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e40c0481379cfb3fb5e6423f9267d79ee88e237" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_export_snapshot&lt;/code&gt; saves the current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it. A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7c2a78ba8dec8a097ba6554379141ee778a83d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082064f30064e38cacd08cc4cf5d96bae8c8c23d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;populate_record&lt;/code&gt; is actually declared with &lt;code&gt;anyelement&lt;/code&gt;, not &lt;code&gt;record&lt;/code&gt;, as its first argument, but it will reject non-record types with a run-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472db68032e87a9f5dc2308d607eed94d8936c47" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0af8636b241010eb58f1e64ca4ece0dacf61bc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;setweight&lt;/code&gt; can be used to label the entries of a &lt;code&gt;tsvector&lt;/code&gt; with a given &lt;em&gt;weight&lt;/em&gt;, where a weight is one of the letters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. This is typically used to mark entries coming from different parts of a document, such as title versus body. Later, this information can be used for ranking of search results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cca378c8ae0fc168761a1769d0060a92e5808a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; is equivalent to the SQL-conforming construct &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2461207b12b5b4e196270e7b51786ac6ccae21" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_debug&lt;/code&gt; allows easy testing of a text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af9ae29d7989fa85e4ac3a29989c54729ceea6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_stat&lt;/code&gt; is useful for checking your configuration and for finding stop-word candidates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e394c193235d538ba957624ee9cbb6815d37e36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1fc89a699325691e39d0dd59e92400a699e36a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebaef272546a7798627e85265fe680ca3031d61e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlconcat&lt;/code&gt; concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef22fdb70040aafe9245779771954e498b2f3f6a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlexists&lt;/code&gt; evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837a957d18da91847b5357c6c3108da0982c435c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;code&gt;xpath&lt;/code&gt; (a &lt;code&gt;text&lt;/code&gt; value) against the XML value &lt;code&gt;xml&lt;/code&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49641632c456630ce0fe9561c2cd9fece93afa1f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath_exists&lt;/code&gt; is a specialized form of the &lt;code&gt;xpath&lt;/code&gt; function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the &lt;code&gt;XMLEXISTS&lt;/code&gt; predicate, except that it also offers support for a namespace mapping argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c574a36f3d0b3b9d8fd4793fb7a1aefa7712dc3" translate="yes" xml:space="preserve">
          <source>The function has no side effects. No information about the arguments is conveyed except via the return value. Any function that might throw an error depending on the values of its arguments is not leak-proof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27ab2a24cc42745c4233c190a0fd395e1a3a156" translate="yes" xml:space="preserve">
          <source>The function has to be used in a &lt;code&gt;FROM&lt;/code&gt; expression, with an &lt;code&gt;AS&lt;/code&gt; clause to specify the output columns; for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bc1caecad2cc53ec1c4c77402a0b8f9335155f" translate="yes" xml:space="preserve">
          <source>The function must have the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d3b3a8b1ce80dcb6ec1f9fb5fa0bcff0d4df0d" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;true&lt;/code&gt; if the leaf tuple matches the query, or &lt;code&gt;false&lt;/code&gt; if not. In the &lt;code&gt;true&lt;/code&gt; case, if &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then &lt;code&gt;leafValue&lt;/code&gt; must be set to the value of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type originally supplied to be indexed for this leaf tuple. Also, &lt;code&gt;recheck&lt;/code&gt; may be set to &lt;code&gt;true&lt;/code&gt; if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array. Leave it NULL otherwise. If at least one of returned distances is not exact, set &lt;code&gt;recheckDistances&lt;/code&gt; to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb965af01f35df576ea93f5375cbc5d7cb5a800" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. All except the headline function are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3b58b43bc6834c37e08716eb6be535f35e900" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. The lexize function is required, but the init function is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e644e558fc444f59115fd62f759afc494438aeb" translate="yes" xml:space="preserve">
          <source>The function to be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c50baf8431e61e9cb02cb427556dde06fcb6c7" translate="yes" xml:space="preserve">
          <source>The function used to implement this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c214640ce9489d4916101b16e01715654ee3006" translate="yes" xml:space="preserve">
          <source>The function used to perform the cast. The function name can be schema-qualified. If it is not, the function will be looked up in the schema search path. The function's result data type must match the target type of the cast. Its arguments are discussed below. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4070b563f17e2132c89c11f1dad26e620d3d0a33" translate="yes" xml:space="preserve">
          <source>The function used to perform the conversion. The function name can be schema-qualified. If it is not, the function will be looked up in the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32829bac3c1c7822fdaafe64cfff6a892c8b38d6" translate="yes" xml:space="preserve">
          <source>The function will now execute with whatever search path is used by its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3887f28b4d8dd432ded2ac6b6e06e93d7b6fd604" translate="yes" xml:space="preserve">
          <source>The function's Boolean result value is significant only when &lt;code&gt;checkUnique&lt;/code&gt; is &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt;. In this case a true result means the new entry is known unique, whereas false means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant false result is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dfbee76245b05e9845e2733e79d53c030e40bb" translate="yes" xml:space="preserve">
          <source>The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the &amp;ldquo;function-like syntax&amp;rdquo; is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff17dc219c0bcfbebd29717a230a4a214e2cbc8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e36b0f324aa4e2e4f308d3f86f3d1cbe3d7e22" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;crypt()&lt;/code&gt; and &lt;code&gt;gen_salt()&lt;/code&gt; are specifically designed for hashing passwords. &lt;code&gt;crypt()&lt;/code&gt; does the hashing and &lt;code&gt;gen_salt()&lt;/code&gt; prepares algorithm parameters for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459538ee1cd160dead602c42a37b3db46574d899" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;json[b]_populate_record&lt;/code&gt;, &lt;code&gt;json[b]_populate_recordset&lt;/code&gt;, &lt;code&gt;json[b]_to_record&lt;/code&gt; and &lt;code&gt;json[b]_to_recordset&lt;/code&gt; operate on a JSON object, or array of objects, and extract the values associated with keys whose names match column names of the output row type. Object fields that do not correspond to any output column name are ignored, and output columns that do not match any object field will be filled with nulls. To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377b36f768957552b23e80bcd91c885aadb25355" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inc&lt;/code&gt; and &lt;code&gt;upper_inc&lt;/code&gt; test the inclusivity of the lower and upper bounds of a range value, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b6f07f168f9bab47cb0d63914798ab55512000" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inf&lt;/code&gt; and &lt;code&gt;upper_inf&lt;/code&gt; test for infinite lower and upper bounds of a range, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f703d74ff7244a4147930578a835fc919fa68d3e" translate="yes" xml:space="preserve">
          <source>The functions above that operate on tables or indexes accept a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the table or index in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the table name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e923506f65e63b3dddbd22a7fb5e1606f3b604" translate="yes" xml:space="preserve">
          <source>The functions and function-like expressions described in this section operate on values of type &lt;code&gt;xml&lt;/code&gt;. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for information about the &lt;code&gt;xml&lt;/code&gt; type. The function-like expressions &lt;code&gt;xmlparse&lt;/code&gt; and &lt;code&gt;xmlserialize&lt;/code&gt; for converting to and from type &lt;code&gt;xml&lt;/code&gt; are documented there, not in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccb73aae614647b2269d26a350b909a44513b27" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.26.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.26.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e464a1af28710d4a1fd7e811bd3d0475c5576752" translate="yes" xml:space="preserve">
          <source>The functions described in this section are used to control and monitor a PostgreSQL installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01945498ca90e6ae3cd1d1b921c28c9c72aead1f" translate="yes" xml:space="preserve">
          <source>The functions here implement the encryption part of the OpenPGP (RFC 4880) standard. Supported are both symmetric-key and public-key encryption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122b22a585b5cb5a2901cc7acf3393bb3b507311" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are helpful for development and debugging of new text search configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec00f1a0d952540e42b411ff256f01a844ba9a" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 259&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d976c2e21ce82fc5ee166341bd65f2f942d7585" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;intarray&lt;/code&gt; module are shown in &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;Table F.9&lt;/a&gt;, the operators in &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;Table F.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589cd253a59ec741e7593831b0243a0b8a47c194" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;pg_trgm&lt;/code&gt; module are shown in &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;Table F.24&lt;/a&gt;, the operators in &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;Table F.25&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afb7a5be90f1ea0d87d155bbd2bc796569625a1" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.26.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ef1c3ef042af3960555b6b81e0fa70ed4d457f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af557d79922e415d01771dc33cbf93a73edbe83c" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2948c9238f28bd4ff2bb40ce8791d0b13005bd" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.90&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d92b50819e3d60d5191300256c8390d3bc20d24" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt; calculate the disk space usage of database objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596d61caa752f0c6f6982e0c8634c7eacfed18b6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed unless the user is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c73f231d92075fb0c71fc7740bf5175d685468" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11868a349a93977f4f568672a07b5dec83a888d7" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.95&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba997e6585ffd2ebf0df203e2718f49b87e3ad76" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf9851935069d5da8579d648493492e0773919e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; provide information about the current status of the standby. These functions may be executed both during recovery and in normal running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ba5a0a32a32de29b727183748ebc1db30a8063" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slot is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b085ba2dc236f90217ee4b570443351039e1a" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.76&lt;/a&gt; provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled and only for transactions that were committed after it was enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfe1a4de569556a1d516d3985556b63d6f6146f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.77&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database. They provide most of the same information, from the same source, as &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;, although in a form better suited to SQL functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46311f3452a56adeb669710af158b1d331e3ba4e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt; extract comments previously stored with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command. A null value is returned if no comment could be found for the specified parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f306d4b7a9229188bb697a19658366a35ce8588" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9398f596a0390810b3e41d607c70ae410202516a" translate="yes" xml:space="preserve">
          <source>The functions verify various &lt;em&gt;invariants&lt;/em&gt; in the structure of the representation of particular relations. The correctness of the access method functions behind index scans and other important operations relies on these invariants always holding. For example, certain functions verify, among other things, that all B-Tree pages have items in &amp;ldquo;logical&amp;rdquo; order (e.g., for B-Tree indexes on &lt;code&gt;text&lt;/code&gt;, index tuples should be in collated lexical order). If that particular invariant somehow fails to hold, we can expect binary searches on the affected page to incorrectly guide index scans, resulting in wrong answers to SQL queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d68a3d97b1b4428fbfcb9d0333819c6fcb3c2b0" translate="yes" xml:space="preserve">
          <source>The fundamental type of an XQuery/XPath expression, the &lt;code&gt;sequence&lt;/code&gt;, which can contain XML nodes, atomic values, or both, does not exist in XPath 1.0. A 1.0 expression can only produce a node-set (containing zero or more XML nodes), or a single atomic value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01481c12012dd36b33a9e59e6d02e28615f69f45" translate="yes" xml:space="preserve">
          <source>The general form of a recursive &lt;code&gt;WITH&lt;/code&gt; query is always a &lt;em&gt;non-recursive term&lt;/em&gt;, then &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;UNION ALL&lt;/code&gt;), then a &lt;em&gt;recursive term&lt;/em&gt;, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eee7d4e38c500df724907fbea7403f66500c981" translate="yes" xml:space="preserve">
          <source>The general format of the &lt;code&gt;pg_hba.conf&lt;/code&gt; file is a set of records, one per line. Blank lines are ignored, as is any text after the &lt;code&gt;#&lt;/code&gt; comment character. Records cannot be continued across lines. A record is made up of a number of fields which are separated by spaces and/or tabs. Fields can contain white space if the field value is double-quoted. Quoting one of the keywords in a database, user, or address field (e.g., &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;replication&lt;/code&gt;) makes the word lose its special meaning, and just match a database, user, or host with that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed177efb04faf95279eeefdbca2d0ce9a32d2a9" translate="yes" xml:space="preserve">
          <source>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5e9d694a644360b18b209b2a60b5fe2f2901b9" translate="yes" xml:space="preserve">
          <source>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or &lt;code&gt;simple&lt;/code&gt;, which recognizes everything. For example, for an astronomy-specific search (&lt;code&gt;astro_en&lt;/code&gt; configuration) one could bind token type &lt;code&gt;asciiword&lt;/code&gt; (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f82a175fcf092449c33c188da71a078b0c24826" translate="yes" xml:space="preserve">
          <source>The generated array type's name is the scalar type's name with an underscore prepended. The array entry's other fields are filled from &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; annotations in &lt;code&gt;pg_type.h&lt;/code&gt;, or if there isn't one, copied from the scalar type. (There's also a special case for &lt;code&gt;typalign&lt;/code&gt;.) Then the &lt;code&gt;typelem&lt;/code&gt; and &lt;code&gt;typarray&lt;/code&gt; fields of the two entries are set to cross-reference each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb30312d4c2f46733a2c8327c7814b6e7e52a77" translate="yes" xml:space="preserve">
          <source>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; is set. Execution of each query is subject to &lt;code&gt;ECHO&lt;/code&gt; processing. (Setting &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;queries&lt;/code&gt; is often advisable when using &lt;code&gt;\gexec&lt;/code&gt;.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9932b57cc46c7c3eb3f68c8f986add5fa46c3a0" translate="yes" xml:space="preserve">
          <source>The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491279f444aecfec04612928c73be9653a1967ca" translate="yes" xml:space="preserve">
          <source>The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107e72819959dbe843c78d42ff3ca5cede1b2e0f" translate="yes" xml:space="preserve">
          <source>The generic WAL redo function will acquire exclusive locks to buffers in the same order as they were registered. After redoing all changes, the locks will be released in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aaa212b0dcfe65dc390eb2bddcbdc50aeac8ad" translate="yes" xml:space="preserve">
          <source>The genetic algorithm (GA) is a heuristic optimization method which operates through randomized search. The set of possible solutions for the optimization problem is considered as a &lt;em&gt;population&lt;/em&gt; of &lt;em&gt;individuals&lt;/em&gt;. The degree of adaptation of an individual to its environment is specified by its &lt;em&gt;fitness&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee74388f5d56affe1f244671fe03aad5cc5e12c" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4cf5614687e283544003825f41ef8216ea5370" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e8935cc591dee18b7ed24a47a78f49e5afb1a3" translate="yes" xml:space="preserve">
          <source>The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443b3b682ab171a2c355d696fdc2acc186cfef4d" translate="yes" xml:space="preserve">
          <source>The given password is hashed using a String2Key (S2K) algorithm. This is rather similar to &lt;code&gt;crypt()&lt;/code&gt; algorithms &amp;mdash; purposefully slow and with random salt &amp;mdash; but it produces a full-length binary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b9a6b33b61484344b41d8768ea944df1857641" translate="yes" xml:space="preserve">
          <source>The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e01e0ce077bd1d9c99c3825e5edad48a491fa26" translate="yes" xml:space="preserve">
          <source>The horizontal header, displayed as the first row, contains the values found in column &lt;code&gt;colH&lt;/code&gt;, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional &lt;code&gt;sortcolH&lt;/code&gt; argument is given, it identifies a column whose values must be integer numbers, and the values from &lt;code&gt;colH&lt;/code&gt; will appear in the horizontal header sorted according to the corresponding &lt;code&gt;sortcolH&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323272ce1c2fce6128855defbc54368c470d5d34" translate="yes" xml:space="preserve">
          <source>The host name and port number of the primary, connection user name, and password are specified in the &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;. The password can also be set in the &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby (specify &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field). For example, if the primary is running on host IP &lt;code&gt;192.168.1.50&lt;/code&gt;, port &lt;code&gt;5432&lt;/code&gt;, the account name for replication is &lt;code&gt;foo&lt;/code&gt;, and the password is &lt;code&gt;foopass&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the standby:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cfca1d0872f04d37ad8cb9cbf3834cb90f01db" translate="yes" xml:space="preserve">
          <source>The host name of the database server, truncated at the first dot, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7649f0038242a26a0c621f7315d0b3f51c7304" translate="yes" xml:space="preserve">
          <source>The hour component of the time zone offset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ced8e552c81e4a5ec5eb0ba5039b71c87a5c484" translate="yes" xml:space="preserve">
          <source>The hour field (0 - 23)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842cd42d6043fc7261db6ee13e01b6e92f6c88ea" translate="yes" xml:space="preserve">
          <source>The i7-860 system measured runs the count query in 9.8 ms while the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; version takes 16.6 ms, each processing just over 100,000 rows. That 6.8 ms difference means the timing overhead per row is 68 ns, about twice what pg_test_timing estimated it would be. Even that relatively small amount of overhead is making the fully timed count statement take almost 70% longer. On more substantial queries, the timing overhead would be less problematic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf85920bba7cb75c10687cf6cd36aab7a7c9b2a" translate="yes" xml:space="preserve">
          <source>The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. PostgreSQL provides the utility program &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for this purpose. The basic usage of this command is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf4bd1d2fa41d408b71387e9f46d7734f70e2c4" translate="yes" xml:space="preserve">
          <source>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cef3c7a191b437000bac7046319a3652002a6f" translate="yes" xml:space="preserve">
          <source>The identifier of the prepared statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5814fec88046aa889ddca71e977eccd80834a133" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c52aeea0184eb0092fc19e054b01bbe20a261fc" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61965181bc017854598b0845bd8393cd487f7cfb" translate="yes" xml:space="preserve">
          <source>The implementation does not resist &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;side-channel attacks&lt;/a&gt;. For example, the time required for a &lt;code&gt;pgcrypto&lt;/code&gt; decryption function to complete varies among ciphertexts of a given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
