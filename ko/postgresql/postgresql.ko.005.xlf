<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">이 기능의 제한 사항은 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; 절의 결과에 적용 되는 &lt;code&gt;ORDER BY&lt;/code&gt; 절 은 표현식이 아니라 출력 열 이름 또는 숫자 만 지정할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 값 조합에 대한 NULL 플래그 목록입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">널이 아닌 요소 값의 목록은 열의 값 내에 가장 자주 나타납니다. 스칼라 유형의 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 및 업데이트 식 에 나타날 수있는 테이블 식 목록입니다 . 이것은 &lt;code&gt;SELECT&lt;/code&gt; 문의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; 에 지정할 수있는 테이블 목록과 유사 합니다. 자체 조인을 의도하지 않는 한 대상 테이블은 &lt;code&gt;from_list&lt;/code&gt; 에 나타나지 않아야합니다 (이 경우 &lt;code&gt;from_list&lt;/code&gt; 에 별명으로 표시되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 에 나타날 수있는 테이블 표현식 목록 . 이것은 지정할 수 있습니다 테이블 목록과 유사 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; (A)의 &lt;code&gt;SELECT&lt;/code&gt; 문; 예를 들어, 테이블 이름의 별명을 지정할 수 있습니다. 자체 조인을 설정하지 않으려면 &lt;code&gt;using_list&lt;/code&gt; 에서 대상 테이블을 반복하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 조합의 기본 주파수 목록, 즉 값당 주파수의 곱. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 조합의 빈도 목록, 즉 각 발생 횟수를 총 행 수로 나눈 값입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 요소 값의 빈도 목록, 즉 주어진 값의 하나 이상의 인스턴스를 포함하는 행의 비율. 요소 당 주파수는 2 개 또는 3 개의 추가 값입니다. 이들은 요소 별 주파수의 최소값과 최대 값이며 선택적으로 null 요소의 주파수입니다. &lt;code&gt;most_common_elems&lt;/code&gt; 가 null 인 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 값의 빈도 목록, 즉 각 발생 횟수를 총 행 수로 나눈 값입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">열에서 가장 일반적인 값 조합 목록입니다. (다른 조합보다 일반적인 조합이없는 경우 널입니다.)</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">열에서 가장 일반적인 값의 목록입니다. (다른 값보다 일반적인 값이없는 경우 널입니다.)</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">트리거가 발생해야하는 연관된 &lt;code&gt;filter_variable&lt;/code&gt; 의 값 목록입니다 . 들어 &lt;code&gt;TAG&lt;/code&gt; ,이 명령 태그 목록 (예를 들면 의미 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">열 값을 대략 동일한 모집단 그룹으로 나누는 값 목록입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 의 값이 있으면이 히스토그램 계산에서 생략됩니다. (열 데이터 유형에 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자가 없거나 &lt;code&gt;most_common_vals&lt;/code&gt; 목록이 전체 모집단을 설명하는 경우이 열은 널 입니다.)</target>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">현재 전자 메일 관리자 프로세스 ID (PID), 클러스터 데이터 디렉토리 경로, 전자 메일 관리자 시작 타임 스탬프, 포트 번호, 유닉스 도메인 소켓의 디렉토리 경로 (Windows에서 비어 있음), 첫 번째 유효한 listen_address (IP 주소 또는 기록 잠금 파일 &lt;code&gt;*&lt;/code&gt; , 또는 그렇지 않으면 비워을 TCP에서 수신 대기) 및 공유 메모리 세그먼트 ID (이 파일은 서버 종료 후 존재하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">논리적 복제 가입은 동기 복제를위한 대기가 될 수 있습니다 ( &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;26.2.8 절&lt;/a&gt; 참조 ). 대기 이름은 기본적으로 구독 이름입니다. 구독의 연결 정보에서 대체 이름을 &lt;code&gt;application_name&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">이 명령이 실행되는 트랜잭션이 커밋 될 때 새 구독에 대한 데이터를 복제하기 위해 논리적 복제 작업자가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">마스터 대기 복제 설정은 모든 데이터 수정 쿼리를 마스터 서버로 보냅니다. 마스터 서버는 비동기 적으로 데이터 변경 사항을 대기 서버로 보냅니다. 마스터 서버가 실행중인 동안 대기는 읽기 전용 조회에 응답 할 수 있습니다. 대기 서버는 데이터웨어 하우스 쿼리에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">다음과 같은 메시지 :</target>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">공유 하드웨어 기능의 수정 된 버전은 파일 시스템 복제이며, 파일 시스템의 모든 변경 사항은 다른 컴퓨터에있는 파일 시스템에 미러링됩니다. 유일한 제한은 대기 서버가 파일 시스템의 일관된 사본을 갖도록하는 방식으로 미러링을 수행해야한다는 것입니다. 특히 대기에 대한 쓰기는 마스터와 동일한 순서로 수행되어야합니다. DRBD는 널리 사용되는 Linux 용 파일 시스템 복제 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">대부분의 유럽 언어에 대한 직접 유용 더 완벽한 예는,에서 찾을 수 있습니다 &lt;code&gt;unaccent.rules&lt;/code&gt; 에 설치되어, &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 때 &lt;code&gt;unaccent&lt;/code&gt; 모듈이 설치됩니다. 이 규칙 파일은 악센트가있는 문자를 악센트가없는 동일한 문자로 변환하고 합자를 일련의 간단한 문자 (예 : &amp;AElig;에서 AE로)로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">보다 복잡한 예는 &lt;code&gt;title&lt;/code&gt; 또는 &lt;code&gt;body&lt;/code&gt; 에 &lt;code&gt;create&lt;/code&gt; 및 &lt;code&gt;table&lt;/code&gt; 이 포함 된 가장 최근 10 개의 문서를 선택하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">이러한 모든 조건을 만족하지 않는보다 복잡한보기는 기본적으로 읽기 전용입니다. 시스템은보기에서 삽입, 업데이트 또는 삭제를 허용하지 않습니다. 뷰에서 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거를 작성 하여 뷰에서 시도 된 삽입 등을 다른 테이블의 적절한 조치로 변환해야 업데이트 가능한 뷰의 효과를 얻을 수 있습니다 . 자세한 정보는 &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER를&lt;/a&gt; 참조하십시오 . 다른 가능성은 규칙을 작성하는 것 ( &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt; 참조 )이지만 실제로 트리거를 이해하고 올바르게 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">이름 에 다음 문자 중 하나 이상이 포함되어 있지 않으면 다중 문자 연산자 이름은 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">다중 열 B- 트리 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있지만 선행 (가장 왼쪽) 열에 제약 조건이있는 경우 인덱스가 가장 효율적입니다. 정확한 규칙은 선행 열에 대한 동등 제한 조건과 동등 제한 조건이없는 첫 번째 열에 대한 부등식 제한 조건이 스캔되는 인덱스의 일부를 제한하는 데 사용된다는 것입니다. 이 열의 오른쪽에있는 열에 대한 제약 조건이 인덱스에서 확인되므로 테이블 방문을 적절하게 저장하지만 스캔해야하는 인덱스 부분을 줄이지 않습니다. 예를 들어, 인덱스에 &lt;code&gt;(a, b, c)&lt;/code&gt; 및 쿼리 조건 &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; 을 지정하면 첫 번째 항목에서 &lt;code&gt;a&lt;/code&gt; 를 사용 하여 인덱스를 스캔해야합니다 .= 5와 &lt;code&gt;b&lt;/code&gt; 와 마지막 항목을 통해 = 42 최대 와 = 5. 인덱스 항목 &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77 생략 될 수 있지만,이 여전히 통해 스캔해야 할 것이다. 이 인덱스는 원칙에 제약이 쿼리에 사용될 수 &lt;code&gt;b&lt;/code&gt; 및 / 또는 &lt;code&gt;c&lt;/code&gt; 에 아무런 제약 조건 그래서 대부분의 경우 플래너는 인덱스를 사용을 통해 순차적 테이블 스캔을 선호하지만, 전체 인덱스 스캔되어야 할 것이다 - . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">다중 컬럼 BRIN 인덱스는 인덱스 열의 서브 세트를 포함하는 쿼리 조건과 함께 사용할 수 있습니다. GIN과 마찬가지로 B-tree 또는 GiST와 달리 인덱스 검색 효과는 쿼리 조건이 사용하는 인덱스 열에 관계없이 동일합니다. 단일 테이블에 하나의 다중 &lt;code&gt;pages_per_range&lt;/code&gt; 인덱스 대신 여러 BRIN 인덱스가있는 유일한 이유는 다른 pages_per_range 스토리지 매개 변수를 갖기 위해서 입니다.</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">다중 열 GIN 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있습니다. B- 트리 또는 GiST와 달리, 인덱스 검색 효과는 쿼리 조건이 사용하는 인덱스 열에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">다중 열 GiST 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있습니다. 추가 열의 조건은 인덱스에서 반환되는 항목을 제한하지만 첫 번째 열의 조건은 인덱스를 얼마나 많이 스캔해야하는지 결정하는 데 가장 중요합니다. 추가 열에 많은 고유 값이 있어도 첫 번째 열에 몇 개의 고유 값만있는 경우 GiST 인덱스는 상대적으로 효과적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">이름 에 다음 문자 중 하나 이상이 포함되어 있지 않으면 여러 문자 연산자 이름은 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">각 &lt;code&gt;WITH&lt;/code&gt; 조회 마다 이름 (스키마 규정이없는)을 지정해야합니다 . 선택적으로 열 이름 목록을 지정할 수 있습니다. 이것이 생략되면, 열 이름은 부속 조회에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">반환 된 열에 사용할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">명명 된 변수. 여러 JSON 처리 함수 의 매개 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 로 값을 설정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;표 9.47&lt;/a&gt; 및 해당 노트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">보안 정책에 유형 전환 규칙이라는 특수 규칙이있는 경우를 제외하고 새 데이터베이스 객체는 기본적으로 상위 객체의 보안 레이블을 상속합니다.이 경우 다른 레이블이 적용될 수 있습니다. 스키마의 경우 상위 개체는 현재 데이터베이스입니다. 테이블, 시퀀스, 뷰 및 함수의 경우 포함 스키마입니다. 열의 경우 포함 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">색인 항목을 작성하기 전에 새 힙 항목이 작성됩니다. (따라서 동시 인덱스 스캔은 힙 항목을 보지 못할 수 있습니다. 어쨌든 인덱스 리더가 커밋되지 않은 행에 관심이 없기 때문에 괜찮습니다. 그러나 &lt;a href=&quot;index-unique-checks&quot;&gt;섹션 61.5를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">새로운 임의 세션 키가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">새로운 임시 색인 정의가 &lt;code&gt;pg_index&lt;/code&gt; 카탈로그에 추가됩니다 . 이 정의는 이전 색인을 대체하는 데 사용됩니다. 세션 레벨 의 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금은 처리 중에 스키마 수정을 방지하기 위해 다시 색인화되는 색인 및 연관된 테이블에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 출력 열에 지정된 비 XML 결과 는 결과의 문자열 값이있는 단일 텍스트 노드 인 컨텐츠를 생성합니다. 다른 유형의 열에 지정된 XML 결과에는 둘 이상의 노드가 없거나 오류가 발생합니다. 정확히 하나의 노드가있는 경우 XPath 1.0 &lt;code&gt;string&lt;/code&gt; 함수에 정의 된대로 노드의 문자열 값 을 PostgreSQL 유형 에 할당하여 열이 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">비 독점 하위 수준 백업은 다른 동시 백업을 실행할 수있는 백업입니다 (동일한 백업 API를 사용하여 시작한 백업과 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup을&lt;/a&gt; 사용하여 시작된 백업 ).</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">별도로 만든 객체 간의 정상적인 관계입니다. 참조 된 개체에 영향을주지 않고 종속 개체를 삭제할 수 있습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 지정해야만 참조 된 오브젝트를 삭제할 수 있으며 ,이 경우 종속 오브젝트도 삭제됩니다. 예 : 테이블 열의 데이터 형식에 대한 일반적인 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">널이 아닌 제한 조건은 항상 열 제한 조건으로 작성됩니다. null이 아닌 제약 조건은 기능적으로 검사 제약 조건 &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; 를 만드는 것과 동일 하지만 PostgreSQL에서는 명시적인 null이 아닌 제약 조건을 만드는 것이 더 효율적입니다. 단점은 이런 식으로 생성 된 null이 아닌 제약 조건에 명시적인 이름을 지정할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">널이 아닌 제한 조건은 단순히 열이 널값을 가정해서는 안됨을 지정합니다. 구문 예 :</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">많은 프로브 또는 추적 점이 이미 소스 코드에 삽입되어 있습니다. 이 프로브는 데이터베이스 개발자 및 관리자가 사용하도록 설계되었습니다. 기본적으로 프로브는 PostgreSQL로 컴파일되지 않습니다. 사용자는 프로브를 사용 가능하게하려면 구성 스크립트에 명시 적으로 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;표 27.28에&lt;/a&gt; 표시된 것처럼 많은 표준 프로브가 소스 코드에 제공됩니다 . &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;표 27.29&lt;/a&gt; 는 프로브에 사용 된 유형을 보여줍니다. PostgreSQL의 관찰 성을 향상시키기 위해 더 많은 프로브를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">이러한 변수 중 다수는 psql에 의해 특별히 처리됩니다. 변수 값을 변경하여 런타임시 변경 될 수있는 특정 옵션 설정을 나타내거나 경우에 따라 psql의 변경 가능한 상태를 나타냅니다. 일반적으로 특수하게 처리 된 모든 변수 이름은 모든 대문자 ASCII 문자 (및 숫자와 밑줄)로 구성됩니다. 나중에 최대한의 호환성을 유지하려면 자신의 목적으로 이러한 변수 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">소수점이나 지수를 포함하지 않는 숫자 상수 는 값이 &lt;code&gt;integer&lt;/code&gt; 유형 (32 비트)에 맞는 경우 처음에는 &lt;code&gt;integer&lt;/code&gt; 유형으로 간주됩니다 . 그렇지 않으면 값이 &lt;code&gt;bigint&lt;/code&gt; 유형 (64 비트)에 맞는 경우 &lt;code&gt;bigint&lt;/code&gt; 유형으로 간주됩니다 . 그렇지 않으면 &lt;code&gt;numeric&lt;/code&gt; 유형으로 간주됩니다 . 소수점 및 / 또는 지수를 포함하는 상수는 항상 초기에 &lt;code&gt;numeric&lt;/code&gt; 유형 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">새 유형의 내부 표현 길이를 바이트 단위로 지정하는 숫자 상수입니다. 기본 가정은 가변 길이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 시작 하여 &lt;code&gt;y&lt;/code&gt; 에서 끝나 거나 그 반대로 끝나는 1 차원 간격 ; 순서는 중요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">1 차원 점 (또는 길이가 0 인 1 차원 간격)</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; 로 얻은 페이지 이미지 는 인수로 전달되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">자식이 남아있는 동안 부모 테이블을 삭제할 수 없습니다. 하위 테이블의 컬럼 또는 점검 제한 조건이 상위 테이블에서 상속 된 경우 삭제되거나 변경 될 수 없습니다. 테이블과 모든 하위 항목을 제거하려면 &lt;code&gt;CASCADE&lt;/code&gt; 옵션을 사용하여 상위 테이블을 삭제하는 것이 가장 쉬운 방법입니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">이 외부 테이블과 연관 시키거나 연관 해제 할 상위 테이블.</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">이 테이블과 연관 시키거나 연관 해제 할 상위 테이블.</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">파티션은 파티션이 속한 파티션 된 테이블과 동일한 컬럼 이름 및 유형을 가져야합니다. 파티션 된 테이블의 컬럼 이름 또는 유형을 수정하면 모든 파티션에 자동으로 전파됩니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 모든 파티션에 의해 자동으로 상속되지만 개별 파티션은 추가 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 지정할 수 있습니다 . 부모에서와 동일한 이름과 조건을 가진 추가 제한 조건은 부모 제한 조건과 병합됩니다. 각 파티션마다 기본값을 별도로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;FOR VALUES&lt;/code&gt; 를 사용 하는 파티션 은 &lt;code&gt;partition_bound_spec&lt;/code&gt; 에 대해 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일한 구문을 사용합니다 . 파티션 바인드 스펙은 대상 테이블의 파티션 전략 및 파티션 키와 일치해야합니다. 첨부 할 테이블은 목표 테이블과 동일한 열을 가져야하며 더 이상 열을 가져서는 안됩니다. 또한 열 유형도 일치해야합니다. 또한 목표 테이블의 모든 &lt;code&gt;NOT NULL&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건이 있어야합니다. 현재 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 제약 조건은 고려되지 않습니다. 부모 테이블의 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건이 아직없는 경우 파티션에 생성됩니다. &lt;code&gt;CHECK&lt;/code&gt; 중 하나라도첨부되는 테이블의 제한 조건이 &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시 되면 명령이 실패합니다. 이러한 제한 조건은 &lt;code&gt;NO INHERIT&lt;/code&gt; 절 없이 다시 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">파티션 된 테이블은 별도의 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령을 사용하여 작성되는 서브 테이블 (파티션이라고 함)로 나뉩니다 . 파티션 된 테이블 자체가 비어 있습니다. 테이블에 삽입 된 데이터 행은 파티션 키의 열 또는 표현식 값에 따라 파티션으로 라우팅됩니다. 기존 파티션이 새 행의 값과 일치하지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">클라이언트 인증 방법으로 데이터베이스에 연결할 때 사용자가 비밀번호를 제공해야하는 경우에만 비밀번호가 중요합니다. &lt;code&gt;password&lt;/code&gt; 와 &lt;code&gt;md5&lt;/code&gt; 인증 방법은 암호를 사용합니다. 데이터베이스 비밀번호는 운영 체제 비밀번호와 다릅니다. 역할을 작성할 때 &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; 으로 비밀번호를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">이러한 형식 중 하나를 따르지 않는 암호는 암호화되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">SQL / JSON 표준은 필터에서만 술어를 허용하지만 경로 표현식은 부울 술어 일 수 있습니다. &lt;code&gt;@@&lt;/code&gt; 연산자 를 구현하는 데 필요합니다 . 예를 들어, 다음 &lt;code&gt;jsonpath&lt;/code&gt; 표현식은 PostgreSQL에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">경로 표현식은 &lt;code&gt;jsonpath&lt;/code&gt; 데이터 유형에 의해 허용되는 일련의 요소로 구성됩니다 . 경로 식은 왼쪽에서 오른쪽으로 평가되지만 괄호를 사용하여 작업 순서를 변경할 수 있습니다. 평가에 성공하면 일련의 SQL / JSON 항목 ( &lt;em&gt;SQL / JSON sequence&lt;/em&gt; )이 생성되고 평가 결과가 지정된 계산을 완료하는 JSON 조회 함수로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">경로 식은 다음과 같은 일련의 경로 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; ) 을 포함하는 패턴 은 스키마 이름 패턴과 오브젝트 이름 패턴으로 해석됩니다. 예를 들어, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; 는 스키마 이름이 &lt;code&gt;foo&lt;/code&gt; 로 시작하는 스키마에 있는 테이블 이름에 &lt;code&gt;bar&lt;/code&gt; 가 포함 된 모든 테이블을 표시합니다 . 점이 나타나지 않으면 패턴은 현재 스키마 검색 경로에 보이는 객체 만 일치합니다. 다시 한 번 큰 따옴표 안에있는 점은 특별한 의미를 잃고 문자 그대로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">내부적으로 제로 볼륨 큐브로 표시되는 n 차원 공간의 점</target>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">정책은 관련 정책 표현식과 일치하는 행을 선택, 삽입, 업데이트 또는 삭제할 수있는 권한을 부여합니다. 기존 테이블 행은 &lt;code&gt;USING&lt;/code&gt; 에 지정된 표현식과 비교하여 검사 되는 반면, &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 를 통해 작성된 새 행 은 &lt;code&gt;WITH CHECK&lt;/code&gt; 에 지정된 표현식과 비교하여 점검 됩니다. 주어진 행에 대해 &lt;code&gt;USING&lt;/code&gt; 표현식이 true를 리턴 하면 해당 행이 사용자에게 표시되고 false 또는 null이 리턴되면 행이 표시되지 않습니다. &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식이 행에 대해 true를 리턴 하면 해당 행이 삽입되거나 갱신되는 반면 false 또는 null이 리턴되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">위치는 일반적으로 문서에서 소스 단어의 위치를 ​​나타냅니다. 위치 정보는 &lt;em&gt;근접성 순위에&lt;/em&gt; 사용될 수 있습니다 . 위치 값의 범위는 1-16383입니다. 더 큰 숫자는 자동으로 16383으로 설정됩니다. 동일한 넥서스에 대한 중복 위치는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">위치 매개 변수 참조는 SQL 문 외부에 제공되는 값을 표시하는 데 사용됩니다. 매개 변수는 SQL 함수 정의 및 준비된 쿼리에 사용됩니다. 일부 클라이언트 라이브러리는 또한 SQL 명령 문자열과 별도로 데이터 값 지정을 지원합니다.이 경우 매개 변수는 라인 외부 데이터 값을 참조하는 데 사용됩니다. 매개 변수 참조의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">함수 정의 본문 또는 준비된 명령문의 본문에있는 위치 매개 변수 참조</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; 단위로 함수의 예상 실행 비용을 제공하는 양수 입니다. 함수가 집합을 반환하면 반환 된 행당 비용입니다. 비용을 지정하지 않으면 C 언어 및 내부 기능에 대해 1 단위, 다른 모든 언어에서 기능에 대해서는 100 단위로 가정됩니다. 값이 클수록 플래너는 함수를 필요 이상으로 자주 평가하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">플래너가 함수가 리턴 할 것으로 예상해야하는 예상 행 수를 제공하는 양수. 함수가 집합을 반환하도록 선언 된 경우에만 허용됩니다. 기본 가정은 1000 행입니다.</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">이 인덱스를 사용하는 가능한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">준비된 명령문은 &lt;em&gt;일반 계획&lt;/em&gt; 또는 &lt;em&gt;사용자 정의 계획&lt;/em&gt; 으로 실행할 수 있습니다 . 일반 계획은 모든 실행에서 동일하지만 해당 호출에 지정된 매개 변수 값을 사용하여 특정 실행에 대해 사용자 정의 계획이 생성됩니다. 일반 계획을 사용하면 계획 오버 헤드가 발생하지 않지만 일부 상황에서는 계획자가 매개 변수 값에 대한 지식을 활용할 수 있으므로 사용자 정의 계획이 훨씬 효율적으로 실행됩니다. (물론, 준비된 명령문에 매개 변수가없는 경우 이는 무의미하며 일반 계획이 항상 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">기본 키 제약 조건은 열 또는 열 그룹이 테이블의 행에 대한 고유 식별자로 사용될 수 있음을 나타냅니다. 이를 위해서는 값이 고유하고 널이 아니어야합니다. 따라서 다음 두 테이블 정의는 동일한 데이터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">절차 언어 호출 핸들러는 &lt;code&gt;language_handler&lt;/code&gt; 를 리턴하도록 선언 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">게시는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">발행물은 &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; 명령을 사용하여 작성되며 나중에 해당 명령을 사용하여 변경하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">게시는 기본적으로 논리적 복제를 통해 데이터 변경 내용을 복제하려는 테이블 그룹입니다. 게시가 논리적 복제 설정에 어떻게 적용되는지에 대한 자세한 내용 &lt;a href=&quot;logical-replication-publication&quot;&gt;은 30.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">게시 된 테이블에는 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 작업 을 복제 할 수 있도록 &quot;복제본 ID&quot;가 구성되어 있어야 구독자 쪽에서 업데이트하거나 삭제할 적절한 행을 식별 할 수 있습니다. 기본 키는 기본 키입니다 (있는 경우). 또 다른 고유 인덱스 (특정 추가 요구 사항 포함)를 복제본 ID로 설정할 수도 있습니다. 테이블에 적합한 키가 없으면 ID를 &quot;full&quot;로 복제하도록 설정하면 전체 행이 키가됩니다. 그러나 이는 매우 비효율적이며 다른 솔루션이없는 경우에만 대체로 사용해야합니다. &quot;전체&quot;이외의 복제본 ID가 게시자 측에 설정된 경우 동일하거나 더 적은 수의 열을 포함하는 복제본 ID도 가입자 측에 설정해야합니다. 보다&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; &lt;/a&gt;복제본 ID를 설정하는 방법에 대한 자세한 내용은 REPLICA IDENTITY 를 참조하십시오. 복제본 ID가없는 테이블이 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업을복제하는 게시에 추가되면후속 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업으로 인해 게시자에서 오류가 발생합니다. &lt;code&gt;INSERT&lt;/code&gt; 작업은 복제본 ID에 관계없이 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">정량화 된 원자는 가능한 한 개의 &lt;em&gt;정량 자&lt;/em&gt; 뒤에 오는 &lt;em&gt;원자&lt;/em&gt; 입니다. 수량자가 없으면 원자와 일치합니다. 수량자를 사용하면 원자의 일부 일치와 일치 할 수 있습니다. &lt;em&gt;원자&lt;/em&gt; 에 도시 된 가능성 중 하나 일 수 &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;표 9.16&lt;/a&gt; . 가능한 수량 자와 그 의미는 &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;표 9.17&lt;/a&gt; 에 나와 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">고정 반복 수량 화기 ( &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 또는 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; )가있는 정량화 된 원자는 원자 자체와 동일한 탐욕을 가질 수 있습니다 (아마도 없음).</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">(포함하는 비 탐욕 정량으로 정량화 원자 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; 와 &lt;code&gt;m&lt;/code&gt; 은 동일한 &lt;code&gt;n&lt;/code&gt; ) (최단 매치를 선호하는) 비 탐욕이다.</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">(다른 정상 포함 한정사와 정량 원자 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 와 &lt;code&gt;m&lt;/code&gt; 은 동일한 &lt;code&gt;n&lt;/code&gt; ) (최장 매치를 선호) 욕심.</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">수량 자는 다른 수량자를 즉시 ​​따라갈 수 없습니다 (예 : &lt;code&gt;**&lt;/code&gt; 가 유효하지 않음) . 수량자는 표현식이나 하위 표현식을 시작할 수 없거나 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">삽입 될 행을 제공 하는 조회 ( &lt;code&gt;SELECT&lt;/code&gt; 문). 구문에 대한 설명은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">원하는 행을 지정 하는 &lt;code&gt;WHERE&lt;/code&gt; 절을 추가하여 쿼리를 &quot;규격화&quot;할 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 절은 부울 식을 반환 true 인 부울 (진리 값) 표현 만 행이 포함되어 있습니다. 규정에 일반적인 부울 연산자 ( &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; 및 &lt;code&gt;NOT&lt;/code&gt; )가 허용됩니다. 예를 들어 다음은 비오는 날 샌프란시스코의 날씨를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">읽기 전용 SQL 트랜잭션은 비 임시 테이블을 변경할 수 없습니다. 이 매개 변수는 각 새 트랜잭션의 기본 읽기 전용 상태를 제어합니다. 기본값은 &lt;code&gt;off&lt;/code&gt; (읽기 / 쓰기).</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">필드 개수 단어가 -1도 아니고 예상되는 열 수도 아닌 경우 오류를보고해야합니다. 이것은 어떻게 든 데이터와 동기화되지 않는지에 대한 추가 검사를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">레코드는 7 가지 형식 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; 작업은 하위 항목이 다른 상위 항목에서 해당 열을 상속하지 않고 해당 열에 대한 독립적 인 정의가없는 경우에만 하위 테이블의 열을 제거합니다. 비 재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; (즉, &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; )은 하위 열을 제거하지 않고 상속되지 않고 독립적으로 정의 된 것으로 표시합니다. 재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; 테이블의 모든 파티션은 파티션 루트와 같은 열이 있어야하기 때문에 명령은, 파티션 테이블에 대한 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">정규식은 문자열 집합 ( &lt;em&gt;일반 집합&lt;/em&gt; ) 의 약어 정의 인 문자 시퀀스입니다 . 문자열은 정규식으로 설명 된 정규 세트의 멤버 인 경우 정규식과 일치한다고합니다. &lt;code&gt;LIKE&lt;/code&gt; 와 마찬가지로 패턴 문자는 정규식 언어의 특수 문자가 아닌 한 문자열 문자와 정확히 일치하지만 정규식은 &lt;code&gt;LIKE&lt;/code&gt; 와 다른 특수 문자를 사용 합니다. &lt;code&gt;LIKE&lt;/code&gt; 패턴 과 달리 정규식이 문자열의 시작 또는 끝에 명시 적으로 고정되어 있지 않은 경우 정규식은 문자열 내 어디에서나 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">정규식은 하나 이상의 &lt;em&gt;분기&lt;/em&gt; 로 정의 되며 &lt;code&gt;|&lt;/code&gt; . 가지 중 하나와 일치하는 항목과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">스케일링, 변환, 회전 및 교차점 결정과 같은 다양한 형상 작업을 수행 할 수있는 다양한 기능과 연산자를 사용할 수 있습니다. 그것들은 &lt;a href=&quot;functions-geometry&quot;&gt;섹션 9.11&lt;/a&gt; 에서 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">역할은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 많은 런타임 구성 설정에 대한 역할 별 기본값을 가질 수도 있습니다 . 예를 들어, 어떤 이유로 든 연결할 때마다 인덱스 스캔을 비활성화하려면 (힌트 : 좋지 않은 아이디어) 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">클러스터의 데이터베이스에서 여전히 참조되는 역할은 제거 할 수 없습니다. 그렇다면 오류가 발생합니다. 역할을 삭제하기 전에 자신이 소유 한 모든 개체를 삭제 (또는 소유권을 다시 할당)하고 다른 개체에 역할이 부여한 권한을 취소해야합니다. &lt;a href=&quot;sql-reassign-owned&quot;&gt;재 할당 소유&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP 소유&lt;/a&gt; 명령은이 목적을 위해 유용 할 수있다; 자세한 내용 &lt;a href=&quot;role-removal&quot;&gt;은 21.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">데이터베이스를 생성 할 수있는 권한을 명시 적으로 부여해야합니다 (슈퍼 유저는 모든 권한 검사를 무시하므로). 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">역할에는 더 많은 역할을 생성 할 수있는 권한이 명시 적으로 부여되어야합니다 (수퍼 유저는 모든 권한 검사를 무시하므로 제외). 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; . &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 있는 역할은 다른 역할도 변경 및 삭제하고 구성원 자격을 부여하거나 취소 할 수 있습니다. 그러나 수퍼 유저 역할의 멤버 자격을 생성, 변경, 삭제 또는 변경하려면 수퍼 유저 상태가 필요합니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">스트리밍 복제를 시작할 수있는 권한이 명시 적으로 부여되어야합니다 (슈퍼 유저는 모든 권한 검사를 무시하므로). 스트리밍 복제에 사용되는 역할에는 &lt;code&gt;LOGIN&lt;/code&gt; 권한도 있어야합니다 . 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">&lt;code&gt;ALTER ROLE&lt;/code&gt; 로 생성 한 후 역할 속성을 수정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 및 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 명령에 대한 참조 페이지를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">행 생성자</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">행 생성자는 &lt;code&gt;.*&lt;/code&gt; 구문이 &lt;code&gt;SELECT&lt;/code&gt; 목록 의 최상위 레벨에서 사용될 때 발생하는 것과 같이 행 값의 요소 목록으로 확장되는 &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 구문을 포함 할 수 있습니다 ( &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;8.16.5 절&lt;/a&gt; 참조). ). 예를 들어, 테이블 &lt;code&gt;t&lt;/code&gt; 에 열 &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 가 있으면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">행 생성자는 멤버 필드의 값을 사용하여 행 값 (복합 값이라고도 함)을 작성하는 표현식입니다. 행 생성자는 키워드 &lt;code&gt;ROW&lt;/code&gt; , 왼쪽 괄호, 행 필드 값에 대한 0 개 이상의 표현식 (쉼표로 구분) 및 마지막으로 오른쪽 괄호로 구성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">규칙은 트리거보다 상당히 많은 오버 헤드를 갖지만 오버 헤드는 행당 한 번이 아니라 쿼리 당 한 번 지불되므로이 방법은 대량 삽입 상황에 유리할 수 있습니다. 그러나 대부분의 경우 트리거 방법이 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">데이터 디렉토리 아래의 &lt;code&gt;pg_multixact/members&lt;/code&gt; 디렉토리에서 숫자가 가장 큰 파일 이름을 찾아서 하나를 추가 한 다음 52352 (0xCC80)를 곱하여 안전한 값을 판별 할 수 있습니다 . 파일 이름은 16 진수입니다. 0을 추가하는 다른 옵션과 같은 간단한 레시피는 없습니다.</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">데이터 디렉토리 아래의 &lt;code&gt;pg_xact&lt;/code&gt; 디렉토리에서 가장 큰 파일 이름을 찾아서 하나를 추가 한 다음 1048576 (0x100000)을 곱하여 안전한 값을 판별 할 수 있습니다 . 파일 이름은 16 진수입니다. 일반적으로 옵션 값을 16 진수로 지정하는 것이 가장 쉽습니다. 예를 들어, &lt;code&gt;0011&lt;/code&gt; 에서 가장 큰 엔트리이다 &lt;code&gt;pg_xact&lt;/code&gt; , &lt;code&gt;-x 0x1200000&lt;/code&gt; (다섯 후미 제로 적절한 배율을 제공하는 것) 일 것이다.</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">다음 멀티 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; ID (첫 번째 파트)의 안전한 값 은 데이터 디렉토리 아래의 pg_multixact / offsets 디렉토리에서 숫자가 가장 큰 파일 이름을 찾고 하나를 추가 한 후 65536 (0x10000)을 곱하여 판별 할 수 있습니다 . 반대로, 가장 오래된 다중 트랜잭션 ID ( &lt;code&gt;-m&lt;/code&gt; 의 두 번째 부분)의 안전한 값 은 같은 디렉토리에서 가장 작은 파일 이름을 찾고 65536을 곱하여 판별 할 수 있습니다. 파일 이름은 16 진법이므로 가장 쉬운 방법입니다. 옵션 값을 16 진수로 지정하고 4 개의 0을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">커밋 시간을 검색 할 수있는 가장 오래된 트랜잭션 ID의 안전한 값 (첫 번째 부분)은 데이터 디렉토리 아래의 &lt;code&gt;pg_commit_ts&lt;/code&gt; 디렉토리에서 가장 작은 파일 이름을 찾아서 확인할 수 있습니다 . 반대로, 커밋 시간을 검색 할 수있는 최신 트랜잭션 ID의 안전한 값 (두 번째 부분)은 동일한 디렉토리에서 가장 큰 파일 이름을 찾아서 결정할 수 있습니다. 파일 이름은 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">저장 점은 트랜잭션 내부에있는 특수 표시로, 설정된 후 실행 된 모든 명령을 롤백하여 트랜잭션 상태를 저장 점 당시의 상태로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">스칼라 하위 쿼리</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">스칼라 하위 쿼리는 괄호로 묶인 일반적인 &lt;code&gt;SELECT&lt;/code&gt; 쿼리로 한 열로 정확히 하나의 행을 반환합니다. 쿼리 작성에 대한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장을&lt;/a&gt; 참조하십시오 . &lt;code&gt;SELECT&lt;/code&gt; 쿼리가 실행되고 단일 반환 값이 주변 값 식에 사용됩니다. 스칼라 서브 쿼리로 둘 이상의 행 또는 둘 이상의 열을 리턴하는 쿼리를 사용하는 것은 오류입니다. 그러나 특정 실행 중에 하위 쿼리가 행을 반환하지 않으면 오류가 없습니다. 스칼라 결과는 null로 간주됩니다. 하위 쿼리 서브 쿼리와 관련된 다른 표현에 대해서는 &lt;a href=&quot;functions-subquery&quot;&gt;9.22 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">스캔 키는 &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 형식 의 &lt;code&gt;WHERE&lt;/code&gt; 절을 내부적으로 표현한 것으로 , 인덱스 키는 인덱스의 열 중 하나이고 연산자는 해당 인덱스 열과 연관된 연산자 패밀리의 멤버 중 하나입니다. 인덱스 스캔에는 0 개 이상의 스캔 키가 있으며 암시 적으로 AND됩니다. 리턴 된 튜플은 표시된 모든 조건을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">스키마는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다. 소유자는 스키마 내에서 일부 오브젝트를 소유하지 않아도 스키마 (및 포함 된 모든 오브젝트)를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">스키마는 본질적으로 네임 스페이스입니다. 여기에는 이름이 다른 스키마에 존재하는 다른 개체의 이름과 중복 될 수있는 명명 된 개체 (테이블, 데이터 형식, 함수 및 연산자)가 포함됩니다. 명명 된 개체는 스키마 이름을 접두사로 사용하여 이름을 &quot;자격&quot;하거나 원하는 스키마를 포함하는 검색 경로를 설정하여 액세스 할 수 있습니다. &lt;code&gt;CREATE&lt;/code&gt; 규정되지 않은 오브젝트 이름을 지정하는 명령은 현재 스키마의 객체 (함수로 측정 할 수있는 탐색 경로의 앞에 하나 생성 &lt;code&gt;current_schema&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">스크립트 파일에는 세미콜론으로 끝나는 하나 이상의 SQL 명령이 포함됩니다. 빈 줄과 &lt;code&gt;--&lt;/code&gt; 으로 시작하는 줄 은 무시됩니다. 스크립트 파일은 또한 &quot;메타 명령&quot;을 포함 할 수 있으며, 이는 아래 설명 된대로 pgbench 자체에서 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 클러스터 초기화 중에 두 번째 데이터베이스 인 &lt;code&gt;template1&lt;/code&gt; 도 작성됩니다. 클러스터 내에서 새 데이터베이스가 작성 될 때마다 &lt;code&gt;template1&lt;/code&gt; 이 본질적으로 복제됩니다. 즉, &lt;code&gt;template1&lt;/code&gt; 에서 변경 한 내용 은 이후에 생성 된 모든 데이터베이스에 전파됩니다. 이 때문에 &lt;code&gt;template1&lt;/code&gt; 에서 개체를 새로 생성 된 모든 데이터베이스에 전파하지 않으려면 개체를 만들지 마십시오 . 자세한 내용 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;은 22.3 절에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 의 템플릿 문자열에서 구분 기호 (공백 또는 문자가 아닌 문자 또는 숫자가 아닌 문자) 는 &lt;code&gt;FX&lt;/code&gt; 옵션을 사용 하지 않는 한 입력 문자열의 단일 구분자와 일치하거나 건너 뜁니다 . 예를 들어, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; 및 &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; 작동하지만 &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; 는 입력 문자열의 구분 기호 수가 템플릿의 구분 기호 수를 초과하기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">이 큰 테이블에 대한 순차적 스캔에는 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">순차 스캔에는 항상 관계 레벨 술어 잠금이 필요합니다. 이로 인해 직렬화 실패 비율이 증가 할 수 있습니다. 줄여 인덱스 스캔의 사용을 장려하기 위해 도움이 될 수 &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost을&lt;/a&gt; 및 / 또는 증가 &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost을&lt;/a&gt; . 쿼리 실행 시간의 전반적인 변경에 대비하여 트랜잭션 롤백 및 재시작의 감소를 측정하십시오.</target>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">상속 기능의 심각한 제한 사항은 인덱스 (고유 제약 조건 포함)와 외래 키 제약 조건이 상속 자식이 아닌 단일 테이블에만 적용된다는 것입니다. 외래 키 제약 조건의 참조 및 참조 측면 모두에 해당됩니다. 따라서 위 예제와 관련하여</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 파일을 관리하고 클라이언트 응용 프로그램에서 데이터베이스로의 연결을 승인하고 클라이언트 대신 데이터베이스 조치를 수행하는 서버 프로세스. 데이터베이스 서버 프로그램을 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; 명령 을 사용하여 지정된 알림 채널에 대해 세션을 등록 취소 할 수 있습니다 . 세션의 청취 등록은 세션이 종료되면 자동으로 지워집니다.</target>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">세션은 &lt;code&gt;temp_buffers&lt;/code&gt; 에 의해 제공된 한계까지 필요한만큼 임시 버퍼를 할당 합니다. 실제로 많은 임시 버퍼를 필요로하지 않는 세션에서 큰 값을 설정하는 비용은 &lt;code&gt;temp_buffers&lt;/code&gt; 단위로 버퍼 설명자 또는 약 64 바이트 입니다 . 그러나 실제로 버퍼가 사용되는 경우 추가 8192 바이트 (또는 일반적으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트) 가 추가로 소비됩니다 .</target>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQL 데이터에서 XML 컨텐츠를 생성하기 위해 함수 및 함수 유사 표현식 세트를 사용할 수 있습니다. 따라서 클라이언트 응용 프로그램에서 처리하기 위해 쿼리 결과를 XML 문서로 형식화하는 데 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">두 가지 공통 유형의 그룹화 세트를 지정하기위한 축약 표기법이 제공됩니다. 양식의 절</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">기본 포크에서 읽기위한 &lt;code&gt;get_raw_page&lt;/code&gt; 의 축약 버전입니다 . 상당 &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;SG&lt;/code&gt; , &lt;code&gt;PL&lt;/code&gt; 또는 &lt;code&gt;MI&lt;/code&gt; 를 사용하여 서식이 지정된 부호 는 숫자에 고정되지 않습니다. 예를 들어, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; 발생 &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; 이지만 &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; 생성 &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; . (Oracle 구현에서는 &lt;code&gt;9&lt;/code&gt; 이전 에 &lt;code&gt;MI&lt;/code&gt; 를 사용할 수 없지만 오히려 &lt;code&gt;9&lt;/code&gt; 보다 먼저 &lt;code&gt;MI&lt;/code&gt; 를 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">서명은 인덱싱 된 속성을 손실로 표현한 것으로 오 탐지를보고하기 쉽습니다. 즉, 요소가없는 경우 요소가 세트에 있다고보고 될 수 있습니다. 따라서 색인 검색 결과는 항상 힙 항목의 실제 속성 값을 사용하여 다시 확인해야합니다. 시그니처가 클수록 오 탐지 확률이 줄어들어 쓸모없는 힙 방문 횟수가 줄어들지 만 물론 인덱스가 더 커져서 스캔 속도가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">대부분의 픽션이 아닌 책에서도 비슷한 방법이 사용됩니다. 독자가 자주 찾는 용어와 개념은 책 끝에 알파벳 순서로 수집됩니다. 관심있는 독자는 관심있는 자료를 찾기 위해 전체 책을 읽을 필요없이 인덱스를 비교적 빠르게 스캔하고 적절한 페이지로 넘길 수 있습니다. 독자가 찾아보기 쉬운 항목을 예상하는 것은 저자의 작업 인 것처럼 데이터베이스 프로그래머가 어떤 인덱스가 유용 할지를 예측하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">아카이브 할 새 파일마다 유사한 명령이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 절에 의해 생성 될 그룹 수와 같이 여러 열 세트의 카디널리티를 추정 할 때도 비슷한 문제가 발생합니다 . 경우 &lt;code&gt;GROUP BY&lt;/code&gt; 는 단일 열로 나열합니다 (HashAggregate 노드에 의해 반환 된 행의 추정값으로서 표시됨)의 n 구별 추정이 매우 정확하다 :</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">조인으로 비슷한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">&lt;code&gt;jdoc&lt;/code&gt; 열의 간단한 GIN 인덱스 가이 쿼리를 지원할 수 있습니다. 그러나 이러한 색인은 모든 키와 값의 사본을 &lt;code&gt;jdoc&lt;/code&gt; 열에 저장하지만 이전 예제의 표현식 색인은 &lt;code&gt;tags&lt;/code&gt; 키 에서 찾은 데이터 만 저장합니다 . 단순 인덱스 방식은 키에 대한 쿼리를 지원하기 때문에 훨씬 유연하지만 대상 표현식 인덱스는 단순 인덱스보다 작고 검색 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">간단한 집계 함수는 하나 또는 두 개의 일반 함수, 상태 전이 함수 &lt;code&gt;sfunc&lt;/code&gt; 및 선택적 최종 계산 함수 &lt;code&gt;ffunc&lt;/code&gt; 로 만들어집니다 . 이들은 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">간단한 구성 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">이러한 규칙의 간단한 예는</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">간단한 쿼리 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">단일 인덱스 스캔은 인덱스의 열을 연산자 클래스의 연산자와 함께 사용하고 &lt;code&gt;AND&lt;/code&gt; 와 결합 된 쿼리 절만 사용할 수 있습니다 . 예를 들어, &lt;code&gt;(a, b)&lt;/code&gt; 에 대한 색인에서 &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; 같은 조회 조건 은 색인을 사용할 수 있지만 &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; 과 같은 조회 는 색인을 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">단일 연산자가 &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;표 F.6&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">정렬 연산자 자세한 내용은 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">때때로 유용한 특별한 경우는 &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; 을 사용하여 두 단어가 동일한 단어와 일치하도록 요구할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">수신자와 송신자 모두로 작동하는 대기를 계단식 대기라고합니다. 마스터에 더 직접 연결된 대기를 업스트림 서버라고하며, 대기 서버는 더 멀리 다운 스트림 서버입니다. 계단식 복제는 다운 스트림 서버의 수나 배열에 제한을 두지 않지만 각 대기는 하나의 업스트림 서버에만 연결되어 결국 단일 마스터 / 기본 서버에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">대기 서버는 파일 기반 로그 전달 ( &lt;a href=&quot;warm-standby&quot;&gt;섹션 26.2&lt;/a&gt; ) 또는 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;섹션 26.2.5&lt;/a&gt; 참조 ) 또는이 둘의 조합을 사용하여 구현할 수 있습니다 . 핫 스탠바이에 대한 내용은 &lt;a href=&quot;hot-standby&quot;&gt;섹션 26.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">명령문은 시작하기 전에 커밋 된 행만 볼 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">이 통계 개체에서 계산할 통계 종류입니다. 현재 지원되는 종류가 &lt;code&gt;ndistinct&lt;/code&gt; ndistinct 통계를 가능하게하는, &lt;code&gt;dependencies&lt;/code&gt; 함수 종속성 통계를 가능하게하는, 및 &lt;code&gt;mcv&lt;/code&gt; 가장 일반적인 값 목록을 할 수 있습니다. 이 절을 생략하면 지원되는 모든 통계 종류가 통계 개체에 포함됩니다. 자세한 정보는 &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;섹션 14.2.2&lt;/a&gt; 및 &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;섹션 70.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">존재하지 않는 요소에 할당하여 저장된 배열 값을 확대 할 수 있습니다. 이전에 존재했던 요소와 새로 할당 된 요소 사이의 위치는 널로 채워집니다. 예를 들어, 배열 &lt;code&gt;myarray&lt;/code&gt; 에 현재 4 개의 요소가있는 경우 업데이트 후 &lt;code&gt;myarray[6]&lt;/code&gt; 할당 된 6 개의 요소가 있습니다 . &lt;code&gt;myarray[5]&lt;/code&gt; 는 null을 포함합니다. 현재이 방식으로 확대하는 것은 다차원 배열이 아닌 1 차원 배열에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">함수를 정의하는 문자열 상수. 그 의미는 언어에 따라 다릅니다. 내부 함수 이름, 오브젝트 파일의 경로, SQL 명령 또는 절차 언어의 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">프로 시저를 정의하는 문자열 상수. 그 의미는 언어에 따라 다릅니다. 내부 프로 시저 이름, 오브젝트 파일의 경로, SQL 명령 또는 절차 언어의 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">SQL의 문자열 상수는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )로 묶인 임의의 문자 시퀀스입니다 ( 예 : &lt;code&gt;'This is a string'&lt;/code&gt; . 문자열 상수 내에 작은 따옴표 문자를 포함 시키려면 두 개의 인접한 작은 따옴표 (예 : &lt;code&gt;'Dianne''s horse'&lt;/code&gt; 쓰십시오 . 이것은 큰 따옴표 문자 ( &lt;code&gt;&quot;&lt;/code&gt; ) 와 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">열거 형 유형의 하나의 값과 연관된 텍스트 레이블을 나타내는 문자열 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">&lt;code&gt;n$&lt;/code&gt; 형식의 문자열. 여기서 &lt;code&gt;n&lt;/code&gt; 은 인쇄 할 인수의 인덱스입니다. 인덱스 1은 &lt;code&gt;formatstr&lt;/code&gt; 다음의 첫 번째 인수를 의미합니다 . 상기 중간 &lt;code&gt;position&lt;/code&gt; 생략, 기본은 순서대로 다음 인수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">문자열 형식의 구문은 문자열 형식 작업 및 복잡한 확장 형식 작업에 사용됩니다. 지정되지 않은 유형의 문자열은 가능한 연산자 후보와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 에 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 나타날 수 있습니다 . 이는 단일 &lt;code&gt;SELECT&lt;/code&gt; 명령 동안 출력이 임시 테이블로 작성된 것처럼 작동합니다 . 하위 &lt;code&gt;SELECT&lt;/code&gt; 는 괄호로 묶어야하며 별명 &lt;em&gt;을&lt;/em&gt; 제공 &lt;em&gt;해야&lt;/em&gt; 합니다. &lt;a href=&quot;sql-values&quot;&gt;VALUES의&lt;/a&gt; 명령은 여기에도 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">하위 쿼리는 &lt;code&gt;VALUES&lt;/code&gt; 목록 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">원하는 경우 가입자 노드는 다수의 가입을 가질 수있다. 단일 게시자-가입자 쌍간에 여러 구독을 정의 할 수 있습니다.이 경우 구독 한 게시 개체가 겹치지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">첨 자식</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">수퍼 유저 만 구독을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 의 대체 이름입니다 . 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 이것은 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가 &lt;code&gt;excluded&lt;/code&gt; 라는 테이블을 대상으로 할 때 특히 유용합니다. 그렇지 않으면 삽입을 위해 제안 된 행을 나타내는 특수 테이블의 이름으로 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">별명을 포함하는 &lt;code&gt;FROM&lt;/code&gt; 항목 의 대체 이름입니다 . 별명은 간결성을 위해 또는 동일한 테이블이 여러 번 스캔되는 자체 조인의 모호성을 제거하는 데 사용됩니다. 별명을 제공하면 테이블 또는 함수의 실제 이름이 완전히 숨겨집니다. 예를 들어 , &lt;code&gt;FROM foo AS f&lt;/code&gt; 가 주어지면 &lt;code&gt;SELECT&lt;/code&gt; 의 나머지 부분은 이 &lt;code&gt;FROM&lt;/code&gt; 항목을 &lt;code&gt;foo&lt;/code&gt; 가 아닌 &lt;code&gt;f&lt;/code&gt; 로 참조해야합니다 . 별명이 작성되면 열 별명리스트를 작성하여 테이블의 하나 이상의 열에 대한 대체 이름을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">대상 테이블의 대체 이름입니다. 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 예를 들어, &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; 가 주어지면 나머지 &lt;code&gt;DELETE&lt;/code&gt; 문은이 테이블을 &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt; 로 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">대상 테이블의 대체 이름입니다. 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 예를 들어, &lt;code&gt;UPDATE foo AS f&lt;/code&gt; 가 주어지면 나머지 &lt;code&gt;UPDATE&lt;/code&gt; 문은이 테이블을 &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt; 로 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">성공적인 실행은 상태 0으로 종료됩니다. 종료 상태 1은 유효하지 않은 명령 행 옵션과 같은 정적 문제를 나타냅니다. 데이터베이스 오류나 스크립트 문제와 같은 실행 중 오류가 발생하면 종료 상태 2가됩니다. 후자의 경우 pgbench는 부분 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">논리적 디코딩을 통해 변경 사항을 수신하는 동기 복제본은 단일 데이터베이스 범위에서 작동합니다. 이와는 대조적으로, &lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; 는&lt;/em&gt; 현재 서버 범위이므로 둘 이상의 데이터베이스가 활발하게 사용되는 경우이 기술이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">동기 대기는 물리적 복제 대기 또는 논리적 복제 구독자 일 수 있습니다. 적절한 피드백 메시지를 보내는 방법을 알고있는 다른 물리적 또는 논리적 WAL 복제 스트림 소비자 일 수도 있습니다. 내장 된 물리적 및 논리적 복제 시스템 외에도 &lt;code&gt;pg_receivewal&lt;/code&gt; 및 &lt;code&gt;pg_recvlogical&lt;/code&gt; 과 같은 특수 프로그램과 일부 타사 복제 시스템 및 사용자 정의 프로그램이 포함됩니다. 동기식 복제 지원에 대한 자세한 내용은 해당 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 승인 하고 의사 유형 &lt;code&gt;table_am_handler&lt;/code&gt; 를 리턴하려면 테이블 액세스 메소드 핸들러 함수를 선언해야합니다 . 인수는 단순히 핸들러 함수가 SQL 명령에서 직접 호출되지 않도록하는 더미 값입니다. 함수의 결과는 &lt;code&gt;TableAmRoutine&lt;/code&gt; 유형의 구조체에 대한 포인터 여야하며 , 여기에는 코어 코드가 테이블 액세스 방법을 사용하기 위해 알아야하는 모든 것이 포함됩니다. 반환 값은 일반적으로 전역 범위에서 &lt;code&gt;static const&lt;/code&gt; 변수 로 정의하여 서버 수명이어야합니다 . &lt;code&gt;TableAmRoutine&lt;/code&gt; 의 구조체, 또한 액세스 메소드의 호출 &lt;em&gt;API 구조체&lt;/em&gt;콜백을 사용하여 액세스 방법의 동작을 정의합니다. 이 콜백은 일반 C 함수에 대한 포인터이며 SQL 수준에서는 표시되거나 호출 할 수 없습니다. 모든 콜백과 그 동작은 &lt;code&gt;TableAmRoutine&lt;/code&gt; 구조에 정의되어 있습니다 (콜백 요구 사항을 정의하는 구조체 안에 주석 포함). 대부분의 콜백에는 랩퍼 함수가 있으며 이는 테이블 액세스 방법의 사용자가 아닌 구현 자의 관점에서 문서화됩니다. 자세한 내용은 &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt; 파일을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">테이블에는 최대 하나의 기본 키가있을 수 있습니다. (기능적으로 거의 동일한 고유하지만 널이 아닌 제한 조건이 많을 수 있지만, 기본 키로 하나만 식별 될 수 있습니다.) 관계형 데이터베이스 이론에 따르면 모든 테이블에 기본 키가 있어야합니다. 이 규칙은 PostgreSQL에 의해 적용되지 않지만 일반적으로 따르는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">테이블에는 둘 이상의 외래 키 제약 조건이있을 수 있습니다. 테이블 간 다 대다 관계를 구현하는 데 사용됩니다. 제품 및 주문에 대한 테이블이 있지만 이제는 하나의 주문에 많은 제품이 포함될 수 있습니다 (위의 구조에서는 허용되지 않음). 이 테이블 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">테이블은 둘 이상의 부모 테이블에서 상속 할 수 있으며,이 경우 부모 테이블에 의해 정의 된 열의 합집합이 있습니다. 자식 테이블 정의에 선언 된 모든 열이 여기에 추가됩니다. 동일한 열 이름이 여러 부모 테이블 또는 부모 테이블과 자식 정의 모두에 나타나는 경우 이러한 열은 &quot;병합&quot;되어 자식 테이블에 해당 열이 하나만있게됩니다. 병합하려면 열의 데이터 형식이 같아야합니다. 그렇지 않으면 오류가 발생합니다. 상속 가능한 검사 제한 조건과 널이 아닌 제한 조건이 유사한 방식으로 병합됩니다. 예를 들어, 병합 된 컬럼은 컬럼 정의 중 하나가 널이 아닌 것으로 표시되면 널이 아닌 것으로 표시됩니다. 이름이 동일한 검사 제한 조건이 병합되고 조건이 다른 경우 병합이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">테이블의 열은 1600 개를 초과 할 수 없습니다. 실제로는 유효 길이가 튜플 길이 제약 조건으로 인해 일반적으로 낮습니다.</target>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">관계형 데이터베이스의 테이블은 종이의 테이블과 매우 유사합니다. 행과 열로 구성됩니다. 열의 수와 순서는 고정되어 있으며 각 열에는 이름이 있습니다. 행 수는 가변적이며 주어진 순간에 저장되는 데이터 양을 반영합니다. SQL은 테이블의 행 순서를 보증하지 않습니다. 테이블을 읽을 때 정렬이 명시 적으로 요청되지 않으면 행이 지정되지 않은 순서로 나타납니다. 이에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장&lt;/a&gt; 에서 다룹니다 . 또한 SQL은 고유 식별자를 행에 할당하지 않으므로 테이블에 완전히 동일한 행이 여러 개있을 수 있습니다. 이는 SQL의 기초가되는 수학적 모델의 결과이지만 일반적으로 바람직하지 않습니다. 이 장의 뒷부분에서이 문제를 해결하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">테이블 참조는 테이블 이름 (아마도 스키마 한정)이거나 하위 쿼리, &lt;code&gt;JOIN&lt;/code&gt; 구문 또는 이들의 복잡한 조합 과 같은 파생 테이블 일 수 있습니다. &lt;code&gt;FROM&lt;/code&gt; 절 에 둘 이상의 테이블 참조가 나열 되면 테이블이 교차 결합됩니다 (즉, 행의 카티 전 곱이 형성됨 (아래 참조)). &lt;code&gt;FROM&lt;/code&gt; 목록 의 결과는 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절에 의해 변환 될 수있는 중간 가상 테이블 이며 최종적으로 전체 테이블 표현식의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">잠재적으로 큰 항목이있는 열이있는 테이블 에는 연관된 &lt;em&gt;TOAST&lt;/em&gt; 테이블이 있으며,이 테이블은 테이블 행에 적절하게 유지하기에는 너무 큰 필드 값의 라인 외부 저장에 사용됩니다. &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltoastrelid&lt;/code&gt; 는 테이블에서 TOAST 테이블 (있는 경우)로 링크합니다. 자세한 정보는 &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">테이블 샘플 메소드 핸들러는 &lt;code&gt;tsm_handler&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">테이블 공간을 통해 수퍼 유저는 파일 및 데이터베이스 개체 (예 : 테이블 및 인덱스)를 포함하는 데이터 파일이 상주 할 수있는 대체 위치를 파일 시스템에서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">테이블 스페이스는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다. 테이블 스페이스는 삭제하기 전에 모든 데이터베이스 오브젝트에서 비어 있어야합니다. 현재 데이터베이스의 오브젝트가 테이블 스페이스를 사용하고 있지 않더라도 다른 데이터베이스의 오브젝트가 여전히 테이블 스페이스에있을 수 있습니다. 또한 테이블 스페이스가 활성 세션 의 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; 설정에 나열되면 테이블 스페이스에있는 임시 파일로 인해 &lt;code&gt;DROP&lt;/code&gt; 이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">테이블 스페이스는 테이블 스페이스가 정의 된 클러스터와 독립적으로 사용될 수 없습니다. &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;섹션 22.6&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">설정하거나 재설정 할 테이블 스페이스 매개 변수입니다. 현재 사용 가능한 유일한 매개 변수는 &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; 및 &lt;code&gt;effective_io_concurrency&lt;/code&gt; 입니다. 특정 테이블 스페이스에 대한 값을 설정하면 동일한 이름의 구성 매개 변수에 의해 설정된대로 해당 테이블 스페이스의 테이블에서 페이지를 읽는 비용에 대한 플래너의 일반적인 예상 비용이 대체됩니다 ( &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency 참조&lt;/a&gt; ). 이것은 하나의 테이블 스페이스가 디스크에 위치하여 나머지 I / O 서브 시스템보다 빠르거나 느린 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">쿼리의 나머지 부분에서 파생 테이블에 대한 참조에 사용되도록 테이블 및 복합 테이블 참조에 임시 이름을 지정할 수 있습니다. 이것을 &lt;em&gt;테이블 별명&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">텍스트 검색 구성은 구문 분석기의 출력 토큰을 처리하기 위해 구문 분석기를 사전 세트와 함께 바인드합니다. 파서가 반환 할 수있는 각 토큰 유형에 대해 별도의 사전 목록이 구성에 의해 지정됩니다. 파서가 해당 유형의 토큰을 찾으면 일부 사전이이를 알려진 단어로 인식 할 때까지 목록의 각 사전이 차례로 참조됩니다. 중지 단어로 식별되거나 사전이 토큰을 인식하지 않으면 삭제되고 색인화되거나 검색되지 않습니다. 일반적으로 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 출력 을 반환하는 첫 번째 사전이 결과를 결정하고 나머지 사전은 참조하지 않습니다. 그러나 필터링 사전은 주어진 단어를 수정 된 단어로 대체 한 다음 후속 사전으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">텍스트 검색 구성은 문서를 &lt;code&gt;tsvector&lt;/code&gt; 로 변환하는 데 필요한 모든 옵션, 즉 텍스트를 토큰으로 나누는 데 사용하는 구문 분석기와 각 토큰을 렉 세어 로 변환하는 데 사용하는 사전을 지정합니다. &lt;code&gt;to_tsvector&lt;/code&gt; 또는 &lt;code&gt;to_tsquery&lt;/code&gt; 의 모든 호출은 처리를 수행하기 위해 텍스트 검색 구성이 필요합니다. 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 는 기본 구성의 이름을 지정하는데, 이는 명시 적 구성 매개 변수가 생략 된 경우 텍스트 검색 기능에서 사용되는 이름입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 설정하거나 &lt;code&gt;SET&lt;/code&gt; 명령을 사용하여 개별 세션에 대해 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">동의어 사전 (TZ로 축약 됨)은 단어와 구의 관계에 대한 정보를 포함하는 단어 모음입니다. 즉, 더 넓은 용어 (BT), 더 좁은 용어 (NT), 선호하는 용어, 비선호 용어, 관련 용어, 기타</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">시소러스 사전이 사용 &lt;em&gt;subdictionary&lt;/em&gt; 구문 일치 검사 전에 입력 텍스트를 정규화 (사전의 구성에 지정된다). 하나의 하위 사전 만 선택할 수 있습니다. 대체 어가 단어를 인식하지 못하면 오류가보고됩니다. 이 경우 단어의 사용을 제거하거나 그 단어에 대한 사전을 가르쳐야합니다. 색인 단어의 시작 부분에 별표 ( &lt;code&gt;*&lt;/code&gt; )를 붙여서 해당 사전을 적용하는 것을 건너 뛸 수 있지만 모든 샘플 단어 &lt;em&gt;를&lt;/em&gt; 해당 사전에 알고 &lt;em&gt;있어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">시스템에서 사용하는 세 번째 식별자 유형은 &lt;code&gt;cid&lt;/code&gt; 또는 명령 식별자입니다. 이 시스템 컬럼의 데이터 유형 &lt;code&gt;cmin&lt;/code&gt; 와 &lt;code&gt;cmax&lt;/code&gt; . 명령 식별자도 32 비트입니다.</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">부분 인덱스에 대한 세 번째 가능한 사용은 인덱스가 쿼리에 전혀 사용될 필요가 없습니다. 여기서 아이디어는 &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt; 과 같이 테이블의 하위 집합에 대해 고유 인덱스를 만드는 것 입니다. 이렇게하면 인덱스 술어를 만족시키는 행 중에서 고유하지 않은 행을 제한하지 않고 고유성을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">예를 들어, 표준 시간대 약어, &lt;code&gt;PST&lt;/code&gt; . 이러한 사양은 일광 절약 시간제 전환 날짜 규칙 세트를 암시 할 수있는 전체 시간대 이름과 달리 UTC에서 특정 오프셋을 정의합니다. 인식되는 약어는 &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 보기에 나열됩니다 ( 51.91 &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;절&lt;/a&gt; 참조 ). 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; 을 표준 시간대 약어로 설정할 수 없지만 날짜 / 시간 입력 값 및 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 연산자 와 함께 약어를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 또는 &lt;code&gt;interval&lt;/code&gt; 입력 없이 타임 스탬프를 처리 할 때는 시간대를 지정할 수 없습니다 . 이들은 항상 액면가로 취합니다.</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">시간대 약어 파일에는 빈 줄과 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 주석이 포함될 수 있습니다 . 주석이 아닌 행은 다음 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">토큰은 &lt;em&gt;키워드&lt;/em&gt; , &lt;em&gt;식별자&lt;/em&gt; , &lt;em&gt;따옴표 붙은 식별자&lt;/em&gt; , &lt;em&gt;리터럴&lt;/em&gt; (또는 상수) 또는 특수 문자 기호 일 수 있습니다. 토큰은 일반적으로 공백 (공백, 탭, 개행)으로 구분되지만 모호성이없는 경우 (일반적으로 특수 문자가 다른 토큰 유형에 인접한 경우에만 해당) 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">구성 파서가 생성 한 토큰 유형</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">트랜잭션은 또한 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; 뷰에서 자체 통계 (컬렉터로 아직 전송되지 않은)를 볼 수 있습니다 . 이 숫자는 위에서 언급 한대로 작동하지 않습니다. 대신 트랜잭션 전체에서 지속적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">트랜잭션은 검색 조건을 만족하는 행 집합을 반환하는 쿼리를 다시 실행하고 조건을 만족하는 행 집합이 최근에 커밋 된 다른 트랜잭션으로 인해 변경된 것을 발견합니다.</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">트랜잭션은 이전에 읽은 데이터를 다시 읽고 다른 트랜잭션 (초기 읽기 이후 커밋 된)에 의해 데이터가 수정 된 것을 발견합니다.</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">트랜잭션은 커밋되지 않은 동시 트랜잭션이 쓴 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 을 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 를 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; 을 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">변환은 데이터 유형을 절차 언어에 적용하는 방법을 지정합니다. 예를 들어, &lt;code&gt;hstore&lt;/code&gt; 유형을 사용하여 PL / Python에서 함수를 작성할 때 PL / Python은 Python 환경에서 &lt;code&gt;hstore&lt;/code&gt; 값을 표시하는 방법에 대한 사전 지식이 없습니다 . 언어 구현은 일반적으로 텍스트 표현을 사용하는 것이 기본이지만, 예를 들어 연관 배열이나 목록이 더 적합 할 때는 불편합니다.</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">변환은 두 가지 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">트리거 함수는 트리거를 반환하도록 선언됩니다 &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">&lt;code&gt;FOR EACH ROW&lt;/code&gt; 로 표시된 트리거 는 조작이 수정하는 모든 행에 대해 한 번 호출됩니다. 예를 들어, &lt;code&gt;DELETE&lt;/code&gt; 10 행에 영향을 미치는 그 어떤 원인이됩니다 &lt;code&gt;ON DELETE&lt;/code&gt; 대상 관계에 트리거가 한 번 삭제 된 각 행에 대해, 10 별도 번 호출 할 수 있습니다. 반대로, &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 로 표시된 트리거는 수정하는 행 수에 관계없이 특정 작업에 대해 한 번만 실행됩니다 (특히, 0 개의 행을 수정하는 작업은 여전히 ​​적용 가능한 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 트리거를 실행합니다) .</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">트라이 그램은 문자열에서 가져온 세 개의 연속 문자 그룹입니다. 두 줄이 공유하는 트라이 그램 수를 세어 두 문자열의 유사성을 측정 할 수 있습니다. 이 간단한 아이디어는 많은 자연 언어에서 단어의 유사성을 측정하는 데 매우 효과적이라는 것이 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">의 사소한 예 &lt;code&gt;LATERAL&lt;/code&gt; 인</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">캐스트</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">유형 캐스트는 한 데이터 유형에서 다른 데이터 유형으로의 변환을 지정합니다. PostgreSQL은 유형 캐스트에 대해 두 가지 동등한 구문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">테이블 별칭의 일반적인 응용 프로그램은 조인 절을 읽을 수 있도록 긴 테이블 이름에 짧은 식별자를 할당하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">일반적인 비용 견적 도구는 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">이 설정이 켜져있을 때 일반적으로 관찰되는 효과는 PostgreSQL 서버에서 사용하는 세마포어 개체가 임의의 시간에 제거되어 서버가 다음과 같은 로그 메시지와 충돌하는 것입니다</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">이 인덱스를 사용할 수있는 일반적인 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">복제 원본에 대한 고유 한 클러스터 전체 식별자입니다. 시스템을 떠나지 마십시오.</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">복제 슬롯에 대한 고유 한 클러스터 전체 식별자</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 쿼리 의 유용한 속성은 부모 쿼리 또는 형제 &lt;code&gt;WITH&lt;/code&gt; 쿼리에 의해 두 번 이상 참조 되더라도 일반적으로 부모 쿼리 실행 당 한 번만 평가된다는 것 입니다. 따라서 중복 작업을 피하기 위해 여러 위치에 필요한 값 비싼 계산을 &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에 배치 할 수 있습니다 . 또 다른 가능한 응용은 부작용으로 기능의 원치 않는 다중 평가를 방지하는 것입니다. 그러나이 코인의 다른 측면은 최적화 프로그램이 상위 쿼리의 제한을 다중 참조 &lt;code&gt;WITH&lt;/code&gt; 쿼리 로 푸시 다운 할 수 없다는 것입니다. 이는 하나의 쿼리에만 영향을 미치면 &lt;code&gt;WITH&lt;/code&gt; 쿼리 출력의 모든 사용에 영향을 줄 수 있기 때문입니다 . 곱하기 참조 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 나중에 상위 쿼리가 버릴 수있는 행을 억제하지 않고 작성된 것으로 평가됩니다. 그러나 위에서 언급 한 것처럼 쿼리에 대한 참조에 제한된 수의 행만 필요한 경우 평가가 일찍 중지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">사용자는 다른 사람의 스키마에서 객체를 만들 수도 있습니다. 이를 위해서는 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 부여되어야합니다. 기본적으로 모든 사람은 &lt;code&gt;public&lt;/code&gt; 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 및 &lt;code&gt;USAGE&lt;/code&gt; 권한을 갖습니다 . 이를 통해 주어진 데이터베이스에 연결할 수있는 모든 사용자가 &lt;code&gt;public&lt;/code&gt; 스키마 에서 오브젝트를 작성할 수 있습니다 . 일부 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;사용 패턴&lt;/a&gt; 은 해당 권한을 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">사용자는 해당 사용자가 직접 부여한 권한 만 취소 할 수 있습니다. 예를 들어, 사용자 A가 사용자 B에게 권한 부여 옵션이있는 권한을 부여하고 사용자 B가 사용자 C에게 권한을 부여한 경우 사용자 A는 C에서 직접 권한을 취소 할 수 없습니다. 대신 사용자 A가 권한 부여 옵션을 취소 할 수 있습니다. 사용자 B에서와 사용 &lt;code&gt;CASCADE&lt;/code&gt; 의 특권이 차례로 다른 예를 들어 사용자 C.에서 취소되도록 A와 B 모두 C에 동일한 권한을 부여한 경우, 옵션을, A는 자신의 부여하지만 B의 부여를 취소 C 그렇게 할 수 있습니다 여전히 효과적으로 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">원격 서버에서 사용될 역할을 식별하려면 &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING으로&lt;/a&gt; 정의 된 사용자 맵핑 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">사용자가 특정 열 또는 전체 테이블에 대해 해당 권한을 보유한 경우 열에서 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; 등을 수행 할 수 있습니다 . 테이블 레벨에서 특권을 부여한 후 한 컬럼에 대해 권한을 취소하면 원하는대로 수행되지 않습니다. 테이블 레벨 권한 부여는 컬럼 레벨 조작의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">적절한 권한이있는 사용자는 &lt;code&gt;tablespace_name&lt;/code&gt; 을 &lt;code&gt;CREATE DATABASE&lt;/code&gt; , &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; 로 전달하여 지정된 테이블 스페이스 내에 이러한 오브젝트에 대한 데이터 파일을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">인수를 사용하지 않고 &lt;code&gt;event_trigger&lt;/code&gt; 유형을 리턴하는 것으로 선언 된 사용자 제공 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">인수를 취하지 않고 트리거가 트리거 될 때 실행되는 &lt;code&gt;trigger&lt;/code&gt; 유형을 리턴하는 것으로 선언 된 사용자 제공 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">유효성 검사기 함수는 일반적으로 함수 본문에서 구문의 정확성을 검사하지만 언어가 특정 인수 유형을 처리 할 수없는 경우와 같이 함수의 다른 속성을 볼 수도 있습니다. 오류를 &lt;code&gt;ereport()&lt;/code&gt; 위해 유효성 검증기 함수는 ereport () 함수를 사용해야합니다 . 함수의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">값 (키는 아님)은 SQL &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">값 표현식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">참조 열에 삽입 된 값은 지정된 일치 유형을 사용하여 참조 테이블 및 참조 열의 값과 일치합니다. &lt;code&gt;MATCH FULL&lt;/code&gt; , &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 및 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; 의 세 가지 일치 유형이 있습니다 (기본값). &lt;code&gt;MATCH FULL&lt;/code&gt; 은 모든 외래 키 열이 null이 아니면 다중 열 외래 키의 한 열이 null이 될 수 없습니다. 모두 널인 경우 행은 참조 된 테이블에서 일치하지 않아도됩니다. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; 을 사용하면 외래 키 열을 null로 지정할 수 있습니다. 이들 중 하나가 널인 경우 행은 참조 된 테이블에서 일치하지 않아도됩니다. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 은 아직 구현되지 않았습니다. (물론 &lt;code&gt;NOT NULL&lt;/code&gt; 이러한 경우가 발생하지 않도록 참조 열에 제약 조건을 적용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">쿼리 할 JSON 텍스트를 나타내는 변수 ( &lt;em&gt;컨텍스트 항목&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">필터 표현식에서 경로 평가 결과를 나타내는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">따옴표 붙은 식별자의 변형으로 코드 포인트로 식별 된 이스케이프 된 유니 코드 문자를 포함 할 수 있습니다. 이 변형은 여는 큰 따옴표 바로 앞의 &lt;code&gt;U&amp;amp;&lt;/code&gt; (대문자 U와 소문자 U 뒤에 앰퍼샌드)로 시작합니다 (예 : &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; . (주이 운영자와의 모호성 만드는 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 . 사용 공간을 운영자 주위에이 문제를 방지 할 수 있습니다.) 따옴표 내부 유니 코드 문자는 4 자리의 16 진수 코드 포인트 번호 또는 뒤에 백 슬래시를 작성하여 탈출 형태로 지정 될 수 있습니다 또는 백 슬래시와 더하기 부호, 6 자리 16 진수 코드 포인트 번호가 뒤 따릅니다. 예를 들어 식별자 &lt;code&gt;&quot;data&quot;&lt;/code&gt; 는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">위 쿼리의 변형은</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">재귀 적 뷰에 대해 뷰 열 이름 목록을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">자동으로 업데이트 할 수있을 정도로 간단한 뷰 ( &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt; 참조 )는 업데이트 할 수 있도록 사용자가 만든 규칙이 필요하지 않습니다. 어쨌든 명시 적 규칙을 만들 수는 있지만 자동 업데이트 변환은 일반적으로 명시 적 규칙보다 성능이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">윈도우 함수 호출</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">윈도우 함수 호출에는 항상 윈도우 함수의 이름과 인수 바로 뒤에 &lt;code&gt;OVER&lt;/code&gt; 절이 포함 됩니다. 이것이 구문 상으로 일반 함수 또는 비 창구 집계와 구별됩니다. &lt;code&gt;OVER&lt;/code&gt; 의 절은 쿼리의 행이 윈도우 함수에 의해 처리 분할 정확하게 방법을 결정합니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 내의 절 &lt;code&gt;OVER&lt;/code&gt; 는 그 주의 동일한 값, 그룹 또는 파티션으로 나누어 행 &lt;code&gt;PARTITION BY&lt;/code&gt; 식 (S). 각 행에 대해 창 함수는 현재 행과 동일한 파티션에 속하는 행에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">단어는 위의 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 및 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 사양에서와 같이 정의됩니다 . 제약 조건 이스케이프는 대괄호 표현식 내에서 불법입니다.</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">대기중인 &lt;code&gt;restore_command&lt;/code&gt; 의 실제 예제 는 &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈 에서 제공됩니다 . 위에서 설명한 논리를 올바르게 구현하는 방법에 대한 참조로 사용해야합니다. 특정 구성 및 환경을 지원하기 위해 필요에 따라 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">쓰기 트랜잭션에는 64 개 이상의 서브 트랜잭션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">ABORT &amp;mdash; 현재 거래 중단</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">독점 액세스</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">액세스 쉐어</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">대체 집계</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE &amp;mdash; 집계 함수의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">대체 컬렉션</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION &amp;mdash; 데이터 정렬의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">변환 변경</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION &amp;mdash; 전환 정의 변경</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">데이터베이스 변경</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE &amp;mdash; 데이터베이스 변경</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">기본 실무 변경</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">DEFAULT PRIVILEGES ALTER DEFAULT PRIVILEGES &amp;mdash; 기본 액세스 권한을 정의합니다</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">도메인 변경</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN &amp;mdash; 도메인 정의 변경</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">이벤트 트리거 변경</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER &amp;mdash; 이벤트 트리거의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">교체 연장</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION &amp;mdash; 확장 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">외국 데이터 랩터 변경</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER &amp;mdash; 외부 데이터 래퍼의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">외국 테이블 변경</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE &amp;mdash; 외래 테이블의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">기능 변경</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION &amp;mdash; 함수의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">대체 그룹</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP &amp;mdash; 역할 이름 또는 멤버십 변경</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">인덱스 변경</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX &amp;mdash; 색인 정의 변경</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">언어 변경</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE &amp;mdash; 절차 언어의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">큰 목표 변경</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT &amp;mdash; 대형 객체의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">대체 재료보기</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW &amp;mdash; 구체화 된 뷰의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">운영자 변경</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR &amp;mdash; 운영자 정의 변경</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">운영자 클래스 변경</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS &amp;mdash; 연산자 클래스의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">운영자 가족 변경</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY &amp;mdash; 운영자 제품군의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">정책 변경</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY &amp;mdash; 행 수준 보안 정책의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">절차 변경</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE &amp;mdash; 절차 정의 변경</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">출판사 변경</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION &amp;mdash; 출판물의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">역할 변경</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE &amp;mdash; 데이터베이스 역할 변경</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">대체 루틴</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE-루틴 정의 변경</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">규칙 변경</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE &amp;mdash; 규칙의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">ALTER SCHEMA</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA &amp;mdash; 스키마 정의 변경</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">순서 변경</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE &amp;mdash; 시퀀스 생성기의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">대체 서버</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER &amp;mdash; 외부 서버의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">통계 변경</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS &amp;mdash; 확장 통계 개체의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">대체 가입</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION &amp;mdash; 구독 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">시스템 변경</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM &amp;mdash; 서버 구성 매개 변수 변경</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">테이블 변경</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE &amp;mdash; 테이블 정의 변경</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">테이블 스페이스 변경</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE &amp;mdash; 테이블 스페이스의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">텍스트 검색 구성 변경</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">텍스트 검색 구성 변경 &amp;mdash; 텍스트 검색 구성의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">텍스트 검색 사전</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">텍스트 검색 사전 변경 &amp;mdash; 텍스트 검색 사전의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">텍스트 검색 파서 변경</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">텍스트 검색 파서 변경 &amp;mdash; 텍스트 검색 파서의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">텍스트 검색 템플릿 변경</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">텍스트 검색 템플릿 변경 &amp;mdash; 텍스트 검색 템플릿의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">대체 트리거</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER &amp;mdash; 트리거의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">대체 유형</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE &amp;mdash; 유형의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">사용자 변경</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER &amp;mdash; 데이터베이스 역할 변경</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">사용자 매핑 변경</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING &amp;mdash; 사용자 매핑의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">변경보기</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW &amp;mdash;보기의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">분석 &amp;mdash; 데이터베이스에 대한 통계 수집</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">AND &lt;code&gt;tsquery&lt;/code&gt; 함께</target>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">인수의 첫 문자의 ASCII 코드 UTF8의 경우 문자의 유니 코드 코드 포인트를 리턴합니다. 다른 멀티 바이트 인코딩의 경우 인수는 ASCII 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">아론 디.</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="translated">약어 (태평양 표준시)</target>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">지정된 시간보다 오래 걸리는 문장을 중단하십시오. &lt;code&gt;log_min_error_statement&lt;/code&gt; 가 &lt;code&gt;ERROR&lt;/code&gt; 이하 로 설정 되면 시간 종료 된 명령문도 로그됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">테이블, 인덱스, 행 또는 기타 데이터베이스 오브젝트에 대한 잠금을 확보하려고 시도하는 동안 지정된 시간보다 오래 기다리는 명령문을 중단하십시오. 시간 제한은 각 잠금 획득 시도에 별도로 적용됩니다. 제한은 명시 적 잠금 요청 ( &lt;code&gt;LOCK TABLE&lt;/code&gt; 또는 &lt;code&gt;NOWAIT&lt;/code&gt; 없이 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 와 같은 ) 및 내재적으로 획득 된 잠금 모두에 적용됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">위 의 &lt;code&gt;OVER&lt;/code&gt; 절 에 &lt;code&gt;ORDER BY&lt;/code&gt; 가 없기 때문에 창 프레임은 파티션과 동일하며 &lt;code&gt;PARTITION BY&lt;/code&gt; 가 없으면 전체 테이블입니다. 다시 말해 각 합계는 전체 테이블에 적용되므로 각 출력 행에 대해 동일한 결과를 얻습니다. 그러나 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 추가하면 매우 다른 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">SQL / JSON 번호의 절대 값</target>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">명시 적 &lt;code&gt;LOCK&lt;/code&gt; 명령과 다양한 DDL 작업을 포함하여 기본 서버에서 수행되는 독점 잠금 은 대기 쿼리의 테이블 액세스와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">데이터의 자연 순서 (예 : btree)로 항목을 항상 반환하는 액세스 방법은 &lt;code&gt;amcanorder&lt;/code&gt; 를 true로 설정해야 합니다. 현재 이러한 액세스 방법은 동등성 및 순서 연산자에 대해 btree 호환 전략 번호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">정렬 된 스캔을 지원하는 액세스 방법은 스캔에서 위치를 &quot;마킹&quot;하고 나중에 표시된 위치로 돌아 오는 것을 지원해야합니다. 동일한 위치가 여러 번 복원 될 수 있습니다. 그러나 스캔 당 하나의 위치 만 기억하면됩니다. 새로운 &lt;code&gt;ammarkpos&lt;/code&gt; 호출은 이전에 표시된 위치를 대체합니다. 제공하지 않아도 주문 스캔을 지원하지 않는 액세스 방법 &lt;code&gt;ammarkpos&lt;/code&gt; 및 &lt;code&gt;amrestrpos&lt;/code&gt; 의 기능을 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 을 ; 대신 포인터를 NULL로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">순서 연산자를 지원하는 액세스 메소드는 &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; 특성 테스트를 구현해야 합니다. 코어 코드는이를 수행하는 방법을 모르고 NULL을 리턴하기 때문입니다. 인덱스를 열고 코어 코드의 기본 동작 인 &lt;code&gt;amcanreturn&lt;/code&gt; 을 호출하는 것보다 저렴하게 수행 할 수있는 경우 &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; 테스트 를 구현하는 것이 유리할 수도 있습니다 . 기본 동작은 다른 모든 표준 속성에 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">순서 연산자를 지원하는 액세스 방법은 &lt;code&gt;amcanorderbyop&lt;/code&gt; 을 true로 설정해야 합니다. 이것은 인덱스가 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 만족하는 순서로 항목을 리턴 할 수 있음을 나타냅니다 . 해당 양식의 스캔 수정자는 앞에서 설명한대로 &lt;code&gt;amrescan&lt;/code&gt; 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">템플릿에 대한 액세스 권한 (실제로는 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">이 유형의 객체가 작성시 가져야하는 액세스 권한</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">접근 권한; 자세한 내용 &lt;a href=&quot;ddl-priv&quot;&gt;은 5.7 절&lt;/a&gt; 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">뷰에서 참조 된 테이블에 대한 액세스는 뷰 소유자의 권한에 의해 결정됩니다. 경우에 따라 기본 테이블에 대한 안전하지만 제한된 액세스를 제공하는 데 사용할 수 있습니다. 그러나 모든 견해가 변조에 대해 안전한 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조하십시오. 뷰에서 호출 된 함수는 뷰를 사용하여 쿼리에서 직접 호출 된 것처럼 동일하게 취급됩니다. 따라서 뷰 사용자에게는 뷰에서 사용하는 모든 함수를 호출 할 수있는 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">&lt;code&gt;subconninfo&lt;/code&gt; 열에 대한 액세스 는 일반 텍스트 비밀번호를 포함 할 수 있기 때문에 일반 사용자로부터 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 테이블에 대한 액세스 는 수퍼 유저로 제한되므로 일반 사용자는 다른 사용자의 테이블 내용을 알 수 없습니다. 일부 선택성 추정 함수는 사용자 제공 연산자 (조회에 나타나는 연산자 또는 관련 연산자)를 사용하여 저장된 통계를 분석합니다. 예를 들어, 저장된 가장 일반적인 값이 적용 가능한지 확인하려면 선택성 추정기는 쿼리의 상수를 저장된 값과 비교하기 위해 적절한 &lt;code&gt;=&lt;/code&gt; 연산자를 실행해야 합니다. 따라서 &lt;code&gt;pg_statistic&lt;/code&gt; 의 데이터잠재적으로 사용자 정의 연산자로 전달됩니다. 적절하게 조작 된 연산자는 전달 된 피연산자를 의도적으로 유출하거나 (예 : 기록하거나 다른 테이블에 기록) 실수로 &lt;code&gt;pg_statistic&lt;/code&gt; 에서 사용자에게 데이터를 노출시키는 경우 오류 메시지에 값을 표시하여 실수로 유출 할 수 있습니다. 그것을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;키워드 = 값&amp;rdquo;문자열과 같은 액세스 방법 별 옵션</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">원격 데이터에 액세스하려면 외부 데이터 소스에 대한 인증이 필요할 수 있습니다. 이 정보는 현재 PostgreSQL 역할에 따라 사용자 이름 및 비밀번호와 같은 추가 데이터를 제공 할 수 있는 &lt;em&gt;사용자 매핑을&lt;/em&gt; 통해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">접근 자 연산자</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">에 나열된 접근 사업자 &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;표 8.25&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">SQL 표준에 따르면 간격 값의 모든 필드는 동일한 부호를 가져야하므로 선행 음수 부호가 모든 필드에 적용됩니다. 예를 들어 간격 리터럴 &lt;code&gt;'-1 2:03:04'&lt;/code&gt; 의 음수 부호 는 일 및시 / 분 / 초 부분에 모두 적용됩니다. PostgreSQL은 필드가 서로 다른 부호를 가질 수있게하며 전통적으로 텍스트 표현의 각 필드를 독립적으로 부호가있는 것으로 취급하므로이 예제에서는 시간 / 분 / 초 부분이 양수로 간주됩니다. &lt;code&gt;IntervalStyle&lt;/code&gt; 이 &lt;code&gt;sql_standard&lt;/code&gt; 로 설정된 경우그런 다음 선행 기호는 모든 필드에 적용되는 것으로 간주됩니다 (단, 추가 기호가 나타나지 않는 경우에만). 그렇지 않으면 전통적인 PostgreSQL 해석이 사용됩니다. 모호성을 피하려면 필드가 음수이면 각 필드에 명시 적 부호를 첨부하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">SQL 표준에 따라 권한 부여 옵션을 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 할 수 있습니다 . PostgreSQL은 역할에 부여 옵션 부여 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;DROP&lt;/code&gt; 명령 에 &lt;code&gt;RESTRICT&lt;/code&gt; 또는 &lt;code&gt;CASCADE&lt;/code&gt; 를 지정 해야합니다 . 실제로 해당 규칙을 적용하는 데이터베이스 시스템은 없지만 기본 동작이 &lt;code&gt;RESTRICT&lt;/code&gt; 인지 &lt;code&gt;CASCADE&lt;/code&gt; 인지 는 시스템마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; 의 &lt;code&gt;PRIVILEGES&lt;/code&gt; 키워드 가 필요합니다. SQL 표준은 명령 당 둘 이상의 오브젝트에 대한 권한 설정을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">SQL 표준에 따르면이 옵션을 설정하는 명령은</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;LIMIT&lt;/code&gt; 를 적용하기 전에 출력 목록의 표현식을 계산해야합니다 . &lt;code&gt;DISTINCT&lt;/code&gt; 를 사용할 때 분명히 필요합니다. 그렇지 않으면 어떤 값이 구별되는지 명확하지 않기 때문입니다. 그러나 많은 경우에 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 후에 출력 표현식이 계산되는 것이 편리합니다.; 특히 출력 목록에 휘발성 또는 고가의 기능이 포함 된 경우. 이 동작을 사용하면 함수 평가 순서가보다 직관적이며 출력에 절대 나타나지 않는 행에 해당하는 평가는 없습니다. PostgreSQL은 &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;GROUP BY&lt;/code&gt; 에서 해당 표현식이 참조되지 않는 한 정렬 및 제한 후 출력 표현식을 효과적으로 평가합니다 . (반대 예로서, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; 은 정렬하기 전에 &lt;code&gt;f(x)&lt;/code&gt; 를 명확하게 평가해야합니다 .) set-returning 함수를 포함하는 출력 표현식은 정렬 후 및 제한 전에 효과적으로 평가되므로 &lt;code&gt;LIMIT&lt;/code&gt; set-returning 기능에서 출력을 차단하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">SQL 표준에 따르면 스키마 소유자는 항상 스키마 내의 모든 개체를 소유합니다. PostgreSQL을 사용하면 스키마 소유자 이외의 사용자가 소유 한 객체를 스키마에 포함 할 수 있습니다. 스키마 소유자 가 자신의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한을 다른 사람 에게 부여 하거나 수퍼 유저가 개체를 만들도록 선택한 경우에만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">comp.ai.genetic FAQ에 따르면 GA가 문제에 대한 해결책을 찾기위한 순수한 무작위 검색이 아니라고 너무 강조 할 수는 없습니다. GA는 확률 적 프로세스를 사용하지만 결과는 임의적이지 않습니다 (무작위보다 낫습니다).</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">표준에 따르면 오류 코드의 처음 두 문자는 오류 클래스를 나타내고 마지막 세 문자는 해당 클래스 내의 특정 조건을 나타냅니다. 따라서 특정 오류 코드를 인식하지 못하는 응용 프로그램은 여전히 ​​오류 클래스에서 수행 할 작업을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">표준에 따르면 대상 열 이름의 괄호로 묶인 하위 목록의 소스 값은 올바른 열 수를 생성하는 행 값 식일 수 있습니다. PostgreSQL에서는 소스 값만 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;행 생성자&lt;/a&gt; 또는 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 될 수 있습니다 . 행 생성자의 경우 개별 열의 업데이트 된 값을 &lt;code&gt;DEFAULT&lt;/code&gt; 로 지정할 수 있지만 하위 &lt;code&gt;SELECT&lt;/code&gt; 안에는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 에 의해 획득 ( &lt;code&gt;CONCURRENTLY&lt;/code&gt; 없이 ).</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; 및 일부 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식으로 획득합니다 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; 통해 획득했습니다 .</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; ( &lt;code&gt;FULL&lt;/code&gt; 없이 ), &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 및 특정 &lt;code&gt;ALTER INDEX&lt;/code&gt; 및 &lt;code&gt;ALTER TABLE&lt;/code&gt; 변형에 의해 획득됩니다 ( 자세한 내용은 &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; 및 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">&lt;code&gt;DROP TABLE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;VACUUM FULL&lt;/code&gt; 및 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; ( &lt;code&gt;CONCURRENTLY&lt;/code&gt; 없이 ) 명령으로 획득 합니다. 여러 형태의 &lt;code&gt;ALTER INDEX&lt;/code&gt; 및 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도이 수준에서 잠금을 획득합니다. 또한 명시 적으로 모드를 지정하지 않은 &lt;code&gt;LOCK TABLE&lt;/code&gt; 문의 기본 잠금 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">스냅 샷 시점의 활성 txid 이 목록에는 &lt;code&gt;xmin&lt;/code&gt; 과 &lt;code&gt;xmax&lt;/code&gt; 사이의 활성 txid 만 포함됩니다 . &lt;code&gt;xmax&lt;/code&gt; 보다 높은 활성 txid가있을 수 있습니다 . TxID 삽입 즉 &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; 그 상태를 커밋이 목록에 이미 스냅 숏시에 완료되므로 어느 보이거나 죽은있어서 아니었다. 리스트에는 서브 트랜잭션의 txid가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">WAL 수신자 프로세스의 활동 상태</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">큰 객체에 저장된 실제 데이터. 이 값은 &lt;code&gt;LOBLKSIZE&lt;/code&gt; 바이트 보다 크지 않으며 더 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">실제로 이전 단락은 지나치게 단순화 된 것입니다. 함수 호출 구문이 실제 함수와 일치하지 않고 캐스트 요청으로 처리되는 두 가지 경우가 있습니다. 함수 호출 &lt;code&gt;name&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )이 기존 함수와 정확히 일치하지 않지만 &lt;code&gt;name&lt;/code&gt; 이 데이터 유형의 이름이고 &lt;code&gt;pg_cast&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 유형에서이 유형으로 이진 강제 변환을 제공하는 경우 호출은 다음과 같이 해석됩니다. 이진 보자 형 캐스트. 이 예외는 바이너리 강제 변환 캐스트가 함수 구문이 없어도 함수 구문을 사용하여 호출 할 수 있도록하기위한 것입니다. 마찬가지로 &lt;code&gt;pg_cast&lt;/code&gt; 가 없으면캐스트가 문자열 유형에 대한 것이거나 캐스트 유형 인 경우 호출은 I / O 변환 캐스트로 해석됩니다. 이 예외는 기능적 구문을 사용하여 I / O 변환 캐스트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">실제로, 각&amp;ldquo;문자&amp;rdquo;는 공백을 포함하지 않는 문자열 일 수 있으므로 분음 부호 제거 외에 다른 종류의 하위 문자열 대체에 &lt;code&gt;unaccent&lt;/code&gt; 사전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">실제로 이러한 예제 쿼리에서 단일 &lt;code&gt;NULL&lt;/code&gt; 속성 이 전체 문서에 대해 &lt;code&gt;NULL&lt;/code&gt; 결과를 발생 시키지 않도록 &lt;code&gt;coalesce&lt;/code&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">사실, 훨씬 더 일반적인 문법</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">추가 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; 명령. &lt;code&gt;--inserts&lt;/code&gt; 또는 &lt;code&gt;--column-inserts&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">추가 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; 명령. &lt;code&gt;--inserts&lt;/code&gt; , &lt;code&gt;--column-inserts&lt;/code&gt; 또는 &lt;code&gt;--rows-per-insert&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">키를 추가하거나 기존 키를 새 값으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 에서 읽은 트랜잭션 스크립트 를 실행 된 스크립트 목록에 추가하십시오 . &lt;code&gt;@&lt;/code&gt; 뒤에 선택적 정수 가중치를 사용하면 테스트를 그릴 확률을 조정할 수 있습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">열 추가</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">구속 조건 추가</target>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">겹치지 않는 테이블 제약 조건을 자식 테이블에 추가하여 각각에 허용 된 키 값을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">함수가 호출 될 때 구성 매개 변수에 지정할 지정을 추가하거나 변경하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 인 &lt;code&gt;DEFAULT&lt;/code&gt; 또는 등가 &lt;code&gt;RESET&lt;/code&gt; 가 사용되는 함수 로컬 설정이 제거되므로, 그 환경에서 본 값으로 함수를 실행한다. 모든 기능 로컬 설정을 지우려면 &lt;code&gt;RESET ALL&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 이 실행될 때 현재 매개 변수 의 값을 기능 입력시 적용될 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">프로 시저가 호출 될 때 구성 매개 변수에 지정할 지정을 추가하거나 변경하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 인 &lt;code&gt;DEFAULT&lt;/code&gt; 또는 등가 &lt;code&gt;RESET&lt;/code&gt; 가 사용되는 절차 로컬 설정이 제거되므로, 그 환경에서의 값과 현재의 절차를 실행한다. 모든 절차 로컬 설정을 지우려면 &lt;code&gt;RESET ALL&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 가 실행될 때 현재 매개 변수 값을 프로 시저가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">발행물에 몇 가지 테이블을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">새 열을 기본값으로 &lt;code&gt;pg_proc.h&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">프로브 정의를 &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; 에 프로브 정의를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">지정된 내장 스크립트를 실행 된 스크립트 목록에 추가하십시오. &lt;code&gt;@&lt;/code&gt; 뒤에 선택적 정수 가중치를 사용하면 스크립트를 그릴 확률을 조정할 수 있습니다. 지정하지 않으면 1로 설정됩니다. 사용 가능한 내장 스크립트는 &lt;code&gt;tpcb-like&lt;/code&gt; , &lt;code&gt;simple-update&lt;/code&gt; 및 &lt;code&gt;select-only&lt;/code&gt; 입니다. 내장 이름의 명확한 접두사가 허용됩니다. 특수 이름 &lt;code&gt;list&lt;/code&gt; 로 내장 스크립트 목록을 표시하고 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">그룹에 사용자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건을 추가 하려면 기존 행이 제약 조건을 충족하는지 확인하기 위해 테이블을 검색해야하지만 테이블을 다시 쓰지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 &lt;code&gt;INCLUDE&lt;/code&gt; 절을 사용하면 색인의 키가 아닌 부분에 포함될 열 목록을 지정할 수 있습니다. 포함 된 열에는 고유성이 적용되지 않지만 제약 조건은 여전히 ​​열에 따라 다릅니다. 결과적으로 포함 된 열 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; ) 에 대한 일부 작업은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">일시적인 &lt;code&gt;DEFAULT&lt;/code&gt; 가 있는 열을 추가 하거나 기존 열의 유형을 변경하면 전체 테이블과 해당 인덱스를 다시 작성해야합니다. 예외로, 기존 컬럼의 유형을 변경할 때 &lt;code&gt;USING&lt;/code&gt; 절이 컬럼 컨텐츠를 변경하지 않고 이전 유형이 새 유형에 대해 강제 변환 가능하거나 새 유형에 대해 제한되지 않은 도메인 인 경우 테이블을 다시 쓸 필요가 없습니다. ; 그러나 영향을받는 열의 인덱스는 여전히 다시 작성해야합니다. 테이블 및 / 또는 인덱스 재 구축은 큰 테이블의 경우 상당한 시간이 걸릴 수 있습니다. 일시적으로 디스크 공간의 두 배가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">기존 인덱스를 사용하여 제약 조건을 추가하면 테이블 업데이트를 오랫동안 차단하지 않고 새로운 제약 조건을 추가해야하는 상황에서 유용 할 수 있습니다. 이를 수행하려면 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 를 사용하여 색인을 작성한 후이 구문을 사용하여 공식 제한 조건으로 설치하십시오. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">기본 키를 추가하면 기본 키에 나열된 열 또는 열 그룹에 고유 한 B- 트리 인덱스가 자동으로 생성되고 열이 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">고유 제약 조건을 추가하면 제약 조건에 나열된 열 또는 열 그룹에 고유 B- 트리 인덱스가 자동으로 생성됩니다. 일부 행만 포함하는 고유성 제한은 고유 제한 조건으로 작성할 수 없지만 고유 &lt;a href=&quot;indexes-partial&quot;&gt;부분 인덱스를&lt;/a&gt; 작성하여 이러한 제한을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">고유 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 절 &lt;code&gt;INCLUDE&lt;/code&gt; 는 고유성이 적용되지 않은 하나 이상의 열을 해당 색인에 추가합니다. 포함 된 열에 제약 조건이 적용되지 않더라도 여전히 열에 따라 달라집니다. 결과적으로 이러한 열에 대한 일부 작업 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; )은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">제외 제약 조건을 추가하면 제약 조건 선언에 지정된 유형의 인덱스가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">RE 주위에 괄호를 추가해도 욕심은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">외래 키 제약 조건 을 추가하려면 제약 조건을받는 테이블의 잠금 외에 참조 된 테이블에 대한 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 잠금이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">추가 기능</target>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">추가 이진 문자열 조작 기능을 사용할 수 있으며 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;표 9.13에&lt;/a&gt; 나열되어 있습니다. 이들 중 일부는 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;표 9.12에&lt;/a&gt; 나열된 SQL 표준 문자열 함수를 구현하기 위해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">생성 된 컬럼 사용시 추가 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">추가적인 논의와 실제적인 예는 &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">Andrew Gierth의 추가 향상 기능 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; , 영국</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / Perl 및 PL / Python 언어 의 &lt;code&gt;hstore&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . 신뢰할 수 있고 신뢰할 수없는 PL / Perl을 위해 PL / Perl의 확장명을 &lt;code&gt;hstore_plperl&lt;/code&gt; 및 &lt;code&gt;hstore_plperlu&lt;/code&gt; 라고 합니다. 이러한 변환을 설치하고 함수를 작성할 때이를 지정하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Perl 해시에 맵핑됩니다. PL / Python의 확장은 &lt;code&gt;hstore_plpythonu&lt;/code&gt; , &lt;code&gt;hstore_plpython2u&lt;/code&gt; 및 &lt;code&gt;hstore_plpython3u&lt;/code&gt; 입니다 ( PL / Python 명명 규칙 &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;은 45.1 절&lt;/a&gt; 참조 ). 이를 사용하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Python 사전에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">다른 절차 언어에 대한 &lt;code&gt;jsonb&lt;/code&gt; 유형의 변환을 구현하는 추가 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Python 의 &lt;code&gt;ltree&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . 확장을 &lt;code&gt;ltree_plpythonu&lt;/code&gt; , &lt;code&gt;ltree_plpython2u&lt;/code&gt; 및 &lt;code&gt;ltree_plpython3u&lt;/code&gt; 라고 합니다 (PL / Python 명명 규칙 &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;은 45.1 절&lt;/a&gt; 참조 ). 함수를 생성 할 때 이러한 변환을 설치하고 지정하면 &lt;code&gt;ltree&lt;/code&gt; 값이 Python 목록에 매핑됩니다. (그러나 그 반대는 현재 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">통계 수집과 관련된 추가 기능은 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;표 27.20에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">함수를 호출하는 방법에 대한 추가 정보. 다시 말하지만 해석은 언어마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">가입 및 논리적 복제에 대한 추가 정보는 &lt;a href=&quot;logical-replication-subscription&quot;&gt;30.2 절&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30 장&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">형식 지정자의 출력 형식을 제어하는 ​​추가 옵션. 현재 지원되는 유일한 플래그는 빼기 부호 ( &lt;code&gt;-&lt;/code&gt; )이며 형식 지정자의 출력이 왼쪽 정렬됩니다. &lt;code&gt;width&lt;/code&gt; 필드도 지정 하지 않으면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">고유 인덱스가 파티션 된 테이블에 적용될 때 추가 제한 사항이 적용됩니다. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">고유 또는 기본 키 제한 조건이 파티션 된 테이블에 추가 될 때 추가 제한 사항이 적용됩니다. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE을&lt;/a&gt; 참조하십시오 . 또한 파티션 된 테이블에 대한 외래 키 제약 조건 은 현재 &lt;code&gt;NOT VALID&lt;/code&gt; 로 선언 되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">추가 문자열 조작 기능을 사용할 수 있으며 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;표 9.10에&lt;/a&gt; 나열되어 있습니다. 이들 중 일부는 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;표 9.9에&lt;/a&gt; 나열된 SQL 표준 문자열 함수를 구현하기 위해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">추가 업데이트는 2006 년 7 월 Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; 에 의해 이루어졌습니다 . 여기에는 &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; 및 더 이상 사용되지 않는 V0 프로토콜 대신 V1 호출 프로토콜을 사용하도록 코드 정리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">매개 변수에 대한 추가적이고 자세한 설명</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">또한 SQL 입력에서 &lt;em&gt;주석&lt;/em&gt; 이 발생할 수 있습니다. 그것들은 토큰이 아니며 효과적으로 공백과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">또한 테이블 참조가 하위 쿼리 인 경우 별칭이 필요합니다 ( &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;섹션 7.2.1.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">또한 쿼리에 일반적으로 함수에 대한 암시 적 변환이 필요한 경우 사용자가 올바른 인수 유형으로 새 함수를 정의하면 파서는이 새로운 함수를 사용해야하며 더 이상 기존 함수를 사용하기 위해 암시 적 변환을 수행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">또한 영역 내에서 PostgreSQL을 실행중인 경우 영역 리소스 사용 제한도 높여야 할 수 있습니다. &lt;code&gt;projects&lt;/code&gt; 및 &lt;code&gt;prctl&lt;/code&gt; 에 대한 자세한 내용 은 &lt;em&gt;시스템 관리자 안내서의&lt;/em&gt; &quot;2 장 : 프로젝트 및 작업&quot; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">또한 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 에 설명 된대로 새로 고침 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">또한 SQL 표준 데이터 정렬 이름 &lt;code&gt;ucs_basic&lt;/code&gt; 을 &lt;code&gt;UTF8&lt;/code&gt; 인코딩에 사용할 수 있습니다 . &lt;code&gt;C&lt;/code&gt; 와 동일하며 유니 코드 코드 포인트별로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">24 시간 기간이 일로 표시되도록 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">30 일 기간이 월로 표시되도록 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">추가적인 부호 조정으로 &lt;code&gt;justify_days&lt;/code&gt; 및 &lt;code&gt;justify_hours&lt;/code&gt; 를 사용하여 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;weather&lt;/code&gt; 의 한 행에서 온도 입력을 조정하고 강수량을 기본값으로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">조정 가능한 인쇄 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">관리 기능</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">관리자는 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 명령을 사용하여 사용자에게 이러한 역할에 대한 액세스 권한을 부여 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">사전 순서와 새로운 가치를 반환</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">시퀀스 객체를 다음 값으로 전진시키고 해당 값을 반환합니다. 이 원자 적으로 수행됩니다 여러 세션을 실행할 경우에도 &lt;code&gt;nextval&lt;/code&gt; 동시에, 각 안전하게 별개의 시퀀스 값을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">ACPI (Advanced Configuration and Power Interface)는 Linux가 acpi_pm이라고하는 전원 관리 (PM) 타이머를 제공합니다. acpi_pm에서 파생 된 클럭은 기껏해야 300 나노초의 해상도를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">고급 사용자는 문자 클래스와 같은 정규식 표기법 (예 : &lt;code&gt;[0-9]&lt;/code&gt; ) 을 사용하여 모든 숫자와 일치시킬 수 있습니다. 를 제외한 모든 정규 표현식 특수 문자는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절에&lt;/a&gt; 지정된대로 작동 합니다 &lt;code&gt;.&lt;/code&gt; 이는 전술 한 바와 같이 세퍼레이터로한다 &lt;code&gt;*&lt;/code&gt; 정규 표현식 표기로 변환된다 &lt;code&gt;.*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; 로 번역됩니다 &lt;code&gt;.&lt;/code&gt; , 및 &lt;code&gt;$&lt;/code&gt; 는 문자 그대로 일치합니다. 필요한 경우 이러한 패턴 문자를 에뮬레이션 할 수 &lt;code&gt;?&lt;/code&gt; 에 대한 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;(R+|)&lt;/code&gt; 에 대한 &lt;code&gt;R*&lt;/code&gt; , 또는 &lt;code&gt;(R|)&lt;/code&gt; 에 대한 &lt;code&gt;R?&lt;/code&gt; . &lt;code&gt;$&lt;/code&gt; 정규식의 일반적인 해석과 달리 패턴이 전체 이름과 일치해야하므로 $ 는 정규식 문자로 필요하지 않습니다 (즉, &lt;code&gt;$&lt;/code&gt; 가 자동으로 패턴에 추가됨). 패턴을 고정하지 않으려면 시작 및 / 또는 끝에 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . 큰 따옴표 내에서 모든 정규식 특수 문자는 특수 의미를 잃고 문자 그대로 일치합니다. 또한 정규 표현식 특수 문자는 문자 그대로 연산자 이름 패턴에서 일치합니다 (예 : &lt;code&gt;\do&lt;/code&gt; 인수 ).</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 복제 슬롯의 현재 확인 된 위치를 진행시킵니다 . 슬롯은 뒤로 이동하지 않으며 현재 인서트 위치를 넘어서 이동하지 않습니다. 슬롯 이름과 슬롯이 진행된 실제 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">단일 &lt;code&gt;bigint&lt;/code&gt; 값 또는 두 개의 정수 값 으로 구성된 키에 대해 권고 잠금을 얻을 수 있습니다 . &lt;code&gt;bigint&lt;/code&gt; 키는 그것의 상위 절반 표시 &lt;code&gt;classid&lt;/code&gt; 칼럼의 하위 상기 반 &lt;code&gt;objid&lt;/code&gt; 열 및 &lt;code&gt;objsubid&lt;/code&gt; 1. 동일한 원래 &lt;code&gt;bigint&lt;/code&gt; 값이 식으로 재 조립 될 수있다 &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; 입니다. 정수 키는 &lt;code&gt;classid&lt;/code&gt; 열의 첫 번째 키 , &lt;code&gt;objid&lt;/code&gt; 열의 두 번째 키 및 &lt;code&gt;objsubid&lt;/code&gt; 가 2 와 함께 표시됩니다. 키 의 실제 의미는 사용자에게 달려 있습니다. 권고 잠금은 각 데이터베이스에 대해 로컬이므로 &lt;code&gt;database&lt;/code&gt; 열은 권고 잠금에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">권고 잠금은 교착 상태 감지를 포함하여 복구시 정상적으로 작동합니다. 권고 잠금은 절대 WAL로 기록되지 않으므로 기본 또는 대기에 대한 권고 잠금이 WAL 재생과 충돌하는 것은 불가능합니다. 또한 기본에서 권고 잠금을 획득하고 대기에서 유사한 권고 잠금을 시작하도록 할 수도 없습니다. 권고 잠금은 획득 한 서버에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">검사 점이 만들어지고 로그가 플러시되면 검사 점의 위치가 &lt;code&gt;pg_control&lt;/code&gt; 파일에 저장됩니다 . 따라서 복구 시작시 서버는 먼저 &lt;code&gt;pg_control&lt;/code&gt; 을 읽은 다음 검사 점 레코드를 읽습니다 . 그런 다음 검사 점 레코드에 표시된 로그 위치에서 앞으로 스캔하여 REDO 작업을 수행합니다. &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 가 비활성화되지 않았다고 가정하면 검사 점 이후 첫 페이지 수정시 데이터 페이지의 전체 내용이 로그에 저장 되므로 검사 점 이후 변경된 모든 페이지는 일관성있는 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">커밋 레코드가 기본의 디스크에 기록 된 후 WAL 레코드가 대기로 전송됩니다. 대기에서 &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 이 0으로 설정되어 있지 않으면 대기는 새 WAL 데이터 배치를 디스크에 쓸 때마다 응답 메시지를 보냅니다 . &lt;code&gt;synchronous_commit&lt;/code&gt; 이 &lt;code&gt;remote_apply&lt;/code&gt; 로 설정된 경우 대기는 커밋 레코드가 재생 될 때 응답 메시지를 보내 트랜잭션을 볼 수있게합니다. 이 대기의 설정에 따라 동기 대기로 선택되면 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 기본에서 해당 대기의 응답 메시지는 다른 동기 대기의 응답 메시지와 함께 고려되어 커미트 레코드가 수신되었다는 확인을 기다리는 트랜잭션을 릴리스 할시기를 결정합니다. 이 매개 변수를 사용하여 관리자는 동기 대기 여야하는 대기 서버를 지정할 수 있습니다. 동기식 복제 구성은 주로 마스터에 있습니다. 명명 된 대기는 마스터에 직접 연결해야합니다. 마스터는 계단식 복제를 사용하는 다운 스트림 대기 서버에 대해 아무것도 모릅니다.</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">조회가 출력 테이블을 생성 한 후 (선택 목록이 처리 된 후) 선택적으로 정렬 될 수 있습니다. 정렬을 선택하지 않으면 행이 지정되지 않은 순서로 반환됩니다. 이 경우 실제 순서는 스캔 및 결합 계획 유형 및 디스크 순서에 따라 달라 지지만 의존해서는 안됩니다. 정렬 단계가 명시 적으로 선택된 경우에만 특정 출력 순서를 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">시퀀스가 작성된 후 &lt;code&gt;nextval&lt;/code&gt; , &lt;code&gt;currval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 함수를 사용 하여 시퀀스에서 작동합니다. 이 기능은 &lt;a href=&quot;functions-sequence&quot;&gt;9.16 절&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">인덱스가 작성된 후 시스템은 테이블과 동기화 된 상태를 유지해야합니다. 이것은 데이터 조작 작업에 오버 헤드를 추가합니다. 따라서 드물거나 쿼리에 사용되지 않은 인덱스는 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">테스트를 완료 한 후 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 매개 변수 를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">의 파티션을 생성 한 후 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 을 , 데이터가 삽입 &lt;code&gt;measurement&lt;/code&gt; 에 매핑 &lt;code&gt;measurement_y2006m02&lt;/code&gt; (또는 직접 삽입 데이터 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 를 , 그것을 만족 그 파티션 제약 제공) 상기 기반으로 파티션 중 하나에 리다이렉트한다 &lt;code&gt;peaktemp&lt;/code&gt; 의 칼럼. 지정된 파티션 키는 부모의 파티션 키와 겹칠 수 있지만 하위 파티션의 경계를 지정할 때는주의해야합니다. 따라서 허용되는 데이터 세트가 파티션 자체의 경계가 허용하는 것의 일부를 구성합니다. 시스템은 실제로 그런지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">함수를 만든 후 트리거 함수를 호출하는 트리거를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">해당 파일을 수정 한 후 새 설정을 적용하려면 재부팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 필터를 전달하면 파생 된 입력 테이블이 &lt;code&gt;GROUP BY&lt;/code&gt; 절을 사용하여 그룹화 되고 &lt;code&gt;HAVING&lt;/code&gt; 절을 사용하여 그룹 행이 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">유효한 WAL의 끝에 도달 한 후 새 WAL이 나타나도록 초당 폴링을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">새 바이너리를 다시 컴파일하고 실행 한 후 다음 DTrace 명령을 실행하여 새로 추가 된 프로브를 사용할 수 있는지 확인하십시오. 비슷한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">백업을 복원 한 후 각 데이터베이스 에서 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행 하여 쿼리 최적화 프로그램이 유용한 통계를 얻는 것이 좋습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은. PostgreSQL에 대량의 데이터를 효율적으로로드하는 방법에 대한 자세한 내용 &lt;a href=&quot;populate&quot;&gt;은 14.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">저장 점으로 롤백 한 후에는 저장 점이 계속 정의되므로 여러 번 롤백 할 수 있습니다. 반대로, 특정 세이브 포인트로 다시 롤백 할 필요가 없다고 확신하면이를 해제하여 시스템이 일부 자원을 해제 할 수 있습니다. 저장 점을 해제하거나 롤백하면 롤백 후에 정의 된 모든 저장 점이 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">이 명령을 실행 한 후에는 서버를 시작할 수 있지만 부분적으로 커밋 된 트랜잭션으로 인해 데이터베이스에 일치하지 않는 데이터가 포함될 수 있습니다. 즉시 데이터를 덤프 하고 &lt;code&gt;initdb&lt;/code&gt; 를 실행 한 후 다시로드해야합니다. 다시로드 한 후 불일치를 확인하고 필요에 따라 복구하십시오.</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">&lt;code&gt;auth-method&lt;/code&gt; 필드 뒤에는 인증 방법에 대한 옵션을 지정하는 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 형식의 필드가있을 수 있습니다 . 어떤 인증 방법에 사용할 수있는 옵션에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 처리 가 완료되면 파생 된 가상 테이블의 각 행이 검색 조건과 비교하여 점검됩니다. 조건의 결과가 true이면 행이 출력 테이블에 유지되고, 그렇지 않으면 (예 : 결과가 false 또는 null 인 경우) 삭제됩니다. 검색 조건은 일반적으로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 생성 된 테이블의 하나 이상의 열을 참조합니다 . 이것은 필수는 아니지만 &lt;code&gt;WHERE&lt;/code&gt; 절은 상당히 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">선택 목록이 처리 된 후 결과 테이블에 선택적으로 중복 행이 제거 될 수 있습니다. &lt;code&gt;DISTINCT&lt;/code&gt; 키워드는 바로 후 작성 &lt;code&gt;SELECT&lt;/code&gt; 는 이를 지정할 수 :</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">이 명령이 실행 된 후에는 색인이 일반 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;ADD UNIQUE&lt;/code&gt; 명령으로 작성된 것과 같은 방식으로 제한 조건이 색인을 &quot;소유&quot;합니다 . 특히 제약 조건을 삭제하면 인덱스도 사라집니다.</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">pg_stop_backup (수퍼 유저 또는 함수에서 EXECUTE가 부여 된 사용자)을 실행할 권한이있는 사용자로 데이터베이스에 다시 연결하고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">다시 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 절 조건을 검사하고 &lt;code&gt;=&lt;/code&gt; 에 대한 선택성 함수 인 &lt;code&gt;eqsel&lt;/code&gt; 을 찾습니다 . 등식 추정을 위해 히스토그램은 유용하지 않습니다. 대신에 &lt;em&gt;가장 일반적인 값&lt;/em&gt; (MCV) 목록이 선택성을 결정하는 데 사용됩니다. 나중에 유용 할 몇 가지 추가 열이있는 MCV를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">다시 한 번 더 현실적인 예 :</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">다시 테이블 별칭이 필요합니다. &lt;code&gt;VALUES&lt;/code&gt; 목록 의 열에 별명을 지정하는 것은 선택 사항이지만 좋은 방법입니다. 자세한 정보는 &lt;a href=&quot;queries-values&quot;&gt;7.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">다시 말하지만,이 명령 중 일부는 기본에서 &quot;읽기 전용&quot;모드 트랜잭션 중에 실제로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">다시, &lt;code&gt;uppercase&lt;/code&gt; 는 생략되었으므로 암시 적 으로 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . 명명 된 표기법을 사용하면 다음과 같은 순서로 인수를 지정할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">집계 함수는 확장입니다.</target>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;부분 모드&lt;/em&gt; 를 지원하는 집계 함수 는 병렬 집계와 같은 다양한 최적화에 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">집계 함수 (있는 경우)는 각 그룹을 구성하는 모든 행에서 계산되어 각 그룹에 대해 별도의 값을 생성합니다. 집계 함수가 있지만 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없는 경우 쿼리는 선택한 모든 행을 포함하는 단일 그룹을 갖는 것으로 처리됩니다. 각 집계 함수에 공급되는 행 세트는 집계 함수에 &lt;code&gt;FILTER&lt;/code&gt; 절을 첨부하여 추가로 필터링 할 수 있습니다. 요구; 참조 &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;섹션 4.2.7을&lt;/a&gt; 자세한 내용은. 때 &lt;code&gt;FILTER&lt;/code&gt; 절이이를 일치 행만 그 집계 함수에 대한 입력으로 포함된다.</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">집계 종류 : &lt;code&gt;n&lt;/code&gt; &quot;정상적인&quot;집계에 대한 &lt;code&gt;o&lt;/code&gt; &quot;주문 - 세트&quot;에 대한 집계, 또는 &lt;code&gt;h&lt;/code&gt; &quot;가상 세트&quot;골재</target>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">집계 : 그룹화</target>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">집계 : array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">집계 : 평균</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">집계 : bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">집계 : bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">집계 : bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">집계 : bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">집계 : corr</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">집계 : 개수</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">집계 : covar_pop</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">집계 : covar_samp</target>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">집계 : cume_dist WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 dense_rank</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">집계 : 모든</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">집계 : json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">집계 : json_object_agg</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">집계 : jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">집계 : jsonb_object_agg</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">집계 : 최대</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">집계 : 분</target>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내 모드</target>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 percent_rank</target>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">집계 : percentile_cont WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 percentile_disc</target>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내 순위</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">집계 : regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">집계 : regr_avgy</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">집계 : regr_count</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">집계 : regr_intercept</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">집계 : regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">집계 : regr_slope</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">집계 : regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">집계 : regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">집계 : regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">집계 : stddev</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">집계 : stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">집계 : stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">집계 : string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">집계 : 합계</target>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">집계 : var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">집계 : var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">집계 : 분산</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">집계 : xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">집계 된 인수 유형</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">집계 로깅</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">집계는 &lt;code&gt;GROUP BY&lt;/code&gt; 절 과 함께 사용하면 매우 유용 합니다. 예를 들어, 각 도시에서 관찰되는 최대 저온을 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; 또는 &lt;code&gt;MAX&lt;/code&gt; 처럼 동작하는 집계는 모든 입력 행을 스캔하는 대신 인덱스를 조사하여 최적화 할 수 있습니다. 이 집계를 최적화 할 수 있으면 &lt;em&gt;정렬 연산자&lt;/em&gt; 를 지정하여 표시하십시오 . 기본 요구 사항은 집계가 연산자에 의해 유도 된 정렬 순서의 첫 번째 요소를 산출해야한다는 것입니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">원인이 무엇이든 관계없이 적극적인 &lt;code&gt;VACUUM&lt;/code&gt; 스캔은 해당 테이블의 값을 향상시킬 수 있습니다. 결국 모든 데이터베이스의 모든 테이블이 스캔되고 가장 오래된 multixact 값이 향상됨에 따라 오래된 multixact에 대한 디스크상의 스토리지를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">튜플을 적극적으로 &quot;동결&quot;시킵니다.</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , 모스크바, Postgres Professional, 러시아</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, 모스크바, 러시아</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">모든 &lt;code&gt;pgcrypto&lt;/code&gt; 기능은 데이터베이스 서버 내에서 실행됩니다. 즉, 모든 데이터와 비밀번호 는 일반 텍스트로 &lt;code&gt;pgcrypto&lt;/code&gt; 와 클라이언트 애플리케이션 간에 이동 합니다. 따라서 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; 이외의 모든 &lt;code&gt;storage&lt;/code&gt; 값 은 &lt;a href=&quot;storage-toast&quot;&gt;섹션 68.2&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;섹션 37.13.1에&lt;/a&gt; 설명 &lt;em&gt;된&lt;/em&gt; 대로 데이터 유형의 기능이 &lt;em&gt;토스트 된&lt;/em&gt; 값을 처리 할 수 ​​있음을 의미합니다 . 주어진 다른 특정 값은 단순히 토스트 가능한 데이터 유형의 열에 대한 기본 TOAST 스토리지 전략을 결정합니다. 사용자는 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; 를 사용하여 개별 열에 대한 다른 전략을 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">모든 권한</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">모든 UPC, ISBN, ISMN 및 ISSN 번호는 EAN13 번호로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">백업에 필요한 모든 WAL 레코드에는 충분한 전체 페이지 쓰기가 포함되어 있어야 하므로 마스터에서 &lt;code&gt;full_page_writes&lt;/code&gt; 를 활성화 하고 pg_compresslog와 같은 도구를 &lt;code&gt;archive_command&lt;/code&gt; 로 사용하여 WAL 파일에서 전체 페이지 쓰기를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">모든 인수는 순서대로 지정됩니다. &lt;code&gt;uppercase&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 지정 되므로 결과는 대문자 입니다 . 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; 절로 명시 적으로 지정하지 않는 한 상위 테이블의 모든 점검 제한 조건 및 널이 아닌 제한 조건은 해당 하위 테이블에서 자동으로 상속됩니다 . 다른 유형의 제약 조건 (고유, 기본 키 및 외래 키 제약 조건)은 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">모든 열은 기본값으로 채워집니다. ( 이 양식에서는 &lt;code&gt;OVERRIDING&lt;/code&gt; 절이 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">제약 조건 제외 중에 부모 테이블의 모든 자식에 대한 모든 제약 조건이 검사되므로 많은 수의 자식이 쿼리 계획 시간을 상당히 늘릴 수 있습니다. 따라서 레거시 상속 기반 파티셔닝은 최대 100 개의 자식 테이블과 잘 작동합니다. 수천 명의 아이들을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">이 세션에 대한 모든 현재 청취 등록이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">현재 사용 가능한 모든 준비된 트랜잭션이 &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; 시스템보기에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 목록의 모든 요소 가 계산됩니다. ( &lt;code&gt;FROM&lt;/code&gt; 목록의 각 요소 는 실제 또는 가상 테이블입니다.) &lt;code&gt;FROM&lt;/code&gt; 목록 에 둘 이상의 요소가 지정된 경우 서로 결합됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">설치에 영향을주는 경우 모든 실패, 재 구축 및 재 인덱싱 사례가 pg_upgrade에 의해보고됩니다. 테이블 및 인덱스를 다시 빌드하기위한 업그레이드 후 스크립트가 자동으로 생성됩니다. 많은 클러스터의 업그레이드를 자동화하려는 경우 데이터베이스 스키마가 동일한 클러스터는 모든 클러스터 업그레이드에 대해 동일한 업그레이드 후 단계가 필요합니다. 업그레이드 후 단계는 사용자 데이터가 아닌 데이터베이스 스키마를 기반으로하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">인덱스 정의에 사용 된 모든 함수와 연산자는 &quot;불변&quot;이어야합니다. 즉, 결과는 인수에만 의존해야하며 외부 영향 (예 : 다른 테이블의 내용 또는 현재 시간)에 의존해서는 안됩니다. 이 제한은 인덱스의 동작이 잘 정의되도록합니다. 인덱스 표현식 또는 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 사용자 정의 함수를 사용하려면 함수를 작성할 때 변경 불가능한 것으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">PostgreSQL의 모든 인덱스는 &lt;em&gt;보조&lt;/em&gt; 인덱스이므로 각 인덱스는 테이블의 기본 데이터 영역 ( PostgreSQL 용어 에서는 테이블 &lt;em&gt;힙&lt;/em&gt; 이라고 함)과 별도로 저장됩니다 . 즉, 일반 인덱스 스캔에서 각 행 검색에는 인덱스와 힙 모두에서 데이터를 가져와야합니다. 또한 주어진 색인 작성 가능 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 일치하는 색인 ​​항목 은 일반적으로 색인에서 서로 가깝지만 참조하는 테이블 행은 힙의 어느 곳에 나있을 수 있습니다. 따라서 인덱스 스캔의 힙 액세스 부분은 힙에 대한 많은 임의 액세스를 포함하며, 이는 특히 전통적인 회전 미디어에서 느릴 수 있습니다. ( &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;11.5 절에&lt;/a&gt; 설명 된대로비트 맵 스캔은 힙 액세스를 정렬 된 순서대로 수행하여이 비용을 완화하려고하지만 지금까지만 진행됩니다.)</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">BRIN 액세스 방법을 작동시키기 위해서는 인덱스에 저장된 요약 값의 동작과 스캔 키와의 상호 작용 방식을 정의하는 몇 가지 사용자 정의 방법을 구현해야합니다. 간단히 말해 BRIN은 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">GIN 액세스 방법을 작동시키기 위해서는 트리에서 키의 동작과 키, 인덱싱 된 항목 및 인덱싱 가능한 쿼리 간의 관계를 정의하는 몇 가지 사용자 정의 방법을 구현해야합니다. 간단히 말해 GIN은 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">GiST 액세스 방법을 시작하고 실행하는 데 필요한 것은 트리에서 키의 동작을 정의하는 몇 가지 사용자 정의 방법을 구현하는 것입니다. 물론 이러한 메소드는 멋진 쿼리를 지원하기에는 꽤 멋지지만 모든 표준 쿼리 (B- 트리, R- 트리 등)는 비교적 간단합니다. 간단히 말해, GiST는 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">PostgreSQL 서버에서 생성 된 모든 메시지에는 &quot;SQLSTATE&quot;코드에 대한 SQL 표준 규칙을 따르는 5 자리 오류 코드가 할당됩니다. 어떤 오류 조건이 발생했는지 알아야하는 응용 프로그램은 일반적으로 텍스트 오류 메시지를 보지 않고 오류 코드를 테스트해야합니다. 오류 코드는 PostgreSQL 릴리스에서 변경 될 가능성이 적으며 오류 메시지의 현지화로 인해 변경되지 않을 수도 있습니다. PostgreSQL에 의해 생성 된 일부는 아니지만 일부 오류 코드는 SQL 표준에 의해 정의됩니다. 표준에 의해 정의되지 않은 조건에 대한 일부 추가 오류 코드는 다른 데이터베이스에서 발명되었거나 빌려 왔습니다.</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">이 전에 모든 멀티 플렉스 ID는이 테이블에서 트랜잭션 ID로 대체되었습니다. 멀티 플렉스 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_multixact&lt;/code&gt; 를 축소 하기 위해 테이블을 정리해야하는지 여부를 추적하는 데 사용됩니다 . 관계가 테이블이 아닌 경우 0 ( &lt;code&gt;InvalidMultiXactId&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">이 ID 이전의 모든 멀티 플렉스 ID는이 데이터베이스에서 트랜잭션 ID로 대체되었습니다. 멀티 플렉스 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_multixact&lt;/code&gt; 를 축소 하기 위해 데이터베이스를 정리해야하는지 여부를 추적하는 데 사용됩니다 . 테이블 당 &lt;code&gt;pg_class&lt;/code&gt; 의 최소값입니다 . &lt;code&gt;relminmxid&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">네임 스페이스별로 그룹화 된 오브젝트의 모든 OID 별명 유형은 스키마 규정 된 이름을 승인하며, 오브젝트가 규정되지 않고 현재 검색 경로에서 찾을 수없는 경우 출력에 스키마 규정 된 이름을 표시합니다. &lt;code&gt;regproc&lt;/code&gt; 와 &lt;code&gt;regoper&lt;/code&gt; 별칭 유형은 그들 만이 사용이 제한되어 있으므로, (과부하되지 않음) 고유 입력 이름을 받아 들일 것입니다; 대부분의 경우 &lt;code&gt;regprocedure&lt;/code&gt; 또는 &lt;code&gt;regoperator&lt;/code&gt; 가 더 적합합니다. 들어 &lt;code&gt;regoperator&lt;/code&gt; , 단항 연산자는 작성하지에 의해 식별됩니다 &lt;code&gt;NONE&lt;/code&gt; 을 사용하지 않은 피연산자.</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;표 9.60&lt;/a&gt; 에 나열된 모든 함수 는 연관된 창 정의 의 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 정렬 순서에 따라 다릅니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 열만 고려할 때 고유하지 않은 행은 &lt;em&gt;피어&lt;/em&gt; 라고합니다 . 4 개의 순위 함수 ( &lt;code&gt;cume_dist&lt;/code&gt; 포함 )는 모든 피어 행에 대해 동일한 답변을 제공하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">&lt;code&gt;convert-crlf&lt;/code&gt; 를 제외한 모든 옵션 은 암호화 기능에만 적용됩니다. 암호 해독 기능은 PGP 데이터에서 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">지금까지 구성된 모든 정책은 허용 가능한 정책으로, 여러 정책이 적용될 때 &quot;OR&quot;부울 연산자를 사용하여 결합됩니다. 허용되는 정책은 의도 된 경우에만 행에 대한 액세스 만 허용하도록 구성 할 수 있지만 허용 정책을 제한적인 정책 (레코드가 통과해야하고 &quot;AND&quot;부울 연산자를 사용하여 결합 된)과 결합하는 것이 더 간단 할 수 있습니다. 위의 예를 바탕으로 관리자가 로컬 Unix 소켓을 통해 &lt;code&gt;passwd&lt;/code&gt; 테이블 의 레코드에 액세스하도록 제한하는 정책을 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">이 모든 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 행의 복합 값을 지정하여 &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;9.23.6 절에&lt;/a&gt; 설명 된 규칙에 따라 행을 정렬합니다 . 그러나 &lt;code&gt;inventory_item&lt;/code&gt; 에 &lt;code&gt;c&lt;/code&gt; 라는 열이 포함 된 경우 첫 번째 경우는 해당 열만 기준으로 정렬되므로 다른 경우와 다릅니다. 이전에 표시된 열 이름이 주어지면 이러한 쿼리는 위의 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">&lt;code&gt;commonName&lt;/code&gt; 을 제외한 이러한 모든 필드는 선택 사항 입니다. 이는 전적으로 포함되거나 포함되지 않는 CA 정책에 따라 다릅니다. 그러나이 필드의 의미는 X.500 및 X.509 표준에 의해 엄격하게 정의되므로 임의의 의미를 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">제공된 배열에 NULL 요소가 포함되어 있으면 이러한 모든 작업에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">다른 모든 매개 변수는 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">모든 매개 변수 이름은 대소 문자를 구분하지 않습니다. 모든 매개 변수는 부울, 문자열, 정수, 부동 소수점 또는 열거 형 (열)의 다섯 가지 유형 중 하나의 값을 갖습니다. 유형에 따라 매개 변수 설정 구문이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 목록의 모든 쿼리 가 계산됩니다. 이들은 효과적으로 &lt;code&gt;FROM&lt;/code&gt; 목록 에서 참조 할 수있는 임시 테이블 역할을 합니다. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 로 달리 지정하지 않으면 &lt;code&gt;FROM&lt;/code&gt; 에서 두 번 이상 참조 되는 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 한 번만 계산됩니다 . (아래 &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt; &lt;code&gt;WITH&lt;/code&gt; &lt;/a&gt; 절 참조)</target>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">임시 테이블의 모든 행은 각 트랜잭션 블록의 끝에서 삭제됩니다. 기본적으로 자동 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE는&lt;/a&gt; 각 커밋에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">임시 테이블의 모든 행은 각 트랜잭션 블록의 끝에서 삭제됩니다. 기본적으로 자동 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE는&lt;/a&gt; 각 커밋에서 수행됩니다. 파티션 된 테이블에서 사용될 때는 파티션에 계단식으로 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">파티션 테이블에 삽입 된 모든 행은 하나에 라우팅 될 것이다 &lt;em&gt;파티션&lt;/em&gt; 분할 키의 값에 기초하여. 각 파티션에는 &lt;em&gt;파티션 경계에&lt;/em&gt; 의해 정의 된 데이터의 하위 집합이 있습니다. 현재 지원되는 분할 방법은 범위, 목록 및 해시입니다.</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">모든 표준 및 미리 정의 된 데이터 정렬은 결정적이며 모든 사용자 정의 데이터 정렬은 기본적으로 결정적입니다. 비 결정적 데이터 정렬은 특히 유니 코드의 강력한 기능과 많은 특수한 경우를 고려할 때보다 &quot;올바른&quot;동작을 제공하지만 몇 가지 단점이 있습니다. 무엇보다 성능이 저하됩니다. 또한 패턴 일치 작업과 같은 비 결정적 데이터 정렬에서는 특정 작업을 수행 할 수 없습니다. 따라서 이들은 특별히 원하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">현재 트랜잭션의 모든 명령문은이 트랜잭션에서 첫 번째 쿼리 또는 데이터 수정 명령문이 실행되기 전에 커밋 된 행만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">현재 트랜잭션의 모든 명령문은이 트랜잭션에서 첫 번째 쿼리 또는 데이터 수정 명령문이 실행되기 전에 커밋 된 행만 볼 수 있습니다. 동시 직렬화 가능 트랜잭션 간의 읽기 및 쓰기 패턴이 해당 트랜잭션의 직렬 (한 번에 한 번) 실행에 대해 발생할 수없는 상황을 작성하는 경우 그 중 하나가 &lt;code&gt;serialization_failure&lt;/code&gt; 오류 와 함께 롤백됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">모든 시스템에는 동일한 &lt;code&gt;shared.conf&lt;/code&gt; 가 있습니다. 특정 양의 메모리를 가진 각 서버는 동일한 &lt;code&gt;memory.conf&lt;/code&gt; 를 공유 할 수 있습니다 . RAM이 8GB 인 모든 서버에 대해 하나, 16GB가있는 서버에 대해 하나를 가질 수 있습니다. 마지막으로 &lt;code&gt;server.conf&lt;/code&gt; 에는 서버 별 구성 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">모든 테이블 행은 동일한 방식으로 구성됩니다. 고정 크기 헤더 (대부분의 컴퓨터에서 23 바이트를 차지함)와 선택적 널 비트 맵, 선택적 오브젝트 ID 필드 및 사용자 데이터가 있습니다. 헤더는 &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;표 68.4에&lt;/a&gt; 자세히 설명되어 있습니다. 실제 사용자 데이터 (행 열)는 &lt;code&gt;t_hoff&lt;/code&gt; 로 표시되는 오프셋에서 시작하며 , 플랫폼에 대한 MAXALIGN 거리의 배수 여야합니다. 경우 생성 널 비트 맵은 존재 &lt;em&gt;HEAP_HASNULL의&lt;/em&gt; 비트가 설정된다 &lt;code&gt;t_infomask&lt;/code&gt; . 존재하는 경우 고정 헤더 바로 다음부터 시작하여 데이터 &lt;code&gt;t_infomask2&lt;/code&gt; 하나의 비트 (즉, t_infomask2 의 속성 수와 동일한 비트 수)를 갖기에 충분한 바이트를 차지합니다.). 이 비트 목록에서 1 비트는 널이 아님을 나타내고 0 비트는 널입니다. 비트 맵이 없으면 모든 열이 널이 아닌 것으로 간주됩니다. 경우 생성 오브젝트 ID 만 존재 &lt;em&gt;HEAP_HASOID_OLD의&lt;/em&gt; 비트가 설정된다 &lt;code&gt;t_infomask&lt;/code&gt; . 있는 경우 &lt;code&gt;t_hoff&lt;/code&gt; 경계 바로 앞에 나타납니다 . &lt;code&gt;t_hoff&lt;/code&gt; 를 MAXALIGN 배수로 만드는 데 필요한 패딩 은 널 비트 맵과 객체 ID 사이에 나타납니다. (이는 차례로 객체 ID가 적절하게 정렬되도록합니다.)</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; 양식 을 사용하여 테이블 스페이스에있는 현재 데이터베이스의 모든 테이블을 이동할 수 있습니다.이 테이블은 모든 테이블을 먼저 이동시킨 다음 각 테이블을 이동시킵니다. 이 양식은 또한 지정된 역할이 소유 한 테이블 만 이동하는 &lt;code&gt;OWNED BY&lt;/code&gt; 를 지원 합니다. 는 IF &lt;code&gt;NOWAIT&lt;/code&gt; 의 옵션이 지정되는 즉시 필요한 잠금을 모두 취득 할 수없는 경우 명령이 실패합니다. 시스템 카탈로그는이 명령으로 이동되지 않습니다. 사용 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 또는 명시 적 &lt;code&gt;ALTER TABLE&lt;/code&gt; 호출하는 대신 원하는 경우. &lt;code&gt;information_schema&lt;/code&gt; 관계는 시스템 카탈로그의 일부로 간주되지 않으며 이동합니다. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">모든 GiST 지원 방법은 일반적으로 수명이 짧은 메모리 컨텍스트에서 호출됩니다. 즉, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 는 각 튜플이 처리 된 후에 재설정됩니다. 그러므로 당신이 palloc하는 모든 것을 pfree'ing하는 것에 대해 걱정하는 것은 그리 중요하지 않습니다. 그러나 어떤 경우에는 지원 메소드가 반복 호출을 통해 데이터를 캐시하는 것이 유용합니다. 이를 위해에서 더 이상 수명이 데이터 할당 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; 을 , 그리고에 대한 포인터를 유지 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; . 이러한 데이터는 인덱스 작업 수명 동안 유지됩니다 (예 : 단일 GiST 인덱스 스캔, 인덱스 빌드 또는 인덱스 튜플 삽입). &lt;code&gt;fn_extra&lt;/code&gt; 값을 교체 할 때 이전 값을 고정 시키십시오. 그렇지 않으면 작동 시간 동안 누수가 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">모든 SP-GiST 지원 방법은 일반적으로 수명이 짧은 메모리 컨텍스트에서 호출됩니다. 즉, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 는 각 튜플을 처리 한 후에 재설정됩니다. 그러므로 당신이 palloc하는 모든 것을 pfree'ing하는 것에 대해 걱정하는 것은 그리 중요하지 않습니다. ( &lt;code&gt;config&lt;/code&gt; 메소드는 예외입니다 : 메모리 누수를 피하려고 노력해야합니다. 그러나 일반적으로 &lt;code&gt;config&lt;/code&gt; 메소드는 전달 된 매개 변수 struct에 상수를 지정할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 및 &lt;code&gt;SET SCHEMA&lt;/code&gt; 를 제외한 모든 조치 를 여러 변경 사항 목록으로 결합하여 동시에 적용 할 수 있습니다. 예를 들어, 단일 명령으로 여러 열을 추가하거나 여러 열의 유형을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;표 9.57에&lt;/a&gt; 나열된 모든 집계 는 정렬 된 입력에서 널값을 무시합니다. 테이크 그들을 위해 &lt;code&gt;fraction&lt;/code&gt; 파라미터를, 분수 값은 0과 1 사이 여야; 그렇지 않은 경우 오류가 발생합니다. 그러나 널 분수 값은 단순히 널 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">주어진 조건부 블록의 모든 백 슬래시 명령은 동일한 소스 파일에 나타나야합니다. 모든 로컬 &lt;code&gt;\if&lt;/code&gt; -block을 닫기 전에 기본 입력 파일 또는 &lt;code&gt;\include&lt;/code&gt; -ed 파일 에서 EOF에 도달 하면 psql에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">색인을 참조하는 모든 제한 조건이 새 색인 정의를 참조하도록 변경되고 색인 이름이 변경됩니다. 이 시점에서 &lt;code&gt;pg_index.indisvalid&lt;/code&gt; 는 새 인덱스의 경우 &quot;true&quot;로, 이전 인덱스의 경우 &quot;false&quot;로 전환되고 캐시 무효화가 수행되어 이전 인덱스를 참조한 모든 세션이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">모든 날짜 / 시간 데이터 유형은 &lt;code&gt;now&lt;/code&gt; 특수한 리터럴 값을 수락 하여 현재 날짜 및 시간을 지정합니다 (다시 말해 트랜잭션 시작 시간으로 해석 됨). 따라서 다음 세 가지 모두 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">모든 세부 사항은 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">모든 세부 사항은 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; , &lt;code&gt;SET SCHEMA&lt;/code&gt; , &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 및 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 을 제외한 단일 테이블에서 작동하는 ALTER TABLE의 모든 양식을 여러 변경 사항 목록으로 결합하여 함께 적용 할 수 있습니다. 예를 들어, 단일 명령으로 여러 열을 추가하거나 여러 열의 유형을 변경할 수 있습니다. 테이블을 한 번만 통과하면되므로 큰 테이블에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">아래에 설명 된 &lt;code&gt;time&lt;/code&gt; 또는 &lt;code&gt;timestamp&lt;/code&gt; 입력 을받는 모든 함수와 연산자는 실제로 두 가지 변형이 있습니다. 하나는 &lt;code&gt;time with time zone&lt;/code&gt; 이 걸리 거나 &lt;code&gt;timestamp with time zone&lt;/code&gt; 이 걸리고 다른 하나는 &lt;code&gt;time without time zone&lt;/code&gt; 또는 &lt;code&gt;timestamp without time zone&lt;/code&gt; 입니다. 간결하게하기 위해 이러한 변형은 별도로 표시되지 않습니다. 또한 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 연산자는 교환 쌍으로 제공됩니다 (예 : 날짜 + 정수 및 정수 + 날짜). 각 쌍 중 하나만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">의 모든 항목 &lt;code&gt;path&lt;/code&gt; 의 매개 변수 &lt;code&gt;jsonb_set&lt;/code&gt; 뿐만 아니라 &lt;code&gt;jsonb_insert&lt;/code&gt; 마지막 항목을 제외하고는에 있어야합니다 &lt;code&gt;target&lt;/code&gt; . 경우 &lt;code&gt;create_missing&lt;/code&gt; 은 거짓,의 모든 항목 &lt;code&gt;path&lt;/code&gt; 의 매개 변수 &lt;code&gt;jsonb_set&lt;/code&gt; 이 있어야합니다. 이러한 조건이 충족되지 않으면 &lt;code&gt;target&lt;/code&gt; 이 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">다른 모든 세부 사항은 이전 항목에서 설명한 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">선택적 &lt;code&gt;regconfig&lt;/code&gt; 인수 를 허용하는 모든 텍스트 검색 함수는 해당 인수가 생략 될 때 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config에&lt;/a&gt; 의해 지정된 구성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">이 모든 조치는 참조 페이지에 여기에 제공된 것 이외의 세부 사항이 포함 된 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">이러한 모든 기능에는 검사 할 개체를 식별하기 위해 개체 OID가 필요합니다. 이름으로 객체를 테스트하려면 다음과 같이 OID 별명 유형 ( &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; 또는 &lt;code&gt;regdictionary&lt;/code&gt; ) 을 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">이 모든 것이 세션 키로 암호화되어 데이터 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">이 모든 것은 트랜잭션 블록 내에서 일어나므로 다른 데이터베이스 세션에서는 볼 수 없습니다. 트랜잭션 블록을 커밋 할 때 커밋 된 작업은 다른 세션에 대한 단위로 표시되지만 롤백 된 작업은 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">모든 시간대 인식 날짜 및 시간은 내부적으로 UTC로 저장됩니다. 클라이언트에 표시되기 전에 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 구성 매개 변수로 지정된 영역에서 현지 시간으로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">이 데이터베이스 이전의 모든 트랜잭션 ID는이 데이터베이스에서 영구 ( &quot;동결 된&quot;) 트랜잭션 ID로 대체되었습니다. 트랜잭션 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_xact&lt;/code&gt; 를 축소 하기 위해 데이터베이스를 정리해야하는지 여부를 추적하는 데 사용됩니다 . 테이블 당 &lt;code&gt;pg_class&lt;/code&gt; 의 최소값입니다 . &lt;code&gt;relfrozenxid&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">이 테이블 이전의 모든 트랜잭션 ID는이 테이블에서 영구 ( &quot;동결 된&quot;) 트랜잭션 ID로 대체되었습니다. 트랜잭션 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_xact&lt;/code&gt; 를 축소 하기 위해 테이블을 정리해야하는지 여부를 추적하는 데 사용됩니다 . 관계가 테이블이 아닌 경우 0 ( &lt;code&gt;InvalidTransactionId&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">모든 유형 변환 규칙은 몇 가지 원칙을 염두에두고 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">모든 값은 작은 따옴표로 묶어야합니다. 백 슬래시로 값 내에 사용 된 작은 따옴표를 이스케이프 처리하십시오. 데이터가 의미하는 백 슬래시는 두 배가 될 수 있지만 반드시 그럴 필요는 없습니다. 이것은 간단한 인용 리터럴에 대한 Perl의 규칙을 따릅니다. 데이터로 나타나는 백 슬래시는 이스케이프 문자열 상수와 동일한 규칙에 따라 부트 스트랩 스캐너에 의해 이스케이프 처리됩니다 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;섹션 4.1.2.2&lt;/a&gt; 참조 ). 예를 들어 &lt;code&gt;\t&lt;/code&gt; 는 탭 문자로 변환됩니다. 실제로 최종 값에 백 슬래시를 원하면 4 개를 작성해야합니다. Perl은 2를 제거 하고 부트 스트랩 스캐너는 &lt;code&gt;\\&lt;/code&gt; 를 남겨 둡니다 .</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">Hayward에 속하는 모든 날씨 기록이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">모든 작업은 Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; )와 Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; )가 수행했습니다. 자세한 내용은 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; 를 참조 하십시오 . Andrey Oktyabrski는 새로운 기능과 작업을 추가하는 데 많은 노력을 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">모든 작업은 Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; )와 Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; )가 수행했습니다. 자세한 내용은 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; 를 참조 하십시오 . 도움을 주신 토론에 대해 Eugeny Rodichev에게 감사의 말씀을 전합니다. 의견 및 버그 리포트를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">데이터베이스 사용자가 서버 측 프로그램을 실행할 수있는 COPY 및 기타 기능과 마찬가지로 데이터베이스 서버에서 프로그램을 실행하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">호환성을 위해 물음표를 자리 표시 자로 허용하십시오. 이것은 오래 전의 기본값이었습니다.</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">COPY 및 기타 파일 액세스 기능을 사용하여 데이터베이스가 서버에서 액세스 할 수있는 모든 위치에서 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">무조건 연결을 허용하십시오. 이 방법을 사용하면 PostgreSQL 데이터베이스 서버에 연결할 수있는 누구나 암호 나 다른 인증 없이도 원하는 PostgreSQL 사용자로 로그인 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-trust&quot;&gt;은 20.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">COPY 및 기타 파일 액세스 기능을 사용하여 데이터베이스가 서버에서 액세스 할 수있는 모든 위치의 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">허용 된 액세스</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">열거 형 매개 변수의 허용 된 값 (비 열거 형 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">PG에서는 허용되지 않지만 허용됨</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">테이블, 뷰 등에서 행의 &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; 를 허용합니다 . 실제로 중요한 &lt;code&gt;DELETE&lt;/code&gt; 명령은 삭제할 행을 결정하기 위해 테이블 ​​열을 참조해야 하므로 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">수 있습니다 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 새로운 행의 등 테이블, 뷰에는 만 열이에 할당 할 수있는 경우에 특정 컬럼 (들)에 부여 할 수 있습니다 &lt;code&gt;INSERT&lt;/code&gt; 명령 (다른 컬럼은 기본 값을 따라서을 받게됩니다). 또한 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">테이블, 뷰, 구체화 된 뷰 또는 기타 테이블과 같은 객체의 열 또는 특정 열에서 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 허용 합니다. 또한 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO를 사용할 수 있습니다 . 이 권한은 또한 &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;sql-delete&quot;&gt;DELETE의&lt;/a&gt; 기존 열 값을 참조하는 데 필요합니다 . 시퀀스의 경우이 권한으로 &lt;code&gt;currval&lt;/code&gt; 함수를 사용할 수도 있습니다 . 큰 객체의 경우이 권한을 통해 객체를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">테이블, 뷰 등에서 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">테이블, 뷰 등의 모든 열 또는 특정 열에 대한 &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 를 허용합니다 . (실제로, 중요하지 않은 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 업데이트 할 행을 결정하기 위해 테이블 ​​열을 참조해야하기 때문에 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 합니다. 또는 열에 대한 새 값을 계산합니다.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; 에는 &lt;code&gt;SELECT&lt;/code&gt; 권한 외에 하나 이상의 열에 대해이 권한이 필요합니다 . 시퀀스의 경우이 권한으로 &lt;code&gt;nextval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 함수를 사용할 수 있습니다 . 큰 개체의 경우이 권한으로 개체를 쓰거나자를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">함수 위에 구현 된 연산자 사용을 포함하여 함수 또는 프로 시저를 호출 할 수 있습니다. 기능과 절차에 적용 할 수있는 유일한 권한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">테이블 또는 테이블의 특정 열을 참조하는 외래 키 제약 조건을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">테이블, 뷰 등에서 트리거를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 덜 일반적으로 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ) 과 같은 GSSAPI / Kerberos 프린시 펄의 경우 맵핑에 사용되는 사용자 이름은 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )입니다. &lt;code&gt;include_realm&lt;/code&gt; 이 0으로 설정 되지 않은 경우, &lt;code&gt;username&lt;/code&gt; (또는 &lt;code&gt;username/hostbased&lt;/code&gt; )은 맵핑시 시스템 사용자 이름으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 덜 일반적으로 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ) 과 같은 SSPI / Kerberos 프린시 펄의 경우 맵핑에 사용되는 사용자 이름은 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )입니다. &lt;code&gt;include_realm&lt;/code&gt; 이 0으로 설정 되지 않은 경우, &lt;code&gt;username&lt;/code&gt; (또는 &lt;code&gt;username/hostbased&lt;/code&gt; )은 맵핑시 시스템 사용자 이름으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">시스템 테이블의 구조를 수정할 수 있습니다. 이것은 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사용 됩니다 . 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">여러 마스터 서버를 허용</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">원격 클라이언트가 TCP / IP (인터넷 도메인) 연결을 통해 연결할 수 있도록합니다. 이 옵션이 없으면 로컬 연결 만 허용됩니다. 이 옵션을 설정하는 것과 같습니다 &lt;code&gt;listen_addresses&lt;/code&gt; 을 에 &lt;code&gt;*&lt;/code&gt; 에 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 또는를 통해 &lt;code&gt;-h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">데이터베이스를 사용하는 동안 임시 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">피부 여자가 데이터베이스에 연결할 수 있도록합니다. 이 권한은 연결 시작시 ( &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 의해 부과 된 제한 사항을 확인하는 것 외에) 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">리더 프로세스가 작업자 프로세스를 기다리지 않고 &lt;code&gt;Gather&lt;/code&gt; 및 &lt;code&gt;Gather Merge&lt;/code&gt; 노드 에서 쿼리 계획을 실행할 수 있습니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 이 값을 &lt;code&gt;off&lt;/code&gt; 로 설정 하면 리더가 충분히 빨리 튜플을 읽지 않기 때문에 작업자가 차단 될 가능성이 줄어들지 만 첫 번째 튜플이 생성되기 전에 작업자 프로세스가 시작될 때까지 리더 프로세스가 대기해야합니다. 리더가 성과를 돕거나 방해 할 수있는 정도는 계획 유형, 작업자 수 및 쿼리 기간에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">시스템 테이블의 구조를 수정할 수 있습니다. 이것은 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">성능상의 이점이없는 경우에도 테스트 목적으로 병렬 쿼리를 사용할 수 있습니다. &lt;code&gt;force_parallel_mode&lt;/code&gt; 의 허용 된 값 이 &lt;code&gt;off&lt;/code&gt; (성능을 향상시킬 것으로 예상되는 경우에만 병렬 모드 사용), &lt;code&gt;on&lt;/code&gt; (안전하다고 생각되는 모든 쿼리에 대해 병렬 쿼리 강제 실행) 및 &lt;code&gt;regress&lt;/code&gt; ( &lt;code&gt;on&lt;/code&gt; 과 같지만 추가 동작 변경) 아래에 설명).</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">클러스터 소유자와 동일한 그룹의 사용자가 &lt;code&gt;initdb&lt;/code&gt; 로 작성된 모든 클러스터 파일을 읽을 수 있도록합니다 . 이 옵션은 POSIX 스타일 그룹 권한을 지원하지 않으므로 Windows에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">PostgreSQL의 거의 모든 &lt;code&gt;DROP&lt;/code&gt; 명령은 &lt;code&gt;CASCADE&lt;/code&gt; 지정을 지원 합니다. 물론, 가능한 종속성의 특성은 객체의 유형에 따라 다릅니다. &lt;code&gt;CASCADE&lt;/code&gt; 대신 &lt;code&gt;RESTRICT&lt;/code&gt; 를 작성 하여 기본 동작을 얻을 수 있습니다. 이는 다른 객체가 의존하는 객체의 삭제를 방지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">또한 테스트 데이터를 구성 할 때는 응용 프로그램이 아직 프로덕션 환경에 있지 않은 경우 피할 수없는 경우가 있으므로주의하십시오. 매우 유사하거나 완전히 임의적이거나 정렬 된 순서로 삽입 된 값은 실제 데이터의 분포에서 통계를 왜곡합니다.</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">또한 옵티마이 저가 사용할 통계를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">또한 &lt;code&gt;timestamp&lt;/code&gt; 와 같은 일부 요소 유형 에는 &quot;무한대&quot;라는 개념이 있으며 이는 저장 될 수있는 또 다른 값일뿐입니다. 이것은 저장 될 수있는 실제 값이 아니라 &lt;code&gt;MINVALUE&lt;/code&gt; 및 &lt;code&gt;MAXVALUE&lt;/code&gt; 와 다르며 , 값이 제한되지 않는다고 말하는 방법입니다. &lt;code&gt;MAXVALUE&lt;/code&gt; 는 &quot;무한대&quot;를 포함하여 다른 값보다 큰 것으로 생각할 수 있으며 &quot; &lt;code&gt;MINVALUE&lt;/code&gt; 무한대&quot;를 포함하여 MINVALUE 는 다른 값보다 작은 것으로 생각할 수 있습니다 . 따라서 &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; 범위는 빈 범위가 아닙니다. &quot;무한대&quot;라는 정확히 하나의 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">다른 환경에서 변환하는 사람들에게는 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 가 동시 트랜잭션이 선택된 행을 업데이트하거나 삭제하지 않을 것이라는 사실에 유의 해야합니다. PostgreSQL에서 변경하려면 값을 변경할 필요가 없더라도 실제로 행을 업데이트해야합니다. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 는 다른 트랜잭션이 동일한 잠금을 획득하거나 잠긴 행에 영향을 줄 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 를 실행하는 것을 &lt;em&gt;일시적으로 차단&lt;/em&gt; 하지만,이 잠금을 보유한 트랜잭션이 커밋 또는 롤백되면 실제 &lt;code&gt;UPDATE&lt;/code&gt; 가 아닌 한 차단 된 트랜잭션이 충돌 작업을 진행 잠금이 유지되는 동안 행 중 하나가 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">또한 &lt;code&gt;INHERITS&lt;/code&gt; 와 달리 &lt;code&gt;LIKE&lt;/code&gt; 에서 복사 한 열 및 제약 조건 은 비슷한 이름의 열 및 제약 조건과 병합되지 않습니다. 동일한 이름이 명시 적으로 또는 다른 &lt;code&gt;LIKE&lt;/code&gt; 절에 지정되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">또한 단어 유사성 또는 엄격한 단어 유사성을 위해 &lt;code&gt;t&lt;/code&gt; 열의 색인을 사용할 수 있습니다 . 일반적인 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">또한 이 목적으로 표준 SQL 구문 &lt;code&gt;SET NAMES&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">또한 접두사 일치를 지정하기 위해 &lt;code&gt;*&lt;/code&gt; 를 lexeme에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">또한 GIN 인덱스는 &lt;code&gt;@@&lt;/code&gt; 및 &lt;code&gt;@?&lt;/code&gt; &lt;code&gt;jsonpath&lt;/code&gt; 일치 를 수행 하는 연산자 .</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">또한 접미사 일치 기능을 구현하려면 역방향 조회가 필요합니다. 실제 클라이언트 호스트 이름을 패턴과 일치시키기 위해서는 알 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">또한 트리거 정의는 부울 &lt;code&gt;WHEN&lt;/code&gt; 조건을 지정 하여 트리거가 발생해야하는지 여부를 테스트합니다. 행 수준 트리거에서 &lt;code&gt;WHEN&lt;/code&gt; 조건은 행 열의 이전 및 / 또는 새 값을 검사 할 수 있습니다. 명령문 레벨 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건을 가질 수도 있지만, 조건이 테이블의 값을 참조 할 수 없으므로이 기능은 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">또한 기본적으로 기능 선택에 대한 정보는 제한되어 있습니다. 그러나 함수 호출을 사용하는 표현식 인덱스를 작성하면 함수에 대한 유용한 통계가 수집되어 표현식 인덱스를 사용하는 쿼리 계획을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">또한 B- 트리 인덱스의 경우 새로 생성 된 인덱스는 논리적으로 인접한 페이지가 일반적으로 새로 작성된 인덱스에 물리적으로 인접하기 때문에 여러 번 업데이트 된 인덱스보다 액세스하는 데 약간 빠릅니다. B- 트리가 아닌 인덱스에는이 고려 사항이 적용되지 않습니다. 액세스 속도를 향상시키기 위해 정기적으로 인덱스를 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">또한, 자연 거리 메트릭이있는 데이터 유형의 경우 &lt;code&gt;btree_gist&lt;/code&gt; 는 거리 연산자 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 를 정의 하고이 연산자를 사용하여 가장 가까운 이웃 검색에 대한 GiST 인덱스 지원을 제공합니다. 거리 연산자는 &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; , &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 &lt;code&gt;timestamp without time zone&lt;/code&gt; , &lt;code&gt;time without time zone&lt;/code&gt; 타임 스탬프 , 시간대가없는 시간 , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; 및 &lt;code&gt;money&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">또한 준비된 트랜잭션을 사용하는 경우 &lt;code&gt;virtualtransaction&lt;/code&gt; &lt;code&gt;transaction&lt;/code&gt; 열을 &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; 뷰 의 트랜잭션 열에 조인하여 잠금을 보유한 준비된 트랜잭션에 대한 자세한 정보를 얻을 수 있습니다. 준비된 트랜잭션은 잠금을 기다릴 수 없지만 실행 중에 획득 한 잠금을 계속 보유합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">또한 &lt;code&gt;tsquery&lt;/code&gt; 의 lexemes에 접두사 일치를 지정하기 위해 &lt;code&gt;*&lt;/code&gt; 로 레이블 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">또한 &lt;code&gt;myschema&lt;/code&gt; 가 경로의 첫 번째 요소이므로 기본적으로 새 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">또한 일부 요소 유형에는 &quot;무한대&quot;라는 개념이 있지만 범위 유형 메커니즘에 관한 한 다른 값일뿐입니다. 예를 들어 타임 스탬프 범위에서 &lt;code&gt;[today,]&lt;/code&gt; 는 &lt;code&gt;[today,)&lt;/code&gt; 와 동일한 것을 의미합니다 . 그러나 &lt;code&gt;[today,infinity]&lt;/code&gt; 는 &lt;code&gt;[today,infinity)&lt;/code&gt; 와 다른 것을 의미 합니다. 후자는 특수 &lt;code&gt;timestamp&lt;/code&gt; 값 &lt;code&gt;infinity&lt;/code&gt; 를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">또한 시스템 카탈로그에는 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1) 인 행이 포함될 수 있으며 이는 initdb의 첫 번째 단계에서 삽입되었음을 나타냅니다. &lt;code&gt;FrozenTransactionId&lt;/code&gt; 와 마찬가지로이 특수 XID는 모든 일반 XID보다 오래된 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">또한 문자열 상수에 대한 유니 코드 이스케이프 구문은 구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 가 설정된 경우에만 작동 합니다. 그렇지 않으면이 구문은 SQL 문을 구문 분석하는 클라이언트가 SQL 삽입 및 유사한 보안 문제로 이어질 수있는 지점을 혼동시킬 수 있기 때문입니다. 매개 변수가 off로 설정되면이 구문은 오류 메시지와 함께 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">또한 SQL 표준 에는 &lt;code&gt;public&lt;/code&gt; 스키마 개념이 없습니다 . 표준을 최대한 준수하려면 &lt;code&gt;public&lt;/code&gt; 스키마를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">또한 병렬 계획 내에서 사용될 때 부분 하위 만 가질 수 있는 일반 &lt;code&gt;Append&lt;/code&gt; 노드 와 달리 &lt;code&gt;Parallel Append&lt;/code&gt; 노드는 부분 및 하위가 아닌 하위 계획을 모두 가질 수 있습니다. 비 일부 하위 항목은 단일 프로세스로만 스캔됩니다. 두 번 이상 스캔하면 중복 결과가 생성되기 때문입니다. 따라서 여러 결과 집합을 추가하는 계획은 효율적인 부분 계획을 사용할 수없는 경우에도 대략적인 병렬 처리를 달성 할 수 있습니다. 예를 들어, 병렬 스캔을 지원하지 않는 인덱스를 사용하여 효율적으로 구현할 수있는 파티션 된 테이블에 대한 쿼리를 고려하십시오. 플래너 는 정기적 인 &lt;code&gt;Index Scan&lt;/code&gt; 의 &lt;code&gt;Parallel Append&lt;/code&gt; 를 선택할 수 있습니다계획; 각 개별 인덱스 스캔은 단일 프로세스에 의해 완료 될 때까지 실행되어야하지만, 다른 프로세스에 의해 다른 스캔이 동시에 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">또한 방금 완료된 트랜잭션이 가능한 빨리 아카이브되도록하려면 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 사용하여 세그먼트 스위치를 수동으로 강제 설정할 수 있습니다. WAL 관리와 관련된 기타 유틸리티 기능은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.84에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">또한 가능한 여러 수정 된 레이블을 &lt;code&gt;|&lt;/code&gt; (또는) 해당 레이블 중 하나와 일치하면 &lt;code&gt;!&lt;/code&gt; (아니요) 다른 대안과 일치하지 않는 모든 라벨과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 서버를 변경하고 연결 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">서버 &lt;code&gt;foo&lt;/code&gt; 변경, 버전 변경, &lt;code&gt;host&lt;/code&gt; 옵션 변경 :</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">명시 적으로 식별 된 역할 대신 현재 세션 사용자를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">명시 적으로 식별 된 역할 대신 현재 사용자를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">로그 전달을위한 대체 방법</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">명령 히스토리 파일의 대체 위치 틸드 ( &lt;code&gt;~&lt;/code&gt; ) 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">사용자의 &lt;code&gt;.psqlrc&lt;/code&gt; 파일 의 대체 위치입니다 . 틸드 ( &lt;code&gt;~&lt;/code&gt; ) 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; 의 대체 철자입니다 .</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">순서 집합 집계를 참조하기위한 대체 구문은 &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt; 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">또는 C 스타일 블록 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">또는 IANA 시간대 데이터베이스에 정의 된 영역 이름을 참조 하여 &lt;code&gt;time_zone_name&lt;/code&gt; 을 지정할 수 있습니다. 해당 영역에서 약어가 사용 중인지 또는 사용 중인지 여부를 확인하기 위해 영역의 정의를 참조합니다. 해당되는 경우 적절한 의미가 사용됩니다. 즉, 값이 결정되는 타임 스탬프에서 현재 사용중인 의미 또는 그 당시에 최신 상태가 아니었다면 그 직전에 사용 된 의미이거나 그 이후에만 사용 된 경우 가장 오래된 의미입니다. 이 동작은 역사적으로 의미가 다른 약어를 처리하는 데 필수적입니다. 해당 약어가 나타나지 않는 영역 이름으로 약어를 정의 할 수도 있습니다. 약어를 사용하는 것은 구역 이름을 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">또는 명령 행 옵션에 &lt;code&gt;-P&lt;/code&gt; 가 포함 된 일반 서버 세션을 시작할 수 있습니다. 이를 수행하는 방법은 클라이언트마다 다르지만 모든 libpq 기반 클라이언트 에서 클라이언트를 시작하기 전에 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수를 &lt;code&gt;-P&lt;/code&gt; 로 설정할 수 있습니다 . 이 방법으로 다른 클라이언트를 잠글 필요는 없지만 복구가 완료 될 때까지 다른 사용자가 손상된 데이터베이스에 연결하지 못하게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">또는 임의의 식으로 구별 할 행을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">또는 다음 형식 중 하나를 입력에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">또는 선행 &lt;code&gt;X&lt;/code&gt; (대문자 또는 소문자) (예 : &lt;code&gt;X'1FF'&lt;/code&gt; )를 사용하여 비트 열 상수를 16 진수 표기법으로 지정할 수 있습니다 . 이 표기법은 각 16 진수에 4 개의 2 진수가있는 비트 열 상수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">또는 한 줄에 한 문자 만 주면 해당 문자의 인스턴스가 삭제됩니다. 이것은 악센트가 별도의 문자로 표시되는 언어에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">또는 연산자 클래스가 &lt;code&gt;compare&lt;/code&gt; 메소드를 제공하지 않으면 GIN은 인덱스 키 데이터 유형에 대한 기본 btree 연산자 클래스를 찾고 해당 비교 함수를 사용합니다. btree 연산자 클래스를 찾는 데 몇 사이클이 걸리므로 하나의 데이터 유형만을위한 GIN 연산자 클래스에서 비교 함수를 지정하는 것이 좋습니다. 그러나 다형성 GIN 연산자 클래스 (예 : &lt;code&gt;array_ops&lt;/code&gt; )는 일반적으로 단일 비교 함수를 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">또는 사용자 계정이 잘못 작성되었거나 변경할 수없는 경우 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">또는 새 하위 테이블을 테이블 계층 구조에 추가하기 전에 작성하고 채울 수 있습니다. 이를 통해 부모 테이블의 쿼리에 표시되기 전에 데이터를로드, 확인 및 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">또는 &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; 명령을 사용하여 제거 할 역할이 소유 한 모든 오브젝트의 소유권을 다른 단일 역할에 재 할당 할 수 있습니다. 때문에 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 다른 데이터베이스에없는 액세스 개체 수, 역할이 소유 객체가 포함 된 각 데이터베이스에서 실행하는 것이 필요하다. (이러한 첫 번째 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 는 삭제 될 역할이 소유 한 데이터베이스 또는 테이블 스페이스 인 공유 데이터베이스 간 오브젝트의 소유권을 변경합니다.)</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">또는 &lt;code&gt;generate_subscripts&lt;/code&gt; 함수를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">또는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">또는 짧은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">또는 다음 과 같이 &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; 프로그램을 통해 &lt;code&gt;initdb&lt;/code&gt; 를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">또는 &lt;code&gt;passwordcheck&lt;/code&gt; 를 수정 하여 사전 암호화 된 비밀번호 를 거부 할 수 있지만 사용자가 비밀번호를 일반 텍스트로 설정하도록 강요하면 자체 보안 위험이 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">또는 이미 다른 서버 소프트웨어와 함께 사용중인 외부 로그 순환 프로그램이있는 경우 외부 로그 회전 프로그램을 사용하는 것이 좋습니다. 예를 들어 Apache 배포에 포함 된 rotatelogs 도구는 PostgreSQL과 함께 사용할 수 있습니다. 이를 수행하는 한 가지 방법은 서버의 stderr 출력을 원하는 프로그램으로 파이프하는 것입니다. &lt;code&gt;pg_ctl&lt;/code&gt; 로 서버를 시작하면 stderr이 이미 stdout으로 리디렉션되므로 파이프 명령이 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">또는 로컬 서버와의 유닉스 도메인 소켓 통신을 시도 할 때 이것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">&lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; 는 기존의 저장된 데이터가 새로운 제한 조건을 만족하는지 검증하려고 시도 하지만 명령이 새로 삽입되거나 갱신되어 아직 커미트되지 않은 테이블 행을 &quot;볼 수&quot;없으므로이 검사는 방탄하지 않습니다. 동시 작업에 잘못된 데이터가 삽입 될 수있는 위험이있는 경우 진행 방법은 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하여 제한 조건을 추가하고 해당 명령을 커밋하고 커밋이 완료되기 전에 모든 트랜잭션이 시작될 때까지 기다린 후 &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; 를 발행하는 것입니다. 제약 조건을 위반하는 데이터를 검색합니다. 이 방법은 제약 조건이 커밋되면 모든 새로운 트랜잭션이 도메인 유형의 새로운 값에 대해 적용되도록 보장하기 때문에 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">하지만 &lt;code&gt;COALESCE&lt;/code&gt; 는 , &lt;code&gt;GREATEST&lt;/code&gt; 및 &lt;code&gt;LEAST&lt;/code&gt; 이 기능에 대한 구문과 유사하다, 그들은 일반적인 기능하지 않고, 따라서 명시 적으로 사용할 수 없습니다 &lt;code&gt;VARIADIC&lt;/code&gt; 의 배열 인수.</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 는 SQL 표준에 표시 되지만 &lt;code&gt;DECLARE CURSOR&lt;/code&gt; 옵션으로 만 허용됩니다 . PostgreSQL은 하위 &lt;code&gt;SELECT&lt;/code&gt; 뿐만 아니라 모든 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 에서도이를 허용 하지만 이것은 확장입니다. &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; 및 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 는 뿐만 아니라, 변형 &lt;code&gt;NOWAIT&lt;/code&gt; 및 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 표준에 표시되지 않습니다, 옵션을.</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 가 지정된 데이터 디렉토리를 작성하려고 시도 하지만 원하는 데이터 디렉토리의 상위 디렉토리가 루트 소유인 경우 권한이 없을 수 있습니다. 이러한 설정에서 초기화하려면 root로 빈 데이터 디렉토리를 작성한 다음 &lt;code&gt;chown&lt;/code&gt; 을 사용 하여 해당 디렉토리의 소유권을 데이터베이스 사용자 계정에 지정하고 &lt;code&gt;su&lt;/code&gt; 를 사용하여 &lt;code&gt;initdb&lt;/code&gt; 를 실행하는 데이터베이스 사용자가되도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">PostgreSQL은 외부 테이블에 제약 조건을 적용하려고 시도하지 않지만 쿼리 최적화 목적으로 올바른 것으로 가정합니다. 외부 테이블에 선언 된 제한 조건을 만족하지 않는 행이 표시되면 테이블에 대한 쿼리가 잘못된 응답을 생성 할 수 있습니다. 구속 조건 정의가 현실과 일치하는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">PostgreSQL은 날짜 입력 및 출력을 위해 Julian Date 표기법을 지원하지만 일부 내부 날짜 시간 계산에는 Julian 날짜를 사용하지만 정오부터 정오까지 날짜를 실행하는 것이 멋지지는 않습니다. PostgreSQL은 Julian Date를 자정부터 자정까지 실행하는 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">모든 내장 WAL 로깅 모듈에는 고유 한 유형의 WAL 레코드가 있지만 일반적인 WAL 레코드 유형도 있습니다.이 유형은 일반적인 방식으로 페이지 변경 사항을 설명합니다. 이는 고유 한 WAL 리두 ​​루틴을 등록 할 수 없으므로 사용자 정의 액세스 방법을 제공하는 확장에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">열거 형은 주로 정적 값 집합을위한 것이지만 기존 열거 형에 새 값을 추가하고 값의 이름을 바꾸는 기능이 지원됩니다 ( &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt; 참조 ). 열거 형에서 기존 값을 제거 할 수 없으며 열거 형을 삭제하고 다시 만들지 않고도 이러한 값의 정렬 순서를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL의 인덱스는 유지 관리 또는 조정이 필요하지 않지만 실제 쿼리 워크로드에서 실제로 사용되는 인덱스를 확인하는 것이 중요합니다. 개별 쿼리에 대한 인덱스 사용량 검사는 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령으로 수행됩니다 . 이 목적에 대한 적용은 &lt;a href=&quot;using-explain&quot;&gt;14.1 절에&lt;/a&gt; 설명되어있다 . &lt;a href=&quot;monitoring-stats&quot;&gt;27.2 절에&lt;/a&gt; 설명 된대로 실행중인 서버에서 인덱스 사용에 대한 전체 통계를 수집 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">상속은 종종 유용하지만 고유 제한 조건이나 외래 키와 통합되지 않아 유용성이 제한됩니다. 자세한 내용 &lt;a href=&quot;ddl-inherit&quot;&gt;은 5.10 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">이름을 &lt;code&gt;template1&lt;/code&gt; 로 지정하여 template1 이외의 데이터베이스를 복사 할 수는 있지만 , 이는 범용 &quot; &lt;code&gt;COPY DATABASE&lt;/code&gt; &quot;기능 으로 의도 된 것은 아닙니다 . 주된 제한 사항은 복사되는 동안 템플릿 데이터베이스에 다른 세션을 연결할 수 없다는 것입니다. 시작할 때 다른 연결이 존재하면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 실패합니다. 그렇지 않으면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 완료 될 때까지 템플리트 데이터베이스에 대한 새 연결이 잠 깁니다 . 자세한 정보는 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;22.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 빈도 의 열 단위 조정은 생산적이지 않을 수 있지만 &lt;code&gt;ANALYZE&lt;/code&gt; 가 수집 한 통계의 세부 사항 레벨을 열 단위로 조정하는 것이 좋습니다 . &lt;code&gt;WHERE&lt;/code&gt; 절에 많이 사용되고 열 분포가 매우 불규칙한 열은 다른 열보다 세밀한 데이터 히스토그램이 필요할 수 있습니다. &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 를 참조 하거나 &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; 구성 매개 변수를 사용하여 데이터베이스 전체 기본값을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">있지만 &lt;code&gt;date&lt;/code&gt; 유형이 관련된 시간대를 가질 수는 &lt;code&gt;time&lt;/code&gt; 유형이 있습니다. 현실 세계의 시간대는 날짜 및 시간과 관련되지 않는 한 의미가 거의 없습니다. 오프셋은 일광 절약 시간제 경계에 따라 연중 내내 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">있지만 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 의 연산자 클래스의 지원 만에 쿼리 &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;@@&lt;/code&gt; 와 &lt;code&gt;@?&lt;/code&gt; 연산자 인 경우 기본 연산자 클래스 &lt;code&gt;jsonb_ops&lt;/code&gt; 보다 뛰어난 성능 이점이 있습니다. &lt;code&gt;jsonb_path_ops&lt;/code&gt; 의 인덱스는 보통보다 훨씬 작은 &lt;code&gt;jsonb_ops&lt;/code&gt; 의 동일한 데이터에 대한 인덱스 및 검색의 특이도는 쿼리가 데이터에 자주 나타납니다 키를 포함 할 때 특히 좋다. 따라서 검색 조작은 일반적으로 기본 연산자 클래스보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">클라이언트 측에서 가능한 오류 조건은 상당히 다양하고 응용 프로그램에 따라 다르지만 그 중 일부는 서버 시작 방법과 직접 관련이있을 수 있습니다. 아래에 표시된 조건 이외의 조건은 해당 클라이언트 응용 프로그램에 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">준비된 명령문의 주요 요점은 구문 분석의 반복 된 구문 분석 및 계획을 피하는 것이지만, PostgreSQL은 명령문에 사용 된 데이터베이스 오브젝트가 정의 (DDL) 변경을 겪을 때마다 명령문을 사용하기 전에 명령문을 재분석 및 재 계획합니다. 준비된 진술의 이전 사용 이후. 또한 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 의 값이 한 사용에서 다음 사용으로 변경되면 새 &lt;code&gt;search_path&lt;/code&gt; 를 사용하여 명령문이 다시 구문 분석됩니다.. (이 후자의 동작은 PostgreSQL 9.3부터 새로 도입되었습니다.)이 규칙은 준비된 명령문을 의미 적으로 동일한 쿼리 텍스트를 반복해서 다시 제출하는 것과 거의 동일하지만 객체 정의가 변경되지 않은 경우, 특히 최상의 계획은 여러 용도에서 동일하게 유지됩니다. 의미 론적 동등성이 완벽하지 않은 경우의 예는 명령문이 규정되지 않은 이름으로 테이블을 참조하는 경우 동일한 이름의 새 테이블이 &lt;code&gt;search_path&lt;/code&gt; 에서 이전에 나타나는 스키마에 작성되고 자동으로 다시 정의되지 않는 경우입니다. 명령문에 사용 된 오브젝트가 변경되지 않았으므로 구문 분석이 발생합니다. 그러나 일부 다른 변경으로 인해 재분석이 필요한 경우 이후 사용시 새 테이블이 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">&lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 의 구문은 SQL 표준 의 구문 과 유사하지만 그 효과는 동일하지 않습니다. 표준에서 임시 테이블은 한 번만 정의되며 필요한 모든 세션에 자동으로 존재합니다 (빈 내용으로 시작). PostgreSQL은 대신 각 세션에서 사용할 각 임시 테이블에 대해 고유 한 &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 명령을 실행해야합니다. 이것은 다른 세션이 다른 목적으로 동일한 임시 테이블 이름을 사용할 수 있도록하는 반면, 표준의 접근 방식은 주어진 임시 테이블 이름의 모든 인스턴스가 동일한 테이블 구조를 갖도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">시스템에서 &lt;code&gt;random_page_cost&lt;/code&gt; 를 &lt;code&gt;seq_page_cost&lt;/code&gt; 보다 작게 설정할 수는 있지만 실제로 그렇게하는 것은 합리적이지 않습니다. 그러나 데이터베이스가 RAM에 완전히 캐시되어 있으면 동일하게 설정하는 것이 합리적입니다.이 경우 순서가 맞지 않는 페이지를 건 드리는 데 대한 페널티가 없기 때문입니다. 또한 캐시가 많은 데이터베이스에서는 이미 RAM에있는 페이지를 가져 오는 데 드는 비용이 평소보다 훨씬 작기 때문에 CPU 매개 변수에 비해 두 값을 모두 낮추어야합니다.</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">이러한 쿼리는 색인없이 작동하지만 대부분의 응용 프로그램은 가끔씩 임시 검색을 제외하고는이 방법이 너무 느리다는 것을 알게됩니다. 텍스트 검색을 실제로 사용하려면 일반적으로 색인을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">이 쿼리는 단일 인덱스 중 하나를 사용하는 것보다 훨씬 빠르게 실행되지만 인덱스 크기가 큰 페널티를받습니다. 각 단일 열 btree 인덱스는 214MB를 차지하므로 필요한 총 공간은 블룸 인덱스에 사용 된 공간의 8 배보다 1.2GB가 넘습니다.</target>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">이 쿼리의 제한 사항은 이전 예제와 피상적으로 비슷하지만 B와 C의 조인에서 일치하는 행이없는 A의 각 행에 대해 행을 생성해야하기 때문에 시맨틱이 다릅니다. 따라서 플래너는 여기서 조인 순서를 선택할 수 없습니다. : B를 C에 결합한 다음 A를 해당 결과에 결합해야합니다. 따라서이 쿼리는 이전 쿼리보다 계획 시간이 덜 걸립니다. 다른 경우, 플래너는 둘 이상의 결합 순서가 안전하다고 판단 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">튜플은 잠금 가능한 객체 유형이지만 행 수준 잠금에 대한 정보는 메모리가 아닌 디스크에 저장되므로 일반적으로이 수준에는 행 수준 잠금이 나타나지 않습니다. 프로세스가 행 레벨 잠금을 대기중인 경우 일반적으로 해당 행 잠금의 현재 보유자의 영구 트랜잭션 ID를 기다리는 것으로보기에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">이 기능으로 모든 출력 형식을 사용할 수 있지만 &lt;code&gt;FETCH_COUNT&lt;/code&gt; 행 의 각 그룹이 개별적으로 형식화되어 행 그룹에 따라 열 너비가 다양해 지므로 기본 &lt;code&gt;aligned&lt;/code&gt; 형식이 좋지 않은 것처럼 보입니다 . 다른 출력 형식이 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">시퀀스를 직접 업데이트 할 수는 없지만 다음과 같은 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">항상 스토리지에서 -1이지만 메모리의 행 디스크립터에로드되면 행 내 속성의 오프셋을 캐시하도록 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">항상 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; 먼저 실행하십시오 . 이 명령은 테이블의 값 분포에 대한 통계를 수집합니다. 이 정보는 쿼리가 리턴 한 행 수를 추정하는 데 필요하며, 계획자가 각 가능한 쿼리 계획에 현실적인 비용을 지정하는 데 필요합니다. 실제 통계가 없으면 일부 기본값이 가정되며 이는 거의 부정확합니다. 따라서 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하지 않고 응용 프로그램의 인덱스 사용량을 검사하는 것은 유실 된 원인입니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;24.1.3 절&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">항상 이전 서버가 아니라 새 서버의 pg_upgrade 바이너리를 실행하십시오. pg_upgrade에는 이전 및 새 클러스터의 데이터 및 실행 파일 ( &lt;code&gt;bin&lt;/code&gt; ) 디렉토리 의 사양이 필요합니다 . 또한 사용자 및 포트 값을 지정하고 기본 복사 동작 대신 데이터 파일을 링크 또는 복제할지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">미국 국가 표준 협회</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">정보 교환을위한 미국 표준 코드</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">모든 관계 연산자 중에서 처리하고 최적화하기 가장 어려운 것은 &lt;em&gt;조인&lt;/em&gt; 입니다. 가능한 쿼리 계획의 수는 쿼리의 조인 수에 따라 기하 급수적으로 증가합니다. 추가 &lt;em&gt;조인&lt;/em&gt; 노력은 개별 조인 및 다양한 &lt;em&gt;인덱스&lt;/em&gt; (예 : B- 트리, 해시, GiST 및 GIN )를 처리하기 위해 다양한 &lt;em&gt;조인 방법&lt;/em&gt; (예 : 중첩 루프, 해시 조인, PostgreSQL의 병합 조인)을 지원하기 때문에 발생 합니다 . 관계에 대한 액세스 경로로 PostgreSQL).</target>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">&quot;순서&quot;연산자 항목은 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 로 표시되는 순서대로 행을 리턴하기 위해이 연산자 제품군의 인덱스를 스캔 할 수 있음을 나타냅니다 . 이러한 연산자는 정렬 가능한 데이터 형식을 반환 할 수 있지만 왼쪽 입력 형식은 인덱스의 열 데이터 형식과 일치해야합니다. &lt;code&gt;ORDER BY&lt;/code&gt; 의 정확한 의미는 &lt;code&gt;amopsortfamily&lt;/code&gt; 열에 의해 지정되며 연산자의 결과 유형에 대한 B- 트리 연산자 패밀리를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 연산자 동치 관계이어야; 즉 , 데이터 유형의 널이 아닌 모든 값 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 의 경우 :</target>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 의 기능은 서명이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 사전은 다음과 같은 옵션을 적용합니다</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">&lt;em&gt;집계 식은&lt;/em&gt; 쿼리에 의해 선택된 행에 걸쳐 집계 함수의 적용을 나타낸다. 집계 함수는 여러 입력을 합 또는 평균과 같은 단일 출력 값으로 줄입니다. 집계 표현식의 구문은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;연산자 클래스&lt;/em&gt; 색인의 각 열에 대해 지정 될 수있다. 연산자 클래스는 해당 열의 색인에서 사용할 연산자를 식별합니다. 예를 들어, 4 바이트 정수의 B- 트리 인덱스는 &lt;code&gt;int4_ops&lt;/code&gt; 클래스를 사용합니다 . 이 연산자 클래스에는 4 바이트 정수에 대한 비교 함수가 포함됩니다. 실제로는 열의 데이터 유형에 대한 기본 연산자 클래스로 충분합니다. 연산자 클래스를 갖는 주요 요점은 일부 데이터 유형의 경우 의미있는 순서가 둘 이상있을 수 있다는 것입니다. 예를 들어 복소수 데이터 유형을 절대 값 또는 실수로 정렬 할 수 있습니다. 데이터 형식에 대해 두 개의 연산자 클래스를 정의한 다음 인덱스를 만들 때 적절한 클래스를 선택하면됩니다. 연산자 클래스에 대한 자세한 정보는&lt;a href=&quot;indexes-opclass&quot;&gt;11.10 항&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;37.16 항&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">ARE는 &lt;em&gt;임베디드 옵션으로&lt;/em&gt; 시작할 수 &lt;em&gt;있습니다&lt;/em&gt; . 시퀀스 &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (여기서 &lt;code&gt;xyz&lt;/code&gt; 는 하나 이상의 알파벳 문자 임)는 나머지 RE에 영향을주는 옵션을 지정합니다. 이러한 옵션은 이전에 결정된 옵션보다 우선합니다. 특히 정규식 연산자에 의해 암시 된 대 / 소문자 구분 동작이나 정규식 함수에 대한 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 재정의 할 수 있습니다 . 사용 가능한 옵션 문자가 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23&lt;/a&gt; 에 나와 있습니다. 이 같은 옵션 문자는 정규식 함수 의 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">IP 주소 범위는 범위의 시작 주소에 대한 표준 숫자 표기법, 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 및 CIDR 마스크 길이를 사용하여 지정됩니다. 마스크 길이는 일치해야하는 클라이언트 IP 주소의 상위 비트 수를 나타냅니다. 주어진 IP 주소에서 오른쪽의 비트는 0이어야합니다. IP 주소, &lt;code&gt;/&lt;/code&gt; 및 CIDR 마스크 길이 사이에 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">RE는 두 가지 특수 &lt;em&gt;디렉터&lt;/em&gt; 접두사 중 하나로 시작할 수 있습니다 . RE가 &lt;code&gt;***:&lt;/code&gt; 로 시작 하면 나머지 RE는 ARE로 간주됩니다. RE는 ARE로 가정되기 때문에 PostgreSQL에는 일반적으로 영향을 미치지 않지만 reg 매개 변수로 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 의해 ERE 또는 BRE 모드가 지정된 경우에는 영향을 미칩니다 . RE가 &lt;code&gt;***=&lt;/code&gt; 로 시작하는 경우 나머지 RE는 리터럴 문자열로 간주되며 모든 문자는 일반 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">RE는 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 으로 연결된 둘 이상의 분기로 구성된 RE | 연산자는 항상 욕심입니다.</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">RFC 4516 LDAP URL입니다. 이것은 다른 LDAP 옵션 중 일부를보다 간결하고 표준 형식으로 작성하는 대체 방법입니다. 형식은</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">임의 접두사 및 데이터의 SHA1 해시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">스키마 내에 작성 될 오브젝트를 정의하는 SQL 문. 현재 &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE VIEW&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; , &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 및 &lt;code&gt;GRANT&lt;/code&gt; 만 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 내 절로 허용됩니다 . 다른 종류의 객체는 스키마가 생성 된 후 별도의 명령으로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">SQL / JSON 경로 표현식은 일반적으로 SQL 쿼리에서 SQL 문자열 리터럴로 작성되므로 작은 따옴표로 묶어야하며 값 내에서 원하는 작은 따옴표는 두 배가되어야합니다 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1&lt;/a&gt; 참조 ). 일부 경로 표현식 형식에는 문자열 리터럴이 필요합니다. 이 포함 된 문자열 리터럴은 JavaScript / ECMAScript 규칙을 따릅니다. 큰 따옴표로 묶어야하며 역 슬래시 이스케이프를 사용하여 형식이 어려운 문자를 나타낼 수 있습니다. 특히, 포함 된 문자열 리터럴 내에 큰 따옴표를 쓰는 방법은 &lt;code&gt;\&quot;&lt;/code&gt; 이며 백 슬래시 자체를 쓰려면 &lt;code&gt;\\&lt;/code&gt; 를 써야합니다 . 다른 특수 백 슬래시 시퀀스에는 JSON 문자열에서 인식되는 것들이 있습니다 : &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; 다양한 ASCII 제어 문자의 경우 , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\v&lt;/code&gt; 및 4 진수 코드 포인트로 식별되는 유니 코드 문자의 경우 &lt;code&gt;\uNNNN&lt;/code&gt; 백 슬래시 구문에는 JSON에서 허용하지 않는 두 가지 경우도 포함됩니다. 두 개의 16 진수로만 작성된 문자 코드의 경우 &lt;code&gt;\xNN&lt;/code&gt; , 1에서 6 개의 16 진수로 작성된 문자 코드의 경우 &lt;code&gt;\u{N...}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 재 계산을 피하는 것이 목표 인 경우 추가 경고 는 플래너가 색인 가능한 &lt;code&gt;WHERE&lt;/code&gt; 절에 없는 &lt;code&gt;f(x)&lt;/code&gt; 사용을 색인 열과 반드시 일치시킬 필요 는 없다는 것입니다 . 일반적으로 위와 같은 간단한 쿼리에서는이 권한을 얻지 만 조인이 포함 된 쿼리에서는 그렇지 않습니다. 이러한 결함은 이후 버전의 PostgreSQL에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">또 다른 기대는 &lt;code&gt;in_range&lt;/code&gt; 함수가 실제적인 경우 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 이 오버플로 될 경우 오류를 발생시키지 않아야한다는 것입니다. 해당 값이 데이터 유형의 범위를 벗어난 경우에도 정확한 비교 결과를 확인할 수 있습니다. 데이터 유형에 &quot;무한대&quot;또는 &quot;NaN&quot;과 같은 개념이 포함 된 경우 &lt;code&gt;in_range&lt;/code&gt; 의 결과가 연산자 제품군의 일반적인 정렬 순서와 일치 하도록 추가주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">파서가 제공하는 추가 휴리스틱을 사용하면 암시 적 캐스트가있는 유형 그룹간에 적절한 캐스트 동작을보다 정확하게 결정할 수 있습니다. 데이터 유형은 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;bitstring&lt;/code&gt; , &lt;code&gt;datetime&lt;/code&gt; , &lt;code&gt;timespan&lt;/code&gt; , &lt;code&gt;geometric&lt;/code&gt; , &lt;code&gt;network&lt;/code&gt; 및 사용자 정의를 포함하여 몇 가지 기본 &lt;em&gt;유형 카테고리&lt;/em&gt; 로 나뉩니다 . (목록은 &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;표 51.64를&lt;/a&gt; 참조하십시오 ; 그러나 사용자 정의 유형 카테고리를 작성할 수도 있습니다.) 각 카테고리 내에 하나 이상의 &lt;em&gt;선호 유형&lt;/em&gt; 이있을 수 있습니다.&lt;em&gt;&lt;/em&gt;가능한 유형을 선택할 때 선호됩니다. 선호하는 유형과 사용 가능한 암시 적 캐스트를 신중하게 선택하면 모호한 표현 (여러 후보 구문 분석 솔루션이있는 표현)을 유용한 방식으로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">대부분의 OID 별명 유형의 추가 특성은 종속성 작성입니다. 이러한 유형 중 하나의 상수가 저장된 표현식 (예 : 열 기본 표현식 또는 뷰)에 표시되면 참조 된 오브젝트에 대한 종속성을 작성합니다. 예를 들어, 열에 기본 표현식 &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; 가있는 경우 PostgreSQL은 기본 표현식이 &lt;code&gt;my_seq&lt;/code&gt; 시퀀스에 의존한다는 것을 이해합니다 . 시스템은 기본 표현식을 먼저 제거하지 않으면 시퀀스가 ​​삭제되지 않습니다. &lt;code&gt;regrole&lt;/code&gt; 은 본 호텔의 유일한 예외입니다. 이러한 유형의 상수는 이러한 표현식에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;섹션 37.12.1에&lt;/a&gt; 설명 된대로 집계는 선택적으로 &lt;em&gt;이동 집계 모드를&lt;/em&gt; 지원할 수 있습니다 . 이를 위해서는 &lt;code&gt;MSFUNC&lt;/code&gt; , &lt;code&gt;MINVFUNC&lt;/code&gt; 및 &lt;code&gt;MSTYPE&lt;/code&gt; 매개 변수 및 선택적으로 &lt;code&gt;MSSPACE&lt;/code&gt; , &lt;code&gt;MFINALFUNC&lt;/code&gt; , &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; , &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 및 &lt;code&gt;MINITCOND&lt;/code&gt; 매개 변수를 지정해야합니다. &lt;code&gt;MINVFUNC&lt;/code&gt; 를 제외하고 이러한 매개 변수는 &lt;code&gt;M&lt;/code&gt; 이 없는 해당 단순 집계 매개 변수처럼 작동합니다 . 역 전이 함수를 포함하는 집계의 개별 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;37.12.4 절에&lt;/a&gt; 설명 된 것처럼 집계는 선택적으로 &lt;em&gt;부분 집계를&lt;/em&gt; 지원할 수 있습니다 . &lt;code&gt;COMBINEFUNC&lt;/code&gt; 매개 변수를 지정해야합니다 . 경우] &lt;code&gt;state_data_type&lt;/code&gt; 가 인 &lt;code&gt;internal&lt;/code&gt; , 일반적으로도 제공 할 수있어 적절한 &lt;code&gt;SERIALFUNC&lt;/code&gt; 및 &lt;code&gt;DESERIALFUNC&lt;/code&gt; 그 병렬 통합이 가능하므로 파라미터. 병렬 집계를 사용 가능하게 하려면 집계에도 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 가 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">집계 식</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">집계 표현식은 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 결과 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에만 나타날 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 와 같은 다른 절에서는 이러한 절이 집계 결과가 형성되기 전에 논리적으로 평가되므로 금지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">집계 함수는 초기 조건, 즉 내부 상태 값의 초기 값을 제공 할 수 있습니다. 이것은 &lt;code&gt;text&lt;/code&gt; 유형의 값으로 데이터베이스에 지정되고 저장 되지만 상태 값 데이터 유형의 상수에 대한 유효한 외부 표현이어야합니다. 제공되지 않으면 상태 값은 null로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">집계 함수는 이름 및 입력 데이터 유형으로 식별됩니다. 동일한 스키마의 두 집계는 서로 다른 입력 유형에서 작동하는 경우 동일한 이름을 가질 수 있습니다. 집계의 이름 및 입력 데이터 유형은 동일한 스키마에있는 모든 일반 함수의 이름 및 입력 데이터 유형과도 달라야합니다. 이 동작은 일반 함수 이름 오버로드와 동일합니다 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">&lt;code&gt;state_data_type&lt;/code&gt; 이 &lt;code&gt;internal&lt;/code&gt; 의 집계 함수 는 &lt;code&gt;serialfunc&lt;/code&gt; 함수 가있는 경우에만 병렬 집계에 참여할 수 있습니다. 이 함수는 다른 프로세스로 전송하기 위해 집계 상태를 &lt;code&gt;bytea&lt;/code&gt; 값 으로 직렬화해야합니다 . 이 함수는 &lt;code&gt;internal&lt;/code&gt; 유형 및 return 유형 &lt;code&gt;bytea&lt;/code&gt; 의 단일 인수를 가져와야 합니다. 해당 &lt;code&gt;deserialfunc&lt;/code&gt; 도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">별명은 테이블과 동일한 방식으로 제공 될 수 있습니다. 별명이 작성되면 &lt;code&gt;ORDINALITY&lt;/code&gt; 가있는 경우 추가 된 열을 포함하여 함수 복합 리턴 유형의 하나 이상의 속성에 대한 대체 이름을 제공하기 위해 열 별명 목록을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">다른 백업 전략은 PostgreSQL이 데이터베이스에 데이터를 저장하는 데 사용하는 파일을 직접 복사하는 것입니다. &lt;a href=&quot;creating-cluster&quot;&gt;18.2 절&lt;/a&gt; 에이 파일들의 위치가 설명되어 있습니다. 파일 시스템 백업을 위해 선호하는 방법을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">다른 파일 시스템 백업 방법은 파일 시스템이 해당 기능을 지원하고 올바르게 구현되었다고 믿을 경우 데이터 디렉토리의 &quot;일관된 스냅 샷&quot;을 만드는 것입니다. 일반적인 절차는 데이터베이스가 포함 된 볼륨의 &quot;고정 된 스냅 샷&quot;을 만든 다음 스냅 샷에서 백업 장치로 전체 데이터 디렉토리 (부분 만이 아니라 위 참조)를 복사 한 다음 고정 된 스냅 샷을 해제하는 것입니다. 데이터베이스 서버가 실행되는 동안에도 작동합니다. 그러나이 방법으로 작성된 백업은 데이터베이스 서버가 제대로 종료되지 않은 것처럼 데이터베이스 파일을 저장합니다. 따라서 백업 된 데이터에서 데이터베이스 서버를 시작하면 이전 서버 인스턴스가 충돌 한 것으로 간주하여 WAL 로그를 재생합니다. 이것은 문제가되지 않습니다.이를 알고 있어야하며 백업에 WAL 파일을 포함시켜야합니다. 당신은 수행 할 수 있습니다 &lt;code&gt;CHECKPOINT&lt;/code&gt; 복구 시간을 줄이기 위해 스냅 샷을 복용하기 전에.</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 키워드를 사용하여 SQL 표준을 따르는 대체 구문 을 1 차원 배열에 사용할 수 있습니다. &lt;code&gt;pay_by_quarter&lt;/code&gt; 는 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">이전 섹션에서 설명한 내장 대기 모드에 대한 대안 은 아카이브 위치를 폴링 하는 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하는 것 입니다. 버전 8.4 이하에서만 사용 가능한 옵션이었습니다. 이에 대한 참조 구현은 &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">연결 매개 변수를 지정하는 대체 방법 은 데이터베이스 이름 대신 사용되는 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 또는 URI에 있습니다. 이 메커니즘은 연결을 매우 광범위하게 제어합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">나중에 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 에 대한이 트랜잭션을 식별하는 임의의 식별자입니다 . 식별자는 문자열 리터럴로 작성되어야하며 길이는 200 바이트보다 작아야합니다. 현재 준비된 거래에 사용 된 식별자와 동일해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">이 특정한 준비된 진술에 주어진 임의의 이름. 단일 세션 내에서 고유해야하며 이전에 준비된 명령문을 실행하거나 할당 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">&lt;code&gt;array_prepend&lt;/code&gt; , &lt;code&gt;array_append&lt;/code&gt; 또는 &lt;code&gt;array_cat&lt;/code&gt; 함수를 사용하여 배열을 구성 할 수도 있습니다 . 처음 두 개는 1 차원 배열 만 지원하지만 &lt;code&gt;array_cat&lt;/code&gt; 은 다차원 배열을 지원합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">단일 요소에서 배열을 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">배열 생성자</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">배열 생성자는 멤버 요소의 값을 사용하여 배열 값을 작성하는 표현식입니다. 간단한 배열 생성자는 키워드 &lt;code&gt;ARRAY&lt;/code&gt; , 왼쪽 대괄호 &lt;code&gt;[&lt;/code&gt; , 배열 요소 값에 대한 표현식 목록 (쉼표로 구분) 및 오른쪽 대괄호 &lt;code&gt;]&lt;/code&gt; 로 구성 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">사용 가능한 통계 종류에 대한 코드가 포함 된 배열입니다. 유효한 값은 다음과 같습니다. n 고유 통계의 경우 &lt;code&gt;d&lt;/code&gt; , 기능 종속성 통계의 경우 &lt;code&gt;f&lt;/code&gt; , 가장 일반적인 값 (MCV) 목록 통계의 경우 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">이 그룹의 역할 ID를 포함하는 배열</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">이 통계 개체가 다루는 테이블 열을 나타내는 특성 번호의 배열입니다. 예를 들어 값 &lt;code&gt;1 3&lt;/code&gt; 은 첫 번째 및 세 번째 테이블 열이 포함됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">배열 자체 또는 아래 첨자식이 null 인 경우 배열 슬라이스 식도 마찬가지로 null을 생성합니다. 그러나 현재 배열 범위를 완전히 벗어난 배열 슬라이스를 선택하는 것과 같은 다른 경우 슬라이스 식은 null 대신 빈 (0 차원) 배열을 생성합니다. 요청 된 슬라이스가 배열 경계와 부분적으로 겹치는 경우 null을 반환하는 대신 겹치는 영역으로 자동 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">배열 자체 또는 아래 첨자 식 중 하나가 null 인 경우 배열 첨자 식은 null을 반환합니다. 또한 첨자가 배열 범위를 벗어나면 null이 반환됩니다 (이 경우 오류가 발생하지 않음). 예를 들어, &lt;code&gt;schedule&lt;/code&gt; 의 크기가 &lt;code&gt;[1:3][1:2]&lt;/code&gt; 인 경우 &lt;code&gt;schedule[3][3]&lt;/code&gt; 을 참조 하면 NULL이됩니다. 마찬가지로 잘못된 수의 첨자를 가진 배열 참조는 오류가 아닌 null을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">배열 값을 완전히 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">함수 인자의 데이터 타입을 가진 배열. 여기에는 모든 인수 ( &lt;code&gt;OUT&lt;/code&gt; 및 &lt;code&gt;INOUT&lt;/code&gt; 인수 포함)가 포함됩니다. 그러나 모든 인수가 &lt;code&gt;IN&lt;/code&gt; 인수이면이 필드는 널이됩니다. 첨자 화는 1을 기반으로하는 반면 역사적 이유로 &lt;code&gt;proargtypes&lt;/code&gt; 은 0부터 첨자 화됩니다.</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">함수 인자의 데이터 타입을 가진 배열. 여기에는 입력 인수 ( &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 포함) 만 포함 되므로 함수의 호출 서명을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">엔코딩 함수 인수의 형태와 배열 &lt;code&gt;i&lt;/code&gt; 위한 &lt;code&gt;IN&lt;/code&gt; 의 인자 &lt;code&gt;o&lt;/code&gt; 에 대한 &lt;code&gt;OUT&lt;/code&gt; 인수 &lt;code&gt;b&lt;/code&gt; 용 &lt;code&gt;INOUT&lt;/code&gt; 의 인자 &lt;code&gt;v&lt;/code&gt; 대 &lt;code&gt;VARIADIC&lt;/code&gt; 의 인자, &lt;code&gt;t&lt;/code&gt; 에 대한 &lt;code&gt;TABLE&lt;/code&gt; 인자. 모든 인수가 &lt;code&gt;IN&lt;/code&gt; 인수이면이 필드는 널이됩니다. 아래 첨자는 &lt;code&gt;proallargtypes&lt;/code&gt; 아닌 &lt;code&gt;proargtypes&lt;/code&gt; 위치에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">함수 인수의 이름을 가진 배열입니다. 이름이없는 인수는 배열에서 빈 문자열로 설정됩니다. 이름을 가진 인수가 없으면이 필드는 널이됩니다. 아래 첨자는 &lt;code&gt;proallargtypes&lt;/code&gt; 아닌 &lt;code&gt;proargtypes&lt;/code&gt; 위치에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">구성 파일의 동의어 끝에 별표 ( &lt;code&gt;*&lt;/code&gt; )를 넣을 수 있습니다. 이것은 동의어가 접두사임을 나타냅니다. 별표는 항목이 사용될 때 무시됩니다 &lt;code&gt;to_tsvector()&lt;/code&gt; 하지만이 사용되는 경우 &lt;code&gt;to_tsquery()&lt;/code&gt; , 결과는 접두사 일치 마커 (참조와 쿼리 항목 될 것입니다 &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;섹션 12.3.2&lt;/a&gt; ). 예를 들어 &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; 에 다음과 같은 항목이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">자동으로 업데이트 가능한보기에는 업데이트 가능한 열과 업데이트 불가능한 열이 혼합되어있을 수 있습니다. 기본 기본 관계의 업데이트 가능한 열에 대한 간단한 참조 인 경우 열을 업데이트 할 수 있습니다. 그렇지 않으면 열이 읽기 전용이며 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 문이 값을 지정하려고 하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">암호화 된 PGP 메시지는 두 부분 또는 &lt;em&gt;패킷으로&lt;/em&gt; 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">표시된 주소가 IPv4-in-IPv6 범위에 있더라도 IPv4 형식으로 제공된 항목은 IPv4 연결 만 일치하고 IPv6 형식으로 제공된 항목은 IPv6 연결 만 일치합니다. 시스템의 C 라이브러리가 IPv6 주소를 지원하지 않으면 IPv6 형식의 항목이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">엔트리의 &lt;code&gt;amopmethod&lt;/code&gt; 이 일치해야한다 &lt;code&gt;opfmethod&lt;/code&gt; 의 포함 작업자의 가족을 (를 포함하여 &lt;code&gt;amopmethod&lt;/code&gt; 여기하는 것은 성능상의 이유로 카탈로그 구조의 의도적 인 비정규입니다). 또한 &lt;code&gt;amoplefttype&lt;/code&gt; 및 &lt;code&gt;amoprighttype&lt;/code&gt; 은 참조 된 &lt;code&gt;pg_operator&lt;/code&gt; 항목 의 &lt;code&gt;oprleft&lt;/code&gt; 및 &lt;code&gt;oprright&lt;/code&gt; 필드 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">열거 형 값은 디스크에서 4 바이트를 차지합니다. 열거 형 값의 텍스트 레이블 길이는 PostgreSQL로 컴파일 된 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 설정에 의해 제한됩니다 . 표준 빌드에서는 최대 63 바이트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">다음과 같은 오류 :</target>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">이벤트 트리거 함수는 &lt;code&gt;event_trigger.&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">행을 삽입하는 명령 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">우선 순위 기반 다중 동기 대기에 대한 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">쿼럼 기반 다중 동기 대기에 대한 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">이 가정을 어기는 일반적인 방법의 예는 &lt;code&gt;CHECK&lt;/code&gt; 표현식 에서 사용자 정의 함수를 참조한 다음 해당 함수의 동작을 변경하는 것입니다. PostgreSQL은이를 허용하지 않지만 테이블에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 위반하는 행이 있는지 알 수 없습니다 . 이로 인해 후속 데이터베이스 덤프 및 재로드가 실패합니다. 이러한 변경을 처리하기 위해 권장되는 방법은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 을 사용하여 제한 조건을 삭제 하고 함수 정의를 조정 한 후 제한 조건을 다시 추가하여 모든 테이블 행에 대해 다시 점검하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">이 가정을 어기는 일반적인 방법의 예는 &lt;code&gt;CHECK&lt;/code&gt; 표현식 에서 사용자 정의 함수를 참조한 다음 해당 함수의 동작을 변경하는 것입니다. PostgreSQL은이를 허용하지 않지만 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 위반하는 도메인 유형의 저장된 값이 있는지 알 수 없습니다 . 이로 인해 후속 데이터베이스 덤프 및 재로드가 실패합니다. 이러한 변경을 처리하기 위해 권장되는 방법은 &lt;code&gt;ALTER DOMAIN&lt;/code&gt; 을 사용하여 제한 조건을 삭제 하고 함수 정의를 조정 한 후 제한 조건을 다시 추가하여 저장된 데이터와 비교하여 다시 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">순서 집합 집계 호출의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">문제점 상황의 예로 는 현재 대기 서버에서 조회중인 테이블 에서 &lt;code&gt;DROP TABLE&lt;/code&gt; 을 실행하는 기본 서버의 관리자 가 있습니다. &lt;code&gt;DROP TABLE&lt;/code&gt; 이 대기에 적용된 경우 대기 쿼리를 계속 진행할 수 없습니다 . 이 상황이 기본에서 발생한 경우 &lt;code&gt;DROP TABLE&lt;/code&gt; 은 다른 쿼리가 완료 될 때까지 기다립니다. 그러나 &lt;code&gt;DROP TABLE&lt;/code&gt; 기본에서 실행되며 기본에는 대기에서 실행중인 쿼리에 대한 정보가 없으므로 이러한 대기 쿼리를 기다리지 않습니다. 대기 쿼리가 계속 실행되는 동안 WAL 변경 레코드가 대기로 전달되어 충돌이 발생합니다. 대기 서버는 WAL 레코드의 적용을 지연 시키거나 그 이후의 모든 항목을 지연 시키거나 충돌 쿼리를 취소하여 &lt;code&gt;DROP TABLE&lt;/code&gt; 을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">이것이 의미하는 예 :</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">예 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 바람직하지 않다 수</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">하나의 지정되지 않은 인수가있는 예 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">단, 신호 (데이터베이스 서버 종료의 일부로 사용되는 SIGTERM 이외) 또는 쉘 오류 (예 : 명령을 찾을 수 없음)로 명령이 종료 된 경우 복구가 중단되고 서버가 중단됩니다. 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">속성 값이 열 참조 인 경우 명시 적 속성 이름을 지정할 필요가 없습니다.이 경우 열 이름이 기본적으로 속성 이름으로 사용됩니다. 다른 경우에는 속성에 명시적인 이름을 지정해야합니다. 따라서이 예제는 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">값 표현식이 생성해야하는 유형 (예 : 테이블 열에 지정된 경우)에 대한 모호성이없는 경우 명시 적 유형 캐스트는 일반적으로 생략 할 수 있습니다. 이 경우 시스템은 자동으로 유형 캐스트를 적용합니다. 그러나 자동 캐스트는 시스템 카탈로그에서 &quot;암시 적으로 적용 가능&quot;으로 표시된 캐스트에 대해서만 수행됩니다. 다른 캐스트는 명시 적 캐스트 구문으로 호출해야합니다. 이 제한은 놀라운 전환이 자동으로 적용되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">테이블의 하나 이상의 열을 기반으로하는 표현식입니다. 표현식은 일반적으로 구문에 표시된대로 괄호로 묶어야합니다. 그러나 식에 함수 호출 형식이 있으면 괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">결과 행을 정렬하는 방법을 나타내는 표현식 또는 정수 상수. 이 표현식은 &lt;code&gt;VALUES&lt;/code&gt; 결과 의 열을 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등 으로 참조 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">해당 열에 할당 할 표현식 또는 값입니다.</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 조치가 수행 될 때 모든 행이 잠기는하지만 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 갱신됩니다 . 참고 &lt;code&gt;condition&lt;/code&gt; 충돌이 갱신에 후보로 식별 한 후, 마지막으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">열에 할당 할 표현식입니다. 표현식은 테이블에서이 열과 다른 열의 이전 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">각 행이 삭제 된 후 &lt;code&gt;DELETE&lt;/code&gt; 명령에 의해 계산되고 리턴되는 표현식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 에 나열된 테이블로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 모든 열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">각 행을 삽입하거나 업데이트 한 후 &lt;code&gt;INSERT&lt;/code&gt; 명령 으로 계산하고 반환 할 식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 으로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 삽입되거나 업데이트 된 행의 모든 ​​열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">각 행이 업데이트 된 후 &lt;code&gt;UPDATE&lt;/code&gt; 명령에 의해 계산되고 리턴되는 표현식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 또는 &lt;code&gt;FROM&lt;/code&gt; 에 나열된 테이블로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 모든 열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">매개 변수가 지정되지 않은 경우 기본값으로 사용될 표현식입니다. 표현식은 매개 변수의 인수 유형에 강제적이어야합니다. 기본값이있는 매개 변수 뒤에 오는 모든 입력 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">매개 변수가 지정되지 않은 경우 기본값으로 사용될 표현식입니다. 표현식은 매개 변수의 인수 유형에 강제적이어야합니다. 입력 ( &lt;code&gt;INOUT&lt;/code&gt; 포함 ) 매개 변수 만 기본값을 가질 수 있습니다. 기본값이있는 매개 변수 뒤에 오는 모든 입력 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">외부 프로그램은 &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 함수 ( &lt;a href=&quot;functions-admin&quot;&gt;섹션 9.26&lt;/a&gt; 참조 )를 호출하여 파일 이름과 WAL의 현재 끝에서 정확한 바이트 오프셋을 찾을 수 있습니다. 그런 다음 WAL 파일에 직접 액세스하여 WAL의 마지막 알려진 끝에서 현재 끝을 통해 대기 서버로 데이터를 복사 할 수 있습니다. 이 방법을 사용하면 데이터 손실의 창은 복사 프로그램의 폴링주기 시간으로 매우 작을 수 있으며 부분적으로 사용되는 세그먼트 파일을 강제로 저장하는 데 낭비되는 대역폭이 없습니다. 대기 서버의 &lt;code&gt;restore_command&lt;/code&gt; 스크립트는 전체 WAL 파일 만 처리 할 수 ​​있으므로 증분 복사 된 데이터는 일반적으로 대기 서버에서 사용할 수 없습니다. 1 차 다이가 종료 된 경우에만 사용되며 마지막 부분 WAL 파일은 대기 상태가되며 대기합니다. 이 프로세스를 올바르게 구현하려면 데이터 복사 프로그램과 &lt;code&gt;restore_command&lt;/code&gt; 스크립트의 협력이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">즉시 모드 종료는 서버 충돌과 동일하므로 플러시되지 않은 비동기 커밋이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">나중에 설명 할 다른 백업 방법에 비해 pg_dump의 중요한 장점은 pg_dump의 출력을 일반적으로 최신 버전의 PostgreSQL로 다시로드 할 수 있다는 점입니다. 반면 파일 수준 백업과 지속적인 아카이빙은 서버 버전에 따라 다릅니다. pg_dump는 또한 데이터베이스를 32 비트에서 64 비트 서버로 전환하는 등 다른 머신 아키텍처로 데이터베이스를 전송할 때 작동하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">스트리밍 복제의 중요한 상태 표시기는 기본에서는 생성되었지만 아직 대기에는 적용되지 않은 WAL 레코드의 양입니다. 기본의 현재 WAL 쓰기 위치와 대기에서 수신 한 마지막 WAL 위치를 비교하여이 지연을 계산할 수 있습니다. 이 위치는 기본에서 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 및 대기에서 각각 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.84&lt;/a&gt; 및 &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.85&lt;/a&gt; 참조). 대기의 마지막 WAL 수신 위치도 &lt;code&gt;ps&lt;/code&gt; 명령을 사용하여 표시되는 WAL 수신자 프로세스의 프로세스 상태에 표시됩니다 (자세한 내용 &lt;a href=&quot;monitoring-ps&quot;&gt;은 27.1 절&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">그러나 중요한 제한 사항은 각 데이터베이스의 문자 집합이 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; (문자 분류) 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; (문자열 정렬 순서) 로캘 설정 과 호환되어야한다는 것 입니다. 들어 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 로케일, 어떤 문자 세트가 허용되지만 다른 libc의 제공 로케일에 대해 제대로 작동 하나의 문자 집합이 있습니다. 그러나 Windows에서는 UTF-8 인코딩을 모든 로캘과 함께 사용할 수 있습니다. ICU 지원을 구성한 경우 ICU 제공 로캘을 대부분의 서버 측 인코딩과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 승인 하고 의사 유형 &lt;code&gt;index_am_handler&lt;/code&gt; 를 리턴하려면 색인 액세스 메소드 핸들러 함수를 선언해야합니다 . 인수는 단순히 핸들러 함수가 SQL 명령에서 직접 호출되지 않도록하는 더미 값입니다. 함수의 결과는 유형의 palloc 한 구조체해야 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 핵심 코드 요구 인덱스 액세스 방법을 사용하기 위해 알아야 할 모든 것이 포함되어 있습니다. &lt;code&gt;IndexAmRoutine&lt;/code&gt; 의 구조체, 또한 액세스 메소드의 호출 &lt;em&gt;API 구조체&lt;/em&gt;은 여러 열 인덱스를 지원할 수 있는지 여부와 같은 액세스 방법의 여러 고정 속성을 지정하는 필드를 포함합니다. 더 중요한 것은 인덱스에 액세스하는 모든 실제 작업을 수행하는 액세스 방법에 대한 기능을 지원하는 포인터가 포함되어 있습니다. 이 지원 함수는 일반 C 함수이며 SQL 레벨에서 보거나 호출 할 수 없습니다. 지원 기능은 &lt;a href=&quot;index-functions&quot;&gt;61.2 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">인덱스 액세스 메소드 핸들러는 &lt;code&gt;index_am_handler&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">인덱스는 테이블의 둘 이상의 열에 정의 될 수 있습니다. 예를 들어,이 형식의 테이블이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">인덱스는 인덱스 열당 하나의 데이터 정렬 만 지원할 수 있습니다. 여러 데이터 정렬이 필요한 경우 여러 인덱스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">인덱스 열은 기본 테이블의 열일 필요는 없지만 테이블의 하나 이상의 열에서 계산 된 함수 또는 스칼라 식일 수 있습니다. 이 기능은 계산 결과를 기반으로 테이블에 빠르게 액세스하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">인덱스 정의는 인덱스의 각 열에 대해 &lt;em&gt;연산자 클래스&lt;/em&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">인덱스 필드는 테이블 행의 하나 이상의 열 값에서 계산 된 표현식 일 수 있습니다. 이 기능을 사용하면 기본 데이터의 일부 변환을 기반으로 데이터에 빠르게 액세스 할 수 있습니다. 예를 들어, &lt;code&gt;upper(col)&lt;/code&gt; 에서 계산 된 인덱스 는 &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; 절이 인덱스를 사용 하도록 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">색인이 &quot;부풀어졌습니다&quot;, 즉 비어 있거나 거의 비어있는 페이지가 많이 있습니다. 이는 특정 드문 액세스 패턴으로 PostgreSQL의 B- 트리 인덱스에서 발생할 수 있습니다. &lt;code&gt;REINDEX&lt;/code&gt; 는 데드 페이지없이 새 버전의 인덱스를 작성하여 인덱스의 공간 소비를 줄이는 방법을 제공합니다. 자세한 정보는 &lt;a href=&quot;routine-reindex&quot;&gt;24.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">색인이 손상되었으며 더 이상 유효한 데이터가 없습니다. 이론 상으로는 이런 일이 발생하지 않아야하지만 실제로 소프트웨어 버그 나 하드웨어 오류로 인해 색인이 손상 될 수 있습니다. &lt;code&gt;REINDEX&lt;/code&gt; 는 복구 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">인덱스 스캔은 마지막에 의해 반환 된 항목을 유지하는 인덱스 페이지에 핀 유지해야 &lt;code&gt;amgettuple&lt;/code&gt; 을 , 그리고 &lt;code&gt;ambulkdelete&lt;/code&gt; 는 다른 백엔드에 의해 페이지에서하지 삭제 항목이 고정되어있다 할 수 있습니다. 이 규칙의 필요성은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">널이 오름차순으로 저장된 색인은 먼저 스캔되는 방향에 따라 &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; 또는 &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; 를 만족시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">개별 색인은 색인을 물리적 관계로 설명 하는 &lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt; 항목과 색인의 논리적 내용 (즉, 색인 열 세트 및 해당 열의 의미)을 표시 하는 &lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt; 항목으로 정의됩니다. 관련 연산자 클래스 인덱스 열 (키 값)은 기본 테이블의 간단한 열이거나 테이블 행에 대한 표현식 일 수 있습니다. 인덱스 액세스 방법은 일반적으로 인덱스 키 값의 출처 (항상 사전 계산 된 키 값으로 &lt;code&gt;pg_index&lt;/code&gt; 관심이 없지만 pg_index 의 연산자 클래스 정보에 매우 관심이 있습니다 . 이러한 카탈로그 항목 모두 &lt;code&gt;Relation&lt;/code&gt; 일부로 액세스 할 수 있습니다. 인덱스의 모든 작업에 전달되는 데이터 구조</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">프로 시저 호출의 입력 인수입니다. 명명 된 매개 변수 사용을 포함한 함수 및 프로 시저 호출 구문에 대한 자세한 내용 &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;은 4.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">집계 함수가 작동하는 입력 데이터 유형입니다. 인수가 0 인 집계 함수를 참조하려면 인수 스펙 목록 대신 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . 정렬 된 집합 집계 함수를 참조하려면 직접 인수 집계 집계 사양 사이에 &lt;code&gt;ORDER BY&lt;/code&gt; 를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">이 집계 함수가 작동하는 입력 데이터 유형입니다. 인수가없는 집계 함수를 작성하려면 인수 스펙 목록 대신 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . (이러한 집계의 예는 &lt;code&gt;count(*)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">btree 인덱스 구현에 대한 소개는 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">대각선으로 마주 보는 모서리 쌍으로 표현되는 n 차원 큐브</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">예를 들어 객체에 적절한 종류 의 &lt;code&gt;ALTER&lt;/code&gt; 명령을 사용하여 객체를 새 소유자에게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">이전의 많은 목적을 위해 사용되었던 더 이상 사용되지 않는 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">&quot;: =&quot;에 기반한 이전 구문은 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">열린 커서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">bloom 인덱스의 연산자 클래스는 인덱스 데이터 유형에 대한 해시 함수와 검색을위한 등호 연산자 만 필요합니다. 이 예는 &lt;code&gt;text&lt;/code&gt; 데이터 유형에 대한 연산자 클래스 정의를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">연산자 클래스는 실제로 &lt;em&gt;연산자 패밀리&lt;/em&gt; 라고하는 더 큰 구조의 하위 집합 &lt;em&gt;입니다&lt;/em&gt; . 여러 데이터 유형이 유사한 동작을 갖는 경우 교차 데이터 유형 연산자를 정의하고 인덱스와 함께 작동하도록하는 것이 종종 유용합니다. 이렇게하려면 각 유형에 대한 연산자 클래스를 동일한 연산자 제품군으로 그룹화해야합니다. 교차 유형 연산자는 패밀리의 구성원이지만 패밀리 내의 단일 클래스와 연관되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">또한 연산자 클래스는 인덱스 된 항목이 쿼리와 일치하는지 확인하는 함수를 제공해야합니다. 그것은 두 가지 종류, 부울로 제공 &lt;code&gt;consistent&lt;/code&gt; 기능, 원계 &lt;code&gt;triConsistent&lt;/code&gt; 의 기능. &lt;code&gt;triConsistent&lt;/code&gt; 는 두 기능을 모두 &lt;code&gt;triConsistent&lt;/code&gt; 므로 triConsistent 만 제공 하면 충분합니다. 그러나 부울 변형이 계산 비용이 상당히 저렴하면 둘 다 제공하는 것이 유리할 수 있습니다. 부울 변형 만 제공되는 경우 모든 키를 가져 오기 전에 반품 인덱스 항목에 의존하는 일부 최적화가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">연산자 클래스의 &lt;code&gt;opcmethod&lt;/code&gt; 는 일치해야한다 &lt;code&gt;opfmethod&lt;/code&gt; 의 포함 작업자의 가족을. 또한, 더 이상이 없어야합니다 &lt;code&gt;pg_opclass&lt;/code&gt; 을 가진 행 &lt;code&gt;opcdefault&lt;/code&gt; 의 특정 조합에 대한 진정한 &lt;code&gt;opcmethod&lt;/code&gt; 및 &lt;code&gt;opcintype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">연산자 호출</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">연산자 이름은 다음 목록에서 최대 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 (기본적으로 63) 문자입니다.</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 저장된 통계를 도출하는 데 사용되는 연산자 . 예를 들어, 히스토그램 슬롯 에는 데이터의 정렬 순서를 정의하는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">선택적인 &lt;code&gt;+&lt;/code&gt; 는 자세한 내용을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">도메인에 대한 선택적 데이터 정렬입니다. 데이터 정렬을 지정하지 않으면 기본 데이터 형식의 기본 데이터 정렬이 사용됩니다. &lt;code&gt;COLLATE&lt;/code&gt; 가 지정된 경우 기본 유형은 축소 가능해야 합니다.</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">트리거가 실행될 때 함수에 제공 할 선택적 쉼표로 구분 된 인수 목록입니다. 인수는 리터럴 문자열 상수입니다. 간단한 이름과 숫자 상수도 여기에 쓸 수 있지만 모두 문자열로 변환됩니다. 함수 내에서 이러한 인수에 액세스하는 방법을 찾으려면 트리거 함수의 구현 언어 설명을 확인하십시오. 일반 함수 인수와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">복사 할 선택적 열 목록입니다. 열 목록을 지정하지 않으면 생성 된 열을 제외한 테이블의 모든 열이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">보기의 열에 사용되는 선택적 이름 목록입니다. 지정하지 않으면 열 이름이 쿼리에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">열 또는 테이블 제약 조건의 선택적 이름입니다. 제한 조건을 위반하면 제한 조건 이름이 오류 메시지에 존재하므로 &lt;code&gt;col must be positive&lt;/code&gt; 과 같은 제한 조건 이름은 양수 여야하며 유용한 제한 조건 정보를 클라이언트 애플리케이션에 전달할 수 있습니다. 공백이 포함 된 제약 조건 이름을 지정하려면 큰 따옴표가 필요합니다. 제약 조건 이름을 지정하지 않으면 시스템에서 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">제약 조건의 선택적 이름입니다. 지정하지 않으면 시스템이 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">출력 컬럼의 이름은 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에서 컬럼 값을 참조하는 데 사용될 수 있지만 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에서는 그렇지 않습니다 . 거기에서 대신 표현식을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">반전 된 조건이있는 유사한 명령문은 = 가 &lt;code&gt;less&lt;/code&gt; 때 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">&lt;code&gt;ON DELETE&lt;/code&gt; 와 유사하게 참조 열이 변경 (업데이트) 될 때 호출되는 &lt;code&gt;ON UPDATE&lt;/code&gt; 도 있습니다 . 가능한 조치는 동일합니다. 이 경우 &lt;code&gt;CASCADE&lt;/code&gt; 는 참조 된 열의 업데이트 된 값이 참조 행에 복사되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">고대 배포판에는 &lt;code&gt;sysctl&lt;/code&gt; 프로그램 이 없을 수 있지만 &lt;code&gt;/proc&lt;/code&gt; 파일 시스템 을 조작하여 동등한 변경을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">마지막으로 변환을 만들어 서로 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">마지막으로 대부분의 디스크 드라이브에는 캐시가 있습니다. 일부는 후기 입 (write-through)이고 일부는 후기 입 (write-back)이며, 데이터 손실에 대한 우려는 디스크 컨트롤러 캐시와 마찬가지로 후기 입 드라이브 캐시에도 동일하게 존재합니다. 소비자 급 IDE 및 SATA 드라이브는 특히 전원 장애시에도 지속되지 않는 후기 입 캐시가있을 가능성이 높습니다. 많은 SSD (Solid-State Drive)에도 휘발성 쓰기 저장 캐시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">그리고 구독자 데이터베이스에서 :</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">그리고 &lt;code&gt;.dict&lt;/code&gt; 의 파일은 다음과 같은 구조를 가지고 :</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">그리고 C 모듈의 일치하는 코드는 다음 골격을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">오른쪽 위 모서리의 첫 번째 좌표에서 내림차순으로 2 차원 큐브를 정렬하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">그리고 서브 필드를 &lt;code&gt;INSERT&lt;/code&gt; 의 대상으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">그리고 함수가 &lt;code&gt;integer&lt;/code&gt; 유형의 인수와 함께 호출 되면 파서는이를 &lt;code&gt;text&lt;/code&gt; 로 변환하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">고려해야 할 또 다른 대안 은 규칙 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 ( &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 참조 )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">또 다른 접근법은 별도의 &lt;code&gt;tsvector&lt;/code&gt; 열 을 만들어 to_tsvector 의 출력을 유지하는 &lt;code&gt;to_tsvector&lt;/code&gt; 입니다. 소스 데이터를 사용하여이 열을 자동으로 최신 상태로 유지하려면 저장된 생성 열을 사용하십시오. 이 예제는 &lt;code&gt;title&lt;/code&gt; 과 &lt;code&gt;body&lt;/code&gt; 연결 한 것으로 , &lt;code&gt;coalesce&lt;/code&gt; 을 사용하여 한 필드가 다른 필드가 &lt;code&gt;NULL&lt;/code&gt; 일 때 색인을 생성하도록 합니다 .</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">쿼리에 대한 또 다른 접근 방식은 다음과 같이 포함을 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">&lt;code&gt;vm.overcommit_memory&lt;/code&gt; 를 변경하거나 사용하지 않고 사용할 수있는 또 다른 방법 은 포스트 마스터 프로세스 의 프로세스 별 &lt;em&gt;OOM 점수 조정&lt;/em&gt; 값을 &lt;code&gt;-1000&lt;/code&gt; 으로 설정하여 OOM 킬러가이를 대상으로하지 않도록하는 것입니다. 이를 수행하는 가장 간단한 방법은 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">고유 인덱스를 동시에 빌드 할 때의 또 다른 경고는 두 번째 테이블 스캔이 시작될 때 고유성 제한 조건이 다른 트랜잭션에 대해 이미 시행되고 있다는 것입니다. 즉, 인덱스를 사용할 수있게되기 전에 또는 인덱스 작성이 실패한 경우에도 다른 쿼리에서 제약 조건 위반이보고 될 수 있습니다. 또한 두 번째 스캔에서 오류가 발생하면 &quot;유효하지 않은&quot;인덱스는 계속해서 고유성 제한 조건을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">복사에 대한 또 다른 일반적인 이유 &lt;code&gt;template0&lt;/code&gt; 대신 &lt;code&gt;template1&lt;/code&gt; 를가 복사 할 때 새로운 인코딩 및 로케일 설정을 지정할 수 있다는 것입니다 &lt;code&gt;template0&lt;/code&gt; 를 사본 반면, &lt;code&gt;template1&lt;/code&gt; 를이 는 않습니다 동일한 설정을 사용해야합니다. 때문이다 &lt;code&gt;template1&lt;/code&gt; 를이 인코딩 특정 또는 로케일 고유의 데이터를 포함하는 반면, &lt;code&gt;template0&lt;/code&gt; 는 하지 않는 것으로 알려져있다.</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">또 다른 고려는 점이다 &lt;code&gt;setval&lt;/code&gt; 에 그들이 캐시 한 모든 할당 된 값을 사용 할 때까지 이러한 시퀀스에서 실행이 다른 세션에 의해 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">규칙 접근의 또 다른 단점은 규칙 집합이 삽입 날짜를 다루지 않는 경우 오류를 발생시키는 간단한 방법이 없다는 것입니다. 데이터가 자동으로 마스터 테이블로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">또 다른 효과 &lt;code&gt;RECURSIVE&lt;/code&gt; 는 것입니다 &lt;code&gt;WITH&lt;/code&gt; 쿼리가 나중에 목록에 또 다른 하나를 참조 할 수 있습니다 : 쿼리 정렬 할 필요는 없다. (단, 순환 참조 또는 상호 재귀 구현되지 않는다.)없이 &lt;code&gt;RECURSIVE&lt;/code&gt; , &lt;code&gt;WITH&lt;/code&gt; 쿼리 만 형제를 참조 할 수 &lt;code&gt;WITH&lt;/code&gt; 이전에 질의 &lt;code&gt;WITH&lt;/code&gt; 리스트.</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">또 다른 예 &amp;mdash; PostgreSQL 메일 링리스트 아카이브에는 461,020 개의 메시지에 57,491,343 개의 어휘와 함께 910,989 개의 고유 한 단어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">이러한 개념을 보여주는 또 다른 예는 이러한 모든 쿼리가 동일한 것을 의미한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">&lt;code&gt;--rate=100&lt;/code&gt; 및 &lt;code&gt;--latency-limit=5&lt;/code&gt; 의 다른 예 (추가 &lt;code&gt;schedule_lag&lt;/code&gt; 열 참조) :</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">테이블 별칭의 또 다른 형식은 테이블 자체뿐만 아니라 테이블의 열에 임시 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">시스템에서 사용하는 다른 식별자 유형은 &lt;code&gt;xid&lt;/code&gt; 또는 transaction (약어)</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">또 다른 중요한 점은 서버 프로세스에 이러한 통계를 표시하도록 요청하면 먼저 콜렉터 프로세스에서 생성 한 최신 보고서를 가져온 다음 현재 트랜잭션이 끝날 때까지 모든 통계 뷰 및 기능에 대해이 스냅 샷을 계속 사용한다는 것입니다 . 따라서 통계는 현재 트랜잭션을 계속하는 한 정적 정보를 표시합니다. 마찬가지로 모든 세션의 현재 쿼리에 대한 정보는 해당 정보가 트랜잭션 내에서 처음 요청 될 때 수집되며 동일한 정보가 트랜잭션 전체에 표시됩니다. 이것은 통계가 아닌 여러 쿼리를 수행하고 숫자가 변경 될 염려없이 결과를 상관시킬 수 있기 때문에 버그가 아닌 기능입니다. 그러나 각 검색어에 대해 새로운 결과를 보려면트랜잭션 블록 외부에서 쿼리를 수행하십시오. 또는 호출 할 수 있습니다 &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; () : 현재 트랜잭션의 통계 스냅 샷 (있는 경우)을 삭제합니다. 다음에 통계 정보를 사용하면 새 스냅 샷을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">트랜잭션 데이터베이스의 또 다른 중요한 속성은 원자 업데이트 개념과 밀접한 관련이 있습니다. 여러 트랜잭션이 동시에 실행되는 경우 각 트랜잭션이 다른 트랜잭션의 불완전한 변경을 볼 수 없어야합니다. 예를 들어, 한 거래가 모든 지점 잔액을 합산하는 데 바쁘면 Alice의 지점에서 차변을 포함하지 않고 Bob의 지점으로의 신용은 포함하지 않으며 그 반대도 마찬가지입니다. 따라서 트랜잭션은 데이터베이스에 대한 영구적 인 영향뿐만 아니라 발생시 가시성 측면에서도 전혀 또는 전혀 없어야합니다. 공개 트랜잭션이 수행 한 업데이트는 트랜잭션이 완료 될 때까지 다른 트랜잭션에서 볼 수 없으므로 모든 업데이트가 동시에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">또 다른 제한은 내부 튜플의 노드가 리프 튜플 세트를 가리킬 때 해당 튜플이 모두 동일한 색인 페이지에 있어야한다는 것입니다. (이러한 튜플을 연결하는 링크에서 탐색을 줄이고 공간을 절약하기위한 디자인 결정입니다.) 리프 튜플 세트가 페이지에 비해 너무 커지면 분할이 수행되고 중간 내부 튜플이 삽입됩니다. 이 문제를 해결하기 위해, 새로운 내부 튜플 &lt;em&gt;해야&lt;/em&gt; 하나 개 이상의 노드 그룹에 리프 값들의 세트를 나눈다. 오퍼레이터 클래스의 &lt;code&gt;picksplit&lt;/code&gt; 기능이이를 수행하지 못하면 SP-GiST 코어는 &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3에&lt;/a&gt; 설명 된 특별 조치에 의지 합니다.</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">동일한 유형의 또 다른 제한 사항은 &lt;code&gt;CASE&lt;/code&gt; 가 &lt;code&gt;SELECT&lt;/code&gt; 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절의 다른 표현식을 고려 하기 전에 집계 표현식이 계산되기 때문에 CASE에 포함 된 집계 표현식의 평가를 막을 수 없다는 것 입니다. 예를 들어 다음 쿼리는 겉보기에 대해 보호 된 것처럼 보이지만 0으로 나누기 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 연결의 또 다른 옵션 은 클라이언트가 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt; 를 사용하여 소켓에 연결된 서버 프로세스의 필수 소유자를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">또 다른 옵션은 기본 서버에서 &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; 를 증가시켜 데드 행이 평소처럼 빨리 정리되지 않도록하는 것입니다. 이것은 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 를 높게 설정할 필요없이 대기에서 취소되기 전에 쿼리를 실행하는 데 더 많은 시간을 허용 합니다. 그러나 &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; 는 기본 서버에서 실행되는 트랜잭션에서 측정 되므로이 방법으로 특정 실행 시간 창을 보장하는 것은 어렵습니다 .</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">또 다른 옵션은 rsync를 사용하여 파일 시스템 백업을 수행하는 것입니다. 데이터베이스 서버가 실행되는 동안 rsync를 먼저 실행 한 다음 &lt;code&gt;rsync --checksum&lt;/code&gt; 을 수행 할 수있을만큼 데이터베이스 서버를 종료하면됩니다 . ( &lt;code&gt;--checksum&lt;/code&gt; 가 있으므로 필요 &lt;code&gt;rsync&lt;/code&gt; 그것을 전송할 비교적 적은 데이터를 가지고 있기 때문에, 제 rsync를 처음보다 빠를 것이다 단지 1 초의 파일 수정 시간 단위가있다.) 서버가 없기 때문에 결과적으로 일관 될 것이다 하위. 이 방법을 사용하면 최소한의 중단 시간으로 파일 시스템 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">종종 선호되는 또 다른 옵션은 파티션 된 테이블에서 파티션을 제거하고 자체 권한으로 테이블로 액세스를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">명심해야 할 또 다른 점은 기본적으로 새로 생성 된 함수에 대해 실행 권한이 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여된다는 것 입니다 (자세한 내용 은 &lt;a href=&quot;ddl-priv&quot;&gt;섹션 5.7&lt;/a&gt; 참조 ). 보안 정의 자 기능의 사용을 일부 사용자로 제한하려는 경우가 종종 있습니다. 그렇게하려면 기본 &lt;code&gt;PUBLIC&lt;/code&gt; 권한을 취소 한 다음 실행 권한을 선택적으로 부여해야합니다. 모든 사람이 새 기능에 액세스 할 수있는 창을 피하려면 기능을 작성하고 단일 트랜잭션 내에서 권한을 설정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">또 다른 가능성은 구성 파일 디렉토리를 작성하고이 정보를 파일에 넣는 것입니다. 예를 들어, &lt;code&gt;conf.d&lt;/code&gt; 디렉토리는 &lt;code&gt;postgresql.conf&lt;/code&gt; 끝에서 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">또 다른 가능성은 문서를 파일 시스템에 간단한 텍스트 파일로 저장하는 것입니다. 이 경우 데이터베이스를 사용하여 전체 텍스트 인덱스를 저장하고 검색을 실행할 수 있으며 일부 고유 식별자를 사용하여 파일 시스템에서 문서를 검색 할 수 있습니다. 그러나 데이터베이스 외부에서 파일을 검색하려면 수퍼 유저 권한 또는 특수 기능 지원이 필요하므로 모든 데이터를 PostgreSQL 내부에 유지하는 것보다 편리하지 않습니다. 또한 모든 것을 데이터베이스에 보관하면 문서 메타 데이터에 쉽게 액세스하여 색인 및 표시를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">다른 가능한 조인 유형은 다음과 같이 병합 조인입니다.</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">부분 인덱스의 또 다른 가능한 용도는 일반적인 쿼리 워크로드에 관심이없는 인덱스에서 값을 제외하는 것입니다. 이것은 &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;예제 11.2에 나와&lt;/a&gt; 있습니다. 결과적으로 위에서 설명한 것과 동일한 장점이 있지만,이 경우 인덱스 스캔이 수익성이 있더라도 해당 인덱스를 통해 &quot;관심없는&quot;값에 액세스 할 수 없습니다. 분명히 이런 종류의 시나리오에 대해 부분 인덱스를 설정하려면 많은주의와 실험이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">로그 출력을 관리하는 또 다른 프로덕션 급 접근 방식은 로그 출력을 syslog로 보내고 syslog가 파일 회전을 처리하도록하는 것입니다. 이렇게하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 구성 매개 변수 &lt;code&gt;log_destination&lt;/code&gt; 을 &lt;code&gt;syslog&lt;/code&gt; (syslog에만 기록)로 설정하십시오 . 그런 다음 새 로그 파일을 작성하도록 강제 할 때마다 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 syslog 디먼에 보낼 수 있습니다 . 로그 회전을 자동화하려면 syslog의 로그 파일에 대해 작업하도록 logrotate 프로그램을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용해야하는 또 다른 이유 는 커서 쿼리가 &quot;단순히 업데이트 가능&quot;하기위한 SQL 표준 규칙을 충족하지 않으면 후속 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 가 실패 할 수 있기 때문입니다 (특히 커서는 하나의 테이블 만 참조하고 그룹화를 사용하지 않아야 함) 또는 &lt;code&gt;ORDER BY&lt;/code&gt; ). 단순히 업데이트 할 수없는 커서는 계획 선택 세부 사항에 따라 작동하거나 작동하지 않을 수 있습니다. 최악의 경우 응용 프로그램이 테스트에서 작동 한 다음 프로덕션에서 실패 할 수 있습니다. 경우 &lt;code&gt;FOR UPDATE&lt;/code&gt; 가 지정되면, 커서는 갱신이 보장된다.</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">다중 데이터 유형 제품군에 대한 또 다른 요구 사항은 운영자 제품군에 포함 된 데이터 유형간에 정의 된 암시 적 또는 이진 강제 변환은 연관된 정렬 순서를 변경하지 않아야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">또 다른 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">디스크 플래터 쓰기 작업 자체에 의해 데이터 손실의 또 다른 위험이 발생합니다. 디스크 플래터는 섹터 (일반적으로 각각 512 바이트)로 나뉩니다. 모든 물리적 읽기 또는 쓰기 작업은 전체 섹터를 처리합니다. 쓰기 요청이 드라이브에 도착하면 512 바이트의 배수 (PostgreSQL은 일반적으로 한 번에 8192 바이트 또는 16 섹터를 씁니다) 일 수 있으며 언제든지 전원 손실로 인해 쓰기 프로세스가 실패 할 수 있습니다. 512 바이트 섹터 중 일부는 작성되었지만 나머지는 그렇지 않았습니다. 이러한 실패를 방지하기 위해 PostgreSQL은 정기적으로 전체 페이지 이미지를 영구 WAL 스토리지 &lt;em&gt;에 기록합니다.&lt;/em&gt;디스크의 실제 페이지 수정 이렇게하면 응급 복구 중에 PostgreSQL이 WAL에서 부분적으로 작성된 페이지를 복원 할 수 있습니다. ZFS와 같은 부분 페이지 쓰기를 방지하는 파일 시스템 소프트웨어가있는 경우 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 매개 변수를 해제하여이 페이지 이미징을 해제 할 수 있습니다 . BBU (Battery-Backed Unit) 디스크 컨트롤러는 데이터가 BBU에 전체 (8kB) 페이지로 기록되도록 보장하지 않는 한 부분 페이지 쓰기를 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">또 다른 특별한 기능은 입력하는 동안 &lt;code&gt;?&lt;/code&gt; 확인 숫자 대신 올바른 확인 숫자가 자동으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">복합 값과 관련된 또 다른 특수한 구문 동작은 복합 값 의 필드를 추출하기 위해 &lt;em&gt;기능 표기법&lt;/em&gt; 을 사용할 수 있다는 것 입니다. 이를 설명하는 간단한 방법은 &lt;code&gt;field(table)&lt;/code&gt; 및 &lt;code&gt;table.field&lt;/code&gt; 표기법 을 서로 바꿔 사용할 수 있다는 것입니다. 예를 들어 다음 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">다른 유형의 추가 정보는 필터 조건에 의해 제거 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">각 열에 대해 저장된 또 다른 유형의 통계는 가장 일반적인 값 목록입니다. 이렇게하면 개별 열에 대한 매우 정확한 추정이 가능하지만 여러 열에 대한 조건이있는 쿼리의 경우 상당한 오해가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">데이터베이스 활동을 모니터링하는 또 다른 유용한 도구는 &lt;code&gt;pg_locks&lt;/code&gt; 시스템 테이블입니다. 데이터베이스 관리자는 잠금 관리자에서 미해결 잠금에 대한 정보를 볼 수 있습니다. 예를 들어이 기능을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">괄호 안의 다른 값 표현식 (하위 표현식을 그룹화하고 우선 순위를 대체하는 데 사용됨)</target>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">동일한 효과를 얻는 또 다른 방법은 &lt;code&gt;regclass&lt;/code&gt; 별칭 유형 을 사용 하여 테이블 OID를 기호로 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">&lt;code&gt;\copy ... to&lt;/code&gt; 와 동일한 결과를 얻는 다른 방법 은 SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; 명령을 사용하고이를 &lt;code&gt;\g filename&lt;/code&gt; 또는 &lt;code&gt;\g |program&lt;/code&gt; 종료하는 것입니다 . &lt;code&gt;\copy&lt;/code&gt; 와 달리이 방법을 사용하면 명령이 여러 줄에 걸쳐있을 수 있습니다. 또한 가변 보간 및 역 따옴표 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">여러 열을 반환하는 또 다른 방법은 &lt;code&gt;TABLE&lt;/code&gt; 함수 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">불연속 범위 유형을 생각하는 또 다른 방법은 각 요소 값에 대해 &quot;다음&quot;또는 &quot;이전&quot;값에 대한 명확한 아이디어가 있다는 것입니다. 이를 알면 원래 제공된 값 대신 다음 또는 이전 요소 값을 선택하여 범위 범위의 포괄적 인 표현과 독점적 표현간에 변환 할 수 있습니다. 예를 들어, 정수 범위 유형 &lt;code&gt;[4,8]&lt;/code&gt; 및 &lt;code&gt;(3,9)&lt;/code&gt; 는 동일한 값 세트를 나타냅니다. 그러나 이것은 숫자 이상의 범위에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">각도로 각도를 측정하는 또 다른 방법은 앞에서 설명한 단위 변환 함수 &lt;code&gt;radians()&lt;/code&gt; 및 &lt;code&gt;degrees()&lt;/code&gt; 하는 것입니다. 그러나 &lt;code&gt;sind(30)&lt;/code&gt; 과 같은 특수한 경우 반올림 오차를 피할 수 있으므로 정도 기반 삼각 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">모든 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 는 , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; 는 , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DECLARE&lt;/code&gt; 을 , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 거나 &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; 그 실행 계획을보고 싶은 문을.</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">모든 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 는 , &lt;code&gt;DELETE&lt;/code&gt; , 또는 &lt;code&gt;VALUES&lt;/code&gt; 의 문.</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;cidr&lt;/code&gt; 값은 암시 적으로 또는 명시 적으로 &lt;code&gt;inet&lt;/code&gt; 으로 캐스트 될 수 있습니다 . 따라서 위의 &lt;code&gt;inet&lt;/code&gt; 에서 작동하는 것으로 표시된 기능 은 &lt;code&gt;cidr&lt;/code&gt; 값 에서도 작동 합니다. ( &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;cidr&lt;/code&gt; 에 대해 별도의 함수 가있는 경우 두 경우에 대해 동작이 달라야하기 때문입니다.) 또한 &lt;code&gt;inet&lt;/code&gt; 값을 &lt;code&gt;cidr&lt;/code&gt; 에 캐스트 할 수 있습니다. 이 작업이 완료되면 유효한 &lt;code&gt;cidr&lt;/code&gt; 값 을 생성하기 위해 넷 마스크 오른쪽의 비트가 자동으로 0으로 설정됩니다 . 또한 일반 캐스트 구문을 사용하여 텍스트 값을 &lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 로 캐스트 할 수 있습니다 &lt;code&gt;inet(expression)&lt;/code&gt; 예 : inet (expression)). 또는 &lt;code&gt;colname::cidr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건 표현식은 &lt;code&gt;NEW&lt;/code&gt; 및 &lt;code&gt;OLD&lt;/code&gt; 이외의 테이블을 참조 할 수 없으며 집계 함수를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건식에는 집계 또는 창 함수가 포함될 수 없습니다. 이 표현식은 행 레벨 보안이 사용 가능한 경우 테이블을 참조하는 쿼리에 추가됩니다. 표현식이 true를 리턴하는 행이 표시됩니다. 표현식이 false 또는 null을 반환하는 행은 사용자에게 표시되지 않으며 ( &lt;code&gt;SELECT&lt;/code&gt; 에서 ) 수정할 수 없습니다 ( &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 에서) ). 이러한 행은 자동으로 억제됩니다. 오류가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건식에는 집계 또는 창 함수가 포함될 수 없습니다. 이 표현식은 행 레벨 보안이 사용 가능한 경우 테이블에 대한 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 조회에서 사용됩니다. 표현식이 true로 평가되는 행만 허용됩니다. 삽입 된 레코드 나 업데이트로 인해 발생한 레코드에 대해식이 false 또는 null로 평가되면 오류가 발생합니다. 있습니다 &lt;code&gt;check_expression&lt;/code&gt; 은 행의 제안 된 새로운 내용이 아니라 원래 내용에 대해 평가한다.</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">의 모든 문자 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자와 일치 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 세트는에서 해당 문자로 대체됩니다 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; 설정. 경우 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 보다 더 이상 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; ,에 추가 문자의 발생 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">새로운 &lt;code&gt;table access method&lt;/code&gt; 개발자는 구현에 대한 세부 사항을 위해 &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; 에 있는 기존 &lt;code&gt;heap&lt;/code&gt; 구현을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">OpenSSL이 지원하는 모든 다이제스트 알고리즘이 자동으로 선택됩니다. 명시 적으로 지원해야하는 암호로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">&lt;code&gt;pgsql_tmp&lt;/code&gt; 로 시작하는 파일 또는 디렉토리 는 백업에서 생략 할 수 있습니다. 이러한 파일은 포스트 마스터 시작시 제거되며 필요에 따라 디렉토리가 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">복사 된 열 정의의 모든 생성 표현식이 복사됩니다. 기본적으로 새 열은 일반 기본 열입니다.</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">복사 된 열 정의의 모든 ID 스펙이 복사됩니다. 이전 테이블과 연관된 시퀀스와 별도로 새 테이블의 각 ID 열에 대해 새 시퀀스가 ​​작성됩니다.</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">그룹 역할의 모든 멤버십은 자동으로 취소되지만 멤버 역할은 다른 방식으로 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">위 표에 언급되지 않은 다른 백 슬래시 문자는 자체를 나타내는 것으로 간주됩니다. 그러나 백 슬래시를 불필요하게 추가하면 실수로 데이터 끝 표시 ( &lt;code&gt;\.&lt;/code&gt; ) 또는 null 문자열 ( 기본적으로 &lt;code&gt;\N&lt;/code&gt; )과 일치하는 문자열이 생성 될 수 있으므로 백 슬래시를 추가하지 않아도 됩니다. 이 문자열은 다른 백 슬래시 처리가 수행되기 전에 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">백 슬래시 뒤의 다른 문자는 그대로 사용됩니다. 따라서 백 슬래시 문자를 포함 시키려면 두 개의 백 슬래시 ( &lt;code&gt;\\&lt;/code&gt; )를 작성하십시오. 또한 &lt;code&gt;''&lt;/code&gt; 의 일반적인 방법 외에도 &lt;code&gt;\'&lt;/code&gt; 을 쓰면 이스케이프 문자열에 작은 따옴표를 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">업데이트 된 값이 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식을 통과하지 않은 행 은 오류를 발생시키고 전체 명령이 중단됩니다. 단지 경우 &lt;code&gt;USING&lt;/code&gt; 절이 지정되어, 그 절은 모두에 사용됩니다 &lt;code&gt;USING&lt;/code&gt; 및 &lt;code&gt;WITH CHECK&lt;/code&gt; 경우.</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">입력시 두 개의 반대쪽 모서리를 제공 할 수 있지만 값은 오른쪽 상단과 왼쪽 하단을 순서대로 저장하는 데 필요한 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 가 0보다 큰 값은 가장 짧은 형식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">인용 부호없는 백 슬래시로 시작하는 psql에 입력 한 것은 psql 자체에서 처리되는 psql 메타 명령입니다. 이 명령은 psql을 관리 또는 스크립팅에 더 유용하게 만듭니다. 메타 명령은 종종 슬래시 또는 백 슬래시 명령이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">서버 로그 출력을 &lt;code&gt;filename&lt;/code&gt; 에 추가하십시오 . 파일이 없으면 작성됩니다. umask는 077로 설정되므로 기본적으로 다른 사용자가 로그 파일에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">부록 A. PostgreSQL 오류 코드</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">부록 B. 날짜 / 시간 지원</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">부록 C. SQL 키워드</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">부록 D. SQL 적합성</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">부록 E. 릴리스 정보</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">부록 F. 추가 제공 모듈</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">부록 G. 추가 제공 프로그램</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">부록 K. PostgreSQL 제한</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">부록 L. 약어</target>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">부록 : 추가 공급 모듈</target>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">부록 : 날짜 / 시간 지원</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">부록 : SQL 적합성</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">적용 가능한 객체 유형</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">응용 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">응용 프로그램 이름</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">여러 정책 적용</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">WAL에서 진공 정리 레코드를 적용하면 제거 할 데이터의 표시 여부에 관계없이 대기의 대상 페이지에 액세스하는 쿼리와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">WAL에서 진공 정리 레코드를 적용하면 스냅 샷이 제거 할 행을 &quot;인식&quot;할 수있는 대기 트랜잭션과 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">정확한 값을 원했던 애플리케이션은 역사적으로 &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 를 3으로 설정하여 값 을 얻었습니다. 버전 간 호환성을 극대화하려면 계속 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">백 슬래시를 이스케이프로 사용하려는 응용 프로그램은 이스케이프 문자열 구문 ( &lt;code&gt;E'...'&lt;/code&gt; ) 을 사용하도록 수정해야합니다. 일반 문자열의 기본 동작은 이제 SQL 표준에 따라 백 슬래시를 일반 문자로 취급하기 때문입니다. 이 변수를 사용하면 변경해야하는 코드를 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">이 레벨을 사용하는 응용 프로그램은 직렬화 실패로 인해 트랜잭션을 재 시도 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">이전 단계에서 얻은 페이지 이미지에 수정 사항을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">장애 조치시 작성된 검사 점에서 시작하여 소스 클러스터에서 WAL을 적용하십시오. 엄밀히 말하면, pg_rewind는 WAL을 적용하지 않고 PostgreSQL을 해당 체크 포인트에서 모든 WAL을 다시 재생하여 시작하게하는 백업 레이블 파일 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">이동 집계 모드에 대한 전이 상태 데이터의 대략적인 평균 크기 (바이트) 또는 기본 추정값을 사용하는 경우 0</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">전이 상태 데이터의 대략적인 평균 크기 (바이트) 또는 기본 추정값을 사용하려면 0</target>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">SQL / JSON 숫자 또는 문자열에서 변환 된 대략적인 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">이 객체의 설명 역할을하는 임의의 텍스트</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">아키텍처 : 초기 스냅 샷</target>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">가로로 정렬되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">평행합니까?</target>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">왼쪽 JSON 경로 / 값 항목이 오른쪽 JSON 값의 최상위 레벨에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">세로로 정렬되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">트리거로 전달할 인수 문자열 (각 NULL로 종료 됨)</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">향후 쿼리 결과를 파일 파일 &lt;code&gt;filename&lt;/code&gt; 으로 저장 하거나 향후 결과를 셸 명령 &lt;code&gt;command&lt;/code&gt; 파이프 하도록 정렬합니다 . 인수를 지정하지 않으면 조회 출력이 표준 출력으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">배열 비교</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">배열 비교 : ALL (배열)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">배열 비교 : ANY / SOME (배열)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">배열 비교 : IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">배열 비교 : NOT IN</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">배열 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">배열 요소 접근 자. &lt;code&gt;subscript&lt;/code&gt; 는 &lt;code&gt;index&lt;/code&gt; 또는 &lt;code&gt;start_index to end_index&lt;/code&gt; 두 가지 형식으로 제공 될 수 있습니다 . 첫 번째 형식은 인덱스별로 단일 배열 요소를 반환합니다. 두 번째 형식은 제공된 &lt;code&gt;start_index&lt;/code&gt; 및 &lt;code&gt;end_index&lt;/code&gt; 에 해당하는 요소를 포함하여 인덱스 범위별로 배열 슬라이스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">확장의 구성 테이블에 대한 &lt;code&gt;WHERE&lt;/code&gt; -clause 필터 조건의 배열. 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">확장의 구성 테이블에 대한 &lt;code&gt;regclass&lt;/code&gt; OID 배열. 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">실제 항목을 가리키는 항목 식별자의 배열입니다. 각 항목은 (오프셋, 길이) 쌍입니다. 항목 당 4 바이트</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">구독 된 발행물 이름의 배열입니다. 이들은 발행자 서버의 발행물을 참조합니다. 출판물에 대한 자세한 내용 &lt;a href=&quot;logical-replication-publication&quot;&gt;은 30.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">배열 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">배열 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">배열 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">배열 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">배열 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">배열 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">배열 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">배열 : =</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">배열 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">배열 : array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">배열 : array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">배열 : array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">배열 : array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">배열 : array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">배열 : array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">배열 : array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">배열 : array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">배열 : array_positions</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">배열 : array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">배열 : array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">배열 : array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">배열 : array_to_string</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">배열 : array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">배열 : 카디널리티</target>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">배열 : string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">배열 : unnest</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">배열 : ||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">배열은 설정되지 않습니다. 특정 배열 요소를 검색하면 데이터베이스 디자인이 잘못 될 수 있습니다. 배열 요소가 될 각 항목에 대해 행이있는 별도의 테이블을 사용하십시오. 이것은 검색하기 쉬울 것이며 많은 요소에 대해 더 잘 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">PostgreSQL이 의미하는 것처럼 이것은 일어나지 않습니다. 큰 물체는 그 자체로 물체로 취급됩니다. 테이블 항목은 OID로 큰 개체를 참조 할 수 있지만 동일한 큰 개체 OID를 참조하는 여러 테이블 항목이있을 수 있으므로 시스템은 그러한 항목 중 하나를 변경하거나 제거하더라도 큰 개체를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">결과적으로 부작용이있는 함수를 복잡한 표현의 일부로 사용하는 것은 현명하지 않습니다. &lt;code&gt;WHERE&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절 에서 부작용 또는 평가 순서에 의존하는 것이 특히 위험합니다. 이러한 절은 실행 계획 개발의 일부로 광범위하게 재 처리되기 때문입니다. 해당 절의 부울 표현식 ( &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; 조합)은 부울 대 수법에 의해 허용되는 방식으로 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">편의상 쉘에서 실행하여 새 데이터베이스 &lt;code&gt;createdb&lt;/code&gt; 을 실행할 수있는 프로그램이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">일반적으로 나열된 키워드를 식별자로 포함하는 명령에 대해 가짜 파서 오류가 발생하면 식별자를 인용하여 문제가 해결되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">이러한 유형의 오류에 대한 부분 보호 수단으로 가변 길이 또는 널 입력 가능 필드는 C 컴파일러에 직접 표시되지 않아야합니다. 이것은 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; ( &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; 은 정의되지 않은 기호) 로 랩핑하여 수행됩니다 . 이렇게하면 C 코드가 존재하지 않거나 다른 오프셋에있을 수있는 필드에 부주의하게 액세스하지 못합니다. 잘못된 행을 만들지 않도록 독립적 인 보호를 위해 null이 아닌 모든 열을 &lt;code&gt;pg_attribute&lt;/code&gt; 에 표시해야 합니다. 부트 스트랩 코드는 카탈로그 열을 &lt;code&gt;NOT NULL&lt;/code&gt; 로 자동 표시 합니다.너비가 고정되어 있고 널 입력 가능 열이 앞에 있지 않은 경우 이 규칙이 적절하지 않은 경우 필요에 따라 &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; 및 &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; 주석을 사용하여 올바른 표시를 강제 할 수 있습니다 . 그러나 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건은 임의의 C 코드로 생성 된 튜플에 대한 것이 아니라 실행 프로그램에서만 시행되므로 카탈로그 행을 수동으로 만들거나 업데이트 할 때는 여전히주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">파티션 된 테이블에 직접 데이터가 없으므로 파티션 된 테이블에서 &lt;code&gt;TRUNCATE&lt;/code&gt; &lt;code&gt;ONLY&lt;/code&gt; 만 사용 하면 항상 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">결과적으로 대기에만 존재하는 추가 인덱스 나 대기에만 존재하는 통계를 작성할 수 없습니다. 이러한 관리 명령이 필요한 경우 기본 명령을 실행해야하며 결국 이러한 변경 사항이 대기로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">일반적으로 &lt;code&gt;queryid&lt;/code&gt; 값은 기본 서버 버전과 카탈로그 메타 데이터 세부 사항이 동일하게 유지되는 한 안정적이고 비교 가능한 것으로 가정 할 수 있습니다. 물리적 WAL 재생을 기반으로 복제에 참여하는 두 서버 는 동일한 쿼리에 대해 동일한 &lt;code&gt;queryid&lt;/code&gt; 값 을 가질 것으로 예상 할 수 있습니다 . 그러나 논리적 복제 체계는 모든 관련 세부 사항에서 복제본을 동일하게 유지한다고 약속하지 않으므로 &lt;code&gt;queryid&lt;/code&gt; 는 일련의 논리적 복제본에서 비용을 축적하는 데 유용한 식별자가 아닙니다. 의심스러운 경우 직접 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">안전 장치로서 multixact-age가 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 보다 큰 테이블에 대해 적극적인 진공 스캔이 발생합니다 . 사용 된 멤버 스토리지 공간의 양이 주소 지정 가능한 스토리지 공간의 50 %를 초과하는 경우 가장 오래된 멀티 랙스 연령을 가진 테이블부터 시작하여 모든 테이블에 대해 점진적 진공 스캔이 점진적으로 발생합니다. autovacuum이 명목상 비활성화되어 있어도 이러한 종류의 공격적인 스캔이 모두 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">온 전성 검사로서 &lt;code&gt;seg&lt;/code&gt; 는 하한이 상한보다 큰 구간을 거부합니다 (예 : &lt;code&gt;5 .. 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">간단한 예로, &lt;code&gt;managers&lt;/code&gt; 역할의 구성원 만 자신의 계정 행에만 액세스 할 수 있도록 &lt;code&gt;account&lt;/code&gt; 관계 에 대한 정책을 만드는 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">구조가 일치해야한다는 일반적인 원칙에 대한 특별한 예외로 배열은 기본 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL이 C가 아닌 로케일에서 &lt;code&gt;LIKE&lt;/code&gt; 절 과 함께 색인을 사용할 수있게하는 임시 해결책으로 여러 사용자 정의 연산자 클래스가 있습니다. 로케일 비교 규칙을 무시하고 엄격한 문자 별 비교를 수행하는 색인을 작성할 수 있습니다. 자세한 정보는 &lt;a href=&quot;indexes-opclass&quot;&gt;11.10 절&lt;/a&gt; 을 참조하십시오. 다른 접근법은 &lt;a href=&quot;collation&quot;&gt;23.2 절&lt;/a&gt; 에서 논의 된 바와 같이 &lt;code&gt;C&lt;/code&gt; 데이터 정렬을 사용하여 인덱스를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">위와 같이 두 테이블 &lt;code&gt;actors&lt;/code&gt; 와 &lt;code&gt;directors&lt;/code&gt; 만 가져옵니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; 옵션 의 대안으로 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">대안으로 파티션 구조 외부에 새 테이블을 작성하고 나중에 적절한 파티션으로 만드는 것이 더 편리한 경우가 있습니다. 이를 통해 분할 된 테이블에 데이터가 나타나기 전에 데이터를로드, 확인 및 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">이러한 함수에 의해 생성 된 출력을 사용하는 예로서, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;그림 9.1&lt;/a&gt; 은 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; 의 출력을 테이블 데이터의 테이블 형식 변환을 포함하는 HTML 문서 로 변환하는 XSLT 스타일 시트를 보여줍니다 . 비슷한 방식으로 이러한 함수의 결과를 다른 XML 기반 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">예를 들어 내장 &lt;code&gt;english&lt;/code&gt; 구성 을 복제하여 구성 &lt;code&gt;pg&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">예를 들어 , 초기에 다음을 포함하는 &lt;code&gt;mytab&lt;/code&gt; 테이블을 고려하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
