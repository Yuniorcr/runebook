<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="324780c29ae9b46671035da5fbfcca3eeeaa0b74" translate="yes" xml:space="preserve">
          <source>Loading an extension requires the same privileges that would be required to create its component objects. For most extensions this means superuser or database owner privileges are needed. The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension's script.</source>
          <target state="translated">확장을로드하려면 해당 구성 요소 개체를 만드는 데 필요한 것과 동일한 권한이 필요합니다. 대부분의 확장에서 수퍼 유저 또는 데이터베이스 소유자 권한이 필요합니다. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 을 실행하는 사용자 는 이후의 권한 검사를 위해 확장의 소유자와 확장의 스크립트에 의해 생성 된 모든 개체의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff55ba6c7cc873988ea156302dfd04284604724" translate="yes" xml:space="preserve">
          <source>Locale Support</source>
          <target state="translated">로케일 지원</target>
        </trans-unit>
        <trans-unit id="1615ae9075efc2383f73fbc3997d85cdd39b60c0" translate="yes" xml:space="preserve">
          <source>Locale support is automatically initialized when a database cluster is created using &lt;code&gt;initdb&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct &lt;code&gt;initdb&lt;/code&gt; exactly which locale to use by specifying the &lt;code&gt;--locale&lt;/code&gt; option. For example:</source>
          <target state="translated">로케일 지원은 데이터베이스 클러스터가 &lt;code&gt;initdb&lt;/code&gt; 를 사용하여 작성 될 때 자동으로 초기화 됩니다 . &lt;code&gt;initdb&lt;/code&gt; 는 기본적으로 실행 환경의 로케일 설정으로 데이터베이스 클러스터를 초기화하므로 시스템이 데이터베이스 클러스터에서 원하는 로케일을 사용하도록 이미 설정되어 있으면 다른 조치가 필요하지 않습니다. 다른 로케일을 사용하려는 경우 (또는 시스템이 어떤 로케일로 설정되어 있는지 확실하지 않은 경우) &lt;code&gt;--locale&lt;/code&gt; 옵션 을 지정하여 &lt;code&gt;initdb&lt;/code&gt; 에 사용할 로케일을 정확하게 지시 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9fc941160f1b0396956bfd39853ec712bd8d1fb" translate="yes" xml:space="preserve">
          <source>Localization</source>
          <target state="translated">Localization</target>
        </trans-unit>
        <trans-unit id="405016b1820c348aea5cd317a6502812cdf4ad22" translate="yes" xml:space="preserve">
          <source>Location of root page (zero if none)</source>
          <target state="translated">루트 페이지의 위치 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="24d45a6df98cb6f2c1180b96048b79a73fa5f768" translate="yes" xml:space="preserve">
          <source>Location of specified substring</source>
          <target state="translated">지정된 부분 문자열의 위치</target>
        </trans-unit>
        <trans-unit id="dbb39d513ae60400b7ebae4d62c9e5ac6f77044b" translate="yes" xml:space="preserve">
          <source>Location of specified substring (same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order)</source>
          <target state="translated">지정된 하위 문자열의 &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; 와 동일하지만 인수 순서가 역순 임)</target>
        </trans-unit>
        <trans-unit id="9c2e448b0989a5090dc489ea6de417d94cf811c0" translate="yes" xml:space="preserve">
          <source>LocationIndex</source>
          <target state="translated">LocationIndex</target>
        </trans-unit>
        <trans-unit id="c804bf0349b9527944ec4a3fe74284d562dd49b7" translate="yes" xml:space="preserve">
          <source>Lock Management</source>
          <target state="translated">잠금 관리</target>
        </trans-unit>
        <trans-unit id="9f5be0c66691f0334e7d2037502bfeef360b9c5d" translate="yes" xml:space="preserve">
          <source>Lock mode of lockers (more than one if multitransaction), an array of &lt;code&gt;Key Share&lt;/code&gt;, &lt;code&gt;Share&lt;/code&gt;, &lt;code&gt;For No Key Update&lt;/code&gt;, &lt;code&gt;No Key Update&lt;/code&gt;, &lt;code&gt;For Update&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;.</source>
          <target state="translated">사물함 잠금 모드 (multitransaction 경우 하나 이상의)의 배열 &lt;code&gt;Key Share&lt;/code&gt; , &lt;code&gt;Share&lt;/code&gt; , &lt;code&gt;For No Key Update&lt;/code&gt; , &lt;code&gt;No Key Update&lt;/code&gt; , &lt;code&gt;For Update&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9404601307758cbcb4a22750c03c625138fcfc8" translate="yes" xml:space="preserve">
          <source>Locking and Indexes</source>
          <target state="translated">잠금 및 색인</target>
        </trans-unit>
        <trans-unit id="8804d3dd97270b8420c7ca1e904a01e8634cbbf1" translate="yes" xml:space="preserve">
          <source>Locking the regular and/or predicate lock manager could have some impact on database performance if this view is very frequently accessed. The locks are held only for the minimum amount of time necessary to obtain data from the lock managers, but this does not completely eliminate the possibility of a performance impact.</source>
          <target state="translated">이보기에 자주 액세스하는 경우 일반 및 / 또는 술어 잠금 관리자를 잠그면 데이터베이스 성능에 영향을 줄 수 있습니다. 잠금은 잠금 관리자로부터 데이터를 얻는 데 필요한 최소 시간 동안 만 유지되지만 성능에 영향을 줄 가능성을 완전히 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="737c6c38b2b84007c82ea914cea8efb3178d5fdf" translate="yes" xml:space="preserve">
          <source>Log File Maintenance</source>
          <target state="translated">로그 파일 유지 관리</target>
        </trans-unit>
        <trans-unit id="6d6b239b122bc0b05311eb6dfbfaaf45f232b9f3" translate="yes" xml:space="preserve">
          <source>Log Sequence Number, see &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt;.</source>
          <target state="translated">로그 시퀀스 번호는 &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;wal-internals&quot;&gt;WAL 내부를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d305d15801e1e955744206adafaf8f3e3d1bb78e" translate="yes" xml:space="preserve">
          <source>Log-Shipping Standby Servers</source>
          <target state="translated">로그 전달 대기 서버</target>
        </trans-unit>
        <trans-unit id="2445214b8389f14bf2045be1111d0264af049737" translate="yes" xml:space="preserve">
          <source>Logical Decoding</source>
          <target state="translated">논리적 디코딩</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="e81affcc4578ce875d0e0b75ca689bf2f32a90ae" translate="yes" xml:space="preserve">
          <source>Logical Operators: AND</source>
          <target state="translated">논리 연산자 : AND</target>
        </trans-unit>
        <trans-unit id="43e083b90a70b3c47c8f0041d3ea2af4e65c51e3" translate="yes" xml:space="preserve">
          <source>Logical Operators: NOT</source>
          <target state="translated">논리 연산자 : NOT</target>
        </trans-unit>
        <trans-unit id="d639dd9302fac485c5ef253dceb1e3f97c540d72" translate="yes" xml:space="preserve">
          <source>Logical Operators: OR</source>
          <target state="translated">논리 연산자 : OR</target>
        </trans-unit>
        <trans-unit id="b3d8aa18dbe5d539b67385e1079b7cb40cef477e" translate="yes" xml:space="preserve">
          <source>Logical Replication</source>
          <target state="translated">논리적 복제</target>
        </trans-unit>
        <trans-unit id="8922d517c58eafe0151a7cf981679470b4600e69" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">논리 디코딩 구축하는 데 사용할 수있는 &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;동기 복제&lt;/a&gt; 에 대한 동기 복제와 같은 사용자 인터페이스 솔루션 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;스트리밍 복제를&lt;/a&gt; . 이를 위해서는 스트리밍 복제 인터페이스 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;섹션 48.3&lt;/a&gt; 참조 )를 사용하여 데이터를 스트리밍해야합니다. 클라이언트는 스트리밍 복제 클라이언트와 마찬가지로 &lt;code&gt;Standby status update (F)&lt;/code&gt; ) 메시지 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 ) 를 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="7b10ab294a9b68fd1f46ed7bc6062a04492e6157" translate="yes" xml:space="preserve">
          <source>Logical group of the parameter</source>
          <target state="translated">매개 변수의 논리 그룹</target>
        </trans-unit>
        <trans-unit id="c580b15c66ecbba918b3e32fb395e268ced977ef" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">논리적 복제를 통해 데이터베이스 서버는 데이터 수정 스트림을 다른 서버로 보낼 수 있습니다. PostgreSQL 논리 복제는 WAL에서 논리 데이터 수정 스트림을 구성합니다. 논리적 복제를 통해 개별 테이블의 데이터 변경 사항을 복제 할 수 있습니다. 논리적 복제에는 특정 서버를 마스터 또는 복제본으로 지정하지 않아도되지만 데이터가 여러 방향으로 흐를 수 있습니다. 논리적 복제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30 장을&lt;/a&gt; 참조하십시오 . 논리적 디코딩 인터페이스 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; )를 통해 타사 확장도 비슷한 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed65fe8b9917e90ed44964dea1e1dc23e674a9f1" translate="yes" xml:space="preserve">
          <source>Logical replication behaves similarly to normal DML operations in that the data will be updated even if it was changed locally on the subscriber node. If incoming data violates any constraints the replication will stop. This is referred to as a &lt;em&gt;conflict&lt;/em&gt;. When replicating &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations, missing data will not produce a conflict and such operations will simply be skipped.</source>
          <target state="translated">논리적 복제는 데이터가 구독자 노드에서 로컬로 변경된 경우에도 데이터가 업데이트된다는 점에서 일반 DML 작업과 유사하게 작동합니다. 들어오는 데이터가 제약 조건을 위반하면 복제가 중지됩니다. 이를 &lt;em&gt;충돌&lt;/em&gt; 이라고합니다 . &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업을 복제 할 때 누락 된 데이터는 충돌을 일으키지 않으며 이러한 작업은 간단히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="686d57c78ae4b376c0e25252dd6b05a5049c2f9c" translate="yes" xml:space="preserve">
          <source>Logical replication currently has the following restrictions or missing functionality. These might be addressed in future releases.</source>
          <target state="translated">논리적 복제에는 현재 다음과 같은 제한이 있거나 기능이 없습니다. 향후 릴리스에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc5341d79f09d707679a0da10e711069ef1d9d1a" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">논리적 복제는 물리적 스트리밍 복제와 유사한 아키텍처로 구축됩니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5 절&lt;/a&gt; 참조 ). &quot;walsender&quot;및 &quot;apply&quot;프로세스로 구현됩니다. walsender 프로세스 는 WAL의 논리적 디코딩 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 에서 설명)을 시작 하고 표준 논리적 디코딩 플러그인 (pgoutput)을로드합니다. 플러그인은 WAL에서 읽은 변경 사항을 논리적 복제 프로토콜 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;52.5&lt;/a&gt; 참조 )로 변환하고 게시 사양에 따라 데이터를 필터링합니다. 그런 다음 데이터는 스트리밍 복제 프로토콜을 사용하여 적용 작업자에게 지속적으로 전송됩니다. 적용 작업자는 데이터를 로컬 테이블에 맵핑하고 수신 된 개별 변경 사항을 올바른 트랜잭션 순서로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="435079a68c735c2e34e8587daebbc03ec2b4108b" translate="yes" xml:space="preserve">
          <source>Logical replication requires several configuration options to be set.</source>
          <target state="translated">논리적 복제에는 몇 가지 구성 옵션을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e84a093ac80e997279a156ad3e78ff218f69bfc7" translate="yes" xml:space="preserve">
          <source>Logical replication starts by copying a snapshot of the data on the publisher database. Once that is done, changes on the publisher are sent to the subscriber as they occur in real time. The subscriber applies data in the order in which commits were made on the publisher so that transactional consistency is guaranteed for the publications within any single subscription.</source>
          <target state="translated">논리적 데이터베이스 복제는 게시자 데이터베이스에서 데이터의 스냅 샷을 복사하여 시작됩니다. 이 작업이 완료되면 게시자의 변경 내용이 실시간으로 구독자에게 전송됩니다. 구독자는 단일 구독 내의 게시에 대해 트랜잭션 일관성이 보장되도록 게시자에 대해 커밋 된 순서대로 데이터를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="27b9470b0624c147b034592fe3f3a73182a2151c" translate="yes" xml:space="preserve">
          <source>Logical replication workers are taken from the pool defined by &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">논리적 복제 작업자는 &lt;code&gt;max_worker_processes&lt;/code&gt; 에 의해 정의 된 풀에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a63c3a3aa22b3789bd62013d2f279dd236a57e8e" translate="yes" xml:space="preserve">
          <source>Londiste, Slony</source>
          <target state="translated">론 디스 테, 슬로 니</target>
        </trans-unit>
        <trans-unit id="7ed5823bb2b8c30b7d42594563eaf3c04e339fc5" translate="yes" xml:space="preserve">
          <source>Look at &lt;code&gt;xsyn_sample.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt;, for an example.</source>
          <target state="translated">예를 들어 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 설치된 &lt;code&gt;xsyn_sample.rules&lt;/code&gt; 를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="ca517b17b581321c398ee4798749fdb48a7ae7a7" translate="yes" xml:space="preserve">
          <source>Look at the new state of the data:</source>
          <target state="translated">데이터의 새로운 상태를보십시오 :</target>
        </trans-unit>
        <trans-unit id="30d58e04409362da5a524652a2e000a29c4e8c15" translate="yes" xml:space="preserve">
          <source>Look for the best match.</source>
          <target state="translated">가장 일치하는 것을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6a2e689d9886aec21b389565fdc3ad34371dc41e" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind constraints cannot contain &lt;em&gt;back references&lt;/em&gt; (see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt;), and all parentheses within them are considered non-capturing.</source>
          <target state="translated">Lookahead 및 Lookbehind 제약 조건에는 &lt;em&gt;역 참조가&lt;/em&gt; 포함될 수 없으며 ( &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;9.7.3.3&lt;/a&gt; 참조 ) 그 안의 모든 괄호는 캡처되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="56e8f3a9171c421d0883280c2cd97e28c0e45385" translate="yes" xml:space="preserve">
          <source>Lookup a replication origin by name and return the internal id. If no corresponding replication origin is found an error is thrown.</source>
          <target state="translated">이름으로 복제 원점을 조회하고 내부 ID를 반환합니다. 해당 복제 기점이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55e4cc0e110df2ac3459453907e4bd26c086ff4d" translate="yes" xml:space="preserve">
          <source>Lossiness causes performance degradation due to unnecessary fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.</source>
          <target state="translated">손실은 테이블 레코드의 불필요한 페치로 인해 성능이 저하되어 잘못된 일치로 판명됩니다. 테이블 레코드에 대한 임의 액세스가 느리기 때문에 GiST 인덱스의 유용성이 제한됩니다. 일치하지 않을 가능성은 여러 가지 요소, 특히 고유 단어 수에 따라 달라 지므로 사전을 사용하여이 수를 줄이는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1531c1daacaf1bc409855b8d1d0f55e08ee771dd" translate="yes" xml:space="preserve">
          <source>Low Value</source>
          <target state="translated">낮은 가치</target>
        </trans-unit>
        <trans-unit id="21ceb119d4d9e001890111b5576f7f16ef00c26f" translate="yes" xml:space="preserve">
          <source>Low level base backups can be made in a non-exclusive or an exclusive way. The non-exclusive method is recommended and the exclusive one is deprecated and will eventually be removed.</source>
          <target state="translated">저수준 기본 백업은 비 독점 또는 독점 방식으로 만들 수 있습니다. 비 독점적 방법이 권장되며 독점적 방법은 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="ac4243ecb01964253411eb3c09a126fc164e78e2" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address</source>
          <target state="translated">MAC (미디어 액세스 제어) 주소</target>
        </trans-unit>
        <trans-unit id="566c47d211683b88f50af170e2aa6203ef55b10a" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address (EUI-64 format)</source>
          <target state="translated">MAC (Media Access Control) 주소 (EUI-64 형식)</target>
        </trans-unit>
        <trans-unit id="b3c62ec9e889671f1211f3670d9feb61fe45a931" translate="yes" xml:space="preserve">
          <source>MAC addresses</source>
          <target state="translated">MAC 주소</target>
        </trans-unit>
        <trans-unit id="22afa78dd9eba1a7e4c213c3623011af13b757a5" translate="yes" xml:space="preserve">
          <source>MAC addresses (EUI-64 format)</source>
          <target state="translated">MAC 주소 (EUI-64 형식)</target>
        </trans-unit>
        <trans-unit id="1c27d6be2a8de3b4e76dde98311054d012ea27ef" translate="yes" xml:space="preserve">
          <source>MCV (most-common values) list statistics, serialized as &lt;code&gt;pg_mcv_list&lt;/code&gt; type</source>
          <target state="translated">MCV (가장 일반적인 값) 목록 통계, &lt;code&gt;pg_mcv_list&lt;/code&gt; 유형으로 직렬화</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="43a2b4962eca5b9cc86e8c34c251b4aaf74d69de" translate="yes" xml:space="preserve">
          <source>MD5 crypt</source>
          <target state="translated">MD5 암호</target>
        </trans-unit>
        <trans-unit id="b7800f24354ba47ad5de45633c8b73e60e95cf0f" translate="yes" xml:space="preserve">
          <source>MD5 hash and SHA1</source>
          <target state="translated">MD5 해시 및 SHA1</target>
        </trans-unit>
        <trans-unit id="609399527c0412d282c04a9855b05c67f3f4ed44" translate="yes" xml:space="preserve">
          <source>MD5-based crypt</source>
          <target state="translated">MD5 기반 암호화</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="ab3eeea11f18e2650760cfbc2a9ee637afed8340" translate="yes" xml:space="preserve">
          <source>MOVE &amp;mdash; position a cursor</source>
          <target state="translated">MOVE &amp;mdash; 커서 위치</target>
        </trans-unit>
        <trans-unit id="29f17acbc2455f9f492968fd0bda5a0de71679d9" translate="yes" xml:space="preserve">
          <source>MSVC</source>
          <target state="translated">MSVC</target>
        </trans-unit>
        <trans-unit id="a967eb92e41a009b9209426313752a674c43be15" translate="yes" xml:space="preserve">
          <source>MVCC</source>
          <target state="translated">MVCC</target>
        </trans-unit>
        <trans-unit id="f7f38fb90552f61a802690d695bfa4d9b25df00e" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">메시지 번역 카탈로그를 유지하려면 PostgreSQL이 선호하는 언어를 잘 사용하고 싶어하는 많은 자원 봉사자의 지속적인 노력이 필요합니다. 귀하의 언어로 된 메시지가 현재 이용 가능하지 않거나 완전히 번역되지 않은 경우 도움을 주시면 감사하겠습니다. 도움이 필요하면 &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;54 장을&lt;/a&gt; 참조 하거나 개발자의 메일 링리스트에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="94de303bbef8935622224c5db48199c807ab7d71" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="translated">Maintenance</target>
        </trans-unit>
        <trans-unit id="dce34191f69ff984184a7501bc8f6215cc2b1283" translate="yes" xml:space="preserve">
          <source>Maintenance commands - &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">유지 관리 명령 &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="477597b3a5e3545e4aafdda2f2a69a40df682681" translate="yes" xml:space="preserve">
          <source>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. pg_upgrade uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not be usable for such upgrades. (The community will attempt to avoid such situations.)</source>
          <target state="translated">주요 PostgreSQL 릴리스는 정기적으로 시스템 테이블의 레이아웃을 변경하는 새로운 기능을 정기적으로 추가하지만 내부 데이터 스토리지 형식은 거의 변경되지 않습니다. pg_upgrade는이 사실을 사용하여 새 시스템 테이블을 작성하고 단순히 기존 사용자 데이터 파일을 재사용함으로써 빠른 업그레이드를 수행합니다. 향후 주요 릴리스에서 이전 데이터 형식을 읽을 수없는 방식으로 데이터 저장 형식을 변경하면 pg_upgrade를 이러한 업그레이드에 사용할 수 없습니다. (커뮤니티는 그러한 상황을 피하려고 시도 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="634be9b233dfc40349e54f6799f11f557bdc5c75" translate="yes" xml:space="preserve">
          <source>Make a base backup of the primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;), and load this data onto the standby.</source>
          <target state="translated">기본 서버를 기본 백업하고 ( &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;섹션 25.3.2&lt;/a&gt; 참조 )이 데이터를 대기에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="63a128e9fdffb0bd6c880f9009ba685205efe3c8" translate="yes" xml:space="preserve">
          <source>Make a password valid forever:</source>
          <target state="translated">비밀번호를 영원히 유효하게 만드십시오 :</target>
        </trans-unit>
        <trans-unit id="3d352bc98e86554b9f8e7bb50ec4f35c4891b735" translate="yes" xml:space="preserve">
          <source>Make sure both database servers are stopped using, on Unix, e.g.:</source>
          <target state="translated">유닉스에서 다음과 같은 두 데이터베이스 서버를 사용하여 중지했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b9eb7d5c96a8c5d308e0b19059ab781c2cbe473e" translate="yes" xml:space="preserve">
          <source>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also &lt;a href=&quot;postgres-user&quot;&gt;Section 18.1&lt;/a&gt;.) The location of the key file is specified by the &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; configuration parameter. The default is &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (or whatever directory was specified as &lt;code&gt;sysconfdir&lt;/code&gt; at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</source>
          <target state="translated">PostgreSQL 서버 계정으로 서버 키탭 파일을 읽을 수 있어야합니다 (쓰기 가능하지 않은 경우에만 읽을 수 있어야 함). 키 파일의 위치는 &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; 구성 매개 변수에 의해 지정됩니다 ( &lt;a href=&quot;postgres-user&quot;&gt;섹션 18.1&lt;/a&gt; 참조 ) . 기본값은 &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (또는 빌드시 &lt;code&gt;sysconfdir&lt;/code&gt; 로 지정된 디렉토리 )입니다. 보안상의 이유로 시스템 키탭 파일에 대한 권한을 열지 않고 PostgreSQL 서버에 대해서만 별도의 키탭을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c85ef738c1ba87c2190fc933e484d7ebb7fc1d3b" translate="yes" xml:space="preserve">
          <source>Make sure that your session does not hold more locks than necessary when calling &lt;code&gt;pg_sleep&lt;/code&gt; or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 또는 그 변형을 호출 할 때 세션이 필요한 것보다 더 많은 잠금을 보유하지 않도록하십시오 . 그렇지 않으면 다른 세션이 수면 프로세스를 기다려야하므로 전체 시스템 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b3ea8ab3afc4ab9fbece610d0afa1cdefe9215" translate="yes" xml:space="preserve">
          <source>Make sure the new binaries and support files are installed on all standby servers.</source>
          <target state="translated">새 바이너리 및 지원 파일이 모든 대기 서버에 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4be89cba4680b61369e645efc68f83ec81c167f1" translate="yes" xml:space="preserve">
          <source>Make sure the new standby data directories do &lt;em&gt;not&lt;/em&gt; exist or are empty. If initdb was run, delete the standby servers' new data directories.</source>
          <target state="translated">새 대기 데이터 디렉토리가 존재 하지 &lt;em&gt;않거나&lt;/em&gt; 비어 있는지 확인하십시오 . initdb가 실행 된 경우 대기 서버의 새 데이터 디렉토리를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="173d02f923c11447cf74a27c2960de0e28e12c9b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; prompt for a password to give the database superuser. If you don't plan on using password authentication, this is not important. Otherwise you won't be able to use password authentication until you have a password set up.</source>
          <target state="translated">차종은 &lt;code&gt;initdb&lt;/code&gt; 에 암호가 데이터베이스 슈퍼 유저를 제공하는 프롬프트. 비밀번호 인증을 사용하지 않을 경우에는 중요하지 않습니다. 그렇지 않으면 비밀번호를 설정할 때까지 비밀번호 인증을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="792a9e540ae77e4ca51fdc9b34493d77aa427a96" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; read the database superuser's password from a file. The first line of the file is taken as the password.</source>
          <target state="translated">차종은 &lt;code&gt;initdb&lt;/code&gt; 에 파일에서 데이터베이스 수퍼 유저의 암호를 읽어 보시기 바랍니다. 파일의 첫 번째 줄이 비밀번호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="272e7aa108f37caed38de50c7bbbc12a4eeb39f5" translate="yes" xml:space="preserve">
          <source>Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must be of the same length.</source>
          <target state="translated">두 배열에 의해 정의 된대로 오른쪽 위와 왼쪽 아래의 좌표를 가진 큐브를 만듭니다. 길이는 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7896b684cd247a71e6d914ea864835f0a201cfd2" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube, with the same values for both endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">새 좌표의 두 끝점에 대해 동일한 값을 사용하여 기존 큐브에 차원을 추가하여 새 큐브를 만듭니다. 계산 된 값을 기준으로 큐브를 하나씩 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="43a84f11220bc7ec3aa6c412b1e43c3f1a62c52f" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">기존 큐브에 차원을 추가하여 새 큐브를 만듭니다. 계산 된 값을 기준으로 큐브를 하나씩 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cec244b05a82755211877f23eb89341a3e2a9049" translate="yes" xml:space="preserve">
          <source>Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as desired.</source>
          <target state="translated">배열의 차원 인덱스 목록을 사용하여 기존 큐브에서 새 큐브를 만듭니다. 단일 치수의 끝점을 추출하거나 치수를 삭제하거나 원하는대로 다시 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c70237aa382dcfcb4e30da44d32fffb86de7855" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube with both coordinates the same.</source>
          <target state="translated">두 좌표가 모두 같은 1 차원 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36186a49b5b2bc93a1e3ef40c1a52eabef758439" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube.</source>
          <target state="translated">1 차원 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c491ded092df3548669d7b1b5d203277eaee1f2e" translate="yes" xml:space="preserve">
          <source>Makes a zero-volume cube using the coordinates defined by the array.</source>
          <target state="translated">배열에 의해 정의 된 좌표를 사용하여 볼륨이 0 인 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fefd6a2a56f64d38ec0468fc161189ce50419761" translate="yes" xml:space="preserve">
          <source>Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.</source>
          <target state="translated">뷰를 자유롭게 사용하는 것은 좋은 SQL 데이터베이스 디자인의 핵심 요소입니다. 뷰를 사용하면 일관된 인터페이스 뒤에서 응용 프로그램이 발전함에 따라 변경 될 수있는 테이블 구조의 세부 정보를 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26b359ba37eb8a50cdf02456f39cff00b1155a4" translate="yes" xml:space="preserve">
          <source>Managing Databases</source>
          <target state="translated">데이터베이스 관리</target>
        </trans-unit>
        <trans-unit id="efd2c6be94610f9dd5980e65687b83de3d52e077" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources</source>
          <target state="translated">커널 리소스 관리</target>
        </trans-unit>
        <trans-unit id="9edd256f8994898f1394cd9f5902a2fe3a3418a1" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Huge Pages</source>
          <target state="translated">커널 리소스 관리 : Linux Huge Pages</target>
        </trans-unit>
        <trans-unit id="f84c08e43ab5092b16e87ebd218788d5283b9b4a" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Memory Overcommit</source>
          <target state="translated">커널 리소스 관리 : Linux 메모리 오버 커밋</target>
        </trans-unit>
        <trans-unit id="412c9a22726797c7f1da88a5ca11bb92ea162415" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Resource Limits</source>
          <target state="translated">커널 자원 관리 : 자원 제한</target>
        </trans-unit>
        <trans-unit id="fc3ccce80bea44ef80a6a994d4e4358186b901da" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Shared Memory and Semaphores</source>
          <target state="translated">커널 리소스 관리 : 공유 메모리 및 세마포어</target>
        </trans-unit>
        <trans-unit id="67cd2bd0c8dc97a476e8e47ebb9371727475113d" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: systemd RemoveIPC</source>
          <target state="translated">커널 리소스 관리 : systemd RemoveIPC</target>
        </trans-unit>
        <trans-unit id="67c48d67ef7ae304937a0a8de822ed104f4b2eb2" translate="yes" xml:space="preserve">
          <source>Manually set the WAL starting location by specifying the name of the next WAL segment file.</source>
          <target state="translated">다음 WAL 세그먼트 파일의 이름을 지정하여 WAL 시작 위치를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6ccaa7bcfd25bcb3a947594b5b5ad3594bebb3be" translate="yes" xml:space="preserve">
          <source>Manually set the next OID.</source>
          <target state="translated">다음 OID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b11b4e5b2d203da27bc1c6504a10632af73bd3c8" translate="yes" xml:space="preserve">
          <source>Manually set the next and oldest multitransaction ID.</source>
          <target state="translated">다음 및 가장 오래된 다중 트랜잭션 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="05fcb9c1e9b6c68d58ec688a6b55b68af75801bf" translate="yes" xml:space="preserve">
          <source>Manually set the next multitransaction offset.</source>
          <target state="translated">다음 다중 트랜잭션 오프셋을 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="14870c8a6c58f7f0c07765537e62008b75b3dc73" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID's epoch.</source>
          <target state="translated">다음 거래 ID의 에포크를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4f4f1e99ced530ddd1fa0f7dac805a0ddcf54b22" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID.</source>
          <target state="translated">다음 거래 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="648bd7a8e83568d94a29f369df1e0064e881bb1c" translate="yes" xml:space="preserve">
          <source>Manually set the oldest and newest transaction IDs for which the commit time can be retrieved.</source>
          <target state="translated">커밋 시간을 검색 할 수있는 가장 오래된 최신 트랜잭션 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ff49c52c5651b25a87adf02de107946b0c6a1108" translate="yes" xml:space="preserve">
          <source>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</source>
          <target state="translated">현재 제품이없는 제조업체는 내부 결합이므로 결과에 나타나지 않습니다. 결과에 그러한 제조업체의 이름을 포함 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5d400bc2fffdc5a10db82b688a6346e4cf189544" translate="yes" xml:space="preserve">
          <source>Many database systems have the notion of a one to many table. Such a table usually sits between two indexed tables, for example:</source>
          <target state="translated">많은 데이터베이스 시스템에는 일대 다 테이블 개념이 있습니다. 이러한 테이블은 일반적으로 두 개의 인덱싱 된 테이블 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ffbad28eb7bf7f9a21d96e280ac0310171a900" translate="yes" xml:space="preserve">
          <source>Many developers consider explicitly listing the columns better style than relying on the order implicitly.</source>
          <target state="translated">많은 개발자는 순서에 암시 적으로 의존하는 것보다 열을 명시 적으로 더 나은 스타일로 나열하는 것을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="1cb82d9eaa9bf285209fa61fc5831409cba350d7" translate="yes" xml:space="preserve">
          <source>Many failover systems use just two systems, the primary and the standby, connected by some kind of heartbeat mechanism to continually verify the connectivity between the two and the viability of the primary. It is also possible to use a third system (called a witness server) to prevent some cases of inappropriate failover, but the additional complexity might not be worthwhile unless it is set up with sufficient care and rigorous testing.</source>
          <target state="translated">많은 장애 조치 시스템은 기본 및 대기의 두 시스템 만 사용하여 어떤 종류의 하트 비트 메커니즘으로 연결되어 두 시스템과 기본 시스템의 실행 가능성 사이의 연결을 지속적으로 확인합니다. 부적절한 장애 조치 (failover)의 경우를 방지하기 위해 세 번째 시스템 (감시 서버라고 함)을 사용할 수도 있지만 충분한주의와 엄격한 테스트로 설정하지 않으면 추가적인 복잡성은 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="de1e6960880fdbfac06a6878d8dd73d232d78b66" translate="yes" xml:space="preserve">
          <source>Many installations create their database clusters on file systems (volumes) other than the machine's &amp;ldquo;root&amp;rdquo; volume. If you choose to do this, it is not advisable to try to use the secondary volume's topmost directory (mount point) as the data directory. Best practice is to create a directory within the mount-point directory that is owned by the PostgreSQL user, and then create the data directory within that. This avoids permissions problems, particularly for operations such as pg_upgrade, and it also ensures clean failures if the secondary volume is taken offline.</source>
          <target state="translated">많은 설치는 시스템의 &quot;루트&quot;볼륨 이외의 파일 시스템 (볼륨)에 데이터베이스 클러스터를 만듭니다. 이 작업을 선택하면 보조 볼륨의 최상위 디렉토리 (마운트 포인트)를 데이터 디렉토리로 사용하지 않는 것이 좋습니다. 모범 사례는 PostgreSQL 사용자가 소유 한 마운트 지점 디렉토리 내에 디렉토리를 작성한 다음 그 디렉토리 내에 데이터 디렉토리를 작성하는 것입니다. 이렇게하면 특히 pg_upgrade와 같은 작업에서 권한 문제를 피할 수 있으며 보조 볼륨이 오프라인 상태가되면 정리 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7998a6e83c9395997d176b8166f6ac50148a21ee" translate="yes" xml:space="preserve">
          <source>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead/lookbehind constraints, and the longest/shortest-match (rather than first-match) matching semantics.</source>
          <target state="translated">ARE 확장의 대부분은 Perl에서 빌려 왔지만, 일부 확장은 정리를 위해 변경되었으며 일부 Perl 확장은 없습니다. 비 호환성에는 &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; , 후행 줄 바꿈에 대한 특수 처리 부족, 줄 바꿈 일치 일치의 영향을받는 항목에 대괄호 표현식 추가, 괄호 및 lookahead / lookbehind 제약 조건의 역 참조에 대한 제한 및 일치하는 시맨틱과 일치하는 최장 / 최단 일치 (일치 일치가 아님)</target>
        </trans-unit>
        <trans-unit id="c2510bd4f5c7e075d877a23b92664b0d94264d01" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</source>
          <target state="translated">&lt;a href=&quot;functions-json&quot;&gt;섹션 9.15에&lt;/a&gt; 설명 된 많은 JSON 처리 함수는 유니 코드 이스케이프를 일반 문자로 변환하므로 입력이 &lt;code&gt;jsonb&lt;/code&gt; 가 아닌 &lt;code&gt;json&lt;/code&gt; 유형 인 경우에도 방금 설명한 것과 동일한 유형의 오류가 발생합니다 . &lt;code&gt;json&lt;/code&gt; 입력 함수가 이러한 검사를 수행하지 않는다는 사실은 UTF-8이 아닌 데이터베이스 인코딩에서 JSON 유니 코드 이스케이프의 간단한 저장 (처리없이)을 허용하지만 역사적인 아티팩트로 간주 될 수 있습니다. 일반적으로 JSON의 유니 코드 이스케이프를 가능한 비 UTF8 데이터베이스 인코딩과 혼합하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3ceba3684c41c44915004b6549907098b3d1192" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. Pgpool-II has this capability. Also, this can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">위의 솔루션 중 다수는 여러 서버가 여러 쿼리를 처리하도록 허용하지만 단일 쿼리가 여러 서버를 사용하여 더 빨리 완료하는 것은 허용하지 않습니다. 이 솔루션을 사용하면 여러 서버가 단일 쿼리에서 동시에 작동 할 수 있습니다. 일반적으로 서버간에 데이터를 분할하고 각 서버가 쿼리의 일부를 실행하고 결과를 중앙 서버로 반환하여 결합되어 사용자에게 반환되도록합니다. Pgpool-II에는이 기능이 있습니다. 또한 PL / Proxy 도구 세트를 사용하여 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="686c93751e24bfbb5a5a8babbdffa0304da95e5d" translate="yes" xml:space="preserve">
          <source>Many of the meta-commands act on the &lt;em&gt;current query buffer&lt;/em&gt;. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</source>
          <target state="translated">많은 메타 명령이 &lt;em&gt;현재 쿼리 버퍼에서 작동&lt;/em&gt; 합니다. 이것은 입력 된 SQL 명령 텍스트를 보유하지만 아직 실행을 위해 서버로 전송되지 않은 버퍼입니다. 여기에는 이전 입력 줄과 같은 줄의 메타 명령 앞에 나타나는 텍스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cfb05fe7e11967ff7a6d7fb5a62aee53e9651c" translate="yes" xml:space="preserve">
          <source>Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type &lt;code&gt;jsonb&lt;/code&gt;, because the conversion was already done; but for &lt;code&gt;json&lt;/code&gt; input, this may result in throwing an error, as noted in &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">이러한 많은 함수와 연산자는 JSON 문자열의 유니 코드 이스케이프를 적절한 단일 문자로 변환합니다. 변환이 이미 완료 되었기 때문에 입력이 &lt;code&gt;jsonb&lt;/code&gt; 유형 인 경우에는 문제가 아닙니다 . 그러나 &lt;code&gt;json&lt;/code&gt; 입력의 경우 &lt;a href=&quot;datatype-json&quot;&gt;8.14 절에&lt;/a&gt; 명시된 것처럼 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cd10805ee6287ed464e4a751e94e4711b1b75c0" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">이러한 기능 중 다수는 복제 프로토콜에서 동등한 명령을 갖습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="09d54c9e108446dcc126d9b9edd300bc8f018b7c" translate="yes" xml:space="preserve">
          <source>Many of these operations are only sensible for one-dimensional arrays. Although they will accept input arrays of more dimensions, the data is treated as though it were a linear array in storage order.</source>
          <target state="translated">이러한 작업 중 많은 부분이 1 차원 배열에만 적합합니다. 더 많은 차원의 입력 배열을 허용하지만 데이터는 스토리지 순서의 선형 배열 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="747ffafd1658c72a0cfd879c2f486677fdad72db" translate="yes" xml:space="preserve">
          <source>Many people choose to use scripts to define their &lt;code&gt;archive_command&lt;/code&gt;, so that their &lt;code&gt;postgresql.conf&lt;/code&gt; entry looks very simple:</source>
          <target state="translated">많은 사람들 이 &lt;code&gt;postgresql.conf&lt;/code&gt; 항목이 매우 단순 해 보이 도록 스크립트를 사용하여 &lt;code&gt;archive_command&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="871adaf8d8928b9b6cb8b32ef8db751f5c6cf9e4" translate="yes" xml:space="preserve">
          <source>Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, and &lt;code&gt;COPY&lt;/code&gt; might produce files that other programs cannot process.</source>
          <target state="translated">많은 프로그램이 이상한 CSV 파일을 생성하기 때문에 파일 형식이 표준보다 더 관례입니다. 따라서이 메커니즘을 사용하여 가져올 수없는 파일이있을 수 있으며 &lt;code&gt;COPY&lt;/code&gt; 는 다른 프로그램이 처리 할 수없는 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aced3527162bd0f606c70ff2d552cd6071f17c5f" translate="yes" xml:space="preserve">
          <source>Many users consider it good practice to always list the column names.</source>
          <target state="translated">많은 사용자는 항상 열 이름을 나열하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e8ae0f81b2286e5d586c06978958263d9a26d81" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using Snowball stemmer rules.</source>
          <target state="translated">Snowball 형태소 규칙을 사용하여 단어의 다른 변형을 정식 형태로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8d7f24aaf39a33003cb1dd2dcc4e2ba52ecca563" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using an Ispell dictionary.</source>
          <target state="translated">Ispell 사전을 사용하여 단어의 다른 변형을 정식 형태로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="7153d307c4a8dd126f6b081d2a4d9f2c3be33e38" translate="yes" xml:space="preserve">
          <source>Map phrases to a single word using a thesaurus.</source>
          <target state="translated">동의어 사전을 사용하여 구를 한 단어로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="9b24aee355a7838c5529c7490a65bac5367e010b" translate="yes" xml:space="preserve">
          <source>Map synonyms to a single word using Ispell.</source>
          <target state="translated">Ispell을 사용하여 동의어를 한 단어로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c4ba0822462e0c373aadd5360a69f205c2a7d036" translate="yes" xml:space="preserve">
          <source>Mar</source>
          <target state="translated">Mar</target>
        </trans-unit>
        <trans-unit id="433632ea5cd64cd163c3a390d5e531d33da3c5e5" translate="yes" xml:space="preserve">
          <source>March</source>
          <target state="translated">March</target>
        </trans-unit>
        <trans-unit id="531a1c0bf44a83aa6422d943626b2d77d47c5593" translate="yes" xml:space="preserve">
          <source>Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">마크 커크 우드 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b50963c78fd5ba0ee384ff4f9865fdb85cbddcd7" translate="yes" xml:space="preserve">
          <source>Mark a column as allowing, or not allowing, null values.</source>
          <target state="translated">열을 허용하거나 허용하지 않는 열로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45379fe0fd98739ca8b200f2546c07f11e0483e4" translate="yes" xml:space="preserve">
          <source>Mark current scan position. The access method need only support one remembered scan position per scan.</source>
          <target state="translated">현재 스캔 위치를 표시하십시오. 액세스 방법은 스캔 당 하나의 기억 된 스캔 위치 만 지원하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d89c04496b47c6c7add6d623e145d05e0e90beea" translate="yes" xml:space="preserve">
          <source>Mark the current session as replaying from the given origin, allowing replay progress to be tracked. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to revert. Can only be used if no previous origin is configured.</source>
          <target state="translated">현재 세션을 지정된 오리진에서 재생 중으로 표시하여 재생 진행 상황을 추적 할 수 있습니다. &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; 을 사용 하여 되돌립니다. 이전 원점이 구성되지 않은 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c353ba22d4916c50376ffc56136935d3788b393" translate="yes" xml:space="preserve">
          <source>Mark the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has previously been configured using &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">주어진 LSN 및 타임 스탬프에서 커밋 된 트랜잭션을 재생하는 것으로 현재 트랜잭션을 표시하십시오. 복제 원점이 이전에 &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; 사용하여 구성된 경우에만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8026198ec726c859996827cb2a33d945433d7db7" translate="yes" xml:space="preserve">
          <source>Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a85793fe091f4b79ea4b1cbe55645a43cdb25119" translate="yes" xml:space="preserve">
          <source>Marks the publication as one that replicates changes for all tables in the database, including tables created in the future.</source>
          <target state="translated">나중에 작성된 테이블을 포함하여 데이터베이스의 모든 테이블에 대한 변경 사항을 복제하는 발행물로 발행을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dbea724ab0ab5100a69e78a28b57720c1d6712f2" translate="yes" xml:space="preserve">
          <source>Master failure will never lose data</source>
          <target state="translated">마스터 실패는 데이터를 잃지 않을 것입니다</target>
        </trans-unit>
        <trans-unit id="b17d5df13d0871fd4cf3c5923d856a866da06d96" translate="yes" xml:space="preserve">
          <source>Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to &lt;code&gt;NULL&lt;/code&gt;. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only in &lt;code&gt;COPY FROM&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">인용 된 경우에도 지정된 열의 값을 널 문자열과 일치시키고 일치하는 것이 있으면 값을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 널 (null) 문자열이 비어있는 기본 경우 인용 된 빈 문자열을 NULL로 변환합니다. 이 옵션은 &lt;code&gt;COPY FROM&lt;/code&gt; 에서만 가능하며 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용하는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="53d751384b810e580b81b6af15ea342f4112abe1" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case insensitive</source>
          <target state="translated">대소 문자를 구분하지 않는 정규식과 일치</target>
        </trans-unit>
        <trans-unit id="50df7b2381b68eae63b34b5f24c7004fae5bf76b" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case sensitive</source>
          <target state="translated">대소 문자를 구분하는 정규식과 일치</target>
        </trans-unit>
        <trans-unit id="7844bff419f63af9d9cad339e25621693c32f323" translate="yes" xml:space="preserve">
          <source>Materialized view definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">구체화 된 뷰 정의 (재구성 된 &lt;code&gt;SELECT&lt;/code&gt; 쿼리)</target>
        </trans-unit>
        <trans-unit id="1636e8b4d786c74d148e1a7dc19345ad47a2c025" translate="yes" xml:space="preserve">
          <source>Mathematical operators are provided for many PostgreSQL types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections.</source>
          <target state="translated">많은 PostgreSQL 유형에 대해 수학 연산자가 제공됩니다. 표준 수학 규칙이없는 유형 (예 : 날짜 / 시간 유형)의 경우 후속 섹션에서 실제 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c3d70e9435a7845b6f93f885d627357ee254fe09" translate="yes" xml:space="preserve">
          <source>Mathematical: !</source>
          <target state="translated">수학 :!</target>
        </trans-unit>
        <trans-unit id="fdaf7cc1ab57d2149690173f829e4f0c4dd36551" translate="yes" xml:space="preserve">
          <source>Mathematical: !!</source>
          <target state="translated">수학적 : !!</target>
        </trans-unit>
        <trans-unit id="b5aaa56c60d256db29a89bc57b92703c0f7cb305" translate="yes" xml:space="preserve">
          <source>Mathematical: #</source>
          <target state="translated">수학 : #</target>
        </trans-unit>
        <trans-unit id="181ffc47f204d3f9ba3ff486f0f30c0c0ef1d5b9" translate="yes" xml:space="preserve">
          <source>Mathematical: %</source>
          <target state="translated">수학적 : %</target>
        </trans-unit>
        <trans-unit id="ab7340ae469c4484dcc6f33a45b64f2dbe2c6ff3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;amp;</source>
          <target state="translated">수학 : &amp;amp;</target>
        </trans-unit>
        <trans-unit id="c195fef9b5d30c42138e890a55d18aa8f3e74af3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;gt;&amp;gt;</source>
          <target state="translated">수학 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="14a14395161c1fa4a496e90e3da92831d4e7dcdb" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;lt;&amp;lt;</source>
          <target state="translated">수학 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddb29852cc33e3b226c0621b50ee13e25c0315f2" translate="yes" xml:space="preserve">
          <source>Mathematical: *</source>
          <target state="translated">수학 : *</target>
        </trans-unit>
        <trans-unit id="59ea67514b35bce8cb0c2fb98d96ab75e1042145" translate="yes" xml:space="preserve">
          <source>Mathematical: +</source>
          <target state="translated">수학 : +</target>
        </trans-unit>
        <trans-unit id="9634adf0f4c35060714ef3c74218c7741d96738c" translate="yes" xml:space="preserve">
          <source>Mathematical: -</source>
          <target state="translated">수학 :-</target>
        </trans-unit>
        <trans-unit id="bc7be2afb633a5ef91761e59ad8b5a5f36c92a00" translate="yes" xml:space="preserve">
          <source>Mathematical: /</source>
          <target state="translated">수학적 : /</target>
        </trans-unit>
        <trans-unit id="3196927fede8cfa3807fe6508ad4afd6a4dd5c10" translate="yes" xml:space="preserve">
          <source>Mathematical: @</source>
          <target state="translated">수학 : @</target>
        </trans-unit>
        <trans-unit id="1dadfd5f33c390a7d584396b6077f56229e94a33" translate="yes" xml:space="preserve">
          <source>Mathematical: ^</source>
          <target state="translated">수학 : ^</target>
        </trans-unit>
        <trans-unit id="20a199d0df7c3ce2a80fb78024a1d00c66d000a9" translate="yes" xml:space="preserve">
          <source>Mathematical: abs</source>
          <target state="translated">수학적 : abs</target>
        </trans-unit>
        <trans-unit id="df0e19fdb206e36a2205ad9d44520f7fee9d3470" translate="yes" xml:space="preserve">
          <source>Mathematical: acos</source>
          <target state="translated">수학적 : acos</target>
        </trans-unit>
        <trans-unit id="f713fa364b0d2333d09caea3c059cdf323feaaae" translate="yes" xml:space="preserve">
          <source>Mathematical: acosh</source>
          <target state="translated">수학적 : acosh</target>
        </trans-unit>
        <trans-unit id="15392ccce532b37463508b07d4825a05d6fb2837" translate="yes" xml:space="preserve">
          <source>Mathematical: asin</source>
          <target state="translated">수학 : asin</target>
        </trans-unit>
        <trans-unit id="3fe074bf9a455acf4922429fcb4f7cd46c3c843a" translate="yes" xml:space="preserve">
          <source>Mathematical: asinh</source>
          <target state="translated">수학 : asinh</target>
        </trans-unit>
        <trans-unit id="83a2bb5d54e23969b5a04d6c088114146c9dc45d" translate="yes" xml:space="preserve">
          <source>Mathematical: atan</source>
          <target state="translated">수학적 : 아탄</target>
        </trans-unit>
        <trans-unit id="c731e727bd85d0cc74cb9191f3962ed11a8f3b3b" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2</source>
          <target state="translated">수학적 : atan2</target>
        </trans-unit>
        <trans-unit id="583724a9264d7b0976ad47dcd14d4ac28456738f" translate="yes" xml:space="preserve">
          <source>Mathematical: atanh</source>
          <target state="translated">수학적 : 아탄</target>
        </trans-unit>
        <trans-unit id="177cd0bc699b2203fdf2d4c75fe30163594d7b7e" translate="yes" xml:space="preserve">
          <source>Mathematical: cbrt</source>
          <target state="translated">수학적 : cbrt</target>
        </trans-unit>
        <trans-unit id="2693815a9d6a69c69854809a47650e0275c1e989" translate="yes" xml:space="preserve">
          <source>Mathematical: ceil</source>
          <target state="translated">수학적 : ceil</target>
        </trans-unit>
        <trans-unit id="d952c9a3323ba3a0a0aaeb01f24cc8dfd99821d9" translate="yes" xml:space="preserve">
          <source>Mathematical: ceiling</source>
          <target state="translated">수학적 : 천장</target>
        </trans-unit>
        <trans-unit id="9db09acf97836fbc07512e622eb6635d3a02dc78" translate="yes" xml:space="preserve">
          <source>Mathematical: cos</source>
          <target state="translated">수학 : cos</target>
        </trans-unit>
        <trans-unit id="ae9e7e216cc8b38acc3988effacc0b9c9f145f6e" translate="yes" xml:space="preserve">
          <source>Mathematical: cosh</source>
          <target state="translated">수학 : 코쉬</target>
        </trans-unit>
        <trans-unit id="6bd28a5aa54b3401f41f88e5856f7384f5d30c00" translate="yes" xml:space="preserve">
          <source>Mathematical: cot</source>
          <target state="translated">수학적 : 간이 침대</target>
        </trans-unit>
        <trans-unit id="18ccdbc8bc11a04cc3a6bf245df208da8e2cae56" translate="yes" xml:space="preserve">
          <source>Mathematical: degrees</source>
          <target state="translated">수학적 :도</target>
        </trans-unit>
        <trans-unit id="aca19fd89939c16cdb0569b07e58a53ad9349a7b" translate="yes" xml:space="preserve">
          <source>Mathematical: div</source>
          <target state="translated">수학 : div</target>
        </trans-unit>
        <trans-unit id="1e46d6487f521a5afb4ed4dd6a23a59fc059e6e5" translate="yes" xml:space="preserve">
          <source>Mathematical: exp</source>
          <target state="translated">수학적 : 특급</target>
        </trans-unit>
        <trans-unit id="573fe26c7738f0584a8c6cbc5489e02fe641fddb" translate="yes" xml:space="preserve">
          <source>Mathematical: floor</source>
          <target state="translated">수학적 : 바닥</target>
        </trans-unit>
        <trans-unit id="402d0cd4fdb985e3812799945b9fceb07540a0b6" translate="yes" xml:space="preserve">
          <source>Mathematical: ln</source>
          <target state="translated">수학 : ln</target>
        </trans-unit>
        <trans-unit id="85d8f0757c4bc05932d8f5d5e562c9da71c34f89" translate="yes" xml:space="preserve">
          <source>Mathematical: log</source>
          <target state="translated">수학적 : 로그</target>
        </trans-unit>
        <trans-unit id="c83ba153e80e1ad83154d81618c218abe75464e9" translate="yes" xml:space="preserve">
          <source>Mathematical: log10</source>
          <target state="translated">수학 : log10</target>
        </trans-unit>
        <trans-unit id="342c1a68d26670cf3f8565a0897aa5cb7ba34b4e" translate="yes" xml:space="preserve">
          <source>Mathematical: mod</source>
          <target state="translated">수학적 : mod</target>
        </trans-unit>
        <trans-unit id="1c34dfef32b83a1764b863b4bbe019d5862c9c11" translate="yes" xml:space="preserve">
          <source>Mathematical: pi</source>
          <target state="translated">수학적 : pi</target>
        </trans-unit>
        <trans-unit id="886814dcb54a703998bbc0cf8f2f8499a7b62fa5" translate="yes" xml:space="preserve">
          <source>Mathematical: power</source>
          <target state="translated">수학적 : 힘</target>
        </trans-unit>
        <trans-unit id="256f270ce3f202545798a4267069da319d55bdce" translate="yes" xml:space="preserve">
          <source>Mathematical: radians</source>
          <target state="translated">수학적 : 라디안</target>
        </trans-unit>
        <trans-unit id="fa28188b7b4ce61e7fd1e57eb3d3850d1782d895" translate="yes" xml:space="preserve">
          <source>Mathematical: random</source>
          <target state="translated">수학적 : 무작위</target>
        </trans-unit>
        <trans-unit id="38618634f79b9464f7b75f0213cc7c4516883f3f" translate="yes" xml:space="preserve">
          <source>Mathematical: round</source>
          <target state="translated">수학적 : 라운드</target>
        </trans-unit>
        <trans-unit id="d57a36e95bfa64f5eb46d773fdde749c2cb84fc4" translate="yes" xml:space="preserve">
          <source>Mathematical: scale</source>
          <target state="translated">수학적 : 스케일</target>
        </trans-unit>
        <trans-unit id="bf096078393c2c98a0b1e6c717f74e687f878163" translate="yes" xml:space="preserve">
          <source>Mathematical: setseed</source>
          <target state="translated">수학적 : setseed</target>
        </trans-unit>
        <trans-unit id="39f4ee6bf2c1ebbb6d092ca5116d3c60ea228290" translate="yes" xml:space="preserve">
          <source>Mathematical: sign</source>
          <target state="translated">수학 : 부호</target>
        </trans-unit>
        <trans-unit id="21776ac559594087e48aa9a00b1065f77ca338fd" translate="yes" xml:space="preserve">
          <source>Mathematical: sin</source>
          <target state="translated">수학적 : 죄</target>
        </trans-unit>
        <trans-unit id="00e2992e6f676f0cd18285a72f0c1e9d55b0d240" translate="yes" xml:space="preserve">
          <source>Mathematical: sinh</source>
          <target state="translated">수학 : sinh</target>
        </trans-unit>
        <trans-unit id="aae7a6e9b70d02f4e993a9db74c8db3083ef0bfc" translate="yes" xml:space="preserve">
          <source>Mathematical: sqrt</source>
          <target state="translated">수학 : sqrt</target>
        </trans-unit>
        <trans-unit id="02a3ee3cf42cf2113efd88c1ad458433f9a69197" translate="yes" xml:space="preserve">
          <source>Mathematical: tan</source>
          <target state="translated">수학적 : 황갈색</target>
        </trans-unit>
        <trans-unit id="43ac9c6f98336e23241f94c577f53cb99b066801" translate="yes" xml:space="preserve">
          <source>Mathematical: tanh</source>
          <target state="translated">수학적 : tanh</target>
        </trans-unit>
        <trans-unit id="fd05d42d41de6870056e68c4ccd289ca842197c7" translate="yes" xml:space="preserve">
          <source>Mathematical: trunc</source>
          <target state="translated">수학 : 잘림</target>
        </trans-unit>
        <trans-unit id="b3fcfe03e83f0fd3f41685d5a0a35fa941c16d42" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket</source>
          <target state="translated">수학 : width_bucket</target>
        </trans-unit>
        <trans-unit id="dfa1e770f800f341e62dbc76cea5befa40e67f50" translate="yes" xml:space="preserve">
          <source>Mathematical: |</source>
          <target state="translated">수학 : |</target>
        </trans-unit>
        <trans-unit id="b18f08aa2ba95d26e5185b6a71ed15ce174e5b8f" translate="yes" xml:space="preserve">
          <source>Mathematical: |/</source>
          <target state="translated">수학 : | /</target>
        </trans-unit>
        <trans-unit id="51e150fa17498f246e415139012baeb22d8f4d4a" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/</source>
          <target state="translated">수학 : || /</target>
        </trans-unit>
        <trans-unit id="3eacd2f34aae3951141d12b3b8bacb1b57ee7e7b" translate="yes" xml:space="preserve">
          <source>Mathematical: ~</source>
          <target state="translated">수학적 : ~</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="eebfdb589d2a38f34e9a5e134f62af1ef891433d" translate="yes" xml:space="preserve">
          <source>Max Password Length</source>
          <target state="translated">최대 비밀번호 길이</target>
        </trans-unit>
        <trans-unit id="462156397b99eeccfdb0f5b4ea63ec4407a809bc" translate="yes" xml:space="preserve">
          <source>Maximum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">매개 변수의 최대 허용 값 (숫자가 아닌 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="f4c49a25b4f19cb0213949aa3e28ef3557be3a93" translate="yes" xml:space="preserve">
          <source>Maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1m&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">클라이언트 인증을 완료 할 수있는 최대 시간입니다. 클라이언트가이 시간 내에 인증 프로토콜을 완료하지 않은 경우 서버는 연결을 닫습니다. 이로 인해 정지 된 클라이언트가 연결을 무기한으로 차지하지 못하게됩니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 1 분 ( &lt;code&gt;1m&lt;/code&gt; )입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16d4343ca4b0ff10b386fabaeb90ec48c83feb93" translate="yes" xml:space="preserve">
          <source>Maximum depth to descend to, or zero for unlimited depth</source>
          <target state="translated">최대로 내려갈 최대 깊이 또는 무제한 깊이의 경우 0</target>
        </trans-unit>
        <trans-unit id="6e382e12a5004b51a9fb6db4c19fb4ad8b8e10a3" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphore identifiers (i.e., sets)</source>
          <target state="translated">세마포어 식별자의 최대 개수 (예 : 세트)</target>
        </trans-unit>
        <trans-unit id="0c59e3da96b0612eb2065c185976ccb89f3be9d6" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores per set</source>
          <target state="translated">세트당 최대 세마포어 수</target>
        </trans-unit>
        <trans-unit id="352ff6e41f28fb4dd9615ad5c6b893bc2f0820a2" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores system-wide</source>
          <target state="translated">시스템 전체의 최대 세마포어 수</target>
        </trans-unit>
        <trans-unit id="c815c1aa92e98505761f17e71fb912e2b0d50481" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments per process</source>
          <target state="translated">프로세스 당 최대 공유 메모리 세그먼트 수</target>
        </trans-unit>
        <trans-unit id="f5eb5768d25d1069e687fbff6c4cdff705aae7ad" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments system-wide</source>
          <target state="translated">시스템 전체의 최대 공유 메모리 세그먼트 수</target>
        </trans-unit>
        <trans-unit id="e4a5cf08c55be90a96549a51c4d65339bafeb337" translate="yes" xml:space="preserve">
          <source>Maximum number of synchronization workers per subscription. This parameter controls the amount of parallelism of the initial data copy during the subscription initialization or when new tables are added.</source>
          <target state="translated">구독 당 최대 동기화 작업자 수 이 매개 변수는 구독 초기화 중 또는 새 테이블이 추가 될 때 초기 데이터 사본의 병렬 처리량을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cf9da86e68e4a7c2a1bc302b1edbdee46483b5d4" translate="yes" xml:space="preserve">
          <source>Maximum size of shared memory segment (bytes)</source>
          <target state="translated">공유 메모리 세그먼트의 최대 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="d78433a672e983d650938d0f8874ea0c01c8e279" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_segments&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">자동 WAL 체크 포인트 사이에서 WAL이 커질 수있는 최대 크기입니다. 이것은 소프트 한계입니다. 로드가 &lt;code&gt;wal_keep_segments&lt;/code&gt; 거나, &lt;code&gt;archive_command&lt;/code&gt; 실패 또는 높은 wal_keep_segments 설정 과 같은 특수한 상황에서는 WAL 크기가 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과 할 수 있습니다 . 이 값을 단위없이 지정하면 메가 바이트로 간주됩니다. 기본값은 1GB입니다. 이 매개 변수를 늘리면 응급 복구에 필요한 시간이 늘어날 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6663cd5d04ec15d3d8cb068011883bb72c21769" translate="yes" xml:space="preserve">
          <source>Maximum time between automatic WAL checkpoints. If this value is specified without units, it is taken as seconds. The valid range is between 30 seconds and one day. The default is five minutes (&lt;code&gt;5min&lt;/code&gt;). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">자동 WAL 체크 포인트 사이의 최대 시간. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 유효한 범위는 30 초에서 1 일입니다. 기본값은 5 분 ( &lt;code&gt;5min&lt;/code&gt; )입니다. 이 매개 변수를 늘리면 응급 복구에 필요한 시간이 늘어날 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4455b92ac909b4c5503624f3e50369ecbf4e7112" translate="yes" xml:space="preserve">
          <source>Maximum time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에 소요 된 최대 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="e356bc07e535e04e9d9c3334c083fcc3488e0bee" translate="yes" xml:space="preserve">
          <source>Maximum value of semaphore</source>
          <target state="translated">세마포의 최대 값</target>
        </trans-unit>
        <trans-unit id="d73ff195380431a5bbd14d7218270378e35474ca" translate="yes" xml:space="preserve">
          <source>Maximum value of the sequence</source>
          <target state="translated">시퀀스의 최대 값</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="181d211e960e06792dfe28bfac1abd601a4c5a9d" translate="yes" xml:space="preserve">
          <source>Mean time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에서 소요 된 평균 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f0f833c6521b2d19b94ba8d0789e74dc9ccb5388" translate="yes" xml:space="preserve">
          <source>Measuring Executor Timing Overhead</source>
          <target state="translated">집행자 타이밍 오버 헤드 측정</target>
        </trans-unit>
        <trans-unit id="1c83efb5aa232017e707b79cbf793fdfcf4c42d0" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</source>
          <target state="translated">지정된 키를 가진 개체 멤버를 반환하는 멤버 접근 자입니다. 키 이름이 &lt;code&gt;$&lt;/code&gt; 로 시작하는 명명 된 변수 이거나 식별자의 JavaScript 규칙을 충족하지 않는 경우 큰 따옴표로 문자열 리터럴로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc3e8f88c1e4c9777ada8c4e159672ef60421a6a" translate="yes" xml:space="preserve">
          <source>Merge join requires its input data to be sorted on the join keys. In this plan the &lt;code&gt;tenk1&lt;/code&gt; data is sorted by using an index scan to visit the rows in the correct order, but a sequential scan and sort is preferred for &lt;code&gt;onek&lt;/code&gt;, because there are many more rows to be visited in that table. (Sequential-scan-and-sort frequently beats an index scan for sorting many rows, because of the nonsequential disk access required by the index scan.)</source>
          <target state="translated">병합 결합에서는 입력 데이터를 결합 키에서 정렬해야합니다. 이 계획에서 &lt;code&gt;tenk1&lt;/code&gt; 데이터는 인덱스 스캔을 사용하여 올바른 순서로 행을 방문하여 정렬되지만 해당 테이블에 방문 할 행이 더 많으므로 &lt;code&gt;onek&lt;/code&gt; 에 대해 순차적 스캔 및 정렬이 선호됩니다 . (순차 스캔 및 정렬은 인덱스 스캔에 필요한 비 순차 디스크 액세스로 인해 많은 행을 정렬하기 위해 인덱스 스캔을 자주 능가합니다.)</target>
        </trans-unit>
        <trans-unit id="5df467aa951005c5f7e89731194b036d002c4227" translate="yes" xml:space="preserve">
          <source>Merge joins also have measurement artifacts that can confuse the unwary. A merge join will stop reading one input if it's exhausted the other input and the next key value in the one input is greater than the last key value of the other input; in such a case there can be no more matches and so no need to scan the rest of the first input. This results in not reading all of one child, with results like those mentioned for &lt;code&gt;LIMIT&lt;/code&gt;. Also, if the outer (first) child contains rows with duplicate key values, the inner (second) child is backed up and rescanned for the portion of its rows matching that key value. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; counts these repeated emissions of the same inner rows as if they were real additional rows. When there are many outer duplicates, the reported actual row count for the inner child plan node can be significantly larger than the number of rows that are actually in the inner relation.</source>
          <target state="translated">또한 병합 조인에는 측정 아티팩트가있어 경고를 혼란스럽게 할 수 있습니다. 병합 조인은 다른 입력이 소진되고 한 입력의 다음 키 값이 다른 입력의 마지막 키 값보다 큰 경우 한 입력 읽기를 중지합니다. 이러한 경우 더 이상 일치하는 항목이 없으므로 나머지 첫 번째 입력을 스캔 할 필요가 없습니다. 이로 인해 한 명의 자녀를 모두 읽지 못하고 &lt;code&gt;LIMIT&lt;/code&gt; 에 대해 언급 한 것과 같은 결과가 나타납니다 . 또한 외부 (첫 번째) 하위 항목에 중복 키 값이있는 행이 포함되어 있으면 내부 (두 번째) 하위 항목이 해당 키 값과 일치하는 행 부분을 백업하고 다시 스캔합니다. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 동일한 내부 열의 반복 배출을 실제 추가 열인 것처럼 계산합니다. 외부 복제본이 많은 경우 내부 하위 계획 노드에 대해보고 된 실제 행 수는 실제로 내부 관계에있는 행 수보다 훨씬 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6317b9601e7c09c328490aa43dfe87e04fe54d" translate="yes" xml:space="preserve">
          <source>Messages like this indicate that you contacted the server, and it is willing to talk to you, but not until you pass the authorization method specified in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file. Check the password you are providing, or check your Kerberos or ident software if the complaint mentions one of those authentication types.</source>
          <target state="translated">이와 같은 메시지는 서버에 접속했음을 나타내며 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일에 지정된 권한 부여 방법을 통과 할 때까지는 대화 할 의사가 없습니다 . 제공 한 비밀번호를 확인하거나 불만 사항에 해당 인증 유형 중 하나가 언급 된 경우 Kerberos 또는 ID 소프트웨어를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2097f911138f2466e5f32e8351dcd5fd749692" translate="yes" xml:space="preserve">
          <source>Meta-Commands</source>
          <target state="translated">Meta-Commands</target>
        </trans-unit>
        <trans-unit id="f693f5960d30f7053e205f6d9a4425df858962e1" translate="yes" xml:space="preserve">
          <source>Metaphone, like Soundex, is based on the idea of constructing a representative code for an input string. Two strings are then deemed similar if they have the same codes.</source>
          <target state="translated">Soundex와 같은 메타 폰은 입력 문자열에 대한 대표 코드를 구성한다는 아이디어를 기반으로합니다. 두 개의 문자열이 동일한 코드를 갖는 경우 두 개의 문자열이 유사한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c1b37b805340abcc2257db6a661352b683548e" translate="yes" xml:space="preserve">
          <source>Method used for forcing WAL updates out to disk. If &lt;code&gt;fsync&lt;/code&gt; is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</source>
          <target state="translated">WAL 업데이트를 디스크에 적용하는 데 사용되는 방법입니다. &lt;code&gt;fsync&lt;/code&gt; 가 꺼져 있으면 WAL 파일 업데이트가 전혀 적용되지 않으므로이 설정은 관련이 없습니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="628dc441c2bafa1afab14e359fb44c6e901b8f85" translate="yes" xml:space="preserve">
          <source>Michael J. Fromberger</source>
          <target state="translated">마이클 제이 프롬 버거</target>
        </trans-unit>
        <trans-unit id="06fca8ee037d3a593497ab6d139577328dd86787" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C</source>
          <target state="translated">마이크로 소프트 비주얼 C</target>
        </trans-unit>
        <trans-unit id="f0e91d657447be038c5b83745dffb09499d6baf9" translate="yes" xml:space="preserve">
          <source>Military abbreviation for UTC</source>
          <target state="translated">UTC의 군사 약어</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="0d47fa8c3e389b0763d87f2daa4ec6a50fb18dc1" translate="yes" xml:space="preserve">
          <source>Minimum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">매개 변수의 최소 허용 값 (숫자가 아닌 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="c5ae78e276525910ef27ff7ddf6b5c2559e2cb00" translate="yes" xml:space="preserve">
          <source>Minimum number of concurrent open transactions to require before performing the &lt;code&gt;commit_delay&lt;/code&gt; delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 지연을 수행하기 전에 필요한 최소 동시 공개 트랜잭션 수 . 값이 클수록 지연 간격 동안 하나 이상의 다른 트랜잭션이 커밋 할 준비가 될 가능성이 높아집니다. 디폴트는 5 개의 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="c373999e365b4d5993611993a45677502343dcde" translate="yes" xml:space="preserve">
          <source>Minimum size of shared memory segment (bytes)</source>
          <target state="translated">공유 메모리 세그먼트의 최소 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="613154c6477db737a4ffc935d45b4f35e3a112f3" translate="yes" xml:space="preserve">
          <source>Minimum time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에서 소요 된 최소 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="9119800734f587e7d9508436d6ce2f949b6a319c" translate="yes" xml:space="preserve">
          <source>Minimum value of the sequence</source>
          <target state="translated">시퀀스의 최소값</target>
        </trans-unit>
        <trans-unit id="f39b9975fa394daf9211460e65ad5e53c2e0737a" translate="yes" xml:space="preserve">
          <source>Minor releases never change the internal storage format and are always compatible with earlier and later minor releases of the same major version number. For example, version 10.1 is compatible with version 10.0 and version 10.6. Similarly, for example, 9.5.3 is compatible with 9.5.0, 9.5.1, and 9.5.6. To update between compatible versions, you simply replace the executables while the server is down and restart the server. The data directory remains unchanged &amp;mdash; minor upgrades are that simple.</source>
          <target state="translated">부 릴리스는 내부 저장소 형식을 변경하지 않으며 항상 동일한 주 버전 번호의 이전 및 이후 부 릴리스와 호환됩니다. 예를 들어, 버전 10.1은 버전 10.0 및 버전 10.6과 호환됩니다. 마찬가지로 예를 들어 9.5.3은 9.5.0, 9.5.1 및 9.5.6과 호환됩니다. 호환되는 버전간에 업데이트하려면 서버가 다운 된 상태에서 실행 파일을 교체하고 서버를 다시 시작하면됩니다. 데이터 디렉토리는 변경되지 않은 상태로 유지됩니다. 간단한 업그레이드는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c1792a6389bbff158897922be21e2febd6b41e73" translate="yes" xml:space="preserve">
          <source>Minor updates to this package were made by Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; in August/September of 2002. These include changing the precision from single precision to double precision and adding some new functions.</source>
          <target state="translated">이 패키지에 대한 약간의 업데이트 는 2002 년 8 월 / 9 월 에 Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; 에 의해 이루어졌습니다 . 여기에는 정밀도를 단 정밀도에서 배정 밀도로 변경하고 새로운 기능을 추가하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="026961d2894207df681418954ca48774a983ec15" translate="yes" xml:space="preserve">
          <source>Minus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">SQL / JSON 시퀀스를 반복하는 빼기 연산자</target>
        </trans-unit>
        <trans-unit id="dc6ddd468d33fb3431787f38241bee7260f00eb6" translate="yes" xml:space="preserve">
          <source>Minutes (in the time part)</source>
          <target state="translated">분 (시간 부분)</target>
        </trans-unit>
        <trans-unit id="dc12f1b1cf6a0bbb2272d3d7ce2040c69a7ecda0" translate="yes" xml:space="preserve">
          <source>Mixed Interval</source>
          <target state="translated">혼합 간격</target>
        </trans-unit>
        <trans-unit id="70c257e1738553c63bcb8eca3e2dc0f60349ef49" translate="yes" xml:space="preserve">
          <source>Mixing temporary and permanent relations in the same partition tree is not allowed. Hence, if the partitioned table is permanent, so must be its partitions and likewise if the partitioned table is temporary. When using temporary relations, all members of the partition tree have to be from the same session.</source>
          <target state="translated">동일한 파티션 트리에서 임시 관계와 영구 관계를 혼합 할 수 없습니다. 따라서 파티션 된 테이블이 영구적이면 파티션 된 테이블과 마찬가지로 파티션 된 테이블도 영구적이어야합니다. 임시 관계를 사용할 때 파티션 트리의 모든 구성원은 동일한 세션에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="b543d8b0cd27fd8c88c5dd290fcb9193a6d18588" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.26&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">수정자를 모든 템플릿 패턴에 적용하여 동작을 변경할 수 있습니다. 예를 들어 &lt;code&gt;FMMonth&lt;/code&gt; 는 &lt;code&gt;FM&lt;/code&gt; 수정자를 사용하는 &lt;code&gt;Month&lt;/code&gt; 패턴입니다 . &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;표 9.26&lt;/a&gt; 은 날짜 / 시간 형식에 대한 수정 자 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca58f6edfb3451890686c36bc73c14bf67559162" translate="yes" xml:space="preserve">
          <source>Modify an existing record using the values from an &lt;code&gt;hstore&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 값을 사용하여 기존 레코드를 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f15aa8ca874492770383bfd8d9e19998f3752e1" translate="yes" xml:space="preserve">
          <source>Modifying Tables</source>
          <target state="translated">테이블 수정</target>
        </trans-unit>
        <trans-unit id="a72464d357e833dd19b1829bd5b00731edf82afe" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Column</source>
          <target state="translated">테이블 수정 : 열 추가</target>
        </trans-unit>
        <trans-unit id="b0a82b15be32cf23af7a5403931cbba2c3a6b302" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Constraint</source>
          <target state="translated">테이블 수정 : 구속 조건 추가</target>
        </trans-unit>
        <trans-unit id="8c76fff9cefc32ac15f30b5883253ecb9faf24b5" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Data Type</source>
          <target state="translated">테이블 수정 : 열의 데이터 유형 변경</target>
        </trans-unit>
        <trans-unit id="bad9bdb3a7e14e2048b20553d6893b9f2daeb0f9" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Default Value</source>
          <target state="translated">테이블 수정 : 열의 기본값 변경</target>
        </trans-unit>
        <trans-unit id="8649a9592e4298a7e8e6b1abb9ef2b90d9a5be2a" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Column</source>
          <target state="translated">테이블 수정 : 열 제거</target>
        </trans-unit>
        <trans-unit id="98650a2f5b97076e75384a35883a830ea83870d0" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Constraint</source>
          <target state="translated">테이블 수정 : 구속 조건 제거</target>
        </trans-unit>
        <trans-unit id="6ee7fe42d54596a2449882ee5313efaaa712af34" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Column</source>
          <target state="translated">테이블 수정 : 열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="dc81484063645f8a58302e10322fd29ad17f1b92" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Table</source>
          <target state="translated">테이블 수정 : 테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c1e625a012d4612de9e088d7c2a093342964bb1f" translate="yes" xml:space="preserve">
          <source>Modifying a partitioned table or a table with inheritance children fires statement-level triggers attached to the explicitly named table, but not statement-level triggers for its partitions or child tables. In contrast, row-level triggers are fired on the rows in affected partitions or child tables, even if they are not explicitly named in the query. If a statement-level trigger has been defined with transition relations named by a &lt;code&gt;REFERENCING&lt;/code&gt; clause, then before and after images of rows are visible from all affected partitions or child tables. In the case of inheritance children, the row images include only columns that are present in the table that the trigger is attached to. Currently, row-level triggers with transition relations cannot be defined on partitions or inheritance child tables.</source>
          <target state="translated">상속 된 자식이있는 테이블 또는 분할 된 테이블을 수정하면 명시 적으로 명명 된 테이블에 연결된 문 수준 트리거가 발생하지만 해당 파티션 또는 자식 테이블에 대한 문 수준 트리거는 실행되지 않습니다. 반대로 행 수준 트리거는 쿼리에서 명시 적으로 이름이 지정되지 않은 경우에도 영향을받는 파티션 또는 자식 테이블의 행에서 시작됩니다. 명령문 레벨 트리거가 &lt;code&gt;REFERENCING&lt;/code&gt; 절로 이름 지정된 전이 관계로 정의 된 경우, 행의 전후 이미지가 영향을받는 모든 파티션 또는 하위 테이블에서 볼 수 있습니다. 상속 하위의 경우 행 이미지에는 트리거가 첨부 된 테이블에 존재하는 열만 포함됩니다. 현재, 전환 관계가있는 행 레벨 트리거는 파티션 또는 상속 하위 테이블에서 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a03c6c23d3b223671b9d8eba84851fccb59e4a7" translate="yes" xml:space="preserve">
          <source>Module for storing (key, value) pairs</source>
          <target state="translated">(키, 값) 쌍을 저장하기위한 모듈</target>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="6463498da98840aa3b093c82890614171c30b5ef" translate="yes" xml:space="preserve">
          <source>Monetary Types</source>
          <target state="translated">화폐 유형</target>
        </trans-unit>
        <trans-unit id="881c22df54316f0107467a0277ce497e98935f6d" translate="yes" xml:space="preserve">
          <source>Monetary Types: money</source>
          <target state="translated">통화 유형 : 돈</target>
        </trans-unit>
        <trans-unit id="a81434589757e654444719de434c44e9adc0c708" translate="yes" xml:space="preserve">
          <source>Monitoring</source>
          <target state="translated">Monitoring</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="ca09870a2f60b20cbbb11a8f1bfa5c112c7f2481" translate="yes" xml:space="preserve">
          <source>Months (in the date part)</source>
          <target state="translated">월 (일자 부분)</target>
        </trans-unit>
        <trans-unit id="b362fae8ba4022e7ee2c51f663135e4f46fe57f1" translate="yes" xml:space="preserve">
          <source>More about &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; can be found in &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; and &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;code&gt;createdb&lt;/code&gt; 및 &lt;code&gt;dropdb&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; 및 &lt;a href=&quot;app-dropdb&quot;&gt;dropdb에서&lt;/a&gt; 각각 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d8a150db9b3697af1b840b6b8689717b67bec26" translate="yes" xml:space="preserve">
          <source>More complex grouping operations than those described above are possible using the concept of &lt;em&gt;grouping sets&lt;/em&gt;. The data selected by the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses is grouped separately by each specified grouping set, aggregates computed for each group just as for simple &lt;code&gt;GROUP BY&lt;/code&gt; clauses, and then the results returned. For example:</source>
          <target state="translated">그룹화 개념을 사용하여 위에서 설명한 것보다 더 복잡한 그룹화 작업이 가능 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;WHERE&lt;/code&gt; 절에 의해 선택된 데이터 는 지정된 각 그룹화 세트별로 개별적으로 그룹화되고 단순 &lt;code&gt;GROUP BY&lt;/code&gt; 절과 마찬가지로 각 그룹에 대해 집계 된 계산 결과가 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32d9dc5690a3f6016671ea3b2ef25dc790df4069" translate="yes" xml:space="preserve">
          <source>More complex usage can produce undesirable results in Read Committed mode. For example, consider a &lt;code&gt;DELETE&lt;/code&gt; command operating on data that is being both added and removed from its restriction criteria by another command, e.g., assume &lt;code&gt;website&lt;/code&gt; is a two-row table with &lt;code&gt;website.hits&lt;/code&gt; equaling &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;:</source>
          <target state="translated">더 복잡한 사용법은 읽기 커밋 모드에서 바람직하지 않은 결과를 생성 할 수 있습니다. 예를 들어, 고려 &lt;code&gt;DELETE&lt;/code&gt; , 예를 들어, 모두 다른 명령하여 제한 기준에서 추가 및 삭제되는 데이터에 명령의 운영을 가정 &lt;code&gt;website&lt;/code&gt; 있는 2 열 테이블 &lt;code&gt;website.hits&lt;/code&gt; 가 동등 해 &lt;code&gt;9&lt;/code&gt; 및 &lt;code&gt;10&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa123892162b2a296320ac735b855a11c0d07673" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">윈도우 함수에 대한 자세한 정보는에서 찾을 수 있습니다 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21&lt;/a&gt; , &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;섹션 7.2.5&lt;/a&gt; , 그리고 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b706c980fab74ceb0b82c89e1d0e57333d172c3f" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">적절한 입력 및 출력 기능을 포함한 더 많은 예는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;37.13 절에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c771e450e93955920d70db2f3a188ef32edea882" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">부분 인덱스에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt; , &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9300c1996c675687b056f93327336beacca1fbf" translate="yes" xml:space="preserve">
          <source>More information about the lock modes and locking strategies can be found in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">잠금 모드 및 잠금 전략에 대한 자세한 내용은 &lt;a href=&quot;explicit-locking&quot;&gt;13.3 절&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef70336c8dc9c2d758937dd2be0326ac89265cd4" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">데이터 업데이트 및 삭제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;6 장을 참조하십시오&lt;/a&gt; . &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 참조 설명서에서 외래 키 제약 조건 구문에 대한 설명도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e689fb0c34bef953cc6f900b699843e5aff59cf5" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">윈도우 기능에 대한 자세한 내용은 &lt;a href=&quot;tutorial-window&quot;&gt;3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;9.21&lt;/a&gt; 및 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;7.2.5 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b29b35804e6bc278cd58dd861059bfbd8e576bad" translate="yes" xml:space="preserve">
          <source>More specifically, setting this value to &lt;code&gt;on&lt;/code&gt; will add a &lt;code&gt;Gather&lt;/code&gt; node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (or, possibly, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;).</source>
          <target state="translated">보다 구체적으로,이 값을 설정 &lt;code&gt;on&lt;/code&gt; A가 추가됩니다 &lt;code&gt;Gather&lt;/code&gt; 이 나타납니다이 안전 할 수있는 모든 쿼리 계획의 상단에 노드를 그래서 병렬 노동자의 내부 쿼리가 실행됩니다. 병렬 작업자를 사용할 수 없거나 사용할 수없는 경우에도, 병렬 쿼리 컨텍스트에서 금지 된 서브 트랜잭션 시작과 같은 조작은 계획자가 쿼리 실패로 이어질 것으로 판단하지 않는 한 금지됩니다. 이 옵션이 설정 될 때 실패 또는 예기치 않은 결과가 발생하면 조회에서 사용하는 일부 기능을 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (또는 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ) 로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf1a578b87b8dcebec736c6d3df5e511c59a7712" translate="yes" xml:space="preserve">
          <source>More usually, &lt;code&gt;VALUES&lt;/code&gt; is used within a larger SQL command. The most common use is in &lt;code&gt;INSERT&lt;/code&gt;:</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;VALUES&lt;/code&gt; 는 더 큰 SQL 명령 내에서 사용됩니다. 가장 일반적인 용도는 &lt;code&gt;INSERT&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f34f1661d8425a72a96b8b7cb49353a492e8fe95" translate="yes" xml:space="preserve">
          <source>Moreover, if we have a function that accepts a single argument of a composite type, we can call it with either notation. These queries are all equivalent:</source>
          <target state="translated">또한 복합 유형의 단일 인수를 허용하는 함수가 있으면 두 가지 표기법으로 호출 할 수 있습니다. 이러한 쿼리는 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b6b5cd5fdbfc629a7d3f75be5167b4b144a3f86d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;pg_ctl&lt;/code&gt; modes require knowing the data directory location; therefore, the &lt;code&gt;-D&lt;/code&gt; option is required unless &lt;code&gt;PGDATA&lt;/code&gt; is set.</source>
          <target state="translated">대부분의 &lt;code&gt;pg_ctl&lt;/code&gt; 모드는 데이터 디렉토리 위치를 알아야합니다. 따라서 &lt;code&gt;PGDATA&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;-D&lt;/code&gt; 옵션이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="69cf03cafc4ea41c94813d7e422965750bb31a86" translate="yes" xml:space="preserve">
          <source>Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.</source>
          <target state="translated">대부분의 집계 함수는 널 입력을 무시하므로 하나 이상의 표현식에서 널을 생성하는 행은 버려집니다. 별도의 지정이없는 한 모든 내장 집계에 대해 이것이 사실이라고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba0155b71f54b39b68d7c23be1cc2e11116377b" translate="yes" xml:space="preserve">
          <source>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</source>
          <target state="translated">대부분의 원자와 모든 제약 조건에는 탐욕 속성이 없습니다 (어쨌든 가변 량의 텍스트와 일치 할 수 없기 때문에).</target>
        </trans-unit>
        <trans-unit id="7f53fad77c0918001bf87e5c2287a1e18f906e5e" translate="yes" xml:space="preserve">
          <source>Most common implementations</source>
          <target state="translated">가장 일반적인 구현</target>
        </trans-unit>
        <trans-unit id="750c1315d8a2e4c64b7b2cf3fe9029ccf298aef6" translate="yes" xml:space="preserve">
          <source>Most kinds of catalog objects are simply referenced by their names. Note that type names must exactly match the referenced &lt;code&gt;pg_type&lt;/code&gt; entry's &lt;code&gt;typname&lt;/code&gt;; you do not get to use any aliases such as &lt;code&gt;integer&lt;/code&gt; for &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">대부분의 카탈로그 오브젝트는 단순히 이름으로 참조됩니다. 형식 이름은 참조 된 &lt;code&gt;pg_type&lt;/code&gt; 항목의 &lt;code&gt;typname&lt;/code&gt; 과 정확히 일치해야합니다 . 당신은 같은 어떤 별칭을 사용하지 않는 &lt;code&gt;integer&lt;/code&gt; 에 대한 &lt;code&gt;int4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a098765cd76a02dd3c28ed1a2d6ced931f0a323" translate="yes" xml:space="preserve">
          <source>Most queries retrieve only a fraction of the rows in a table, due to &lt;code&gt;WHERE&lt;/code&gt; clauses that restrict the rows to be examined. The planner thus needs to make an estimate of the &lt;em&gt;selectivity&lt;/em&gt; of &lt;code&gt;WHERE&lt;/code&gt; clauses, that is, the fraction of rows that match each condition in the &lt;code&gt;WHERE&lt;/code&gt; clause. The information used for this task is stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; system catalog. Entries in &lt;code&gt;pg_statistic&lt;/code&gt; are updated by the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; commands, and are always approximate even when freshly updated.</source>
          <target state="translated">검사 할 행을 제한하는 &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 대부분의 쿼리는 테이블에서 행의 일부만 검색합니다 . 플래너 따라서 추정치해야하기 &lt;em&gt;선택성&lt;/em&gt; 의 &lt;code&gt;WHERE&lt;/code&gt; 이다 조항, 상기 각 조건에 합치 행 분획 &lt;code&gt;WHERE&lt;/code&gt; 절. 이 작업에 사용 된 정보는 &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그에 저장됩니다 . &lt;code&gt;pg_statistic&lt;/code&gt; 의 항목 은 &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 명령 으로 업데이트되며 새로 업데이트하더라도 항상 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="6eb034f582f8c2b79ea5f1d4aeb8e1cc749b45b2" translate="yes" xml:space="preserve">
          <source>Most scalar data types should have a corresponding array type (that is, a standard varlena array type whose element type is the scalar type, and which is referenced by the &lt;code&gt;typarray&lt;/code&gt; field of the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry). &lt;code&gt;genbki.pl&lt;/code&gt; is able to generate the &lt;code&gt;pg_type&lt;/code&gt; entry for the array type automatically in most cases.</source>
          <target state="translated">대부분의 스칼라 데이터 유형에는 해당 배열 유형 (즉, 요소 ​​유형이 스칼라 유형이고 스칼라 유형 &lt;code&gt;pg_type&lt;/code&gt; 항목 의 &lt;code&gt;typarray&lt;/code&gt; 필드로 참조되는 표준 varlena 배열 유형)이 있어야 합니다 . &lt;code&gt;genbki.pl&lt;/code&gt; 은 대부분의 경우 배열 유형에 대한 &lt;code&gt;pg_type&lt;/code&gt; 항목을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8934cf5770ff56a86643f007085fd816b1b58dfa" translate="yes" xml:space="preserve">
          <source>Most system catalogs are copied from the template database during database creation and are thereafter database-specific. A few catalogs are physically shared across all databases in a cluster; these are noted in the descriptions of the individual catalogs.</source>
          <target state="translated">대부분의 시스템 카탈로그는 데이터베이스를 생성하는 동안 템플릿 데이터베이스에서 복사 된 후 데이터베이스에 따라 다릅니다. 일부 카탈로그는 클러스터의 모든 데이터베이스에서 실제로 공유됩니다. 이들은 개별 카탈로그의 설명에 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7bd8e4c0ba4c5fef185f840f580e4a5b9a25b96" translate="yes" xml:space="preserve">
          <source>Most types of dictionaries rely on configuration files, such as files of stop words. These files &lt;em&gt;must&lt;/em&gt; be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</source>
          <target state="translated">대부분의 유형의 사전은 중지 단어 파일과 같은 구성 파일에 의존합니다. 이러한 파일 &lt;em&gt;은&lt;/em&gt; UTF-8 인코딩으로 저장 &lt;em&gt;해야합니다&lt;/em&gt; . 서버로 읽을 때 실제 데이터베이스 인코딩으로 다른 경우 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="473029ab69353e53921e8ecd7440a49c9a86be94" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">psql의 동작을 제어하는 ​​대부분의 변수는 설정 해제 할 수 없습니다. 대신 &lt;code&gt;\unset&lt;/code&gt; 명령은 기본값으로 설정하는 것으로 해석됩니다. 아래의 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7293739c8cef6860367bef80e497db37fda337b4" translate="yes" xml:space="preserve">
          <source>Moving an object to a new schema additionally requires &lt;code&gt;remove_name&lt;/code&gt; permission on the old schema and &lt;code&gt;add_name&lt;/code&gt; permission on the new one.</source>
          <target state="translated">개체를 새 스키마로 이동하려면 이전 스키마에 대한 &lt;code&gt;remove_name&lt;/code&gt; 권한과 새 스키마 에 대한 &lt;code&gt;add_name&lt;/code&gt; 권한이 추가로 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="9a676159878bdf52262c05ecb519fb1a7d01d39b" translate="yes" xml:space="preserve">
          <source>Much of the PostgreSQL type system is built around a rich set of functions. Functions can have one or more arguments. Since PostgreSQL permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments.</source>
          <target state="translated">대부분의 PostgreSQL 유형 시스템은 다양한 기능을 기반으로 구축되었습니다. 함수는 하나 이상의 인수를 가질 수 있습니다. PostgreSQL은 함수 오버로딩을 허용하므로 함수 이름만으로는 호출 할 함수를 고유하게 식별하지 않습니다. 파서는 제공된 인수의 데이터 유형에 따라 올바른 함수를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="2740f0c680a6e63e450d5b3c062a5229834ae2d2" translate="yes" xml:space="preserve">
          <source>Mule internal code</source>
          <target state="translated">뮬 내부 코드</target>
        </trans-unit>
        <trans-unit id="344fa8c431ce29a1cdabfe9e517c51ceaef15678" translate="yes" xml:space="preserve">
          <source>Multi-Version Concurrency Control</source>
          <target state="translated">다중 버전 동시성 제어</target>
        </trans-unit>
        <trans-unit id="384caf1b9fc6ff1244af37a2f4eefa0674d24a27" translate="yes" xml:space="preserve">
          <source>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</source>
          <target state="translated">다중 열 GIN 인덱스는 복합 값 (열 번호, 키 값) 위에 단일 B- 트리를 작성하여 구현됩니다. 다른 열의 키 값은 다른 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c159674cdc49534760eb0265af934a2b89d41fe" translate="yes" xml:space="preserve">
          <source>Multicolumn Indexes</source>
          <target state="translated">여러 열 인덱스</target>
        </trans-unit>
        <trans-unit id="2d93cd8bc72bc57af1ba376ce47d069b6c4a937d" translate="yes" xml:space="preserve">
          <source>Multicolumn indexes should be used sparingly. In most situations, an index on a single column is sufficient and saves space and time. Indexes with more than three columns are unlikely to be helpful unless the usage of the table is extremely stylized. See also &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt; and &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt; for some discussion of the merits of different index configurations.</source>
          <target state="translated">여러 열 인덱스는 드물게 사용해야합니다. 대부분의 경우 단일 열의 인덱스만으로도 공간과 시간을 절약 할 수 있습니다. 3 개 이상의 열이있는 인덱스는 테이블 사용법이 매우 양식화되어 있지 않으면 도움이되지 않습니다. 다른 인덱스 구성의 장점에 대한 설명은 &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;11.5 절&lt;/a&gt; 및 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;11.9 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99aa634fe16bee7bdf05b0cf7793d76fb5f12b3" translate="yes" xml:space="preserve">
          <source>Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-&lt;code&gt;ARRAY&lt;/code&gt; construct. For example:</source>
          <target state="translated">다차원 배열 생성자 요소는 하위 &lt;code&gt;ARRAY&lt;/code&gt; 구문 뿐만 아니라 적절한 종류의 배열을 생성하는 모든 것이 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dca66d7f2aee43ef1797a393d0e215db306ea18" translate="yes" xml:space="preserve">
          <source>Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word &lt;code&gt;ARRAY&lt;/code&gt; can be omitted. For example, these produce the same result:</source>
          <target state="translated">배열 생성자를 중첩하여 다차원 배열 값을 작성할 수 있습니다. 내부 생성자에서 키워드 &lt;code&gt;ARRAY&lt;/code&gt; 는 생략 할 수 있습니다. 예를 들어, 동일한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d7e3b8a7276708d01165024b6293de444e2c11" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays must have matching extents for each dimension. A mismatch causes an error, for example:</source>
          <target state="translated">다차원 배열에는 각 차원에 대해 일치하는 범위가 있어야합니다. 불일치로 인해 오류가 발생합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="b92978283c35094160cf22fc851c3df5bcf7effd" translate="yes" xml:space="preserve">
          <source>Multilingual Emacs</source>
          <target state="translated">다국어 이맥스</target>
        </trans-unit>
        <trans-unit id="da392350dc33944a643a54bf379fde9199e79c15" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;EXCEPT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;EXCEPT&lt;/code&gt; binds at the same level as &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">괄호로 달리 지정하지 않는 한 동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 왼쪽에서 오른쪽으로 평가됩니다. &lt;code&gt;EXCEPT&lt;/code&gt; 는 &lt;code&gt;UNION&lt;/code&gt; 과 같은 수준에서 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="545da6f8ee31d7740c9c3d5dad863f020a69eb93" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;INTERSECT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;INTERSECT&lt;/code&gt; binds more tightly than &lt;code&gt;UNION&lt;/code&gt;. That is, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; will be read as &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt;.</source>
          <target state="translated">괄호로 달리 지정하지 않는 한 동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;INTERSECT&lt;/code&gt; 연산자가 왼쪽에서 오른쪽으로 평가됩니다. &lt;code&gt;INTERSECT&lt;/code&gt; 는 &lt;code&gt;UNION&lt;/code&gt; 보다 더 밀접하게 바인딩 됩니다. 즉, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; 는 &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt; 으로 읽 힙니다 .</target>
        </trans-unit>
        <trans-unit id="44cc99500b8c6afffdf8915313cbba82fb39e906" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;UNION&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless otherwise indicated by parentheses.</source>
          <target state="translated">동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;UNION&lt;/code&gt; 연산자는 괄호로 표시되지 않는 한 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="09ad30df55e0ee1fdeb0db77709134b50e5f6d5c" translate="yes" xml:space="preserve">
          <source>Multiple Identity Columns</source>
          <target state="translated">여러 ID 열</target>
        </trans-unit>
        <trans-unit id="e2933c3051980c1e2e6ec097345b6b77b93e0721" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</source>
          <target state="translated">여러 개의 RADIUS 서버를 지정할 수 있으며이 경우 순차적으로 시도됩니다. 서버에서 부정적인 응답을 받으면 인증이 실패합니다. 응답이 수신되지 않으면 목록의 다음 서버가 시도됩니다. 여러 서버를 지정하려면 이름을 따옴표로 묶고 서버 이름을 쉼표로 구분하십시오. 여러 서버를 지정하면 다른 모든 RADIUS 옵션을 쉼표로 구분 된 목록으로 제공하여 각 값을 개별 서버에 적용 할 수 있습니다. 단일 값으로 지정할 수도 있습니다.이 경우이 값은 모든 서버에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="47cf9ecc42c00f97b187ac65e4ad87ed8ddddec7" translate="yes" xml:space="preserve">
          <source>Multiple function calls can be combined into a single &lt;code&gt;FROM&lt;/code&gt;-clause item by surrounding them with &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</source>
          <target state="translated">여러 함수 호출 을 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 으로 묶어 단일 &lt;code&gt;FROM&lt;/code&gt; 절 항목 으로 결합 할 수 있습니다 . 이러한 항목의 출력은 각 함수에서 첫 번째 행을 연결 한 다음 각 함수에서 두 번째 행을 연결하는 것입니다. 일부 함수가 다른 함수보다 적은 수의 행을 생성하는 경우 누락 된 데이터에 대해 널 (NULL) 값이 대체되므로 반환 된 총 행 수는 항상 가장 많은 행을 생성 한 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cb041e89d71104ed194545d06d97265abcc8ac5c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance via the &lt;code&gt;INHERITS&lt;/code&gt; clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL.</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 절을 통한 다중 상속 은 PostgreSQL 언어 확장입니다. SQL : 1999 이상은 다른 구문과 의미를 사용하여 단일 상속을 정의합니다. PostgreSQL은 SQL : 1999 스타일 상속을 아직 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfc4b99f808466861398cb5089390dbcf8288968" translate="yes" xml:space="preserve">
          <source>Multiple initial administrators, and all the other options of &lt;code&gt;CREATE ROLE&lt;/code&gt;, are PostgreSQL extensions.</source>
          <target state="translated">여러 초기 관리자 및 다른 &lt;code&gt;CREATE ROLE&lt;/code&gt; 옵션 은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="7023aa5fc8e888d453cd39667bc365999be7e91b" translate="yes" xml:space="preserve">
          <source>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as &lt;code&gt;NOWAIT&lt;/code&gt; if that is specified in any of the clauses affecting it. Otherwise, it is processed as &lt;code&gt;SKIP LOCKED&lt;/code&gt; if that is specified in any of the clauses affecting it.</source>
          <target state="translated">다른 테이블에 대해 다른 잠금 동작을 지정해야하는 경우 여러 잠금 절을 작성할 수 있습니다. 동일한 테이블이 둘 이상의 잠금 절에 의해 언급되거나 암시 적으로 영향을받는 경우 가장 강한 테이블에서만 지정된 것처럼 처리됩니다. 마찬가지로 테이블이 영향을받는 절에 지정된 경우 &lt;code&gt;NOWAIT&lt;/code&gt; 로 테이블이 처리됩니다 . 그렇지 않으면, &lt;code&gt;SKIP LOCKED&lt;/code&gt; 로 영향을주는 조항 중 하나라도 지정되면 SKIP LOCKED 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ff93077b96a2599909c71e452a52b617dcb75f7" translate="yes" xml:space="preserve">
          <source>Multiple-Server Parallel Query Execution</source>
          <target state="translated">다중 서버 병렬 쿼리 실행</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="2c0c5f6099e92ebebc75583d550cc71584a93e4c" translate="yes" xml:space="preserve">
          <source>Multiply the number of rows generated by the scale factor. For example, &lt;code&gt;-s 100&lt;/code&gt; will create 10,000,000 rows in the &lt;code&gt;pgbench_accounts&lt;/code&gt; table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (&lt;code&gt;aid&lt;/code&gt; columns) will switch to using larger integers (&lt;code&gt;bigint&lt;/code&gt;), in order to be big enough to hold the range of account identifiers.</source>
          <target state="translated">스케일 팩터로 생성 된 행 수를 곱하십시오. 예를 들어, &lt;code&gt;-s 100&lt;/code&gt; 은 &lt;code&gt;pgbench_accounts&lt;/code&gt; 테이블 에 10,000,000 개의 행을 작성 합니다. 기본값은 1입니다. 스케일이 20,000 이상인 경우 계정 식별자를 보유하는 데 사용되는 열 ( &lt;code&gt;aid&lt;/code&gt; 컬럼)은 계정 식별자의 범위를 보유 할 수있을만큼 커지기 위해 더 큰 정수 ( &lt;code&gt;bigint&lt;/code&gt; ) 를 사용하도록 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b63b41e9535d1638fe83e7fb152d39f9e2c71b6" translate="yes" xml:space="preserve">
          <source>Multivariate Statistics Examples</source>
          <target state="translated">다변량 통계 예</target>
        </trans-unit>
        <trans-unit id="67f1e276e130e436d878dd37efbefd858f1a15f3" translate="yes" xml:space="preserve">
          <source>Multivariate correlation can be demonstrated with a very simple data set &amp;mdash; a table with two columns, both containing the same values:</source>
          <target state="translated">다변량 상관은 매우 간단한 데이터 세트 (두 개의 열이 있고 동일한 값을 포함하는 테이블)를 사용하여 입증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e9ef2c165e4fa8adf23b844de4bcd199158fae" translate="yes" xml:space="preserve">
          <source>MurmurHash2 hash</source>
          <target state="translated">MurmurHash2 해시</target>
        </trans-unit>
        <trans-unit id="1d1a603b8a91745540a0eb62aecc8635b092e498" translate="yes" xml:space="preserve">
          <source>Mutation as genetic operator is deprecated so that no repair mechanisms are needed to generate legal TSP tours.</source>
          <target state="translated">유전자 조작자로서의 돌연변이는 더 이상 사용되지 않으므로 합법적 인 TSP 투어를 생성하기 위해 수리 메커니즘이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="411d403f2e3b649eb2f47189fa6c058b68a3959d" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST의 요점을 밝히는 Joe Hellerstein 교수 ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) 에게 감사 의 말씀을 전합니다 ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ). 전 학생 Andy Dong은 Illustra를 위해 작성된 그의 예를 들었습니다. 또한 현재와 과거의 모든 Postgres 개발자에게 자신의 세계를 만들고 방해받지 않고 살아갈 수있게되어 감사합니다. 데이터베이스 연구에 대한 수년간의 충실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="63806797acec7e92b9e9bba40d5e19f39040d989" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST의 요점을 설명해 주신 Joe Hellerstein 교수 ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) 에게 감사 를 표합니다 ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ). 또한 현재와 과거의 모든 Postgres 개발자에게 자신의 세계를 만들고 방해받지 않고 살아갈 수있게되어 감사합니다. 데이터베이스 연구에 대한 수년간의 충실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="990ae3b2652542659607c20d6be633d0e3b25e79" translate="yes" xml:space="preserve">
          <source>MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, PostgreSQL implements only the basic compound word operations of Hunspell.</source>
          <target state="translated">MySpell은 복합 단어를 지원하지 않습니다. Hunspell은 복합 단어를 정교하게 지원합니다. 현재 PostgreSQL은 Hunspell의 기본 복합 단어 연산 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5e441f15c5e733792befe0ffc73906895c439622" translate="yes" xml:space="preserve">
          <source>MySpell format is a subset of Hunspell. The &lt;code&gt;.affix&lt;/code&gt; file of Hunspell has the following structure:</source>
          <target state="translated">MySpell 형식은 Hunspell의 하위 집합입니다. Hunspell 의 &lt;code&gt;.affix&lt;/code&gt; 파일 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="488df82bbfc103d0d771499379d0ae7070c9580f" translate="yes" xml:space="preserve">
          <source>N-distinct counts for combinations of column values. If greater than zero, the estimated number of distinct values in the combination. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique combination of columns in which the number of distinct combinations is the same as the number of rows.</source>
          <target state="translated">열 값의 조합에 대한 N 개의 구별 카운트. 0보다 크면 조합에서 추정되는 구별 값의 수입니다. 0보다 작은 경우 고유 값 수의 음수를 행 수로 나눈 값입니다. (거짓된 형식은 &lt;code&gt;ANALYZE&lt;/code&gt; 에서 테이블이 커짐에 따라 고유 한 값의 수가 증가 할 것으로 판단 할 때 사용되며, 양의 형식은 열에 고정 된 수의 가능한 값이있는 경우 사용됩니다.) 예를 들어, -1은 고유 조합 수가 행 수와 동일한 열의 고유 조합.</target>
        </trans-unit>
        <trans-unit id="b9f3788bf337d1fbd1e44a8ca35f9f8dc00922f3" translate="yes" xml:space="preserve">
          <source>N-distinct counts, serialized as &lt;code&gt;pg_ndistinct&lt;/code&gt; type</source>
          <target state="translated">N 개의 고유 카운트, &lt;code&gt;pg_ndistinct&lt;/code&gt; 타입으로 직렬화</target>
        </trans-unit>
        <trans-unit id="e75dedcc315971ca035b9f33d5ff4a268f0acad9" translate="yes" xml:space="preserve">
          <source>NAS</source>
          <target state="translated">NAS</target>
        </trans-unit>
        <trans-unit id="05c70c4a8ccede51b0f764a8b31b48ffad7c77b1" translate="yes" xml:space="preserve">
          <source>NLS</source>
          <target state="translated">NLS</target>
        </trans-unit>
        <trans-unit id="578dc1c57657369feb194b2bc15910a2480a2342" translate="yes" xml:space="preserve">
          <source>NOT &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">NOT &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efde75752ab811815325697b4ba90b5afbe2e2a6" translate="yes" xml:space="preserve">
          <source>NOTIFY</source>
          <target state="translated">NOTIFY</target>
        </trans-unit>
        <trans-unit id="3e7d70b52328177b60019485c8ea011b37cce023" translate="yes" xml:space="preserve">
          <source>NOTIFY &amp;mdash; generate a notification</source>
          <target state="translated">NOTIFY &amp;mdash; 알림 생성</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="385a7cff63d2b3c51a6859910c942e284cc2cff9" translate="yes" xml:space="preserve">
          <source>Name of SSL cipher in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">사용중인 SSL 암호 이름 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="5eaeda54ec9eb68b2072fa5d1feb6c035f44d644" translate="yes" xml:space="preserve">
          <source>Name of a language</source>
          <target state="translated">언어의 이름</target>
        </trans-unit>
        <trans-unit id="0178948b94c691d929c18fcd5464bd15baa26a58" translate="yes" xml:space="preserve">
          <source>Name of a new or existing column.</source>
          <target state="translated">신규 또는 기존 컬럼의 이름.</target>
        </trans-unit>
        <trans-unit id="560c42c98008ce51d03f9d6187d29c37c7009544" translate="yes" xml:space="preserve">
          <source>Name of a new or existing constraint.</source>
          <target state="translated">신규 또는 기존 구속 조건의 이름.</target>
        </trans-unit>
        <trans-unit id="35dcedcca97d439e09701340473e9f3ca046b02c" translate="yes" xml:space="preserve">
          <source>Name of a notification channel (any identifier).</source>
          <target state="translated">알림 채널의 이름 (모든 식별자)</target>
        </trans-unit>
        <trans-unit id="ce514f0b60e997e86128266bb519efbba0a6ff6b" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">설정 가능한 구성 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="954ee074d5be1c36459da8f7253027e56d893199" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 이하에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e3cf73c45665ec4941eb25f3329677ad2c627" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 및 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 참조 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2301404426d669bb911593cec730650e2bdbfe" translate="yes" xml:space="preserve">
          <source>Name of a single trigger to disable or enable.</source>
          <target state="translated">비활성화하거나 활성화 할 단일 트리거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="231d1ed2d468b8d6e17991509cbba8cadc17e1e5" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop or rename.</source>
          <target state="translated">삭제하거나 이름을 바꿀 기존 구속 조건의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22745c3446c7c4d17ba8fa32b15b8f7c06992bdd" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop.</source>
          <target state="translated">제거 할 기존 구속 조건의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b073ede31105aa5c1b6f36a11370455d96d537b0" translate="yes" xml:space="preserve">
          <source>Name of an existing table. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is affected. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are affected. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">기존 테이블의 이름입니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 영향을받습니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우)의 영향을받습니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="694de0e59c53dd44f4f4691acabc413768ef9d9a" translate="yes" xml:space="preserve">
          <source>Name of anonymous-block handler function, or null if none</source>
          <target state="translated">익명 블록 핸들러 함수의 이름.없는 경우 null</target>
        </trans-unit>
        <trans-unit id="5915762ae281a23f2bd1848ce737f5d865ae38a8" translate="yes" xml:space="preserve">
          <source>Name of call handler function</source>
          <target state="translated">호출 핸들러 함수의 이름</target>
        </trans-unit>
        <trans-unit id="206dec00fa32e6c205384b3df437c35f69e88392" translate="yes" xml:space="preserve">
          <source>Name of default version, or &lt;code&gt;NULL&lt;/code&gt; if none is specified</source>
          <target state="translated">기본 버전의 이름 또는 지정되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee034d5b0508537af88d7be3d4206b7d9a6f7ace" translate="yes" xml:space="preserve">
          <source>Name of extended statistics</source>
          <target state="translated">확장 통계 이름</target>
        </trans-unit>
        <trans-unit id="987fff60ced95bb42507af7d6f424dce288531b4" translate="yes" xml:space="preserve">
          <source>Name of index</source>
          <target state="translated">색인 이름</target>
        </trans-unit>
        <trans-unit id="b76e90e08249294dc6388d288e0a0ff43959a02e" translate="yes" xml:space="preserve">
          <source>Name of materialized view</source>
          <target state="translated">구체화 된 뷰의 이름</target>
        </trans-unit>
        <trans-unit id="6501e212c15d2fb75aeb9acf75320931a339d605" translate="yes" xml:space="preserve">
          <source>Name of materialized view's owner</source>
          <target state="translated">구체화 된 뷰 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="e6cf10a0a70ad19c5b7371da58941b6c0037ae86" translate="yes" xml:space="preserve">
          <source>Name of policy</source>
          <target state="translated">정책 이름</target>
        </trans-unit>
        <trans-unit id="a146b1bd6e895582068f638a02a8412aaeadca11" translate="yes" xml:space="preserve">
          <source>Name of publication</source>
          <target state="translated">출판 이름</target>
        </trans-unit>
        <trans-unit id="611f97b7cc9cb3302c011583c51a64d361fde262" translate="yes" xml:space="preserve">
          <source>Name of rule</source>
          <target state="translated">규칙의 이름</target>
        </trans-unit>
        <trans-unit id="916daa93b2ab22b09d0d27a6fc75daa92e090cbf" translate="yes" xml:space="preserve">
          <source>Name of schema containing extended statistic</source>
          <target state="translated">확장 된 통계를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="b8e23c7699d61150cab192ab08cb0a8c8eff18ba" translate="yes" xml:space="preserve">
          <source>Name of schema containing materialized view</source>
          <target state="translated">구체화 된 뷰를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="8a4b8a6f4e6c77468796e3b2343ea829020a1a97" translate="yes" xml:space="preserve">
          <source>Name of schema containing sequence</source>
          <target state="translated">시퀀스를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="9330f5310d2e7af8a885aaca54f40c7a5b2e64d8" translate="yes" xml:space="preserve">
          <source>Name of schema containing table</source>
          <target state="translated">테이블을 포함하는 스키마 이름</target>
        </trans-unit>
        <trans-unit id="dd40e81316e76702c45608033ccb5e0f85f3dfea" translate="yes" xml:space="preserve">
          <source>Name of schema containing table and index</source>
          <target state="translated">테이블 및 인덱스를 포함하는 스키마 이름</target>
        </trans-unit>
        <trans-unit id="b025c1d95310dde444c37ad986883a8dee5bb9d3" translate="yes" xml:space="preserve">
          <source>Name of schema containing table policy is on</source>
          <target state="translated">테이블 정책을 포함하는 스키마 이름이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="651e03eac67fc05e08a5fc3c4b0db8b8a5ca2d70" translate="yes" xml:space="preserve">
          <source>Name of schema containing view</source>
          <target state="translated">뷰를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="fd465cc8a117f3266eab848066483930a22454ae" translate="yes" xml:space="preserve">
          <source>Name of sequence</source>
          <target state="translated">시퀀스 이름</target>
        </trans-unit>
        <trans-unit id="f8e19bb0d7e02e23ea651a2fbd412be10bd907ea" translate="yes" xml:space="preserve">
          <source>Name of sequence's owner</source>
          <target state="translated">시퀀스 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="2c617ffcb7fc75270eec292d65c4160eff374b06" translate="yes" xml:space="preserve">
          <source>Name of table</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="f10df6f392a1568c4d43e34377ec16b2f3a7fa44" translate="yes" xml:space="preserve">
          <source>Name of table policy is on</source>
          <target state="translated">테이블 정책 이름이 켜져 있습니다</target>
        </trans-unit>
        <trans-unit id="c0513b8ba01d1af1c795daf01358ee55cf3296c9" translate="yes" xml:space="preserve">
          <source>Name of table the index is for</source>
          <target state="translated">인덱스가있는 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="d795c0056cb1fd8b2838b400cf90a77a5b34f1c7" translate="yes" xml:space="preserve">
          <source>Name of table the rule is for</source>
          <target state="translated">규칙이 적용되는 테이블 이름</target>
        </trans-unit>
        <trans-unit id="6f44460598242d440e308c5206bbdd4ee6c15df5" translate="yes" xml:space="preserve">
          <source>Name of table's owner</source>
          <target state="translated">테이블 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="cc73fa216f99d868d036ec5fa8be32ea593b2352" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing index (null if default for database)</source>
          <target state="translated">인덱스를 포함하는 테이블 스페이스의 이름 (데이터베이스의 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="13a740701fe416ff32d444b4b9dea241f97f8406" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing materialized view (null if default for database)</source>
          <target state="translated">구체화 된 뷰를 포함하는 테이블 스페이스의 이름 (데이터베이스에 대한 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="e235059f85c95c9cf0964b16c38689bf7ab5f960" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing table (null if default for database)</source>
          <target state="translated">테이블을 포함하는 테이블 스페이스의 이름 (데이터베이스의 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="b950b20317e5d48a4d7180b3b67b23925387d954" translate="yes" xml:space="preserve">
          <source>Name of the WAL file of the last failed archival operation</source>
          <target state="translated">마지막으로 실패한 보관 작업의 WAL 파일 이름</target>
        </trans-unit>
        <trans-unit id="50c7ff72173e6a33ac0f4b45d6945424b157e3f8" translate="yes" xml:space="preserve">
          <source>Name of the access method</source>
          <target state="translated">액세스 방법의 이름</target>
        </trans-unit>
        <trans-unit id="42336fd50699db80c8e30a44b238f551cdfe5e05" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this WAL sender</source>
          <target state="translated">이 WAL 발신자에 연결된 응용 프로그램 이름</target>
        </trans-unit>
        <trans-unit id="73eb48e900d4da8e91ccec691048b06a84e20927" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this backend</source>
          <target state="translated">이 백엔드에 연결된 애플리케이션의 이름</target>
        </trans-unit>
        <trans-unit id="e5622c8d744e74d58e5852a23ea1813374720ca0" translate="yes" xml:space="preserve">
          <source>Name of the column described by this row</source>
          <target state="translated">이 행에서 설명하는 열의 이름</target>
        </trans-unit>
        <trans-unit id="05582534113d6fd58f1c91cf719019de03349552" translate="yes" xml:space="preserve">
          <source>Name of the database in which the transaction was executed</source>
          <target state="translated">트랜잭션이 실행 된 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="3c046694c5a00d97ff6a1379659314bd6a78ef25" translate="yes" xml:space="preserve">
          <source>Name of the database this backend is connected to</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="21b466dc28882ad5e606c7e29b3635f8046375c5" translate="yes" xml:space="preserve">
          <source>Name of the database to which this backend is connected.</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a4b1ce5ff884a2efdb43d43a59c57f0b4fa4d401" translate="yes" xml:space="preserve">
          <source>Name of the event source for pg_ctl to use for logging to the event log when running as a Windows service. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. Note that this only controls messages sent from pg_ctl itself; once started, the server will use the event source specified by its &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; parameter. Should the server fail very early in startup, before that parameter has been set, it might also log using the default event source name &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Windows 서비스로 실행할 때 이벤트 로그에 로깅하는 데 사용할 pg_ctl의 이벤트 소스 이름. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다. 이것은 pg_ctl 자체에서 전송 된 메시지 만 제어합니다. 일단 시작되면, 서버는 &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; 매개 변수로 지정된 이벤트 소스를 사용합니다 . 서버가 시작 초기에 실패하면 해당 매개 변수를 설정하기 전에 기본 이벤트 소스 이름 &lt;code&gt;PostgreSQL&lt;/code&gt; 을 사용하여 로그 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db2a8ab1c7a6e8e7352acea353746079da1e0da5" translate="yes" xml:space="preserve">
          <source>Name of the extension</source>
          <target state="translated">확장명</target>
        </trans-unit>
        <trans-unit id="b32842559bebdaa75c2073237260c49768556ba4" translate="yes" xml:space="preserve">
          <source>Name of the field to order siblings by (optional)</source>
          <target state="translated">형제를 주문할 필드 이름 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="d305530c62c0c372c9b705ff8915012e6f1258b2" translate="yes" xml:space="preserve">
          <source>Name of the foreign server</source>
          <target state="translated">외부 서버의 이름</target>
        </trans-unit>
        <trans-unit id="59348747feca44834dd28cf94d333b16c8cfbbf0" translate="yes" xml:space="preserve">
          <source>Name of the foreign-data wrapper</source>
          <target state="translated">외부 데이터 랩퍼의 이름</target>
        </trans-unit>
        <trans-unit id="9e20c57335eda37ac38552a55cb17fe874d8fb6b" translate="yes" xml:space="preserve">
          <source>Name of the function</source>
          <target state="translated">기능의 이름</target>
        </trans-unit>
        <trans-unit id="eee39eba3634db32e7cb3a66942216268c13c704" translate="yes" xml:space="preserve">
          <source>Name of the group</source>
          <target state="translated">그룹 이름</target>
        </trans-unit>
        <trans-unit id="e6e050c906fd9fbc0c7b4d3a235e25d068290256" translate="yes" xml:space="preserve">
          <source>Name of the key field</source>
          <target state="translated">키 필드의 이름</target>
        </trans-unit>
        <trans-unit id="b217fce5b600ff5e59a7bde206ff84c6743ebd06" translate="yes" xml:space="preserve">
          <source>Name of the language</source>
          <target state="translated">언어의 이름</target>
        </trans-unit>
        <trans-unit id="999d13acc30868afb96a2061f85f8cfbf835af9a" translate="yes" xml:space="preserve">
          <source>Name of the language this template is for</source>
          <target state="translated">이 템플릿의 언어 이름</target>
        </trans-unit>
        <trans-unit id="c0904d4653e24f5cf40ca0e66167033212dff01e" translate="yes" xml:space="preserve">
          <source>Name of the last WAL file successfully archived</source>
          <target state="translated">성공적으로 아카이브 된 마지막 WAL 파일의 이름</target>
        </trans-unit>
        <trans-unit id="632030382b37c4353da7f8cfd3fb10f03fb4878e" translate="yes" xml:space="preserve">
          <source>Name of the local user to be mapped</source>
          <target state="translated">매핑 할 로컬 사용자의 이름</target>
        </trans-unit>
        <trans-unit id="3283788f7750678653d33179d0a9b570a3fb07a0" translate="yes" xml:space="preserve">
          <source>Name of the lock mode held or desired by this process (see &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Section 13.3.1&lt;/a&gt; and &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;)</source>
          <target state="translated">이 프로세스에서 보유하거나 원하는 잠금 모드 이름 ( &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;섹션 13.3.1&lt;/a&gt; 및 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;섹션 13.2.3 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bca4b201210cb86555d12a73e7fa1d0df2b4ce1d" translate="yes" xml:space="preserve">
          <source>Name of the namespace</source>
          <target state="translated">네임 스페이스의 이름</target>
        </trans-unit>
        <trans-unit id="116ede6679101b358b013bfe3778515f6a6eb59a" translate="yes" xml:space="preserve">
          <source>Name of the notification channel to be signaled (any identifier).</source>
          <target state="translated">신호를 보낼 알림 채널의 이름 (모든 식별자).</target>
        </trans-unit>
        <trans-unit id="b1846b8dfbb275c5d01dbe581ad89ecd8bd17f99" translate="yes" xml:space="preserve">
          <source>Name of the on-disk file of this relation; zero means this is a &amp;ldquo;mapped&amp;rdquo; relation whose disk file name is determined by low-level state</source>
          <target state="translated">이 관계의 디스크 파일 이름. 0은 디스크 파일 이름이 하위 레벨 상태에 의해 결정되는 &quot;매핑 된&quot;관계임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ffd1b3d5baf3902d7d64e922601a9c11dc846fd8" translate="yes" xml:space="preserve">
          <source>Name of the operator</source>
          <target state="translated">운영자 이름</target>
        </trans-unit>
        <trans-unit id="f362cae832a0a92cf6859f4e3035227030a3fa7e" translate="yes" xml:space="preserve">
          <source>Name of the parent-key field</source>
          <target state="translated">부모 키 필드의 이름</target>
        </trans-unit>
        <trans-unit id="914386f36015301aa42cdc85d2971f37bbd3f6e1" translate="yes" xml:space="preserve">
          <source>Name of the publication</source>
          <target state="translated">출판물의 이름</target>
        </trans-unit>
        <trans-unit id="95141217167b4e44530e9c633ef9691ad9e4c7d5" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database. Also used for local replication origin name.</source>
          <target state="translated">업스트림 데이터베이스의 복제 슬롯 이름 로컬 복제 오리진 이름에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48b6dcd7b3f9b0cceabe3c942a0ff0d053cf3051" translate="yes" xml:space="preserve">
          <source>Name of the replication slot to use. The default behavior is to use the name of the subscription for the slot name.</source>
          <target state="translated">사용할 복제 슬롯의 이름입니다. 기본 동작은 슬롯 이름에 구독 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c22c3cdbc7df0d29a30ef0e5d20c6d53a22aba3" translate="yes" xml:space="preserve">
          <source>Name of the schema that the extension must be installed into, or &lt;code&gt;NULL&lt;/code&gt; if partially or fully relocatable</source>
          <target state="translated">확장을 설치해야하는 스키마 이름 또는 부분적으로 또는 완전히 재배치 가능한 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46b2c8652132c7dc1c02610fe232f22c32a70e49" translate="yes" xml:space="preserve">
          <source>Name of the schema that this table is in</source>
          <target state="translated">이 테이블이있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="aeed8d4431144cabd5a1127005bce646d16cab11" translate="yes" xml:space="preserve">
          <source>Name of the schema this function is in</source>
          <target state="translated">이 함수가 속한 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="b11dd1fd926881e2c689b2ce026036d1c6bf66aa" translate="yes" xml:space="preserve">
          <source>Name of the schema this index is in</source>
          <target state="translated">이 인덱스가있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="55e1e35ee330306af1edafba8c0ccceb0641d202" translate="yes" xml:space="preserve">
          <source>Name of the schema this sequence is in</source>
          <target state="translated">이 순서가있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="d75b4d0b583232f5341524b6ac4e00946212dc64" translate="yes" xml:space="preserve">
          <source>Name of the source relation</source>
          <target state="translated">소스 관계의 이름</target>
        </trans-unit>
        <trans-unit id="02fe646b94a9a3942519f9c9b3db9e92f9c9c3fd" translate="yes" xml:space="preserve">
          <source>Name of the statistics object</source>
          <target state="translated">통계 개체의 이름</target>
        </trans-unit>
        <trans-unit id="33574f9c61c2e627eb0d3d0f3da70a170678a9ff" translate="yes" xml:space="preserve">
          <source>Name of the subscription</source>
          <target state="translated">구독 이름</target>
        </trans-unit>
        <trans-unit id="90ae080c0a5fc808f5e0a7e8b8cae579504b16d5" translate="yes" xml:space="preserve">
          <source>Name of the system service to register. This name will be used as both the service name and the display name. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">등록 할 시스템 서비스의 이름입니다. 이 이름은 서비스 이름과 표시 이름으로 사용됩니다. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5e271781547e2a1e2376a48974f2d9fab48cde2" translate="yes" xml:space="preserve">
          <source>Name of the table for this index</source>
          <target state="translated">이 인덱스의 테이블 이름</target>
        </trans-unit>
        <trans-unit id="0200e1f7b3df494bd305d84c497873916f941937" translate="yes" xml:space="preserve">
          <source>Name of the table, index, view, etc.</source>
          <target state="translated">테이블 이름, 인덱스, 뷰 등</target>
        </trans-unit>
        <trans-unit id="a1f59b4d65687dc8fe0a85f1b74351b10bfba7a6" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this WAL sender process</source>
          <target state="translated">이 WAL 발신자 프로세스에 로그인 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="3fe80a85bf2161f51d9c08098d7bfcdedce6c9ee" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this backend</source>
          <target state="translated">이 백엔드에 로그인 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="04f7b7b315d382679587d80fba309d2bb70b1345" translate="yes" xml:space="preserve">
          <source>Name of the user that executed the transaction</source>
          <target state="translated">트랜잭션을 실행 한 사용자의 이름</target>
        </trans-unit>
        <trans-unit id="c24f99aa0c8caf23a96b75cece5098629fd6a94e" translate="yes" xml:space="preserve">
          <source>Name of this database</source>
          <target state="translated">이 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="73d6411e8bd4b74b577e7365540cb543464ed926" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects.</source>
          <target state="translated">이 데이터베이스의 이름이거나 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09edc4fe28078a94e956caa9447364b4707b6491" translate="yes" xml:space="preserve">
          <source>Name of this function</source>
          <target state="translated">이 기능의 이름</target>
        </trans-unit>
        <trans-unit id="a2e0e5204a994c27fb6b9e0e825c613dd1c4755e" translate="yes" xml:space="preserve">
          <source>Name of this index</source>
          <target state="translated">이 인덱스의 이름</target>
        </trans-unit>
        <trans-unit id="52256e99af10a92f8d2567b55a83d56fe82e813a" translate="yes" xml:space="preserve">
          <source>Name of this operator class</source>
          <target state="translated">이 연산자 클래스의 이름</target>
        </trans-unit>
        <trans-unit id="8660634803fb7c50b11c80dde370467806dff8e0" translate="yes" xml:space="preserve">
          <source>Name of this operator family</source>
          <target state="translated">이 운영자 제품군의 이름</target>
        </trans-unit>
        <trans-unit id="67e86bea4f13cfb5fdec580a24af26d2de2fdc44" translate="yes" xml:space="preserve">
          <source>Name of this sequence</source>
          <target state="translated">이 순서의 이름</target>
        </trans-unit>
        <trans-unit id="b490c1221b4b64551bfddc6b8b9c77d0ea3870a9" translate="yes" xml:space="preserve">
          <source>Name of this table</source>
          <target state="translated">이 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="79333580b15aa0175b731014d71be95e862ff44a" translate="yes" xml:space="preserve">
          <source>Name of validator function, or null if none</source>
          <target state="translated">유효성 검사기 함수의 이름 또는없는 경우 null</target>
        </trans-unit>
        <trans-unit id="d340979d7f1712dd54645083825a2794537380b7" translate="yes" xml:space="preserve">
          <source>Name of view</source>
          <target state="translated">보기의 이름</target>
        </trans-unit>
        <trans-unit id="ca9987204d1e0d3bf0d8020ca5eccf2de116a77a" translate="yes" xml:space="preserve">
          <source>Name of view's owner</source>
          <target state="translated">뷰 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="715cd77a48eca5f7bbf90153374438716221cbe4" translate="yes" xml:space="preserve">
          <source>Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).</source>
          <target state="translated">집계 함수를 호출 할 때는 현재 이름이 지정된 혼합 호출 표기법을 사용할 수 없습니다 (단, 집계 함수가 창 함수로 사용될 때는 작동합니다).</target>
        </trans-unit>
        <trans-unit id="febb13b6b6bedee695a2cdffc8584795987df071" translate="yes" xml:space="preserve">
          <source>Named run-time parameters can be set in either of these styles:</source>
          <target state="translated">명명 된 런타임 매개 변수는 다음 스타일 중 하나로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b335beb0e29ec02f76a030301ce30aec55d10a00" translate="yes" xml:space="preserve">
          <source>Names can be assigned to table constraints in the same way as column constraints:</source>
          <target state="translated">열 제약 조건과 같은 방식으로 테이블 제약 조건에 이름을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e76064cba28bce291e20a00492ac8908ed2815" translate="yes" xml:space="preserve">
          <source>Names of prerequisite extensions, or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">전제 조건 확장명 또는 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="879c37a97f04ee34ad69a53c4aa464879102ff50" translate="yes" xml:space="preserve">
          <source>Names of the columns the extended statistics is defined on</source>
          <target state="translated">확장 통계가 정의 된 열의 이름</target>
        </trans-unit>
        <trans-unit id="774a71278e16cec9ccf959b5bab94713611e399e" translate="yes" xml:space="preserve">
          <source>Names of the publications on the publisher to subscribe to.</source>
          <target state="translated">구독 할 발행인의 발행물 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ef2014703004a1217b3fec5210db4117b70e51de" translate="yes" xml:space="preserve">
          <source>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</source>
          <target state="translated">연결할 LDAP 서버의 이름 또는 IP 주소입니다. 공백으로 구분하여 여러 서버를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f95be766c8568501a000e46e6894d04ef9f8877" translate="yes" xml:space="preserve">
          <source>Namespace Available to &lt;code&gt;GROUP BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;ORDER BY&lt;/code&gt; 에 사용 가능한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="47230dc537dc21987e746d4c719b4cc41ae69b6a" translate="yes" xml:space="preserve">
          <source>Namespace of this operator class</source>
          <target state="translated">이 연산자 클래스의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="a230663970531d46658f671326f61bad6755f192" translate="yes" xml:space="preserve">
          <source>Namespace of this operator family</source>
          <target state="translated">이 연산자 제품군의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="a1c428db5a690b5f5a2a8bbbdfae45bd49175ad0" translate="yes" xml:space="preserve">
          <source>National Language Support</source>
          <target state="translated">자국어 지원</target>
        </trans-unit>
        <trans-unit id="725efb9e43acf1bf580c09d2cb1b0cf911451468" translate="yes" xml:space="preserve">
          <source>National Standard</source>
          <target state="translated">국가 표준</target>
        </trans-unit>
        <trans-unit id="333e55744c1836d8e2f747a46f8a58bd387549f7" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the SQL/JSON number</source>
          <target state="translated">SQL / JSON 수보다 크거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="bee672459bc21a36f5d885e59227b9978e9d1866" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the SQL/JSON number</source>
          <target state="translated">SQL / JSON 수 이하의 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="8e224c76bc25e4149e084462adee5b7564caac26" translate="yes" xml:space="preserve">
          <source>Needless to say, processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</source>
          <target state="translated">말할 것도없이, PostgreSQL로 XML 데이터를 처리하는 것은 XML 데이터 인코딩, 클라이언트 인코딩 및 서버 인코딩이 동일한 경우 오류가 적고 효율적입니다. XML 데이터는 내부적으로 UTF-8로 처리되므로 서버 인코딩도 UTF-8 인 경우 계산이 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="27cadf6ca95971ac3dd5c11e621924026c16209f" translate="yes" xml:space="preserve">
          <source>Negator of this operator, if any</source>
          <target state="translated">이 연산자의 부정 자 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="cdedd7a3e12a28ecdae254105845f04dc8b7e221" translate="yes" xml:space="preserve">
          <source>Neither sequential scans nor nested-loop joins can be disabled completely; the &lt;code&gt;-fs&lt;/code&gt; and &lt;code&gt;-fn&lt;/code&gt; options simply discourage the optimizer from using those plan types if it has any other alternative.</source>
          <target state="translated">순차적 스캔이나 중첩 루프 조인을 완전히 비활성화 할 수는 없습니다. &lt;code&gt;-fs&lt;/code&gt; 과 &lt;code&gt;-fn&lt;/code&gt; 옵션은 단순히 다른 대안이있는 경우 그 계획 유형을 사용하여 최적화 알고리즘을 억제.</target>
        </trans-unit>
        <trans-unit id="dc249089e46e70234a72d288cf1c8de145f74bd2" translate="yes" xml:space="preserve">
          <source>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files stored under &lt;code&gt;.../share/timezone/&lt;/code&gt; and &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;).</source>
          <target state="translated">시간대 이름이나 약어는 서버에 연결되지 않습니다. 설치 디렉토리의 &lt;code&gt;.../share/timezone/&lt;/code&gt; 및 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 아래에 저장된 구성 파일에서 얻습니다 ( &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="8d546e29b4f4fdcb009106a5c128188e2431946d" translate="yes" xml:space="preserve">
          <source>NetBSD versions before 5.0 work like old OpenBSD (see below), except that kernel parameters should be set with the keyword &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt;.</source>
          <target state="translated">5.0 이전의 NetBSD 버전은 이전 OpenBSD처럼 작동하지만 (아래 참조) 커널 매개 변수는 키워드 &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt; 사용하여 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4970c28f364d041c28f5d5ff2bc88daf1a13ad01" translate="yes" xml:space="preserve">
          <source>Network Address Types</source>
          <target state="translated">네트워크 주소 유형</target>
        </trans-unit>
        <trans-unit id="1aab162fb1d4be431f43c575684b7d8c545c8302" translate="yes" xml:space="preserve">
          <source>Network Address Types: cidr</source>
          <target state="translated">네트워크 주소 유형 : cidr</target>
        </trans-unit>
        <trans-unit id="a0a4631210875f94aba2f16fc813f4614e393764" translate="yes" xml:space="preserve">
          <source>Network Address Types: inet</source>
          <target state="translated">네트워크 주소 유형 : inet</target>
        </trans-unit>
        <trans-unit id="341da3e8cf1498f3f62648168d4190e67f278782" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr</source>
          <target state="translated">네트워크 주소 유형 : macaddr</target>
        </trans-unit>
        <trans-unit id="81bbd3c87492587fd7ddfed55118e840abffce9f" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr8</source>
          <target state="translated">네트워크 주소 유형 : macaddr8</target>
        </trans-unit>
        <trans-unit id="c5f17a43f889ac0d89795d00fba1671fe47f62f0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;</source>
          <target state="translated">네트워크 주소: &amp;amp;</target>
        </trans-unit>
        <trans-unit id="3182c01748d8a83efe78a3f4ab6c4e990eacea0c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;&amp;amp;</source>
          <target state="translated">네트워크 주소: &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c32091a6107e7e44a68fb436fb33982336ccc452" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;</source>
          <target state="translated">네트워크 주소 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86a00c20e3381c9260f079dcb6e41c4262f1ea3a" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;</source>
          <target state="translated">네트워크 주소 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3736d0bb3a030e00d7114ef9030a0916af6881f" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;=</source>
          <target state="translated">네트워크 주소 : &amp;gt;&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="b6a612c0f5ca1e234f11a6f50c9a9f41342ace58" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;=</source>
          <target state="translated">네트워크 주소 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="0cab881598e19094a73fe2cb680ef2e7600ff52c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2a64bdcd407fdda5883dcb3954eb4988b1bf440" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;gt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e00740580248e58ab92c3eb2672f19b765c748b0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ff901142c2068fe8cf464afe26c9042106af748" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;=</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;lt; =</target>
        </trans-unit>
        <trans-unit id="68fb0bbbf4bee491f6e6bbc78cee804b2462e684" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;=</source>
          <target state="translated">네트워크 주소 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="6b9e98c353b63977350c4597ab783ed68802ee56" translate="yes" xml:space="preserve">
          <source>Network Address: +</source>
          <target state="translated">네트워크 주소 : +</target>
        </trans-unit>
        <trans-unit id="39dd97c5cafd7589b71c3638f6bb1482a7b84d8f" translate="yes" xml:space="preserve">
          <source>Network Address: -</source>
          <target state="translated">네트워크 주소: -</target>
        </trans-unit>
        <trans-unit id="b43debcb1e648bae4f59d9ad9d57421aa61da314" translate="yes" xml:space="preserve">
          <source>Network Address: =</source>
          <target state="translated">네트워크 주소 : =</target>
        </trans-unit>
        <trans-unit id="f6da4644273b4e1c84158d7bdc34944932533ec4" translate="yes" xml:space="preserve">
          <source>Network Address: abbrev</source>
          <target state="translated">네트워크 주소 : abbrev</target>
        </trans-unit>
        <trans-unit id="c0aa9d1b8f2a11dc8e2d5492bfd563df5e51a186" translate="yes" xml:space="preserve">
          <source>Network Address: broadcast</source>
          <target state="translated">네트워크 주소 : 방송</target>
        </trans-unit>
        <trans-unit id="22c496032e898e93c86c9e0b2d1794774c6cc3b0" translate="yes" xml:space="preserve">
          <source>Network Address: family</source>
          <target state="translated">네트워크 주소 : family</target>
        </trans-unit>
        <trans-unit id="6144652f94deb193ec23e96153e939af827c258d" translate="yes" xml:space="preserve">
          <source>Network Address: host</source>
          <target state="translated">네트워크 주소 : 호스트</target>
        </trans-unit>
        <trans-unit id="60b63d4c005ed64503064242e41d8bfa685a802b" translate="yes" xml:space="preserve">
          <source>Network Address: hostmask</source>
          <target state="translated">네트워크 주소 : hostmask</target>
        </trans-unit>
        <trans-unit id="d7c102cda170efbd5c926c080194943072fd0080" translate="yes" xml:space="preserve">
          <source>Network Address: inet_merge</source>
          <target state="translated">네트워크 주소 : inet_merge</target>
        </trans-unit>
        <trans-unit id="026b427d2abc32061f460f5004b1e92329b176c3" translate="yes" xml:space="preserve">
          <source>Network Address: inet_same_family</source>
          <target state="translated">네트워크 주소 : inet_same_family</target>
        </trans-unit>
        <trans-unit id="78246e2d890ea6d8b5a4e72ded75baf6bfea7473" translate="yes" xml:space="preserve">
          <source>Network Address: macaddr8_set7bit</source>
          <target state="translated">네트워크 주소 : macaddr8_set7bit</target>
        </trans-unit>
        <trans-unit id="1c089819bd8607b5f9a99695372b4e5df1ae11f3" translate="yes" xml:space="preserve">
          <source>Network Address: masklen</source>
          <target state="translated">네트워크 주소 : masklen</target>
        </trans-unit>
        <trans-unit id="e38c25828a5f421b05060a2505734c3b8ed3c4ff" translate="yes" xml:space="preserve">
          <source>Network Address: netmask</source>
          <target state="translated">네트워크 주소 : 넷 마스크</target>
        </trans-unit>
        <trans-unit id="9e08bb5a4ba97edb3516d3ee46ca743eed995918" translate="yes" xml:space="preserve">
          <source>Network Address: network</source>
          <target state="translated">네트워크 주소 : 네트워크</target>
        </trans-unit>
        <trans-unit id="e7c94e499362212c6e5807040cfed09039e1ec82" translate="yes" xml:space="preserve">
          <source>Network Address: set_masklen</source>
          <target state="translated">네트워크 주소 : set_masklen</target>
        </trans-unit>
        <trans-unit id="0ec1baf847c109f5d8cc27de72a96ec587a99682" translate="yes" xml:space="preserve">
          <source>Network Address: text</source>
          <target state="translated">네트워크 주소 : text</target>
        </trans-unit>
        <trans-unit id="221efaf6a0e58b3e7e632e503daaffa7a1a069d7" translate="yes" xml:space="preserve">
          <source>Network Address: trunc</source>
          <target state="translated">네트워크 주소 : trunc</target>
        </trans-unit>
        <trans-unit id="ab7cd2917681a96bc47067425beee2467a73704d" translate="yes" xml:space="preserve">
          <source>Network Address: |</source>
          <target state="translated">네트워크 주소 : |</target>
        </trans-unit>
        <trans-unit id="83814dd86a48a4c95e9a2274b66946fe0603b1c9" translate="yes" xml:space="preserve">
          <source>Network Address: ~</source>
          <target state="translated">네트워크 주소 : ~</target>
        </trans-unit>
        <trans-unit id="0a2ec6319838e0ec218c4906d73f925465627945" translate="yes" xml:space="preserve">
          <source>Network address types</source>
          <target state="translated">네트워크 주소 유형</target>
        </trans-unit>
        <trans-unit id="424a86543035666947635d11018cbc54c86cb289" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">비밀번호 프롬프트를 발행하지 마십시오. 서버에 비밀번호 인증이 필요하고 &lt;code&gt;.pgpass&lt;/code&gt; 파일 과 같은 다른 방법으로 비밀번호를 사용할 수없는 경우 연결 시도가 실패합니다. 이 옵션은 비밀번호를 입력 할 사용자가없는 배치 작업 및 스크립트에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d783af92d40765554d538ccb5cb29b09817e84f6" translate="yes" xml:space="preserve">
          <source>New OIDs cannot be assigned, though some UUID generators may still work as long as they do not rely on writing new status to the database.</source>
          <target state="translated">새 UID를 할당 할 수는 없지만 일부 UUID 생성기는 데이터베이스에 새 상태를 작성하지 않는 한 여전히 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1599ff1bdbcb64919583d13e639c6bfaf051dfca" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">새로운 집계 함수는 &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; 명령으로 등록됩니다 . 집계 함수 작성 및 전이 함수의 의미 등에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;37.12 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e31c4f5893b955e11ebf06d3912e5da97f70565f" translate="yes" xml:space="preserve">
          <source>New array values can also be constructed using the concatenation operator, &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">연결 연산자 &lt;code&gt;||&lt;/code&gt; 를 사용하여 새 배열 값을 구성 할 수도 있습니다. :</target>
        </trans-unit>
        <trans-unit id="98e5f0d308c976c18e3e4b7efffa4995977e2612" translate="yes" xml:space="preserve">
          <source>New domain constraint for the domain.</source>
          <target state="translated">도메인에 대한 새로운 도메인 제약.</target>
        </trans-unit>
        <trans-unit id="a12c3795c3d4f4819f76dadf3e557565c057892c" translate="yes" xml:space="preserve">
          <source>New libc collations can be created like this:</source>
          <target state="translated">다음과 같이 새 libc 데이터 정렬을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650ded8d5d402f503baa0bc831171b9d8bc4272d" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">새로운 메이저 버전은 또한 일반적으로 사용자가 볼 수있는 비 호환성을 도입하므로 애플리케이션 프로그래밍 변경이 필요할 수 있습니다. 모든 사용자가 볼 수있는 변경 사항은 릴리스 정보 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;부록 E&lt;/a&gt; )에 나열되어 있습니다 . &quot;이주&quot;섹션에 특히주의하십시오. 여러 주요 버전에서 업그레이드하는 경우 각 중간 버전에 대한 릴리스 정보를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="a56ea799e1817e77cfb14f705f9837d87da3531d" translate="yes" xml:space="preserve">
          <source>New name for an existing column.</source>
          <target state="translated">기존 열의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="b258c013a0b2baff94eb0ca18fab582791cfc317" translate="yes" xml:space="preserve">
          <source>New name for the table.</source>
          <target state="translated">테이블의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="e2584f9de9d6b68e373738ded405b0367bf25369" translate="yes" xml:space="preserve">
          <source>New probes can be defined within the code wherever the developer desires, though this will require a recompilation. Below are the steps for inserting new probes:</source>
          <target state="translated">개발자가 원하는 곳에서는 코드 내에서 새로운 프로브를 정의 할 수 있지만 재 컴파일이 필요합니다. 다음은 새 프로브를 삽입하는 단계입니다.</target>
        </trans-unit>
        <trans-unit id="9bb5261862459d4fc2f236436c680944b53b22bf" translate="yes" xml:space="preserve">
          <source>New row</source>
          <target state="translated">새로운 행</target>
        </trans-unit>
        <trans-unit id="b1955e711ad4344c38fc8ef166f89eecc1ca6dce" translate="yes" xml:space="preserve">
          <source>New row &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">새 행 &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45bbeac915cddbd627fa355d4df5b9dbbc9336c8" translate="yes" xml:space="preserve">
          <source>New rows are checked against the conditions of the view and all underlying base views. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is specified, and neither &lt;code&gt;LOCAL&lt;/code&gt; nor &lt;code&gt;CASCADED&lt;/code&gt; is specified, then &lt;code&gt;CASCADED&lt;/code&gt; is assumed.</source>
          <target state="translated">새 행은 뷰의 조건과 모든 기본 뷰에 대해 점검됩니다. 는 IF &lt;code&gt;CHECK OPTION&lt;/code&gt; 지정하고,도 &lt;code&gt;LOCAL&lt;/code&gt; 도 &lt;code&gt;CASCADED&lt;/code&gt; 가 지정하면 &lt;code&gt;CASCADED&lt;/code&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="08a4db17fa684c55666b397d42c621a7aaca8bcb" translate="yes" xml:space="preserve">
          <source>New rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify the &lt;code&gt;CHECK OPTION&lt;/code&gt;).</source>
          <target state="translated">새 행은보기 자체에 직접 정의 된 조건에 대해서만 점검됩니다. 기본 기준 뷰에 정의 된 모든 조건은 점검되지 않습니다 ( &lt;code&gt;CHECK OPTION&lt;/code&gt; 도 지정하지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="0fffd55cc966a5c918570729a73087e9799e7b21" translate="yes" xml:space="preserve">
          <source>New server version.</source>
          <target state="translated">새로운 서버 버전.</target>
        </trans-unit>
        <trans-unit id="326bf78cdc5261237c497696e2f88d3bf937ac51" translate="yes" xml:space="preserve">
          <source>New table constraint for the foreign table.</source>
          <target state="translated">외부 테이블에 대한 새 테이블 제한 조건.</target>
        </trans-unit>
        <trans-unit id="c7fc18feb54e6ecc777a74b8dce9c763304724d3" translate="yes" xml:space="preserve">
          <source>New table constraint for the table.</source>
          <target state="translated">테이블에 대한 새로운 테이블 제약.</target>
        </trans-unit>
        <trans-unit id="0ef8f5b2618f8741358d2dc6f311e26c77d17c09" translate="yes" xml:space="preserve">
          <source>New value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no &lt;code&gt;SET&lt;/code&gt; had been executed in the current session).</source>
          <target state="translated">매개 변수의 새로운 값. 값은 특정 매개 변수에 따라 문자열 상수, 식별자, 숫자 또는 쉼표로 구분 된 목록으로 지정할 수 있습니다. &lt;code&gt;DEFAULT&lt;/code&gt; 를 작성하여 매개 변수를 기본값 (즉 , 현재 세션에서 &lt;code&gt;SET&lt;/code&gt; 이 실행 되지 않은 경우의 값)으로 재설정하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74ad18207dee0729707d6021134389a09abbbcf4" translate="yes" xml:space="preserve">
          <source>New value of the parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify removing the parameter and its value from &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">매개 변수의 새로운 값. 값은 특정 매개 변수에 따라 문자열 상수, 식별자, 숫자 또는 쉼표로 구분 된 목록으로 지정할 수 있습니다. &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 에서 매개 변수 및 해당 값을 제거하도록 지정하기 위해 &lt;code&gt;DEFAULT&lt;/code&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f73bcda4d00edad798e144ba44c98c20a80aa1b" translate="yes" xml:space="preserve">
          <source>Newer operating systems may check for the known TSC problems and switch to a slower, more stable clock source when they are seen. If your system supports TSC time but doesn't default to that, it may be disabled for a good reason. And some operating systems may not detect all the possible problems correctly, or will allow using TSC even in situations where it's known to be inaccurate.</source>
          <target state="translated">최신 운영 체제는 알려진 TSC 문제를 확인하고보다 느리고 안정적인 클럭 소스로 전환 할 수 있습니다. 시스템이 TSC 시간을 지원하지만 기본값으로 설정하지 않은 경우에는 적절한 이유로 비활성화 될 수 있습니다. 일부 운영 체제는 가능한 모든 문제를 올바르게 감지하지 못하거나 부정확 한 것으로 알려진 상황에서도 TSC를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91613c0496c344d2d60b757f74e45fc5cc402ce3" translate="yes" xml:space="preserve">
          <source>Newline (ASCII 10)</source>
          <target state="translated">개행 (ASCII 10)</target>
        </trans-unit>
        <trans-unit id="abcfe34ad9620d6f4bc03407b5ef1c1c15fc3d23" translate="yes" xml:space="preserve">
          <source>Newlines are inserted between fields as needed to limit line length to 80 characters, if possible. A newline is also inserted between the metadata fields and the regular fields.</source>
          <target state="translated">가능한 경우 줄 길이를 80 자로 제한하기 위해 필드 사이에 줄 바꾸기가 삽입됩니다. 메타 데이터 필드와 일반 필드 사이에도 줄 바꿈이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="668d132684646785e22fe1441b80ce3d2edabbcd" translate="yes" xml:space="preserve">
          <source>Next field is Julian Date</source>
          <target state="translated">다음 필드는 Julian Date입니다</target>
        </trans-unit>
        <trans-unit id="b894f41f03f11b1ed4f8f278b45d31b30d6d7e9d" translate="yes" xml:space="preserve">
          <source>Next field is time</source>
          <target state="translated">다음 필드는 시간입니다</target>
        </trans-unit>
        <trans-unit id="8bbd06fda45074a003115cb92bcdeae70e3776f1" translate="yes" xml:space="preserve">
          <source>Next let's consider an example with an equality condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">다음으로 &lt;code&gt;WHERE&lt;/code&gt; 절 에 동등 조건이있는 예제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5ed06150c503b0381101da4c9e29738d8aede6e0" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">다음으로&amp;ldquo;&amp;lt;1000&amp;rdquo;이 차지하는 히스토그램의 분수가 계산됩니다. 이것이 선택성입니다. 히스토그램은 범위를 동일한 주파수 버킷으로 나누므로 값이있는 버킷을 찾아서 그 &lt;em&gt;일부&lt;/em&gt; 와 이전의 &lt;em&gt;모든&lt;/em&gt; 버킷을 계산 하기 만하면됩니다. 값 1000은 분명히 두 번째 버킷 (993-1997)에 있습니다. 각 버킷 내에서 값의 선형 분포를 가정하면 선택성을 다음과 같이 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e15fe544e0817c8abcd5bf63590f065c8fda5e8" translate="yes" xml:space="preserve">
          <source>Next we register the Ispell dictionary &lt;code&gt;english_ispell&lt;/code&gt;, which has its own configuration files:</source>
          <target state="translated">다음 으로 자체 구성 파일이 있는 Ispell 사전 &lt;code&gt;english_ispell&lt;/code&gt; 을 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="bdb6f7d3081e6797875cb41a13e6c45a3f761bbf" translate="yes" xml:space="preserve">
          <source>Next, create a trigram index on the word column:</source>
          <target state="translated">다음으로 단어 열에 트라이 그램 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d9e892095e44895492c517f24015243e155c5a35" translate="yes" xml:space="preserve">
          <source>Next, there might be a cache in the disk drive controller; this is particularly common on RAID controller cards. Some of these caches are &lt;em&gt;write-through&lt;/em&gt;, meaning writes are sent to the drive as soon as they arrive. Others are &lt;em&gt;write-back&lt;/em&gt;, meaning data is sent to the drive at some later time. Such caches can be a reliability hazard because the memory in the disk controller cache is volatile, and will lose its contents in a power failure. Better controller cards have &lt;em&gt;battery-backup units&lt;/em&gt; (BBUs), meaning the card has a battery that maintains power to the cache in case of system power loss. After power is restored the data will be written to the disk drives.</source>
          <target state="translated">다음으로 디스크 드라이브 컨트롤러에 캐시가있을 수 있습니다. 이것은 RAID 컨트롤러 카드에서 특히 일반적입니다. 이러한 캐시 중 일부는 &lt;em&gt;연속 기입&lt;/em&gt; 이므로 쓰기가 도착하자마자 드라이브로 전송됩니다. 다른 사람은 &lt;em&gt;다시 쓰기&lt;/em&gt; 일부 나중에 드라이브로 전송되는 데이터를 의미한다. 이러한 캐시는 디스크 컨트롤러 캐시의 메모리가 휘발성이므로 정전시 내용이 손실되므로 안정성이 위험 할 수 있습니다. 더 나은 컨트롤러 카드에는 &lt;em&gt;배터리 백업 장치&lt;/em&gt; (BBU)가 있습니다. 즉, 시스템 전원 손실시 캐시에 전원을 유지하는 배터리가 카드에 있습니다. 전원이 복구되면 데이터가 디스크 드라이브에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="ab63ab43b9cd6b9423e3548d5b6495e55251533e" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">총 백그라운드 작업자 수가 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes를&lt;/a&gt; 초과 할 수 없다는 제한으로 인해 백그라운드 작업자를 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1db509e223519bbbe9c20165e8b19fc16220b41f" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers launched for purposes of parallel query cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;.</source>
          <target state="translated">병렬 쿼리를 위해 시작된 총 백그라운드 워커 수가 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers를&lt;/a&gt; 초과 할 수 없다는 제한 때문에 백그라운드 워커를 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="737fbf99fcaacc1c750aa9911a89ba763b4fb6c2" translate="yes" xml:space="preserve">
          <source>No conflict resolution necessary</source>
          <target state="translated">충돌 해결이 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c4ae42341e7948bd6be9068db7f6b708eab0516f" translate="yes" xml:space="preserve">
          <source>No direct modifications of buffers are allowed! All modifications must be done in copies acquired from &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt;. In other words, code that makes generic WAL records should never call &lt;code&gt;BufferGetPage()&lt;/code&gt; for itself. However, it remains the caller's responsibility to pin/unpin and lock/unlock the buffers at appropriate times. Exclusive lock must be held on each target buffer from before &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; until after &lt;code&gt;GenericXLogFinish()&lt;/code&gt;.</source>
          <target state="translated">버퍼를 직접 수정할 수 없습니다! 모든 수정은 &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 에서 얻은 사본에서 수행해야합니다 . 즉, 일반 WAL 레코드를 만드는 코드는 절대로 &lt;code&gt;BufferGetPage()&lt;/code&gt; 를 호출해서는 안됩니다 . 그러나 적절한 시간에 버퍼를 고정 / 고정 해제 및 잠금 / 잠금 해제하는 것은 호출자의 책임입니다. &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 이전부터 &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 이후까지 각 대상 버퍼에서 독점 잠금을 보유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="59fe225d3b68631dd2336d2bf5588427b3b21997" translate="yes" xml:space="preserve">
          <source>No error concerning corruption raised by &lt;code&gt;amcheck&lt;/code&gt; should ever be a false positive. &lt;code&gt;amcheck&lt;/code&gt; raises errors in the event of conditions that, by definition, should never happen, and so careful analysis of &lt;code&gt;amcheck&lt;/code&gt; errors is often required.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 에 의해 야기 된 손상에 관한 오류 는 거짓 긍정이 되어서 는 안됩니다. &lt;code&gt;amcheck&lt;/code&gt; 는 정의상 절대로 발생하지 않아야하는 조건에서 오류를 발생 &lt;code&gt;amcheck&lt;/code&gt; 오류를 신중하게 분석 해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b39fb69a71692aa8fa18d1717c1f94f66adfcdf" translate="yes" xml:space="preserve">
          <source>No master server overhead</source>
          <target state="translated">마스터 서버 오버 헤드 없음</target>
        </trans-unit>
        <trans-unit id="69d7c6fd29e6141d46559276ef0d0824b8ca6117" translate="yes" xml:space="preserve">
          <source>No more than 256 positions per lexeme</source>
          <target state="translated">lexeme 당 256 개 이하의 위치</target>
        </trans-unit>
        <trans-unit id="d6105567c57e07dede5d4075af64116a14eb0b4d" translate="yes" xml:space="preserve">
          <source>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</source>
          <target state="translated">이 구현에서 RE의 길이에는 특별한 제한이 없다. 그러나 이식성이 높은 프로그램은 POSIX 호환 구현이 그러한 RE를 수락하는 것을 거부 할 수 있으므로 256 바이트보다 긴 RE를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b403c7e51ec107180064180093a27a248cb9fcae" translate="yes" xml:space="preserve">
          <source>No special action is taken at the ends of transactions. This is the default behavior.</source>
          <target state="translated">거래 종료시 특별한 조치가 취해지지 않습니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="61fdd0ee1a0e012e017d3d0ae54de832b57200e8" translate="yes" xml:space="preserve">
          <source>No special hardware required</source>
          <target state="translated">특별한 하드웨어 불필요</target>
        </trans-unit>
        <trans-unit id="ae79014d45aed5cbc3110d3674ce8fdfb2183d69" translate="yes" xml:space="preserve">
          <source>No support for encryption key as master key. As such practice is generally discouraged, this should not be a problem.</source>
          <target state="translated">마스터 키로 암호화 키를 지원하지 않습니다. 이러한 관행은 일반적으로 권장되지 않으므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c30a7a5188f10c0ac8624ba81f5e723c5467bcf" translate="yes" xml:space="preserve">
          <source>No support for several subkeys. This may seem like a problem, as this is common practice. On the other hand, you should not use your regular GPG/PGP keys with &lt;code&gt;pgcrypto&lt;/code&gt;, but create new ones, as the usage scenario is rather different.</source>
          <target state="translated">여러 하위 키를 지원하지 않습니다. 이것은 일반적인 관행이므로 문제처럼 보일 수 있습니다. 반면에 &lt;code&gt;pgcrypto&lt;/code&gt; 와 함께 일반 GPG / PGP 키를 사용하지 말고 사용 시나리오가 다소 다르므로 새 키를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9435d4dd42a8ebc8de1b106f0a226340aa75454" translate="yes" xml:space="preserve">
          <source>No support for signing. That also means that it is not checked whether the encryption subkey belongs to the master key.</source>
          <target state="translated">서명을 지원하지 않습니다. 또한 암호화 하위 키가 마스터 키에 속하는지 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0ba19704438347e67d6c41db6384452ae2aa5a4" translate="yes" xml:space="preserve">
          <source>No waiting for multiple servers</source>
          <target state="translated">여러 서버를 기다리지 않음</target>
        </trans-unit>
        <trans-unit id="4b6d8042bc7e3d0b0614251a34971ce673127f09" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;C&lt;/code&gt; and non-&lt;code&gt;POSIX&lt;/code&gt; locales rely on the operating system's collation library for character set ordering. This controls the ordering of keys stored in indexes. For this reason, a cluster cannot switch to an incompatible collation library version, either through snapshot restore, binary streaming replication, a different operating system, or an operating system upgrade.</source>
          <target state="translated">비 &lt;code&gt;C&lt;/code&gt; 및 비 &lt;code&gt;POSIX&lt;/code&gt; 로켈은 문자 집합 순서를 위해 운영 체제의 데이터 정렬 라이브러리를 사용합니다. 인덱스에 저장된 키의 순서를 제어합니다. 이러한 이유로 클러스터는 스냅 샷 복원, 이진 스트리밍 복제, 다른 운영 체제 또는 운영 체제 업그레이드를 통해 호환되지 않는 조합 라이브러리 버전으로 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b791053ba5b378d8e57979f3c97566be063ef0d0" translate="yes" xml:space="preserve">
          <source>Non-Deferred Uniqueness Constraints</source>
          <target state="translated">지연되지 않은 고유성 제약</target>
        </trans-unit>
        <trans-unit id="2edd532d90e9a265b3d587446d10683f0ddb82ba" translate="yes" xml:space="preserve">
          <source>Non-Durable Settings</source>
          <target state="translated">내구성이없는 설정</target>
        </trans-unit>
        <trans-unit id="1606d825faba4ca859c553032bca97393df353c3" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e. numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">절대적이지 않은 디렉토리 이름은 참조 구성 파일이 들어있는 디렉토리를 기준으로합니다. 지정된 디렉토리 내에 이름이 접미사 &lt;code&gt;.conf&lt;/code&gt; 로 끝나는 비 디렉토리 파일 만 포함됩니다. 로 시작하는 파일 이름 &lt;code&gt;.&lt;/code&gt; 일부 플랫폼에서는 이러한 파일이 숨겨져 있기 때문에 실수를 방지하기 위해 문자도 무시됩니다. 포함 디렉토리 내의 여러 파일은 파일 이름 순서로 처리됩니다 (C 로케일 규칙, 즉 문자 앞의 숫자 및 대문자 앞의 소문자에 따라).</target>
        </trans-unit>
        <trans-unit id="005bf64a001e88d6c5954633016b2d70a8916d20" translate="yes" xml:space="preserve">
          <source>Non-equality operator</source>
          <target state="translated">비 균등 연산자</target>
        </trans-unit>
        <trans-unit id="5d6b03babc67eb26f4a561798892e8e1d042f8b8" translate="yes" xml:space="preserve">
          <source>Non-equality operator (same as &lt;code&gt;!=&lt;/code&gt;)</source>
          <target state="translated">비항 등 연산자 ( &lt;code&gt;!=&lt;/code&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="20c0da4f56e91a8e794e8ad5b40aa2db7a25e473" translate="yes" xml:space="preserve">
          <source>Non-schema objects such as blobs are not dumped when &lt;code&gt;-n&lt;/code&gt; is specified. You can add blobs back to the dump with the &lt;code&gt;--blobs&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 을 지정 하면 Blob과 같은 비 스키마 개체는 덤프되지 않습니다 . &lt;code&gt;--blobs&lt;/code&gt; 스위치 를 사용하여 덤프에 덤프를 다시 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9caf6bd6e45fde8300143ee2bd8d45d380012859" translate="yes" xml:space="preserve">
          <source>Non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trim()&lt;/code&gt; 비표준 구문</target>
        </trans-unit>
        <trans-unit id="1b82aac77684b2e34b968be8bab3328cdefd6c87" translate="yes" xml:space="preserve">
          <source>Non-superusers can only apply &lt;code&gt;LOAD&lt;/code&gt; to library files located in &lt;code&gt;$libdir/plugins/&lt;/code&gt; &amp;mdash; the specified &lt;code&gt;filename&lt;/code&gt; must begin with exactly that string. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.)</source>
          <target state="translated">수퍼 유저가 아닌 사용자는 &lt;code&gt;$libdir/plugins/&lt;/code&gt; 에있는 라이브러리 파일 에만 &lt;code&gt;LOAD&lt;/code&gt; 를 적용 할 수 있습니다 . 지정된 &lt;code&gt;filename&lt;/code&gt; 은 정확히 해당 문자열로 시작해야합니다. ( &quot;안전한&quot;라이브러리 만 설치되도록하는 것은 데이터베이스 관리자의 책임입니다.)</target>
        </trans-unit>
        <trans-unit id="cdcf35d8373c6ae03dbb38620bdfe970a151c4ed" translate="yes" xml:space="preserve">
          <source>Nondeterministic collations are only supported with the ICU provider.</source>
          <target state="translated">비 결정적 데이터 정렬은 ICU 공급자에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="592caa46c1febc51d4ba97d3f0cb331e0f251855" translate="yes" xml:space="preserve">
          <source>Nonrepeatable Read</source>
          <target state="translated">반복 불가능한 읽기</target>
        </trans-unit>
        <trans-unit id="4cd9a0397eea6fedc043bb59b16fdf2f16c3bc14" translate="yes" xml:space="preserve">
          <source>Nonstandard Clauses</source>
          <target state="translated">비표준 조항</target>
        </trans-unit>
        <trans-unit id="d10c40965cecc5427a7ccc11e532baca90682092" translate="yes" xml:space="preserve">
          <source>Nordic</source>
          <target state="translated">Nordic</target>
        </trans-unit>
        <trans-unit id="5d192ac91d079d3947c34df6ca0da6af270cb95a" translate="yes" xml:space="preserve">
          <source>Normal cursors return data in text format, the same as a &lt;code&gt;SELECT&lt;/code&gt; would produce. The &lt;code&gt;BINARY&lt;/code&gt; option specifies that the cursor should return data in binary format. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform-dependent binary data formats. As an example, if a query returns a value of one from an integer column, you would get a string of &lt;code&gt;1&lt;/code&gt; with a default cursor, whereas with a binary cursor you would get a 4-byte field containing the internal representation of the value (in big-endian byte order).</source>
          <target state="translated">일반 커서는 &lt;code&gt;SELECT&lt;/code&gt; 에서 생성 한 것과 같은 텍스트 형식으로 데이터를 반환합니다 . &lt;code&gt;BINARY&lt;/code&gt; 옵션의 지정이 커서 바이너리 형식으로 데이터를 반환해야 함. 이렇게하면 플랫폼 종속 바이너리 데이터 형식을 처리하려는 프로그래머의 노력으로 서버와 클라이언트 모두에 대한 변환 노력이 줄어 듭니다. 예를 들어, 쿼리가 정수 열에서 1의 값을 반환하면 기본 커서를 사용하여 문자열 &lt;code&gt;1&lt;/code&gt; 을 얻는 반면 이진 커서를 사용하면 값의 내부 표현을 포함하는 4 바이트 필드를 얻을 수 있습니다 ( 빅 엔디안 바이트 순서로).</target>
        </trans-unit>
        <trans-unit id="e719f066c8f80c3d098dc0de105e52604edf52bd" translate="yes" xml:space="preserve">
          <source>Normally a copy of &lt;code&gt;pg_type.typstorage&lt;/code&gt; of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy.</source>
          <target state="translated">일반적 으로이 열 유형 의 &lt;code&gt;pg_type.typstorage&lt;/code&gt; 사본입니다 . TOAST 가능 데이터 유형의 경우, 스토리지 정책을 제어하기 위해 컬럼 작성 후이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfefa02592536f045045c313a59b93cf3ea4a182" translate="yes" xml:space="preserve">
          <source>Normally it is better to start &lt;code&gt;postgres&lt;/code&gt; in the background. For this, use the usual Unix shell syntax:</source>
          <target state="translated">일반적으로 백그라운드에서 &lt;code&gt;postgres&lt;/code&gt; 를 시작하는 것이 좋습니다 . 이를 위해 일반적인 Unix 쉘 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eb15db27354b906033434be491a2ae185754105d" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">일반적으로 테이블을 처음 정의 할 때 설정된 파티션 세트는 정적으로 유지되지 않습니다. 오래된 데이터 파티션을 제거하고 주기적으로 새로운 데이터에 대한 새로운 파티션을 추가하는 것이 일반적입니다. 파티셔닝의 가장 중요한 장점 중 하나는 실제로 많은 양의 데이터를 실제로 이동시키는 대신 파티션 구조를 조작하여 고통스러운 작업을 거의 즉시 실행할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85e1a3935578c6fbceb8f9dfc1ec7edf36d93788" translate="yes" xml:space="preserve">
          <source>Normally there is one entry, with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;, for each table column that has been analyzed. If the table has inheritance children, a second entry with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; is also created. This row represents the column's statistics over the inheritance tree, i.e., statistics for the data you'd see with &lt;code&gt;SELECT column FROM table*&lt;/code&gt;, whereas the &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; row represents the results of &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt;.</source>
          <target state="translated">일반적 으로 분석 된 각 테이블 열에 대해 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 인 항목이 하나 있습니다. 테이블에 상속 하위가 있으면 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 인 두 번째 항목 도 작성됩니다. 이 행은 상속 트리에 대한 열의 통계, 즉 &lt;code&gt;SELECT column FROM table*&lt;/code&gt; 과 함께 표시되는 데이터에 대한 통계를 나타내는 반면 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 행은 &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt; 의 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ef0a797677cd4cd7010abb5ff69a6286820deaa9" translate="yes" xml:space="preserve">
          <source>Normally these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt; so that they apply to all server processes, but it is possible to turn them on or off in individual sessions using the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command. (To prevent ordinary users from hiding their activity from the administrator, only superusers are allowed to change these parameters with &lt;code&gt;SET&lt;/code&gt;.)</source>
          <target state="translated">일반적으로 이러한 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정되어 모든 서버 프로세스에 적용되지만 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 명령을 사용하여 개별 세션에서 설정 하거나 해제 할 수 있습니다 . 일반 사용자가 자신의 활동을 관리자에게 숨기지 않도록 수퍼 유저 만 &lt;code&gt;SET&lt;/code&gt; 를 사용하여 이러한 매개 변수를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="059b752177da2be76f272de074908dfea33c9049" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;VACUUM&lt;/code&gt; will skip pages based on the &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;visibility map&lt;/a&gt;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.</source>
          <target state="translated">일반적으로 &lt;code&gt;VACUUM&lt;/code&gt; 은 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;가시성 맵을&lt;/a&gt; 기준으로 페이지를 건너 뜁니다 . 모든 튜플이 고정 된 것으로 알려진 페이지는 항상 건너 뛸 수 있으며 모든 튜플이 모든 트랜잭션에 표시되는 것으로 알려진 페이지는 공격적인 진공을 수행 할 때를 제외하고는 건너 뛸 수 있습니다. 또한 적극적인 진공 청소기를 수행하는 경우를 제외하고 다른 세션의 사용이 끝나기를 기다리지 않기 위해 일부 페이지를 건너 뛸 수 있습니다. 이 옵션은 모든 페이지 건너 뛰기 동작을 비활성화하며 가시성 맵의 내용이 의심되는 경우에만 사용하도록되어 있으며 데이터베이스 손상을 일으키는 하드웨어 또는 소프트웨어 문제가있는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a28b92dedca807b45d1375cda7834475db13842" translate="yes" xml:space="preserve">
          <source>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; command on the dictionary. This can be a &amp;ldquo;dummy&amp;rdquo; update that doesn't actually change any parameter values.</source>
          <target state="translated">일반적으로 데이터베이스 세션은 세션 내에서 처음 사용될 때 사전 구성 파일을 한 번만 읽습니다. 구성 파일을 수정하고 기존 세션이 새 컨텐츠를 선택 하도록하려면 사전에서 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 명령을 실행하십시오. 이것은 실제로 매개 변수 값을 변경하지 않는 &quot;더미&quot;업데이트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bffa790046f833c87fae190fc13aecca45c4acb" translate="yes" xml:space="preserve">
          <source>Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If &lt;code&gt;MATCH FULL&lt;/code&gt; is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a &lt;code&gt;MATCH FULL&lt;/code&gt; constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">일반적으로 참조 행이 참조 열이 null 인 경우 참조 행은 외래 키 제약 조건을 충족 할 필요가 없습니다. 경우 &lt;code&gt;MATCH FULL&lt;/code&gt; 는 외래 키 선언에 추가하는 참조 행 (널 (null)이 아닌 null 값의 혼합이 실패 보장되도록 모든 참조 열이 null 경우에만 제약 조건을 만족 기약 &lt;code&gt;MATCH FULL&lt;/code&gt; 의 제약을). 참조 행이 외래 키 제약 조건을 충족시키지 못하도록하려면 참조 열을 &lt;code&gt;NOT NULL&lt;/code&gt; 로 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="a73d6e4c0676c9748a26df54015a17cf72960f1a" translate="yes" xml:space="preserve">
          <source>Normally, psql will dispatch a SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</source>
          <target state="translated">일반적으로 psql은 현재 줄에 더 많은 입력이 남아 있어도 명령 종료 세미콜론에 도달하자마자 서버에 SQL 명령을 발송합니다. 따라서 예를 들어 입력</target>
        </trans-unit>
        <trans-unit id="c995fea5a35dfbddf38f7ea21e264f8ae6030a27" translate="yes" xml:space="preserve">
          <source>Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a &amp;ldquo;file not found&amp;rdquo; message, the exact text of the error message depending upon your choice of &lt;code&gt;restore_command&lt;/code&gt;. You may also see an error message at the start of recovery for a file named something like &lt;code&gt;00000001.history&lt;/code&gt;. This is also normal and does not indicate a problem in simple recovery situations; see &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">일반적으로 복구는 사용 가능한 모든 WAL 세그먼트를 통해 진행되므로 데이터베이스를 현재 시점으로 (또는 사용 가능한 WAL 세그먼트가 가능한 한 가깝게) 복원합니다. 따라서 정상적인 복구는 &lt;code&gt;restore_command&lt;/code&gt; 의 선택에 따라 오류 메시지의 정확한 텍스트 인&amp;ldquo;file not found&amp;rdquo;메시지로 끝납니다 . 복구 시작시 &lt;code&gt;00000001.history&lt;/code&gt; 와 같은 이름의 파일에 대한 오류 메시지가 표시 될 수도 있습니다 . 이것은 또한 정상적인 현상이며 간단한 복구 상황에서는 문제가되지 않습니다. 자세한 내용 &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;은 25.3.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="991460ee5abf98bebd31fd08e1871d36222f94b0" translate="yes" xml:space="preserve">
          <source>Normally, the database user who executes this command becomes the owner of the new database. However, a different owner can be specified via the &lt;code&gt;-O&lt;/code&gt; option, if the executing user has appropriate privileges.</source>
          <target state="translated">일반적으로이 명령을 실행하는 데이터베이스 사용자는 새 데이터베이스의 소유자가됩니다. 그러나 실행중인 사용자에게 적절한 권한이있는 경우 &lt;code&gt;-O&lt;/code&gt; 옵션을 통해 다른 소유자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cce3fdca736676d73614d21a0ddda63501859fa9" translate="yes" xml:space="preserve">
          <source>Normally, the single-user mode server treats newline as the command entry terminator; there is no intelligence about semicolons, as there is in psql. To continue a command across multiple lines, you must type backslash just before each newline except the last one. The backslash and adjacent newline are both dropped from the input command. Note that this will happen even when within a string literal or comment.</source>
          <target state="translated">일반적으로 단일 사용자 모드 서버는 개행을 명령 입력 종료 자로 처리합니다. psql에있는 것처럼 세미콜론에 대한 정보는 없습니다. 여러 줄에 걸쳐 명령을 계속하려면 마지막 줄을 제외한 각 줄 바꿈 바로 앞에 백 슬래시를 입력해야합니다. 백 슬래시와 인접한 줄 바꿈은 모두 입력 명령에서 삭제됩니다. 이것은 문자열 리터럴 또는 주석 내에있을 때도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ab9de63486b486ed7137fde8276d785f144a066" translate="yes" xml:space="preserve">
          <source>Normally, there is a single apply process running for an enabled subscription. A disabled subscription or a crashed subscription will have zero rows in this view. If the initial data synchronization of any table is in progress, there will be additional workers for the tables being synchronized.</source>
          <target state="translated">일반적으로 사용 가능한 구독에 대해 단일 적용 프로세스가 실행 중입니다. 비활성화 된 가입 또는 중단 된 가입은이보기에서 행이 없습니다. 테이블의 초기 데이터 동기화가 진행중인 경우 테이블에 대한 추가 작업자가 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="67e110cfa914197db96be5bd8ad2cb0e12d33a41" translate="yes" xml:space="preserve">
          <source>Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the &lt;code&gt;NOT VALID&lt;/code&gt; option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; option. See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more information about using the &lt;code&gt;NOT VALID&lt;/code&gt; option.</source>
          <target state="translated">일반적으로이 양식은 테이블을 스캔하여 테이블의 모든 기존 행이 새 제한 조건을 만족하는지 확인합니다. 그러나 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하는 경우이 잠재적으로 긴 스캔을 건너 뜁니다. 이후의 삽입 또는 업데이트에 대해 제약 조건이 계속 적용됩니다. 즉, 외래 키의 경우 참조 테이블에 일치하는 행이 없으면 실패하거나 새 행이 지정된 검사와 일치하지 않으면 실패합니다. 질환). 그러나 데이터베이스는 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 옵션 을 사용하여 유효성을 검증 할 때까지 테이블의 모든 행에 대해 제한 조건이 있다고 가정하지 않습니다 . &lt;code&gt;NOT VALID&lt;/code&gt; 옵션 사용에 대한 자세한 내용은 아래 &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;참고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01a8f59aaf55d8442cfcf99c35955b402850a73f" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">일반적으로 컴퓨터가 부팅 될 때 데이터베이스 서버를 시작하려고합니다. 자동 시작 스크립트는 운영 체제에 따라 다릅니다. &lt;code&gt;contrib/start-scripts&lt;/code&gt; 디렉토리에 PostgreSQL과 함께 배포 된 것이 있습니다. 하나를 설치하려면 루트 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="99872ab32108649405bf8805c9de4baeb85fb7ad" translate="yes" xml:space="preserve">
          <source>North European</source>
          <target state="translated">북유럽</target>
        </trans-unit>
        <trans-unit id="f79ff66cfb084d1746f64ba03a393ded056f91f0" translate="yes" xml:space="preserve">
          <source>Not all client APIs support all the listed character sets. For example, the PostgreSQL JDBC driver does not support &lt;code&gt;MULE_INTERNAL&lt;/code&gt;, &lt;code&gt;LATIN6&lt;/code&gt;, &lt;code&gt;LATIN8&lt;/code&gt;, and &lt;code&gt;LATIN10&lt;/code&gt;.</source>
          <target state="translated">모든 클라이언트 API가 나열된 모든 문자 세트를 지원하지는 않습니다. 예를 들어 PostgreSQL JDBC 드라이버는 &lt;code&gt;MULE_INTERNAL&lt;/code&gt; , &lt;code&gt;LATIN6&lt;/code&gt; , &lt;code&gt;LATIN8&lt;/code&gt; 및 &lt;code&gt;LATIN10&lt;/code&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bacd7c0a9a33892b688e78e77b6ecea0ecffd5d" translate="yes" xml:space="preserve">
          <source>Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of &lt;code&gt;.history&lt;/code&gt;. Also be aware that the base name of the &lt;code&gt;%p&lt;/code&gt; path will be different from &lt;code&gt;%f&lt;/code&gt;; do not expect them to be interchangeable.</source>
          <target state="translated">요청 된 파일이 모두 WAL 세그먼트 파일이되는 것은 아닙니다. 접미사가 &lt;code&gt;.history&lt;/code&gt; 인 파일에 대한 요청도 예상해야합니다 . 또한 &lt;code&gt;%p&lt;/code&gt; 경로 의 기본 이름은 &lt;code&gt;%f&lt;/code&gt; 와 다릅니다 . 그것들이 상호 교환 될 것으로 기대하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f925a3c210bc672e17b8d68ff775e287c505fff" translate="yes" xml:space="preserve">
          <source>Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the purposes of this tutorial under the user account that you started the server as. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">모든 사용자가 새 데이터베이스를 만들 권한이있는 것은 아닙니다. PostgreSQL이 데이터베이스 생성을 거부하면 사이트 관리자가 데이터베이스 생성 권한을 부여해야합니다. 이 경우 사이트 관리자에게 문의하십시오. PostgreSQL을 직접 설치 한 경우 서버를 시작한 사용자 계정으로이 자습서의 목적으로 로그인해야합니다. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7dd5e10546306e9d83ef043283f9c8c8719bbf88" translate="yes" xml:space="preserve">
          <source>Not possible</source>
          <target state="translated">불가능</target>
        </trans-unit>
        <trans-unit id="14141efdb351648cd5997a4ec11511c9b9025f02" translate="yes" xml:space="preserve">
          <source>Not the password (always reads as &lt;code&gt;********&lt;/code&gt;)</source>
          <target state="translated">비밀번호가 아님 (항상 &lt;code&gt;********&lt;/code&gt; 로 읽음 )</target>
        </trans-unit>
        <trans-unit id="5b3582a3ba934510ccb693b77b7924863143d181" translate="yes" xml:space="preserve">
          <source>Notable differences between the existing POSIX-based regular-expression feature and XQuery regular expressions include:</source>
          <target state="translated">기존 POSIX 기반 정규 표현식 기능과 XQuery 정규 표현식의 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9b3331f6b2637140f06fa920c5a275390198583a" translate="yes" xml:space="preserve">
          <source>Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction's snapshot is actually frozen at the start of its first query or data-modification command (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;), so it is possible to obtain locks explicitly before the snapshot is frozen.</source>
          <target state="translated">동시 변경을 방지하기 위해 명시 적 잠금에 의존하는 경우 읽기 커밋 모드를 사용하거나 반복 가능한 읽기 모드에서 쿼리를 수행하기 전에 잠금을 얻도록주의해야합니다. 반복 가능한 읽기 트랜잭션에 의해 획득 된 잠금은 테이블을 수정하는 다른 트랜잭션이 아직 실행 중임을 보장하지 않지만, 트랜잭션에 의해 표시된 스냅 샷이 잠금을 획득하기 전에 테이블에서 현재 커밋 된 일부 변경 사항보다 오래 될 수 있습니다. 반복 가능한 읽기 트랜잭션의 스냅 샷은 실제로 첫 번째 쿼리 또는 데이터 수정 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; ) 이 시작될 때 고정 되므로 스냅 샷이 고정되기 전에 명시 적으로 잠금을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7593ffc9010adfe129fd98d3fee440d02e9a7b83" translate="yes" xml:space="preserve">
          <source>Note however that if multiple standby servers are restoring from the same archive directory, you will need to ensure that you do not delete WAL files until they are no longer needed by any of the servers. &lt;code&gt;archive_cleanup_command&lt;/code&gt; would typically be used in a warm-standby configuration (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command.</source>
          <target state="translated">그러나 여러 대기 서버가 동일한 아카이브 디렉토리에서 복원하는 경우 서버에서 더 이상 필요하지 않을 때까지 WAL 파일을 삭제하지 않아야합니다. &lt;code&gt;archive_cleanup_command&lt;/code&gt; 는 일반적으로 웜 스탠바이 구성에 사용됩니다 ( &lt;a href=&quot;warm-standby&quot;&gt;26.2 절&lt;/a&gt; 참조 ). 명령에 실제 &lt;code&gt;%&lt;/code&gt; 문자 를 포함 시키려면 &lt;code&gt;%%&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="a9a98603977441f8554a2833afe694dbcfe6aeee" translate="yes" xml:space="preserve">
          <source>Note however that simple names are matched to column names before table names, so this example works only because there is no column named &lt;code&gt;c&lt;/code&gt; in the query's tables.</source>
          <target state="translated">그러나 단순 이름은 테이블 이름 이전의 열 이름과 일치하므로이 예 는 쿼리 테이블에 &lt;code&gt;c&lt;/code&gt; 라는 열이 없기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0aef3a8d9770be0e69a039281f14778156239350" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;try all combinations&amp;rdquo; is not a realistic exercise. Usually password cracking is done with the help of dictionaries, which contain both regular words and various mutations of them. So, even somewhat word-like passwords could be cracked much faster than the above numbers suggest, while a 6-character non-word-like password may escape cracking. Or not.</source>
          <target state="translated">&quot;모든 조합을 시도하십시오&quot;는 현실적인 연습이 아닙니다. 일반적으로 비밀번호 크래킹은 사전의 도움으로 이루어지며 여기에는 규칙적인 단어와 다양한 변형이 포함됩니다. 따라서 6 자리가 아닌 단어와 같은 암호는 크랙을 피할 수있는 반면, 단어와 비슷한 암호는 위의 숫자보다 훨씬 빠르게 해독 될 수 있습니다. 아님</target>
        </trans-unit>
        <trans-unit id="00e6a4c57a18e5fbbf85ff612c2a3727ded13249" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/etc/rc&lt;/code&gt; is usually overwritten by macOS system updates, so you should expect to have to redo these edits after each update.</source>
          <target state="translated">참고 있음 &lt;code&gt;/etc/rc&lt;/code&gt; 각 업데이트 후이 편집을 다시 실행을 감수해야하므로 일반적으로, 맥 OS 시스템 업데이트로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="27a1cfa3bf0ee9c52c7a87330ba166c5fa86db79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; are not in the SQL standard, but are a common extension. Some other databases make them return NULL if any argument is NULL, rather than only when all are NULL.</source>
          <target state="translated">참고 &lt;code&gt;GREATEST&lt;/code&gt; 와 &lt;code&gt;LEAST&lt;/code&gt; 는 SQL 표준에 있지 않은,하지만 일반적인 확장이다. 일부 다른 데이터베이스는 모든 인수가 NULL 일 때가 아니라 인수가 NULL 인 경우 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d1e87e3a532a3c85a5fb7cefcf86b5bd58f7519a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT&lt;/code&gt; with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; checks &lt;code&gt;INSERT&lt;/code&gt; policies' &lt;code&gt;WITH CHECK&lt;/code&gt; expressions only for rows appended to the relation by the &lt;code&gt;INSERT&lt;/code&gt; path.</source>
          <target state="translated">참고 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 검사 &lt;code&gt;INSERT&lt;/code&gt; 의 정책 ' &lt;code&gt;WITH CHECK&lt;/code&gt; 단지로의 관계에 추가 행에 대한 식을 &lt;code&gt;INSERT&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="c319652e77f1cdd2df39e790f0f919f2b95a2486" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;amcheck&lt;/code&gt; examines a page as represented in some shared memory buffer at the time of verification if there is only a shared buffer hit when accessing the block. Consequently, &lt;code&gt;amcheck&lt;/code&gt; does not necessarily examine data read from the file system at the time of verification. Note that when checksums are enabled, &lt;code&gt;amcheck&lt;/code&gt; may raise an error due to a checksum failure when a corrupt block is read into a buffer.</source>
          <target state="translated">참고 &lt;code&gt;amcheck&lt;/code&gt; 이 블록에 액세스하는 경우에만 공유 버퍼 히트가 있는지 확인시 일부 공유 메모리 버퍼에 표시된 바와 같이 페이지를 검사한다. 결과적으로 &lt;code&gt;amcheck&lt;/code&gt; 는 검증시 파일 시스템에서 읽은 데이터를 반드시 검사하지는 않습니다. 체크섬이 활성화 되면 손상된 블록을 버퍼로 읽을 때 체크섬 오류로 인해 &lt;code&gt;amcheck&lt;/code&gt; 에서 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef24e95dba1150cbef958d74c2f80a5630d7740c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extract&lt;/code&gt;'s day of the week numbering differs from that of the &lt;code&gt;to_char(..., 'D')&lt;/code&gt; function.</source>
          <target state="translated">참고 &lt;code&gt;extract&lt;/code&gt; '의 그것과 다르다 번호 주중의 날 &lt;code&gt;to_char(..., 'D')&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="993b93174865d889f669c89fbc134d310b24fd79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt; consider only the rows within the &amp;ldquo;window frame&amp;rdquo;, which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for &lt;code&gt;last_value&lt;/code&gt; and sometimes also &lt;code&gt;nth_value&lt;/code&gt;. You can redefine the frame by adding a suitable frame specification (&lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt;) to the &lt;code&gt;OVER&lt;/code&gt; clause. See &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt; for more information about frame specifications.</source>
          <target state="translated">참고 &lt;code&gt;first_value&lt;/code&gt; , &lt;code&gt;last_value&lt;/code&gt; 및 &lt;code&gt;nth_value&lt;/code&gt; 기본적으로 현재 행의 마지막 피어를 통해 파티션의 시작부터 행을 포함하는 &quot;창 프레임&quot;내에서만 행을 고려하십시오. 이것은 인정에 대한 결과를 줄 가능성이 &lt;code&gt;last_value&lt;/code&gt; 때로는 및 &lt;code&gt;nth_value&lt;/code&gt; 을 . 적절한 프레임 스펙 ( &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; )을 &lt;code&gt;OVER&lt;/code&gt; 절 에 추가하여 프레임을 재정의 할 수 있습니다 . 프레임 사양에 대한 자세한 내용은 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e089463c04f2f8771502e8d62b431f3c71d88b7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort (&lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</source>
          <target state="translated">참고 &lt;code&gt;m&lt;/code&gt; 의 열은 또한 보조 저장 밖으로 이동 될 수 있지만, 최후로 ( &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 열이 먼저 이동).</target>
        </trans-unit>
        <trans-unit id="40331004e0ffed62ad250a770b0b797c5ac46ee7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</source>
          <target state="translated">참고 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 은 쿼리가 취소되기 전에 실행할 수있는 최대 시간과 동일하지 않습니다; 오히려 하나의 WAL 세그먼트 데이터를 적용 할 수있는 최대 총 시간입니다. 따라서 하나의 쿼리로 인해 WAL 세그먼트의 초기에 상당한 지연이 발생하면 후속 충돌 쿼리의 유예 시간이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d4ea769871b3208ec9bdd68befff4d7903f7eff9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</source>
          <target state="translated">참고 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 은 쿼리가 취소되기 전에 실행할 수있는 최대 시간과 동일하지 않습니다; 오히려 주 서버에서 WAL 데이터를 수신 한 후 적용 할 수있는 최대 총 시간입니다. 따라서 하나의 쿼리로 인해 상당한 지연이 발생하면 대기 서버가 다시 중단 될 때까지 후속 충돌 쿼리의 유예 시간이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d6596a8da6c53c8c974c373f17703e4e032c6d9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;plainto_tsquery&lt;/code&gt; will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">참고 &lt;code&gt;plainto_tsquery&lt;/code&gt; 가 인식하지 않습니다 &lt;code&gt;tsquery&lt;/code&gt; 입력 연산자, 체중 레이블 또는 접두사 일치 라벨 :</target>
        </trans-unit>
        <trans-unit id="531e2b77490742cd189acb5bc5e4276f0143a9de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;postgres_fdw&lt;/code&gt; currently lacks support for &lt;code&gt;INSERT&lt;/code&gt; statements with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause. However, the &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; clause is supported, provided a unique index inference specification is omitted. Note also that &lt;code&gt;postgres_fdw&lt;/code&gt; supports row movement invoked by &lt;code&gt;UPDATE&lt;/code&gt; statements executed on partitioned tables, but it currently does not handle the case where a remote partition chosen to insert a moved row into is also an &lt;code&gt;UPDATE&lt;/code&gt; target partition that will be updated later.</source>
          <target state="translated">참고 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재에 대한 지원이 부족 &lt;code&gt;INSERT&lt;/code&gt; 와 문 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절을. 그러나 고유 색인 유추 스펙이 생략 되면 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 절이 지원됩니다. 참고 또한 &lt;code&gt;postgres_fdw&lt;/code&gt; 의 지지체 열 운동에 의해 호출 &lt;code&gt;UPDATE&lt;/code&gt; 파티션 테이블에서 실행 문 있지만 현재로 이동 된 행을 삽입 선택된 원격 파티션도 인 경우에는 처리하지 않는 &lt;code&gt;UPDATE&lt;/code&gt; 이후 업데이트 될 타겟 파티션.</target>
        </trans-unit>
        <trans-unit id="9d0c357cbd644595d94bcf660fedeb383e698ab1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;to_tsquery&lt;/code&gt; will process prefixes in the same way as other words, which means this comparison returns true:</source>
          <target state="translated">참고 &lt;code&gt;to_tsquery&lt;/code&gt; 은 이 비교가 true를 돌려주는 의미의 다른 단어와 같은 방법에 접두사를 처리합니다 :</target>
        </trans-unit>
        <trans-unit id="547e51942705ea4910d562213bfd3cab3c67874d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wal_receiver_timeout&lt;/code&gt;, &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; and &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; configuration parameters affect the logical replication workers as well.</source>
          <target state="translated">참고 &lt;code&gt;wal_receiver_timeout&lt;/code&gt; 을 , &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 및 &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; 구성 매개 변수가 아니라 논리적 복제 노동자에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e5c3c7860afae265b42af4a1e6e8bf5af951d1e2" translate="yes" xml:space="preserve">
          <source>Note that GIN index build time can often be improved by increasing &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;, while GiST index build time is not sensitive to that parameter.</source>
          <target state="translated">GIN 인덱스 빌드 시간은 종종 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 을 늘려서 향상시킬 수 있지만 GiST 인덱스 빌드 시간은 해당 매개 변수에 민감하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b8a5f57b365044d35823a4b451d18873918bc73" translate="yes" xml:space="preserve">
          <source>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap &lt;code&gt;xmlforest&lt;/code&gt; expressions in &lt;code&gt;xmlelement&lt;/code&gt;.</source>
          <target state="translated">XML 포리스트는 둘 이상의 요소로 구성된 경우 유효한 XML 문서가 아니므로 &lt;code&gt;xmlforest&lt;/code&gt; 식을 &lt;code&gt;xmlelement&lt;/code&gt; 로 감싸는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41bc51ade685b6e9a9074785e60b9928bfbc83ce" translate="yes" xml:space="preserve">
          <source>Note that a file system backup will typically be larger than an SQL dump. (pg_dump does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster.</source>
          <target state="translated">파일 시스템 백업은 일반적으로 SQL 덤프보다 큽니다. (pg_dump는 인덱스의 내용을 덤프 할 필요가 없습니다. 예를 들어, 인덱스를 다시 작성하는 명령 만 있습니다.) 그러나 파일 시스템 백업을 수행하는 것이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c32d659dad68b2cd17eab976deb46f2e6ed59ea" translate="yes" xml:space="preserve">
          <source>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</source>
          <target state="translated">외부 테이블은 기본 원격 테이블보다 적은 수의 열 또는 다른 열 순서로 선언 될 수 있습니다. 리모트 테이블에 컬럼을 일치시키는 것은 위치가 아니라 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c47a3a43d56fab6f7325c7aa20434bcba1bc9c0b" translate="yes" xml:space="preserve">
          <source>Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (&lt;code&gt;'&lt;/code&gt;), as in the example. The &lt;code&gt;date&lt;/code&gt; type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.</source>
          <target state="translated">모든 데이터 유형은 명백한 입력 형식을 사용합니다. 간단한 숫자 값이 아닌 상수는 일반적으로 예제와 같이 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )로 묶어야합니다 . &lt;code&gt;date&lt;/code&gt; 형식은 실제로 받아들이는 것에 매우 유연하지만이 튜토리얼 우리는 여기에 표시된 명확한 형식에 충실 할 것이다.</target>
        </trans-unit>
        <trans-unit id="25d42cd6ceef922ecf25e7b24fce40695e12cb56" translate="yes" xml:space="preserve">
          <source>Note that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause.</source>
          <target state="translated">다른 모든 세션은 데이터가 성공적으로로드되면 즉시 데이터를 볼 수 있습니다. 이는 일반적인 MVCC 가시성 규칙에 위배되며이를 지정하는 사용자는 이로 인해 발생할 수있는 잠재적 문제를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="df99d378fb51575b390c0b84d9d7987211c8c70b" translate="yes" xml:space="preserve">
          <source>Note that all the solutions described above take care of starting new log files at configurable intervals, but they do not handle deletion of old, no-longer-useful log files. You will probably want to set up a batch job to periodically delete old log files. Another possibility is to configure the rotation program so that old log files are overwritten cyclically.</source>
          <target state="translated">위에서 설명한 모든 솔루션은 구성 가능한 간격으로 새 로그 파일을 시작하는 것을 처리하지만 더 오래 사용되지 않는 오래된 로그 파일의 삭제는 처리하지 않습니다. 오래된 로그 파일을 주기적으로 삭제하도록 배치 작업을 설정하려고 할 수 있습니다. 또 다른 가능성은 회전 로그 프로그램을 구성하여 오래된 로그 파일을 주기적으로 덮어 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c87d02f3e8f6257698af02e373aea3121b7dc2e" translate="yes" xml:space="preserve">
          <source>Note that although WAL archiving will allow you to restore any modifications made to the data in your PostgreSQL database, it will not restore changes made to configuration files (that is, &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt; and &lt;code&gt;pg_ident.conf&lt;/code&gt;), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for how to relocate the configuration files.</source>
          <target state="translated">WAL 아카이브를 사용하면 PostgreSQL 데이터베이스의 데이터에 대한 수정 사항을 복원 할 수 있지만 구성 파일 ( &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; 및 &lt;code&gt;pg_ident.conf&lt;/code&gt; )에 대한 변경 사항은 복원되지 않습니다. SQL 작업 대신 수동으로 편집했습니다. 일반 파일 시스템 백업 절차에 의해 백업 될 위치에 구성 파일을 보관할 수 있습니다. 구성 파일을 재배치하는 방법 &lt;a href=&quot;runtime-config-file-locations&quot;&gt;은 19.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53090021f825a89df9ea9e9d71eae604c7c4a95" translate="yes" xml:space="preserve">
          <source>Note that an &lt;code&gt;AS&lt;/code&gt; clause is required when &lt;code&gt;VALUES&lt;/code&gt; is used in a &lt;code&gt;FROM&lt;/code&gt; clause, just as is true for &lt;code&gt;SELECT&lt;/code&gt;. It is not required that the &lt;code&gt;AS&lt;/code&gt; clause specify names for all the columns, but it's good practice to do so. (The default column names for &lt;code&gt;VALUES&lt;/code&gt; are &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc in PostgreSQL, but these names might be different in other database systems.)</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 의 경우와 마찬가지로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 &lt;code&gt;VALUES&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;AS&lt;/code&gt; 절이 필요합니다 . &lt;code&gt;AS&lt;/code&gt; 절이 모든 열의 이름을 지정할 필요는 없지만 그렇게하는 것이 좋습니다. ( PostgreSQL에서 &lt;code&gt;VALUES&lt;/code&gt; 의 기본 열 이름 은 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등이지만 다른 데이터베이스 시스템에서는 이름이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2b4af4e58c7c07f18643d7fac4e1368ce1d5e583" translate="yes" xml:space="preserve">
          <source>Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Thus, for example, revoking &lt;code&gt;SELECT&lt;/code&gt; privilege from &lt;code&gt;PUBLIC&lt;/code&gt; does not necessarily mean that all roles have lost &lt;code&gt;SELECT&lt;/code&gt; privilege on the object: those who have it granted directly or via another role will still have it. Similarly, revoking &lt;code&gt;SELECT&lt;/code&gt; from a user might not prevent that user from using &lt;code&gt;SELECT&lt;/code&gt; if &lt;code&gt;PUBLIC&lt;/code&gt; or another membership role still has &lt;code&gt;SELECT&lt;/code&gt; rights.</source>
          <target state="translated">특정 역할에는 해당 역할에 직접 부여 된 권한, 현재 구성원 인 모든 역할에 부여 된 권한 및 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 된 권한의 합계가 있습니다 . 예를 들어 &lt;code&gt;PUBLIC&lt;/code&gt; 에서 &lt;code&gt;SELECT&lt;/code&gt; 권한을 취소 한다고해서 모든 역할이 객체에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한을 잃어버린 것은 아닙니다 . 직접 또는 다른 역할을 통해 권한을 부여한 사람에게는 여전히 권한이 있습니다. 마찬가지로 &lt;code&gt;PUBLIC&lt;/code&gt; 또는 다른 멤버십 역할에 여전히 &lt;code&gt;SELECT&lt;/code&gt; 권한 이있는 경우 사용자에서 &lt;code&gt;SELECT&lt;/code&gt; 를 취소 하면 해당 사용자가 &lt;code&gt;SELECT&lt;/code&gt; 를 사용하지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fd76787f2a53ba7fb758f8a964cdd22772c1d78" translate="yes" xml:space="preserve">
          <source>Note that because &lt;code&gt;recovery.signal&lt;/code&gt; will not be removed when &lt;code&gt;recovery_target_action&lt;/code&gt; is set to &lt;code&gt;shutdown&lt;/code&gt;, any subsequent start will end with immediate shutdown unless the configuration is changed or the &lt;code&gt;recovery.signal&lt;/code&gt; file is removed manually.</source>
          <target state="translated">그 때문에 참고 &lt;code&gt;recovery.signal&lt;/code&gt; 이 때 제거되지 않습니다 &lt;code&gt;recovery_target_action&lt;/code&gt; 이 설정되어 &lt;code&gt;shutdown&lt;/code&gt; 구성이 변경되거나하지 않는 한, 후속 시작은 즉시 종료와 함께 종료됩니다 &lt;code&gt;recovery.signal&lt;/code&gt; 파일을 수동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9c33fcc287f27c5bc2a2b32d53b1b513b1091d88" translate="yes" xml:space="preserve">
          <source>Note that casting to just &amp;ldquo;bit&amp;rdquo; means casting to &lt;code&gt;bit(1)&lt;/code&gt;, and so will deliver only the least significant bit of the integer.</source>
          <target state="translated">&quot;비트&quot;로 캐스팅하는 것은 &lt;code&gt;bit(1)&lt;/code&gt; 캐스팅하는 것을 의미 하므로 정수의 최하위 비트 만 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fd0a0fb6f9e97d5efee795fd874b77207c725a32" translate="yes" xml:space="preserve">
          <source>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</source>
          <target state="translated">명령문 별 대기 시간 계산에 필요한 추가 타이밍 정보를 수집하면 약간의 오버 헤드가 추가됩니다. 그러면 평균 실행 속도가 느려지고 계산 된 TPS가 낮아집니다. 성능 저하 정도는 플랫폼 및 하드웨어에 따라 크게 다릅니다. 지연 시간보고를 사용하거나 사용하지 않는 평균 TPS 값을 비교하면 타이밍 오버 헤드가 중요한지 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46048f7966588bd79b584545411fe217e62e0e87" translate="yes" xml:space="preserve">
          <source>Note that constraints other than &lt;code&gt;NOT NULL&lt;/code&gt; will never be imported from the remote tables. Although PostgreSQL does support &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a &lt;code&gt;CHECK&lt;/code&gt; constraint could lead to hard-to-detect errors in query optimization. So if you wish to import &lt;code&gt;CHECK&lt;/code&gt; constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 이외의 제약 조건 은 원격 테이블에서 가져 오지 않습니다. PostgreSQL은 외부 테이블에 대한 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 지원하지만 제약 조건식이 로컬 및 원격 서버에서 다르게 평가 될 위험 때문에 자동으로 가져 오기를 제공 할 수 없습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 의 동작에 이러한 불일치 가 있으면 쿼리 최적화에서 오류를 감지하기 어려울 수 있습니다. 따라서 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 가져 오려면 수동으로 가져와야 하며 각각의 의미를 신중하게 확인해야합니다. 외부 테이블 의 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 처리에 대한 자세한 내용 은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="699164176c152ba6b84d675ad75f5ace743cae19" translate="yes" xml:space="preserve">
          <source>Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer.</source>
          <target state="translated">비용 산정 함수는 플래너 / 최적화 프로그램의 내부 데이터 구조에 액세스해야하므로 SQL 또는 사용 가능한 절차 언어가 아닌 C로 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06d4a3361a37979804bf5a58a39eb486b3f91ba2" translate="yes" xml:space="preserve">
          <source>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:</source>
          <target state="translated">교착 상태는 행 수준 잠금의 결과로 발생할 수도 있습니다 (따라서 명시 적 잠금을 사용하지 않더라도 발생할 수 있음). 두 개의 동시 트랜잭션이 테이블을 수정하는 경우를 고려하십시오. 첫 번째 트랜잭션은 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8001d46d3d20b93246bb06a2398e61902d0e24f2" translate="yes" xml:space="preserve">
          <source>Note that different keys may have the same ID. This is rare but a normal event. The client application should then try to decrypt with each one, to see which fits &amp;mdash; like handling &lt;code&gt;ANYKEY&lt;/code&gt;.</source>
          <target state="translated">다른 키는 동일한 ID를 가질 수 있습니다. 이것은 드물지만 정상적인 사건입니다. 그런 다음 클라이언트 응용 프로그램은 각각을 해독하여 &lt;code&gt;ANYKEY&lt;/code&gt; 처리와 같이 어느 것이 적합한 지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9652ff899a1fe6db38db0e7bf8d1018609b472" translate="yes" xml:space="preserve">
          <source>Note that different units are used for the per loop time than the histogram. The loop can have resolution within a few nanoseconds (ns), while the individual timing calls can only resolve down to one microsecond (us).</source>
          <target state="translated">루프 당 시간에는 히스토그램과 다른 단위가 사용됩니다. 루프는 몇 나노초 (ns) 내에서 해상도를 가질 수있는 반면 개별 타이밍 호출은 1 마이크로 초 (us)까지만 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8463fb9b10613a7f093421dc720a6dd930e1df32" translate="yes" xml:space="preserve">
          <source>Note that enabling or disabling group access on an existing cluster requires the cluster to be shut down and the appropriate mode to be set on all directories and files before restarting PostgreSQL. Otherwise, a mix of modes might exist in the data directory. For clusters that allow access only by the owner, the appropriate modes are &lt;code&gt;0700&lt;/code&gt; for directories and &lt;code&gt;0600&lt;/code&gt; for files. For clusters that also allow reads by the group, the appropriate modes are &lt;code&gt;0750&lt;/code&gt; for directories and &lt;code&gt;0640&lt;/code&gt; for files.</source>
          <target state="translated">기존 클러스터에서 그룹 액세스를 활성화 또는 비활성화하려면 PostgreSQL을 다시 시작하기 전에 클러스터를 종료하고 모든 디렉토리와 파일에 적절한 모드를 설정해야합니다. 그렇지 않으면, 혼합 모드가 데이터 디렉토리에 존재할 수 있습니다. 소유자 만 액세스 할 수있는 클러스터의 경우 적합한 모드는 디렉토리의 경우 &lt;code&gt;0700&lt;/code&gt; 이고 파일의 경우 &lt;code&gt;0600&lt;/code&gt; 입니다. 그룹이 읽을 수있는 클러스터의 경우 적절한 모드는 디렉토리의 경우 &lt;code&gt;0750&lt;/code&gt; 이고 파일의 경우 &lt;code&gt;0640&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="836bf1d98935001a9e7ffe81c54955b795aef94c" translate="yes" xml:space="preserve">
          <source>Note that even when this parameter is disabled, the system will launch autovacuum processes if necessary to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수가 사용 불가능한 경우에도 시스템은 트랜잭션 ID 랩 어라운드를 방지하기 위해 자동 진공 프로세스를 시작합니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f1ea5bec1703e5249cd8348fa7e3e07222422cf" translate="yes" xml:space="preserve">
          <source>Note that exclusion constraints are not supported as arbiters with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;. In all cases, only &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; constraints and unique indexes are supported as arbiters.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가있는 중재자로는 제외 제약 조건이 지원되지 않습니다 . 모든 경우에 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 제한 조건 및 고유 색인 만 중재자로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8de881cb4486af9a5996e8f814cf056ae7026e35" translate="yes" xml:space="preserve">
          <source>Note that for constraint triggers, evaluation of the &lt;code&gt;WHEN&lt;/code&gt; condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</source>
          <target state="translated">제한 조건 트리거의 경우 &lt;code&gt;WHEN&lt;/code&gt; 조건의 평가는 지연되지 않지만 행 업데이트 조작이 수행 된 직후에 수행됩니다. 조건이 true로 평가되지 않으면 지연된 실행을 위해 트리거가 대기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0be6e3fd01fb4ed50e92212c3560099998e4c687" translate="yes" xml:space="preserve">
          <source>Note that for historic reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; to convert between the two, for example &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation.</source>
          <target state="translated">역사적인 이유로 인해 &lt;code&gt;md5&lt;/code&gt; 함수는 16 진수로 인코딩 된 &lt;code&gt;text&lt;/code&gt; 유형의 값을 리턴하고 SHA-2 함수는 유형 &lt;code&gt;bytea&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;encode&lt;/code&gt; 및 &lt;code&gt;decode&lt;/code&gt; 기능을 사용하여 두 가지 사이를 변환하십시오 &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; 예 : encode (sha256 ( 'abc'), 'hex')) .</target>
        </trans-unit>
        <trans-unit id="cfe04c8846d33d71c984b2b6f7148e6d08053137" translate="yes" xml:space="preserve">
          <source>Note that foreign tables that use a foreign-data wrapper with no handler cannot be accessed.</source>
          <target state="translated">핸들러없이 외래 데이터 래퍼를 사용하는 외래 테이블에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5453a69c6ad7e7ddfed4130bdc5747df6c5fd62b" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server which the database can read and that those reads bypass all in-database privilege checks. This means that, among other things, a user with this access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is contained, as well as read any file in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">사용자에게 &lt;code&gt;pg_read_file()&lt;/code&gt; 또는 관련 함수 에 대한 EXECUTE 특권을 부여 하면 데이터베이스에서 읽을 수있는 서버의 모든 파일을 읽을 수 있고 모든 데이터베이스 내 특권 검사를 무시할 수 있습니다. 즉,이 액세스 권한을 가진 사용자는 인증 정보가 포함 된 &lt;code&gt;pg_authid&lt;/code&gt; 테이블 의 내용을 읽을 수있을 뿐만 아니라 데이터베이스의 모든 파일을 읽을 수 있습니다. 따라서 이러한 기능에 대한 액세스 권한 부여를 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd90b8fb5e3c2266322a8f9361a13beecb2d12fc" translate="yes" xml:space="preserve">
          <source>Note that here the &lt;code&gt;field&lt;/code&gt; parameter needs to be a string value, not a name. The valid field names for &lt;code&gt;date_part&lt;/code&gt; are the same as for &lt;code&gt;extract&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;field&lt;/code&gt; 매개 변수는 이름이 아닌 문자열 값이어야합니다. 유효한 필드 이름 &lt;code&gt;date_part&lt;/code&gt; 가 와 동일 &lt;code&gt;extract&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13c19c7fbcb3e2d4787b53bfa2ce9ac2e3e6f680" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;MINVALUE&lt;/code&gt; or &lt;code&gt;MAXVALUE&lt;/code&gt; is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; is not a valid bound; you should write &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt;.</source>
          <target state="translated">분할 경계의 한 열에 &lt;code&gt;MINVALUE&lt;/code&gt; 또는 &lt;code&gt;MAXVALUE&lt;/code&gt; 를 사용 하는 경우 모든 후속 열에 동일한 값을 사용해야합니다. 예를 들어, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; 은 유효한 범위가 아닙니다. &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt; 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba56c2e43467332103da0c13e1894f6a417084e8" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;FROM&lt;/code&gt; clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</source>
          <target state="translated">경우 참고 &lt;code&gt;FROM&lt;/code&gt; 절을 지정하지 쿼리는 데이터베이스 테이블을 참조 할 수 없습니다. 예를 들어 다음 쿼리는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90a3cd6b9233790897980d2c49eb8226596f6f8e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are specified, the &lt;code&gt;fields&lt;/code&gt; must include &lt;code&gt;SECOND&lt;/code&gt;, since the precision applies only to the seconds.</source>
          <target state="translated">두 경우 참고 &lt;code&gt;fields&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt; 지정의 &lt;code&gt;fields&lt;/code&gt; 포함해야 &lt;code&gt;SECOND&lt;/code&gt; 를 정밀도가 초 정보만을 적용하기 때문에.</target>
        </trans-unit>
        <trans-unit id="a560da48a0c3eebe2ee9e445e8f80b7a7c072449" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 표현식이 널 (null)을 생성하는 경우 &lt;code&gt;IN&lt;/code&gt; 구문 의 결과는 false가 아니라 null입니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0c5f4c3fbdd65353e1a71d55f99ee8748d4b0fa1" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true as one might naively expect. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 표현식이 널 (null)을 생성하는 경우, &lt;code&gt;NOT IN&lt;/code&gt; 구문 의 결과는 순진하게 기대할 수 있으므로 널이 아닙니다. . 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3770b570045d24672e81b92be3b78c98e0908b47" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 행이 널을 생성하는 경우 &lt;code&gt;IN&lt;/code&gt; 구문 의 결과는 거짓이 아니라 널이됩니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="95d9a10f36eb36219f7c3566abef0868c3a7a8f8" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 행이 널 (null)을 생성하는 경우 &lt;code&gt;NOT IN&lt;/code&gt; 구문 의 결과는 널이 아니고 참이 아닙니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b5695d0e24822e1a46463dd2f7c72886d58ca728" translate="yes" xml:space="preserve">
          <source>Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the &lt;code&gt;ANY&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">성공이없고 연산자 결과에 대해 하나 이상의 오른쪽 행이 널을 생성하는 경우 &lt;code&gt;ANY&lt;/code&gt; 구문 의 결과는 거짓이 아니라 널이됩니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f74d4f9409b75f18ec02eb7363768188eed257dd" translate="yes" xml:space="preserve">
          <source>Note that if you use this option currently, you probably also want the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as the &lt;code&gt;COPY FROM&lt;/code&gt; during restore does not support row security.</source>
          <target state="translated">현재이 옵션을 사용하는 경우 복원 중 &lt;code&gt;COPY FROM&lt;/code&gt; 이 행 보안을 지원하지 않으므로 덤프를 &lt;code&gt;INSERT&lt;/code&gt; 형식으로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76b5be5ae69de8a00f81a37774ba0bddbcd592c1" translate="yes" xml:space="preserve">
          <source>Note that in a standard-conforming string literal, &lt;code&gt;\&lt;/code&gt; just means &lt;code&gt;\&lt;/code&gt; anyway. This parameter only affects the handling of non-standard-conforming literals, including escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;).</source>
          <target state="translated">참고있는 표준 준수 문자열 리터럴에서, &lt;code&gt;\&lt;/code&gt; 단지 수단 &lt;code&gt;\&lt;/code&gt; 어쨌든. 이 매개 변수는 이스케이프 문자열 구문 ( &lt;code&gt;E'...'&lt;/code&gt; )을 포함하여 비표준 준수 리터럴의 처리에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="23bc72830133f60c02bed8bfbe946fd178dc8663" translate="yes" xml:space="preserve">
          <source>Note that in some macOS versions, &lt;em&gt;all five&lt;/em&gt; shared-memory parameters must be set in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, else the values will be ignored.</source>
          <target state="translated">일부 macOS 버전에서는 &lt;em&gt;5 개의&lt;/em&gt; 공유 메모리 매개 변수를 모두 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 설정해야 합니다. . 그렇지 않으면 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d63d2dbef5cb198e7018e15f160e61a7a98bae4" translate="yes" xml:space="preserve">
          <source>Note that in the latter case the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit &lt;code&gt;COLLATE&lt;/code&gt; clause will override the collations of all other arguments. (Attaching non-matching &lt;code&gt;COLLATE&lt;/code&gt; clauses to more than one argument, however, is an error. For more details see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) Thus, this gives the same result as the previous example:</source>
          <target state="translated">후자의 경우 &lt;code&gt;COLLATE&lt;/code&gt; 절은 우리가 영향을 줄 연산자의 입력 인수에 첨부됩니다. 연산자 또는 함수 에 의해 적용되는 데이터 정렬은 모든 인수를 고려하여 파생되므로 명시 적 &lt;code&gt;COLLATE&lt;/code&gt; 절은 다른 모든 데이터 정렬을 재정의 하므로 &lt;code&gt;COLLATE&lt;/code&gt; 절이 연결된 연산자 또는 함수 호출의 인수는 중요하지 않습니다. 인수. ( 그러나 일치하지 않는 &lt;code&gt;COLLATE&lt;/code&gt; 절을 둘 이상의 인수에 첨부하는 것은 오류입니다. 자세한 내용은 &lt;a href=&quot;collation&quot;&gt;23.2 절을&lt;/a&gt; 참조하십시오 .) 따라서 이전 예제와 동일한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a84d7bddb80d9016bd6c4bee8fb7ca51415943a4" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">이 모드에서 서버는 한 번에 하나의 파일 만 WAL을 적용하므로 대기 서버를 쿼리에 사용하는 경우 (핫 대기 참조) 마스터의 작업과 작업의 표시가 나타날 때 사이에 지연이 발생합니다. WAL 파일을 채우는 데 걸리는 시간에 해당합니다. &lt;code&gt;archive_timeout&lt;/code&gt; 을 사용하여 지연 시간을 줄일 수 있습니다. 또한 스트리밍 복제를이 방법과 결합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4405d800f3ae0d5fa272786ae62fc932fc40328" translate="yes" xml:space="preserve">
          <source>Note that in this syntax, &lt;code&gt;BINARY&lt;/code&gt; and &lt;code&gt;CSV&lt;/code&gt; are treated as independent keywords, not as arguments of a &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">이 구문에서 &lt;code&gt;BINARY&lt;/code&gt; 및 &lt;code&gt;CSV&lt;/code&gt; 는 &lt;code&gt;FORMAT&lt;/code&gt; 옵션의 인수가 아닌 독립 키워드로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="a52e8eceb78cffa4749cb6c0e0ac81c842683dee" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported by &lt;code&gt;postgres_fdw&lt;/code&gt; to prepare the remote transaction for two-phase commit.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재 2 단계 커밋을위한 원격 트랜잭션을 준비하는 것을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf276b552e113c8aa30767266df52ef9cf60275" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported for the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause of an &lt;code&gt;INSERT&lt;/code&gt; applied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.</source>
          <target state="translated">충돌하는 행의 파티션 키를 업데이트하여 행을 새 파티션으로 이동해야하는 경우 파티션 된 테이블에 적용된 &lt;code&gt;INSERT&lt;/code&gt; 의 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절이 현재 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1def70c0867779a85dc5cf9834ec9df5745ab872" translate="yes" xml:space="preserve">
          <source>Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the &lt;code&gt;WHERE&lt;/code&gt; clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a b-tree indexed column, it is left to the b-tree &lt;code&gt;amrescan&lt;/code&gt; function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during &lt;code&gt;amrescan&lt;/code&gt; will depend on the extent to which the index access method needs to reduce the scan keys to a &amp;ldquo;normalized&amp;rdquo; form.</source>
          <target state="translated">주어진 스캔 키를 모두 통과하는 모든 항목 만 올바르게 찾을 수 있도록하는 것은 전적으로 액세스 방법에 달려 있습니다. 또한 핵심 시스템은 의미 론적 분석없이 인덱스 키 및 연산자 패밀리와 일치하는 모든 &lt;code&gt;WHERE&lt;/code&gt; 절을 전달하여 모순인지 여부를 판별합니다. 예를 들어, &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 는 b- 트리 인덱싱 된 열인 경우)는 첫 번째 스캔 키가 중복되어 버릴 수 있음을 인식 하기 위해 b- 트리 &lt;code&gt;amrescan&lt;/code&gt; 기능으로 남겨 집니다. &lt;code&gt;amrescan&lt;/code&gt; 중 필요한 전처리 의 범위는 인덱스 액세스 방법이 스캔 키를 &quot;정규화 된&quot;형식으로 줄여야하는 정도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="873ebf4f2aa65167f1962a321c4caa0aa6923fed" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for an access method to implement only &lt;code&gt;amgetbitmap&lt;/code&gt; and not &lt;code&gt;amgettuple&lt;/code&gt;, or vice versa, if its internal implementation is unsuited to one API or the other.</source>
          <target state="translated">내부 구현이 한 API에 적합하지 않은 경우 액세스 메소드가 &lt;code&gt;amgetbitmap&lt;/code&gt; 만 구현 하고 &lt;code&gt;amgettuple&lt;/code&gt; 은 구현 하지 않으며 그 반대도 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0eac953a1d1c9a171b24393d7da1daab96fde8aa" translate="yes" xml:space="preserve">
          <source>Note that it is possible that pre-existing options of the foreign-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator. PostgreSQL does not check for this. It is up to the user to make sure that these options are correct before using the modified foreign-data wrapper. However, any options specified in this &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; command will be checked using the new validator.</source>
          <target state="translated">외부 유효성 검사기에 따라 외부 데이터 래퍼 또는 종속 서버, 사용자 매핑 또는 외부 테이블의 기존 옵션이 유효하지 않을 수 있습니다. PostgreSQL은이를 확인하지 않습니다. 수정 된 외부 데이터 래퍼를 사용하기 전에 이러한 옵션이 올바른지 확인하는 것은 사용자의 몫입니다. 그러나이 &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; 명령에 지정된 옵션 은 새 유효성 검증기를 사용하여 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="54f1f1ea0bfe92e9a92461b1d9eddd8c8bc5388c" translate="yes" xml:space="preserve">
          <source>Note that it is possible to create array values containing null values even when this variable is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 변수가 &lt;code&gt;off&lt;/code&gt; 있어도 널값을 포함하는 배열 값을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e482ec43ca141e91073df95564c36e7944046093" translate="yes" xml:space="preserve">
          <source>Note that it would not make much sense to test a non-schema-qualified type name in this way &amp;mdash; if the name can be recognized at all, it must be visible.</source>
          <target state="translated">이러한 방식으로 스키마에 한정되지 않은 형식 이름을 테스트하는 것은 의미가 없습니다. 이름을 전혀 인식 할 수 없으면 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1aef4a22f764ee40b1bcb8140980923ce0f949fc" translate="yes" xml:space="preserve">
          <source>Note that it's quite possible for two objects to be linked by more than one &lt;code&gt;pg_depend&lt;/code&gt; entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without &lt;code&gt;CASCADE&lt;/code&gt; if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied.</source>
          <target state="translated">두 개의 객체가 둘 이상의 &lt;code&gt;pg_depend&lt;/code&gt; 항목 으로 연결될 수 있습니다 . 예를 들어, 하위 파티션 된 인덱스는 연관된 파티션 테이블에 대한 파티션 유형 종속성과 색인을 생성하는 해당 테이블의 각 열에 대한 자동 종속성을 모두 갖습니다. 이러한 상황은 다중 종속성 시맨틱의 결합을 나타냅니다. 종속 항목 중 하나라도 자동 삭제 조건을 만족하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 없이 종속 오브젝트를 삭제할 수 있습니다 . 반대로, 어떤 오브젝트를 함께 삭제해야하는지에 대한 모든 종속성의 제한 사항이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a633bec827cd5945acb13add9ef3e8ab355704d" translate="yes" xml:space="preserve">
          <source>Note that late binding was the only behavior supported in PostgreSQL releases before 8.1, so you might need to do this to preserve the semantics of old applications.</source>
          <target state="translated">후기 바인딩은 8.1 이전의 PostgreSQL 릴리스에서 지원되는 유일한 동작이므로 이전 응용 프로그램의 의미를 유지하려면이 작업을 수행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f498abb4a796a1a75315ef84efac83b6642a42d1" translate="yes" xml:space="preserve">
          <source>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</source>
          <target state="translated">명시적인 사용자 이름이 지정되지 않은 경우 libpq는 SAM 호환 이름을 사용합니다. libpq 또는이를 기반으로하는 드라이버를 사용하는 경우이 옵션을 사용하지 않거나 연결 문자열에 사용자 이름을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="743714bf2d851c6ffde333b305cc76acb3b1f4e3" translate="yes" xml:space="preserve">
          <source>Note that loading a large number of rows using &lt;code&gt;COPY&lt;/code&gt; is almost always faster than using &lt;code&gt;INSERT&lt;/code&gt;, even if &lt;code&gt;PREPARE&lt;/code&gt; is used and multiple insertions are batched into a single transaction.</source>
          <target state="translated">&lt;code&gt;PREPARE&lt;/code&gt; 를 사용하고 여러 삽입을 단일 트랜잭션으로 일괄 처리 하더라도 &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 많은 수의 행을로드하는 것이 &lt;code&gt;INSERT&lt;/code&gt; 를 사용하는 것보다 거의 항상 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="42e8e431b9942cab90fba21d1a0369e9ad613d53" translate="yes" xml:space="preserve">
          <source>Note that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.</source>
          <target state="translated">로케일 이름은 운영 체제에 따라 다르므로 위의 명령이 모든 곳에서 동일한 방식으로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9b85d99902345f4af7308b01a61dc7702db748b" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">모든 SQL 명령이 상속 계층 구조에서 작동 할 수있는 것은 아닙니다. 데이터 조회, 데이터 수정 또는 스키마 수정에 사용되는 명령 (예 : &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 대부분 변형 , &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; 제외)은 일반적으로 자식 테이블을 포함하고 &lt;code&gt;ONLY&lt;/code&gt; 만 지원합니다. 제외하는 표기법. 데이터베이스 유지 관리 및 조정을 수행하는 명령 (예 : &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; )는 일반적으로 개별 물리적 테이블에서만 작동하며 상속 계층 구조에 대한 반복을 지원하지 않습니다. 각 개별 명령의 각 동작은 해당 참조 페이지에 설명되어 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL 명령&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5a5e9d67d623aca716181f6ec9cb80abc27268bb" translate="yes" xml:space="preserve">
          <source>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as:</source>
          <target state="translated">객체 키는 저장 순서대로 비교됩니다. 특히 키가 길수록 키가 짧을수록 키가 짧아 지므로 다음과 같은 직관적이지 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b32073b6d3e410922a70ee12709380a01c6753" translate="yes" xml:space="preserve">
          <source>Note that older clients might lack support for the SCRAM authentication mechanism, and hence not work with passwords encrypted with SCRAM-SHA-256. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for more details.</source>
          <target state="translated">이전 클라이언트는 SCRAM 인증 메커니즘을 지원하지 않을 수 있으므로 SCRAM-SHA-256으로 암호화 된 비밀번호로는 작동하지 않습니다. 자세한 내용 &lt;a href=&quot;auth-password&quot;&gt;은 20.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b3d09d3d6340576d5c998f6421491652b39ecd" translate="yes" xml:space="preserve">
          <source>Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.</source>
          <target state="translated">업데이트 트랜잭션 만 재 시도해야합니다. 읽기 전용 트랜잭션은 직렬화 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2954af76eca7ba35f68a0a8d801d4249462c8089" translate="yes" xml:space="preserve">
          <source>Note that ordering options apply only to the expression they follow; for example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; does not mean the same thing as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">순서 옵션은 다음 표현식에만 적용됩니다. 예를 들어 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 는 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 와 같은 의미가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b1c2c8127025345a934a6314a2f889673aacbd3b" translate="yes" xml:space="preserve">
          <source>Note that parallel queries may consume very substantially more resources than non-parallel queries, because each worker process is a completely separate process which has roughly the same impact on the system as an additional user session. This should be taken into account when choosing a value for this setting, as well as when configuring other settings that control resource utilization, such as &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;. Resource limits such as &lt;code&gt;work_mem&lt;/code&gt; are applied individually to each worker, which means the total utilization may be much higher across all processes than it would normally be for any single process. For example, a parallel query using 4 workers may use up to 5 times as much CPU time, memory, I/O bandwidth, and so forth as a query which uses no workers at all.</source>
          <target state="translated">각 작업자 프로세스는 별도의 프로세스이므로 추가 사용자 세션과 시스템에 거의 동일한 영향을 미치기 때문에 병렬 쿼리는 비 병렬 쿼리보다 훨씬 더 많은 리소스를 소비 할 수 있습니다. 이 설정의 값을 선택할 때뿐만 아니라 &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt; 과 같은 자원 활용을 제어하는 ​​다른 설정을 구성 할 때이 점을 고려해야 합니다. &lt;code&gt;work_mem&lt;/code&gt; 과 같은 자원 제한 은 각 작업자에게 개별적으로 적용됩니다. 즉, 전체 프로세스는 전체 프로세스에서 일반적으로 단일 프로세스보다 훨씬 더 높을 수 있습니다. 예를 들어 작업자 4 명을 사용하는 병렬 쿼리는 작업자를 전혀 사용하지 않는 쿼리로 최대 5 배 많은 CPU 시간, 메모리, I / O 대역폭 등을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d17cb56c53d9a14510ff412e2277014674b9c7" translate="yes" xml:space="preserve">
          <source>Note that parallel utility commands should not consume substantially more memory than equivalent non-parallel operations. This strategy differs from that of parallel query, where resource limits generally apply per worker process. Parallel utility commands treat the resource limit &lt;code&gt;maintenance_work_mem&lt;/code&gt; as a limit to be applied to the entire utility command, regardless of the number of parallel worker processes. However, parallel utility commands may still consume substantially more CPU resources and I/O bandwidth.</source>
          <target state="translated">병렬 유틸리티 명령은 동등한 비 병렬 작업보다 훨씬 더 많은 메모리를 소비해서는 안됩니다. 이 전략은 일반적으로 작업자 프로세스 당 리소스 제한이 적용되는 병렬 쿼리의 전략과 다릅니다. 병렬 유틸리티 명령은 자원 제한 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 을 병렬 작업자 프로세스 수에 관계없이 전체 유틸리티 명령에 적용되는 제한으로 취급합니다 . 그러나 병렬 유틸리티 명령은 여전히 ​​훨씬 더 많은 CPU 리소스와 I / O 대역폭을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c3896a4097aefd43e61d30f8ed6fc4608d53683" translate="yes" xml:space="preserve">
          <source>Note that partition pruning is driven only by the constraints defined implicitly by the partition keys, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</source>
          <target state="translated">파티션 프 루닝은 인덱스의 존재가 아니라 파티션 키에 의해 암시 적으로 정의 된 제한 조건에 의해서만 구동됩니다. 따라서 키 열에 인덱스를 정의 할 필요가 없습니다. 지정된 파티션에 대해 인덱스를 작성해야하는지 여부는 파티션을 스캔하는 쿼리가 일반적으로 파티션의 큰 부분 또는 작은 부분 만 스캔하는지 여부에 따라 다릅니다. 후자의 경우에는 색인이 도움이되지만 전자는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aed232352821561d7f4d97b0cbed4bb08fe3a2ef" translate="yes" xml:space="preserve">
          <source>Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster.</source>
          <target state="translated">역할은 데이터베이스 클러스터 수준에서 정의되므로 클러스터의 모든 데이터베이스에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="746fd0d5f2f710a9b186a9ef98779e17d15fa9db" translate="yes" xml:space="preserve">
          <source>Note that tablespace directories are not cleaned up either way.</source>
          <target state="translated">테이블 스페이스 디렉토리는 정리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1d5538437b8defc93f56eee03304e310c0c5042" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;actual time&amp;rdquo; values are in milliseconds of real time, whereas the &lt;code&gt;cost&lt;/code&gt; estimates are expressed in arbitrary units; so they are unlikely to match up. The thing that's usually most important to look for is whether the estimated row counts are reasonably close to reality. In this example the estimates were all dead-on, but that's quite unusual in practice.</source>
          <target state="translated">&quot;실제 시간&quot;값은 실시간으로 밀리 초 단위 인 반면 &lt;code&gt;cost&lt;/code&gt; 추정치는 임의의 단위로 표시됩니다. 그래서 일치하지 않을 것입니다. 일반적으로 가장 중요하게 생각되는 것은 예상 행 개수가 실제에 가까운 지 여부입니다. 이 예에서 추정치는 모두 망가졌지만 실제로는 이례적인 일입니다.</target>
        </trans-unit>
        <trans-unit id="9e220f4fc878ea43d3bad6e0a739b4b79c17d896" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;best match&amp;rdquo; rules are identical for operator and function type resolution. Some examples follow.</source>
          <target state="translated">&quot;최적 일치&quot;규칙은 연산자 및 기능 유형 확인에 동일합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="68a397047ec4388fcee29b79f7e608c05447ff76" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of these types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on) likewise compare areas for these types.</source>
          <target state="translated">&amp;ldquo;같은&amp;rdquo;연산자 &lt;code&gt;~=&lt;/code&gt; 는 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; 및 &lt;code&gt;circle&lt;/code&gt; 유형에 대한 평등 개념을 나타냅니다 . 이러한 유형 중 일부에는 &lt;code&gt;=&lt;/code&gt; 연산자가 있지만 &lt;code&gt;=&lt;/code&gt; 는 동일한 &lt;em&gt;영역에&lt;/em&gt; 대해서만 비교 합니다. 다른 스칼라 비교 연산자 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; 등)도 마찬가지로 이러한 유형의 영역을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3f9568498993be48d548609f8f99b58407bdc0b5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CHECK OPTION&lt;/code&gt; is only supported on views that are automatically updatable, and do not have &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers or &lt;code&gt;INSTEAD&lt;/code&gt; rules. If an automatically updatable view is defined on top of a base view that has &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers, then the &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; may be used to check the conditions on the automatically updatable view, but the conditions on the base view with &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has an &lt;code&gt;INSTEAD&lt;/code&gt; rule that causes the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the &lt;code&gt;INSTEAD&lt;/code&gt; rule.</source>
          <target state="translated">있습니다 &lt;code&gt;CHECK OPTION&lt;/code&gt; 에만 자동으로 업데이트 할 수있는 뷰에 지원되며,이없는 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 또는 &lt;code&gt;INSTEAD&lt;/code&gt; 은 규칙. &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 가있는 기본보기 위에 자동 업데이트 가능보기가 정의 된 경우 &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; 을 사용하여 자동 업데이트 가능보기의 조건을 확인할 수 있지만 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거가 있는 기본보기의 조건 은 그렇지 않습니다. 계단식 검사 옵션은 트리거 업데이트 가능 뷰까지 계단식으로 정렬되지 않으며 트리거 업데이트 가능 뷰에 직접 정의 된 모든 검사 옵션은 무시됩니다. 뷰 또는 기본 관계에 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙이있는 경우 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령을 다시 작성하면 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 과의 관계 위에 정의 된 자동 업데이트 가능한 뷰의 확인을 포함하여 모든 확인 옵션이 다시 작성된 쿼리에서 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="048b814d4fde306f95eb514ec96249604d0f3baf" translate="yes" xml:space="preserve">
          <source>Note that the checksum depends on the block number, so matching block numbers should be passed (except when doing esoteric debugging).</source>
          <target state="translated">체크섬은 블록 번호에 따라 다르므로 일치하는 블록 번호를 전달해야합니다 (난해한 디버깅을 수행하는 경우 제외).</target>
        </trans-unit>
        <trans-unit id="8c92d729af687d63d61faa7693bb18cfc4db6007" translate="yes" xml:space="preserve">
          <source>Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">명령은 쉘에 의해 호출되므로, 신뢰할 수없는 소스에서 온 쉘 명령에 인수를 전달해야하는 경우, 쉘에 특별한 의미를 가질 수있는 특수 문자를 제거하거나 이스케이프해야합니다. 보안상의 이유로 고정 명령 문자열을 사용하거나 사용자 입력을 전달하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95e2592cd121958603de591b16676dfd151d7385" translate="yes" xml:space="preserve">
          <source>Note that the effects of all per-row &lt;code&gt;BEFORE INSERT&lt;/code&gt; triggers are reflected in &lt;code&gt;excluded&lt;/code&gt; values, since those effects may have contributed to the row being excluded from insertion.</source>
          <target state="translated">모든 당 행의 효과 유의 &lt;code&gt;BEFORE INSERT&lt;/code&gt; 트리거가 반영된다 &lt;code&gt;excluded&lt;/code&gt; 그 효과가 행에 공헌 할 수 있기 때문에, 삽입 값으로부터 제외된다.</target>
        </trans-unit>
        <trans-unit id="e212873009117f62fcd9c668559d87771494a3ea" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field is meaningless. Also, on non-leaf pages, the first real data item (the first item that is not a high key) is a &amp;ldquo;minus infinity&amp;rdquo; item, with no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">가장 오른쪽이 아닌 페이지의 첫 번째 항목 ( &lt;code&gt;btpo_next&lt;/code&gt; 필드 에 0이 아닌 값을 가진 페이지)은 페이지의 &quot;높은 키&quot;입니다. 즉, 해당 &lt;code&gt;data&lt;/code&gt; 는 페이지에 나타나는 모든 항목의 상한으로 사용됩니다. 그 &lt;code&gt;ctid&lt;/code&gt; 필드는 의미가 없습니다. 또한 리프가 아닌 페이지에서 첫 번째 실제 데이터 항목 (높은 키가 아닌 첫 번째 항목)은 &lt;code&gt;data&lt;/code&gt; 필드 에 실제 값이없는 &quot;빼기 무한대&quot;항목 입니다. 그러나 이러한 항목은 해당 &lt;code&gt;ctid&lt;/code&gt; 필드 에 유효한 다운 링크가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="535954ca2908fbda93be1ed4d604a5a38ff7249d" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">다음 섹션에서는 내장 &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;테이블 액세스 방법&lt;/a&gt; 의 동작 과 내장 &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;인덱스 액세스 방법에&lt;/a&gt; 대해 설명합니다 . PostgreSQL의 확장 가능한 특성으로 인해 다른 액세스 방법이 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff99b02bab93b2bce6ccdae00e15d7def0f0061" translate="yes" xml:space="preserve">
          <source>Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated.</source>
          <target state="translated">서버의 로케일 동작은 클라이언트의 환경이 아니라 서버에서 볼 수있는 환경 변수에 의해 결정됩니다. 따라서 서버를 시작하기 전에 올바른 로케일 설정을 구성해야합니다. 그 결과 클라이언트와 서버가 서로 다른 로케일로 설정된 경우 메시지가 발생한 위치에 따라 다른 언어로 메시지가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d471153d0c31d19d3a687501b18f85b42ddbd4" translate="yes" xml:space="preserve">
          <source>Note that the only supported &lt;a href=&quot;auth-methods&quot;&gt;authentication methods&lt;/a&gt; for use with GSSAPI encryption are &lt;code&gt;gss&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, and &lt;code&gt;trust&lt;/code&gt;.</source>
          <target state="translated">GSSAPI 암호화에 사용 되는 지원되는 유일한 &lt;a href=&quot;auth-methods&quot;&gt;인증 방법&lt;/a&gt; 은 &lt;code&gt;gss&lt;/code&gt; , &lt;code&gt;reject&lt;/code&gt; 및 &lt;code&gt;trust&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1ad926ce9c3e21892b3792f7b8c1dbecab3b69d" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a &amp;ldquo;+&amp;rdquo; operator for some custom data type it will have the same precedence as the built-in &amp;ldquo;+&amp;rdquo; operator, no matter what yours does.</source>
          <target state="translated">연산자 우선 순위 규칙은 위에서 언급 한 내장 연산자와 이름이 같은 사용자 정의 연산자에도 적용됩니다. 예를 들어, 일부 사용자 정의 데이터 유형에 대해 &quot;+&quot;연산자를 정의하면 사용자의 작업에 관계없이 기본 제공 &quot;+&quot;연산자와 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8f86dee03c6b505a272324fb9a4a25b4a43909d" translate="yes" xml:space="preserve">
          <source>Note that the ordering options are considered independently for each sort column. For example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; means &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;, which is not the same as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">순서 옵션은 각 정렬 열에 대해 독립적으로 고려됩니다. 예를 들어 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 는 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 를 의미하며 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2d7f74d4ba0ae61a9bd9e94f45d68a74a955765" translate="yes" xml:space="preserve">
          <source>Note that the parser automatically understands that &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are of type &lt;code&gt;boolean&lt;/code&gt;, but this is not so for &lt;code&gt;NULL&lt;/code&gt; because that can have any type. So in some contexts you might have to cast &lt;code&gt;NULL&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt; explicitly, for example &lt;code&gt;NULL::boolean&lt;/code&gt;. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">구문 분석기는 &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 유형이 &lt;code&gt;boolean&lt;/code&gt; 유형 이라는 것을 자동으로 이해 하지만 모든 유형을 가질 수 있으므로 &lt;code&gt;NULL&lt;/code&gt; 에는 해당 되지 않습니다 . 따라서 일부 컨텍스트 에서는 &lt;code&gt;NULL::boolean&lt;/code&gt; 과 같이 명시 적으로 &lt;code&gt;NULL&lt;/code&gt; 을 &lt;code&gt;boolean&lt;/code&gt; 로 캐스트해야 할 수도 있습니다 . 반대로, 파서는 리터럴이 &lt;code&gt;boolean&lt;/code&gt; 유형이어야한다고 추론 할 수있는 컨텍스트에서 문자열 리터럴 부울 값에서 캐스트를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6830af538ea3d4def0017ebca2cb9eb811ef481a" translate="yes" xml:space="preserve">
          <source>Note that the password prompt will occur again for each database to be dumped. Usually, it's better to set up a &lt;code&gt;~/.pgpass&lt;/code&gt; file than to rely on manual password entry.</source>
          <target state="translated">각 데이터베이스를 덤프 할 때마다 비밀번호 프롬프트가 다시 나타납니다. 일반적 으로 수동 비밀번호 입력에 의존하는 것보다 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일 을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="42ada1c8e6a6026750e361cb5d7ba311ef045adc" translate="yes" xml:space="preserve">
          <source>Note that the query planner does not consider deferring the evaluation of parallel-restricted functions or aggregates involved in the query in order to obtain a superior plan. So, for example, if a &lt;code&gt;WHERE&lt;/code&gt; clause applied to a particular table is parallel restricted, the query planner will not consider performing a scan of that table in the parallel portion of a plan. In some cases, it would be possible (and perhaps even efficient) to include the scan of that table in the parallel portion of the query and defer the evaluation of the &lt;code&gt;WHERE&lt;/code&gt; clause so that it happens above the &lt;code&gt;Gather&lt;/code&gt; node. However, the planner does not do this.</source>
          <target state="translated">쿼리 계획자는 우수한 계획을 얻기 위해 쿼리에 포함 된 병렬 제한 함수 또는 집계의 평가 연기를 고려하지 않습니다. 예를 들어, 특정 테이블에 적용되는 &lt;code&gt;WHERE&lt;/code&gt; 절이 병렬 제한되는 경우 쿼리 플래너는 계획의 병렬 부분에서 해당 테이블의 스캔 수행을 고려하지 않습니다. 경우에 따라 쿼리의 병렬 부분에 해당 테이블의 스캔을 포함시키고 &lt;code&gt;WHERE&lt;/code&gt; 절의 평가를 연기 하여 &lt;code&gt;Gather&lt;/code&gt; 노드 위에서 발생할 수 있습니다. 그러나 플래너는이를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f4f575c0dfc110a613df4c8c43c09b6bc17afc4" translate="yes" xml:space="preserve">
          <source>Note that the single-user mode server does not provide sophisticated line-editing features (no command history, for example). Single-user mode also does not do any background processing, such as automatic checkpoints or replication.</source>
          <target state="translated">단일 사용자 모드 서버는 정교한 라인 편집 기능을 제공하지 않습니다 (예 : 명령 기록 없음). 단일 사용자 모드는 자동 검사 점 또는 복제와 같은 백그라운드 처리도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="542b405bccbd1dfc2248044e2da7018d901a07e8" translate="yes" xml:space="preserve">
          <source>Note that the unique key on this catalog is (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collencoding&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;) not just (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;). PostgreSQL generally ignores all collations that do not have &lt;code&gt;collencoding&lt;/code&gt; equal to either the current database's encoding or -1, and creation of new entries with the same name as an entry with &lt;code&gt;collencoding&lt;/code&gt; = -1 is forbidden. Therefore it is sufficient to use a qualified SQL name (&lt;code&gt;schema&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;) to identify a collation, even though this is not unique according to the catalog definition. The reason for defining the catalog this way is that initdb fills it in at cluster initialization time with entries for all locales available on the system, so it must be able to hold entries for all encodings that might ever be used in the cluster.</source>
          <target state="translated">참고이 카탈로그에 고유 키 (이다 &lt;code&gt;collname&lt;/code&gt; , &lt;code&gt;collencoding&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; )뿐만 아니라 ( &lt;code&gt;collname&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; ). PostgreSQL은 일반적으로 현재 데이터베이스의 인코딩 또는 -1과 같은 &lt;code&gt;collencoding&lt;/code&gt; 이없는 모든 데이터 정렬을 무시 하고 &lt;code&gt;collencoding&lt;/code&gt; = -1 인 항목과 동일한 이름의 새 항목을 만드는 것은 금지됩니다. 따라서 규정 된 SQL 이름 ( &lt;code&gt;schema&lt;/code&gt; . &lt;code&gt;name&lt;/code&gt; ) 을 사용하면 충분합니다 .)가 카탈로그 정의에 따라 고유하지 않더라도 데이터 정렬을 식별합니다. 이 방법으로 카탈로그를 정의하는 이유는 initdb가 클러스터 초기화시 카탈로그를 시스템에서 사용 가능한 모든 로케일의 항목으로 채우므로 클러스터에서 사용될 수있는 모든 인코딩의 항목을 보유 할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="57816233be3efc2c0b4b0cdc3b84a0dda807639d" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">보기에서 삽입, 업데이트 또는 삭제를 수행하는 사용자에게는보기에 대한 해당 삽입, 업데이트 또는 삭제 권한이 있어야합니다. 또한 뷰의 소유자는 기본 관계에 대한 관련 권한을 가져야하지만 업데이트를 수행하는 사용자는 기본 관계에 대한 권한이 필요하지 않습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;40.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f758ecc8993acb3505a10e1f0f3118a15da20e0" translate="yes" xml:space="preserve">
          <source>Note that the white space on each line is actually a tab character.</source>
          <target state="translated">각 줄의 공백은 실제로 탭 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f2961d22f06a0ed36b2caf77fbad086d6c0a84ff" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in an online backup from the standby:</source>
          <target state="translated">대기에서의 온라인 백업에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0151522b3b77d6456a32b223d7660f4475e688" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;CREATE ROUTINE&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;CREATE ROUTINE&lt;/code&gt; 명령 은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d66a79704a8f138a556c34b5e710e75580d121" translate="yes" xml:space="preserve">
          <source>Note that there needs to be at least one permissive policy to grant access to records before restrictive policies can be usefully used to reduce that access. If only restrictive policies exist, then no records will be accessible. When a mix of permissive and restrictive policies are present, a record is only accessible if at least one of the permissive policies passes, in addition to all the restrictive policies.</source>
          <target state="translated">제한적인 정책을 사용하여 해당 액세스를 줄이는 데 유용하기 전에 레코드에 대한 액세스 권한을 부여하려면 하나 이상의 허용 정책이 있어야합니다. 제한적인 정책 만 있으면 레코드에 액세스 할 수 없습니다. 허용 정책과 제한 정책이 혼합 된 경우 모든 제한 정책과 함께 하나 이상의 허용 정책이 통과하는 경우에만 레코드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b9e36ae86d5f4054bebe05afb0d0ec344eb9ad" translate="yes" xml:space="preserve">
          <source>Note that these potentially produce a lot of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, it might be worthwhile to consider mapping the tables separately instead, possibly even through a cursor.</source>
          <target state="translated">이것들은 잠재적으로 많은 양의 데이터를 생성하므로 메모리에 구축해야합니다. 큰 스키마 또는 데이터베이스의 컨텐츠 맵핑을 요청하는 경우 커서를 통해서도 테이블을 개별적으로 맵핑하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b8effb15698d614b121eab24d0dff7bc4e7c22a6" translate="yes" xml:space="preserve">
          <source>Note that this actually means &amp;ldquo;revoke all privileges that I granted&amp;rdquo;.</source>
          <target state="translated">이것은 실제로 &quot;내가 부여한 모든 권한을 취소합니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a377102624b4be7d75b74040aea8858a414e0fc7" translate="yes" xml:space="preserve">
          <source>Note that this behavior is consistent with other popular implementations of host name-based access control, such as the Apache HTTP Server and TCP Wrappers.</source>
          <target state="translated">이 동작은 Apache HTTP Server 및 TCP Wrappers와 같이 널리 사용되는 다른 호스트 이름 기반 액세스 제어 구현과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="765730fc2ec6d6848cd71e4c2044c699075b50df" translate="yes" xml:space="preserve">
          <source>Note that this command is subtly different from the server-side &lt;code&gt;lo_import&lt;/code&gt; because it acts as the local user on the local file system, rather than the server's user and file system.</source>
          <target state="translated">이 명령은 서버의 사용자 및 파일 시스템이 아닌 로컬 파일 시스템의 로컬 사용자 역할을하기 때문에 서버 측 &lt;code&gt;lo_import&lt;/code&gt; 와 미묘하게 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0f8fb90970b8968e4f7127f317566345b970df55" translate="yes" xml:space="preserve">
          <source>Note that this doesn't affect any existing rows in the table, it just changes the default for future &lt;code&gt;INSERT&lt;/code&gt; commands.</source>
          <target state="translated">이는 테이블의 기존 행에는 영향을 미치지 않으며 향후 &lt;code&gt;INSERT&lt;/code&gt; 명령 의 기본값 만 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="56e3b32d061c366fed83bd98f4d4590767c40034" translate="yes" xml:space="preserve">
          <source>Note that this is different from</source>
          <target state="translated">이것은 다음과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e5d1d4e065e9c7dc21ef91bf768d68d3c9d8a1d" translate="yes" xml:space="preserve">
          <source>Note that this is not the same as the left-to-right &amp;ldquo;short-circuiting&amp;rdquo; of Boolean operators that is found in some programming languages.</source>
          <target state="translated">이것은 일부 프로그래밍 언어에서 볼 수있는 부울 연산자의 왼쪽에서 오른쪽으로의 &quot;단락&quot;과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca51a28e46507688c57df1dccd9f468de8996aae" translate="yes" xml:space="preserve">
          <source>Note that this option currently also requires the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as &lt;code&gt;COPY FROM&lt;/code&gt; does not support row security.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 은 행 보안을 지원하지 않으므로이 옵션은 현재 덤프도 &lt;code&gt;INSERT&lt;/code&gt; 형식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ddb5224f9cf66b54a71c646c3cd12c1c98805d5f" translate="yes" xml:space="preserve">
          <source>Note that this option only affects the exact form &lt;code&gt;= NULL&lt;/code&gt;, not other comparison operators or other expressions that are computationally equivalent to some expression involving the equals operator (such as &lt;code&gt;IN&lt;/code&gt;). Thus, this option is not a general fix for bad programming.</source>
          <target state="translated">이 옵션은 정확한 형식 &lt;code&gt;= NULL&lt;/code&gt; 에만 영향을 미치며 다른 비교 연산자 나 등호 연산자를 포함하는 일부 표현식 (예 : &lt;code&gt;IN&lt;/code&gt; ) 과 계산적으로 동등한 다른 표현식 에는 영향을 주지 않습니다 . 따라서이 옵션은 잘못된 프로그래밍에 대한 일반적인 해결책이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e47f160f4c862fafa44c7f19b4f7d0d78fd15669" translate="yes" xml:space="preserve">
          <source>Note that this option will remain set for the entire session, and so it affects uses of the meta-command &lt;code&gt;\connect&lt;/code&gt; as well as the initial connection attempt.</source>
          <target state="translated">이 옵션은 전체 세션에 대해 설정된 상태로 유지되므로 초기 연결 시도와 메타 명령 &lt;code&gt;\connect&lt;/code&gt; 의 사용에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="9cb49d36842c28bbc6961c206fc6fb511f408fc8" translate="yes" xml:space="preserve">
          <source>Note that this query cannot use this index:</source>
          <target state="translated">이 쿼리는이 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eeb09f3d3f513d7242e768b40d1a3d7a48755d6c" translate="yes" xml:space="preserve">
          <source>Note that this setting only affects the main shared memory area. Operating systems such as Linux, FreeBSD, and Illumos can also use huge pages (also known as &amp;ldquo;super&amp;rdquo; pages or &amp;ldquo;large&amp;rdquo; pages) automatically for normal memory allocation, without an explicit request from PostgreSQL. On Linux, this is called &amp;ldquo;transparent huge pages&amp;rdquo; (THP). That feature has been known to cause performance degradation with PostgreSQL for some users on some Linux versions, so its use is currently discouraged (unlike explicit use of &lt;code&gt;huge_pages&lt;/code&gt;).</source>
          <target state="translated">이 설정은 기본 공유 메모리 영역에만 영향을 미칩니다. Linux, FreeBSD 및 Illumos와 같은 운영 체제는 PostgreSQL의 명시적인 요청없이 일반 메모리 할당을 위해 거대한 페이지 ( &quot;슈퍼&quot;페이지 또는 &quot;큰&quot;페이지라고도 함)를 자동으로 사용할 수도 있습니다. Linux에서는이를 &quot;투명 거대한 페이지&quot;(THP)라고합니다. 이 기능은 일부 Linux 버전의 일부 사용자에 대해 PostgreSQL에서 성능 저하를 유발하는 것으로 알려져 있으므로 현재는 사용하지 않는 것이 좋습니다 ( &lt;code&gt;huge_pages&lt;/code&gt; 를 명시 적으로 사용하는 것과는 달리 ).</target>
        </trans-unit>
        <trans-unit id="906c24642d7c9d1ccf94ab876f98cee1fa64d503" translate="yes" xml:space="preserve">
          <source>Note that this way the connection from &lt;code&gt;shell.foo.com&lt;/code&gt; to &lt;code&gt;db.foo.com&lt;/code&gt; will not be encrypted by the SSH tunnel. SSH offers quite a few configuration possibilities when the network is restricted in various ways. Please refer to the SSH documentation for details.</source>
          <target state="translated">이 방법 으로 &lt;code&gt;db.foo.com&lt;/code&gt; 에서 &lt;code&gt;shell.foo.com&lt;/code&gt; 으로의 연결 은 SSH 터널에 의해 암호화되지 않습니다. SSH는 네트워크가 다양한 방식으로 제한 될 때 상당히 많은 구성 가능성을 제공합니다. 자세한 내용은 SSH 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aed9a462aeaf6aae78a53a2e55aac5e3c16613ab" translate="yes" xml:space="preserve">
          <source>Note that this will result in locking all rows of &lt;code&gt;mytable&lt;/code&gt;, whereas &lt;code&gt;FOR UPDATE&lt;/code&gt; at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the &lt;code&gt;ORDER BY&lt;/code&gt; is combined with &lt;code&gt;LIMIT&lt;/code&gt; or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</source>
          <target state="translated">이렇게하면 &lt;code&gt;mytable&lt;/code&gt; 의 모든 행이 잠기는 반면 최상위 레벨의 &lt;code&gt;FOR UPDATE&lt;/code&gt; 는 실제로 리턴 된 행만 잠급니다. 이는 특히 &lt;code&gt;ORDER BY&lt;/code&gt; 가 &lt;code&gt;LIMIT&lt;/code&gt; 또는 기타 제한 사항 과 결합 된 경우 상당한 성능 차이를 만들 수 있습니다 . 따라서이 기법은 순서 열의 동시 업데이트가 예상되고 엄격하게 정렬 된 결과가 필요한 경우에만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="59d9533d6b1ff70587da7945ccc9db2ea583f449" translate="yes" xml:space="preserve">
          <source>Note that two rows are displayed for the same column, one corresponding to the complete inheritance hierarchy starting at the &lt;code&gt;road&lt;/code&gt; table (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;t&lt;/code&gt;), and another one including only the &lt;code&gt;road&lt;/code&gt; table itself (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;f&lt;/code&gt;).</source>
          <target state="translated">동일한 열에 대해 두 개의 행이 표시되는데, 하나는 &lt;code&gt;road&lt;/code&gt; 테이블 에서 시작하는 전체 상속 계층 구조 ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;t&lt;/code&gt; )와 다른 하나는 &lt;code&gt;road&lt;/code&gt; 테이블 자체 ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;f&lt;/code&gt; )를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="10e9b0e25eb4f44f89bb51356ad1df0c93761c8b" translate="yes" xml:space="preserve">
          <source>Note that unlike most catalogs with a &amp;ldquo;namespace&amp;rdquo; column, &lt;code&gt;extnamespace&lt;/code&gt; is not meant to imply that the extension belongs to that schema. Extension names are never schema-qualified. Rather, &lt;code&gt;extnamespace&lt;/code&gt; indicates the schema that contains most or all of the extension's objects. If &lt;code&gt;extrelocatable&lt;/code&gt; is true, then this schema must in fact contain all schema-qualifiable objects belonging to the extension.</source>
          <target state="translated">&amp;ldquo;네임 스페이스&amp;rdquo;열이있는 대부분의 카탈로그와 달리 &lt;code&gt;extnamespace&lt;/code&gt; 는 확장이 해당 스키마에 속한다는 것을 의미하지는 않습니다. 확장명은 스키마로 정규화되지 않습니다. 오히려 &lt;code&gt;extnamespace&lt;/code&gt; 는 확장 기능의 대부분 또는 전부를 포함하는 스키마를 나타냅니다. 경우 &lt;code&gt;extrelocatable&lt;/code&gt; 이 사실 다음 사실에서이 스키마해야 확장자에 속하는 모든 스키마 qualifiable 개체가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d30679c93680a49476e594a17f9119213eea89" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;code&gt;cube&lt;/code&gt;-based part of the module, units are hardwired here: changing the &lt;code&gt;earth()&lt;/code&gt; function will not affect the results of this operator.</source>
          <target state="translated">모듈 의 &lt;code&gt;cube&lt;/code&gt; 기반 부분 과 달리 단위는 여기에 고정되어 있습니다. &lt;code&gt;earth()&lt;/code&gt; 함수를 변경해도이 연산자의 결과에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec424e8783da60644af6ec05ea73b5e181a5ff9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;ldapscheme&lt;/code&gt; or &lt;code&gt;ldaptls&lt;/code&gt; only encrypts the traffic between the PostgreSQL server and the LDAP server. The connection between the PostgreSQL server and the PostgreSQL client will still be unencrypted unless SSL is used there as well.</source>
          <target state="translated">사용하여 &lt;code&gt;ldapscheme&lt;/code&gt; 또는 &lt;code&gt;ldaptls&lt;/code&gt; 하면 PostgreSQL 서버와 LDAP 서버 간의 트래픽 만 암호화됩니다. SSL을 사용하지 않으면 PostgreSQL 서버와 PostgreSQL 클라이언트 간의 연결은 여전히 ​​암호화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4e11f3a6327ed7b6ce66ef2d86de4e055bd13dd" translate="yes" xml:space="preserve">
          <source>Note that using this mode together with the &lt;code&gt;-f&lt;/code&gt; (&lt;code&gt;FULL&lt;/code&gt;) option might cause deadlock failures if certain system catalogs are processed in parallel.</source>
          <target state="translated">이 모드를 &lt;code&gt;-f&lt;/code&gt; 특정 시스템 카탈로그가 병렬로 처리되는 -f ( &lt;code&gt;FULL&lt;/code&gt; ) 옵션 하면 교착 상태 실패가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608b76c0c846a43652d18d27b367a743ac19721" translate="yes" xml:space="preserve">
          <source>Note that weight labels apply to &lt;em&gt;positions&lt;/em&gt;, not &lt;em&gt;lexemes&lt;/em&gt;. If the input vector has been stripped of positions then &lt;code&gt;setweight&lt;/code&gt; does nothing.</source>
          <target state="translated">무게 라벨은 &lt;em&gt;위치에&lt;/em&gt; 적용됩니다&lt;em&gt;&lt;/em&gt;&lt;em&gt; lexemes가&lt;/em&gt; 아닌 . 입력 벡터가 위치에서 제거 된 경우 &lt;code&gt;setweight&lt;/code&gt; 는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fb0133d2b01bcc98921dcbe4b4f3b20ca215976" translate="yes" xml:space="preserve">
          <source>Note that when an ACL entry in another catalog is null, it is taken to represent the hard-wired default privileges for its object, &lt;em&gt;not&lt;/em&gt; whatever might be in &lt;code&gt;pg_default_acl&lt;/code&gt; at the moment. &lt;code&gt;pg_default_acl&lt;/code&gt; is only consulted during object creation.</source>
          <target state="translated">다른 카탈로그의 ACL 항목이 null의 경우, 그 개체에 대한 하드 와이어 기본 권한을 표현하기 위해 촬영 한 것을 참고 &lt;em&gt;하지&lt;/em&gt; 뭐든에있을 수 있습니다 &lt;code&gt;pg_default_acl&lt;/code&gt; 현재 pg_default_acl 에있는 됩니다. &lt;code&gt;pg_default_acl&lt;/code&gt; 은 객체 생성 중에 만 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="2e6cf1460524f06f7b596e4f9001c12f09f21277" translate="yes" xml:space="preserve">
          <source>Note that when autovacuum runs, up to &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; times this memory may be allocated, so be careful not to set the default value too high. It may be useful to control for this by separately setting &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;.</source>
          <target state="translated">autovacuum이 실행될 때 최대 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;&lt;/a&gt; 때이 메모리가 autovacuum_max_workers 배 할당 될 수 있으므로 기본값을 너무 높게 설정하지 않도록주의하십시오. &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt; 을 별도로 설정하여이를 제어하는 ​​것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b298d8fd9d5a27445f1547b4987f220ddf522324" translate="yes" xml:space="preserve">
          <source>Note that when multiple rewrite rules are applied in this way, the order of application can be important; so in practice you will want the source query to &lt;code&gt;ORDER BY&lt;/code&gt; some ordering key.</source>
          <target state="translated">이러한 방식으로 여러 번의 다시 쓰기 규칙이 적용되는 경우 응용 순서가 중요 할 수 있습니다. 그래서 실제로 당신은 원본 쿼리를 원할 것입니다 &lt;code&gt;ORDER BY&lt;/code&gt; 일부 주문 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="15b117a19d6af07c7a1d926814d3fa7ed429f962" translate="yes" xml:space="preserve">
          <source>Note that when using nondefault WAL segment sizes, the numbers in the WAL file names are different from the LSNs that are reported by system functions and system views. This option takes a WAL file name, not an LSN.</source>
          <target state="translated">기본이 아닌 WAL 세그먼트 크기를 사용하는 경우 WAL 파일 이름의 숫자는 시스템 기능 및 시스템보기에 의해보고되는 LSN과 다릅니다. 이 옵션은 LSN이 아닌 WAL 파일 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5091d99db40796ae0ac6a127a75124d1c7974a77" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;COPY&lt;/code&gt; allows options such as &lt;code&gt;HEADER&lt;/code&gt; to be specified without a corresponding value, the foreign table option syntax requires a value to be present in all cases. To activate &lt;code&gt;COPY&lt;/code&gt; options typically written without a value, you can pass the value TRUE, since all such options are Booleans.</source>
          <target state="translated">동안 참고 &lt;code&gt;COPY&lt;/code&gt; 허용과 같은 옵션 &lt;code&gt;HEADER&lt;/code&gt; 해당 값없이 지정 될 수는 해외 테이블 옵션 구문은 모든 경우에 존재하는 값을 필요로한다. 일반적으로 값없이 작성된 &lt;code&gt;COPY&lt;/code&gt; 옵션 을 활성화하려면 모든 옵션이 부울이므로 TRUE 값을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e2ed64775c1454506227ebe10642431813ecd2" translate="yes" xml:space="preserve">
          <source>Note that while a table's filenode often matches its OID, this is &lt;em&gt;not&lt;/em&gt; necessarily the case; some operations, like &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;, can change the filenode while preserving the OID. Avoid assuming that filenode and table OID are the same. Also, for certain system catalogs including &lt;code&gt;pg_class&lt;/code&gt; itself, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt; contains zero. The actual filenode number of these catalogs is stored in a lower-level data structure, and can be obtained using the &lt;code&gt;pg_relation_filenode()&lt;/code&gt; function.</source>
          <target state="translated">테이블의 파일 노드가 종종 OID와 일치하지만 반드시 그런 것은 &lt;em&gt;아닙니다&lt;/em&gt; . &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; 및 일부 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식과 같은 일부 작업 은 OID를 유지하면서 파일 노드를 변경할 수 있습니다. 파일 노드와 테이블 OID가 동일하다고 가정하지 마십시오. 또한, 포함하여 특정 시스템 카탈로그에 대한 &lt;code&gt;pg_class&lt;/code&gt; 자체 &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relfilenode&lt;/code&gt; 는 0을 포함합니다. 이러한 카탈로그의 실제 파일 노드 수는 하위 레벨 데이터 구조에 저장되며 다음을 사용하여 얻을 수 있습니다. &lt;code&gt;pg_relation_filenode()&lt;/code&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="acd42ff3a7dd119700e6cb55e96c90dc5e6fd840" translate="yes" xml:space="preserve">
          <source>Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">행을 로컬 파티션에서 외부 테이블 파티션으로 이동할 수 있지만 (외래 데이터 랩퍼가 튜플 라우팅을 지원하는 경우) 외부 테이블 파티션에서 다른 파티션으로 이동할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d8be16bebefaea4da0b18cb12ca9511981a5205" translate="yes" xml:space="preserve">
          <source>Note that while the above will indeed grant all privileges if executed by a superuser or the owner of &lt;code&gt;kinds&lt;/code&gt;, when executed by someone else it will only grant those permissions for which the someone else has grant options.</source>
          <target state="translated">위의 내용은 실제로 수퍼 유저 또는 &lt;code&gt;kinds&lt;/code&gt; 의 소유자가 실행하는 경우 모든 권한을 부여하지만 다른 사람이 실행하는 경우 다른 사람이 권한을 부여한 권한 만 부여합니다.</target>
        </trans-unit>
        <trans-unit id="ec3a83831ac9036a3595c6ce5f5e7350a4e67363" translate="yes" xml:space="preserve">
          <source>Note that while this system allows creating collations that &amp;ldquo;ignore case&amp;rdquo; or &amp;ldquo;ignore accents&amp;rdquo; or similar (using the &lt;code&gt;ks&lt;/code&gt; key), in order for such collations to act in a truly case- or accent-insensitive manner, they also need to be declared as not &lt;em&gt;deterministic&lt;/em&gt; in &lt;code&gt;CREATE COLLATION&lt;/code&gt;; see &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Section 23.2.2.4&lt;/a&gt;. Otherwise, any strings that compare equal according to the collation but are not byte-wise equal will be sorted according to their byte values.</source>
          <target state="translated">이 시스템에서는 대소 문자를 무시하거나 악센트를 무시하거나 이와 유사한 데이터 정렬을 만들 수 있지만 ( &lt;code&gt;ks&lt;/code&gt; 키를 사용하여 ) 대 / 소문자를 구분하지 않는 방식으로 데이터 정렬을 수행 할 수 있어야합니다. &lt;code&gt;CREATE COLLATION&lt;/code&gt; 에서 &lt;em&gt;결정적&lt;/em&gt; 이지 않은 &lt;em&gt;것으로&lt;/em&gt; 선언되었습니다 . 보다&lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt; 섹션 23.2.2.4&lt;/a&gt; . 그렇지 않으면 데이터 정렬에 따라 동일하지만 바이트 단위가 아닌 문자열은 바이트 값에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="84595e2b092724cd7800c2af7679de35fbd01caf" translate="yes" xml:space="preserve">
          <source>Note that with any of these methods, attempting to prewarm more blocks than can be cached &amp;mdash; by the OS when using &lt;code&gt;prefetch&lt;/code&gt; or &lt;code&gt;read&lt;/code&gt;, or by PostgreSQL when using &lt;code&gt;buffer&lt;/code&gt; &amp;mdash; will likely result in lower-numbered blocks being evicted as higher numbered blocks are read in. Prewarmed data also enjoys no special protection from cache evictions, so it is possible that other system activity may evict the newly prewarmed blocks shortly after they are read; conversely, prewarming may also evict other data from cache. For these reasons, prewarming is typically most useful at startup, when caches are largely empty.</source>
          <target state="translated">이러한 방법 중 하나를 사용하면 &lt;code&gt;prefetch&lt;/code&gt; 또는 &lt;code&gt;read&lt;/code&gt; 를 사용할 때 OS 또는 &lt;code&gt;buffer&lt;/code&gt; 사용할 때 PostgreSQL에 의해 캐시 될 수있는 것보다 많은 블록을 사전 예열하려고 시도합니다. 번호가 높은 블록을 읽을 때 번호가 낮은 블록이 제거 될 수 있습니다. 사전 예열 된 데이터는 캐시 제거로부터 특별한 보호를받지 않으므로 다른 시스템 활동이 새로 사전 예열 된 블록을 읽은 직후에이를 제거 할 수 있습니다. 반대로 사전 예열은 다른 데이터를 캐시에서 제거 할 수도 있습니다. 이러한 이유로 프리 워밍은 일반적으로 캐시가 거의 비었을 때 시작시 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e25d9c4fc7da6af49acba3a1d74aecf78d61de9d" translate="yes" xml:space="preserve">
          <source>Note that you can name the collation objects in the SQL environment anything you want. In this example, we follow the naming style that the predefined collations use, which in turn also follow BCP 47, but that is not required for user-defined collations.</source>
          <target state="translated">SQL 환경에서 원하는대로 데이터 정렬 오브젝트의 이름을 지정할 수 있습니다. 이 예에서는 미리 정의 된 데이터 정렬이 사용하는 이름 지정 스타일을 따릅니다.이 데이터 정렬은 BCP 47도 따르지만 사용자 정의 데이터 정렬에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f6471c0f24b8d6760419402c171355a4484c03" translate="yes" xml:space="preserve">
          <source>Note that you must execute this command while logged into the PostgreSQL user account, which is described in the previous section.</source>
          <target state="translated">이전 섹션에서 설명한 PostgreSQL 사용자 계정에 로그인 한 상태에서이 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb0a6a455313edbad71a60b25303151964bacc15" translate="yes" xml:space="preserve">
          <source>Note that you should also create an index with the default operator class if you want queries involving ordinary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt; comparisons to use an index. Such queries cannot use the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes. (Ordinary equality comparisons can use these operator classes, however.) It is possible to create multiple indexes on the same column with different operator classes. If you do use the C locale, you do not need the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes, because an index with the default operator class is usable for pattern-matching queries in the C locale.</source>
          <target state="translated">일반 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 비교 와 관련된 쿼리가 인덱스를 사용하도록하려면 기본 연산자 클래스를 사용하여 인덱스를 만들어야합니다 . 이러한 쿼리는 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 연산자 클래스를 사용할 수 없습니다 . 그러나 평등 평등 비교에서는 이러한 연산자 클래스를 사용할 수 있습니다. 연산자 클래스가 다른 동일한 열에서 여러 인덱스를 만들 수 있습니다. C 로캘을 사용하는 경우 기본 연산자 클래스가있는 인덱스를 C 로캘의 패턴 일치 쿼리에 사용할 수 있으므로 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 연산자 클래스 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a9ac1561fc3ccdadc787e0b99a4aeb85f57a226f" translate="yes" xml:space="preserve">
          <source>Note that, for the purposes of combining multiple policies, &lt;code&gt;ALL&lt;/code&gt; policies are treated as having the same type as whichever other type of policy is being applied.</source>
          <target state="translated">여러 정책을 결합 할 목적으로 &lt;code&gt;ALL&lt;/code&gt; 정책은 적용되는 다른 유형의 정책과 동일한 유형을 갖는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce85a00735b68da34a1fd226cafeaa370c6ae8f" translate="yes" xml:space="preserve">
          <source>Note the relatively large number of false positives: 2439 rows were selected to be visited in the heap, but none actually matched the query. We could reduce that by specifying a larger signature length. In this example, creating the index with &lt;code&gt;length=200&lt;/code&gt; reduced the number of false positives to 55; but it doubled the index size (to 306 MB) and ended up being slower for this query (125 ms overall).</source>
          <target state="translated">상대적으로 많은 오 탐지 수에 유의하십시오. 힙에서 방문하도록 2439 개의 행이 선택되었지만 실제로는 쿼리와 일치하는 것이 없습니다. 더 큰 서명 길이를 지정하여이를 줄일 수 있습니다. 이 예에서 &lt;code&gt;length=200&lt;/code&gt; 인덱스를 만들면 오 탐지 수가 55로 줄었습니다. 그러나 인덱스 크기를 306MB로 두 배로 늘리고이 쿼리의 속도가 느려졌습니다 (전체 125ms).</target>
        </trans-unit>
        <trans-unit id="ad6486d9d7802af73d40de7a1e56de198a7926a1" translate="yes" xml:space="preserve">
          <source>Note the use of the double underline in the probe name. In a DTrace script using the probe, the double underline needs to be replaced with a hyphen, so &lt;code&gt;transaction-start&lt;/code&gt; is the name to document for users.</source>
          <target state="translated">프로브 이름에 이중 밑줄을 사용하십시오. 프로브를 사용하는 DTrace 스크립트에서 이중 밑줄은 하이픈으로 바꿔야하므로 &lt;code&gt;transaction-start&lt;/code&gt; 는 사용자를 위해 문서화 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6d65457512b308441a74c7c138c05193c57c7bb6" translate="yes" xml:space="preserve">
          <source>Note there can be ambiguity in the &lt;code&gt;months&lt;/code&gt; field returned by &lt;code&gt;age&lt;/code&gt; because different months have different numbers of days. PostgreSQL's approach uses the month from the earlier of the two dates when calculating partial months. For example, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; uses April to yield &lt;code&gt;1 mon 1 day&lt;/code&gt;, while using May would yield &lt;code&gt;1 mon 2 days&lt;/code&gt; because May has 31 days, while April has only 30.</source>
          <target state="translated">달마다 달 수가 다르기 때문에 &lt;code&gt;age&lt;/code&gt; 로 반환 된 &lt;code&gt;months&lt;/code&gt; 필드 에는 모호성이있을 수 있습니다 . PostgreSQL의 접근 방식은 부분 월을 계산할 때 두 날짜 중 초기의 월을 사용합니다. 예를 들어 &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; 는 April를 사용하여 &lt;code&gt;1 mon 1 day&lt;/code&gt; 을 생성 하는 반면 5 월을 사용하면 5 월은 31 일이되기 때문에 &lt;code&gt;1 mon 2 days&lt;/code&gt; 생성 하고 4 월은 30 일만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="1afbaf202c9ac2c26c7604e3bc2b4bbf35293589" translate="yes" xml:space="preserve">
          <source>Note, however, that the SQL/MED functionality as a whole is not yet conforming.</source>
          <target state="translated">그러나 SQL / MED 기능은 전체적으로 아직 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccd71e26f3c643a05b48c9814bdace2e62bf73fd" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ltxtquery&lt;/code&gt; allows whitespace between symbols, but &lt;code&gt;ltree&lt;/code&gt; and &lt;code&gt;lquery&lt;/code&gt; do not.</source>
          <target state="translated">참고 : &lt;code&gt;ltxtquery&lt;/code&gt; 는 심볼 사이의 공백을 허용하지만, &lt;code&gt;ltree&lt;/code&gt; 및 &lt;code&gt;lquery&lt;/code&gt; 은 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b12db1dd6e1d08b3916e0fb99c42096b024c7157" translate="yes" xml:space="preserve">
          <source>Note: This index type is lossy.</source>
          <target state="translated">참고 :이 색인 유형은 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windows 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="070bd4d20a16681cab0fd80e64bbfd09232b5422" translate="yes" xml:space="preserve">
          <source>Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after &lt;code&gt;SET&lt;/code&gt;, but we do need parentheses when referencing the same column in the expression to the right of the equal sign.</source>
          <target state="translated">여기서 &lt;code&gt;SET&lt;/code&gt; 바로 뒤에 나타나는 열 이름을 괄호로 묶을 필요는 없으며 실제로 등호 오른쪽의 표현식에서 같은 열을 참조 할 때는 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4daabf40dd7349fdbfe5f996ee7218e2e875bd85" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;AS&lt;/code&gt; clause is used to relabel the output column. (The &lt;code&gt;AS&lt;/code&gt; clause is optional.)</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 절을 사용하여 출력 열의 레이블을 다시 지정하는 방법에 주목하십시오 . 합니다 ( &lt;code&gt;AS&lt;/code&gt; 의 절은 선택 사항입니다.)</target>
        </trans-unit>
        <trans-unit id="faa7b0c69e4931a2ff5fa82ad77b7c14b3d74a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;NOT BETWEEN&lt;/code&gt; does the opposite comparison:</source>
          <target state="translated">것을 알 수 &lt;code&gt;BETWEEN&lt;/code&gt; 취급 엔드 포인트 값이 같은 범위에 포함되어 있습니다. &lt;code&gt;NOT BETWEEN&lt;/code&gt; 은 반대 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8240947764f6659f2796d4acf4007ac22ad3a1c1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;supernova star&lt;/code&gt; matches &lt;code&gt;supernovae stars&lt;/code&gt; in &lt;code&gt;thesaurus_astro&lt;/code&gt; because we specified the &lt;code&gt;english_stem&lt;/code&gt; stemmer in the thesaurus definition. The stemmer removed the &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;supernova star&lt;/code&gt; 경기는 &lt;code&gt;supernovae stars&lt;/code&gt; 에 &lt;code&gt;thesaurus_astro&lt;/code&gt; 우리가 지정했기 때문에 &lt;code&gt;english_stem&lt;/code&gt; 의 동의어 사전 정의 형태소 분석기를. 형태소 분석기는 &lt;code&gt;e&lt;/code&gt; 와 &lt;code&gt;s&lt;/code&gt; 를 제거했습니다 .</target>
        </trans-unit>
        <trans-unit id="89eb1ae6972d1166d8e27e8ffc5a4983fca12820" translate="yes" xml:space="preserve">
          <source>Notice that although the recursive view's name is schema-qualified in this &lt;code&gt;CREATE&lt;/code&gt;, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.</source>
          <target state="translated">이 &lt;code&gt;CREATE&lt;/code&gt; 에서는 재귀 뷰의 이름이 스키마로 규정되어 있지만 내부 자체 참조는 스키마로 규정되지 않습니다. 내재적으로 작성된 CTE의 이름을 스키마로 규정 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c36fb1e9faaa2ef2c027bbd666eb850c4abbeb31" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples.</source>
          <target state="translated">&lt;code&gt;enum_range&lt;/code&gt; 의 두 인수 형식을 제외 하고 이러한 함수는 전달 된 특정 값을 무시합니다. 선언 된 데이터 유형에만 관심이 있습니다. 동일한 결과로 null 또는 특정 유형의 값을 전달할 수 있습니다. 예제에서 제안한대로 하드 와이어 유형 이름보다는 테이블 열 또는 함수 인수에 이러한 함수를 적용하는 것이 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="3f7db9efeeec80f82f8d01c7d6c915db40d7ca58" translate="yes" xml:space="preserve">
          <source>Notice that here the planner has chosen to &amp;ldquo;materialize&amp;rdquo; the inner relation of the join, by putting a Materialize plan node atop it. This means that the &lt;code&gt;t2&lt;/code&gt; index scan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</source>
          <target state="translated">여기서 플래너는 구체화 계획 노드를 배치하여 결합의 내부 관계를 &quot;구체화&quot;하도록 선택했습니다. 즉 , 중첩 루프 조인 노드가 외부 관계에서 각 행에 대해 한 번씩 해당 데이터를 10 번 읽어야하더라도 &lt;code&gt;t2&lt;/code&gt; 인덱스 스캔은 한 번만 수행됩니다. Materialise 노드는 읽은대로 데이터를 메모리에 저장 한 다음 이후의 각 패스에서 메모리에서 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bf689adc2caa48f04b5854bba37632c664406c0" translate="yes" xml:space="preserve">
          <source>Notice that in both &lt;code&gt;ROWS&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; mode, &lt;code&gt;0 PRECEDING&lt;/code&gt; and &lt;code&gt;0 FOLLOWING&lt;/code&gt; are equivalent to &lt;code&gt;CURRENT ROW&lt;/code&gt;. This normally holds in &lt;code&gt;RANGE&lt;/code&gt; mode as well, for an appropriate data-type-specific meaning of &amp;ldquo;zero&amp;rdquo;.</source>
          <target state="translated">공지 사항은 모두 것을 &lt;code&gt;ROWS&lt;/code&gt; 와 &lt;code&gt;GROUPS&lt;/code&gt; 모드, &lt;code&gt;0 PRECEDING&lt;/code&gt; 와 &lt;code&gt;0 FOLLOWING&lt;/code&gt; 에 해당합니다 &lt;code&gt;CURRENT ROW&lt;/code&gt; . 이것은 일반적으로 &amp;ldquo;제로&amp;rdquo;라는 적절한 데이터 유형별 의미를 위해 &lt;code&gt;RANGE&lt;/code&gt; 모드에서도 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="944ef29330d1f49189c08507e0ff3ef14adbfe93" translate="yes" xml:space="preserve">
          <source>Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.</source>
          <target state="translated">달러 인용 문자열 내에서 이스케이프하지 않고 작은 따옴표를 사용할 수 있습니다. 실제로, 달러 인용 문자열 내부의 문자는 이스케이프 처리되지 않습니다. 문자열 내용은 항상 문자 그대로 작성됩니다. 백 슬래시는 특수하지 않으며 시작 태그와 일치하는 시퀀스의 일부가 아닌 한 달러 기호도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f68a4013d1520908a834c3452585e4c0680f0866" translate="yes" xml:space="preserve">
          <source>Notice that placing the restriction in the &lt;code&gt;WHERE&lt;/code&gt; clause produces a different result:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절에 제한을두면 다른 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d13f7a26b5cfa0ec363a717ba07bad2b152f0f72" translate="yes" xml:space="preserve">
          <source>Notice that the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; is used. Only text search functions that specify a configuration name can be used in expression indexes (&lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;). This is because the index contents must be unaffected by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;. If they were affected, the index contents might be inconsistent because different entries could contain &lt;code&gt;tsvector&lt;/code&gt;s that were created with different text search configurations, and there would be no way to guess which was which. It would be impossible to dump and restore such an index correctly.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 의 2 인수 버전 이 사용됩니다. 구성 이름을 지정하는 텍스트 검색 기능 만 표현식 색인에 사용할 수 있습니다 ( &lt;a href=&quot;indexes-expressional&quot;&gt;11.7 절&lt;/a&gt; ). 인덱스 내용은 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config의&lt;/a&gt; 영향을받지 않아야하기 때문 입니다. 영향을받는 경우, 다른 항목이 다른 텍스트 검색 구성으로 작성된 &lt;code&gt;tsvector&lt;/code&gt; 를 포함 할 수 있고 어떤 항목을 추측 할 방법이 없기 때문에 색인 내용이 일치하지 않을 수 있습니다 . 그러한 인덱스를 올바르게 덤프 및 복원하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4b9c07bbe048665c89925c842ae22cd1fc6040f9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;DROP&lt;/code&gt; syntax only specifies the &amp;ldquo;slot&amp;rdquo; in the operator family, by strategy or support number and input data type(s). The name of the operator or function occupying the slot is not mentioned. Also, for &lt;code&gt;DROP FUNCTION&lt;/code&gt; the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function.</source>
          <target state="translated">알 &lt;code&gt;DROP&lt;/code&gt; 의 문법 만 전략 또는 지원 번호 입력 데이터 타입 (들)에 의해, 오퍼레이터 가족의 &quot;슬롯&quot;을 지정한다. 슬롯을 점유하는 오퍼레이터 또는 기능의 이름은 언급되지 않았습니다. 또한 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 의 경우 지정할 유형은 입력 데이터 유형이며, 함수가 지원하도록되어 있습니다. GiST, SP-GiST 및 GIN 인덱스의 경우 이는 함수의 실제 입력 인수 유형과 관련이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051e5841933239126fb981b1dfd93c63aee12913" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;EXPLAIN&lt;/code&gt; output shows the &lt;code&gt;WHERE&lt;/code&gt; clause being applied as a &amp;ldquo;filter&amp;rdquo; condition attached to the Seq Scan plan node. This means that the plan node checks the condition for each row it scans, and outputs only the ones that pass the condition. The estimate of output rows has been reduced because of the &lt;code&gt;WHERE&lt;/code&gt; clause. However, the scan will still have to visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;, to be exact) to reflect the extra CPU time spent checking the &lt;code&gt;WHERE&lt;/code&gt; condition.</source>
          <target state="translated">주목하라 그 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 프로그램을 &lt;code&gt;WHERE&lt;/code&gt; 절은 서열 검사 계획 노드에 부착 된 &quot;필터&quot;상태로 적용된다. 이는 계획 노드가 스캔하는 각 행의 조건을 확인하고 조건을 통과 한 행만 출력 함을 의미합니다. &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 출력 행의 추정치가 줄었습니다 . 그러나 스캔은 여전히 ​​10000 행을 모두 방문해야하므로 비용이 줄어들지 않았습니다. 실제로 &lt;code&gt;WHERE&lt;/code&gt; 조건 을 확인하는 데 소비되는 추가 CPU 시간을 반영하기 위해 비트가 약간 증가했습니다 ( 정확히 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d34da680054f05253f7563479166aab9f149ee00" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;WITH&lt;/code&gt; query was evaluated only once, so that we got two sets of the same three random values.</source>
          <target state="translated">것을 알 수 &lt;code&gt;WITH&lt;/code&gt; 의 쿼리가 우리가 같은 세 가지 임의의 값의 두 세트를 가지고 그래서, 한 번만 평가 하였다.</target>
        </trans-unit>
        <trans-unit id="51724582644bab73340aa6c622d37155c5257732" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;picksplit&lt;/code&gt; function's result is delivered by modifying the passed-in &lt;code&gt;v&lt;/code&gt; structure. The return value per se is ignored, though it's conventional to pass back the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">전달 된 &lt;code&gt;v&lt;/code&gt; 구조를 수정 하면 &lt;code&gt;picksplit&lt;/code&gt; 함수의 결과가 전달됩니다 . &lt;code&gt;v&lt;/code&gt; 의 주소를 다시 전달하는 것이 일반적이지만 반환 값 자체는 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf156003e881a5db213ca4ff342d316a104a89cc" translate="yes" xml:space="preserve">
          <source>Notice that the above commands specify copying the &lt;code&gt;template0&lt;/code&gt; database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">위의 명령은 &lt;code&gt;template0&lt;/code&gt; 데이터베이스 복사를 지정 합니다. 다른 데이터베이스를 복사 할 때 인코딩 및 로케일 설정을 소스 데이터베이스의 설정 및 로케일 설정에서 변경할 수 없습니다. 데이터가 손상 될 수 있습니다. 자세한 정보는 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;섹션 22.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8cdb89e02698866354e5dd11605d6eb9295c222" translate="yes" xml:space="preserve">
          <source>Notice that the array elements are ordinary SQL constants or expressions; for instance, string literals are single quoted, instead of double quoted as they would be in an array literal. The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;.</source>
          <target state="translated">배열 요소는 일반적인 SQL 상수 또는 표현식입니다. 예를 들어, 문자열 리터럴은 배열 리터럴에서와 같이 큰 따옴표 대신 작은 따옴표로 묶습니다. &lt;code&gt;ARRAY&lt;/code&gt; 의 생성자의 구문에서보다 상세히 논의된다 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;섹션 4.2.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66469b4e59f919ba275ed4a6fda1a4c5c23cd621" translate="yes" xml:space="preserve">
          <source>Notice that the individual subcommands do not end with semicolons.</source>
          <target state="translated">개별 부속 명령은 세미콜론으로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3160def781e659e6cdc752185f9870b36c8a345f" translate="yes" xml:space="preserve">
          <source>Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches.</source>
          <target state="translated">비트 맵 인덱스 스캔에서 리턴 된 것으로 추정되는 행 수는 인덱스와 함께 사용 된 조건 만 반영합니다. 이는 후속 힙 페치에 대한 비용 추정에 영향을주기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="873a445a12a2fae4f43b1f16da917ba94ef395cb" translate="yes" xml:space="preserve">
          <source>Notice that the owner's implicit grant options are not marked in the access privileges display. A &lt;code&gt;*&lt;/code&gt; will appear only when grant options have been explicitly granted to someone.</source>
          <target state="translated">소유자의 암시 적 부여 옵션은 액세스 권한 표시에 표시되지 않습니다. &lt;code&gt;*&lt;/code&gt; 는 그랜트 옵션이 명시 적으로 누군가에게 부여 된 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bf407e6deb6991a0a95054bdc8f3340e9ff64b36" translate="yes" xml:space="preserve">
          <source>Notice that the period (&lt;code&gt;.&lt;/code&gt;) is not a metacharacter for &lt;code&gt;SIMILAR TO&lt;/code&gt;.</source>
          <target state="translated">마침표 ( &lt;code&gt;.&lt;/code&gt; )는 &lt;code&gt;SIMILAR TO&lt;/code&gt; 의 메타 문자가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="74768806db56cf6b766037079dc057b3f23de85a" translate="yes" xml:space="preserve">
          <source>Notice that the primary key overlaps with the foreign keys in the last table.</source>
          <target state="translated">기본 키는 마지막 테이블의 외래 키와 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="8e2f5e5785b45b8d6d5aee74a3bd7e8d7b7e0944" translate="yes" xml:space="preserve">
          <source>Notice that this example defines the &lt;code&gt;page_count&lt;/code&gt; result column as an integer. The function deals internally with string representations, so when you say you want an integer in the output, it will take the string representation of the XPath result and use PostgreSQL input functions to transform it into an integer (or whatever type the &lt;code&gt;AS&lt;/code&gt; clause requests). An error will result if it can't do this &amp;mdash; for example if the result is empty &amp;mdash; so you may wish to just stick to &lt;code&gt;text&lt;/code&gt; as the column type if you think your data has any problems.</source>
          <target state="translated">이 예제는 &lt;code&gt;page_count&lt;/code&gt; 결과 열을 정수로 정의합니다 . 이 함수는 내부적으로 문자열 표현을 처리하므로 출력에서 ​​정수를 원할 때 XPath 결과의 문자열 표현을 가져 와서 PostgreSQL 입력 함수를 사용하여 정수로 변환합니다 (또는 &lt;code&gt;AS&lt;/code&gt; 절이 요청 하는 모든 유형 ). . 이 작업을 수행 할 수없는 경우 (예 : 결과가 비어있는 경우) 오류가 발생하므로 데이터에 문제가 있다고 생각되면 &lt;code&gt;text&lt;/code&gt; 를 열 유형으로 고수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9217ccd836ba1fba783902d277384da15bf50d" translate="yes" xml:space="preserve">
          <source>Notice that we showed &lt;code&gt;inner_cardinality&lt;/code&gt; as 10000, that is, the unmodified size of &lt;code&gt;tenk2&lt;/code&gt;. It might appear from inspection of the &lt;code&gt;EXPLAIN&lt;/code&gt; output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on &lt;code&gt;tenk2&lt;/code&gt;. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to round-off error and other factors they sometimes diverge significantly.</source>
          <target state="translated">공지 사항 우리는 보여 주었다 &lt;code&gt;inner_cardinality&lt;/code&gt; 을 ,의 수정되지 않은 크기입니다, 10000로 &lt;code&gt;tenk2&lt;/code&gt; . (가)의이 검사에서 나타날 수 &lt;code&gt;EXPLAIN&lt;/code&gt; 행 가입의 추정치는 50 * (1)로부터 오는 출력 즉, 외부 행 횟수 각 내부 인덱스 스캔에 의해 얻어진 예상 행 번호 &lt;code&gt;tenk2&lt;/code&gt; . 그러나 이것은 사실이 아닙니다. 결합 관계의 크기는 특정 결합 계획이 고려되기 전에 추정됩니다. 모든 것이 잘 작동하면 결합 크기를 추정하는 두 가지 방법으로 거의 같은 대답을 얻을 수 있지만 반올림 오류 및 기타 요인으로 인해 때로는 크게 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="159dfc60dcca0632285615def5fab2a023373a94" translate="yes" xml:space="preserve">
          <source>Notice that while the plain (unaggregated) log file shows which script was used for each transaction, the aggregated log does not. Therefore if you need per-script data, you need to aggregate the data on your own.</source>
          <target state="translated">일반 (집계되지 않은) 로그 파일에는 각 트랜잭션에 사용 된 스크립트가 표시되지만 집계 된 로그는 표시되지 않습니다. 따라서 스크립트 별 데이터가 필요한 경우 자체적으로 데이터를 집계해야합니다.</target>
        </trans-unit>
        <trans-unit id="99369cd02fa72e17001071790856a797298fed53" translate="yes" xml:space="preserve">
          <source>Notice the typical form of recursive queries: an initial condition, followed by &lt;code&gt;UNION&lt;/code&gt;, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for more examples.)</source>
          <target state="translated">재귀 쿼리의 일반적인 형식 인 초기 조건, &lt;code&gt;UNION&lt;/code&gt; , 쿼리의 재귀 부분을 확인하십시오. 쿼리의 재귀 부분이 결국 튜플을 반환하지 않으면 쿼리가 무한 반복됩니다. ( 더 많은 예제는 &lt;a href=&quot;queries-with&quot;&gt;7.8 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="085506905d3dc520376505271fd3c45af0c829eb" translate="yes" xml:space="preserve">
          <source>Notice we don't use &lt;code&gt;-C&lt;/code&gt;, and instead connect directly to the database to be restored into. Also note that we clone the new database from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, to ensure it is initially empty.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; 를 사용하지 않고 대신 복원 할 데이터베이스에 직접 연결하십시오. 또한 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 새 데이터베이스를 복제하여 처음에 비어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bb9bfefd5391f52be54267e2a938a126661b0ff7" translate="yes" xml:space="preserve">
          <source>Nov</source>
          <target state="translated">Nov</target>
        </trans-unit>
        <trans-unit id="3c5bf776f5efcaa22d6e0fd4839db7d2b83e52be" translate="yes" xml:space="preserve">
          <source>November</source>
          <target state="translated">November</target>
        </trans-unit>
        <trans-unit id="0ffcf97fe0b617e1a1fb0f97e1a88d84bed8f352" translate="yes" xml:space="preserve">
          <source>Now consider the same query, but with a constant that is not in the MCV list:</source>
          <target state="translated">이제 동일한 쿼리를 고려하지만 MCV 목록에없는 상수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1101583b5cab5dfe73a02721963b60a84711fcd9" translate="yes" xml:space="preserve">
          <source>Now it is impossible to create orders with non-NULL &lt;code&gt;product_no&lt;/code&gt; entries that do not appear in the products table.</source>
          <target state="translated">이제 제품 테이블에 나타나지 않는 NULL이 아닌 &lt;code&gt;product_no&lt;/code&gt; 항목으로 주문을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05189fbbab4b515fc19f955242b1b42d3dc53c9c" translate="yes" xml:space="preserve">
          <source>Now it is possible to bind the thesaurus dictionary &lt;code&gt;thesaurus_simple&lt;/code&gt; to the desired token types in a configuration, for example:</source>
          <target state="translated">이제 동의어 사전 &lt;code&gt;thesaurus_simple&lt;/code&gt; 동의어 사전 을 구성에서 원하는 토큰 유형에 바인딩 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b6efa33e8cde1d203d7549fcab8edf43d173c9" translate="yes" xml:space="preserve">
          <source>Now it is possible to create a foreign table with &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. In this example we wish to access the table named &lt;code&gt;some_schema.some_table&lt;/code&gt; on the remote server. The local name for it will be &lt;code&gt;foreign_table&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 을 사용하여 외래 테이블을 만들 수 있습니다 . 이 예에서는 원격 서버의 &lt;code&gt;some_schema.some_table&lt;/code&gt; 테이블에 액세스하려고 합니다. 로컬 이름은 &lt;code&gt;foreign_table&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="dd96a87b36842da43e36de2200fdfc1838f0e684" translate="yes" xml:space="preserve">
          <source>Now let's add another condition to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절에 다른 조건을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="95432c22f405504df2d81a0fb2d4efc9ca2560c4" translate="yes" xml:space="preserve">
          <source>Now let's consider a case with more than one condition in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절 에 하나 이상의 조건이있는 경우를 생각해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="f0a0a72cb219eba72676d0750f57b70ee142cf22" translate="yes" xml:space="preserve">
          <source>Now let's modify the query to add a &lt;code&gt;WHERE&lt;/code&gt; condition:</source>
          <target state="translated">이제 쿼리를 수정하여 &lt;code&gt;WHERE&lt;/code&gt; 조건 을 추가하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="47c1122f650e2dbfda8bc7f189317df3657e8635" translate="yes" xml:space="preserve">
          <source>Now look at the table definition again:</source>
          <target state="translated">이제 테이블 정의를 다시 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="d6a6836d17a53567c7bdd65d95a74e120c1311f5" translate="yes" xml:space="preserve">
          <source>Now suppose that &lt;code&gt;alice&lt;/code&gt; wishes to change the &amp;ldquo;slightly secret&amp;rdquo; information, but decides that &lt;code&gt;mallory&lt;/code&gt; should not be trusted with the new content of that row, so she does:</source>
          <target state="translated">이제 가정 &lt;code&gt;alice&lt;/code&gt; 은 &quot;약간 비밀&quot;정보를 변경하고자하지만, 그 결정 &lt;code&gt;mallory&lt;/code&gt; 그녀가 있으므로, 해당 행의 새로운 내용으로 신뢰해서는 안된다 :</target>
        </trans-unit>
        <trans-unit id="9c4ea909bc20a14cf1d5201600f80228a4642b36" translate="yes" xml:space="preserve">
          <source>Now the parenthesized object is correctly interpreted as a reference to the &lt;code&gt;item&lt;/code&gt; column, and then the subfield can be selected from it.</source>
          <target state="translated">이제 괄호로 묶은 객체가 &lt;code&gt;item&lt;/code&gt; 열에 대한 참조로 올바르게 해석 된 후 서브 필드를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deae757ce21f92bbc32823a914fbc837ca56a164" translate="yes" xml:space="preserve">
          <source>Now this is fine for PostgreSQL-specific applications, but standard code using JDBC or ODBC won't delete the objects, resulting in orphan objects &amp;mdash; objects that are not referenced by anything, and simply occupy disk space.</source>
          <target state="translated">이제 이것은 PostgreSQL 특정 응용 프로그램에는 적합하지만 JDBC 또는 ODBC를 사용하는 표준 코드는 객체를 삭제하지 않으므로 고아 객체 (어떤 것이 참조하지 않는 객체)를 생성하고 단순히 디스크 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="084bd00ac798eb5161b956e1962a53497a37531c" translate="yes" xml:space="preserve">
          <source>Now try inserting an invalid record:</source>
          <target state="translated">이제 잘못된 레코드를 삽입하십시오 :</target>
        </trans-unit>
        <trans-unit id="5458bef284659cf16721d439d4b767332bf554fc" translate="yes" xml:space="preserve">
          <source>Now we are ready to perform a fast full text search:</source>
          <target state="translated">이제 빠른 전체 텍스트 검색을 수행 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a02f5ffaa75cbfc6c6328ab3a75ec757069f839c" translate="yes" xml:space="preserve">
          <source>Now we can see how it works. &lt;code&gt;ts_lexize&lt;/code&gt; is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;to_tsvector&lt;/code&gt; which will break their input strings into multiple tokens:</source>
          <target state="translated">이제 어떻게 작동하는지 볼 수 있습니다. &lt;code&gt;ts_lexize&lt;/code&gt; 는 입력을 단일 토큰으로 취급하기 때문에 동의어 사전을 테스트하는 데별로 유용하지 않습니다. 대신 &lt;code&gt;plainto_tsquery&lt;/code&gt; 와 &lt;code&gt;to_tsvector&lt;/code&gt; 를 사용 하여 입력 문자열을 여러 토큰으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18b6223b0641dfa27780508785b1cab41976292c" translate="yes" xml:space="preserve">
          <source>Now we can set up the mappings for words in configuration &lt;code&gt;pg&lt;/code&gt;:</source>
          <target state="translated">이제 구성 &lt;code&gt;pg&lt;/code&gt; 에서 단어에 대한 매핑을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4d3c996fedace29e66a9cecc69860990e5567d4" translate="yes" xml:space="preserve">
          <source>Now we can show some &lt;code&gt;INSERT&lt;/code&gt; statements:</source>
          <target state="translated">이제 몇 가지 &lt;code&gt;INSERT&lt;/code&gt; 문을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9811d50e24107f487d484ef3d4f8590f2676cba5" translate="yes" xml:space="preserve">
          <source>Now we can test our configuration:</source>
          <target state="translated">이제 구성을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ace10f4ace4cfabef3a16f550a37af5ffc6dcce7" translate="yes" xml:space="preserve">
          <source>Now we can test our dictionary:</source>
          <target state="translated">이제 사전을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f27c4f52d858064037f2d98b4e6143af1fdd5e4c" translate="yes" xml:space="preserve">
          <source>Now we change the prompt to something more interesting:</source>
          <target state="translated">이제 프롬프트를보다 흥미로운 것으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d4a301c61d4f0a929427d7399e79093ab65b2312" translate="yes" xml:space="preserve">
          <source>Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the &lt;code&gt;weather&lt;/code&gt; table and for each row to find the matching &lt;code&gt;cities&lt;/code&gt; row(s). If no matching row is found we want some &amp;ldquo;empty values&amp;rdquo; to be substituted for the &lt;code&gt;cities&lt;/code&gt; table's columns. This kind of query is called an &lt;em&gt;outer join&lt;/em&gt;. (The joins we have seen so far are inner joins.) The command looks like this:</source>
          <target state="translated">이제 Hayward 레코드를 다시 가져올 수있는 방법을 알아볼 것입니다. 쿼리가 원하는 것은 &lt;code&gt;weather&lt;/code&gt; 테이블 을 스캔하고 각 행이 일치하는 &lt;code&gt;cities&lt;/code&gt; 행 을 찾는 것 입니다. 일치하는 행이 없으면 일부 &quot;빈 값&quot;을 &lt;code&gt;cities&lt;/code&gt; 테이블의 열로 대체하려고합니다 . 이러한 종류의 쿼리를 &lt;em&gt;외부 조인&lt;/em&gt; 이라고합니다 . 지금까지 본 조인은 내부 조인입니다. 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ce7fd7c4c102dd293619badd0d980d7f605bb16" translate="yes" xml:space="preserve">
          <source>Now you are ready to create the foreign data table. Using the &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command, you will need to define the columns for the table, the CSV file name, and its format:</source>
          <target state="translated">이제 외부 데이터 테이블을 작성할 준비가되었습니다. (가) 사용 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 명령을, 테이블, CSV 파일 이름과 형식의 열을 정의해야합니다 :</target>
        </trans-unit>
        <trans-unit id="64a8dd2545b6bf024381f0d92feccb523f90f566" translate="yes" xml:space="preserve">
          <source>Now you need only &lt;code&gt;SELECT&lt;/code&gt; from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</source>
          <target state="translated">이제 기본 원격 테이블에 저장된 데이터에 액세스하려면 외부 테이블에서 &lt;code&gt;SELECT&lt;/code&gt; 만 필요 합니다. &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 를 사용하여 원격 테이블을 수정할 수도 있습니다 . 물론 사용자 매핑에 지정한 원격 사용자에게는 이러한 작업을 수행 할 수있는 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="08d3e6ece6ec2bb9a41472c3b51de60739aa48a4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;SELECT&lt;/code&gt; query similar to the previous example can be used to suggest spellings for misspelled words in user search terms. A useful extra test is to require that the selected words are also of similar length to the misspelled word.</source>
          <target state="translated">이제 이전 예와 유사한 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 사용하여 사용자 검색어에서 철자가 틀린 단어의 철자를 제안 할 수 있습니다. 유용한 추가 테스트는 선택한 단어의 철자가 틀린 단어와 비슷한 길이를 요구하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb91f362c7c32cf6e84b89572465a581c06ab515" translate="yes" xml:space="preserve">
          <source>Now, let's make the condition more restrictive:</source>
          <target state="translated">이제 조건을 더 제한적으로 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="fb9ab76d936c6c858686ae054f0811c70819eab5" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; will be recognized as an application of the indexable operator &lt;code&gt;?&lt;/code&gt; to the indexed expression &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt;. (More information on expression indexes can be found in &lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;.)</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절 &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; 는 인덱싱 가능한 연산자의 응용 프로그램으로 인식 &lt;code&gt;?&lt;/code&gt; 색인 된 표현식 &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt; . (표현식 인덱스에 대한 자세한 내용 &lt;a href=&quot;indexes-expressional&quot;&gt;은 11.7 절&lt;/a&gt; 에서 찾을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="9343983b435f96d35ab006d0ce2a792fa81e36a3" translate="yes" xml:space="preserve">
          <source>Now, the catalogs also provide a cast from &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;integer&lt;/code&gt;. If that cast were marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which it is not &amp;mdash; then the parser would be faced with choosing between the above interpretation and the alternative of casting the &lt;code&gt;numeric&lt;/code&gt; constant to &lt;code&gt;integer&lt;/code&gt; and applying the &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; operator. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed &lt;code&gt;numeric&lt;/code&gt;-and-&lt;code&gt;integer&lt;/code&gt; expression as &lt;code&gt;numeric&lt;/code&gt;; there is no built-in knowledge about that.</source>
          <target state="translated">이제 카탈로그는 &lt;code&gt;numeric&lt;/code&gt; 에서 &lt;code&gt;integer&lt;/code&gt; 로 캐스트도 제공합니다 . 만약 그 캐스트가 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 로 표시 되었다면 &amp;ndash; 파서는 위의 해석과 &lt;code&gt;numeric&lt;/code&gt; 상수를 &lt;code&gt;integer&lt;/code&gt; 로 캐스트하는 방법과 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; 연산자를 적용하는 대안 중 하나를 선택 해야 합니다 . 선호하는 선택에 대한 지식이 없기 때문에 쿼리를 모호하게 포기하고 선언합니다. 두 캐스트의 하나가 암시 적 사실은 혼합의 해상도를 선호하는 우리가 파서을 가르 칠하는 방법입니다 &lt;code&gt;numeric&lt;/code&gt; - 및 - &lt;code&gt;integer&lt;/code&gt; 로 표현 &lt;code&gt;numeric&lt;/code&gt; ; 그것에 대한 기본 지식이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e07cf090027f130a2dc1fbc4d060d70553c3b5f" translate="yes" xml:space="preserve">
          <source>Now, the main problem with the btree search is that btree is inefficient when the search conditions do not constrain the leading index column(s). A better strategy for btree is to create a separate index on each column. Then the planner will choose something like this:</source>
          <target state="translated">이제 btree 검색의 주요 문제점은 검색 조건이 선행 색인 열을 제한하지 않는 경우 btree가 비효율적이라는 것입니다. btree에 대한 더 나은 전략은 각 열에 별도의 인덱스를 만드는 것입니다. 그런 다음 플래너는 다음과 같은 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8cf5b756d6afa6277b947e17d815b23a45e8f0cf" translate="yes" xml:space="preserve">
          <source>Now, this methodology can be cumbersome with a very large number of entries in the &lt;code&gt;one_to_many&lt;/code&gt; table. Often, a join like this would result in an index scan and a fetch for each right hand entry in the table for a particular left hand entry. If you have a very dynamic system, there is not much you can do. However, if you have some data which is fairly static, you can create a summary table with the aggregator.</source>
          <target state="translated">이제이 방법론은 &lt;code&gt;one_to_many&lt;/code&gt; 테이블 에 많은 수의 항목이있어 성 가실 수 있습니다 . 종종 이와 같은 조인은 특정 왼쪽 항목에 대한 테이블의 각 오른쪽 항목에 대한 색인 스캔 및 페치가 발생합니다. 매우 역동적 인 시스템이라면 할 수있는 일이 많지 않습니다. 그러나 상당히 정적 인 데이터가있는 경우 수집기를 사용하여 요약 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333cddf155e5f6b845810ca1b1ec9493a847d199" translate="yes" xml:space="preserve">
          <source>Now, we can run some queries on the table. First, we show how to access a single element of an array. This query retrieves the names of the employees whose pay changed in the second quarter:</source>
          <target state="translated">이제 테이블에서 몇 가지 쿼리를 실행할 수 있습니다. 먼저 배열의 단일 요소에 액세스하는 방법을 보여줍니다. 이 쿼리는 2 분기에 급여가 변경된 직원의 이름을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e60c418bd02619354d423e5f131c6effce59534d" translate="yes" xml:space="preserve">
          <source>Now, we have a table &lt;code&gt;test&lt;/code&gt; populated with data describing the hierarchy shown below:</source>
          <target state="translated">이제 아래 표시된 계층 구조를 설명하는 데이터로 채워진 테이블 &lt;code&gt;test&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc801eb7aa113d4d373983685ad8e4b411d4462" translate="yes" xml:space="preserve">
          <source>Null values are represented by &lt;code&gt;_null_&lt;/code&gt;. (Note that there is no way to create a value that is just that string.)</source>
          <target state="translated">널값은 &lt;code&gt;_null_&lt;/code&gt; 로 표시됩니다 . 해당 문자열 인 값을 만들 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf00f0e98d92759b2ab900b85062ac054ac00545" translate="yes" xml:space="preserve">
          <source>Number of &amp;ldquo;internal&amp;rdquo; (upper-level) pages</source>
          <target state="translated">&amp;ldquo;내부&amp;rdquo;(상위) 페이지 수</target>
        </trans-unit>
        <trans-unit id="766db6ffc20af3c98e8a0c222cc91dcfc261ce82" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;CHECK&lt;/code&gt; constraints on the table; see &lt;a href=&quot;catalog-pg-constraint&quot;&gt;&lt;code&gt;pg_constraint&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">테이블 의 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 수 &lt;a href=&quot;catalog-pg-constraint&quot;&gt; &lt;code&gt;pg_constraint&lt;/code&gt; &lt;/a&gt; 카탈로그를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f562c8ed4194c0f5d892247c878f35e3b1adf69e" translate="yes" xml:space="preserve">
          <source>Number of WAL files that have been successfully archived</source>
          <target state="translated">성공적으로 아카이브 된 WAL 파일 수</target>
        </trans-unit>
        <trans-unit id="c384981df593e79281c2a20754104f1934f6c9b7" translate="yes" xml:space="preserve">
          <source>Number of argument strings passed to trigger function</source>
          <target state="translated">함수를 트리거하기 위해 전달 된 인수 문자열의 수</target>
        </trans-unit>
        <trans-unit id="686b06e76d78fdcab0c83dfec56d5de3d95d6021" translate="yes" xml:space="preserve">
          <source>Number of arguments that have defaults</source>
          <target state="translated">기본값이있는 인수 수</target>
        </trans-unit>
        <trans-unit id="646ba2279db42aaed6dee8b8ba74083e8ded4a4e" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">이 데이터베이스에 현재 연결된 백엔드 수 또는 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다. 이 뷰에서 현재 상태를 반영하는 값을 반환하는 유일한 열입니다. 다른 모든 열은 마지막 재설정 이후 누적 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="055e292dc7e47521853b27a0e59b3a6f4ac3517d" translate="yes" xml:space="preserve">
          <source>Number of backends pinning this buffer</source>
          <target state="translated">이 버퍼를 고정하는 백엔드 수</target>
        </trans-unit>
        <trans-unit id="7fc2a68fbd98db7f2b41bb2e743259772026c43c" translate="yes" xml:space="preserve">
          <source>Number of bitmap pages</source>
          <target state="translated">비트 맵 페이지 수</target>
        </trans-unit>
        <trans-unit id="7826db063f5934f4aaa44397cffd4f35886a95d2" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">각 인덱스 열에 대해 생성 된 비트 수 각 매개 변수의 이름은 제어하는 ​​색인 ​​열의 번호를 나타냅니다. 기본값은 &lt;code&gt;2&lt;/code&gt; 비트이며 최대 값은 &lt;code&gt;4095&lt;/code&gt; 입니다. 실제로 사용되지 않는 인덱스 열의 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6ee47813de9741b16e5983ad54532485c3f7d8" translate="yes" xml:space="preserve">
          <source>Number of bits in string</source>
          <target state="translated">문자열의 비트 수</target>
        </trans-unit>
        <trans-unit id="1efe22f20b8b3239aa455f2b88a22e48c7032a46" translate="yes" xml:space="preserve">
          <source>Number of bits in the encryption algorithm used, or NULL if SSL is not used on this connection</source>
          <target state="translated">사용 된 암호화 알고리즘의 비트 수 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="0aaa9d047e0edd588ca0e7b28edd0b562bba9543" translate="yes" xml:space="preserve">
          <source>Number of blocks already processed in the current phase.</source>
          <target state="translated">현재 단계에서 이미 처리 된 블록 수</target>
        </trans-unit>
        <trans-unit id="00533abb6601d842f496de1f71453437a6ebdea3" translate="yes" xml:space="preserve">
          <source>Number of bucket pages</source>
          <target state="translated">버킷 페이지 수</target>
        </trans-unit>
        <trans-unit id="5f0a807486a5a6ed87ce1d425faa9e67bccd0b96" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in all indexes on this table</source>
          <target state="translated">이 테이블의 모든 인덱스에서 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="e19591b7755dbe90f2648065af697ccee73ba936" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this index</source>
          <target state="translated">이 인덱스의 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="7bc9f9ddcb6814f42c1dfcc0f6c3a5f06c83a41c" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this sequence</source>
          <target state="translated">이 순서에서 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="1b92c223ff9c814c48eef462cd5d9e3733ab3a60" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table</source>
          <target state="translated">이 테이블의 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="fb5ce149dfa5df345dadf32e3e7609e73a91ab4d" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블에서 버퍼 히트 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="23b7daeca394ace2c29173c2e4db7f60e4ffa150" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table indexes (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블 인덱스에서 버퍼 히트 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="820cb42f301c46e1dfd210dd8b99d341db358b4e" translate="yes" xml:space="preserve">
          <source>Number of buffers allocated</source>
          <target state="translated">할당 된 버퍼 수</target>
        </trans-unit>
        <trans-unit id="9d5ff89dcfa3fb4035bf4d286f1b89c75201025e" translate="yes" xml:space="preserve">
          <source>Number of buffers written by the background writer</source>
          <target state="translated">백그라운드 작성자가 쓴 버퍼 수</target>
        </trans-unit>
        <trans-unit id="0754f03bfbfe66ccdcb625fa7e3f44aa2c2a10bf" translate="yes" xml:space="preserve">
          <source>Number of buffers written directly by a backend</source>
          <target state="translated">백엔드가 직접 쓴 버퍼 수</target>
        </trans-unit>
        <trans-unit id="5c0d5f7ac01275f2192348fde149f7bc358fa9b2" translate="yes" xml:space="preserve">
          <source>Number of buffers written during checkpoints</source>
          <target state="translated">체크 포인트 동안 기록 된 버퍼 수</target>
        </trans-unit>
        <trans-unit id="07fff57f12d731d3ce6021e11cbee81eeb3c2283" translate="yes" xml:space="preserve">
          <source>Number of bytes in binary string</source>
          <target state="translated">이진 문자열의 바이트 수</target>
        </trans-unit>
        <trans-unit id="776e4abf0d400377907ab4118caf858bc018038c" translate="yes" xml:space="preserve">
          <source>Number of bytes in string</source>
          <target state="translated">문자열의 바이트 수</target>
        </trans-unit>
        <trans-unit id="0c72d2a102dbeffb7f10cf64774275780bc212cb" translate="yes" xml:space="preserve">
          <source>Number of bytes used to store a particular value (possibly compressed)</source>
          <target state="translated">특정 값을 저장하는 데 사용 된 바이트 수 (압축 가능)</target>
        </trans-unit>
        <trans-unit id="c08b0fa84d37e1078db655b5ae7decd119da648e" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자 수&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd2d8b2ef7ef37c5c432bb5b54f4a96fe58d0820" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; must be valid in this encoding.</source>
          <target state="translated">주어진 &lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt; 에서 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자 수입니다 . &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이 인코딩에서 유효해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21fa6ae67d156ef97e3bcf08c970e730cf5312e3" translate="yes" xml:space="preserve">
          <source>Number of characters in string</source>
          <target state="translated">문자열의 문자 수</target>
        </trans-unit>
        <trans-unit id="b6c03f4ded52583235611efb49840aea96640208" translate="yes" xml:space="preserve">
          <source>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</source>
          <target state="translated">시뮬레이션 된 클라이언트 수, 즉 동시 데이터베이스 세션 수 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="85c5091c823d8842dadc7ece08cd606b9ead02d8" translate="yes" xml:space="preserve">
          <source>Number of completed index vacuum cycles.</source>
          <target state="translated">완료된 인덱스 진공 사이클 수</target>
        </trans-unit>
        <trans-unit id="07c0251b99d852d386e6230c7bc68b422860b2c8" translate="yes" xml:space="preserve">
          <source>Number of data page checksum failures detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">이 데이터베이스 (또는 공유 객체)에서 감지 된 데이터 페이지 체크섬 실패 수 또는 데이터 체크섬이 활성화되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="fd10e6b6630a5e0b1a1e37d857ce93abbe92b80c" translate="yes" xml:space="preserve">
          <source>Number of dead tuples</source>
          <target state="translated">죽은 튜플 수</target>
        </trans-unit>
        <trans-unit id="afdac9c7f2737a1b2507732298381e07eead13a4" translate="yes" xml:space="preserve">
          <source>Number of dead tuples (exact)</source>
          <target state="translated">죽은 튜플 수 (정확한)</target>
        </trans-unit>
        <trans-unit id="02be773fcf618322b70d57bc8dd9f3bf3919a6ff" translate="yes" xml:space="preserve">
          <source>Number of dead tuples collected since the last index vacuum cycle.</source>
          <target state="translated">마지막 인덱스 진공 사이클 이후 수집 된 데드 튜플 수입니다.</target>
        </trans-unit>
        <trans-unit id="dfb451e3ffa3210bb1e566dd30fd90934219a10e" translate="yes" xml:space="preserve">
          <source>Number of dead tuples that we can store before needing to perform an index vacuum cycle, based on &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem에&lt;/a&gt; 따라 인덱스 진공 사이클을 수행하기 전에 저장할 수있는 데드 튜플 수입니다 .</target>
        </trans-unit>
        <trans-unit id="c4921acfb7b89b906d587e207c982d99387b078d" translate="yes" xml:space="preserve">
          <source>Number of deadlocks detected in this database</source>
          <target state="translated">이 데이터베이스에서 감지 된 교착 상태 수</target>
        </trans-unit>
        <trans-unit id="7cb4a85ff41caf8fe6b956d1175a54bab38b2930" translate="yes" xml:space="preserve">
          <source>Number of deleted pages</source>
          <target state="translated">삭제 된 페이지 수</target>
        </trans-unit>
        <trans-unit id="c3223e4de0ae9c43ca827d1664c98d5d300c8a06" translate="yes" xml:space="preserve">
          <source>Number of dimensions, if the column is an array type; otherwise 0. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means &amp;ldquo;it's an array&amp;rdquo;.)</source>
          <target state="translated">열이 배열 유형 인 경우 차원 수입니다. 그렇지 않으면 0입니다. 현재 배열의 차원 수는 적용되지 않으므로 0이 아닌 값은 사실상 &quot;배열입니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2be05a9b990f09033b8618eab5d65ae1aecc4032" translate="yes" xml:space="preserve">
          <source>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to &lt;code&gt;pronargs&lt;/code&gt;, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</source>
          <target state="translated">순서 집합 또는 가정 집합 집합의 직접 (집계되지 않은) 인수의 수는 가변 배열을 하나의 인수로 계산합니다. &lt;code&gt;pronargs&lt;/code&gt; 와 동일한 경우 집계는 가변이어야하며, 가변 배열은 최종 인수와 집계 된 인수를 설명합니다. 정규 집계의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="32e023d3421063e999e37bd8a8607f9d3b37c25b" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from all indexes on this table</source>
          <target state="translated">이 테이블의 모든 인덱스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="5d872dc4357e4133d7ccee125da5dd9ed6f1e23f" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this index</source>
          <target state="translated">이 인덱스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="f152a31061ce6ad3788ac1d44859392030a5e387" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this sequence</source>
          <target state="translated">이 순서에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="5d8a5f136039b36181bc2310abac4c580db63dc6" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table</source>
          <target state="translated">이 테이블에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="0eec262fa83f105ce7c719197839961c454478bd" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블에서 읽은 디스크 블록 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c3595c16a4db90858d963b19c02306856a40fc17" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table indexes (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블 인덱스에서 읽은 디스크 블록 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="afcfec9d8002c45f94146f16eeb8704ff31575b1" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read in this database</source>
          <target state="translated">이 데이터베이스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="da37950fc1304c1760a3162855b0cc7eba9abaaf" translate="yes" xml:space="preserve">
          <source>Number of empty pages</source>
          <target state="translated">빈 페이지 수</target>
        </trans-unit>
        <trans-unit id="1eef621006cc03444cdc3f17923c510b432b6ba9" translate="yes" xml:space="preserve">
          <source>Number of entries in semaphore map</source>
          <target state="translated">세마포어 맵의 항목 수</target>
        </trans-unit>
        <trans-unit id="8ad03f1cded443f2951e34811d9b174dcd53e9f1" translate="yes" xml:space="preserve">
          <source>Number of failed attempts for archiving WAL files</source>
          <target state="translated">WAL 파일 보관에 실패한 횟수</target>
        </trans-unit>
        <trans-unit id="db7d7d8e8c6ad921ea1f650987683cdca25be133" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. Because the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to &lt;code&gt;heap_blks_total&lt;/code&gt; when the vacuum is complete. This counter only advances when the phase is &lt;code&gt;scanning heap&lt;/code&gt;.</source>
          <target state="translated">스캔 된 힙 블록 수 &lt;a href=&quot;storage-vm&quot;&gt;가시성 맵&lt;/a&gt; 은 스캔을 최적화하는 데 사용 되므로 일부 블록은 검사없이 건너 뜁니다. 건너 뛴 블록이이 합계에 포함되므로 진공이 완료 될 때이 숫자가 결국 &lt;code&gt;heap_blks_total&lt;/code&gt; 과 같습니다 . 이 카운터는 단계가 &lt;code&gt;scanning heap&lt;/code&gt; 할 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8abfe62e8394a6c74c6d4a5a932d175e4675308e" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">스캔 된 힙 블록 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3cc4495fb3d4a190394bf457f27a153df853feb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks vacuumed. Unless the table has no indexes, this counter only advances when the phase is &lt;code&gt;vacuuming heap&lt;/code&gt;. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.</source>
          <target state="translated">청소 된 힙 블록 수 테이블에 인덱스가없는 경우이 카운터는 단계가 &lt;code&gt;vacuuming heap&lt;/code&gt; 때만 진행됩니다 . 데드 튜플이 포함되지 않은 블록은 건너 뛰므로 카운터가 때때로 크게 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7065ea221f976c9edbd673b5b220f7e3c796ada" translate="yes" xml:space="preserve">
          <source>Number of heap tuples scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">스캔 한 힙 튜플 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; 또는 &lt;code&gt;writing new heap&lt;/code&gt; 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1608d82e7902ccc755c873e18179b75db06e972e" translate="yes" xml:space="preserve">
          <source>Number of heap tuples written. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">쓴 힙 튜플 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; 또는 &lt;code&gt;writing new heap&lt;/code&gt; 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8a4f5e567445d068c8e050292c1c88bc19074f5" translate="yes" xml:space="preserve">
          <source>Number of index entries returned by scans on this index</source>
          <target state="translated">이 색인에서 스캔이 리턴 한 색인 항목 수</target>
        </trans-unit>
        <trans-unit id="2e47feab593e8d7f11f91aca87244c1647d56eda" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this index</source>
          <target state="translated">이 인덱스에서 시작된 인덱스 스캔 수</target>
        </trans-unit>
        <trans-unit id="9740aebc5f5b78757843f388b08b6acf15d45722" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this table</source>
          <target state="translated">이 테이블에서 시작된 인덱스 스캔 수</target>
        </trans-unit>
        <trans-unit id="2512b3dbef65d5a2946445bd9f10f953be318af1" translate="yes" xml:space="preserve">
          <source>Number of indexes rebuilt. This counter only advances when the phase is &lt;code&gt;rebuilding index&lt;/code&gt;.</source>
          <target state="translated">재 구축 된 인덱스 수입니다. 이 카운터는 단계가 &lt;code&gt;rebuilding index&lt;/code&gt; 하는 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c472386046a97dee2b6524340bae3b671c82f90b" translate="yes" xml:space="preserve">
          <source>Number of input arguments</source>
          <target state="translated">입력 인수의 수</target>
        </trans-unit>
        <trans-unit id="2f8814269318ff6e97c5ce39779e7a57b9de7c2a" translate="yes" xml:space="preserve">
          <source>Number of leaf pages</source>
          <target state="translated">리프 페이지 수</target>
        </trans-unit>
        <trans-unit id="09d24d58ee5f9d720e6e82ed3d6f447d63a9f297" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by index scans</source>
          <target state="translated">인덱스 스캔으로 페치 된 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="7f6337cf0b1025e25455e7f1eb27c447744854cc" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by sequential scans</source>
          <target state="translated">순차적 스캔으로 페치 된 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="c7bb465c5d5812b8f1ac688b0973b4608d17fc34" translate="yes" xml:space="preserve">
          <source>Number of live rows in the table. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">테이블의 라이브 행 수 이것은 플래너가 사용한 추정치 일뿐입니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="6384ca87c928ff5826fd519745a102a2e37dcfdf" translate="yes" xml:space="preserve">
          <source>Number of live table rows fetched by simple index scans using this index</source>
          <target state="translated">이 인덱스를 사용하여 간단한 인덱스 스캔으로 가져온 라이브 테이블 행 수</target>
        </trans-unit>
        <trans-unit id="dd029b3676675a63d87f153e3800676e7c7dd2a6" translate="yes" xml:space="preserve">
          <source>Number of live tuples</source>
          <target state="translated">라이브 튜플 수</target>
        </trans-unit>
        <trans-unit id="d58d2b3f2cd29b1e4cc2b40b834ed9770119552a" translate="yes" xml:space="preserve">
          <source>Number of live tuples (estimated)</source>
          <target state="translated">라이브 튜플 수 (예상)</target>
        </trans-unit>
        <trans-unit id="5571a3a39c2a5eeb8bba94092d426fefd43fd703" translate="yes" xml:space="preserve">
          <source>Number of lockers already waited for.</source>
          <target state="translated">이미 대기 한 사물함 수</target>
        </trans-unit>
        <trans-unit id="11736240ddbd910654d9f20076ce6396954df295" translate="yes" xml:space="preserve">
          <source>Number of overflow pages</source>
          <target state="translated">오버플로 페이지 수</target>
        </trans-unit>
        <trans-unit id="2ef8f42ee9f5e2c4b09ad099506a9000c698f3af" translate="yes" xml:space="preserve">
          <source>Number of pages in the pending list</source>
          <target state="translated">보류 목록의 페이지 수</target>
        </trans-unit>
        <trans-unit id="daa5300000bb09c7a79335a89c2593536d8853e6" translate="yes" xml:space="preserve">
          <source>Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">테이블의 가시성 맵에서 모두 표시 가능한 페이지 수입니다. 이것은 플래너가 사용한 추정치 일뿐입니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3cf04020ae64faac82b051a0ef081a4ffd60a33" translate="yes" xml:space="preserve">
          <source>Number of points in path or polygon</source>
          <target state="translated">경로 또는 다각형의 포인트 수</target>
        </trans-unit>
        <trans-unit id="59e27e77340db29b89a3fbca8921ff6b082deb57" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.)</source>
          <target state="translated">이 데이터베이스의 복구와의 충돌로 인해 취소 된 쿼리 수입니다. 충돌은 대기 서버에서만 발생합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14b49512f9667544c12ae0c4b4cd966d96369baa" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to deadlocks</source>
          <target state="translated">교착 상태로 인해 취소 된이 데이터베이스의 쿼리 수</target>
        </trans-unit>
        <trans-unit id="2965fecffa2cf1a8144374cd40187c529bd62354" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to dropped tablespaces</source>
          <target state="translated">이 데이터베이스에서 테이블 스페이스 삭제로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="285091906a09f767f888d2dff167e4dafef20892" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to lock timeouts</source>
          <target state="translated">이 데이터베이스에서 잠금 시간 종료로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="7bd181d498f49b3250f7391fd0a21bf7f1dd7ba8" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to old snapshots</source>
          <target state="translated">이 데이터베이스에서 오래된 스냅 샷으로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="a343fc19cbfe51192fb4c899e5aeef503d395f97" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to pinned buffers</source>
          <target state="translated">고정 된 버퍼로 인해이 데이터베이스에서 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="0ac9bcd7ffe37a50ba3f5b534d815f116bf780f4" translate="yes" xml:space="preserve">
          <source>Number of requested checkpoints that have been performed</source>
          <target state="translated">수행 된 요청 된 체크 포인트 수</target>
        </trans-unit>
        <trans-unit id="ac10ddd98993ae90bf693c73dcdf8ce8ff50a428" translate="yes" xml:space="preserve">
          <source>Number of rows HOT updated (i.e., with no separate index update required)</source>
          <target state="translated">HOT 업데이트 된 행 수 (즉, 별도의 인덱스 업데이트가 필요하지 않음)</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">삭제 된 행 수</target>
        </trans-unit>
        <trans-unit id="f34b08643d44d2358187f3d93aedd65adc903d85" translate="yes" xml:space="preserve">
          <source>Number of rows deleted by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리에 의해 삭제 된 행 수</target>
        </trans-unit>
        <trans-unit id="a2b82f360651a017d5888c1a773debe321eb0eb6" translate="yes" xml:space="preserve">
          <source>Number of rows fetched by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리로 가져온 행 수</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">삽입 된 행 수</target>
        </trans-unit>
        <trans-unit id="6a09e7859bb80515b532f0be7e2f1d0e3e69ef9b" translate="yes" xml:space="preserve">
          <source>Number of rows inserted by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리에 의해 삽입 된 행 수</target>
        </trans-unit>
        <trans-unit id="df7903056ffeb2c4aeb95ecc376e010c64637c6c" translate="yes" xml:space="preserve">
          <source>Number of rows returned by queries in this database</source>
          <target state="translated">이 데이터베이스의 쿼리에서 반환 된 행 수</target>
        </trans-unit>
        <trans-unit id="323338c3c2a474e71a2da0eb4b11693b9c2f500b" translate="yes" xml:space="preserve">
          <source>Number of rows updated (includes HOT updated rows)</source>
          <target state="translated">업데이트 된 행 수 (HOT 업데이트 된 행 포함)</target>
        </trans-unit>
        <trans-unit id="454a23c41b48acf5b2ccd14833f1fbd50495e2fe" translate="yes" xml:space="preserve">
          <source>Number of rows updated by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리로 업데이트 된 행 수</target>
        </trans-unit>
        <trans-unit id="2ac84789e08f3d81095c6bdcfce3914d10c756d6" translate="yes" xml:space="preserve">
          <source>Number of scheduled checkpoints that have been performed</source>
          <target state="translated">수행 된 예약 된 검사 점 수</target>
        </trans-unit>
        <trans-unit id="70b6c2dc7031b941f16874427081ef44f2d0e18e" translate="yes" xml:space="preserve">
          <source>Number of sequential scans initiated on this table</source>
          <target state="translated">이 테이블에서 시작된 순차 스캔 수</target>
        </trans-unit>
        <trans-unit id="db1eaebd91f46f68739419b406f7116ca7278810" translate="yes" xml:space="preserve">
          <source>Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">이 데이터베이스에서 쿼리로 작성된 임시 파일 수 임시 파일이 작성된 이유 (예 : 정렬 또는 해싱)와 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; 설정에 관계없이 모든 임시 파일이 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="321ef5914a0a09d168438f2273433fc677686e24" translate="yes" xml:space="preserve">
          <source>Number of the log line for each session or process, starting at 1</source>
          <target state="translated">1부터 시작하는 각 세션 또는 프로세스의 로그 라인 수</target>
        </trans-unit>
        <trans-unit id="63fe0ed940b40404d3e8a92d939916a5dc589c9e" translate="yes" xml:space="preserve">
          <source>Number of times a backend had to execute its own &lt;code&gt;fsync&lt;/code&gt; call (normally the background writer handles those even when the backend does its own write)</source>
          <target state="translated">백엔드가 자체 &lt;code&gt;fsync&lt;/code&gt; 호출 을 실행 해야하는 횟수 (일반적으로 백그라운드 작성기는 백엔드가 자체 쓰기를 수행하는 경우에도 처리합니다)</target>
        </trans-unit>
        <trans-unit id="a553947fcdc098d224243a39019d65fcd42472fd" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)</source>
          <target state="translated">디스크 캐시가 이미 버퍼 캐시에서 발견 된 횟수로 읽기가 필요하지 않음 (운영 체제의 파일 시스템 캐시가 아닌 PostgreSQL 버퍼 캐시의 적중 만 포함)</target>
        </trans-unit>
        <trans-unit id="d7202f6daa9d37d53dc5948cf3ce73b0f377e700" translate="yes" xml:space="preserve">
          <source>Number of times executed</source>
          <target state="translated">실행 횟수</target>
        </trans-unit>
        <trans-unit id="03d48edf24ffbd37a62d6a4ffcfb82831fa45c63" translate="yes" xml:space="preserve">
          <source>Number of times the background writer stopped a cleaning scan because it had written too many buffers</source>
          <target state="translated">백그라운드 작성기가 너무 많은 버퍼를 작성하여 클리닝 스캔을 중지 한 횟수</target>
        </trans-unit>
        <trans-unit id="db4c1e8598791346cf7ab2d43ead7da4a1cb087e" translate="yes" xml:space="preserve">
          <source>Number of times this function has been called</source>
          <target state="translated">이 함수가 호출 된 횟수</target>
        </trans-unit>
        <trans-unit id="981adc683189320f78f847f75dfe9f19ed8a5df7" translate="yes" xml:space="preserve">
          <source>Number of times this table has been analyzed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 분석 한 횟수</target>
        </trans-unit>
        <trans-unit id="b87ae2050cfd76f7faad9ed39e95e377b7ba3065" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually analyzed</source>
          <target state="translated">이 테이블을 수동으로 분석 한 횟수</target>
        </trans-unit>
        <trans-unit id="86f3157922ed18f5e1cb8cdea053f28b23ec91b9" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">이 테이블을 수동으로 진공 청소 한 횟수 ( &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 계산하지 않음 )</target>
        </trans-unit>
        <trans-unit id="7d451fa30c0c321954c3a675d2c5bb4c2d50a932" translate="yes" xml:space="preserve">
          <source>Number of times this table has been vacuumed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 정리 한 횟수</target>
        </trans-unit>
        <trans-unit id="4c54cfa40fa8364c91aff563ca87ddd6edf318b8" translate="yes" xml:space="preserve">
          <source>Number of transactions each client runs. Default is 10.</source>
          <target state="translated">각 클라이언트가 실행하는 트랜잭션 수 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="3275a376403dc18fc868eeb773fd1acfe4f18aec" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been committed</source>
          <target state="translated">이 데이터베이스에서 커밋 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="5b3dba5ee04dc9d1479c1b216978bf3f1db9f6aa" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been rolled back</source>
          <target state="translated">이 데이터베이스에서 롤백 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="249fa0ad004c753cb36af02875bc1dafebf2db43" translate="yes" xml:space="preserve">
          <source>Number of tuples already processed in the current phase.</source>
          <target state="translated">현재 단계에서 이미 처리 된 튜플 수</target>
        </trans-unit>
        <trans-unit id="e10a2168070471eb01214b024083f7afd7ad7f4a" translate="yes" xml:space="preserve">
          <source>Number of tuples in the pending list</source>
          <target state="translated">보류 목록의 튜플 수</target>
        </trans-unit>
        <trans-unit id="cf7d86c225385fe6e945a39e465f0448098943a9" translate="yes" xml:space="preserve">
          <source>Number of unused pages</source>
          <target state="translated">사용하지 않은 페이지 수</target>
        </trans-unit>
        <trans-unit id="64210a61d52a14f7a802ee5036f59bb4880be4c1" translate="yes" xml:space="preserve">
          <source>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in &lt;code&gt;pg_attribute&lt;/code&gt;. See also &lt;code&gt;pg_attribute.attnum&lt;/code&gt;.</source>
          <target state="translated">관계의 사용자 열 수 (시스템 열은 계산되지 않음) &lt;code&gt;pg_attribute&lt;/code&gt; 에 해당하는 많은 항목이 있어야합니다 . &lt;code&gt;pg_attribute.attnum&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5897414fda7aed8102e3f5d6f9e16ee579dd363" translate="yes" xml:space="preserve">
          <source>Number of worker threads within pgbench. Using more than one thread can be helpful on multi-CPU machines. Clients are distributed as evenly as possible among available threads. Default is 1.</source>
          <target state="translated">pgbench 내의 작업자 스레드 수 다중 CPU 시스템에서 둘 이상의 스레드를 사용하면 도움이 될 수 있습니다. 클라이언트는 사용 가능한 스레드간에 최대한 고르게 분배됩니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="cefa5441373f254fdc1cb9fdbc4d9c0c1aa44ee4" translate="yes" xml:space="preserve">
          <source>Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits.</source>
          <target state="translated">유효 숫자가 7 이하인 숫자는 원래 정밀도를 유지합니다. 즉, 쿼리에서 0.00을 반환하면 후행 0이 서식의 인공물이 아닌 것입니다. 원래 데이터의 정밀도를 반영합니다. 선행 0의 수는 정밀도에 영향을 미치지 않습니다. 값 0.0067은 유효 숫자가 2 자리 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="58224773d7dc5786efbb9bfbfa152b78d5c3ced5" translate="yes" xml:space="preserve">
          <source>Numeric Types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="f1b55ea9345add00dc53f8d39e821048683ac6ac" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigint</source>
          <target state="translated">숫자 유형 : bigint</target>
        </trans-unit>
        <trans-unit id="34ca1938464846ffd7671c72fe6fcf56ce8ed626" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigserial</source>
          <target state="translated">숫자 유형 : bigserial</target>
        </trans-unit>
        <trans-unit id="4f4c21c7dbf7d3b0ce15752213f48b0ca85c6be6" translate="yes" xml:space="preserve">
          <source>Numeric Types: decimal</source>
          <target state="translated">숫자 유형 : 10 진수</target>
        </trans-unit>
        <trans-unit id="5f39be2adc33677462c0440cd7f421e180a13185" translate="yes" xml:space="preserve">
          <source>Numeric Types: double precision</source>
          <target state="translated">숫자 유형 : 배정도</target>
        </trans-unit>
        <trans-unit id="7d13fe88ea7d98f3a10e5a107a6fb5f2b06420b9" translate="yes" xml:space="preserve">
          <source>Numeric Types: integer</source>
          <target state="translated">숫자 유형 : 정수</target>
        </trans-unit>
        <trans-unit id="589f0dce7263b0f4a4ffcc692a06b6cca5db39a7" translate="yes" xml:space="preserve">
          <source>Numeric Types: numeric</source>
          <target state="translated">숫자 유형 : 숫자</target>
        </trans-unit>
        <trans-unit id="d049c61cbf5f08cf4a2b6ad03914911c2436a250" translate="yes" xml:space="preserve">
          <source>Numeric Types: real</source>
          <target state="translated">숫자 유형 : 실수</target>
        </trans-unit>
        <trans-unit id="017b04d1c97e36f0333abaaf314c6a6c6bbedc30" translate="yes" xml:space="preserve">
          <source>Numeric Types: serial</source>
          <target state="translated">숫자 유형 : serial</target>
        </trans-unit>
        <trans-unit id="9e36bc851d04411f4bd3afa229897af484988fe2" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallint</source>
          <target state="translated">숫자 유형 : smallint</target>
        </trans-unit>
        <trans-unit id="3fa9584c0cd0a43cf41d81cfcfb10456d729bae0" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallserial</source>
          <target state="translated">숫자 유형 : smallserial</target>
        </trans-unit>
        <trans-unit id="6907254669bc308bcd96a76901734e20d0b431f6" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">ASCII 범위 (0-127) 이외의 값을 지정하는 숫자 문자 입력 이스케이프는 데이터베이스 인코딩에 따라 의미가 있습니다. 인코딩이 UTF-8 인 경우 이스케이프 값은 유니 코드 코드 포인트와 같습니다. 예를 들어 &lt;code&gt;\u1234&lt;/code&gt; 는 문자 &lt;code&gt;U+1234&lt;/code&gt; 를 의미합니다 . 다른 멀티 바이트 인코딩의 경우 문자 입력 이스케이프는 일반적으로 문자의 바이트 값 연결을 지정합니다. 이스케이프 값이 데이터베이스 인코딩에서 유효한 문자와 일치하지 않으면 오류가 발생하지 않지만 데이터와 일치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e2759a88d02cd4c49727936e3e39cfce1c8fe1b" translate="yes" xml:space="preserve">
          <source>Numeric constants are accepted in these general forms:</source>
          <target state="translated">숫자 상수는 다음과 같은 일반적인 형식으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="32c0946f98f3a53c7cc5e78bd6ba14716174ad6a" translate="yes" xml:space="preserve">
          <source>Numeric ordering, sorts sequences of digits by their numeric value, for example: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (also known as natural sort).</source>
          <target state="translated">숫자 순서는 숫자 값을 기준으로 일련의 숫자를 정렬합니다 (예 : &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (자연 정렬이라고도 함)).</target>
        </trans-unit>
        <trans-unit id="8d7bc2659eda5afabdbd8dae30a1b10b69aab0fa" translate="yes" xml:space="preserve">
          <source>Numeric transaction identifier of the prepared transaction</source>
          <target state="translated">준비된 거래의 숫자 거래 식별자</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="bbed1ad8168ad945da348f70d8f35c3aaa2d08ae" translate="yes" xml:space="preserve">
          <source>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt; lists the available types.</source>
          <target state="translated">숫자 유형은 2, 4 및 8 바이트 정수, 4 및 8 바이트 부동 소수점 숫자 및 선택 가능한 정밀도 10 진수로 구성됩니다. 사용 가능한 유형이 &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;표 8.2에&lt;/a&gt; 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae34df1114cf867e5a5e67721782e6b4936cf60a" translate="yes" xml:space="preserve">
          <source>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the &lt;code&gt;numeric&lt;/code&gt; type is more akin to &lt;code&gt;varchar(n)&lt;/code&gt; than to &lt;code&gt;char(n)&lt;/code&gt;.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</source>
          <target state="translated">숫자 값은 추가 선행 또는 후행 0없이 물리적으로 저장됩니다. 따라서 열의 선언 된 정밀도 및 스케일은 고정 할당이 아니라 최대 값입니다. (이러한 관점에서, &lt;code&gt;numeric&lt;/code&gt; 타입에 더 가깝다 &lt;code&gt;varchar(n)&lt;/code&gt; 보다 &lt;code&gt;char(n)&lt;/code&gt; ). 실제 스토리지 요건 오버 네 십진수의 각 그룹에 대해 2 바이트 플러스 3-8 바이트이다.</target>
        </trans-unit>
        <trans-unit id="1cd1073fd79a8443ea8d6973895d5ee6ffe7cdf9" translate="yes" xml:space="preserve">
          <source>Numerical statistics of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not involve numerical values</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 적절한 종류의 숫자 통계 또는 슬롯 종류에 숫자 값이 포함되지 않은 경우 null</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="725ff3ec092f4de8d511006eba9dfe844003c6f9" translate="yes" xml:space="preserve">
          <source>OID of a database</source>
          <target state="translated">데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="f8c02df27c83758b75b440e8700bcc0f8b46a3f0" translate="yes" xml:space="preserve">
          <source>OID of a function</source>
          <target state="translated">함수의 OID</target>
        </trans-unit>
        <trans-unit id="faffc6a7f80d0822867cb82f8a02546997b88ef9" translate="yes" xml:space="preserve">
          <source>OID of a handler function that is responsible for supplying information about the access method</source>
          <target state="translated">액세스 방법에 대한 정보를 제공하는 처리기 함수의 OID</target>
        </trans-unit>
        <trans-unit id="5a4a96aa8d7efd7ac397558d10f843a235a92c88" translate="yes" xml:space="preserve">
          <source>OID of a sequence</source>
          <target state="translated">시퀀스의 OID</target>
        </trans-unit>
        <trans-unit id="996a8d685aef72e0b42d14422b03fa62a0285fd1" translate="yes" xml:space="preserve">
          <source>OID of a table</source>
          <target state="translated">테이블의 OID</target>
        </trans-unit>
        <trans-unit id="90f9df50ed473af29d597298ed5c8caeb84243d2" translate="yes" xml:space="preserve">
          <source>OID of database in which the statement was executed</source>
          <target state="translated">명령문이 실행 된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="080d0fef7c4d986b1330554caa1d1e593f3124b0" translate="yes" xml:space="preserve">
          <source>OID of session's temporary schema, or 0 if none</source>
          <target state="translated">세션의 임시 스키마의 OID.없는 경우 0</target>
        </trans-unit>
        <trans-unit id="346ed8429eddd05e15627f07718d2d6a7f44eddd" translate="yes" xml:space="preserve">
          <source>OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this foreign table</source>
          <target state="translated">이 외부 테이블에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목의 OID</target>
        </trans-unit>
        <trans-unit id="3bcb74cd3805e6c2a6b21b10048ed96a348a5d71" translate="yes" xml:space="preserve">
          <source>OID of the TOAST table associated with this table, 0 if none. The TOAST table stores large attributes &amp;ldquo;out of line&amp;rdquo; in a secondary table.</source>
          <target state="translated">이 테이블과 연관된 TOAST 테이블의 OID.없는 경우 0 TOAST 테이블은 큰 속성 &quot;out of line&quot;을 보조 테이블에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5cb554635bbb124706c2580bd976000c272a3041" translate="yes" xml:space="preserve">
          <source>OID of the collation used for range comparisons, or 0 if none</source>
          <target state="translated">범위 비교에 사용 된 데이터 정렬의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="1af1844b19464c23fc7fd9fcae9a412bfe3133ff" translate="yes" xml:space="preserve">
          <source>OID of the data type this transform is for</source>
          <target state="translated">이 변환의 데이터 유형에 대한 OID</target>
        </trans-unit>
        <trans-unit id="7be8af1517de8b566e91490637cc744e1bfc4538" translate="yes" xml:space="preserve">
          <source>OID of the database in which the lock target exists, or zero if the target is a shared object, or null if the target is a transaction ID</source>
          <target state="translated">잠금 대상이 존재하는 데이터베이스의 OID. 대상이 공유 오브젝트 인 경우 0 또는 대상이 트랜잭션 ID 인 경우 널</target>
        </trans-unit>
        <trans-unit id="d6eff8fed00f101585817bdde7217d409d0452cb" translate="yes" xml:space="preserve">
          <source>OID of the database this backend is connected to</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="c3f83d507478524c5f0343641eaf036c1dd5f6f4" translate="yes" xml:space="preserve">
          <source>OID of the database to which this backend is connected.</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="99d858de93dcac0523dbaa414705f17f8ce20935" translate="yes" xml:space="preserve">
          <source>OID of the database which the subscription resides in</source>
          <target state="translated">구독이있는 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="3c094c24ab67863a7765120475d6a2f2e2e272ea" translate="yes" xml:space="preserve">
          <source>OID of the element type (subtype) of this range type</source>
          <target state="translated">이 범위 유형의 요소 유형 (하위 유형)의 OID</target>
        </trans-unit>
        <trans-unit id="91964bc019a248521428ce08554d6e0d30140b28" translate="yes" xml:space="preserve">
          <source>OID of the foreign server for this foreign table</source>
          <target state="translated">이 외부 테이블에 대한 외부 서버의 OID</target>
        </trans-unit>
        <trans-unit id="73727764a13452c62b9dc37a3cc28ff75c10a8fb" translate="yes" xml:space="preserve">
          <source>OID of the foreign-data wrapper of this foreign server</source>
          <target state="translated">이 외부 서버의 외부 데이터 랩퍼의 OID</target>
        </trans-unit>
        <trans-unit id="bef000be97274c50b609e7040996c7f3a74549e7" translate="yes" xml:space="preserve">
          <source>OID of the function</source>
          <target state="translated">기능의 OID</target>
        </trans-unit>
        <trans-unit id="d936ce13d6a2191f0fb1ebd586182169926914bd" translate="yes" xml:space="preserve">
          <source>OID of the function to convert a range value into canonical form, or 0 if none</source>
          <target state="translated">범위 값을 정식 형식으로 변환하는 함수의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="3de3255d0dade1eabbba67bef7bb7de2117ad3f9" translate="yes" xml:space="preserve">
          <source>OID of the function to return the difference between two element values as &lt;code&gt;double precision&lt;/code&gt;, or 0 if none</source>
          <target state="translated">두 요소 값의 차이를 &lt;code&gt;double precision&lt;/code&gt; 로 반환하는 함수의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="04695e3476f4985e5e3d88253bca9d829918ada5" translate="yes" xml:space="preserve">
          <source>OID of the index being created or reindexed. During a non-concurrent &lt;code&gt;CREATE INDEX&lt;/code&gt;, this is 0.</source>
          <target state="translated">작성 또는 재 색인되는 색인의 OID 비 동시 &lt;code&gt;CREATE INDEX&lt;/code&gt; 동안이 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="36fd3faf4abf64d7b63021e96a36b08b96b00ad5" translate="yes" xml:space="preserve">
          <source>OID of the language this transform is for</source>
          <target state="translated">이 변환을위한 언어의 OID</target>
        </trans-unit>
        <trans-unit id="7e460991382ec78ace08e8b50c8809bb0c2a37f4" translate="yes" xml:space="preserve">
          <source>OID of the large object to be altered</source>
          <target state="translated">변경 될 큰 객체의 OID</target>
        </trans-unit>
        <trans-unit id="1d1d811b028d1d43309ac3a6a9795a5474876c40" translate="yes" xml:space="preserve">
          <source>OID of the local role being mapped, 0 if the user mapping is public</source>
          <target state="translated">맵핑되는 로컬 역할의 OID, 사용자 맵핑이 공용 인 경우 0</target>
        </trans-unit>
        <trans-unit id="f6befa197b5efdceb1d6e3e97ba6a7089030d83b" translate="yes" xml:space="preserve">
          <source>OID of the lock target within its system catalog, or null if the target is not a general database object</source>
          <target state="translated">시스템 카탈로그 내에서 잠금 대상의 OID 또는 대상이 일반 데이터베이스 오브젝트가 아닌 경우 널</target>
        </trans-unit>
        <trans-unit id="547ca9a3f91e95b8778cc1a87f9fe368954503d2" translate="yes" xml:space="preserve">
          <source>OID of the operator</source>
          <target state="translated">운영자의 OID</target>
        </trans-unit>
        <trans-unit id="57147e7dec8c6552f43472e577611d734b852d01" translate="yes" xml:space="preserve">
          <source>OID of the parser's headline function</source>
          <target state="translated">파서 헤드 라인 함수의 OID</target>
        </trans-unit>
        <trans-unit id="e75052ec080efa2cb48c4eee33c12247804336c7" translate="yes" xml:space="preserve">
          <source>OID of the parser's lextype function</source>
          <target state="translated">파서의 lextype 함수의 OID</target>
        </trans-unit>
        <trans-unit id="070d9465021b789c1852df9d85e1dab51aa12f2b" translate="yes" xml:space="preserve">
          <source>OID of the parser's next-token function</source>
          <target state="translated">파서의 다음 토큰 기능의 OID</target>
        </trans-unit>
        <trans-unit id="28ddd7cda8c6ae7b671231bc8b5771d3c20a5115" translate="yes" xml:space="preserve">
          <source>OID of the parser's shutdown function</source>
          <target state="translated">파서 종료 기능의 OID</target>
        </trans-unit>
        <trans-unit id="3441d838ae5086ffa5ad3452eab23ff3831aa095" translate="yes" xml:space="preserve">
          <source>OID of the parser's startup function</source>
          <target state="translated">파서 시작 기능의 OID</target>
        </trans-unit>
        <trans-unit id="cf7d55d689e6813249b16676499a1c0b2b7376b1" translate="yes" xml:space="preserve">
          <source>OID of the range type</source>
          <target state="translated">범위 유형의 OID</target>
        </trans-unit>
        <trans-unit id="00bba16646f2a65970a0b9e99737c24fb8db4ee2" translate="yes" xml:space="preserve">
          <source>OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation</source>
          <target state="translated">잠금이 대상으로하는 관계의 OID 또는 대상이 관계 또는 관계의 일부가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="10ccac12f9b1c1d8ff7d1e3fe492cab3d5e3c0cd" translate="yes" xml:space="preserve">
          <source>OID of the relation that the worker is synchronizing; null for the main apply worker</source>
          <target state="translated">작업자가 동기화하고있는 관계의 OID; 기본 적용 작업자의 경우 null</target>
        </trans-unit>
        <trans-unit id="64dbbea0aaf12efa0d4ebae8170596e36c349efc" translate="yes" xml:space="preserve">
          <source>OID of the source data type</source>
          <target state="translated">소스 데이터 유형의 OID</target>
        </trans-unit>
        <trans-unit id="4ab6e82967b76a601d959c42c032a9613f62366e" translate="yes" xml:space="preserve">
          <source>OID of the subscription</source>
          <target state="translated">구독의 OID</target>
        </trans-unit>
        <trans-unit id="529393343c510cc7f43e20828d0d63fb68383a2c" translate="yes" xml:space="preserve">
          <source>OID of the subtype's operator class used for range comparisons</source>
          <target state="translated">범위 비교에 사용되는 하위 유형의 연산자 클래스의 OID</target>
        </trans-unit>
        <trans-unit id="633257d0b0d38e2fef790525052ae12fd0314ed1" translate="yes" xml:space="preserve">
          <source>OID of the system catalog containing the lock target, or null if the target is not a general database object</source>
          <target state="translated">잠금 대상을 포함하는 시스템 카탈로그의 OID 또는 대상이 일반 데이터베이스 오브젝트가 아닌 경우 널</target>
        </trans-unit>
        <trans-unit id="6da84f1d83f2a7ebd175fcdf78bf746dff039dba" translate="yes" xml:space="preserve">
          <source>OID of the table being clustered.</source>
          <target state="translated">클러스터중인 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="0e4debb724827a1126e4f0985aac0c3bd73e2728" translate="yes" xml:space="preserve">
          <source>OID of the table being vacuumed.</source>
          <target state="translated">진공 청소중인 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="e9109406be796a3753b7f074b353cc534267a046" translate="yes" xml:space="preserve">
          <source>OID of the table for this index</source>
          <target state="translated">이 인덱스에 대한 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="50e7e1691ddba39a8ac80c840ffce2b6dd3a48c8" translate="yes" xml:space="preserve">
          <source>OID of the table on which the index is being created.</source>
          <target state="translated">인덱스가 작성되는 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="090219832be11fe1619b95babe8e9c1e5e92c437" translate="yes" xml:space="preserve">
          <source>OID of the target data type</source>
          <target state="translated">대상 데이터 유형의 OID</target>
        </trans-unit>
        <trans-unit id="ac66a3e3aabe35420bf2d2c1e94ee59c9c06a065" translate="yes" xml:space="preserve">
          <source>OID of the template's initialization function</source>
          <target state="translated">템플릿 초기화 기능의 OID</target>
        </trans-unit>
        <trans-unit id="50c0da2d8b347f30166307b39f81117e5e35c3ea" translate="yes" xml:space="preserve">
          <source>OID of the template's lexize function</source>
          <target state="translated">템플릿의 lexize 함수의 OID</target>
        </trans-unit>
        <trans-unit id="a8374b131925b37be69ac971d0b27d489ca95329" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this WAL sender process</source>
          <target state="translated">이 WAL 발신자 프로세스에 로그인 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="5fe5cd795b2ac38b10709cbfaf75428859cfc40c" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this backend</source>
          <target state="translated">이 백엔드에 로그인 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="ac6509d860cce791cfecdfeff54c3c371229705b" translate="yes" xml:space="preserve">
          <source>OID of the user mapping</source>
          <target state="translated">사용자 매핑의 OID</target>
        </trans-unit>
        <trans-unit id="5cb18008fb6941eebe8d741c085bfe9b7fb69a3f" translate="yes" xml:space="preserve">
          <source>OID of this database, or 0 for objects belonging to a shared relation</source>
          <target state="translated">이 데이터베이스의 OID 또는 공유 관계에 속하는 오브젝트의 경우 0</target>
        </trans-unit>
        <trans-unit id="a7af712c7c37a60b529576ed90f30e8cf2d7a00c" translate="yes" xml:space="preserve">
          <source>OID of this index</source>
          <target state="translated">이 인덱스의 OID</target>
        </trans-unit>
        <trans-unit id="d3dd8c985a0eabab21975bbe483a04f61be0cad9" translate="yes" xml:space="preserve">
          <source>OID of user who executed the statement</source>
          <target state="translated">명령문을 실행 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="387852e7a1481866714e0a22f56d3c6e25b3ae5f" translate="yes" xml:space="preserve">
          <source>OIDs assigned during normal database operation are constrained to be 16384 or higher. This ensures that the range 10000&amp;mdash;16383 is free for OIDs assigned automatically by &lt;code&gt;genbki.pl&lt;/code&gt; or during bootstrap. These automatically-assigned OIDs are not considered stable, and may change from one installation to another.</source>
          <target state="translated">일반 데이터베이스 작업 중에 할당 된 OID는 16384 이상으로 제한됩니다. 이 보장하는 범위 10000-16383에 의해 자동으로 할당 OID를위한 무료입니다 &lt;code&gt;genbki.pl&lt;/code&gt; 또는 부트 스트랩 중. 이러한 자동 할당 OID는 안정적인 것으로 간주되지 않으며 설치마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08513f8d6a0456d0e2e3f8053e17f798ea2afa0" translate="yes" xml:space="preserve">
          <source>OLAP</source>
          <target state="translated">OLAP</target>
        </trans-unit>
        <trans-unit id="751cc96735bf8b84aef2fec3e06efb1b1a5b1ccc" translate="yes" xml:space="preserve">
          <source>OLTP</source>
          <target state="translated">OLTP</target>
        </trans-unit>
        <trans-unit id="25e9c7c3a98b268d5dfb9854a9b3f093ee86933f" translate="yes" xml:space="preserve">
          <source>OR &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">또는 함께 &lt;code&gt;tsquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204bd21a2ea07120bf9aa428b287753e7d9939bc" translate="yes" xml:space="preserve">
          <source>ORDBMS</source>
          <target state="translated">ORDBMS</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="b77e714dbd01a80315e52e6a9d94c65e9f359c98" translate="yes" xml:space="preserve">
          <source>Object Identifier</source>
          <target state="translated">객체 식별자</target>
        </trans-unit>
        <trans-unit id="2ebed2ba0d6eed2f88e2d3187c0748eee35c9c48" translate="yes" xml:space="preserve">
          <source>Object Identifier Types</source>
          <target state="translated">객체 식별자 유형</target>
        </trans-unit>
        <trans-unit id="690a335354f7107071acc3fa67c016dc6bc384da" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: oid</source>
          <target state="translated">객체 식별자 유형 : OID</target>
        </trans-unit>
        <trans-unit id="0075fd06325f676dff687ca83f8e432afb05cd0a" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regclass</source>
          <target state="translated">객체 식별자 유형 : regclass</target>
        </trans-unit>
        <trans-unit id="9ff60426c655614fda7aef019d73fd45fb97d826" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regconfig</source>
          <target state="translated">객체 식별자 유형 : regconfig</target>
        </trans-unit>
        <trans-unit id="dfaba8ba7726385dd9aaa48834af168d2f9ceedf" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regdictionary</source>
          <target state="translated">객체 식별자 유형 : 등록</target>
        </trans-unit>
        <trans-unit id="cc8674af1caee1212cf1ad2d15d842446e9a98aa" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regnamespace</source>
          <target state="translated">객체 식별자 유형 : regnamespace</target>
        </trans-unit>
        <trans-unit id="c2b56a3df38b329696180cd377e1ed88251bb409" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoper</source>
          <target state="translated">객체 식별자 유형 : regoper</target>
        </trans-unit>
        <trans-unit id="30c72913cd86047f07f98633a45661ed568c2533" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoperator</source>
          <target state="translated">객체 식별자 유형 : regoperator</target>
        </trans-unit>
        <trans-unit id="a48a31a0bb9251c420e48d22aa7c1d09ca5723bd" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regproc</source>
          <target state="translated">객체 식별자 유형 : regproc</target>
        </trans-unit>
        <trans-unit id="67cdc0df1aaf8b31658af7a6a45b330191b5746d" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regprocedure</source>
          <target state="translated">객체 식별자 유형 : regprocedure</target>
        </trans-unit>
        <trans-unit id="6c6385e5aae8c21dd4c725971f7b3936a95ef63b" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regrole</source>
          <target state="translated">객체 식별자 유형 : regrole</target>
        </trans-unit>
        <trans-unit id="f7695a1c32f9f4d88fc2778bef31cc0d65aad8a7" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regtype</source>
          <target state="translated">객체 식별자 유형 : regtype</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="486ece6dd89f3c4ea297334b48675b716e4268bd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt;: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regrole&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">객체 식별자 (OID)는 PostgreSQL에 의해 내부적으로 다양한 시스템 테이블의 기본 키로 사용됩니다. &lt;code&gt;oid&lt;/code&gt; 유형 은 객체 식별자를 나타냅니다. &lt;code&gt;oid&lt;/code&gt; 에 대한 별칭 유형도 있습니다 : &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regrole&lt;/code&gt; , &lt;code&gt;regnamespace&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; 및 &lt;code&gt;regdictionary&lt;/code&gt; . &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;표 8.26&lt;/a&gt; 은 개요를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e6ffe45f664bbe6f6262859df4e3695e1d12153a" translate="yes" xml:space="preserve">
          <source>Object-Relational Database Management System</source>
          <target state="translated">객체 관계형 데이터베이스 관리 시스템</target>
        </trans-unit>
        <trans-unit id="ec90b7e160c78de5740196cc2532f466404d90bc" translate="yes" xml:space="preserve">
          <source>Objects can have initial privileges either by having those privileges set when the system is initialized (by initdb) or when the object is created during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; and the extension script sets initial privileges using the &lt;code&gt;GRANT&lt;/code&gt; system. Note that the system will automatically handle recording of the privileges during the extension script and that extension authors need only use the &lt;code&gt;GRANT&lt;/code&gt; and &lt;code&gt;REVOKE&lt;/code&gt; statements in their script to have the privileges recorded. The &lt;code&gt;privtype&lt;/code&gt; column indicates if the initial privilege was set by initdb or during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; command.</source>
          <target state="translated">오브젝트는 시스템이 초기화 될 때 (initdb에 의해) 또는 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 중에 오브젝트가 작성 되고 확장 스크립트가 &lt;code&gt;GRANT&lt;/code&gt; 시스템을 사용하여 초기 권한을 설정할 때 해당 권한을 설정하여 초기 권한을 가질 수 있습니다 . 시스템은 확장 스크립트 중에 권한 기록을 자동으로 처리하며 확장 작성자 는 스크립트에서 &lt;code&gt;GRANT&lt;/code&gt; 및 &lt;code&gt;REVOKE&lt;/code&gt; 문만 사용 하여 권한을 기록해야합니다. &lt;code&gt;privtype&lt;/code&gt; 의 초기 특권은 initdb에 의해 또는시 설정된 경우 열을 나타냅니다 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="8d18be902bfa3d762f98290f3d1e8291c77198c6" translate="yes" xml:space="preserve">
          <source>Objects which have initial privileges set by initdb will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'i'&lt;/code&gt;, while objects which have initial privileges set by &lt;code&gt;CREATE EXTENSION&lt;/code&gt; will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'e'&lt;/code&gt;.</source>
          <target state="translated">initdb에 의해 초기 권한이 설정된 오브젝트는 &lt;code&gt;privtype&lt;/code&gt; 이 &lt;code&gt;'i'&lt;/code&gt; 인 항목 을 갖는 반면 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 에 의해 초기 권한이 설정된 오브젝트 는 &lt;code&gt;privtype&lt;/code&gt; 이 &lt;code&gt;'e'&lt;/code&gt; 인 항목을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8f79c201923795ddf3fc3a390dc899926a81383e" translate="yes" xml:space="preserve">
          <source>Objects with equal numbers of pairs are compared in the order:</source>
          <target state="translated">동일한 수의 쌍을 가진 객체는 순서대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="40a4edd85bccc1fb19d69c2e2dabe7dd4292f362" translate="yes" xml:space="preserve">
          <source>Observe how in the traditional ICU locale naming system, the root locale is selected by an empty string.</source>
          <target state="translated">전통적인 ICU 로케일 명명 시스템에서 루트 로케일이 빈 문자열로 어떻게 선택되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="82dae9ce3d89138d44c64eb3de8005375bc20848" translate="yes" xml:space="preserve">
          <source>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.</source>
          <target state="translated">이러한 종류의 부분 인덱스는 공통 값을 미리 결정해야하므로 이러한 부분 인덱스는 변경되지 않는 데이터 분포에 가장 적합합니다. 이러한 인덱스는 새로운 데이터 배포에 맞게 조정하여 가끔씩 재 작성할 수 있지만 유지 보수 노력이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d607df7ca6e658558b5841d4666abffe49980352" translate="yes" xml:space="preserve">
          <source>Observe that this match would not succeed if written as</source>
          <target state="translated">다음과 같이 쓰면이 경기가 성공하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="d177dde8092a5f060f1495243a63f697a9a17705" translate="yes" xml:space="preserve">
          <source>Observe two things about the result set:</source>
          <target state="translated">결과 집합에 대해 두 가지 사항을 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="4201c9715be128e9359f0f8e049514e18476b73a" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;code&gt;N&lt;/code&gt; is now ignored, since the number of value columns is always determined by the calling query</source>
          <target state="translated">사용되지 않는 버전의 &lt;code&gt;crosstab(text)&lt;/code&gt; . 값 열의 개수는 항상 호출 쿼리에 의해 결정되므로 매개 변수 &lt;code&gt;N&lt;/code&gt; 은 이제 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="11744d185f0b82d838b338e8988d902a0140f6b7" translate="yes" xml:space="preserve">
          <source>Obtain a &lt;code&gt;SHARE&lt;/code&gt; lock on a primary key table when going to perform inserts into a foreign key table:</source>
          <target state="translated">외래 키 테이블에 삽입을 수행 할 때 기본 키 테이블에 대한 &lt;code&gt;SHARE&lt;/code&gt; 잠금을 확보 하십시오.</target>
        </trans-unit>
        <trans-unit id="05c7fc189f9bad2f9b668a2a40c5180d608c005f" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock</source>
          <target state="translated">독점 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="019972b3655998bb11d76b53a542ff72a8b76dca" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock if available</source>
          <target state="translated">가능한 경우 독점 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="cbeca9dbec7784436d93a189577fd29e34a7fe37" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock</source>
          <target state="translated">독점적 인 거래 수준 자문 잠금 획득</target>
        </trans-unit>
        <trans-unit id="b51bd7cdf3315df0e1b538d8f77d94955e4c6d83" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock if available</source>
          <target state="translated">가능한 경우 독점적 인 거래 수준 자문 잠금 획득</target>
        </trans-unit>
        <trans-unit id="b1ba75ca9786f988af27bd943f8ef875b87406fc" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock</source>
          <target state="translated">공유 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="4efab6b4a18b953adcf6fcfd9c4e7e2bbeb2b169" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock if available</source>
          <target state="translated">가능한 경우 공유 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="9524c0b6999d2af997e67edd5b67a8f0eafef7e0" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock</source>
          <target state="translated">공유 트랜잭션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="36c2761c3324c27688dc73a65bc20a430c91b936" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock if available</source>
          <target state="translated">가능한 경우 공유 트랜잭션 레벨 권고 잠금 확보</target>
        </trans-unit>
        <trans-unit id="443dac9c78b1145631de0395325a4f37cac34453" translate="yes" xml:space="preserve">
          <source>Obtain the client's operating system user name from the operating system and check if it matches the requested database user name. This is only available for local connections. See &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 클라이언트의 운영 체제 사용자 이름을 확보하여 요청 된 데이터베이스 사용자 이름과 일치하는지 확인하십시오. 로컬 연결에서만 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;auth-peer&quot;&gt;섹션 20.9&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e679373412300b3d7cf749daeaf3997d4726aac" translate="yes" xml:space="preserve">
          <source>Obtain the operating system user name of the client by contacting the ident server on the client and check if it matches the requested database user name. Ident authentication can only be used on TCP/IP connections. When specified for local connections, peer authentication will be used instead. See &lt;a href=&quot;auth-ident&quot;&gt;Section 20.8&lt;/a&gt; for details.</source>
          <target state="translated">클라이언트의 ID 서버에 접속하여 클라이언트의 운영 체제 사용자 이름을 확보하고 요청 된 데이터베이스 사용자 이름과 일치하는지 확인하십시오. ID 인증은 TCP / IP 연결에서만 사용할 수 있습니다. 로컬 연결에 지정된 경우 피어 인증이 대신 사용됩니다. 자세한 내용 &lt;a href=&quot;auth-ident&quot;&gt;은 20.8 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c565c625c5016da01624ee751e9ac2b988301ee" translate="yes" xml:space="preserve">
          <source>Obtaining the next value is done using the &lt;code&gt;nextval()&lt;/code&gt; function instead of the standard's &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression.</source>
          <target state="translated">다음 값을 얻으려면 표준의 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 표현식 대신 &lt;code&gt;nextval()&lt;/code&gt; 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f2c6c6809790186229da7b012c8919a980f66c8" translate="yes" xml:space="preserve">
          <source>Obviously, indexes with non-default sort orderings are a fairly specialized feature, but sometimes they can produce tremendous speedups for certain queries. Whether it's worth maintaining such an index depends on how often you use queries that require a special sort ordering.</source>
          <target state="translated">기본 정렬 순서가 아닌 인덱스는 상당히 특수한 기능이지만 특정 쿼리에 대해 엄청나게 빠른 속도를 낼 수도 있습니다. 이러한 인덱스를 유지할 가치가 있는지 여부는 특별한 정렬 순서가 필요한 쿼리를 얼마나 자주 사용하는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1f89e656ff03a0a31a91974becb3d200ff4b46" translate="yes" xml:space="preserve">
          <source>Obviously, no one should be accessing the clusters during the upgrade. pg_upgrade defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</source>
          <target state="translated">분명히 업그레이드하는 동안 아무도 클러스터에 액세스하지 않아야합니다. 의도하지 않은 클라이언트 연결을 피하기 위해 pg_upgrade는 기본적으로 포트 50432에서 서버를 실행합니다. 이전 클러스터와 새 클러스터가 동시에 실행되지 않으므로 업그레이드를 수행 할 때 두 클러스터 모두에 동일한 포트 번호를 사용할 수 있습니다. 그러나 이전에 실행중인 서버를 확인할 때는 이전 포트 번호와 새 포트 번호가 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="91a6106fff0646feab85327987f859dce96328f8" translate="yes" xml:space="preserve">
          <source>Obviously, pg_restore cannot restore information that is not present in the archive file. For instance, if the archive was made using the &amp;ldquo;dump data as &lt;code&gt;INSERT&lt;/code&gt; commands&amp;rdquo; option, pg_restore will not be able to load the data using &lt;code&gt;COPY&lt;/code&gt; statements.</source>
          <target state="translated">분명히 pg_restore는 아카이브 파일에없는 정보를 복원 할 수 없습니다. 예를 들어, &quot;덤프 데이터를 &lt;code&gt;INSERT&lt;/code&gt; 명령으로&quot;옵션을 사용하여 아카이브를 만든 경우 pg_restore는 &lt;code&gt;COPY&lt;/code&gt; 문을 사용하여 데이터를로드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ea9f0a51f8358360ebe5d226327ee6a6dba47689" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison.</source>
          <target state="translated">분명히 하나 이상의 열 값이 다르면 두 개의 행이 구별되는 것으로 간주됩니다. 이 비교에서 널값은 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0325b2d5f9478c521e0c1edeceeab6be935d2d2e" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules:</source>
          <target state="translated">때로는 영어 조합 규칙을 사용하지만 스페인어 메시지를 사용하는 등 여러 로케일의 규칙을 혼합하는 것이 유용합니다. 이를 지원하기 위해 현지화 규칙의 특정 측면 만 제어하는 ​​로케일 하위 카테고리 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51327aef9866e85ef5b5b2294a28494d2715ae59" translate="yes" xml:space="preserve">
          <source>Oct</source>
          <target state="translated">Oct</target>
        </trans-unit>
        <trans-unit id="87206ae2363483496c099f8c3aac5b4a8ae2a66a" translate="yes" xml:space="preserve">
          <source>October</source>
          <target state="translated">October</target>
        </trans-unit>
        <trans-unit id="c07f133434909a3b139ea6fd5087f84900fccadf" translate="yes" xml:space="preserve">
          <source>Of course, a column can have more than one constraint. Just write the constraints one after another:</source>
          <target state="translated">물론 열에는 둘 이상의 제약 조건이있을 수 있습니다. 제약 조건을 하나씩 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="15554cdfd90fe94a0c248e4f64467a3a5d448ea0" translate="yes" xml:space="preserve">
          <source>Of course, each column must be used with operators appropriate to the index type; clauses that involve other operators will not be considered.</source>
          <target state="translated">물론 각 열은 인덱스 유형에 적합한 연산자와 함께 사용해야합니다. 다른 연산자와 관련된 조항은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cfcf640173f2cee55033307859827db1cc0f9ba" translate="yes" xml:space="preserve">
          <source>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the &lt;code&gt;information_schema&lt;/code&gt; views will report a &lt;code&gt;postgres_fdw&lt;/code&gt; foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</source>
          <target state="translated">물론 원격 테이블을 실제로 업데이트 할 수 없으면 오류가 발생합니다. 이 옵션을 사용하면 주로 원격 서버를 조회하지 않고 로컬로 오류가 발생합니다. 그러나 &lt;code&gt;information_schema&lt;/code&gt; 보기는 원격 서버를 확인하지 않고이 옵션의 설정에 따라 &lt;code&gt;postgres_fdw&lt;/code&gt; 외부 테이블을 업데이트 할 수 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="ac88e35965ca0b1056564e9dfa16bc3a086971ee" translate="yes" xml:space="preserve">
          <source>Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all.</source>
          <target state="translated">물론 일부 SQL 데이터베이스 시스템은 스키마를 전혀 구현하지 않거나 데이터베이스 간 액세스를 제한하여 네임 스페이스 지원을 제공 할 수 있습니다. 해당 시스템으로 작업해야하는 경우 스키마를 전혀 사용하지 않으면 서 이식성을 극대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09f440f59472b164c47e7153b71ff603597271c" translate="yes" xml:space="preserve">
          <source>Of course, the &lt;code&gt;SELECT&lt;/code&gt; statement is compatible with the SQL standard. But there are some extensions and some missing features.</source>
          <target state="translated">물론 &lt;code&gt;SELECT&lt;/code&gt; 문은 SQL 표준과 호환됩니다. 그러나 일부 확장 기능과 누락 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b998cb5ccff7c6a6d09f60a802fba18afa38d81f" translate="yes" xml:space="preserve">
          <source>Of course, the argument of a sequence function can be an expression as well as a constant. If it is a text expression then the implicit coercion will result in a run-time lookup.</source>
          <target state="translated">물론, 시퀀스 함수의 인수는 상수 일뿐만 아니라 표현식 일 수 있습니다. 텍스트 표현식 인 경우 내재 된 강제 변환은 런타임 조회를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="c8ec66919586aa50108f55c55fa32064846f02f9" translate="yes" xml:space="preserve">
          <source>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns.</source>
          <target state="translated">물론 제약 된 열의 수와 유형은 참조 된 열의 수와 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="608089afae6cc6682d178112cb3562d38642d49b" translate="yes" xml:space="preserve">
          <source>Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:</source>
          <target state="translated">물론, 이전의 예는 많이 고안되었습니다. 일반적으로 어떤 종류의 데이터를 저장하는지 테이블과 열에 이름을 지정합니다. 보다 현실적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cdf2e77434f0f6336db99d58530ea7e875d07b42" translate="yes" xml:space="preserve">
          <source>Of course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary between PostgreSQL releases due to planner improvements. In addition, the &lt;code&gt;ANALYZE&lt;/code&gt; command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of &lt;code&gt;ANALYZE&lt;/code&gt;, even if the actual distribution of data in the table has not changed.</source>
          <target state="translated">물론 여기에 표시된 특정 숫자는 관련된 테이블의 실제 내용에 따라 다릅니다. 또한 계획 수의 향상으로 인해 PostgreSQL 릴리스마다 숫자와 선택한 쿼리 전략이 다를 수 있습니다. 또한 &lt;code&gt;ANALYZE&lt;/code&gt; 명령은 무작위 샘플링을 사용하여 데이터 통계를 추정합니다. 따라서 테이블에서 데이터의 실제 분배가 변경되지 않은 경우에도 &lt;code&gt;ANALYZE&lt;/code&gt; 를 새로 실행 한 후 비용 추정치가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a685091dfb5c40427eaec8e993f66849819cf14d" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.19&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;표 9.19에&lt;/a&gt; 설명 된 문자 입력 이스케이프 중 XQuery는 &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; 및 &lt;code&gt;\t&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="1a7f91ef8e30ab71323f7f16c956192d29cee4ea" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;jsonb&lt;/code&gt;, &lt;code&gt;jsonb_ops&lt;/code&gt; is the default. &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports fewer operators but offers better performance for those operators. See &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; for details.</source>
          <target state="translated">형에 대한 두 개의 연산자 클래스 중 &lt;code&gt;jsonb&lt;/code&gt; , &lt;code&gt;jsonb_ops&lt;/code&gt; 은 기본값입니다. &lt;code&gt;jsonb_path_ops&lt;/code&gt; 는 더 적은 연산자를 지원하지만 해당 연산자에 대해 더 나은 성능을 제공합니다. 자세한 내용 &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;은 8.14.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34c9deaa906dcefa70af958d1df36fd494f6477e" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;quad_point_ops&lt;/code&gt; is the default. &lt;code&gt;kd_point_ops&lt;/code&gt; supports the same operators but uses a different index data structure that may offer better performance in some applications.</source>
          <target state="translated">형에 대한 두 개의 연산자 클래스 중 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;quad_point_ops&lt;/code&gt; 은 기본값입니다. &lt;code&gt;kd_point_ops&lt;/code&gt; 는 동일한 연산자를 지원하지만 일부 애플리케이션에서 더 나은 성능을 제공 할 수있는 다른 인덱스 데이터 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ae7fdb11d6c25f66601f3fb8a8f5b8fcc9b0822b" translate="yes" xml:space="preserve">
          <source>Offset from UTC (positive means east of Greenwich)</source>
          <target state="translated">UTC로부터 오프셋 (그리니치의 동쪽을 의미 함)</target>
        </trans-unit>
        <trans-unit id="1981d8aed8642cc19a01ec017cd302822eb99a80" translate="yes" xml:space="preserve">
          <source>Offset to end of free space</source>
          <target state="translated">여유 공간 끝까지 오프셋</target>
        </trans-unit>
        <trans-unit id="e27e1909bffb440ac18ed4f49dfc030d3bf289b3" translate="yes" xml:space="preserve">
          <source>Offset to start of free space</source>
          <target state="translated">여유 공간을 시작하기위한 오프셋</target>
        </trans-unit>
        <trans-unit id="96263ee552b7638e48664d80735a522bd69e2d15" translate="yes" xml:space="preserve">
          <source>Offset to start of special space</source>
          <target state="translated">특수 공간의 시작으로 오프셋</target>
        </trans-unit>
        <trans-unit id="7f9b46694e3dc059ec6a436a3380fe755ceb8f95" translate="yes" xml:space="preserve">
          <source>Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is:</source>
          <target state="translated">종종 다른 사람이 소유 한 스키마를 만들려고 할 것입니다 (이것은 사용자 활동을 잘 정의 된 네임 스페이스로 제한하는 방법 중 하나이기 때문에). 그 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa524be3205ddb773bfe2be8f0cbe395871121b5" translate="yes" xml:space="preserve">
          <source>Okay, the worst has happened and you need to recover from your backup. Here is the procedure:</source>
          <target state="translated">좋습니다. 최악의 상황이 발생하여 백업에서 복구해야합니다. 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16be0330fc822ce35047bcbe410657ce60f50c0e" translate="yes" xml:space="preserve">
          <source>Older Linux kernels do not offer &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt;, but may have a previous version of the same functionality called &lt;code&gt;/proc/self/oom_adj&lt;/code&gt;. This works the same except the disable value is &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt;.</source>
          <target state="translated">이전 리눅스 커널은 제공하지 않습니다 &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt; 만이라는 동일한 기능의 이전 버전있을 수 있습니다 &lt;code&gt;/proc/self/oom_adj&lt;/code&gt; . 비활성화 값은 제외하고이 같은 일 &lt;code&gt;-17&lt;/code&gt; 되지 &lt;code&gt;-1000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced6ddc46443201e8e3d960abac900f5903d1b39" translate="yes" xml:space="preserve">
          <source>Older PostgreSQL versions do not have this setting and always use the client's preferences. This setting is mainly for backward compatibility with those versions. Using the server's preferences is usually better because it is more likely that the server is appropriately configured.</source>
          <target state="translated">이전 PostgreSQL 버전에는이 설정이 없으며 항상 클라이언트 기본 설정을 사용합니다. 이 설정은 주로 해당 버전과의 호환성을 위해 사용됩니다. 서버의 환경 설정을 사용하는 것이 서버가 적절하게 구성되어있을 가능성이 높기 때문에 일반적으로 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b76ff612400899f457b05452321eac3486e8a6ab" translate="yes" xml:space="preserve">
          <source>Oldest unpruned XMAX on page, or zero if none</source>
          <target state="translated">페이지에서 정리되지 않은 가장 오래된 XMAX 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="794b92ddcf68cabe2809fe5836f4849010daf46d" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, 모스크바, 러시아</target>
        </trans-unit>
        <trans-unit id="21c3dce2dbff52b671e09984835bd018b576e577" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Moscow University, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; , 러시아 모스크바 대학교 모스크바</target>
        </trans-unit>
        <trans-unit id="c57ccf7fdc0e782593eaa681140c5d9ba28fcdd1" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;ROW()&lt;/code&gt; syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency.</source>
          <target state="translated">사이클을 인식하기 위해 하나의 필드 만 검사해야하는 일반적인 경우 &lt;code&gt;ROW()&lt;/code&gt; 구문을 생략하십시오 . 따라서 복합 형 배열이 아닌 간단한 배열을 사용하여 효율성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263c5dac706b853afb054876ee3140dcdc435cf6" translate="yes" xml:space="preserve">
          <source>Omitted &lt;code&gt;FROM&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절에서 생략</target>
        </trans-unit>
        <trans-unit id="46b3737570e6db5d4ea7e5047dd8b127387b63f0" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;AS&lt;/code&gt; Key Word</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 키워드 생략</target>
        </trans-unit>
        <trans-unit id="22a45e27f71c292f06706c737b69fd6802e9347f" translate="yes" xml:space="preserve">
          <source>On FreeBSD, IDE drives can be queried using &lt;code&gt;atacontrol&lt;/code&gt; and write caching turned off using &lt;code&gt;hw.ata.wc=0&lt;/code&gt; in &lt;code&gt;/boot/loader.conf&lt;/code&gt;; SCSI drives can be queried using &lt;code&gt;camcontrol identify&lt;/code&gt;, and the write cache both queried and changed using &lt;code&gt;sdparm&lt;/code&gt; when available.</source>
          <target state="translated">FreeBSD에서 &lt;code&gt;atacontrol&lt;/code&gt; 을 사용하여 IDE 드라이브를 쿼리 하고 &lt;code&gt;/boot/loader.conf&lt;/code&gt; 에서 &lt;code&gt;hw.ata.wc=0&lt;/code&gt; 을 사용하여 쓰기 캐싱을 해제 할 수 있습니다 . &lt;code&gt;camcontrol identify&lt;/code&gt; 사용하여 SCSI 드라이브를 쿼리 할 수 ​​있으며 , 사용 가능한 경우 &lt;code&gt;sdparm&lt;/code&gt; 을 사용하여 쓰기 캐시를 쿼리하고 변경 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
