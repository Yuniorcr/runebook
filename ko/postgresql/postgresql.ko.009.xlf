<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="5a4d553a940905a5b45f8f4a9271805f05936143" translate="yes" xml:space="preserve">
          <source>Force reindexdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 reindexdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d704d18558a65a962929acf79610b9c10e0ea21f" translate="yes" xml:space="preserve">
          <source>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">새로운 미리 쓰기 로그 파일로 강제 전환 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="ad34c2643c5ad08a3b8ba0b861d443b8a1146fd4" translate="yes" xml:space="preserve">
          <source>Force vacuumdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 vacuumdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ab1894a9915a1c5bdd4fa99a3c35aa7aef1f3043" translate="yes" xml:space="preserve">
          <source>Forces quoting to be used for all non-&lt;code&gt;NULL&lt;/code&gt; values in each specified column. &lt;code&gt;NULL&lt;/code&gt; output is never quoted. If &lt;code&gt;*&lt;/code&gt; is specified, non-&lt;code&gt;NULL&lt;/code&gt; values will be quoted in all columns. This option is allowed only in &lt;code&gt;COPY TO&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">지정된 각 열에서 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 모든 값에 따옴표를 사용 합니다. &lt;code&gt;NULL&lt;/code&gt; 출력은 인용되지 않습니다. 경우 &lt;code&gt;*&lt;/code&gt; 가 지정되어, 비 &lt;code&gt;NULL&lt;/code&gt; 의 값은 모든 열에서 인용됩니다. 이 옵션은 &lt;code&gt;COPY TO&lt;/code&gt; 및 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용할 때만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e53ee207fccbc10bf771537429c8ceb105018b4c" translate="yes" xml:space="preserve">
          <source>Foreign Data</source>
          <target state="translated">외국 데이터</target>
        </trans-unit>
        <trans-unit id="60b698071b99433356500a6664686a79ff0c576f" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="translated">외부 데이터는 &lt;em&gt;외부 데이터 랩퍼의&lt;/em&gt; 도움으로 액세스됩니다 . 외부 데이터 랩퍼는 외부 데이터 소스와 통신 할 수있는 라이브러리로, 데이터 소스에 연결하고 데이터를 가져 오는 세부 사항을 숨 깁니다. &lt;code&gt;contrib&lt;/code&gt; 모듈 로 사용 가능한 일부 외부 데이터 랩퍼가 있습니다 . &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;부록 F를&lt;/a&gt; 참조하십시오 . 다른 종류의 외부 데이터 래퍼는 타사 제품으로 제공 될 수 있습니다. 기존 외부 데이터 래퍼 중 어느 것도 사용자 요구에 맞지 않으면 직접 작성할 수 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;56 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94c0cd02df3f1a32213c26c15ceb6bc33046efb5" translate="yes" xml:space="preserve">
          <source>Foreign key deletion action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">외래 키 삭제 동작 코드 : &lt;code&gt;a&lt;/code&gt; = 동작 없음, &lt;code&gt;r&lt;/code&gt; = 제한, &lt;code&gt;c&lt;/code&gt; = 계단식, &lt;code&gt;n&lt;/code&gt; = 널 설정, &lt;code&gt;d&lt;/code&gt; = 기본값 설정</target>
        </trans-unit>
        <trans-unit id="67ed786663de0061ba336e549d3d7d184b09ab90" translate="yes" xml:space="preserve">
          <source>Foreign key match type: &lt;code&gt;f&lt;/code&gt; = full, &lt;code&gt;p&lt;/code&gt; = partial, &lt;code&gt;s&lt;/code&gt; = simple</source>
          <target state="translated">외래 키 일치 유형 : &lt;code&gt;f&lt;/code&gt; = 전체, &lt;code&gt;p&lt;/code&gt; = 부분, &lt;code&gt;s&lt;/code&gt; = 단순</target>
        </trans-unit>
        <trans-unit id="f7223fe60c8520d1d8c5dd54e60a3a21d67aff2e" translate="yes" xml:space="preserve">
          <source>Foreign key update action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">외래 키 업데이트 동작 코드 : &lt;code&gt;a&lt;/code&gt; = 동작 없음, &lt;code&gt;r&lt;/code&gt; = 제한, &lt;code&gt;c&lt;/code&gt; = 캐스케이드, &lt;code&gt;n&lt;/code&gt; = 널 설정, &lt;code&gt;d&lt;/code&gt; = 기본값 설정</target>
        </trans-unit>
        <trans-unit id="65a5d0add327edf5ad461c0cb7f6054d85e3b0e7" translate="yes" xml:space="preserve">
          <source>Foreign server specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 서버 별 옵션</target>
        </trans-unit>
        <trans-unit id="b1b45f3e264a3f3e8e58872fe892f43e82136b90" translate="yes" xml:space="preserve">
          <source>Foreign table options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 테이블 옵션</target>
        </trans-unit>
        <trans-unit id="a914bd9dafd1ce6150ce31452c647084bd0851ab" translate="yes" xml:space="preserve">
          <source>Foreign tables (see &lt;a href=&quot;ddl-foreign-data&quot;&gt;Section 5.12&lt;/a&gt;) can also be part of inheritance hierarchies, either as parent or child tables, just as regular tables can be. If a foreign table is part of an inheritance hierarchy then any operations not supported by the foreign table are not supported on the whole hierarchy either.</source>
          <target state="translated">외래 테이블 ( &lt;a href=&quot;ddl-foreign-data&quot;&gt;5.12 절&lt;/a&gt; 참조 )은 일반 테이블과 마찬가지로 부모 또는 자식 테이블과 같은 상속 계층 구조의 일부일 수 있습니다. 외래 테이블이 상속 계층의 일부인 경우 외래 테이블에서 지원하지 않는 작업은 전체 계층에서도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f355c9e7f0aaa375694a97f071442929b8bef72d" translate="yes" xml:space="preserve">
          <source>Foreign tables are analyzed only when explicitly selected. Not all foreign data wrappers support &lt;code&gt;ANALYZE&lt;/code&gt;. If the table's wrapper does not support &lt;code&gt;ANALYZE&lt;/code&gt;, the command prints a warning and does nothing.</source>
          <target state="translated">외부 테이블은 명시 적으로 선택된 경우에만 분석됩니다. 모든 외부 데이터 랩퍼가 &lt;code&gt;ANALYZE&lt;/code&gt; 를 지원하지는 않습니다 . 테이블의 랩퍼가 &lt;code&gt;ANALYZE&lt;/code&gt; 를 지원하지 않으면 명령이 경고를 표시하고 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="114810936e2e203f850dfc30c1a7c22dda77dc02" translate="yes" xml:space="preserve">
          <source>Foreign tables can have generated columns. See &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for details.</source>
          <target state="translated">외부 테이블은 열을 생성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="85799ef6669eba496b7c90dd087afbef34699725" translate="yes" xml:space="preserve">
          <source>Foreign-data wrapper specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 데이터 래퍼 특정 옵션</target>
        </trans-unit>
        <trans-unit id="8340dbc9e3b7c8b79fc57d1ea821c4dd6ab2e45a" translate="yes" xml:space="preserve">
          <source>Fork number within the relation; see &lt;code&gt;include/common/relpath.h&lt;/code&gt;</source>
          <target state="translated">관계 내의 포크 번호; &lt;code&gt;include/common/relpath.h&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="bfff5fab0567decaa660bb51d870a4a558ade9bd" translate="yes" xml:space="preserve">
          <source>Form feed (ASCII 12)</source>
          <target state="translated">용지 공급 (ASCII 12)</target>
        </trans-unit>
        <trans-unit id="2186cd568d6445c67ce20f9b2564241918cf9481" translate="yes" xml:space="preserve">
          <source>Format arguments according to a format string. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;. See &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;.</source>
          <target state="translated">형식 문자열에 따라 인수를 형식화하십시오. 이 함수는 C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 유사합니다 . &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;섹션 9.4.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="2f10703a114eeb65e11771dfbfc8cbc068e4d983" translate="yes" xml:space="preserve">
          <source>Format of the &lt;code&gt;.dict&lt;/code&gt; file is:</source>
          <target state="translated">&lt;code&gt;.dict&lt;/code&gt; 파일의 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d32d1fc793b4203a324b693b7b245d9ad6dbbf1f" translate="yes" xml:space="preserve">
          <source>Format specifiers are introduced by a &lt;code&gt;%&lt;/code&gt; character and have the form</source>
          <target state="translated">형식 지정자는 &lt;code&gt;%&lt;/code&gt; 문자 로 소개되며 형식은</target>
        </trans-unit>
        <trans-unit id="ac4e3c929fdec4f6080024051a0ba50e01f4af70" translate="yes" xml:space="preserve">
          <source>Formatting Functions</source>
          <target state="translated">서식 기능</target>
        </trans-unit>
        <trans-unit id="27f02bbdc243505380802862dfc269e6f51a4b71" translate="yes" xml:space="preserve">
          <source>Formatting of currency amounts</source>
          <target state="translated">통화 금액 서식</target>
        </trans-unit>
        <trans-unit id="3117b3b2c7e85f24cb15daec9ea8d347a5a664b1" translate="yes" xml:space="preserve">
          <source>Formatting of dates and times</source>
          <target state="translated">날짜 및 시간 형식</target>
        </trans-unit>
        <trans-unit id="860fd1b538482a0032ad8bac4633d0f2e1fcba7b" translate="yes" xml:space="preserve">
          <source>Formatting of numbers</source>
          <target state="translated">숫자 서식</target>
        </trans-unit>
        <trans-unit id="6a1f6ab661d4c193244f17d409e7e72bd4d570ee" translate="yes" xml:space="preserve">
          <source>Fortunately, PostgreSQL has the ability to combine multiple indexes (including multiple uses of the same index) to handle cases that cannot be implemented by single index scans. The system can form &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; conditions across several index scans. For example, a query like &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; could be broken down into four separate scans of an index on &lt;code&gt;x&lt;/code&gt;, each scan using one of the query clauses. The results of these scans are then ORed together to produce the result. Another example is that if we have separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, one possible implementation of a query like &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; is to use each index with the appropriate query clause and then AND together the index results to identify the result rows.</source>
          <target state="translated">다행스럽게도 PostgreSQL에는 단일 인덱스 스캔으로 구현할 수없는 경우를 처리하기 위해 여러 인덱스 (동일 인덱스의 여러 사용 포함)를 결합 할 수 있습니다. 시스템은 여러 인덱스 스캔에서 &lt;code&gt;AND&lt;/code&gt; 및 &lt;code&gt;OR&lt;/code&gt; 조건을 형성 할 수 있습니다 . 예를 들어 &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; 와 같은 쿼리는 각 쿼리 절 중 하나를 사용하여 &lt;code&gt;x&lt;/code&gt; 에서 인덱스에 대한 4 개의 개별 인덱스 스캔으로 나눌 수 있습니다 . 그런 다음 이러한 스캔 결과를 OR로 연결하여 결과를 생성합니다. 또 다른 예는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 별도의 인덱스가있는 경우 &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; 같은 쿼리 구현이 가능하다는 것입니다 적절한 쿼리 절과 함께 각 인덱스를 사용한 다음 인덱스 결과를 함께 사용하여 결과 행을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="7a4530052e4c5506e1ca3c7fe0019b4ab8ad7aeb" translate="yes" xml:space="preserve">
          <source>Forward transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드를위한 순방향 전환 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="f6bf4e66e6e60c9947bd8c75fee01c881afbe844" translate="yes" xml:space="preserve">
          <source>Fourth, verify your shell is operating in the &lt;code&gt;unconfined_t&lt;/code&gt; domain:</source>
          <target state="translated">넷째, 쉘이 &lt;code&gt;unconfined_t&lt;/code&gt; 도메인 에서 작동하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b72b0d434a6da3b7a140f72c4533ea003e1049d" translate="yes" xml:space="preserve">
          <source>Fraction of column entries that are null</source>
          <target state="translated">널 (null) 인 열 항목의 비율</target>
        </trans-unit>
        <trans-unit id="05336909662a05ee4c216375dd2926cd06ca7ff1" translate="yes" xml:space="preserve">
          <source>Free Space Map</source>
          <target state="translated">여유 공간지도</target>
        </trans-unit>
        <trans-unit id="8d1442f2468898b3b97983d4c108633f0dd9704b" translate="yes" xml:space="preserve">
          <source>Free space</source>
          <target state="translated">자유 공간</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="eba92e8cbbcf79124e18b38dc9296cb1e7b3c90c" translate="yes" xml:space="preserve">
          <source>FreeBSD also allows changing the time source on the fly, and it logs information about the timer selected during boot:</source>
          <target state="translated">FreeBSD는 또한 시간 소스를 즉시 변경할 수 있으며 부팅 중에 선택된 타이머에 대한 정보를 기록합니다 :</target>
        </trans-unit>
        <trans-unit id="163ea5dad4eb636b98f8ad7f2021b2c2146c890b" translate="yes" xml:space="preserve">
          <source>FreeBSD libcrypt</source>
          <target state="translated">FreeBSD libcrypt</target>
        </trans-unit>
        <trans-unit id="28073e04cfc0b55e307bd7ab2f2fab043889d334" translate="yes" xml:space="preserve">
          <source>FreeBSD versions before 4.0 work like old OpenBSD (see below).</source>
          <target state="translated">4.0 이전의 FreeBSD 버전은 이전 OpenBSD처럼 작동합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="bbd6e32ee1326237814b697269b4368033d50d2f" translate="yes" xml:space="preserve">
          <source>Fri</source>
          <target state="translated">Fri</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="0092eefda9395145cd29888b2348888692bc90be" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the &lt;code&gt;ALTER TABLE&lt;/code&gt; statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the &lt;code&gt;ALTER TABLE&lt;/code&gt; very fast even on large tables.</source>
          <target state="translated">PostgreSQL 11부터 상수 기본값을 가진 열을 추가한다고해서 &lt;code&gt;ALTER TABLE&lt;/code&gt; 문을 실행할 때 테이블의 각 행을 업데이트 할 필요가 없습니다 . 대신, 다음에 행에 액세스 할 때 기본값이 리턴되고 테이블을 다시 쓸 때 적용되므로 대형 테이블에서도 &lt;code&gt;ALTER TABLE&lt;/code&gt; 이 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="74866cf8a85ad43b25b0fa833b5c4a9e7721fc2f" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 8.3 on, there is XML-related functionality based on the SQL/XML standard in the core server. That functionality covers XML syntax checking and XPath queries, which is what this module does, and more, but the API is not at all compatible. It is planned that this module will be removed in a future version of PostgreSQL in favor of the newer standard API, so you are encouraged to try converting your applications. If you find that some of the functionality of this module is not available in an adequate form with the newer API, please explain your issue to &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; so that the deficiency can be addressed.</source>
          <target state="translated">PostgreSQL 8.3부터 코어 서버에는 SQL / XML 표준을 기반으로하는 XML 관련 기능이 있습니다. 이 기능은이 모듈이하는 XML 구문 검사 및 XPath 쿼리를 다루지 만 API는 전혀 호환되지 않습니다. 이 표준은 최신 표준 API를 위해 향후 PostgreSQL 버전에서 제거 될 예정이므로 애플리케이션 변환을 시도하는 것이 좋습니다. 이 모듈의 일부 기능이 최신 API와 함께 적절한 형태로 제공되지 않는 경우 결함을 해결할 수 있도록 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; 문제를 설명하십시오 .</target>
        </trans-unit>
        <trans-unit id="278d8abdb35f5b8d4b7f92c6d932b66d8fe44745" translate="yes" xml:space="preserve">
          <source>From experience, values in the thousands (e.g., 5000 &amp;mdash; 20000) work well.</source>
          <target state="translated">경험상 수천의 값 (예 : 5000 &amp;mdash; 20000)이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9f490fca8caa246230fe49e0dcc7c45a0810a07" translate="yes" xml:space="preserve">
          <source>From the point of view of the issuing session, &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is not unlike a &lt;code&gt;ROLLBACK&lt;/code&gt; command: after executing it, there is no active current transaction, and the effects of the prepared transaction are no longer visible. (The effects will become visible again if the transaction is committed.)</source>
          <target state="translated">발행 세션의 관점에서 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 &lt;code&gt;ROLLBACK&lt;/code&gt; 명령 과 다르지 않습니다 . 실행 후 활성 현재 트랜잭션이 없으며 준비된 트랜잭션의 효과가 더 이상 표시되지 않습니다. 트랜잭션이 커밋되면 효과가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2047a74f4a2930f4b44969e9f4cae7215400249e" translate="yes" xml:space="preserve">
          <source>Frontend code should not include any &lt;code&gt;pg_xxx.h&lt;/code&gt; catalog header file, as these files may contain C code that won't compile outside the backend. (Typically, that happens because these files also contain declarations for functions in &lt;code&gt;src/backend/catalog/&lt;/code&gt; files.) Instead, frontend code may include the corresponding generated &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header, which will contain OID &lt;code&gt;#define&lt;/code&gt;s and any other data that might be of use on the client side. If you want macros or other code in a catalog header to be visible to frontend code, write &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; around that section to instruct &lt;code&gt;genbki.pl&lt;/code&gt; to copy that section to the &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header.</source>
          <target state="translated">프런트 엔드 코드에는 &lt;code&gt;pg_xxx.h&lt;/code&gt; 카탈로그 헤더 파일이 포함되지 않아야 합니다. 이러한 파일에는 백엔드 외부에서 컴파일되지 않는 C 코드가 포함될 수 있습니다. 일반적으로 이러한 파일에는 &lt;code&gt;src/backend/catalog/&lt;/code&gt; 파일의 함수에 대한 선언이 포함되어 있기 때문에 발생 합니다. 대신 프런트 엔드 코드에는 해당 생성 된 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 헤더 가 포함될 수 있습니다.이 헤더에는 OID &lt;code&gt;#define&lt;/code&gt; 및 기타 데이터가 포함될 수 있습니다. 클라이언트 측에서 사용하십시오. 카탈로그 헤더의 매크로 또는 기타 코드를 프론트 엔드 코드에 표시하려면 &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; 를 해당 섹션 주위 에 작성하여 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 해당 섹션을 &lt;code&gt;genbki.pl&lt;/code&gt; 에 복사 하도록 지시 하십시오 . 헤더.</target>
        </trans-unit>
        <trans-unit id="5342caa1027afd1b462e71637b0394a8eb14ac7b" translate="yes" xml:space="preserve">
          <source>Frontend/Backend Protocol</source>
          <target state="translated">프론트 엔드 / 백엔드 프로토콜</target>
        </trans-unit>
        <trans-unit id="6b2e86b36efeac1ca193b435611b528921adc671" translate="yes" xml:space="preserve">
          <source>Full Text Search</source>
          <target state="translated">전문 검색</target>
        </trans-unit>
        <trans-unit id="58bab05efd3bb13a137c704cfe50139caf2da01d" translate="yes" xml:space="preserve">
          <source>Full Text Searching (or just &lt;em&gt;text search&lt;/em&gt;) provides the capability to identify natural-language &lt;em&gt;documents&lt;/em&gt; that satisfy a &lt;em&gt;query&lt;/em&gt;, and optionally to sort them by relevance to the query. The most common type of search is to find all documents containing given &lt;em&gt;query terms&lt;/em&gt; and return them in order of their &lt;em&gt;similarity&lt;/em&gt; to the query. Notions of &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;similarity&lt;/code&gt; are very flexible and depend on the specific application. The simplest search considers &lt;code&gt;query&lt;/code&gt; as a set of words and &lt;code&gt;similarity&lt;/code&gt; as the frequency of query words in the document.</source>
          <target state="translated">전체 텍스트 검색 (또는 &lt;em&gt;텍스트 검색&lt;/em&gt; )은 &lt;em&gt;쿼리&lt;/em&gt; 를 만족하는 자연어 &lt;em&gt;문서&lt;/em&gt; 를 식별 하고 선택적으로 &lt;em&gt;쿼리&lt;/em&gt; 와 관련하여 &lt;em&gt;문서&lt;/em&gt; 를 정렬 하는 기능을 제공합니다 . 가장 일반적인 검색 유형은 주어진 &lt;em&gt;검색어를&lt;/em&gt; 포함하는 모든 문서를 찾아서 해당 &lt;em&gt;검색어&lt;/em&gt; 와 &lt;em&gt;유사한&lt;/em&gt; 순서로 반환하는 것입니다 . &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;similarity&lt;/code&gt; 개념 은 매우 유연하며 특정 응용 프로그램에 따라 다릅니다. 가장 간단한 검색은 &lt;code&gt;query&lt;/code&gt; 를 단어 집합으로 간주 하고 문서의 쿼리 단어 빈도 와 &lt;code&gt;similarity&lt;/code&gt; 을 고려 합니다 .</target>
        </trans-unit>
        <trans-unit id="db82b334faa95ac9dd9f6513348aba4908da1917" translate="yes" xml:space="preserve">
          <source>Full knowledge of running transactions is required before snapshots can be taken. Transactions that use large numbers of subtransactions (currently greater than 64) will delay the start of read only connections until the completion of the longest running write transaction. If this situation occurs, explanatory messages will be sent to the server log.</source>
          <target state="translated">스냅 샷을 작성하려면 트랜잭션 실행에 대한 모든 지식이 필요합니다. 많은 수의 서브 트랜잭션 (현재 64보다 큰)을 사용하는 트랜잭션은 가장 오래 실행되는 쓰기 트랜잭션이 완료 될 때까지 읽기 전용 연결 시작을 지연시킵니다. 이 상황이 발생하면 설명 메시지가 서버 로그로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89b5598c4c2f96620f236425e65a764b4e0c" translate="yes" xml:space="preserve">
          <source>Full path name of the configuration file</source>
          <target state="translated">구성 파일의 전체 경로 이름</target>
        </trans-unit>
        <trans-unit id="f75d588686a67b50b8825a6ec9a2cd0fa788d6f1" translate="yes" xml:space="preserve">
          <source>Full text indexing allows documents to be &lt;em&gt;preprocessed&lt;/em&gt; and an index saved for later rapid searching. Preprocessing includes:</source>
          <target state="translated">전체 텍스트 인덱싱을 통해 문서를 &lt;em&gt;사전 처리&lt;/em&gt; 하고 나중에 빠른 검색을 위해 인덱스를 저장할 수 있습니다 . 전처리에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1e173192dc3f0eff1cb3f86ab840c4e44f26a1a2" translate="yes" xml:space="preserve">
          <source>Full text searching in PostgreSQL is based on the match operator &lt;code&gt;@@&lt;/code&gt;, which returns &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;tsvector&lt;/code&gt; (document) matches a &lt;code&gt;tsquery&lt;/code&gt; (query). It doesn't matter which data type is written first:</source>
          <target state="translated">PostgreSQL에서 전체 텍스트 검색은 일치 연산자 &lt;code&gt;@@&lt;/code&gt; 을 기반으로하며 , &lt;code&gt;tsvector&lt;/code&gt; (문서)가 &lt;code&gt;tsquery&lt;/code&gt; (쿼리) 와 일치하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 어떤 데이터 유형이 먼저 작성되는지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31ad0600481ef9dcfec15d2c9583987bbeea5538" translate="yes" xml:space="preserve">
          <source>Full time zone name</source>
          <target state="translated">정규 시간대 이름</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="199b395518a17474f39a98683e459c8710d22bf0" translate="yes" xml:space="preserve">
          <source>Function (degrees)</source>
          <target state="translated">기능 (도)</target>
        </trans-unit>
        <trans-unit id="c4cdc4b98800828d365361d7093d5e13c470e528" translate="yes" xml:space="preserve">
          <source>Function (radians)</source>
          <target state="translated">기능 (라디안)</target>
        </trans-unit>
        <trans-unit id="e3ebe4e72fe78109751ae6020102e21b46343c0b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="translated">&lt;code&gt;concat_lower_or_upper&lt;/code&gt; 함수 에는 두 개의 필수 매개 변수 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 가 있습니다. 또한 기본적으로 &lt;code&gt;false&lt;/code&gt; 로 설정 되는 선택적 매개 변수 &lt;code&gt;uppercase&lt;/code&gt; 가 있습니다. 및 &lt;code&gt;b&lt;/code&gt; 입력 연접하고, 상하 방향 어느 쪽의 케이스에 따라 강제한다 &lt;code&gt;uppercase&lt;/code&gt; 파라미터. 이 함수 정의의 나머지 세부 사항은 여기서 중요하지 않습니다 ( 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;37 장&lt;/a&gt; 참조 ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9485768ec808a8458b8061522775420e2a0d736" translate="yes" xml:space="preserve">
          <source>Function Calls in &lt;code&gt;FROM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="5cd7aa6580361c1c90294750468e2a6e5d51165d" translate="yes" xml:space="preserve">
          <source>Function Security</source>
          <target state="translated">기능 보안</target>
        </trans-unit>
        <trans-unit id="307d58da1cb5c708acf50f78b41a528827c81cf8" translate="yes" xml:space="preserve">
          <source>Function calls</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="8b07e5d5a0f30facf481faff6183bfd24366f034" translate="yes" xml:space="preserve">
          <source>Function calls can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. When the optional &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.</source>
          <target state="translated">함수 호출은 &lt;code&gt;FROM&lt;/code&gt; 절에 나타날 수 있습니다 . (결과 세트를 리턴하는 함수에 특히 유용하지만 모든 함수를 사용할 수 있습니다.) 이는 단일 &lt;code&gt;SELECT&lt;/code&gt; 명령 이 지속되는 동안 함수의 출력이 임시 테이블로 작성된 것처럼 작동합니다 . 선택적 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 함수 호출에 추가되면 모든 행의 번호가 지정된 모든 함수의 출력 열 뒤에 새 열이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b4946fa700c9eda6e438f9d998236ae26798c94a" translate="yes" xml:space="preserve">
          <source>Function is a security definer (i.e., a &amp;ldquo;setuid&amp;rdquo; function)</source>
          <target state="translated">함수는 보안 정의 자입니다 (예 : &quot;setuid&quot;함수)</target>
        </trans-unit>
        <trans-unit id="716c6238c1da557cf03815f10e855bae3322359c" translate="yes" xml:space="preserve">
          <source>Function returns a set (i.e., multiple values of the specified data type)</source>
          <target state="translated">함수는 집합 (예 : 지정된 데이터 유형의 여러 값)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23fbe0cb5a01469d890d631e094cc17384405a30" translate="yes" xml:space="preserve">
          <source>Function returns null if any call argument is null. In that case the function won't actually be called at all. Functions that are not &amp;ldquo;strict&amp;rdquo; must be prepared to handle null inputs.</source>
          <target state="translated">호출 인수가 널이면 함수는 널을 리턴합니다. 이 경우 함수가 실제로 호출되지 않습니다. &quot;엄격한&quot;기능이 아닌 함수는 널 입력을 처리하도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fd90f4b1717187c9f3e3d19223db85d2f734625" translate="yes" xml:space="preserve">
          <source>Function that implements this operator</source>
          <target state="translated">이 연산자를 구현하는 함수</target>
        </trans-unit>
        <trans-unit id="3d160cc011b485e39a85d5d485371501ec7cfb5f" translate="yes" xml:space="preserve">
          <source>Function's local settings for run-time configuration variables</source>
          <target state="translated">런타임 구성 변수에 대한 기능의 로컬 설정</target>
        </trans-unit>
        <trans-unit id="72f655d0260fed163ce26bf8c073ff029ead93e0" translate="yes" xml:space="preserve">
          <source>Functional Dependencies</source>
          <target state="translated">기능적 의존성</target>
        </trans-unit>
        <trans-unit id="5ff8dd38721f013a6f2f4a7b0736888d581a5d95" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="translated">함수 종속성은 현재 열을 상수 값과 비교하는 단순 동등 조건을 고려할 때만 적용됩니다. 두 열을 비교하거나 열을 식과 비교하는 등가 조건이나 범위 절, &lt;code&gt;LIKE&lt;/code&gt; 또는 다른 유형의 조건에 대한 추정값을 개선하는 데 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1d8fc0143ef31c2eddcaedc63b8975839dcb0a6" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics</source>
          <target state="translated">기능적 의존성 통계</target>
        </trans-unit>
        <trans-unit id="66e4b5d56651ee62066b47e8179cf0572f0a44de" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics, serialized as &lt;code&gt;pg_dependencies&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;pg_dependencies&lt;/code&gt; 유형으로 직렬화되는 기능 종속성 통계</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="4bc6ed2a77aad7bfa2b82a40e38f2ba52fbf90bc" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt; are available for adjusting days and hours that overflow their normal ranges.</source>
          <target state="translated">&lt;code&gt;justify_days&lt;/code&gt; 및 &lt;code&gt;justify_hours&lt;/code&gt; 함수 는 정상 범위를 초과하는 요일 및 시간을 조정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be003abde8f2ab71ad33e1cc06ea3dd303feedda" translate="yes" xml:space="preserve">
          <source>Functions and Operators</source>
          <target state="translated">함수와 연산자</target>
        </trans-unit>
        <trans-unit id="c65bb1eea1a55d451d6926238ca1817228c00025" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g. a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="translated">함수 및 집계는 데이터베이스에 쓰거나 시퀀스에 액세스하거나 트랜잭션 상태를 일시적으로 변경하더라도 (예 : 오류를 포착하기 위해 &lt;code&gt;EXCEPTION&lt;/code&gt; 블록을 설정하는 PL / pgSQL 함수 ) 설정을 영구적으로 변경하는 경우 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 로 표시되어야합니다 . 마찬가지로, 함수가 시스템에서 작업자간에 동기화 할 수없는 임시 테이블, 클라이언트 연결 상태, 커서, 준비된 명령문 또는 기타 백엔드 로컬 상태에 액세스하는 경우 함수는 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 로 표시되어야합니다 . 예를 들어 &lt;code&gt;setseed&lt;/code&gt; 및 &lt;code&gt;random&lt;/code&gt; 은이 마지막 이유로 병렬 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe9555fcfd38cd02c2b84229962727f96f4f2eb" translate="yes" xml:space="preserve">
          <source>Functions and most operators return &lt;code&gt;NULL&lt;/code&gt; on &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">함수와 대부분의 연산자 는 &lt;code&gt;NULL&lt;/code&gt; 입력 에서 NULL을 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f265f85b070748c539b48bb2df1919c8d0132ab" translate="yes" xml:space="preserve">
          <source>Functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. The path evaluation result to be filtered is denoted by the &lt;code&gt;@&lt;/code&gt; variable. To refer to a JSON element stored at a lower nesting level, add one or more accessor operators after &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">필터 표현식에 사용할 수있는 함수와 연산자는 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;표 9.49에&lt;/a&gt; 나열되어 있습니다. 필터링 될 경로 평가 결과는 &lt;code&gt;@&lt;/code&gt; 변수 로 표시됩니다 . 하위 중첩 수준에 저장된 JSON 요소를 참조하려면 &lt;code&gt;@&lt;/code&gt; 뒤에 하나 이상의 접근 자 연산자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="898ae4ce80d1416da1e82be5528ff4ee3420d0cc" translate="yes" xml:space="preserve">
          <source>Functions are provided to support input in latitude and longitude (in degrees), to support output of latitude and longitude, to calculate the great circle distance between two points and to easily specify a bounding box usable for index searches.</source>
          <target state="translated">위도와 경도 입력을 지원하고 위도와 경도의 출력을 지원하고 두 점 사이의 큰 원거리를 계산하고 인덱스 검색에 사용할 수있는 경계 상자를 쉽게 지정할 수있는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="363d6f73b8773f17e3ee7b55c329af36a576dd3e" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo data types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="translated">C로 코딩 된 함수 (내장 또는 동적로드 여부)는 이러한 의사 데이터 유형을 승인하거나 리턴하도록 선언 될 수 있습니다. 의사 유형이 인수 유형으로 사용될 때 함수가 안전하게 작동하도록하는 것은 함수 작성자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="357d435e84354e072901789e999d5e8184ddfdf6" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the types &lt;code&gt;anyelement&lt;/code&gt;, &lt;code&gt;anyarray&lt;/code&gt;, &lt;code&gt;anynonarray&lt;/code&gt;, &lt;code&gt;anyenum&lt;/code&gt;, and &lt;code&gt;anyrange&lt;/code&gt;.</source>
          <target state="translated">절차 언어로 코딩 된 함수는 구현 언어에서 허용하는 의사 유형 만 사용할 수 있습니다. 현재 대부분의 절차 언어는 의사 유형을 인수 유형으로 사용하는 것을 금지 하고 결과 유형 ( 함수가 트리거 또는 이벤트 트리거로 사용되는 경우 &lt;code&gt;trigger&lt;/code&gt; 또는 &lt;code&gt;event_trigger&lt;/code&gt; ) 으로 &lt;code&gt;void&lt;/code&gt; 및 &lt;code&gt;record&lt;/code&gt; 만 허용합니다 . 일부는 &lt;code&gt;anyelement&lt;/code&gt; , &lt;code&gt;anyarray&lt;/code&gt; , &lt;code&gt;anynonarray&lt;/code&gt; , &lt;code&gt;anyenum&lt;/code&gt; 및 &lt;code&gt;anyrange&lt;/code&gt; 유형을 사용하여 다형성 함수를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="4a3e904c1371583b52ebdd3a3d3f52a9437f4a8d" translate="yes" xml:space="preserve">
          <source>Functions run inside the backend server process with the operating system permissions of the database server daemon. If the programming language used for the function allows unchecked memory accesses, it is possible to change the server's internal data structures. Hence, among many other things, such functions can circumvent any system access controls. Function languages that allow such access are considered &amp;ldquo;untrusted&amp;rdquo;, and PostgreSQL allows only superusers to create functions written in those languages.</source>
          <target state="translated">함수는 데이터베이스 서버 디먼의 운영 체제 권한으로 백엔드 서버 프로세스 내에서 실행됩니다. 함수에 사용 된 프로그래밍 언어가 검사되지 않은 메모리 액세스를 허용하는 경우 서버의 내부 데이터 구조를 변경할 수 있습니다. 따라서, 많은 다른 것들 중에서도, 그러한 기능들은 모든 시스템 액세스 제어를 우회 할 수있다. 이러한 액세스를 허용하는 함수 언어는 &quot;신뢰할 수없는&quot;것으로 간주되며 PostgreSQL에서는 수퍼 유저 만 해당 언어로 작성된 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425b58ada88d6e2c4cd54b7ad94f94b6cfbbbdae" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g. &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g. &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="translated">함수는 데이터베이스 상태를 수정하거나 서브 트랜잭션 사용과 같이 트랜잭션을 변경하거나 시퀀스에 액세스하거나 설정을 지속적으로 변경하려는 경우 (예 : &lt;code&gt;setval&lt;/code&gt; ) 병렬 안전하지 않은 레이블로 표시해야합니다 . 시스템이 병렬 모드에서 동기화 할 수없는 임시 테이블, 클라이언트 연결 상태, 커서, 준비된 명령문 또는 기타 백엔드 로컬 상태에 액세스하는 경우 병렬 제한으로 레이블되어야합니다 (예 : &lt;code&gt;setseed&lt;/code&gt; ).다른 프로세스에서 변경 한 내용은 리더에 반영되지 않으므로 그룹 리더가 아닌 다른 사람은 실행할 수 없습니다. 일반적으로 함수가 제한되거나 안전하지 않을 때 안전하다고 레이블이 지정되거나 실제로 안전하지 않을 때 제한됨으로 레이블이 지정되면 병렬 쿼리에 사용될 때 오류가 발생하거나 잘못된 응답을 생성 할 수 있습니다. 시스템이 임의의 C 코드로부터 자신을 보호 할 방법이 없기 때문에 C 언어 함수는 이론적으로 잘못 레이블이 지정되면 완전히 정의되지 않은 동작을 나타낼 수 있지만, 대부분의 경우 결과는 다른 함수보다 나쁘지 않습니다. &lt;code&gt;UNSAFE&lt;/code&gt; 하지 않은 경우, 함수는 UNSAFE 로 레이블되어야합니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b84230860ab5761ae6c39a0cf038afa0e0d25690" translate="yes" xml:space="preserve">
          <source>Functions that display information about &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bits are much more costly than those that only consult the visibility map, because they must read the relation's data blocks rather than only the (much smaller) visibility map. Functions that check the relation's data blocks are similarly expensive.</source>
          <target state="translated">&lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 비트 에 대한 정보를 표시하는 함수 는 가시성 맵만 참조하는 것보다 훨씬 비쌉니다. 가시성 맵이 아닌 관계형 데이터 블록을 읽어야하기 때문입니다. 관계의 데이터 블록을 검사하는 함수도 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="bdbee713b789a01d106896990329fe65f45aec42" translate="yes" xml:space="preserve">
          <source>Functions that have default values for parameters are considered to match any call that omits zero or more of the defaultable parameter positions. If more than one such function matches a call, the one appearing earliest in the search path is used. If there are two or more such functions in the same schema with identical parameter types in the non-defaulted positions (which is possible if they have different sets of defaultable parameters), the system will not be able to determine which to prefer, and so an &amp;ldquo;ambiguous function call&amp;rdquo; error will result if no better match to the call can be found.</source>
          <target state="translated">매개 변수의 기본값이있는 함수는 0 개 이상의 기본 매개 변수 위치를 생략하는 모든 호출과 일치하는 것으로 간주됩니다. 이러한 기능이 둘 이상 호출과 일치하면 검색 경로에서 가장 빠른 기능이 사용됩니다. 기본값이 아닌 위치에서 동일한 매개 변수 유형을 가진 동일한 스키마에 두 개 이상의 이러한 기능이있는 경우 (기본 매개 변수의 다른 세트가있는 경우 가능) 시스템이 선호하는 기능을 결정할 수 없습니다. &quot;모호한 함수 호출&quot;오류는 호출과 더 일치하는 항목을 찾을 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="968a1bb51fb8e88d31fbc6fa43c7108e8557e4b7" translate="yes" xml:space="preserve">
          <source>Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use. For example, consider</source>
          <target state="translated">인수 유형 목록이 다른 함수는 작성시 충돌하는 것으로 간주되지 않지만 기본값이 제공되면 사용 중에 충돌 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="135becd421fd7ec3a1d11031f3897f120bbd244e" translate="yes" xml:space="preserve">
          <source>Functions, triggers and row-level security policies allow users to insert code into the backend server that other users might execute unintentionally. Hence, these mechanisms permit users to &amp;ldquo;Trojan horse&amp;rdquo; others with relative ease. The strongest protection is tight control over who can define objects. Where that is infeasible, write queries referring only to objects having trusted owners. Remove from &lt;code&gt;search_path&lt;/code&gt; the public schema and any other schemas that permit untrusted users to create objects.</source>
          <target state="translated">기능, 트리거 및 행 수준 보안 정책을 통해 사용자는 다른 사용자가 실수로 실행할 수있는 코드를 백엔드 서버에 삽입 할 수 있습니다. 따라서 이러한 메커니즘을 통해 사용자는 다른 사람을 비교적 쉽게 &quot;트로이 목마&quot;로 만들 수 있습니다. 가장 강력한 보호는 객체를 정의 할 수있는 사람을 엄격하게 제어하는 ​​것입니다. 그것이 불가능한 경우, 신뢰할 수있는 소유자를 가진 객체만을 참조하는 쿼리를 작성하십시오. 신뢰할 수없는 사용자가 오브젝트를 작성할 수있게하는 공용 스키마 및 기타 스키마를 &lt;code&gt;search_path&lt;/code&gt; 에서 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="5108d609f3fb07622f5f3d1be40ac26ef2e0a0a8" translate="yes" xml:space="preserve">
          <source>Functions: Aggregate</source>
          <target state="translated">함수 : 집계</target>
        </trans-unit>
        <trans-unit id="64682352d164f9b71b9cd241b5b867b131e9918f" translate="yes" xml:space="preserve">
          <source>Functions: Array</source>
          <target state="translated">기능 : 배열</target>
        </trans-unit>
        <trans-unit id="a17a5cd5398272b5c3db6c42f415d4231dc9dd50" translate="yes" xml:space="preserve">
          <source>Functions: Binary String</source>
          <target state="translated">함수 : 이진 문자열</target>
        </trans-unit>
        <trans-unit id="46e7b932a583771eba0b904ed9f4220de160a130" translate="yes" xml:space="preserve">
          <source>Functions: Bit String</source>
          <target state="translated">함수 : 비트 문자열</target>
        </trans-unit>
        <trans-unit id="106e142aa5e330cde3a84b7b845817b28d2e9175" translate="yes" xml:space="preserve">
          <source>Functions: Data Type Formatting</source>
          <target state="translated">함수 : 데이터 형식</target>
        </trans-unit>
        <trans-unit id="bfefb2129f2304220f19e00946bdffaabf6dc0e1" translate="yes" xml:space="preserve">
          <source>Functions: Date/Time</source>
          <target state="translated">기능 : 날짜 / 시간</target>
        </trans-unit>
        <trans-unit id="9b63eb1b87b1e024896cd43589c27f090399d066" translate="yes" xml:space="preserve">
          <source>Functions: Geometric</source>
          <target state="translated">기능 : 기하</target>
        </trans-unit>
        <trans-unit id="4d3dafd3b51e63a124d63c626067bce30229ab1f" translate="yes" xml:space="preserve">
          <source>Functions: JSON</source>
          <target state="translated">기능 : JSON</target>
        </trans-unit>
        <trans-unit id="9b518a3dc41009e3acee3808ac0e704f6b08a5f3" translate="yes" xml:space="preserve">
          <source>Functions: Mathematical</source>
          <target state="translated">함수 : 수학</target>
        </trans-unit>
        <trans-unit id="a9c0c6a0475c27e5bdfe98492ed642ea26c29174" translate="yes" xml:space="preserve">
          <source>Functions: Network Address</source>
          <target state="translated">기능 : 네트워크 주소</target>
        </trans-unit>
        <trans-unit id="a4976494155f4e6dade31fdc069e51f1a7d1ce69" translate="yes" xml:space="preserve">
          <source>Functions: Range</source>
          <target state="translated">기능 : 범위</target>
        </trans-unit>
        <trans-unit id="b8fcb9bba13dc3a8cc6d595a39daf47631d430a4" translate="yes" xml:space="preserve">
          <source>Functions: Statistics Information</source>
          <target state="translated">함수 : 통계 정보</target>
        </trans-unit>
        <trans-unit id="d1ee22b179879e9f873763bb172d33f3017f840e" translate="yes" xml:space="preserve">
          <source>Functions: String</source>
          <target state="translated">함수 : 문자열</target>
        </trans-unit>
        <trans-unit id="6843fcead53a6cf24daa8566fecd89162ab37e7f" translate="yes" xml:space="preserve">
          <source>Functions: System Administration</source>
          <target state="translated">기능 : 시스템 관리</target>
        </trans-unit>
        <trans-unit id="a388797fbe7fca428c186d9bd0e36003dc121806" translate="yes" xml:space="preserve">
          <source>Functions: System Information</source>
          <target state="translated">기능 : 시스템 정보</target>
        </trans-unit>
        <trans-unit id="6774bc067b00b4a898fa2d81854d9f8ccd1bb6e9" translate="yes" xml:space="preserve">
          <source>Functions: Text Search</source>
          <target state="translated">기능 : 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="1acb35ad39f3bcd2faf73955c2408efc740b8965" translate="yes" xml:space="preserve">
          <source>Functions: Window</source>
          <target state="translated">기능 : 창</target>
        </trans-unit>
        <trans-unit id="4ea9b0534343b6662064e8e66df29f936486dcbe" translate="yes" xml:space="preserve">
          <source>Functions: XML</source>
          <target state="translated">함수 : XML</target>
        </trans-unit>
        <trans-unit id="be1881053687afed29c0ae862b5bb84c66f949f7" translate="yes" xml:space="preserve">
          <source>Further along the line of common sense, the fuzziness of the limits suggests that the use of traditional numeric data types leads to a certain loss of information. Consider this: your instrument reads 6.50, and you input this reading into the database. What do you get when you fetch it? Watch:</source>
          <target state="translated">또한 상식에 따라 한계의 어리 석음은 전통적인 숫자 데이터 유형을 사용하면 특정 정보가 손실됨을 나타냅니다. 이것을 고려하십시오 : 계측기는 6.50을 읽고이 판독 값을 데이터베이스에 입력합니다. 가져 오면 무엇을 얻습니까? 손목 시계:</target>
        </trans-unit>
        <trans-unit id="e2310579f06e5c7b30a8aa96bc1d602f5e9203e6" translate="yes" xml:space="preserve">
          <source>Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type's &lt;code&gt;&amp;lt;&lt;/code&gt; operator is the proper sort operator for &lt;code&gt;MIN&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt; is the proper sort operator for &lt;code&gt;MAX&lt;/code&gt;. Note that the optimization will never actually take effect unless the specified operator is the &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than&amp;rdquo; strategy member of a B-tree index operator class.</source>
          <target state="translated">추가 가정은 집계가 널 입력을 무시하고 널이 아닌 입력이없는 경우에만 널 결과를 전달한다고 가정합니다. 일반적으로 데이터 유형의 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자는 &lt;code&gt;MIN&lt;/code&gt; 에 대한 적절한 정렬 연산자 이고 &lt;code&gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;MAX&lt;/code&gt; 에 대한 적절한 정렬 연산자입니다 . 지정된 연산자가 B- 트리 인덱스 연산자 클래스의 &quot;보다 작음&quot;또는 &quot;보다 큼&quot;전략 구성원이 아니면 최적화가 실제로 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e3fde8eb12ee9830b9efa317f6db1a2760019c3" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="translated">플래너의 통계 사용에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;70 장&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80923ff08a3698b44c0358905326ad4315d1f3f8" translate="yes" xml:space="preserve">
          <source>Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values might be generated out of sequence when all the sessions are considered. For example, with a &lt;code&gt;cache&lt;/code&gt; setting of 10, session A might reserve values 1..10 and return &lt;code&gt;nextval&lt;/code&gt;=1, then session B might reserve values 11..20 and return &lt;code&gt;nextval&lt;/code&gt;=11 before session A has generated &lt;code&gt;nextval&lt;/code&gt;=2. Thus, with a &lt;code&gt;cache&lt;/code&gt; setting of one it is safe to assume that &lt;code&gt;nextval&lt;/code&gt; values are generated sequentially; with a &lt;code&gt;cache&lt;/code&gt; setting greater than one you should only assume that the &lt;code&gt;nextval&lt;/code&gt; values are all distinct, not that they are generated purely sequentially. Also, &lt;code&gt;last_value&lt;/code&gt; will reflect the latest value reserved by any session, whether or not it has yet been returned by &lt;code&gt;nextval&lt;/code&gt;.</source>
          <target state="translated">또한 여러 세션이 고유 한 시퀀스 값을 할당하도록 보장되지만 모든 세션이 고려 될 때 값이 시퀀스에서 생성되지 않을 수 있습니다. 예를 들어, &lt;code&gt;cache&lt;/code&gt; 설정이 10 인 경우 세션 A는 값 1..10을 예약하고 &lt;code&gt;nextval&lt;/code&gt; = 1을 반환 할 수 있고 세션 B는 값 11..20을 예약하고 세션 A가 &lt;code&gt;nextval&lt;/code&gt; = 2를 생성하기 전에 &lt;code&gt;nextval&lt;/code&gt; = 11을 반환 할 수 있습니다 . 따라서, 함께 &lt;code&gt;cache&lt;/code&gt; 하나의 설치는 것으로 가정하는 것이 안전 &lt;code&gt;nextval&lt;/code&gt; 값이 순차적으로 생성된다; 로모그래퍼 &lt;code&gt;cache&lt;/code&gt; 보다 설정보다 당신은 단지 가정한다 &lt;code&gt;nextval&lt;/code&gt; 값은 순차 순차로 생성되는 것이 아니라 모두 고유합니다. 또한 &lt;code&gt;last_value&lt;/code&gt; 는 아직 &lt;code&gt;nextval&lt;/code&gt; 에 의해 반환되었는지 여부에 관계없이 모든 세션에서 예약 한 최신 값을 반영합니다 .</target>
        </trans-unit>
        <trans-unit id="224c260c1b97921918028686f800ec2a753d6d99" translate="yes" xml:space="preserve">
          <source>Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote:</source>
          <target state="translated">또한 표현식의 일부만 평가하여 표현식의 결과를 판별 할 수 있으면 다른 하위 표현식이 전혀 평가되지 않을 수 있습니다. 예를 들어, 다음과 같이 쓴 경우 :</target>
        </trans-unit>
        <trans-unit id="c76baa18e3a105ad25a2e47745a365c732d219e6" translate="yes" xml:space="preserve">
          <source>Furthermore, immediately before reporting a uniqueness violation according to the above rules, the access method must recheck the liveness of the row being inserted. If it is committed dead then no violation should be reported. (This case cannot occur during the ordinary scenario of inserting a row that's just been created by the current transaction. It can happen during &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt;, however.)</source>
          <target state="translated">또한, 위의 규칙에 따라 고유성 위반을보고하기 직전에 액세스 방법은 삽입되는 행의 활성을 다시 확인해야합니다. 종료 된 경우 위반을보고하지 않아야합니다. (이 경우는 현재 트랜잭션에 의해 생성 된 행을 삽입하는 일반적인 시나리오에서는 발생할 수 없습니다. 그러나 &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt; 동안 발생할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b247028066a34eb255cbd5a7c12a62f7ec515ba5" translate="yes" xml:space="preserve">
          <source>Furthermore, indexes for exclusion constraints cannot be reindexed concurrently. If such an index is named directly in this command, an error is raised. If a table or database with exclusion constraint indexes is reindexed concurrently, those indexes will be skipped. (It is possible to reindex such indexes without the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option.)</source>
          <target state="translated">또한 제외 제약 조건에 대한 인덱스는 동시에 다시 인덱싱 할 수 없습니다. 이 명령에서 이러한 색인의 이름을 직접 지정하면 오류가 발생합니다. 제외 제약 조건 인덱스가있는 테이블 또는 데이터베이스를 동시에 다시 인덱싱하면 해당 인덱스를 건너 뜁니다. &lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 사용 하지 않고도 이러한 색인을 다시 색인화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca37f367ca14421a51e0f4caacbc290fabee5387" translate="yes" xml:space="preserve">
          <source>Furthermore, the ordering is total; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">또한 주문은 총계입니다. 즉, 널이 아닌 모든 값 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="403e23f7e975f56f502368918f62f79a68fb24a2" translate="yes" xml:space="preserve">
          <source>Furthermore, the output of &lt;code&gt;JOIN USING&lt;/code&gt; suppresses redundant columns: there is no need to print both of the matched columns, since they must have equal values. While &lt;code&gt;JOIN ON&lt;/code&gt; produces all columns from &lt;code&gt;T1&lt;/code&gt; followed by all columns from &lt;code&gt;T2&lt;/code&gt;, &lt;code&gt;JOIN USING&lt;/code&gt; produces one output column for each of the listed column pairs (in the listed order), followed by any remaining columns from &lt;code&gt;T1&lt;/code&gt;, followed by any remaining columns from &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;JOIN USING&lt;/code&gt; 의 출력은 중복 열을 억제합니다. 일치하는 열을 모두 같은 값을 가져야하므로 인쇄 할 필요가 없습니다. 동안 &lt;code&gt;JOIN ON&lt;/code&gt; 생성 한 모든 열 &lt;code&gt;T1&lt;/code&gt; 은 모든 열 뒤에 &lt;code&gt;T2&lt;/code&gt; , &lt;code&gt;JOIN USING&lt;/code&gt; 에서 나머지 열 뒤에 (열거 된 순서대로) 나열된 열 쌍 각각에 대해 하나의 출력 열을 생성 &lt;code&gt;T1&lt;/code&gt; 에서 나머지 열 뒤에 &lt;code&gt;T2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e40a8533f467834ab1d55c9055f3d84061da31d" translate="yes" xml:space="preserve">
          <source>GEQO</source>
          <target state="translated">GEQO</target>
        </trans-unit>
        <trans-unit id="7c02cecaa08dd20b2878a0e9246d9afddbd1bfa9" translate="yes" xml:space="preserve">
          <source>GIN</source>
          <target state="translated">GIN</target>
        </trans-unit>
        <trans-unit id="ecc6a1db2685ccbd525e456602d8a531d64c012d" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Built-in Operator Classes</source>
          <target state="translated">GIN 인덱스 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="df2283621762cf6fbe34492dd970bdc1a2fb8f2e" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Examples</source>
          <target state="translated">GIN 지수 : 예</target>
        </trans-unit>
        <trans-unit id="bcdb1f5984e5f5fc37ee2625a5e106b5ace38b47" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Extensibility</source>
          <target state="translated">GIN 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="1f6ebc2a0d191b466ed9b8d366b380c7d0d18de4" translate="yes" xml:space="preserve">
          <source>GIN Indexes: GIN Tips and Tricks</source>
          <target state="translated">GIN 지수 : GIN 팁과 요령</target>
        </trans-unit>
        <trans-unit id="79cd3f5e4f5e10454468404b67550cb2d0ff11bb" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Implementation</source>
          <target state="translated">GIN 지수 : 구현</target>
        </trans-unit>
        <trans-unit id="bac90b5d133adfb4770f3d94ae6faf770a933f01" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Limitations</source>
          <target state="translated">GIN 지수 : 한계</target>
        </trans-unit>
        <trans-unit id="ece4291bbc12d9bc7ed3dfad4dd491c4406b75fd" translate="yes" xml:space="preserve">
          <source>GIN and GiST Index Types</source>
          <target state="translated">GIN 및 GiST 인덱스 유형</target>
        </trans-unit>
        <trans-unit id="838975c5a4d167bd2f6ce5e8ea900f60f03b2972" translate="yes" xml:space="preserve">
          <source>GIN assumes that indexable operators are strict. This means that &lt;code&gt;extractValue&lt;/code&gt; will not be called at all on a null item value (instead, a placeholder index entry is created automatically), and &lt;code&gt;extractQuery&lt;/code&gt; will not be called on a null query value either (instead, the query is presumed to be unsatisfiable). Note however that null key values contained within a non-null composite item or query value are supported.</source>
          <target state="translated">GIN은 색인 가능한 연산자가 엄격하다고 가정합니다. 즉 , &lt;code&gt;extractQuery&lt;/code&gt; 인덱스 항목이 자동으로 생성되는 대신 null 항목 값에서 &lt;code&gt;extractValue&lt;/code&gt; 가 전혀 호출 되지 않고 null 쿼리 값에서도 extractQuery 가 호출되지 않습니다 (대신 쿼리가 만족스럽지 않은 것으로 간주 됨) . 그러나 널이 아닌 복합 항목 또는 쿼리 값에 포함 된 널 키 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe2b1de04947c2b348e8de70b6c2f63da721161b" translate="yes" xml:space="preserve">
          <source>GIN can support &amp;ldquo;partial match&amp;rdquo; queries, in which the query does not determine an exact match for one or more keys, but the possible matches fall within a reasonably narrow range of key values (within the key sorting order determined by the &lt;code&gt;compare&lt;/code&gt; support method). The &lt;code&gt;extractQuery&lt;/code&gt; method, instead of returning a key value to be matched exactly, returns a key value that is the lower bound of the range to be searched, and sets the &lt;code&gt;pmatch&lt;/code&gt; flag true. The key range is then scanned using the &lt;code&gt;comparePartial&lt;/code&gt; method. &lt;code&gt;comparePartial&lt;/code&gt; must return zero for a matching index key, less than zero for a non-match that is still within the range to be searched, or greater than zero if the index key is past the range that could match.</source>
          <target state="translated">GIN은 쿼리가 하나 이상의 키에 대한 정확한 일치를 결정하지 않지만 가능한 일치는 상당히 좁은 범위의 키 값 ( &lt;code&gt;compare&lt;/code&gt; 지원 방법에 의해 결정된 키 정렬 순서 내)에 속하는 &quot;부분 일치&quot;쿼리를 지원할 수 있습니다. ). &lt;code&gt;extractQuery&lt;/code&gt; 의 대신에 키 값을 되 돌리는 방법이 정확하게 일치하도록, 하부 검색 할 범위 바인딩 된 키 값을 반환하고, 세트 &lt;code&gt;pmatch&lt;/code&gt; 의 진정한 플래그. 그런 다음 &lt;code&gt;comparePartial&lt;/code&gt; 메소드를 사용하여 키 범위를 스캔합니다 . &lt;code&gt;comparePartial&lt;/code&gt; 일치하는 색인 ​​키의 경우 0을, 검색 할 범위 내에있는 비 일치의 경우 0보다 작거나, 색인 키가 일치 할 수있는 범위를 지나면 0보다 큰 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="614db4420feca405f38d8b066253c12c8348900b" translate="yes" xml:space="preserve">
          <source>GIN index extracts statements of following form out of &lt;code&gt;jsonpath&lt;/code&gt;: &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt;. Accessors chain may consist of &lt;code&gt;.key&lt;/code&gt;, &lt;code&gt;[*]&lt;/code&gt;, and &lt;code&gt;[index]&lt;/code&gt; accessors. &lt;code&gt;jsonb_ops&lt;/code&gt; additionally supports &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.**&lt;/code&gt; accessors.</source>
          <target state="translated">GIN 색인은 &lt;code&gt;jsonpath&lt;/code&gt; 에서 다음 형식의 명령문을 추출합니다 . &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt; . 접근 자 체인은 &lt;code&gt;.key&lt;/code&gt; , &lt;code&gt;[*]&lt;/code&gt; 및 &lt;code&gt;[index]&lt;/code&gt; 접근 자로 구성 될 수 있습니다 . &lt;code&gt;jsonb_ops&lt;/code&gt; 는 &lt;code&gt;.*&lt;/code&gt; 및 &lt;code&gt;.**&lt;/code&gt; 접근 자를 추가로 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="45189d146afca1631f2530069592ce2a3f6f8758" translate="yes" xml:space="preserve">
          <source>GIN indexes</source>
          <target state="translated">진 지수</target>
        </trans-unit>
        <trans-unit id="b1817ec41a2b97676aa792c5a571f79e3047197e" translate="yes" xml:space="preserve">
          <source>GIN indexes accept different parameters:</source>
          <target state="translated">GIN 인덱스는 다른 매개 변수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9ae2afa12a8014fb0afa678aad4a0a6fdff0194f" translate="yes" xml:space="preserve">
          <source>GIN indexes are &amp;ldquo;inverted indexes&amp;rdquo; which are appropriate for data values that contain multiple component values, such as arrays. An inverted index contains a separate entry for each component value, and can efficiently handle queries that test for the presence of specific component values.</source>
          <target state="translated">GIN 인덱스는 배열과 같이 여러 구성 요소 값이 포함 된 데이터 값에 적합한 &quot;반전 인덱스&quot;입니다. 반전 된 색인에는 각 구성 요소 값에 대한 별도의 항목이 포함되며 특정 구성 요소 값이 있는지 테스트하는 쿼리를 효율적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6e3602f0fe2770a2e803379f390135df1f58a159" translate="yes" xml:space="preserve">
          <source>GIN indexes are the preferred text search index type. As inverted indexes, they contain an index entry for each word (lexeme), with a compressed list of matching locations. Multi-word searches can find the first match, then use the index to remove rows that are lacking additional words. GIN indexes store only the words (lexemes) of &lt;code&gt;tsvector&lt;/code&gt; values, and not their weight labels. Thus a table row recheck is needed when using a query that involves weights.</source>
          <target state="translated">GIN 색인은 선호하는 텍스트 검색 색인 유형입니다. 거꾸로 된 색인으로 일치하는 위치의 압축 된 목록과 함께 각 단어 (lexeme)에 대한 색인 항목이 포함됩니다. 여러 단어 검색은 첫 번째 일치 항목을 찾은 다음 색인을 사용하여 추가 단어가없는 행을 제거 할 수 있습니다. GIN 인덱스는 &lt;code&gt;tsvector&lt;/code&gt; 값 의 단어 ( lexemes ) 만 저장 하고 가중치 레이블은 저장하지 않습니다. 따라서 가중치와 관련된 쿼리를 사용할 때는 테이블 행을 다시 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="662e0bcd43903a7d3e17f00c272dcd79f02aa415" translate="yes" xml:space="preserve">
          <source>GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of &lt;code&gt;jsonb&lt;/code&gt; documents (datums). Two GIN &amp;ldquo;operator classes&amp;rdquo; are provided, offering different performance and flexibility trade-offs.</source>
          <target state="translated">GIN 인덱스는 많은 &lt;code&gt;jsonb&lt;/code&gt; 문서 (데이텀) 내에서 발생하는 키 또는 키 / 값 쌍을 효율적으로 검색하는 데 사용될 수 있습니다 . 서로 다른 성능과 유연성의 균형을 제공하는 두 개의 GIN &quot;운영자 클래스&quot;가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="680a142f22f16149f0a10d5733b44a15bfc9f906" translate="yes" xml:space="preserve">
          <source>GIN is generalized in the sense that the GIN access method code does not need to know the specific operations that it accelerates. Instead, it uses custom strategies defined for particular data types. The strategy defines how keys are extracted from indexed items and query conditions, and how to determine whether a row that contains some of the key values in a query actually satisfies the query.</source>
          <target state="translated">GIN은 GIN 액세스 방법 코드가 가속화하는 특정 작업을 알 필요가 없다는 의미에서 일반화됩니다. 대신 특정 데이터 유형에 대해 정의 된 사용자 지정 전략을 사용합니다. 이 전략은 인덱싱 된 항목 및 쿼리 조건에서 키를 추출하는 방법과 쿼리에 일부 키 값이 포함 된 행이 실제로 쿼리를 만족하는지 여부를 결정하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2d1d5b806ff667bfec2719e4c38322233f7a1f8b" translate="yes" xml:space="preserve">
          <source>GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.</source>
          <target state="translated">GIN은 Generalized Inverted Index의 약자입니다. GIN은 인덱싱 할 항목이 복합 값이고 인덱스에서 처리 할 쿼리가 복합 항목 내에 나타나는 요소 값을 검색해야하는 경우를 처리하기 위해 설계되었습니다. 예를 들어 항목은 문서 일 수 있고 쿼리는 특정 단어가 포함 된 문서를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="823f6d975b918a4f4904609a69bccd4f6db0e016" translate="yes" xml:space="preserve">
          <source>GIN version number</source>
          <target state="translated">진 버전 번호</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="46e5d5c005d767dc686d5fdb5278440482f67660" translate="yes" xml:space="preserve">
          <source>GRANT</source>
          <target state="translated">GRANT</target>
        </trans-unit>
        <trans-unit id="f96c309d7771b4500d22efff00cb264218c6cf3a" translate="yes" xml:space="preserve">
          <source>GRANT &amp;mdash; define access privileges</source>
          <target state="translated">GRANT-액세스 권한 정의</target>
        </trans-unit>
        <trans-unit id="50381ef340ee08d7a029c8e513ea2dc8126c9d21" translate="yes" xml:space="preserve">
          <source>GRANT on Database Objects</source>
          <target state="translated">데이터베이스 객체에 대한 GRANT</target>
        </trans-unit>
        <trans-unit id="040876dd6cec9809d1a84a48115c6451d11d511c" translate="yes" xml:space="preserve">
          <source>GRANT on Roles</source>
          <target state="translated">역할에 대한 열정</target>
        </trans-unit>
        <trans-unit id="18b63165da1ffe19e191b11267fd831d16b20629" translate="yes" xml:space="preserve">
          <source>GSSAPI</source>
          <target state="translated">GSSAPI</target>
        </trans-unit>
        <trans-unit id="6b3f2424f13149fada5347cf28d874ce4ce85971" translate="yes" xml:space="preserve">
          <source>GSSAPI Authentication</source>
          <target state="translated">GSSAPI 인증</target>
        </trans-unit>
        <trans-unit id="3d0265dcf1697d6c2f5c259d07fa634b6fbdea24" translate="yes" xml:space="preserve">
          <source>GSSAPI is an industry-standard protocol for secure authentication defined in RFC 2743. PostgreSQL supports GSSAPI for use as either an encrypted, authenticated layer, or for authentication only. GSSAPI provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure. If GSSAPI encryption (see &lt;code&gt;hostgssenc&lt;/code&gt;) or SSL encryption are used, the data sent along the database connection will be encrypted; otherwise, it will not.</source>
          <target state="translated">GSSAPI는 RFC 2743에 정의 된 보안 인증을위한 산업 표준 프로토콜입니다. PostgreSQL은 암호화, 인증 된 계층 또는 인증 전용으로 GSSAPI를 지원합니다. GSSAPI는이를 지원하는 시스템에 자동 인증 (싱글 사인온)을 제공합니다. 인증 자체는 안전합니다. GSSAPI 암호화 ( &lt;code&gt;hostgssenc&lt;/code&gt; 참조 ) 또는 SSL 암호화가 사용되면 데이터베이스 연결을 통해 전송 된 데이터가 암호화됩니다. 그렇지 않으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c340397893e38112dd6e1110b015089ffe980f8" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="translated">PostgreSQL을 빌드 할 때 GSSAPI 지원을 활성화해야합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a65194631e53d423c8f7dc36b0337ca4d0af275f" translate="yes" xml:space="preserve">
          <source>GSSAPI-encrypted connections encrypt all data sent across the network, including queries and data returned. (No password is sent across the network.) The &lt;code&gt;pg_hba.conf&lt;/code&gt; file allows administrators to specify which hosts can use non-encrypted connections (&lt;code&gt;host&lt;/code&gt;) and which require GSSAPI-encrypted connections (&lt;code&gt;hostgssenc&lt;/code&gt;). Also, clients can specify that they connect to servers only on GSSAPI-encrypted connections (&lt;code&gt;gssencmode=require&lt;/code&gt;).</source>
          <target state="translated">GSSAPI 암호화 연결은 쿼리 및 반환 된 데이터를 포함하여 네트워크를 통해 전송 된 모든 데이터를 암호화합니다. (없음 암호는 네트워크를 통해 전송된다.)에 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일 관리자는 호스트가 암호화되지 않은 연결 (사용할 수있는 지정할 수 있습니다 &lt;code&gt;host&lt;/code&gt; ) 및 GSSAPI 암호화 된 연결 (필요 &lt;code&gt;hostgssenc&lt;/code&gt; 을 ). 또한 클라이언트는 GSSAPI 암호화 연결 ( &lt;code&gt;gssencmode=require&lt;/code&gt; ) 에서만 서버에 연결하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f4a781a866c82c10ec06cfdb99d578fac96f0a9" translate="yes" xml:space="preserve">
          <source>GUC</source>
          <target state="translated">GUC</target>
        </trans-unit>
        <trans-unit id="55d3b12a3edecf2084b5b37090f9f7a53387e200" translate="yes" xml:space="preserve">
          <source>Gaussian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 가우스 분포 랜덤 정수 ( 아래 참조)</target>
        </trans-unit>
        <trans-unit id="ae313cc97f019cc02b5747068e2416db0beed99a" translate="yes" xml:space="preserve">
          <source>General Purpose</source>
          <target state="translated">범용</target>
        </trans-unit>
        <trans-unit id="3160665d714fc6d7b194361c56057ae8d2d10ef8" translate="yes" xml:space="preserve">
          <source>Generalized Inverted Index</source>
          <target state="translated">일반화 반전 지수</target>
        </trans-unit>
        <trans-unit id="aa5854e74a08fd00bcac0cc44c6f66a2c57b9442" translate="yes" xml:space="preserve">
          <source>Generalized Search Tree</source>
          <target state="translated">일반화 된 검색 트리</target>
        </trans-unit>
        <trans-unit id="3e7c9f89ced37df1cb7e21ed93f1ae9c43e37c8c" translate="yes" xml:space="preserve">
          <source>Generally, any file system with POSIX semantics can be used for PostgreSQL. Users prefer different file systems for a variety of reasons, including vendor support, performance, and familiarity. Experience suggests that, all other things being equal, one should not expect major performance or behavior changes merely from switching file systems or making minor file system configuration changes.</source>
          <target state="translated">일반적으로 POSIX 시맨틱이있는 모든 파일 시스템을 PostgreSQL에 사용할 수 있습니다. 사용자는 공급 업체 지원, 성능 및 친숙성을 포함하여 다양한 이유로 다른 파일 시스템을 선호합니다. 경험에 따르면, 다른 모든 것들이 동일 할 경우 파일 시스템을 전환하거나 파일 시스템 구성을 약간만 변경해도 주요 성능이나 동작 변경이 예상되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e4dfa0a05721faeacd6c28188e09916650d7ec35" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;EXPLAIN&lt;/code&gt; output will display details for every plan node which was generated by the query planner. However, there are cases where the executor is able to determine that certain nodes are not required; currently, the only node types to support this are the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; nodes. These node types have the ability to discard subnodes which they are able to determine won't contain any records required by the query. It is possible to determine that nodes have been removed in this way by the presence of a &quot;Subplans Removed&quot; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">일반적으로 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력은 쿼리 플래너가 생성 한 모든 계획 노드에 대한 세부 사항을 표시합니다. 그러나 실행자가 특정 노드가 필요하지 않다고 판단 할 수있는 경우가 있습니다. 현재이를 지원하는 유일한 노드 유형은 &lt;code&gt;Append&lt;/code&gt; 및 &lt;code&gt;MergeAppend&lt;/code&gt; 노드입니다. 이러한 노드 유형에는 쿼리에 필요한 레코드가 포함되어 있지 않은지 확인할 수있는 하위 노드를 버리는 기능이 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 에 &quot;하위 계획 제거&quot;특성이 존재하여 이러한 방식으로 노드가 제거되었는지 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="affe2a15ea854fded86126b770c099c64d24c777" translate="yes" xml:space="preserve">
          <source>Generally, the system will enforce filter conditions imposed using security policies prior to qualifications that appear in user queries, in order to prevent inadvertent exposure of the protected data to user-defined functions which might not be trustworthy. However, functions and operators marked by the system (or the system administrator) as &lt;code&gt;LEAKPROOF&lt;/code&gt; may be evaluated before policy expressions, as they are assumed to be trustworthy.</source>
          <target state="translated">일반적으로, 시스템은 신뢰할 수없는 사용자 정의 기능에 보호 된 데이터가 실수로 노출되는 것을 방지하기 위해 사용자 쿼리에 표시되는 자격에 앞서 보안 정책을 사용하여 적용된 필터 조건을 시행합니다. 그러나 시스템 (또는 시스템 관리자)이 &lt;code&gt;LEAKPROOF&lt;/code&gt; 로 표시 한 기능 및 연산자는 신뢰할 수있는 것으로 간주되기 때문에 정책 표현 전에 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3eac14aa88e73035cec53cd24d7892747e63a31" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts.</source>
          <target state="translated">주어진 배열의 아래 첨자로 구성된 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4a5175300e4854a10a7b94e474436e6a6e890471" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, the series is returned in reverse order.</source>
          <target state="translated">주어진 배열의 아래 첨자로 구성된 시리즈를 생성하십시오. 때 &lt;em&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/em&gt; 사실이다 시리즈는 역순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ad5fcb5a5c8eeebb88c26d2bf0bde7f9fa38281f" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">에서, 일련의 값을 생성 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 을 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 하는 단계 크기 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5fb2cfb648fe3292c4f21944415cd71835246e3" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of one</source>
          <target state="translated">단계 크기가 1 인 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 부터 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 까지 일련의 값 생성</target>
        </trans-unit>
        <trans-unit id="37f727cfa62167384e5f8947ef57078f0d482808" translate="yes" xml:space="preserve">
          <source>Generate data and load it into the standard tables, replacing any data already present.</source>
          <target state="translated">데이터를 생성하고 표준 테이블에로드하여 이미 존재하는 데이터를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="9dcf1fb2a5619d507a1603ea13343b634907fbb2" translate="yes" xml:space="preserve">
          <source>Generated Columns</source>
          <target state="translated">생성 된 열</target>
        </trans-unit>
        <trans-unit id="75d723afc8209b9ad813733ed0d276b98f57a469" translate="yes" xml:space="preserve">
          <source>Generated columns are, conceptually, updated after &lt;code&gt;BEFORE&lt;/code&gt; triggers have run. Therefore, changes made to base columns in a &lt;code&gt;BEFORE&lt;/code&gt; trigger will be reflected in generated columns. But conversely, it is not allowed to access generated columns in &lt;code&gt;BEFORE&lt;/code&gt; triggers.</source>
          <target state="translated">생성 된 열은 개념적으로 &lt;code&gt;BEFORE&lt;/code&gt; 트리거가 실행 된 후에 업데이트됩니다 . 따라서 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 에서 기본 열에 대한 변경 사항은 생성 된 열에 반영됩니다. 그러나 반대로 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 에서 생성 된 열에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="942c0fc170e0c5a1f9b1ae453e356f340b1b4ebb" translate="yes" xml:space="preserve">
          <source>Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to arrange it so that a particular role can read from a generated column but not from the underlying base columns.</source>
          <target state="translated">생성 된 열은 기본 열과 별도로 액세스 권한을 유지 관리합니다. 따라서 기본 역할이 아닌 생성 된 열에서 특정 역할을 읽을 수 있도록 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0ef22f71ecfc740ab931db74f147c122ec3d69" translate="yes" xml:space="preserve">
          <source>Generates a great amount of debugging output for the &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt; commands. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; must be &lt;code&gt;DEBUG1&lt;/code&gt; or lower to send this output to the client or server logs, respectively.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 및 &lt;code&gt;NOTIFY&lt;/code&gt; 명령에 대한 대량의 디버깅 출력을 생성 합니다. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; 는 이 출력을 각각 클라이언트 또는 서버 로그로 보내 &lt;code&gt;DEBUG1&lt;/code&gt; 이하 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c512aad043f38a5c410a9715731ea7ab925a02c" translate="yes" xml:space="preserve">
          <source>Generates a new random salt string for use in &lt;code&gt;crypt()&lt;/code&gt;. The salt string also tells &lt;code&gt;crypt()&lt;/code&gt; which algorithm to use.</source>
          <target state="translated">&lt;code&gt;crypt()&lt;/code&gt; 에서 사용할 새로운 임의 솔트 문자열을 생성합니다 . 솔트 문자열은 &lt;code&gt;crypt()&lt;/code&gt; 에게 사용할 알고리즘을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="2aed1c9095c07cc7e84b3424230f02a2d9b469cc" translate="yes" xml:space="preserve">
          <source>Generic Security Services Application Programming Interface</source>
          <target state="translated">일반 보안 서비스 응용 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="8bc48767cdd05b47e355717259ca35db85925a08" translate="yes" xml:space="preserve">
          <source>Generic WAL Records</source>
          <target state="translated">일반 WAL 레코드</target>
        </trans-unit>
        <trans-unit id="205b89cfc2a1a2269f79b2bc4ed00c40f5cec848" translate="yes" xml:space="preserve">
          <source>Generic WAL assumes that the pages to be modified have standard layout, and in particular that there is no useful data between &lt;code&gt;pd_lower&lt;/code&gt; and &lt;code&gt;pd_upper&lt;/code&gt;.</source>
          <target state="translated">Generic WAL은 수정 될 페이지에 표준 레이아웃이 있으며 특히 &lt;code&gt;pd_lower&lt;/code&gt; 와 &lt;code&gt;pd_upper&lt;/code&gt; 사이에 유용한 데이터가 없다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="651fc79b97c554a5773cb00dd19d49f06b1a6de8" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer</source>
          <target state="translated">유전자 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="285a459d41ebc8b40cc4e21eb5058c5046b9a518" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Further Reading</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 추가 정보</target>
        </trans-unit>
        <trans-unit id="0fe3a114537a44f8bb8da3ae145d25fd674c9baa" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Algorithms</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 유전자 알고리즘</target>
        </trans-unit>
        <trans-unit id="a4b0f535ba1259d8c2e707ca90836a3a1579135e" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Query Optimization (GEQO) in PostgreSQL</source>
          <target state="translated">Genetic Query Optimizer : PostgreSQL의 GEQO (Genetic Query Optimization)</target>
        </trans-unit>
        <trans-unit id="c07c10eab422b8e5a37b4814c23b452b246b27ed" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Query Handling as a Complex Optimization Problem</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 복잡한 최적화 문제로서의 쿼리 처리</target>
        </trans-unit>
        <trans-unit id="59a79a1ee234d61d42db147aa7f797d2e6ec2302" translate="yes" xml:space="preserve">
          <source>Geometric Types</source>
          <target state="translated">기하학적 유형</target>
        </trans-unit>
        <trans-unit id="1b872848d87aaa550340d8fe24c7f0a2a9ae8bcb" translate="yes" xml:space="preserve">
          <source>Geometric Types: box</source>
          <target state="translated">기하학적 유형 : box</target>
        </trans-unit>
        <trans-unit id="92cdb69f3efb505ed8f65eafd9adff3faa140669" translate="yes" xml:space="preserve">
          <source>Geometric Types: circle</source>
          <target state="translated">기하학적 유형 : circle</target>
        </trans-unit>
        <trans-unit id="b780ba45a62c07dae122a8391383dec51d0ae3fb" translate="yes" xml:space="preserve">
          <source>Geometric Types: line</source>
          <target state="translated">기하학적 유형 : line</target>
        </trans-unit>
        <trans-unit id="93e949ac77b5da81e10c0d00eb14e5b76ecbcd17" translate="yes" xml:space="preserve">
          <source>Geometric Types: lseg</source>
          <target state="translated">기하학적 유형 : lseg</target>
        </trans-unit>
        <trans-unit id="70c8994901b16ea96046ff8cb3549fb5591cc7c5" translate="yes" xml:space="preserve">
          <source>Geometric Types: path</source>
          <target state="translated">기하학적 유형 : path</target>
        </trans-unit>
        <trans-unit id="5971b419fcb4741dbee95edc6702d224da6e2f8b" translate="yes" xml:space="preserve">
          <source>Geometric Types: point</source>
          <target state="translated">기하학적 유형 : point</target>
        </trans-unit>
        <trans-unit id="a42b9eae0d25dcae6593b119b1ff920376ab3fdb" translate="yes" xml:space="preserve">
          <source>Geometric Types: polygon</source>
          <target state="translated">기하학적 유형 : polygon</target>
        </trans-unit>
        <trans-unit id="c0f24750d757100bf5b4c2c76561499175630de1" translate="yes" xml:space="preserve">
          <source>Geometric data types represent two-dimensional spatial objects. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;Table 8.20&lt;/a&gt; shows the geometric types available in PostgreSQL.</source>
          <target state="translated">기하 데이터 유형은 2 차원 공간 객체를 나타냅니다. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;표 8.20&lt;/a&gt; 은 PostgreSQL에서 사용 가능한 기하학적 유형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7694ba97cb7c18e18a22a41d6adc199509b697ef" translate="yes" xml:space="preserve">
          <source>Geometric types</source>
          <target state="translated">기하학적 유형</target>
        </trans-unit>
        <trans-unit id="9ae1f34e04075cebb1033f14ff7dd7b2bf91177b" translate="yes" xml:space="preserve">
          <source>Geometric: #</source>
          <target state="translated">기하학 : #</target>
        </trans-unit>
        <trans-unit id="541465ff2784b3862252a679a04558fbc655a79e" translate="yes" xml:space="preserve">
          <source>Geometric: ##</source>
          <target state="translated">기하학 : ##</target>
        </trans-unit>
        <trans-unit id="72e0052efc06dc944e06a8b63310fcb1f4bce4d7" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;amp;</source>
          <target state="translated">기하학적 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c6f1767ec1ac7b1e533771c3bc6f2d157e3a0ffa" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;gt;</source>
          <target state="translated">기하학적 : &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0efad1957c6995260f5c39d190b260d9567a113b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;</source>
          <target state="translated">기하학적 : &amp;amp; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0f689675538b5b4ec110540ff41eb289d6bd6b43" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;|</source>
          <target state="translated">기하학적 : &amp;amp; &amp;lt;|</target>
        </trans-unit>
        <trans-unit id="f1e472c7b332a52572d117379abc66949f9e31c1" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;&amp;gt;</source>
          <target state="translated">기하학적 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6fb2a9acb2064c887124b6f5b0e4e754de5f5fc" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;^</source>
          <target state="translated">기하학 :&amp;gt; ^</target>
        </trans-unit>
        <trans-unit id="d77e84d344e830ae23e28900f46ab81224e68d7d" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;</source>
          <target state="translated">기하학적 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="114e3e68bec04a11161b64f095fcabaa1b93c022" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;|</source>
          <target state="translated">기하학적 : &amp;lt;&amp;lt; |</target>
        </trans-unit>
        <trans-unit id="3ebddf62e56d977cd85a67e8678d46b2782a23db" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;-&amp;gt;</source>
          <target state="translated">기하학적 : &amp;lt;-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3447c8a88fb2334b8df577a95ce9dc8220f2dd2" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;@</source>
          <target state="translated">기하학적 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="cce9525015da81ce4d350742ece1c53d96c3ca2b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;^</source>
          <target state="translated">기하학적 : &amp;lt;^</target>
        </trans-unit>
        <trans-unit id="56a2009f06f5c74871588a05282ba0b39fb6ceeb" translate="yes" xml:space="preserve">
          <source>Geometric: *</source>
          <target state="translated">기하학적 : *</target>
        </trans-unit>
        <trans-unit id="fa3ffad94fe9509b3b02c414cf9edaa0a2aba46e" translate="yes" xml:space="preserve">
          <source>Geometric: +</source>
          <target state="translated">기하학 : +</target>
        </trans-unit>
        <trans-unit id="356d9d70234e609b9b853b2369c157f70b7aebbe" translate="yes" xml:space="preserve">
          <source>Geometric: -</source>
          <target state="translated">기하학적 :-</target>
        </trans-unit>
        <trans-unit id="2ffe2cc10b627cd354dfeb7422da5a985c240d62" translate="yes" xml:space="preserve">
          <source>Geometric: /</source>
          <target state="translated">기하학 : /</target>
        </trans-unit>
        <trans-unit id="1c2280f6c1d1edcd9860d33a2a8a075c691adc71" translate="yes" xml:space="preserve">
          <source>Geometric: ?#</source>
          <target state="translated">기하학 :? #</target>
        </trans-unit>
        <trans-unit id="12821b449935c6dc49b03d2b040482308099f146" translate="yes" xml:space="preserve">
          <source>Geometric: ?-</source>
          <target state="translated">기하학적 :?-</target>
        </trans-unit>
        <trans-unit id="41659a241d6173118c63109b8d58f3b040547d38" translate="yes" xml:space="preserve">
          <source>Geometric: ?-|</source>
          <target state="translated">기하학 :?-|</target>
        </trans-unit>
        <trans-unit id="d6f03fc9c9b0ab0563a28c6910f4a205a373dffb" translate="yes" xml:space="preserve">
          <source>Geometric: ?|</source>
          <target state="translated">기하학적 :? |</target>
        </trans-unit>
        <trans-unit id="13e94b0d1073bd3bdfb91bcd5a193786583c973b" translate="yes" xml:space="preserve">
          <source>Geometric: ?||</source>
          <target state="translated">기하학 :? ||</target>
        </trans-unit>
        <trans-unit id="9330c7f285f4544ce63cffaf12c739ac5f145ca1" translate="yes" xml:space="preserve">
          <source>Geometric: @&amp;gt;</source>
          <target state="translated">기하학 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5270f97dad19be61277e040028add99dc4c8a2f8" translate="yes" xml:space="preserve">
          <source>Geometric: @-@</source>
          <target state="translated">기하학 : @-@</target>
        </trans-unit>
        <trans-unit id="28dfb9d3208de0df87974a869f843209287712a0" translate="yes" xml:space="preserve">
          <source>Geometric: @@</source>
          <target state="translated">기하학 : @@</target>
        </trans-unit>
        <trans-unit id="b52a6568265c2c5d617423e6cf36665bbcecd5cd" translate="yes" xml:space="preserve">
          <source>Geometric: area</source>
          <target state="translated">기하학적 : 면적</target>
        </trans-unit>
        <trans-unit id="93665e808ca1c14ef16cc6912cf6d87101aae4b0" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box</source>
          <target state="translated">기하학 : bound_box</target>
        </trans-unit>
        <trans-unit id="39d2105da034c7db21d98973af72a8064f606dda" translate="yes" xml:space="preserve">
          <source>Geometric: box</source>
          <target state="translated">기하학적 : 상자</target>
        </trans-unit>
        <trans-unit id="f403cd59f8511c55a29a5613deb6dc17553ae356" translate="yes" xml:space="preserve">
          <source>Geometric: center</source>
          <target state="translated">기하학적 : 중심</target>
        </trans-unit>
        <trans-unit id="e4f391fd63cca84c9f17c34aa7cc7e489332e1f7" translate="yes" xml:space="preserve">
          <source>Geometric: circle</source>
          <target state="translated">기하학 : 원</target>
        </trans-unit>
        <trans-unit id="e9d52c7012ac5f08fa191553229f86a574d2d1fe" translate="yes" xml:space="preserve">
          <source>Geometric: diameter</source>
          <target state="translated">기하학적 : 직경</target>
        </trans-unit>
        <trans-unit id="eba387383e96b60f7dd8fc11f767b059ffe3a921" translate="yes" xml:space="preserve">
          <source>Geometric: height</source>
          <target state="translated">기하학적 : 높이</target>
        </trans-unit>
        <trans-unit id="dfc5959ea0a6181524e306d022dfcc8e49a1d83c" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed</source>
          <target state="translated">기하학적 : isclosed</target>
        </trans-unit>
        <trans-unit id="7f81a6975db9a38b5af5931e1338ccf232987667" translate="yes" xml:space="preserve">
          <source>Geometric: isopen</source>
          <target state="translated">기하학 : isopen</target>
        </trans-unit>
        <trans-unit id="a9a3900467aaca1b8a4c1362db68f305b19582ef" translate="yes" xml:space="preserve">
          <source>Geometric: length</source>
          <target state="translated">기하학 : 길이</target>
        </trans-unit>
        <trans-unit id="1ba5f3a75b551d018972ef798eb335c100716e14" translate="yes" xml:space="preserve">
          <source>Geometric: line</source>
          <target state="translated">기하학 : 선</target>
        </trans-unit>
        <trans-unit id="206f9fccbd7deb8bf02553e15b19fa03337233fd" translate="yes" xml:space="preserve">
          <source>Geometric: lseg</source>
          <target state="translated">기하학 : lseg</target>
        </trans-unit>
        <trans-unit id="4d54cec15bcab56f2da1b1f390b73632b1dcbf4d" translate="yes" xml:space="preserve">
          <source>Geometric: npoints</source>
          <target state="translated">기하학 : npoints</target>
        </trans-unit>
        <trans-unit id="28645e62602ce8fec7218147e4987f407e8f9a72" translate="yes" xml:space="preserve">
          <source>Geometric: path</source>
          <target state="translated">기하학적 : 경로</target>
        </trans-unit>
        <trans-unit id="45ec99c5c4e908e62ccff4e585500d723032cfdc" translate="yes" xml:space="preserve">
          <source>Geometric: pclose</source>
          <target state="translated">기하학적 : pclose</target>
        </trans-unit>
        <trans-unit id="507989896f0547d05a215ff9f295d24b17e091c7" translate="yes" xml:space="preserve">
          <source>Geometric: point</source>
          <target state="translated">기하학적 : 포인트</target>
        </trans-unit>
        <trans-unit id="3ae9f6bad12ee8c28eb43284381811f2bae31846" translate="yes" xml:space="preserve">
          <source>Geometric: polygon</source>
          <target state="translated">기하학 : 다각형</target>
        </trans-unit>
        <trans-unit id="819b82ef2ad538d3fe48c1ae412245c21d9fd58a" translate="yes" xml:space="preserve">
          <source>Geometric: popen</source>
          <target state="translated">기하학 : popen</target>
        </trans-unit>
        <trans-unit id="833a7938b28ff55bf890ede9562c88a3cf3616b2" translate="yes" xml:space="preserve">
          <source>Geometric: radius</source>
          <target state="translated">기하학적 : 반경</target>
        </trans-unit>
        <trans-unit id="7f7868cefc6080ede3e7599ccdee8580f1c6391a" translate="yes" xml:space="preserve">
          <source>Geometric: width</source>
          <target state="translated">기하학적 : 폭</target>
        </trans-unit>
        <trans-unit id="a3d7536af893973e797484588417b811fa49c9c9" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;amp;&amp;gt;</source>
          <target state="translated">기하학적 : | &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dac5ddcfb396044c241822b103826072cea9122a" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;gt;&amp;gt;</source>
          <target state="translated">기하학적 : | &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e1ce90a64a5a3e719604091e787102d24302368f" translate="yes" xml:space="preserve">
          <source>Geometric: ~=</source>
          <target state="translated">기하학적 : ~ =</target>
        </trans-unit>
        <trans-unit id="3764766959b2e2fca792b770cb84c07ab6ed354f" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004 - 2006</source>
          <target state="translated">Germ&amp;aacute;n M&amp;eacute;ndez Bravo (크로노 즈), 2004-2006</target>
        </trans-unit>
        <trans-unit id="8435540f9357c0427826e02b4177ce363970db3c" translate="yes" xml:space="preserve">
          <source>German collation for Austria, default variant</source>
          <target state="translated">오스트리아에 대한 독일어 데이터 정렬, 기본 변형</target>
        </trans-unit>
        <trans-unit id="7510fc993536622c741a49aafa894361e7ab10a4" translate="yes" xml:space="preserve">
          <source>German collation with phone book collation type</source>
          <target state="translated">전화 번호부 데이터 정렬 유형의 독일어 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="564857758dc8e91c1f74d993f78de5567b5c7dfc" translate="yes" xml:space="preserve">
          <source>German collation, default variant</source>
          <target state="translated">독일어 데이터 정렬, 기본 변형</target>
        </trans-unit>
        <trans-unit id="f27aff0cadc166c49cd93ee1187bf701f6029a5e" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube (counting from 1).</source>
          <target state="translated">가져 &lt;code&gt;n&lt;/code&gt; (1에서 계산) 큐브의 좌표 번째.</target>
        </trans-unit>
        <trans-unit id="d35f795aa05a88fb426392aad122ef3b2bb082f7" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube in following way: n = 2 * k - 1 means lower bound of &lt;code&gt;k&lt;/code&gt;-th dimension, n = 2 * k means upper bound of &lt;code&gt;k&lt;/code&gt;-th dimension. Negative &lt;code&gt;n&lt;/code&gt; denotes the inverse value of the corresponding positive coordinate. This operator is designed for KNN-GiST support.</source>
          <target state="translated">위젯 &lt;code&gt;n&lt;/code&gt; 방식으로 다음의 큐브 좌표 번째 : N = 2 * K는 1 - 수단의 하한 &lt;code&gt;k&lt;/code&gt; 번째 사이즈 N = 2 * K 수단은 상부의 경계 &lt;code&gt;k&lt;/code&gt; 번째의 측정. 음수 &lt;code&gt;n&lt;/code&gt; 은 해당 양의 좌표의 역값을 나타냅니다. 이 운영자는 KNN-GiST 지원을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc6f8c8aaf13b3fdd311883db3b903abaee70123" translate="yes" xml:space="preserve">
          <source>Get JSON array element (indexed from zero, negative integers count from the end)</source>
          <target state="translated">JSON 배열 요소 가져 오기 (0에서 색인화, 끝에서 음의 정수로 계산)</target>
        </trans-unit>
        <trans-unit id="96cd8c94d1b03053f959c0260a5693091dfb369e" translate="yes" xml:space="preserve">
          <source>Get JSON array element as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSON 배열 요소를 &lt;code&gt;text&lt;/code&gt; 로 가져 오기</target>
        </trans-unit>
        <trans-unit id="cf31bd14e1935206dcfd63aadbd1872ba57dea93" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path</source>
          <target state="translated">지정된 경로에서 JSON 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ef1cbd5cb305475720a9020825d5fd0aab442b3e" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">지정된 경로에서 JSON 객체를 &lt;code&gt;text&lt;/code&gt; 로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="25fd43d0d3f16339264c4b37b814115f9d3ce410" translate="yes" xml:space="preserve">
          <source>Get JSON object field as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSON 객체 필드를 &lt;code&gt;text&lt;/code&gt; 로 가져 오기</target>
        </trans-unit>
        <trans-unit id="073ceb452af411396658b2179c607b15772b77b9" translate="yes" xml:space="preserve">
          <source>Get JSON object field by key</source>
          <target state="translated">키로 JSON 객체 필드 가져 오기</target>
        </trans-unit>
        <trans-unit id="a3c9485f60ac0e72f3350d75767b48ed6ff294ae" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log flush location</source>
          <target state="translated">현재 미리 쓰기 로그 플러시 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="ff5bd5ba7d4bd0b1adf164a5c3514a0cde09068d" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log insert location</source>
          <target state="translated">현재 미리 쓰기 로그 삽입 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="6d563af8ba9dd62228b11fa7ee4de03e9c015df2" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log write location</source>
          <target state="translated">현재 미리 쓰기 로그 쓰기 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="6128ac644ecb365c2a1eeec7ff1509ae52372521" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location received and synced to disk by streaming replication. While streaming replication is in progress this will increase monotonically. If recovery has completed this will remain static at the value of the last WAL record received and synced to disk during recovery. If streaming replication is disabled, or if it has not yet started, the function returns NULL.</source>
          <target state="translated">스트리밍 복제를 통해 마지막으로 미리 기록한 로그 위치를 받고 디스크에 동기화합니다. 스트리밍 복제가 진행되는 동안 단조 증가합니다. 복구가 완료되면 복구 중에 디스크에 마지막으로 수신 및 동기화 된 WAL 레코드의 값으로 정적으로 유지됩니다. 스트리밍 복제가 비활성화되었거나 아직 시작되지 않은 경우 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76a64be22601bc127252c3868430ba6f7837c55b" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location replayed during recovery. If recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last WAL record applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">복구 중에 재생 된 마지막 미리 쓰기 로그 위치를 가져옵니다. 복구가 여전히 진행 중이면 단조 증가합니다. 복구가 완료된 경우이 값은 해당 복구 중에 적용된 마지막 WAL 레코드의 값에서 정적으로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="406fdc630e83917e4241518be673ae1f0d8347d2" translate="yes" xml:space="preserve">
          <source>Get start time of an on-line exclusive backup in progress.</source>
          <target state="translated">진행중인 온라인 독점 백업의 시작 시간을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dca6c016406c3b0ed8f48fe56cd9e3bf358bbd54" translate="yes" xml:space="preserve">
          <source>Get subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">서브 필드 가져 오기 ( &lt;code&gt;extract&lt;/code&gt; 과 동일 ); &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;섹션 9.9.1&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="3152064f9ae3eb1ab6d172e1fe8f75ea161bdf61" translate="yes" xml:space="preserve">
          <source>Get subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">서브 필드를 얻으십시오. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;섹션 9.9.1&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4cfad13dc60760cc3b206a5a63697b11a532048c" translate="yes" xml:space="preserve">
          <source>Get time stamp of last transaction replayed during recovery. This is the time at which the commit or abort WAL record for that transaction was generated on the primary. If no transactions have been replayed during recovery, this function returns NULL. Otherwise, if recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last transaction applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">복구 중에 재생 된 마지막 트랜잭션의 타임 스탬프를 가져옵니다. 이것은 해당 트랜잭션에 대한 커밋 또는 중단 WAL 레코드가 기본에서 생성 된 시간입니다. 복구 중에 트랜잭션이 재생되지 않은 경우이 함수는 NULL을 리턴합니다. 그렇지 않으면 복구가 여전히 진행중인 경우 단조 증가합니다. 복구가 완료된 경우이 값은 해당 복구 중에 적용된 마지막 트랜잭션 값에서 정적으로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2286e40b8a539e9f8b5d59de04327253f0b8e306" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value and wraps result into an array.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 모든 JSON 항목을 가져오고 결과를 배열로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="69ca4727f266434b20f8a8cff91f85228790e89c" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 모든 JSON 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f74211e2c2ac907544fec9e563a5484f2bc9bf8f" translate="yes" xml:space="preserve">
          <source>Gets the current status of the weak mode</source>
          <target state="translated">약한 모드의 현재 상태를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="ffe1d3bb8fb75103abea9d97f24675a5e6f74f12" translate="yes" xml:space="preserve">
          <source>Gets the first JSON item returned by JSON path for the specified JSON value. Returns &lt;code&gt;NULL&lt;/code&gt; on no results.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 첫 번째 JSON 항목을 가져옵니다. 결과가 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea0c334189a899d918625993b37ead61ecb3937" translate="yes" xml:space="preserve">
          <source>GiST</source>
          <target state="translated">GiST</target>
        </trans-unit>
        <trans-unit id="2c7e841b76f37f5f1283940a7342c797bb3bd024" translate="yes" xml:space="preserve">
          <source>GiST Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</source>
          <target state="translated">GiST 개발 사이트 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77dacc994e0a5c24fbb20b4e435e091dad5586f5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Built-in Operator Classes</source>
          <target state="translated">GiST 인덱스 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="22165dcd40882c92f600bb8d95e394930c229760" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Examples</source>
          <target state="translated">GiST 지수 : 예</target>
        </trans-unit>
        <trans-unit id="cd4fa206206b0d9b9a4a09e74cdc45a9b7bac6d5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Extensibility</source>
          <target state="translated">GiST 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="1e6e31ed1dfc0534ae7fa938c637d58b4def631a" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Implementation</source>
          <target state="translated">GiST 인덱스 : 구현</target>
        </trans-unit>
        <trans-unit id="494456433e65d5f6cf54c8e3f52f00d35404d83c" translate="yes" xml:space="preserve">
          <source>GiST and SP-GiST indexes can be created for table columns of range types. For instance, to create a GiST index:</source>
          <target state="translated">범위 유형의 테이블 컬럼에 대해 GiST 및 SP-GiST 인덱스를 작성할 수 있습니다. 예를 들어 GiST 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="49924620a95a816339f17d76ecc000e2cecd8a90" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">이상 GIST 지수 &lt;code&gt;ltree&lt;/code&gt; : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c380bccd59920d150dcf1776323ee944932357" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt;: &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">이상 GIST 지수 &lt;code&gt;ltree[]&lt;/code&gt; : &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt; , &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d319a311ddbbf36d4e1fdb2142c71c77f7a27e3" translate="yes" xml:space="preserve">
          <source>GiST indexes additionally accept this parameter:</source>
          <target state="translated">GiST 색인은이 매개 변수를 추가로 승인합니다.</target>
        </trans-unit>
        <trans-unit id="fd10e71b27221cbba626117e71058b4d0b5d0794" translate="yes" xml:space="preserve">
          <source>GiST indexes are also capable of optimizing &amp;ldquo;nearest-neighbor&amp;rdquo; searches, such as</source>
          <target state="translated">GiST 인덱스는 다음과 같은 &quot;인접 이웃&quot;검색을 최적화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e06a8812b702e9e01b2b2a18cfa676aaed004f" translate="yes" xml:space="preserve">
          <source>GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the &lt;em&gt;operator class&lt;/em&gt;). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators:</source>
          <target state="translated">GiST 인덱스는 단일 종류의 인덱스가 아니라 다양한 인덱싱 전략을 구현할 수있는 인프라입니다. 따라서 GiST 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략 ( &lt;em&gt;오퍼레이터 클래스&lt;/em&gt; ) 에 따라 다릅니다 . 예를 들어, PostgreSQL의 표준 배포에는 다음과 같은 연산자를 사용하여 인덱스 된 쿼리를 지원하는 몇 가지 2 차원 기하학적 데이터 유형에 대한 GiST 연산자 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8444450d765d03c90597419731d461339d26e37a" translate="yes" xml:space="preserve">
          <source>GiST stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in GiST.</source>
          <target state="translated">GiST는 일반 검색 트리를 나타냅니다. 균형 잡힌 트리 구조 액세스 방법으로, 임의의 인덱싱 체계를 구현하는 기본 템플릿 역할을합니다. B- 트리, R- 트리 및 기타 여러 인덱싱 체계는 GiST에서 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="b0f44dac1f3500cf2c64a5e96b25bdc72296caa1" translate="yes" xml:space="preserve">
          <source>Give a role a non-default setting of the &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 매개 변수 의 기본 설정이 아닌 역할을 역할에 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d339f7ddc04ed38d6c4f1627fd17d7b3c263479" translate="yes" xml:space="preserve">
          <source>Give a role a non-default, database-specific setting of the &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; 매개 변수 의 기본이 아닌 데이터베이스 별 설정을 역할에 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="657b05bd06e4a30ca8560408b6cca3b16ee24c04" translate="yes" xml:space="preserve">
          <source>Give a role the ability to create other roles and new databases:</source>
          <target state="translated">역할에 다른 역할과 새 데이터베이스를 만들 수있는 기능을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="7e461b397ac9e789e72233367d6e54d13bd1ea4f" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines the index entry's &amp;ldquo;distance&amp;rdquo; from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest &amp;ldquo;distance&amp;rdquo; values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have.</source>
          <target state="translated">인덱스 항목 &lt;code&gt;p&lt;/code&gt; 와 쿼리 값 &lt;code&gt;q&lt;/code&gt; 가 주어지면 이 함수 는 쿼리 값 에서 인덱스 항목의 &quot;거리&quot;를 결정합니다. 연산자 클래스에 순서 연산자가 포함 된 경우이 함수를 제공해야합니다. 순서 연산자를 사용한 쿼리는 가장 작은 &quot;거리&quot;값을 가진 색인 항목을 먼저 반환하여 구현되므로 결과는 연산자의 의미와 일치해야합니다. 리프 인덱스 항목의 경우 결과는 인덱스 항목까지의 거리 만 나타냅니다. 내부 트리 노드의 경우 결과는 모든 하위 항목이 가질 수있는 최소 거리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="693396c0b50006bc8bf563a767c6df7376338535" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines whether the index entry is &amp;ldquo;consistent&amp;rdquo; with the query; that is, could the predicate &amp;ldquo;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;indexable_operator&lt;/code&gt;&lt;code&gt;q&lt;/code&gt;&amp;rdquo; be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;recheck&lt;/code&gt; flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; then the index has tested the predicate condition exactly, whereas if &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; the row is only a candidate match. In that case the system will automatically evaluate the &lt;code&gt;indexable_operator&lt;/code&gt; against the actual row value to see if it is really a match. This convention allows GiST to support both lossless and lossy index structures.</source>
          <target state="translated">인덱스 항목 &lt;code&gt;p&lt;/code&gt; 와 쿼리 값 &lt;code&gt;q&lt;/code&gt; 가 주어지면 이 함수는 인덱스 항목이 쿼리와 &quot;일관성&quot;인지 여부를 결정합니다. 즉 , 인덱스 항목으로 표시되는 행에 대해 술어 &quot; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;indexable_operator&lt;/code&gt; &lt;code&gt;q&lt;/code&gt; &quot;가 참일 수 있습니까? 리프 인덱스 항목의 경우 색인 가능한 조건을 테스트하는 것과 동일하지만 내부 트리 노드의 경우 트리 노드가 나타내는 인덱스의 하위 트리를 스캔해야하는지 여부를 결정합니다. 결과가있을 때 &lt;code&gt;true&lt;/code&gt; 하는 &lt;code&gt;recheck&lt;/code&gt; 플래그도 반환해야합니다. 이것은 술어가 확실히 참인지 아니면 가능한 참인지를 나타냅니다. &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 인 경우인덱스는 술어 조건을 정확하게 테스트 한 반면, &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 인 경우 행은 후보 일치 일뿐입니다. 이 경우 시스템은 실제 행 값과 비교하여 &lt;code&gt;indexable_operator&lt;/code&gt; 를 자동으로 평가하여 실제로 일치하는지 확인합니다. 이 규칙을 통해 GiST는 무손실 및 무손실 인덱스 구조를 모두 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92d55ae3ac298e4b66632b1af221ac34e3be444" translate="yes" xml:space="preserve">
          <source>Given an index tuple and an indexed value, modifies the indicated attribute of the tuple so that it additionally represents the new value. If any modification was done to the tuple, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">인덱스 튜플과 인덱스 값이 주어지면 튜플의 표시된 속성을 수정하여 새 값을 추가로 나타냅니다. 튜플을 수정 한 경우 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="769764fd5b04005314c3f8df7317ab69c5882b21" translate="yes" xml:space="preserve">
          <source>Given the cost of the plan, it is entirely reasonable that no JIT was used; the cost of JIT would have been bigger than the potential savings. Adjusting the cost limits will lead to JIT use:</source>
          <target state="translated">계획 비용이 주어지면 JIT를 사용하지 않은 것이 전적으로 합리적입니다. JIT의 비용은 잠재적 절감액보다 클 것입니다. 비용 한도를 조정하면 JIT가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37460509d9524c32ce3522fe588bb30e9b9a9e2c" translate="yes" xml:space="preserve">
          <source>Given the default configuration and only the first function existing, the first and second calls are insecure. Any user could intercept them by creating the second or third function. By matching the argument type exactly and using the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, the third call is secure.</source>
          <target state="translated">기본 구성과 첫 번째 기능 만 존재하면 첫 번째와 두 번째 호출은 안전하지 않습니다. 모든 사용자는 두 번째 또는 세 번째 기능을 작성하여이를 가로 챌 수 있습니다. 인수 유형을 정확하게 일치시키고 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 사용하면 세 번째 호출이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="40af5c52e4886430e556bb2588adddc7f3345e29" translate="yes" xml:space="preserve">
          <source>Given the sample data from the PostgreSQL tutorial (see &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt;), this returns:</source>
          <target state="translated">PostgreSQL 튜토리얼 ( &lt;a href=&quot;tutorial-sql-intro&quot;&gt;섹션 2.1&lt;/a&gt; 참조 ) 의 샘플 데이터가 주어지면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48862a4ac236aec67af11d9ca9afc2c469e5ae88" translate="yes" xml:space="preserve">
          <source>Gives syntax help on the specified SQL command. If &lt;code&gt;command&lt;/code&gt; is not specified, then psql will list all the commands for which syntax help is available. If &lt;code&gt;command&lt;/code&gt; is an asterisk (&lt;code&gt;*&lt;/code&gt;), then syntax help on all SQL commands is shown.</source>
          <target state="translated">지정된 SQL 명령에 대한 구문 도움말을 제공합니다. 경우 &lt;code&gt;command&lt;/code&gt; 지정되어 있지 않은 경우, psql의 구문 도움말을 사용할 수있는 모든 명령을 나열합니다. 경우 &lt;code&gt;command&lt;/code&gt; 별표 (입니다 &lt;code&gt;*&lt;/code&gt; 모든 SQL 명령에), 다음 구문 도움말을 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="696e22e619af6c7115546ae99d980b04fd02c2c6" translate="yes" xml:space="preserve">
          <source>Gives the distance in statute miles between two points on the Earth's surface.</source>
          <target state="translated">지표면의 두 지점 사이의 법정 마일 거리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2e72630d76d2483c8fcffc2dffd1c7c6a52ab67" translate="yes" xml:space="preserve">
          <source>Global transaction identifier that was assigned to the transaction</source>
          <target state="translated">트랜잭션에 지정된 글로벌 트랜잭션 식별자</target>
        </trans-unit>
        <trans-unit id="31e73c02a46d40c2d70edd740f19c8958fbb213c" translate="yes" xml:space="preserve">
          <source>Global validity checks require extra thought under non-serializable MVCC. For example, a banking application might wish to check that the sum of all credits in one table equals the sum of debits in another table, when both tables are being actively updated. Comparing the results of two successive &lt;code&gt;SELECT sum(...)&lt;/code&gt; commands will not work reliably in Read Committed mode, since the second query will likely include the results of transactions not counted by the first. Doing the two sums in a single repeatable read transaction will give an accurate picture of only the effects of transactions that committed before the repeatable read transaction started &amp;mdash; but one might legitimately wonder whether the answer is still relevant by the time it is delivered. If the repeatable read transaction itself applied some changes before trying to make the consistency check, the usefulness of the check becomes even more debatable, since now it includes some but not all post-transaction-start changes. In such cases a careful person might wish to lock all tables needed for the check, in order to get an indisputable picture of current reality. A &lt;code&gt;SHARE&lt;/code&gt; mode (or higher) lock guarantees that there are no uncommitted changes in the locked table, other than those of the current transaction.</source>
          <target state="translated">전역 유효성 검사에는 직렬화 할 수없는 MVCC에서 추가로 고려해야합니다. 예를 들어, 뱅킹 애플리케이션은 두 테이블이 모두 업데이트 될 때 한 테이블의 모든 크레딧 합계가 다른 테이블의 차변 합계와 같은지 확인하려고 할 수 있습니다. 두 개의 연속 &lt;code&gt;SELECT sum(...)&lt;/code&gt; 의 결과 비교명령은 읽기 커밋 모드에서 안정적으로 작동하지 않습니다. 두 번째 쿼리는 첫 번째 쿼리에서 계산하지 않은 트랜잭션의 결과를 포함하기 때문입니다. 반복 가능한 단일 읽기 트랜잭션에서 두 개의 합계를 수행하면 반복 가능한 읽기 트랜잭션이 시작되기 전에 커밋 된 트랜잭션의 효과 만 정확하게 파악할 수 있지만, 답변이 제공 될 때까지 여전히 관련이 있는지 궁금 할 수 있습니다. 일관성 검사를 시도하기 전에 반복 가능한 읽기 트랜잭션 자체가 일부 변경 사항을 적용한 경우, 트랜잭션 이후의 모든 변경 사항을 포함하지 않기 때문에 점검의 유용성은 더욱 논란의 여지가 있습니다. 이러한 경우주의 깊은 사람은 현재 현실에 대한 확실한 그림을 얻기 위해 점검에 필요한 모든 테이블을 잠그기를 원할 수 있습니다. &lt;code&gt;SHARE&lt;/code&gt; 모드 (또는 그 이상) 잠금은 현재 트랜잭션의 변경 외에 잠긴 테이블에 커밋되지 않은 변경이 없음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">좋은 습관</target>
        </trans-unit>
        <trans-unit id="3c09ec28f005ae7495ffdeada3d59d9447d92430" translate="yes" xml:space="preserve">
          <source>Good results will show most (&amp;gt;90%) individual timing calls take less than one microsecond. Average per loop overhead will be even lower, below 100 nanoseconds. This example from an Intel i7-860 system using a TSC clock source shows excellent performance:</source>
          <target state="translated">좋은 결과는 대부분의 (&amp;gt; 90 %) 개별 타이밍 호출에 1 마이크로 초 미만이 소요됨을 보여줍니다. 루프 당 평균 오버 헤드는 100 나노초 미만으로 훨씬 낮아집니다. TSC 클럭 소스를 사용하는 Intel i7-860 시스템의이 예는 뛰어난 성능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="01af961ffadccd5726ec885717dd08dd99e478cf" translate="yes" xml:space="preserve">
          <source>Grant SELECT privilege to everyone for all tables (and views) you subsequently create in schema &lt;code&gt;myschema&lt;/code&gt;, and allow role &lt;code&gt;webuser&lt;/code&gt; to INSERT into them too:</source>
          <target state="translated">나중에 스키마 &lt;code&gt;myschema&lt;/code&gt; 에서 작성하는 모든 테이블 (및 뷰)에 대해 모든 사람에게 SELECT 권한을 부여 하고 &lt;code&gt;webuser&lt;/code&gt; 역할 도 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24617f7e457da3734cfeda27633b2aa731a9c9ef" translate="yes" xml:space="preserve">
          <source>Grant all available privileges to user &lt;code&gt;manuel&lt;/code&gt; on view &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">보기 &lt;code&gt;kinds&lt;/code&gt; 에 대해 사용자 &lt;code&gt;manuel&lt;/code&gt; 에게 사용 가능한 모든 권한을 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e182dc9d9691657bc39b554f5fd47996c873086" translate="yes" xml:space="preserve">
          <source>Grant all of the privileges available for the object's type. The &lt;code&gt;PRIVILEGES&lt;/code&gt; key word is optional in PostgreSQL, though it is required by strict SQL.</source>
          <target state="translated">객체 유형에 사용할 수있는 모든 권한을 부여하십시오. &lt;code&gt;PRIVILEGES&lt;/code&gt; 이 엄격한 SQL에 필요하지만 키 워드는, PostgreSQL의에서 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="bb6ece16050b16e5f45fddd08ab0ab254c3c1353" translate="yes" xml:space="preserve">
          <source>Grant all privileges on all views in schema &lt;code&gt;public&lt;/code&gt; to role &lt;code&gt;webuser&lt;/code&gt;:</source>
          <target state="translated">schema &lt;code&gt;public&lt;/code&gt; 의 모든 뷰에 대한 모든 권한 을 역할 &lt;code&gt;webuser&lt;/code&gt; 에 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="269d15aac0905b9feb98dc13ab02754db1782270" translate="yes" xml:space="preserve">
          <source>Grant insert privilege to all users on table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 모든 사용자에게 삽입 권한 부여 :</target>
        </trans-unit>
        <trans-unit id="ba27670ed37d6c78d0b14c4148d50cc7aab110fa" translate="yes" xml:space="preserve">
          <source>Grant membership in role &lt;code&gt;admins&lt;/code&gt; to user &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;joe&lt;/code&gt; 사용자에게 역할 &lt;code&gt;admins&lt;/code&gt; 멤버십 부여 :</target>
        </trans-unit>
        <trans-unit id="1f88fd823ea9c3dd2200a42432c3efa9ef706298" translate="yes" xml:space="preserve">
          <source>Granting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied to &lt;code&gt;SERIAL&lt;/code&gt; columns. Permissions on sequences must be set separately.</source>
          <target state="translated">테이블에 대한 권한을 &lt;code&gt;SERIAL&lt;/code&gt; 열에 묶인 시퀀스를 포함하여 테이블에 사용 된 시퀀스에 대한 권한이 자동으로 확장되지는 않습니다 . 시퀀스에 대한 권한은 별도로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">보다 큰</target>
        </trans-unit>
        <trans-unit id="e7c7faa35b86c7d8f2aa278406d57686d0e76cab" translate="yes" xml:space="preserve">
          <source>Greater-than operator</source>
          <target state="translated">보다 큰 연산자</target>
        </trans-unit>
        <trans-unit id="1b0cd62dcaabb41d866e961c21030484cdf15a5a" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to operator</source>
          <target state="translated">같거나 큰 연산자</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="fafd8001d43d87515ae86352c97c37616a4d6762" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time</source>
          <target state="translated">그리니치 표준시</target>
        </trans-unit>
        <trans-unit id="6261b12bce7847fa9426739910b4246568401661" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1-99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="translated">그레고리력 연도 AD 1-99는 앞에 0이있는 4 자리 숫자를 사용하여 입력 할 수 있습니다 (예 : &lt;code&gt;0099&lt;/code&gt; 는 AD 99).</target>
        </trans-unit>
        <trans-unit id="2b13ec9d057eee3b8bf047437042e0b54f1f6425" translate="yes" xml:space="preserve">
          <source>Grouping operations are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; operation are not actually evaluated, but they must match exactly expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. Bits are assigned with the rightmost argument being the least-significant bit; each bit is 0 if the corresponding expression is included in the grouping criteria of the grouping set generating the result row, and 1 if it is not. For example:</source>
          <target state="translated">그룹화 작업은 결과 행을 구별하기 위해 그룹화 세트 ( &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;7.2.4&lt;/a&gt; 참조)와 함께 사용됩니다 . &lt;code&gt;GROUPING&lt;/code&gt; 연산에 대한 인수 는 실제로 평가되지 않지만 연관된 쿼리 레벨 의 &lt;code&gt;GROUP BY&lt;/code&gt; 절에 제공된 표현식과 정확하게 일치해야합니다 . 비트에는 가장 중요한 인수가 가장 중요하지 않은 비트가 할당됩니다. 결과 행을 생성하는 그룹화 세트의 그룹화 기준에 해당 표현식이 포함되어 있으면 각 비트는 0이고, 그렇지 않으면 1입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88d7c69cfe151f010dd11e55984fa5a2e4485f4b" translate="yes" xml:space="preserve">
          <source>Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the &lt;code&gt;DISTINCT&lt;/code&gt; clause (see &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;Section 7.3.3&lt;/a&gt;).</source>
          <target state="translated">집계 식없이 그룹화하면 열의 고유 값 집합을 효과적으로 계산합니다. &lt;code&gt;DISTINCT&lt;/code&gt; 절을 사용 하여이 작업을 수행 할 수도 있습니다 ( &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;섹션 7.3.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b82d3603eb93c98eb825eb4e6b01ee350ff3fb6d" translate="yes" xml:space="preserve">
          <source>HASH version number</source>
          <target state="translated">해시 버전 번호</target>
        </trans-unit>
        <trans-unit id="1cc155b76768b5b5fb2f3643a0744204e68a9ccc" translate="yes" xml:space="preserve">
          <source>HBA</source>
          <target state="translated">HBA</target>
        </trans-unit>
        <trans-unit id="0feddc013d3db0d214cc286a21a9e52cacbc17e4" translate="yes" xml:space="preserve">
          <source>HMAC: Keyed-Hashing for Message Authentication.</source>
          <target state="translated">HMAC : 메시지 인증을위한 키 해싱.</target>
        </trans-unit>
        <trans-unit id="06833bde6c3138c525040c232dbadac4725bac88" translate="yes" xml:space="preserve">
          <source>HOT</source>
          <target state="translated">HOT</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="61a2a1882fc631d64e7d30ef57cec31971ea2c09" translate="yes" xml:space="preserve">
          <source>Had there been MCV lists for the two columns, &lt;code&gt;eqjoinsel&lt;/code&gt; would have used direct comparison of the MCV lists to determine the join selectivity within the part of the column populations represented by the MCVs. The estimate for the remainder of the populations follows the same approach shown here.</source>
          <target state="translated">두 열에 대해 MCV 목록이있는 경우 &lt;code&gt;eqjoinsel&lt;/code&gt; 은 MCV 목록을 직접 비교하여 MCV가 나타내는 열 모집단 부분 내에서 조인 선택성을 결정했을 것입니다. 나머지 모집단의 추정치는 여기에 표시된 것과 동일한 접근 방식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4bf7a6d465bc019e543ce8b66fbf5cd1235516a8" translate="yes" xml:space="preserve">
          <source>Had we not supplied values for all the subfields of the column, the remaining subfields would have been filled with null values.</source>
          <target state="translated">열의 모든 서브 필드에 값을 제공하지 않은 경우 나머지 서브 필드는 널값으로 채워 졌을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0c8e4e26ef951b2d257ad48905d56d36c233bc8" translate="yes" xml:space="preserve">
          <source>Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">유효하지 않거나 모호한 타임 스탬프 처리</target>
        </trans-unit>
        <trans-unit id="56d01e9677df53b4a2c4ef118ff77a201dd06a2e" translate="yes" xml:space="preserve">
          <source>Has a replication origin been configured in the current session?</source>
          <target state="translated">현재 세션에서 복제 원본이 구성 되었습니까?</target>
        </trans-unit>
        <trans-unit id="3127cc395c91e262a7a0864c40a7527573818c9c" translate="yes" xml:space="preserve">
          <source>Has the constraint been validated? Currently, can only be false for foreign keys and CHECK constraints</source>
          <target state="translated">구속 조건이 검증 되었습니까? 현재 외래 키 및 CHECK 제약 조건에 대해서만 false 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc36e4e0152a0239de102d530bd0c47b3d9e3a1" translate="yes" xml:space="preserve">
          <source>Hash Partitioning</source>
          <target state="translated">해시 분할</target>
        </trans-unit>
        <trans-unit id="90507c1a5721f22f49292627451907b5c9b469f4" translate="yes" xml:space="preserve">
          <source>Hash functions &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;hash_murmur2&lt;/code&gt; and &lt;code&gt;hash_fnv1a&lt;/code&gt; accept an input value and an optional seed parameter. In case the seed isn't provided the value of &lt;code&gt;:default_seed&lt;/code&gt; is used, which is initialized randomly unless set by the command-line &lt;code&gt;-D&lt;/code&gt; option. Hash functions can be used to scatter the distribution of random functions such as &lt;code&gt;random_zipfian&lt;/code&gt; or &lt;code&gt;random_exponential&lt;/code&gt;. For instance, the following pgbench script simulates possible real world workload typical for social media and blogging platforms where few accounts generate excessive load:</source>
          <target state="translated">해시 함수 &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;hash_murmur2&lt;/code&gt; 및 &lt;code&gt;hash_fnv1a&lt;/code&gt; 는 입력 값과 선택적 시드 매개 변수를 승인합니다. 시드가 제공되지 않은 경우 &lt;code&gt;:default_seed&lt;/code&gt; 값 이 사용되며 명령 행 &lt;code&gt;-D&lt;/code&gt; 옵션으로 설정하지 않는 한 임의로 초기화됩니다 . 해시 함수는 &lt;code&gt;random_zipfian&lt;/code&gt; 또는 &lt;code&gt;random_exponential&lt;/code&gt; 과 같은 임의 함수의 분포를 분산시키는 데 사용할 수 있습니다 . 예를 들어, 다음 pgbench 스크립트는 계정이 과도하게 많은 계정을 생성하는 소셜 미디어 및 블로그 플랫폼에 일반적인 실제 워크로드를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="cc1cfbcfc5781fb19f027f2126a6d7e099a4d8b1" translate="yes" xml:space="preserve">
          <source>Hash indexes</source>
          <target state="translated">해시 인덱스</target>
        </trans-unit>
        <trans-unit id="f9f75839548d1e6a1a51f586eb631d2c4a104ff8" translate="yes" xml:space="preserve">
          <source>Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the &lt;code&gt;=&lt;/code&gt; operator. The following command is used to create a hash index:</source>
          <target state="translated">해시 인덱스는 단순한 동등 비교 만 처리 할 수 ​​있습니다. 쿼리 플래너는 인덱스 된 열이 &lt;code&gt;=&lt;/code&gt; 연산자를 사용하여 비교할 때마다 해시 인덱스 사용을 고려 합니다. 다음 명령은 해시 인덱스를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea4ccce2369daab1022355aaafd39217be056ac4" translate="yes" xml:space="preserve">
          <source>Hashes/sec</source>
          <target state="translated">Hashes/sec</target>
        </trans-unit>
        <trans-unit id="fa2065c836a17176e9e4314cc0f9ae6d0e4ea762" translate="yes" xml:space="preserve">
          <source>Having created this trigger, any change in &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; will automatically be reflected into &lt;code&gt;tsv&lt;/code&gt;, without the application having to worry about it.</source>
          <target state="translated">이 트리거를 생성 하면 응용 프로그램이 걱정할 필요없이 &lt;code&gt;title&lt;/code&gt; 이나 &lt;code&gt;body&lt;/code&gt; 변경 사항 이 자동으로 &lt;code&gt;tsv&lt;/code&gt; 에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="349ced815f5c84c9f5228e606a1b7ba0c2ddee06" translate="yes" xml:space="preserve">
          <source>Having defined the types, we can use them to create tables:</source>
          <target state="translated">유형을 정의한 후이를 사용하여 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="847116884ad55b09c96b3c4dc05ec99dcc5ec687" translate="yes" xml:space="preserve">
          <source>Header extension area length</source>
          <target state="translated">헤더 확장 영역 길이</target>
        </trans-unit>
        <trans-unit id="e10aa6b979969f7c629b2451c2c2a904b3d450a7" translate="yes" xml:space="preserve">
          <source>Heap-Only Tuples</source>
          <target state="translated">힙 전용 튜플</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="0107076effd18727f0d6bde8cfc48a85171576c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;*&lt;/code&gt; is a shorthand for &amp;ldquo;all columns&amp;rdquo;. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; So the same result would be had with:</source>
          <target state="translated">여기서 &lt;code&gt;*&lt;/code&gt; 는&amp;ldquo;모든 열&amp;rdquo;의 약어입니다. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; 따라서 동일한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4c0298ee7318c32798634cdbf2dfdaaab57a634f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ANY&lt;/code&gt; can be considered either as introducing a subquery, or as being an aggregate function, if the subquery returns one row with a Boolean value. Thus the standard name cannot be given to these aggregates.</source>
          <target state="translated">여기서 &lt;code&gt;ANY&lt;/code&gt; , 부질 도입으로, 또는 총 함수로서 간주 될 수 어느 부질 돌아 가면 부울 값과 하나의 행. 따라서 이러한 집계에는 표준 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4131a740f8662a6e1405a124ef5fe7cf873c01" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;expression&lt;/code&gt; is an arbitrary value expression that is evaluated for all rows. A set of rows for which all the expressions are equal are considered duplicates, and only the first row of the set is kept in the output. Note that the &amp;ldquo;first row&amp;rdquo; of a set is unpredictable unless the query is sorted on enough columns to guarantee a unique ordering of the rows arriving at the &lt;code&gt;DISTINCT&lt;/code&gt; filter. (&lt;code&gt;DISTINCT ON&lt;/code&gt; processing occurs after &lt;code&gt;ORDER BY&lt;/code&gt; sorting.)</source>
          <target state="translated">여기서 &lt;code&gt;expression&lt;/code&gt; 은 모든 행에 대해 평가되는 임의의 값 표현식입니다. 모든 표현식이 동일한 행 세트는 중복으로 간주되며 세트의 첫 번째 행만 출력에 유지됩니다. &lt;code&gt;DISTINCT&lt;/code&gt; 필터에 도달하는 행의 고유 한 순서를 보장하기 위해 쿼리가 충분한 열에서 정렬되지 않으면 세트의 &quot;첫 번째 행&quot;을 예측할 수 없습니다 . ( &lt;code&gt;ORDER BY&lt;/code&gt; 정렬 후 &lt;code&gt;DISTINCT ON&lt;/code&gt; 처리가 발생합니다 .)</target>
        </trans-unit>
        <trans-unit id="32e70bf63bd6299c1b514b324e5813b6785f48fc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;sum&lt;/code&gt; 은 전체 그룹에서 단일 값을 계산하는 집계 함수입니다. 사용 가능한 집계 함수에 대한 자세한 정보는 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c74e599f4f4cd10f806357bb4a577d879a636f92" translate="yes" xml:space="preserve">
          <source>Here again, the result row ordering might vary. You can ensure consistent results by using &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; together: &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">여기서도 결과 행 순서가 다를 수 있습니다. &lt;code&gt;DISTINCT&lt;/code&gt; 와 &lt;code&gt;ORDER BY&lt;/code&gt; 를 함께 사용하면 일관된 결과를 얻을 수 있습니다 . &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9361fe781c0dc9515f2a15d806649d45978ad2ff" translate="yes" xml:space="preserve">
          <source>Here are a few more operating-system-specific suggestions. (In each case be sure to use the proper installation directory and user name where we show generic values.)</source>
          <target state="translated">운영 체제 별 제안 사항이 몇 가지 더 있습니다. (각각의 경우 일반적인 값을 표시하는 올바른 설치 디렉토리 및 사용자 이름을 사용해야합니다.)</target>
        </trans-unit>
        <trans-unit id="33c629349369b081c96a4709bd4c05ca3d526b68" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;code&gt;width&lt;/code&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 필드와 &lt;code&gt;-&lt;/code&gt; 플래그를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7e1f296e08c37893cc7499c23d5ef526f191a997" translate="yes" xml:space="preserve">
          <source>Here are some example collations that might be created:</source>
          <target state="translated">생성 될 수있는 데이터 정렬의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="794bf261c0ef6d9f03e6ee073f42ca9e62437531" translate="yes" xml:space="preserve">
          <source>Here are some examples for the Norwegian language:</source>
          <target state="translated">노르웨이어에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aedfd7af6c8c45fb8ea4b749385a6c955d7ebd4b" translate="yes" xml:space="preserve">
          <source>Here are some examples of &lt;code&gt;WHERE&lt;/code&gt; clauses:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2b46ad535b1f1605c8d8b383d4b83d313d3c5c39" translate="yes" xml:space="preserve">
          <source>Here are some examples of full text search:</source>
          <target state="translated">전체 텍스트 검색의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59581a37d8149d77f6e2121b432ef3ab5471d652" translate="yes" xml:space="preserve">
          <source>Here are some examples of path matching:</source>
          <target state="translated">경로 일치의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="081304796cf08884f88e8e57322d960864d34d64" translate="yes" xml:space="preserve">
          <source>Here are some examples of the basic format conversions:</source>
          <target state="translated">기본 형식 변환의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6671c9ef7af5c4291212558669b68a47697a4f97" translate="yes" xml:space="preserve">
          <source>Here are some examples of the proper syntax for inserting and updating composite columns. First, inserting or updating a whole column:</source>
          <target state="translated">다음은 복합 열을 삽입하고 업데이트하기위한 올바른 구문의 예입니다. 먼저 전체 열을 삽입하거나 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="cff6bd1f9746e782ec9405f845ffac129954f75a" translate="yes" xml:space="preserve">
          <source>Here are some suggestions about the easiest ways to perform common tasks when updating catalog data files.</source>
          <target state="translated">다음은 카탈로그 데이터 파일을 업데이트 할 때 일반적인 작업을 수행하는 가장 쉬운 방법에 대한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="8d395c7f381e1a472cda6f6e9e7b568dac052ead" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="translated">다음은 시작하는 데 도움이되는 간단한 예입니다. 자세한 정보 및 예는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;섹션 37.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="211fc895cd2c281ef748e752305609850c1006cd" translate="yes" xml:space="preserve">
          <source>Here are some usage examples:</source>
          <target state="translated">사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="869c324dd483307e5d715a3f86abbbcd015bfd60" translate="yes" xml:space="preserve">
          <source>Here are two complete examples:</source>
          <target state="translated">다음은 두 가지 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="461b806fbebb6f513c6608122e9ae50853cfb34f" translate="yes" xml:space="preserve">
          <source>Here are two simple examples of defining composite types:</source>
          <target state="translated">복합 유형을 정의하는 간단한 두 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">다음은 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="879a2b3e6157baeae30fe41038c69a70091e7ab2" translate="yes" xml:space="preserve">
          <source>Here is a concatenation of two values of unspecified types:</source>
          <target state="translated">다음은 지정되지 않은 유형의 두 값을 연결 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc7d83360ed38ff4e831e43a35b15e111bd3cccc" translate="yes" xml:space="preserve">
          <source>Here is a more complete example of bloom index definition and usage, as well as a comparison with equivalent btree indexes. The bloom index is considerably smaller than the btree index, and can perform better.</source>
          <target state="translated">다음은 블룸 인덱스 정의 및 사용법에 대한보다 완전한 예제와 동등한 btree 인덱스와의 비교입니다. 블룸 인덱스는 btree 인덱스보다 상당히 작으며 더 잘 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6e374336fa7e724d2419753cd63165e6b67b04" translate="yes" xml:space="preserve">
          <source>Here is a more complex example: &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds.</source>
          <target state="translated">더 복잡한 예는 다음과 같습니다. &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; 는 15 시간, 12 분 및 2 초 + 20 밀리 초 + 1230 마이크로 초 = 2.021230 초입니다. .</target>
        </trans-unit>
        <trans-unit id="4b2dfe5ad07694de5eeb1cdf20070a788ef8e7be" translate="yes" xml:space="preserve">
          <source>Here is a sample of data suitable for copying into a table from &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;STDIN&lt;/code&gt; 에서 테이블로 복사하기에 적합한 데이터 샘플입니다 .</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="79fce6a010075477b9d4f3d2b7d0892550a64ad8" translate="yes" xml:space="preserve">
          <source>Here is a snippet of a log file generated in a single-client run:</source>
          <target state="translated">다음은 단일 클라이언트 실행에서 생성 된 로그 파일의 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="5a5fc7880a4ea236d1b3bb1d32e27412d9d31338" translate="yes" xml:space="preserve">
          <source>Here is a trivial example, just to show what the output looks like:</source>
          <target state="translated">다음은 출력 결과를 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="196e7b38bd23094a34f08fd4e1d56d0de9737199" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses &lt;code&gt;ldapsearchfilter&lt;/code&gt; instead of &lt;code&gt;ldapsearchattribute&lt;/code&gt; to allow authentication by user ID or email address:</source>
          <target state="translated">다음은 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 대신 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 를 사용하여 사용자 ID 또는 이메일 주소로 인증 할 수 있는 검색 + 바인드 구성의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="adb407aa80bcb23407a6343cd3fb06a44aaa7159" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses DNS SRV discovery to find the host name(s) and port(s) for the LDAP service for the domain name &lt;code&gt;example.net&lt;/code&gt;:</source>
          <target state="translated">다음은 DNS SRV 감지를 사용하여 도메인 이름 &lt;code&gt;example.net&lt;/code&gt; 에 대한 LDAP 서비스의 호스트 이름 및 포트를 찾는 검색 + 바인드 구성의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8294bedf7f93c4debbc985ac5b71d91485ccb87a" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration:</source>
          <target state="translated">검색 + 바인드 구성의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1012c91578d9866c1a1a935ccf5f74b1c398069" translate="yes" xml:space="preserve">
          <source>Here is an example for a simple-bind LDAP configuration:</source>
          <target state="translated">다음은 단순 바인딩 LDAP 구성의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1e2a8eb0839de265c32ba8726c7fb8ce612f9ebc" translate="yes" xml:space="preserve">
          <source>Here is an example of a dictionary definition using the &lt;code&gt;simple&lt;/code&gt; template:</source>
          <target state="translated">다음은 &lt;code&gt;simple&lt;/code&gt; 템플릿을 사용하는 사전 정의의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d6c310d42c6ff4f581c1e303b9eef10bb403ca6c" translate="yes" xml:space="preserve">
          <source>Here is an example of a function with an ordinality column added:</source>
          <target state="translated">다음은 순서 열이 추가 된 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="39d9a1ec97da0de0b2ebe001d89411c194d0136a" translate="yes" xml:space="preserve">
          <source>Here is an example of a query plan for a query using an aggregate function:</source>
          <target state="translated">다음은 집계 함수를 사용하는 쿼리에 대한 쿼리 계획의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f6d493babc38181bb9e797ebc36b6dee1ed42248" translate="yes" xml:space="preserve">
          <source>Here is an example of collecting functional-dependency statistics:</source>
          <target state="translated">다음은 기능 종속 통계를 수집하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d635cae1e0a20113dd837d7519806bc17d144c7b" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a foreign table with &lt;code&gt;postgres_fdw&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;postgres_fdw&lt;/code&gt; 로 외래 테이블을 만드는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d65bbbca8355ed90ddee51a853e323cb2c5356" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed</source>
          <target state="translated">다음은 대기 이벤트를 보는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="289e8ce361948510d7bea9298d834548d8a0bcac" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 로 테이블 샘플을 선택하는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a28a21ccc575549b0e4278f1befd6c3171d0c15c" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_TIME&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 으로 테이블 샘플을 선택하는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1b25585e57445c9a690160c1f6293b2c2334f6" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; to display the execution plan for a prepared query:</source>
          <target state="translated">다음은 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 를 사용하여 준비된 쿼리에 대한 실행 계획을 표시 하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="3d0353f1bd1f4e5d0cdada03e8194af993f90dd3" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to initialize a fresh database cluster with &lt;code&gt;sepgsql&lt;/code&gt; functions and security labels installed. Adjust the paths shown as appropriate for your installation:</source>
          <target state="translated">다음은 &lt;code&gt;sepgsql&lt;/code&gt; 함수 및 보안 레이블이 설치된 새 데이터베이스 클러스터를 초기화하는 방법을 보여주는 예 입니다. 설치에 따라 표시된 경로를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="f5681a46af83bb7c4af1228232eef4280217edbe" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to insert the &lt;code&gt;unaccent&lt;/code&gt; dictionary into a text search configuration:</source>
          <target state="translated">다음은 &lt;code&gt;unaccent&lt;/code&gt; 사전을 텍스트 검색 구성 에 삽입하는 방법을 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="740b499e9d1667a11938c2361c53f8d80be32b73" translate="yes" xml:space="preserve">
          <source>Here is an example showing the effects of &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;LIMIT&lt;/code&gt; 의 효과를 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b663de54fe9a475edef4cab194ba9fd34363260e" translate="yes" xml:space="preserve">
          <source>Here is an example that selects only the ten highest-ranked matches:</source>
          <target state="translated">다음은 10 개의 최고 순위 일치 항목 만 선택하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="df8103a128aa015d77a6739520d4e9345c77b089" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to compare each employee's salary with the average salary in his or her department:</source>
          <target state="translated">다음은 각 직원의 급여를 부서의 평균 급여와 비교하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b75486070871a14c2ef5c89ea4b7f39dda615103" translate="yes" xml:space="preserve">
          <source>Here is another example of resolving an operator with one known and one unknown input:</source>
          <target state="translated">다음은 하나의 알려진 입력과 하나의 알려지지 않은 입력으로 연산자를 해결하는 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="862cabf7adcfd5c087659f8a55b3eecf121ea793" translate="yes" xml:space="preserve">
          <source>Here is another example: it calculates the total sales for each product (rather than the total sales of all products):</source>
          <target state="translated">또 다른 예는 다음과 같습니다. 모든 제품의 총 매출이 아닌 각 제품의 총 매출을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a6970b339f07dcc03e141391304c0d8752344244" translate="yes" xml:space="preserve">
          <source>Here is sample status output from pg_ctl:</source>
          <target state="translated">다음은 pg_ctl의 샘플 상태 출력입니다.</target>
        </trans-unit>
        <trans-unit id="1352c501bf85911546ec6a7652f925835c799c63" translate="yes" xml:space="preserve">
          <source>Here is some example output:</source>
          <target state="translated">다음은 예제 출력입니다.</target>
        </trans-unit>
        <trans-unit id="e962869eb6c37279a68d52de2ccf4f45b22a61bc" translate="yes" xml:space="preserve">
          <source>Here is the same plan with cost estimates suppressed:</source>
          <target state="translated">비용 산정이 억제 된 동일한 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fabdc0d28afb5f0b655ec42a14587280ddf1ed63" translate="yes" xml:space="preserve">
          <source>Here is the same query, but in YAML format:</source>
          <target state="translated">다음은 동일한 쿼리이지만 YAML 형식입니다.</target>
        </trans-unit>
        <trans-unit id="760b794b45c32777224d4cbdefb3ac43472e24da" translate="yes" xml:space="preserve">
          <source>Here is the same query, with JSON output formatting:</source>
          <target state="translated">다음은 JSON 출력 형식의 동일한 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="a12bd1a7adf1cd80938f005fb42c32962ebef7a7" translate="yes" xml:space="preserve">
          <source>Here is the same search+bind configuration written as a URL:</source>
          <target state="translated">다음은 URL로 작성된 동일한 검색 + 바인드 구성입니다.</target>
        </trans-unit>
        <trans-unit id="841d1a406c85c774b7e74eabd4886bcaf8000efc" translate="yes" xml:space="preserve">
          <source>Here it can be seen that column 1 (zip code) fully determines column 5 (city) so the coefficient is 1.0, while city only determines zip code about 42% of the time, meaning that there are many cities (58%) that are represented by more than a single ZIP code.</source>
          <target state="translated">여기서 1 열 (우편 번호)은 5 열 (도시)을 완전히 결정하므로 계수는 1.0이고, 도시는 우편 번호를 시간의 약 42 % 만 결정하므로 많은 도시 (58 %)가 있음을 의미합니다. 하나 이상의 우편 번호로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae0c10bf978a8e41d20283c701cce10abe5e998" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;$1&lt;/code&gt; references the value of the first function argument whenever the function is invoked.</source>
          <target state="translated">여기서 &lt;code&gt;$1&lt;/code&gt; 은 함수가 호출 될 때마다 첫 번째 함수 인수의 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e24bb102552ef59f6370ebf0e5c3297d839673d3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; before &lt;code&gt;cities&lt;/code&gt; indicates that the query should be run over only the &lt;code&gt;cities&lt;/code&gt; table, and not tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support this &lt;code&gt;ONLY&lt;/code&gt; notation.</source>
          <target state="translated">여기에 &lt;code&gt;ONLY&lt;/code&gt; 전에 &lt;code&gt;cities&lt;/code&gt; 쿼리 만 이상 실행해야 함을 나타냅니다 &lt;code&gt;cities&lt;/code&gt; 아래 테이블을 테이블을, 그리고 &lt;code&gt;cities&lt;/code&gt; 상속 계층 구조입니다. 이미 논의한 많은 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; ) 은이 표기법 &lt;code&gt;ONLY&lt;/code&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c60ac8b55debcc4cd6f35118bfe06a2acf106ceb" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; keyword indicates that the query should apply only to &lt;code&gt;cities&lt;/code&gt;, and not any tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support the &lt;code&gt;ONLY&lt;/code&gt; keyword.</source>
          <target state="translated">여기서 &lt;code&gt;ONLY&lt;/code&gt; 키워드는 상속 계층 구조에서 &lt;code&gt;cities&lt;/code&gt; 아래에있는 테이블이 아니라 쿼리 만 &lt;code&gt;cities&lt;/code&gt; 적용해야 함을 나타냅니다 . 이미 논의한 많은 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; ) 은 &lt;code&gt;ONLY&lt;/code&gt; 키워드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="180331b7141355384ecd89f79e056920df2b9440" translate="yes" xml:space="preserve">
          <source>Here the first field is a non-NULL empty string, the third is NULL.</source>
          <target state="translated">여기서 첫 번째 필드는 NULL이 아닌 빈 문자열이고 세 번째 필드는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="5f5c637c8dd6f2e0bc8a363ff5737852d1e4d516" translate="yes" xml:space="preserve">
          <source>Here the planner has decided to use a two-step plan: the child plan node visits an index to find the locations of rows matching the index condition, and then the upper plan node actually fetches those rows from the table itself. Fetching rows separately is much more expensive than reading them sequentially, but because not all the pages of the table have to be visited, this is still cheaper than a sequential scan. (The reason for using two plan levels is that the upper plan node sorts the row locations identified by the index into physical order before reading them, to minimize the cost of separate fetches. The &amp;ldquo;bitmap&amp;rdquo; mentioned in the node names is the mechanism that does the sorting.)</source>
          <target state="translated">여기서 플래너는 2 단계 계획을 사용하기로 결정했습니다. 하위 계획 노드는 인덱스를 방문하여 인덱스 조건과 일치하는 행의 위치를 ​​찾은 다음 상위 계획 노드는 실제로 해당 행을 테이블 자체에서 가져옵니다. 행을 개별적으로 가져 오는 것은 순차적으로 읽는 것보다 훨씬 비싸지 만 테이블의 모든 페이지를 방문 할 필요는 없기 때문에 순차 스캔보다 저렴합니다. (두 개의 계획 레벨을 사용하는 이유는 상위 계획 노드가 인덱스를 통해 식별 된 행 위치를 읽기 전에 물리적 순서로 정렬하여 별도의 페치 비용을 최소화하기 때문입니다. 노드 이름에 언급 된 &quot;비트 맵&quot;은 정렬합니다.)</target>
        </trans-unit>
        <trans-unit id="09e8656c67ee501e993f2cabda72b9c29cefa0ac" translate="yes" xml:space="preserve">
          <source>Here the query's IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:</source>
          <target state="translated">여기서 쿼리의 IP 주소는 부분 인덱스로 덮여 있습니다. 다음 쿼리는 인덱스에서 제외 된 IP 주소를 사용하므로 부분 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ec31c843165653bc80fe695cd716d3b9ef2fc60" translate="yes" xml:space="preserve">
          <source>Here the sum is taken from the first (lowest) salary up through the current one, including any duplicates of the current one (notice the results for the duplicated salaries).</source>
          <target state="translated">여기서 합계는 현재 급여의 사본을 포함하여 현재 급여를 통해 첫 번째 (가장 낮은) 급여에서 가져옵니다 (중복 급여의 결과에 주목).</target>
        </trans-unit>
        <trans-unit id="537366727b0a957f32d32f1d223a0385ada41099" translate="yes" xml:space="preserve">
          <source>Here the system has implicitly resolved the unknown-type literal as type &lt;code&gt;float8&lt;/code&gt; before applying the chosen operator. We can verify that &lt;code&gt;float8&lt;/code&gt; and not some other type was used:</source>
          <target state="translated">여기서 시스템은 선택된 연산자를 적용하기 전에 알 수없는 유형 리터럴을 &lt;code&gt;float8&lt;/code&gt; 유형으로 암시 적으로 해결했습니다 . &lt;code&gt;float8&lt;/code&gt; 과 다른 유형이 사용되지 않았 음을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf1e98ca0f0c927b9d08ba4561b2098f2af147e3" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;tenk1&lt;/code&gt; contains 10000 rows, as do its indexes, but the indexes are (unsurprisingly) much smaller than the table.</source>
          <target state="translated">여기서는 인덱스와 마찬가지로 &lt;code&gt;tenk1&lt;/code&gt; 에 10000 개의 행이 포함되어 있지만 인덱스가 테이블보다 훨씬 작다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0eab29aaf89686f1fe2e4313a3e207759c193e4" translate="yes" xml:space="preserve">
          <source>Here we can see that the index returned one candidate row, which was then rejected by a recheck of the index condition. This happens because a GiST index is &amp;ldquo;lossy&amp;rdquo; for polygon containment tests: it actually returns the rows with polygons that overlap the target, and then we have to do the exact containment test on those rows.</source>
          <target state="translated">여기서 인덱스가 하나의 후보 행을 리턴 한 후 인덱스 조건을 다시 점검하여 거부되었음을 알 수 있습니다. GiST 인덱스는 다각형 포함 테스트에 대해 &quot;손실&quot;하기 때문에 발생합니다. 실제로 대상과 겹치는 다각형이있는 행을 반환 한 다음 해당 행에 대해 정확한 포함 테스트를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d135a143a8ec460162e891ace4cc0562f7f0ea6" translate="yes" xml:space="preserve">
          <source>Here we give a short overview of the stages a query has to pass in order to obtain a result.</source>
          <target state="translated">여기서는 결과를 얻기 위해 쿼리가 통과해야하는 단계에 대한 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe633ffbd28597ca13c601e922e114369f31f0" translate="yes" xml:space="preserve">
          <source>Here we have relabeled the weather table as &lt;code&gt;W1&lt;/code&gt; and &lt;code&gt;W2&lt;/code&gt; to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.:</source>
          <target state="translated">여기 에서는 조인의 왼쪽과 오른쪽을 구별 할 수 있도록 날씨 테이블의 레이블을 &lt;code&gt;W1&lt;/code&gt; 과 &lt;code&gt;W2&lt;/code&gt; 로 재 지정 했습니다. 다른 쿼리에서 이러한 종류의 별칭을 사용하여 입력 내용을 저장할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="42307deb2832e0c7af756f3107b84bf8b2ea8057" translate="yes" xml:space="preserve">
          <source>Here we have used &lt;code&gt;setweight&lt;/code&gt; to label the source of each lexeme in the finished &lt;code&gt;tsvector&lt;/code&gt;, and then merged the labeled &lt;code&gt;tsvector&lt;/code&gt; values using the &lt;code&gt;tsvector&lt;/code&gt; concatenation operator &lt;code&gt;||&lt;/code&gt;. (&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; gives details about these operations.)</source>
          <target state="translated">여기에 우리가 사용하고 &lt;code&gt;setweight&lt;/code&gt; 을 완성 각 어휘의 소스 레이블을 &lt;code&gt;tsvector&lt;/code&gt; 한 다음 표시된 통합 &lt;code&gt;tsvector&lt;/code&gt; 의 사용하여 값 &lt;code&gt;tsvector&lt;/code&gt; 의 연결 연산자를 &lt;code&gt;||&lt;/code&gt; . ( &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;12.4.1 절&lt;/a&gt; 에 이러한 작업에 대한 자세한 내용이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ebe0ff0a0f834e90a6235b06460f658da331e569" translate="yes" xml:space="preserve">
          <source>Here's a simple example of usage:</source>
          <target state="translated">다음은 간단한 사용법 예입니다.</target>
        </trans-unit>
        <trans-unit id="a00d1ad8972f6aee9ca962b7dd2f9cc873a842a4" translate="yes" xml:space="preserve">
          <source>Here's an annotated example of &lt;code&gt;lquery&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;lquery&lt;/code&gt; 의 주석이 달린 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d49be83bb6ef95a34484a28f1063c126af2cd0f3" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;ltxtquery&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;ltxtquery&lt;/code&gt; 예 입니다 .</target>
        </trans-unit>
        <trans-unit id="48493c355bde53a50b460fe64d3981e1bf2c28dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;DictFile&lt;/code&gt;, &lt;code&gt;AffFile&lt;/code&gt;, and &lt;code&gt;StopWords&lt;/code&gt; specify the base names of the dictionary, affixes, and stop-words files. The stop-words file has the same format explained above for the &lt;code&gt;simple&lt;/code&gt; dictionary type. The format of the other files is not specified here but is available from the above-mentioned web sites.</source>
          <target state="translated">여기에서 &lt;code&gt;DictFile&lt;/code&gt; , &lt;code&gt;AffFile&lt;/code&gt; 및 &lt;code&gt;StopWords&lt;/code&gt; 는 사전, 접두사 및 중지 단어 파일의 기본 이름을 지정합니다. 중지 단어 파일은 &lt;code&gt;simple&lt;/code&gt; 사전 유형에 대해 위에서 설명한 것과 동일한 형식 입니다. 다른 파일의 형식은 여기에 지정되어 있지 않지만 위에서 언급 한 웹 사이트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a15f0741ab9f0607b3961ed00005a1407be190df" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;db_column:update&lt;/code&gt; will be checked for &lt;code&gt;t1.x&lt;/code&gt;, since it is being updated, &lt;code&gt;db_column:{select update}&lt;/code&gt; will be checked for &lt;code&gt;t1.y&lt;/code&gt;, since it is both updated and referenced, and &lt;code&gt;db_column:select&lt;/code&gt; will be checked for &lt;code&gt;t1.z&lt;/code&gt;, since it is only referenced. &lt;code&gt;db_table:{select update}&lt;/code&gt; will also be checked at the table level.</source>
          <target state="translated">여기, &lt;code&gt;db_column:update&lt;/code&gt; 에 대한 확인됩니다 &lt;code&gt;t1.x&lt;/code&gt; 가 업데이트되고 있기 때문에, &lt;code&gt;db_column:{select update}&lt;/code&gt; 에 대해 확인됩니다 &lt;code&gt;t1.y&lt;/code&gt; 가 모두 업데이트 및 참조하기 때문에, 그리고 &lt;code&gt;db_column:select&lt;/code&gt; 을 위해 확인됩니다 &lt;code&gt;t1.z&lt;/code&gt; 만 참조되므로 참조하십시오. &lt;code&gt;db_table:{select update}&lt;/code&gt; 도 테이블 레벨에서 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="94323f34e2769fd6d8140ecf86916e1a4ffa6df9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;english&lt;/code&gt; is the base name of a file of stop words. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt;, where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory, often &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (use &lt;code&gt;pg_config --sharedir&lt;/code&gt; to determine it if you're not sure). The file format is simply a list of words, one per line. Blank lines and trailing spaces are ignored, and upper case is folded to lower case, but no other processing is done on the file contents.</source>
          <target state="translated">여기서 &lt;code&gt;english&lt;/code&gt; 는 중지 단어 파일의 기본 이름입니다. 파일의 전체 이름이 될 것입니다 &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt; 여기서 &lt;code&gt;$SHAREDIR&lt;/code&gt; PostgreSQL의 설치의 공유 데이터 디렉토리, 종종 의미 &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (사용 &lt;code&gt;pg_config --sharedir&lt;/code&gt; 을 당신이하지 않으면 그것을 결정 확실한). 파일 형식은 단순히 한 줄에 하나씩 단어 목록입니다. 빈 줄과 후행 공백은 무시되고 대문자는 소문자로 접혀 지지만 파일 내용에 대해서는 다른 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c3b85c63ac80bdd86554daac13d878a06c56b22" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;expression&lt;/code&gt; represents any value expression that does not itself contain window function calls.</source>
          <target state="translated">여기서 &lt;code&gt;expression&lt;/code&gt; 은 자체적으로 창 함수 호출을 포함하지 않는 값 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b22882051bae4c80aed43f53d018119709936657" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;key&lt;/code&gt; is an element in the index and &lt;code&gt;query&lt;/code&gt; the value being looked up in the index. The &lt;code&gt;StrategyNumber&lt;/code&gt; parameter indicates which operator of your operator class is being applied &amp;mdash; it matches one of the operator numbers in the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command.</source>
          <target state="translated">여기서 &lt;code&gt;key&lt;/code&gt; 는 인덱스의 요소이며 인덱스에서 &lt;code&gt;query&lt;/code&gt; 되는 값을 쿼리 합니다. &lt;code&gt;StrategyNumber&lt;/code&gt; 의 매개 변수는 적용되는 운영자 클래스의 어떤 연산자를 나타냅니다 - 그것은에서 운영자 번호 중 하나와 일치 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="f689631caa32c4a22198886b0f15d59af75c4c1d" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded as being space symbols.</source>
          <target state="translated">여기에서 모든 입력 구두점은 공백 기호로 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2bea9418baff2dab8ad2f535eead313521a74b5" translate="yes" xml:space="preserve">
          <source>Here, condition has a format similar to the format of regular expressions. It can use groupings &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt;. For example, &lt;code&gt;[AEIOU]Y&lt;/code&gt; means that the last letter of the word is &lt;code&gt;&quot;y&quot;&lt;/code&gt; and the penultimate letter is &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;e&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;o&quot;&lt;/code&gt; or &lt;code&gt;&quot;u&quot;&lt;/code&gt;. &lt;code&gt;[^EY]&lt;/code&gt; means that the last letter is neither &lt;code&gt;&quot;e&quot;&lt;/code&gt; nor &lt;code&gt;&quot;y&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 조건은 정규식 형식과 유사한 형식을 갖습니다. 그룹화 &lt;code&gt;[...]&lt;/code&gt; 및 &lt;code&gt;[^...]&lt;/code&gt; 사용할 수 있습니다 . 예를 들어 &lt;code&gt;[AEIOU]Y&lt;/code&gt; 는 단어의 마지막 문자가 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 이고 두 번째 문자는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; , &lt;code&gt;&quot;e&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;o&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 입니다. &lt;code&gt;[^EY]&lt;/code&gt; 는 마지막 문자가 &lt;code&gt;&quot;e&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 가 아님을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="00e7b43ee7c6b641274238949f463079d5bbf579" translate="yes" xml:space="preserve">
          <source>Here, materialization of the &lt;code&gt;WITH&lt;/code&gt; query ensures that &lt;code&gt;very_expensive_function&lt;/code&gt; is evaluated only once per table row, not twice.</source>
          <target state="translated">여기서 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 &lt;code&gt;very_expensive_function&lt;/code&gt; 하면 very_expensive_function 이 두 번이 아니라 테이블 행당 한 번만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eadb56d6708463f3d868c5af1a2244c7c4a3fed2" translate="yes" xml:space="preserve">
          <source>Here, since type &lt;code&gt;real&lt;/code&gt; cannot be implicitly cast to &lt;code&gt;integer&lt;/code&gt;, but &lt;code&gt;integer&lt;/code&gt; can be implicitly cast to &lt;code&gt;real&lt;/code&gt;, the union result type is resolved as &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;real&lt;/code&gt; 유형 은 암시 적으로 &lt;code&gt;integer&lt;/code&gt; 로 캐스트 할 수 없지만 &lt;code&gt;integer&lt;/code&gt; 는 암시 적으로 &lt;code&gt;real&lt;/code&gt; 로 캐스트 될 수 있으므로 공용체 결과 유형은 &lt;code&gt;real&lt;/code&gt; 로 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="cfec33c2243bfacb00b180b26c912c2de7a8aad2" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;uppercase&lt;/code&gt; parameter is omitted, so it receives its default value of &lt;code&gt;false&lt;/code&gt;, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults.</source>
          <target state="translated">여기서 &lt;code&gt;uppercase&lt;/code&gt; 매개 변수는 생략되므로 기본값 인 &lt;code&gt;false&lt;/code&gt; 를 수신하여 소문자 출력이 발생합니다. 위치 표기법에서는 기본값이있는 한 인수를 오른쪽에서 왼쪽으로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c823dd873535ad7ccdb6e068431505db91bdcea6" translate="yes" xml:space="preserve">
          <source>Here, the planner has chosen to use a hash join, in which rows of one table are entered into an in-memory hash table, after which the other table is scanned and the hash table is probed for matches to each row. Again note how the indentation reflects the plan structure: the bitmap scan on &lt;code&gt;tenk1&lt;/code&gt; is the input to the Hash node, which constructs the hash table. That's then returned to the Hash Join node, which reads rows from its outer child plan and searches the hash table for each one.</source>
          <target state="translated">여기서 플래너는 한 테이블의 행이 메모리 내 해시 테이블에 입력 된 후 다른 테이블이 스캔되고 해시 테이블이 각 행과 일치하는지 조사되는 해시 조인을 사용하도록 선택했습니다. 들여 쓰기에 계획 구조가 어떻게 반영되는지 다시 한 번 주목하십시오. &lt;code&gt;tenk1&lt;/code&gt; 의 비트 맵 스캔 은 해시 노드에 대한 입력으로 해시 테이블을 구성합니다. 그런 다음 해시 조인 노드로 돌아갑니다.이 노드는 외부 자식 계획에서 행을 읽고 각 해시 테이블을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5850a821f06c0b2f442ebe11558a575852c8aeb5" translate="yes" xml:space="preserve">
          <source>Here, the sequence &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; represents a dollar-quoted literal string &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt;, which will be recognized when the function body is executed by PostgreSQL. But since the sequence does not match the outer dollar quoting delimiter &lt;code&gt;$function$&lt;/code&gt;, it is just some more characters within the constant so far as the outer string is concerned.</source>
          <target state="translated">여기서 &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; 시퀀스 는 달러 인용 리터럴 문자열 &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt; 을 나타내며 함수 본문에서 인식됩니다. PostgreSQL에 의해 실행됩니다. 그러나 시퀀스가 ​​외부 달러 인용 구분 기호 &lt;code&gt;$function$&lt;/code&gt; 와 일치하지 않기 때문에 외부 문자열에 관한 한 상수 내에 더 많은 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e42cf0e074b0fa8e95e14f4ebb3e1b606554ddda" translate="yes" xml:space="preserve">
          <source>Here, the unknown-type literal &lt;code&gt;'b'&lt;/code&gt; will be resolved to type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">여기서 알 수없는 문자 리터럴 &lt;code&gt;'b'&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 를 입력하도록 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="6789cbae03419b1c1cfba25dda2b2a3e23e7e4c6" translate="yes" xml:space="preserve">
          <source>Hex Representation</source>
          <target state="translated">16 진 표현</target>
        </trans-unit>
        <trans-unit id="120e75d0d27169271eff5b30f1995d939cf69223" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;. Octal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">진수 숫자들은 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; , - &lt;code&gt;f&lt;/code&gt; 및 - &lt;code&gt;F&lt;/code&gt; . 진수 숫자는 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">고 가용성</target>
        </trans-unit>
        <trans-unit id="946223b4ede05fe838dc846e6faf0a89f88f0e1d" translate="yes" xml:space="preserve">
          <source>High Value</source>
          <target state="translated">높은 가치</target>
        </trans-unit>
        <trans-unit id="c23ab61c10027c96a9184ffc34b5fb7aecf016a1" translate="yes" xml:space="preserve">
          <source>Historically this module depended on the OSSP UUID library, which accounts for the module's name. While the OSSP UUID library can still be found at &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt;, it is not well maintained, and is becoming increasingly difficult to port to newer platforms. &lt;code&gt;uuid-ossp&lt;/code&gt; can now be built without the OSSP library on some platforms. On FreeBSD, NetBSD, and some other BSD-derived platforms, suitable UUID creation functions are included in the core &lt;code&gt;libc&lt;/code&gt; library. On Linux, macOS, and some other platforms, suitable functions are provided in the &lt;code&gt;libuuid&lt;/code&gt; library, which originally came from the &lt;code&gt;e2fsprogs&lt;/code&gt; project (though on modern Linux it is considered part of &lt;code&gt;util-linux-ng&lt;/code&gt;). When invoking &lt;code&gt;configure&lt;/code&gt;, specify &lt;code&gt;--with-uuid=bsd&lt;/code&gt; to use the BSD functions, or &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; to use &lt;code&gt;e2fsprogs&lt;/code&gt;' &lt;code&gt;libuuid&lt;/code&gt;, or &lt;code&gt;--with-uuid=ossp&lt;/code&gt; to use the OSSP UUID library. More than one of these libraries might be available on a particular machine, so &lt;code&gt;configure&lt;/code&gt; does not automatically choose one.</source>
          <target state="translated">역사적으로이 모듈은 모듈 이름을 설명하는 OSSP UUID 라이브러리에 의존했습니다. OSSP UUID 라이브러리는 여전히 &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt; 에서 찾을 수 있지만 잘 관리되지 않아 새로운 플랫폼으로 포팅하기가 점점 어려워지고 있습니다. 일부 플랫폼에서 OSSP 라이브러리없이 &lt;code&gt;uuid-ossp&lt;/code&gt; 를 빌드 할 수 있습니다. FreeBSD, NetBSD 및 기타 BSD 파생 플랫폼에서 적합한 UUID 작성 기능이 코어 &lt;code&gt;libc&lt;/code&gt; 라이브러리에 포함되어 있습니다. Linux, macOS 및 기타 플랫폼의 경우 &lt;code&gt;libuuid&lt;/code&gt; 라이브러리 에 적합한 기능이 제공됩니다. libuuid 라이브러리는 원래 &lt;code&gt;e2fsprogs&lt;/code&gt; 프로젝트 에서 제공되었습니다 (현대 Linux에서는 &lt;code&gt;util-linux-ng&lt;/code&gt; 의 일부로 간주 됨)). &lt;code&gt;configure&lt;/code&gt; 를 호출 할 때 &lt;code&gt;--with-uuid=bsd&lt;/code&gt; 를 지정 하여 BSD 함수를 사용하거나 &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; 를 지정하여 &lt;code&gt;e2fsprogs&lt;/code&gt; ' &lt;code&gt;libuuid&lt;/code&gt; 를 사용 하거나 &lt;code&gt;--with-uuid=ossp&lt;/code&gt; 를 지정하여 OSSP UUID 라이브러리를 사용하십시오. 특정 머신에서 이러한 라이브러리 중 둘 이상을 사용할 수 있으므로 &lt;code&gt;configure&lt;/code&gt; 가 자동으로 하나를 선택하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5584bf16896f3c913b27677d773698adc908eae" translate="yes" xml:space="preserve">
          <source>History of Units</source>
          <target state="translated">단위의 역사</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="7e3d4d69eb95f3292122a5fea9416ed4cba36be3" translate="yes" xml:space="preserve">
          <source>Host name of the connected client, as reported by a reverse DNS lookup of &lt;code&gt;client_addr&lt;/code&gt;. This field will only be non-null for IP connections, and only when &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;client_addr&lt;/code&gt; 의 역방향 DNS 조회에 의해보고 된 연결된 클라이언트의 호스트 이름입니다 . 이 필드는 IP 연결의 경우 null이 &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;아니며 log_hostname&lt;/a&gt; 이 활성화 된 경우에만 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="67b082e00139eb65670882e9969e878f533f20b1" translate="yes" xml:space="preserve">
          <source>Host name or IP address, or one of &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;samehost&lt;/code&gt;, or &lt;code&gt;samenet&lt;/code&gt;, or null for local connections</source>
          <target state="translated">호스트 이름 또는 IP 주소 또는 &lt;code&gt;all&lt;/code&gt; , &lt;code&gt;samehost&lt;/code&gt; 또는 &lt;code&gt;samenet&lt;/code&gt; 중 하나 또는 로컬 연결의 경우 null</target>
        </trans-unit>
        <trans-unit id="3acb05d9b4db45ddd95be7a72351a5560907bba2" translate="yes" xml:space="preserve">
          <source>Host of the PostgreSQL instance this WAL receiver is connected to. This can be a host name, an IP address, or a directory path if the connection is via Unix socket. (The path case can be distinguished because it will always be an absolute path, beginning with &lt;code&gt;/&lt;/code&gt;.)</source>
          <target state="translated">이 WAL 수신자가 연결된 PostgreSQL 인스턴스의 호스트입니다. Unix 소켓을 통한 연결 인 경우 호스트 이름, IP 주소 또는 디렉토리 경로 일 수 있습니다. (경로 대 / 소문자는 항상 &lt;code&gt;/&lt;/code&gt; 로 시작하는 절대 경로이므로 구분할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="e716495d010a3dcebf55c7c74d98bdb385a76508" translate="yes" xml:space="preserve">
          <source>Host-Based Authentication</source>
          <target state="translated">호스트 기반 인증</target>
        </trans-unit>
        <trans-unit id="cc53b246d6c96fb218922a66ec6b6ca310bf3021" translate="yes" xml:space="preserve">
          <source>Hot Standby</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="d972243453928257bff4b6354fce98c1493ba542" translate="yes" xml:space="preserve">
          <source>Hot Standby feedback propagates upstream, whatever the cascaded arrangement.</source>
          <target state="translated">계단식 배열에 관계없이 핫 스탠바이 피드백은 업스트림으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="5091beeb3be00f483925a2bb31c058bfcaaaeb31" translate="yes" xml:space="preserve">
          <source>Hot Standby is the term used to describe the ability to connect to the server and run read-only queries while the server is in archive recovery or standby mode. This is useful both for replication purposes and for restoring a backup to a desired state with great precision. The term Hot Standby also refers to the ability of the server to move from recovery through to normal operation while users continue running queries and/or keep their connections open.</source>
          <target state="translated">핫 스탠바이는 서버가 아카이브 복구 또는 대기 모드에있는 동안 서버에 연결하고 읽기 전용 쿼리를 실행하는 기능을 설명하는 데 사용되는 용어입니다. 이는 복제 목적과 백업을 원하는 상태로 매우 정확하게 복원하는 데 유용합니다. 핫 스탠바이라는 용어는 사용자가 쿼리를 계속 실행하거나 연결을 열린 상태로 유지하면서 서버가 복구에서 정상 작동으로 이동하는 기능을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="b8d371fd69de846ce0d56ec576287b8268a9b53e" translate="yes" xml:space="preserve">
          <source>How Connections Are Established</source>
          <target state="translated">연결 방법</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="a41409a5166c5d74bdffdf63899f116578d1e299" translate="yes" xml:space="preserve">
          <source>How Parallel Query Works</source>
          <target state="translated">병렬 쿼리 작동 방식</target>
        </trans-unit>
        <trans-unit id="7604442ec6b924ac1f168d8f81e9b0b61679f4f6" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 (the default) means no limit.</source>
          <target state="translated">이 데이터베이스에 동시에 연결할 수있는 횟수 -1 (기본값)은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d98f671ec6200c3b445e94f09f19857316dd290b" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 means no limit.</source>
          <target state="translated">이 데이터베이스에 동시에 연결할 수있는 횟수 -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e914be45633e81e1b35dd5a5a8544fdfa64c8d17" translate="yes" xml:space="preserve">
          <source>How much to compress. Higher levels compress smaller but are slower. 0 disables compression.</source>
          <target state="translated">압축 정도 높은 수준의 압축은 작지만 느립니다. 0은 압축을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ef6f180b70cdcd17c60a982706ebbdc6fbb46234" translate="yes" xml:space="preserve">
          <source>How the planner determines the cardinality of &lt;code&gt;tenk1&lt;/code&gt; is covered in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, but is repeated here for completeness. The number of pages and rows is looked up in &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">플래너가 &lt;code&gt;tenk1&lt;/code&gt; 의 카디널리티를 판별하는 방법은 &lt;a href=&quot;planner-stats&quot;&gt;섹션 14.2&lt;/a&gt; 에서 다루지 만 여기서는 완전성을 위해 반복됩니다. 페이지와 행 수는 &lt;code&gt;pg_class&lt;/code&gt; 에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="94ecf8c7f95f01155b7f0495cbc646415e78c1ae" translate="yes" xml:space="preserve">
          <source>How to choose a good password.</source>
          <target state="translated">올바른 비밀번호를 선택하는 방법</target>
        </trans-unit>
        <trans-unit id="2ba82223beeb024535e1c4a0ddfd885368b08372" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;jsonb&lt;/code&gt; will preserve trailing fractional zeroes, as seen in this example, even though those are semantically insignificant for purposes such as equality checks.</source>
          <target state="translated">그러나 &lt;code&gt;jsonb&lt;/code&gt; 는이 예에서 볼 수 있듯이 후행 소수 0을 유지하지만 등호 검사와 같은 목적 상 의미가 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483f78f78539b97c5a6d0e5895b7ea66709bc65e" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;TABLE&lt;/code&gt; function is different from the preceding examples, because it actually returns a &lt;em&gt;set&lt;/em&gt; of records, not just one record.</source>
          <target state="translated">그러나 &lt;code&gt;TABLE&lt;/code&gt; 함수는 실제로 하나의 레코드가 아니라 레코드 &lt;em&gt;세트&lt;/em&gt; 를 리턴하므로 이전 예제와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5593eb449291b54fa57b6d536402c4a2c8454af7" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;WITH&lt;/code&gt; query can be marked &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to remove this guarantee. In that case, the &lt;code&gt;WITH&lt;/code&gt; query can be folded into the primary query much as though it were a simple sub-&lt;code&gt;SELECT&lt;/code&gt; in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This results in duplicate computations if the primary query refers to that &lt;code&gt;WITH&lt;/code&gt; query more than once; but if each such use requires only a few rows of the &lt;code&gt;WITH&lt;/code&gt; query's total output, &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; can provide a net savings by allowing the queries to be optimized jointly. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; is ignored if it is attached to a &lt;code&gt;WITH&lt;/code&gt; query that is recursive or is not side-effect-free (i.e., is not a plain &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions).</source>
          <target state="translated">그러나 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 로 표시 하여이 보증을 제거 할 수 있습니다 . 이 경우 기본 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에서 단순한 하위 &lt;code&gt;SELECT&lt;/code&gt; 인 것처럼 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 기본 쿼리로 접을 수 있습니다 . 기본 조회가 &lt;code&gt;WITH&lt;/code&gt; 조회를 두 번 이상 참조하면 중복 계산이 수행됩니다 . 그러나 그러한 각 사용에 &lt;code&gt;WITH&lt;/code&gt; 쿼리의 총 출력 중 몇 행만 필요한 경우 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 는 쿼리를 공동으로 최적화하여 순 절감 효과를 제공 할 수 있습니다. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 가 &lt;code&gt;WITH&lt;/code&gt; 에 첨부되면 무시됩니다.재귀 적이거나 부작용이없는 쿼리 (즉, 휘발성 함수가없는 일반 &lt;code&gt;SELECT&lt;/code&gt; 가 아님)</target>
        </trans-unit>
        <trans-unit id="b767ca4c454cedd41bdf2ff2cdb11395909dd8d9" translate="yes" xml:space="preserve">
          <source>However, buffering index build needs to call the &lt;code&gt;penalty&lt;/code&gt; function more often, which consumes some extra CPU resources. Also, the buffers used in the buffering build need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation.</source>
          <target state="translated">그러나 버퍼링 인덱스 빌드는 &lt;code&gt;penalty&lt;/code&gt; 함수를 더 자주 호출해야하므로 일부 추가 CPU 리소스가 사용됩니다. 또한 버퍼링 빌드에 사용 된 버퍼에는 결과 인덱스 크기까지 임시 디스크 공간이 필요합니다. 버퍼링은 또한 양의 방향과 음의 방향 모두에서 결과 인덱스의 품질에 영향을 줄 수 있습니다. 이러한 영향은 입력 데이터 배포 및 연산자 클래스 구현과 같은 다양한 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9ace55465d56f996227de2d5f96f6d4ae754cfc4" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 100 is not a leap year.</source>
          <target state="translated">그러나 매년 100으로 나눌 수있는 것은 윤년이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="792feefacc6fed97444972da0544bbf7d0187b3d" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 400 is a leap year after all.</source>
          <target state="translated">그러나 매년 400으로 나눌 수있는 해는 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="7f65ac3c6b4eb7f83cd55133554a3e43236a59b1" translate="yes" xml:space="preserve">
          <source>However, filtered forms in Microsoft Access generate queries that appear to use &lt;code&gt;expr = NULL&lt;/code&gt; to test for null values, so if you use that interface to access the database you might want to turn this option on. Since expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; always return the null value (using the SQL standard interpretation), they are not very useful and do not appear often in normal applications so this option does little harm in practice. But new users are frequently confused about the semantics of expressions involving null values, so this option is off by default.</source>
          <target state="translated">그러나 Microsoft Access에서 필터링 된 양식은 &lt;code&gt;expr = NULL&lt;/code&gt; 을 사용하여 null 값을 테스트 하는 것처럼 보이는 쿼리를 생성 하므로 해당 인터페이스를 사용하여 데이터베이스에 액세스하는 경우이 옵션을 설정해야합니다. &lt;code&gt;expr = NULL&lt;/code&gt; 형식의 표현식은 항상 널값을 리턴하므로 (SQL 표준 해석 사용), 유용하지 않으며 일반 응용 프로그램에서는 자주 나타나지 않으므로이 옵션은 실제로 거의 해를 끼치 지 않습니다. 그러나 새로운 사용자는 종종 null 값과 관련된 표현식의 의미에 대해 혼동되므로이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27fc16525c2f3eccc5221bef3e492bce51567b8a" translate="yes" xml:space="preserve">
          <source>However, if a &lt;code&gt;WITH&lt;/code&gt; query is non-recursive and side-effect-free (that is, it is a &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the &lt;code&gt;WITH&lt;/code&gt; query just once, but not if it references the &lt;code&gt;WITH&lt;/code&gt; query more than once. You can override that decision by specifying &lt;code&gt;MATERIALIZED&lt;/code&gt; to force separate calculation of the &lt;code&gt;WITH&lt;/code&gt; query, or by specifying &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to force it to be merged into the parent query. The latter choice risks duplicate computation of the &lt;code&gt;WITH&lt;/code&gt; query, but it can still give a net savings if each usage of the &lt;code&gt;WITH&lt;/code&gt; query needs only a small part of the &lt;code&gt;WITH&lt;/code&gt; query's full output.</source>
          <target state="translated">그러나 &lt;code&gt;WITH&lt;/code&gt; 쿼리가 재귀 적이 지 않고 부작용이없는 경우 (즉, 휘발성 함수를 포함하지 않는 &lt;code&gt;SELECT&lt;/code&gt; ) 부모 쿼리로 접을 수 있으므로 두 쿼리 수준의 공동 최적화가 가능합니다. 기본적으로 이는 상위 쿼리가 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 한 번만 참조하지만 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 두 번 이상 참조하는 경우에는 발생하지 않습니다 . &lt;code&gt;WITH&lt;/code&gt; 쿼리를 별도로 계산하도록 &lt;code&gt;MATERIALIZED&lt;/code&gt; 를 지정 하거나 부모 쿼리에 강제로 병합되도록 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 를 지정하여 해당 결정을 무시할 수 있습니다 . 후자의 선택은 &lt;code&gt;WITH&lt;/code&gt; 의 중복 계산 위험이 있습니다. &lt;code&gt;WITH&lt;/code&gt; 쿼리를 사용할 때마다 &lt;code&gt;WITH&lt;/code&gt; 쿼리 전체 출력의 작은 부분 만 필요한 경우 여전히 순 절감 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057cccafbf2013b3d5aa591e41a10dbea6d97107" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g. &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="translated">그러나 기본값이 &lt;code&gt;clock_timestamp()&lt;/code&gt; (예 : clock_timestamp () ) 각 행은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 이 실행될 때 계산 된 값으로 업데이트되어야합니다 . 잠재적으로 긴 업데이트 작업을 피하려면, 특히 어쨌든 주로 기본값이 아닌 값으로 열을 채우려는 경우 기본값이없는 열을 추가하고 &lt;code&gt;UPDATE&lt;/code&gt; 를 사용하여 올바른 값을 삽입 한 다음 아래 설명 된대로 원하는 기본값을 추가하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="fbbfd51a31cdab8f282fc85ab92999c7b1df44cb" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to remove role memberships involving the role; &lt;code&gt;DROP ROLE&lt;/code&gt; automatically revokes any memberships of the target role in other roles, and of other roles in the target role. The other roles are not dropped nor otherwise affected.</source>
          <target state="translated">그러나 역할과 관련된 역할 구성원 자격을 제거 할 필요는 없습니다. &lt;code&gt;DROP ROLE&lt;/code&gt; 은 다른 역할의 대상 역할 멤버와 대상 역할의 다른 역할 멤버십을 자동으로 취소합니다. 다른 역할은 삭제되거나 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f99a4fe30aa35a7291430986cdc65efbff8dd39f" translate="yes" xml:space="preserve">
          <source>However, the above does not account for amortization of index reads across repeated index scans.</source>
          <target state="translated">그러나 위의 내용은 반복 된 인덱스 스캔에서 인덱스 읽기의 상각을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c28ea9e20c2e7864029d4301f424d9903192d30" translate="yes" xml:space="preserve">
          <source>However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for arrays of unspecified length.</source>
          <target state="translated">그러나 현재 구현은 제공된 배열 크기 제한을 무시합니다. 즉, 동작은 지정되지 않은 길이의 배열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e7668db05f29105ac82edf505ab55c50a37483ff" translate="yes" xml:space="preserve">
          <source>However, the first and second calls will prefer more-specific functions, if available:</source>
          <target state="translated">그러나 첫 번째 및 두 번째 호출은 사용 가능한 경우보다 구체적인 기능을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="8dd49b73a6bd91b9638ef49c19702f4c5cff091d" translate="yes" xml:space="preserve">
          <source>However, the index can also be used in queries that do not involve &lt;code&gt;order_nr&lt;/code&gt; at all, e.g.:</source>
          <target state="translated">그러나 index는 &lt;code&gt;order_nr&lt;/code&gt; 을 전혀 포함하지 않는 쿼리에도 사용될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2b5348adbefd43e71711c0de0facb597d742b53" translate="yes" xml:space="preserve">
          <source>However, the index could not be used for queries like the following, because though the operator &lt;code&gt;?&lt;/code&gt; is indexable, it is not applied directly to the indexed column &lt;code&gt;jdoc&lt;/code&gt;:</source>
          <target state="translated">그러나 연산자 &lt;code&gt;?&lt;/code&gt; 를 통해 다음과 같은 쿼리에는 인덱스를 사용할 수 없습니다 . 인덱싱 가능하며 인덱싱 된 열 &lt;code&gt;jdoc&lt;/code&gt; 에 직접 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="30d62ecc57d7df5a78dd582f05557b7fb23c077b" translate="yes" xml:space="preserve">
          <source>However, the second query may give unexpected results if &lt;code&gt;salesmen&lt;/code&gt;.&lt;code&gt;id&lt;/code&gt; is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple &lt;code&gt;id&lt;/code&gt; matches. Also, if there is no match for a particular &lt;code&gt;accounts&lt;/code&gt;.&lt;code&gt;sales_id&lt;/code&gt; entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.</source>
          <target state="translated">그러나 &lt;code&gt;salesmen&lt;/code&gt; 인 경우 두 번째 쿼리에서 예기치 않은 결과가 발생할 수 있습니다 . &lt;code&gt;id&lt;/code&gt; 는 고유 키가 아니지만 여러 &lt;code&gt;id&lt;/code&gt; 일치 가 있으면 첫 번째 쿼리에서 오류가 발생합니다 . 또한 특정 &lt;code&gt;accounts&lt;/code&gt; 과 일치하지 않는 경우 . &lt;code&gt;sales_id&lt;/code&gt; 항목에서 첫 번째 쿼리는 해당 이름 필드를 NULL로 설정하지만 두 번째 쿼리는 해당 행을 전혀 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac0aa3ca3aadbd76b33daf42fe2d9f38b7a21341" translate="yes" xml:space="preserve">
          <source>However, this is not recommended. Floating point numbers should not be used to handle money due to the potential for rounding errors.</source>
          <target state="translated">그러나 이것은 권장되지 않습니다. 반올림 오류 가능성으로 인해 돈을 처리하는 데 부동 소수점 숫자를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a5e278e5a670634fe4d0890f09f0f07f287151" translate="yes" xml:space="preserve">
          <source>However, this only works for types whose names are also valid as function names. For example, &lt;code&gt;double precision&lt;/code&gt; cannot be used this way, but the equivalent &lt;code&gt;float8&lt;/code&gt; can. Also, the names &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;timestamp&lt;/code&gt; can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided.</source>
          <target state="translated">그러나 이것은 이름이 함수 이름으로도 유효한 유형에 대해서만 작동합니다. 예를 들어, &lt;code&gt;double precision&lt;/code&gt; 는 이런 식으로 사용할 수 없지만 &lt;code&gt;float8&lt;/code&gt; 은 사용할 수 있습니다. 또한 이름 &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; 및 시간 &lt;code&gt;timestamp&lt;/code&gt; 은 구문 충돌로 인해 큰 따옴표로 묶인 경우에만이 방식으로 사용할 수 있습니다. 따라서 함수형 캐스트 ​​구문을 사용하면 불일치가 발생하므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab41e0a4da3a7de05a4b7068787924b0e3cb154d" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="translated">그러나 이는 대형 배열의 경우 지루해지며 배열의 크기를 알 수없는 경우에는 도움이되지 않습니다. 다른 방법은 &lt;a href=&quot;functions-comparisons&quot;&gt;섹션 9.23에&lt;/a&gt; 설명되어 있습니다. 위의 쿼리는 다음으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49121f1f7d3b19887ff759c895c872e45fe0450d" translate="yes" xml:space="preserve">
          <source>However, unless a module is specifically designed to be used in this way by non-superusers, this is usually not the right setting to use. Look at &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; instead.</source>
          <target state="translated">그러나 수퍼 유저가 아닌 사람이 이러한 방식으로 사용하도록 모듈을 특별히 설계하지 않으면 일반적으로 올바른 설정이 아닙니다. 봐 &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="f4744bf3a8101c9dd55ef2a04f348b62af8e9994" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="translated">그러나 디렉토리 내용은 안전하지만 기본 클라이언트 인증 설정을 통해 모든 로컬 사용자가 데이터베이스에 연결하고 데이터베이스 수퍼 유저가 될 수도 있습니다. 다른 로컬 사용자를 신뢰하지 않으면 &lt;code&gt;initdb&lt;/code&gt; 의 &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;--pwprompt&lt;/code&gt; 또는 &lt;code&gt;--pwfile&lt;/code&gt; 옵션 중 하나를 사용 하여 데이터베이스 수퍼 유저에게 암호를 할당하는 것이 좋습니다 . 또한 기본 &lt;code&gt;trust&lt;/code&gt; 인증 모드가 사용되지 않도록 &lt;code&gt;-A md5&lt;/code&gt; 또는 &lt;code&gt;-A password&lt;/code&gt; 지정하십시오 . 또는 &lt;code&gt;initdb&lt;/code&gt; 를 실행 한 후 , 그러나 &lt;em&gt;전에&lt;/em&gt; 생성 된 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일을 수정하십시오.&lt;em&gt;&lt;/em&gt;서버를 처음 시작합니다. 다른 합리적인 접근 방법으로는 &lt;code&gt;peer&lt;/code&gt; 인증 또는 파일 시스템 권한을 사용하여 연결을 제한하는 방법이 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57ff938f130455fd7c5423b61feb93bb1fcef3bc" translate="yes" xml:space="preserve">
          <source>Huge pages are known as large pages on Windows. To use them, you need to assign the user right Lock Pages in Memory to the Windows user account that runs PostgreSQL. You can use Windows Group Policy tool (gpedit.msc) to assign the user right Lock Pages in Memory. To start the database server on the command prompt as a standalone process, not as a Windows service, the command prompt must be run as an administrator or User Access Control (UAC) must be disabled. When the UAC is enabled, the normal command prompt revokes the user right Lock Pages in Memory when started.</source>
          <target state="translated">큰 페이지는 Windows에서 큰 페이지라고합니다. 이를 사용하려면 PostgreSQL을 실행하는 Windows 사용자 계정에 사용자 권한 메모리의 잠금 페이지를 할당해야합니다. Windows 그룹 정책 도구 (gpedit.msc)를 사용하여 메모리에 사용자 권한 잠금 페이지를 할당 할 수 있습니다. 명령 프롬프트에서 데이터베이스 서비스를 Windows 서비스가 아닌 독립형 프로세스로 시작하려면 명령 프롬프트를 관리자로 실행하거나 UAC (User Access Control)를 사용하지 않아야합니다. UAC가 활성화되면 일반 명령 프롬프트가 시작될 때 사용자 권한 메모리에서 페이지 잠금을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d8bf3846fb1be35204cb20d765d7076251578e99" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all ASCII</source>
          <target state="translated">하이픈으로 연결된 단어 부분, 모든 ASCII</target>
        </trans-unit>
        <trans-unit id="8cdd097739f98ad844abd99f2945f21997a9eb1e" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all letters</source>
          <target state="translated">하이픈으로 묶인 단어 부분, 모든 문자</target>
        </trans-unit>
        <trans-unit id="e93c4156f46693ca03a7e7a80ab8d3ba346ec445" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, letters and digits</source>
          <target state="translated">하이픈으로 연결된 단어 부분, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="5b3864b1f64d7c5d3d32b1aa431d4fc8168f5866" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all ASCII</source>
          <target state="translated">하이픈이있는 단어, 모든 ASCII</target>
        </trans-unit>
        <trans-unit id="913f77eb20ad8621544651272e4864006cc9a993" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all letters</source>
          <target state="translated">하이픈이있는 단어, 모든 문자</target>
        </trans-unit>
        <trans-unit id="f8a2b7bdb3666b53d93dd9a984de988e23d346eb" translate="yes" xml:space="preserve">
          <source>Hyphenated word, letters and digits</source>
          <target state="translated">하이픈으로 연결된 단어, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="b4d527f11debd0a7c15ff494a4d7c586833b355b" translate="yes" xml:space="preserve">
          <source>I believe this union:</source>
          <target state="translated">나는이 연합을 믿는다 :</target>
        </trans-unit>
        <trans-unit id="778d85fd9d1cf9d0bbf34776934bafa267e37666" translate="yes" xml:space="preserve">
          <source>ICU &amp;ldquo;root&amp;rdquo; collation. Use this to get a reasonable language-agnostic sort order.</source>
          <target state="translated">ICU &quot;루트&quot;데이터 정렬. 언어에 관계없이 합리적인 정렬 순서를 얻으려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4186bb5b6042e95ce616f6bfea478c30a4a80a0a" translate="yes" xml:space="preserve">
          <source>ICU allows collations to be customized beyond the basic language+country set that is preloaded by &lt;code&gt;initdb&lt;/code&gt;. Users are encouraged to define their own collation objects that make use of these facilities to suit the sorting behavior to their requirements. See &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; and &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; for information on ICU locale naming. The set of acceptable names and attributes depends on the particular ICU version.</source>
          <target state="translated">ICU를 사용하면 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사전로드 된 기본 언어 + 국가 세트를 넘어 데이터 정렬을 사용자 정의 할 수 있습니다 . 사용자는 이러한 기능을 사용하여 요구 사항에 맞는 정렬 동작에 적합한 자체 데이터 정렬 개체를 정의하는 것이 좋습니다. ICU 로캘 이름 지정에 대한 자세한 내용은 &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; 및 &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; 를 참조하십시오 . 허용되는 이름과 속성 세트는 특정 ICU 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6f538ad1e5ea2537ef4ecc8ee6d246518b569e28" translate="yes" xml:space="preserve">
          <source>ICU?</source>
          <target state="translated">ICU?</target>
        </trans-unit>
        <trans-unit id="85ddc12eb726993ba7496e593b7b33905cb52428" translate="yes" xml:space="preserve">
          <source>ID of a role that has a member</source>
          <target state="translated">회원이있는 역할의 ID</target>
        </trans-unit>
        <trans-unit id="5e2534334ba3879c3b535d5349da57994812e977" translate="yes" xml:space="preserve">
          <source>ID of a role that is a member of &lt;code&gt;roleid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;roleid&lt;/code&gt; 의 구성원 인 역할의 ID</target>
        </trans-unit>
        <trans-unit id="b3334a0f3355b9fb358c2a763909308ff227db92" translate="yes" xml:space="preserve">
          <source>ID of role</source>
          <target state="translated">역할의 ID</target>
        </trans-unit>
        <trans-unit id="00ab5d608ce03301bac5fabc168033a98fb8425a" translate="yes" xml:space="preserve">
          <source>ID of the role that granted this membership</source>
          <target state="translated">이 멤버십을 부여한 역할의 ID</target>
        </trans-unit>
        <trans-unit id="4acecf86a885801175aac9f839c4e27dfcd0bb71" translate="yes" xml:space="preserve">
          <source>ID of the transaction targeted by the lock, or null if the target is not a transaction ID</source>
          <target state="translated">잠금이 대상으로하는 트랜잭션의 ID 또는 대상이 트랜잭션 ID가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="4405588c83fcde9e77a297389a5a77edfc33fd81" translate="yes" xml:space="preserve">
          <source>ID of this group</source>
          <target state="translated">이 그룹의 ID</target>
        </trans-unit>
        <trans-unit id="364041630f947c82ae36797d2d8b4d8c51f1090b" translate="yes" xml:space="preserve">
          <source>ID of this user</source>
          <target state="translated">이 사용자의 ID</target>
        </trans-unit>
        <trans-unit id="efeddb9b2b9bc9d252eb880921c3b8b3f041d65a" translate="yes" xml:space="preserve">
          <source>ID, in the range 1..&lt;code&gt;shared_buffers&lt;/code&gt;</source>
          <target state="translated">1 범위의 ID .. &lt;code&gt;shared_buffers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fab9fa5af6726f4fbc7c7dbc87a28acfc40a63e9" translate="yes" xml:space="preserve">
          <source>IEC</source>
          <target state="translated">IEC</target>
        </trans-unit>
        <trans-unit id="91e003cabbbc52544795f505584d809fe4bf1cdc" translate="yes" xml:space="preserve">
          <source>IEEE</source>
          <target state="translated">IEEE</target>
        </trans-unit>
        <trans-unit id="44285b6e9ccd859327d44fd855fe1b27a08233b1" translate="yes" xml:space="preserve">
          <source>IEEE Std 802-2001 specifies the second shown form (with hyphens) as the canonical form for MAC addresses, and specifies the first form (with colons) as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. This convention is widely ignored nowadays, and it is relevant only for obsolete network protocols (such as Token Ring). PostgreSQL makes no provisions for bit reversal, and all accepted formats use the canonical LSB order.</source>
          <target state="translated">IEEE Std 802-2001은 MAC 주소의 표준 형식으로 두 번째로 표시된 형식 (하이픈 포함)을 지정하고 첫 번째 형식 (콜론 포함)을 비트 반전 표기법으로 지정하여 08-00-2b-01-02- 03 = 01 : 00 : 4D : 08 : 04 : 0C. 이 규칙은 현재 널리 무시되고 있으며 오래된 네트워크 프로토콜 (예 : 토큰 링)에만 적용됩니다. PostgreSQL은 비트 리버설을 제공하지 않으며 모든 허용 형식은 표준 LSB 순서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6125697017457f602c07e148a748e8cb804d044" translate="yes" xml:space="preserve">
          <source>IEEE754 specifies that &lt;code&gt;NaN&lt;/code&gt; should not compare equal to any other floating-point value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">IEEE754는 &lt;code&gt;NaN&lt;/code&gt; 이 다른 부동 소수점 값 ( &lt;code&gt;NaN&lt;/code&gt; 포함 ) 과 같지 않도록 지정합니다 . 허용하기 위해 부동 소수점 값을 소트 및 트리 기반 인덱스 PostgreSQL의 치료에 사용 &lt;code&gt;NaN&lt;/code&gt; 값 동일한로서, 모든 비 - 초과 &lt;code&gt;NaN&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="0d3a231ed1c6dcab8fa35edd0bd127d0e5d21d84" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA</source>
          <target state="translated">수입 외국인 스키마</target>
        </trans-unit>
        <trans-unit id="b8d5fc1f41eb794e02ccf1b51b842239e54448da" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA &amp;mdash; import table definitions from a foreign server</source>
          <target state="translated">IMPORT FOREIGN SCHEMA &amp;mdash; 외부 서버에서 테이블 정의 가져 오기</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="b42f874d7db1e2726d84a76cc0d5b0946a10b15b" translate="yes" xml:space="preserve">
          <source>INSERT &amp;mdash; create new rows in a table</source>
          <target state="translated">삽입 &amp;mdash; 테이블에 새 행을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48ef49cd856e5cecb996e0f1d379dbd5b56b7cb9" translate="yes" xml:space="preserve">
          <source>IP address mask, or null if not applicable</source>
          <target state="translated">IP 주소 마스크 또는 해당 사항이없는 경우 null</target>
        </trans-unit>
        <trans-unit id="998514d91724c3d88d4cab07518debfcd96862e2" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this WAL sender. If this field is null, it indicates that the client is connected via a Unix socket on the server machine.</source>
          <target state="translated">이 WAL 발신자에 연결된 클라이언트의 IP 주소입니다. 이 필드가 널인 경우 클라이언트가 서버 시스템의 Unix 소켓을 통해 연결되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26ec3318a4493a39e748c88c589f3baeb8b0af15" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend</source>
          <target state="translated">이 백엔드에 연결된 클라이언트의 IP 주소</target>
        </trans-unit>
        <trans-unit id="4da843a738e5c670d4d958349979cce4c9e32eb3" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.</source>
          <target state="translated">이 백엔드에 연결된 클라이언트의 IP 주소 이 필드가 널인 경우 클라이언트가 서버 시스템의 Unix 소켓을 통해 연결되었거나 autovacuum과 같은 내부 프로세스임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="82c9856123dd418f4774d9eae5cdc6c13b4a17dd" translate="yes" xml:space="preserve">
          <source>IPC parameters can be set in the System Administration Manager (SAM) under Kernel Configuration &amp;rarr; Configurable Parameters. Choose Create A New Kernel when you're done.</source>
          <target state="translated">IPC 매개 변수는 SAM (System Administration Manager)의 Kernel Configuration &amp;rarr; Configurable Parameters에서 설정할 수 있습니다. 완료되면 새 커널 만들기를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="ab288f3447cf3cc34399c5b2b5851efa6c3d80a4" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 hosts and networks</source>
          <target state="translated">IPv4 및 IPv6 호스트 및 네트워크</target>
        </trans-unit>
        <trans-unit id="86de966d86cc975242ef8e4aaaa8450d6855f8c5" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 networks</source>
          <target state="translated">IPv4 및 IPv6 네트워크</target>
        </trans-unit>
        <trans-unit id="570cca22ddf6e073a6dbd2cc896fd406204eb7b0" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 host address</source>
          <target state="translated">IPv4 또는 IPv6 호스트 주소</target>
        </trans-unit>
        <trans-unit id="c2e4edd4992d9d0688f940e8473197cf9ffe481e" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 network address</source>
          <target state="translated">IPv4 또는 IPv6 네트워크 주소</target>
        </trans-unit>
        <trans-unit id="9d11567d01c59efb43ef67bb8206340e658f9d9d" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="bb9ab15de59e9d547e927c8c62069791df1e8268" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; ISBN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; ISBN13</target>
        </trans-unit>
        <trans-unit id="a43d901bb73f40ccaba8783a1129360f50fba85d" translate="yes" xml:space="preserve">
          <source>ISBN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4497b3ae9c75adbc043fd5847cc29356be8a5644" translate="yes" xml:space="preserve">
          <source>ISBN13, ISMN13, ISSN13 numbers are all EAN13 numbers.</source>
          <target state="translated">ISBN13, ISMN13, ISSN13 번호는 모두 EAN13 번호입니다.</target>
        </trans-unit>
        <trans-unit id="95889ddf7167ca49889a166a2e3858db51bb28d5" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="d9a94674870da708d9a2ffc2a85d2b1561319391" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; ISMN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; ISMN13</target>
        </trans-unit>
        <trans-unit id="9f6fa2a3d8d31764fc531c626fb4ec439b13e49d" translate="yes" xml:space="preserve">
          <source>ISMN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="03b66feb77a5287d927a40831615b0a53c5c265e" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;alternative format&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;대체 형식&amp;rdquo;: 위와 동일한 의미</target>
        </trans-unit>
        <trans-unit id="347f83fd1ecbce8da8703c53ec0ee71401af00f9" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;format with designators&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;지정자가있는 형식&amp;rdquo;: 위와 동일한 의미</target>
        </trans-unit>
        <trans-unit id="249eb6740bd82a6c1db53f9cab25650c97a5d209" translate="yes" xml:space="preserve">
          <source>ISO 8601 day of the week, Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">ISO 8601 요일, 월요일 ( &lt;code&gt;1&lt;/code&gt; ) ~ 일요일 ( &lt;code&gt;7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9d2092d27bf384f64eb368a2dfd612d31022bd2b" translate="yes" xml:space="preserve">
          <source>ISO 8601 specifies the use of uppercase letter &lt;code&gt;T&lt;/code&gt; to separate the date and time. PostgreSQL accepts that format on input, but on output it uses a space rather than &lt;code&gt;T&lt;/code&gt;, as shown above. This is for readability and for consistency with RFC 3339 as well as some other database systems.</source>
          <target state="translated">ISO 8601은 대문자 &lt;code&gt;T&lt;/code&gt; 를 사용 하여 날짜와 시간을 구분합니다. PostgreSQL은 입력에서 해당 형식을 허용하지만 출력에서 위에 표시된 것처럼 &lt;code&gt;T&lt;/code&gt; 대신 공백을 사용합니다 . 이것은 가독성과 RFC 3339 및 일부 다른 데이터베이스 시스템과의 일관성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e8d83297c37a8caa9129a785251aaffead6b3d8" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-numbering year (4 or more digits)</source>
          <target state="translated">ISO 8601 주간 번호 년 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="5113b76aa827aecd1b2fbeb19739776b2cdcbdb5" translate="yes" xml:space="preserve">
          <source>ISO 8601, SQL standard</source>
          <target state="translated">ISO 8601, SQL 표준</target>
        </trans-unit>
        <trans-unit id="c4bb947ff5dc5345f70f6892f02bf85a04d4eb7d" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8 in any mode (recommended format)</source>
          <target state="translated">ISO 8601; 모든 모드에서 1 월 8 일 (권장 형식)</target>
        </trans-unit>
        <trans-unit id="a83c80f67456b395aa2704158f1dc68957610271" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8, 1999 in any mode</source>
          <target state="translated">ISO 8601; 모든 모드에서 1999 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="b1922fbd22025577b8a5e43c812e096c3b9acffc" translate="yes" xml:space="preserve">
          <source>ISO 8859-1, ECMA 94</source>
          <target state="translated">ISO 8859-1, ECMA 94</target>
        </trans-unit>
        <trans-unit id="276d48941fbc0543fbb5ce642fe1dc3b05b9bb7d" translate="yes" xml:space="preserve">
          <source>ISO 8859-10, ECMA 144</source>
          <target state="translated">ISO 8859-10, ECMA 144</target>
        </trans-unit>
        <trans-unit id="b206da53a9051bf3226d71a6e114418f28766469" translate="yes" xml:space="preserve">
          <source>ISO 8859-13</source>
          <target state="translated">ISO 8859-13</target>
        </trans-unit>
        <trans-unit id="26424d0dadf461ca6901513d3dcfc085ec66b2c7" translate="yes" xml:space="preserve">
          <source>ISO 8859-14</source>
          <target state="translated">ISO 8859-14</target>
        </trans-unit>
        <trans-unit id="b292668cb49c44b020b58d7d79cd50329ab61aed" translate="yes" xml:space="preserve">
          <source>ISO 8859-15</source>
          <target state="translated">ISO 8859-15</target>
        </trans-unit>
        <trans-unit id="6a937cb9225885ed540430a532e08182311c8fb7" translate="yes" xml:space="preserve">
          <source>ISO 8859-16, ASRO SR 14111</source>
          <target state="translated">ISO 8859-16, ASRO SR 14111</target>
        </trans-unit>
        <trans-unit id="5f8eb67d9b294dc7fa2960e49427ec254bf78d3e" translate="yes" xml:space="preserve">
          <source>ISO 8859-2, ECMA 94</source>
          <target state="translated">ISO 8859-2, ECMA 94</target>
        </trans-unit>
        <trans-unit id="34bfa7b1e0970a505b7c18beda35ee12ae67b627" translate="yes" xml:space="preserve">
          <source>ISO 8859-3, ECMA 94</source>
          <target state="translated">ISO 8859-3, ECMA 94</target>
        </trans-unit>
        <trans-unit id="19f1d5efe10cfb525dac348f64f156d08531f5ba" translate="yes" xml:space="preserve">
          <source>ISO 8859-4, ECMA 94</source>
          <target state="translated">ISO 8859-4, ECMA 94</target>
        </trans-unit>
        <trans-unit id="958ae0517642b5a63a0ba42f16e7dba51f3f03b9" translate="yes" xml:space="preserve">
          <source>ISO 8859-5, ECMA 113</source>
          <target state="translated">ISO 8859-5, ECMA 113</target>
        </trans-unit>
        <trans-unit id="edc58fa1dfcc675f8f0e7cd9ba637022f963b9a5" translate="yes" xml:space="preserve">
          <source>ISO 8859-6, ECMA 114</source>
          <target state="translated">ISO 8859-6, ECMA 114</target>
        </trans-unit>
        <trans-unit id="ac642f9b939a7e25fc9c152794f7c55763fbe736" translate="yes" xml:space="preserve">
          <source>ISO 8859-7, ECMA 118</source>
          <target state="translated">ISO 8859-7, ECMA 118</target>
        </trans-unit>
        <trans-unit id="aafb9bf8d9a3dd18a9bc858aa3091007431a81fe" translate="yes" xml:space="preserve">
          <source>ISO 8859-8, ECMA 121</source>
          <target state="translated">ISO 8859-8, ECMA 121</target>
        </trans-unit>
        <trans-unit id="561419819864b8b7eafa254ff17c2c5838572d02" translate="yes" xml:space="preserve">
          <source>ISO 8859-9, ECMA 128</source>
          <target state="translated">ISO 8859-9, ECMA 128</target>
        </trans-unit>
        <trans-unit id="19fa6eb3258ffb4709ac1dfbba399d0753e7e88f" translate="yes" xml:space="preserve">
          <source>ISO-8601 offset for PST</source>
          <target state="translated">PST에 대한 ISO-8601 오프셋</target>
        </trans-unit>
        <trans-unit id="d9bfc4c480632e7b109f99ac77c51a2a5260171b" translate="yes" xml:space="preserve">
          <source>ISSN</source>
          <target state="translated">ISSN</target>
        </trans-unit>
        <trans-unit id="3941c970e85e394c43837d5b44cc1bf0483f215f" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="a203140c0f91a7564ce62d86b204a626e15ee7d8" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; ISSN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; ISSN13</target>
        </trans-unit>
        <trans-unit id="57b604002c866aad17fa814a63620ac73af4bf08" translate="yes" xml:space="preserve">
          <source>ISSN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="0a6d0a09ee6e1eec933513081c533fbe57cab3a4" translate="yes" xml:space="preserve">
          <source>Ident Authentication</source>
          <target state="translated">신원 인증</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="64ed35bcb9eba82bb5083c305000e3e8e174b736" translate="yes" xml:space="preserve">
          <source>Identifier of the large object that includes this page</source>
          <target state="translated">이 페이지를 포함하는 큰 객체의 식별자</target>
        </trans-unit>
        <trans-unit id="d19347e41a5213caf5fbef640d085e03cc5288d2" translate="yes" xml:space="preserve">
          <source>Identifies a function taking or returning an unspecified row type.</source>
          <target state="translated">지정되지 않은 행 유형을 가져 오거나 리턴하는 함수를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c67a87f9e8c8e7cd1eee8d202259f233b1765" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g. of an undecorated string literal.</source>
          <target state="translated">아직 해결되지 않은 유형 (예 : 데코레이션되지 않은 문자열 리터럴)을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c7cbe1f08ac13359acc228819549de4cb50db912" translate="yes" xml:space="preserve">
          <source>Identifies a representation of DDL commands that is available to event triggers.</source>
          <target state="translated">이벤트 트리거에 사용 가능한 DDL 명령의 표현을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c10498b4e600d39b28759a6ca1704d299a1166cc" translate="yes" xml:space="preserve">
          <source>Identifies the event for which this trigger fires</source>
          <target state="translated">이 트리거가 발생하는 이벤트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="708e5b0969ad9b9e70cb24a115182be857e71a40" translate="yes" xml:space="preserve">
          <source>If 1, OIDs are included in the data; if 0, not. Oid system columns are not supported in PostgreSQL anymore, but the format still contains the indicator.</source>
          <target state="translated">1이면 OID가 데이터에 포함됩니다. 0이 아닌 경우 Oid 시스템 열은 PostgreSQL에서 더 이상 지원되지 않지만 형식에는 여전히 표시기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8295c4be7fefd76f1788c97ecf7d786d2a81d6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; has been configured the cluster name will also be shown in &lt;code&gt;ps&lt;/code&gt; output:</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;CLUSTER_NAME가&lt;/a&gt; 구성된 클러스터 이름은에 표시됩니다 &lt;code&gt;ps&lt;/code&gt; 출력 :</target>
        </trans-unit>
        <trans-unit id="8a629049c6dc481b39f88d9e65ac7e85ce3a796f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; is set to &lt;code&gt;off&lt;/code&gt;, or if no JIT implementation is available (for example because the server was compiled without &lt;code&gt;--with-llvm&lt;/code&gt;), JIT will not be performed, even if it would be beneficial based on the above criteria. Setting &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; has effects at both plan and execution time.</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;JIT가&lt;/a&gt; 설정되어 &lt;code&gt;off&lt;/code&gt; 더 JIT 구현을 사용할 수없는 경우, 또는 (예를 들어 서버가없이 컴파일 되었기 때문에 &lt;code&gt;--with-llvm&lt;/code&gt; 은 위의 기준에 따라 도움이 될 것입니다 경우에도, JIT는 수행되지 않습니다). &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; 을 &lt;code&gt;off&lt;/code&gt; 로 설정하면 계획 및 실행 시간 모두에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9523a6aef92c0b8b469d3754e7282b8f5942c267" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, this parameter also controls whether or not transaction commits will wait for their WAL records to be replicated to the standby server(s). When set to &lt;code&gt;on&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to disk. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s). When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it out to their operating system. This setting is sufficient to ensure data preservation even if a standby instance of PostgreSQL were to crash, but not if the standby suffers an operating-system-level crash, since the data has not necessarily reached stable storage on the standby. Finally, the setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is not usually desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; 가 비어 있지 않으면 이 매개 변수는 트랜잭션 커밋이 WAL 레코드가 대기 서버로 복제 될 때까지 대기할지 여부를 제어합니다. &lt;code&gt;on&lt;/code&gt; 으로 설정하면 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하여 디스크로 플러시 할 때까지 기다립니다. 이를 통해 기본 및 모든 동기 대기가 데이터베이스 스토리지의 손상을 입지 않으면 트랜잭션이 유실되지 않습니다. &lt;code&gt;remote_apply&lt;/code&gt; 로 설정하면 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하고 적용했음을 나타낼 때까지 대기하여 대기의 쿼리에 표시됩니다. 로 설정하면 &lt;code&gt;remote_write&lt;/code&gt; , 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하여 운영 체제에 기록 할 때까지 기다립니다. 이 설정은 PostgreSQL의 대기 인스턴스가 충돌하더라도 데이터 보존을 보장하기에 충분하지만 데이터가 대기의 안정적인 스토리지에 반드시 도달 할 필요는 없기 때문에 대기에서 운영 체제 수준의 충돌이 발생하지는 않습니다. 마지막으로 &lt;code&gt;local&lt;/code&gt; 을 설정 하면 커밋이 디스크에 대한 로컬 플러시를 기다리지 만 복제는 기다리지 않습니다. 동기식 복제를 사용하는 경우에는 일반적으로 바람직하지 않지만 완전성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1a25dc46209d8ed1ade19ed10060c5c528c285e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the sum of the sizes of each relation's partitions is also displayed, along with the relation's description. If &lt;code&gt;n&lt;/code&gt; is combined with &lt;code&gt;+&lt;/code&gt;, two sizes are shown: one including the total size of directly-attached leaf partitions, and another showing the total size of all partitions, including indirectly attached sub-partitions.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름을 추가하고, 각각의 관계의 파티션의 크기의 합은 관계의 설명과 함께 표시된다. 경우 &lt;code&gt;n&lt;/code&gt; 결합된다 &lt;code&gt;+&lt;/code&gt; , 두 가지 크기가 도시되어있다 : 하나는 직접 부착 판 파티션의 전체 크기를 포함하고, 다른 간접 부착 서브 파티션을 포함한 모든 파티션의 전체 크기를 표시.</target>
        </trans-unit>
        <trans-unit id="f1cb07ba733b8d98ef45c815d6dfcd5240fbfb93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered from 1.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 출력 라인은 하나의 숫자가된다.</target>
        </trans-unit>
        <trans-unit id="070b09cd2b09c6b749465149e9d2da178b70c1ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 출력 라인은 함수 바디 존재 라인의 제 1 라인으로 넘버링된다.</target>
        </trans-unit>
        <trans-unit id="2d52331f0d53378e8895c635840bb2a68f08d247" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--latency-limit&lt;/code&gt; is used together with &lt;code&gt;--rate&lt;/code&gt;, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</source>
          <target state="translated">경우 &lt;code&gt;--latency-limit&lt;/code&gt; 과 함께 사용 &lt;code&gt;--rate&lt;/code&gt; , 트랜잭션이 이미 대기 시간 한도를 초과 너무 많이이라고 뒤쳐 수있을 때 이전 트랜잭션 종료, 대기 시간은 예약 시작 시간을 계산하기 때문에. 이러한 트랜잭션은 서버로 전송되지 않지만 완전히 건너 뛰어 별도로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5b7745b7624e7dd43bb242cb0d62e7379c97ee2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (the form that adds a new value to an enum type) is executed inside a transaction block, the new value cannot be used until after the transaction has been committed.</source>
          <target state="translated">경우 &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (열거 타입에 새로운 값을 추가하는 형태)가 트랜잭션 블록 내부에서 실행되고, 새로운 값은 트랜잭션이 커밋 된 후에까지 사용될 수 없다.</target>
        </trans-unit>
        <trans-unit id="bb077bc49a16e30ee77115d9ffe115d963646660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, a new transaction is immediately started with the same transaction characteristics (see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;) as the just finished one. Otherwise, no new transaction is started.</source>
          <target state="translated">경우 &lt;code&gt;AND CHAIN&lt;/code&gt; 지정, 새로운 트랜잭션은 즉시 동일한 트랜잭션 특성 (참조로 시작 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET 거래를&lt;/a&gt; 방금 완성 된 하나). 그렇지 않으면 새 트랜잭션이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7c08e9bace5b5133ac34adca9a08f4fe042258e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL&lt;/code&gt; is executed in a transaction block, then the called procedure cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;CALL&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">경우 &lt;code&gt;CALL&lt;/code&gt; 가 트랜잭션 블록에서 실행 한 후 호출 된 프로 시저는 트랜잭션 제어 문을 실행할 수 없습니다. 트랜잭션 제어문은 &lt;code&gt;CALL&lt;/code&gt; 이 자체 트랜잭션에서 실행 되는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="848ec5bbdc5b00e6cc3d9f1bcaa95b1dc8f6e6eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 가 지정되면, 테이블은 부모 테이블의 기본 파티션으로 생성됩니다. 해시 파티션 된 테이블에는이 옵션을 사용할 수 없습니다. 주어진 부모의 다른 파티션에 맞지 않는 파티션 키 값은 기본 파티션으로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="e7358add8de8561a637a99b57db04968568623ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DISTINCT&lt;/code&gt; is specified in addition to an &lt;code&gt;order_by_clause&lt;/code&gt;, then all the &lt;code&gt;ORDER BY&lt;/code&gt; expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the &lt;code&gt;DISTINCT&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;order_by_clause&lt;/code&gt; 외에 &lt;code&gt;DISTINCT&lt;/code&gt; 가 지정된 경우 모든 &lt;code&gt;ORDER BY&lt;/code&gt; 표현식은 집계의 일반 인수와 일치해야합니다. 즉, &lt;code&gt;DISTINCT&lt;/code&gt; 목록에 포함되지 않은 식을 정렬 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="30705d4f5de2e5919df753dbf707be6e61f46c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DO&lt;/code&gt; is executed in a transaction block, then the procedure code cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;DO&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">경우 &lt;code&gt;DO&lt;/code&gt; 가 트랜잭션 블록에서 실행되는 다음 프로 시저 코드는 트랜잭션 제어 문을 실행할 수 없습니다. 트랜잭션 제어문은 &lt;code&gt;DO&lt;/code&gt; 가 자체 트랜잭션에서 실행 되는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="df6a86ce0cd5c24d459324e69a0c7e3798125378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; is specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">경우 &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; 지정되고 열이 ID 열이 아닌, 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="895523ab1404bbeb5f8a66ec67423cf5c0e02e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP ROLE&lt;/code&gt; is attempted while dependent objects still remain, it will issue messages identifying which objects need to be reassigned or dropped.</source>
          <target state="translated">종속 오브젝트가 계속 남아있는 동안 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 시도 하면 , 재 할당하거나 삭제해야하는 오브젝트를 식별하는 메시지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="da529f5ed28015eb2651a4b68ada28ed62e240c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the aggregate function; other rows are discarded. For example:</source>
          <target state="translated">경우 &lt;code&gt;FILTER&lt;/code&gt; 되는, 만 입력 행 지정 &lt;code&gt;filter_clause&lt;/code&gt; 의 참으로 평가를 집계 함수로 공급되는 단계; 다른 행은 삭제됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bc024c5c56715620389a9f40a0a619b2dabf192" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the window function; other rows are discarded. Only window functions that are aggregates accept a &lt;code&gt;FILTER&lt;/code&gt; clause.</source>
          <target state="translated">경우 &lt;code&gt;FILTER&lt;/code&gt; 지정된 경우 만 입력되는 행을위한 &lt;code&gt;filter_clause&lt;/code&gt; 의 참으로 평가하여 창 함수에 공급된다; 다른 행은 삭제됩니다. 집계 된 창 함수 만 &lt;code&gt;FILTER&lt;/code&gt; 절을 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="cd9e1d53d5d6b7dacb647bc6b43f3a0bb2b3f3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate's regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</source>
          <target state="translated">경우 &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; 가 지정된 후 최종 상태 값과 직접적인 인자 이외에, 최종 함수는 골재의 정규 (응집) 인자에 대응하는 여분의 NULL 값을 수신한다. 이는 다형성 집계가 정의 될 때 집계 결과 유형의 올바른 해상도를 허용하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79c74fbef6be293db9ab06b3c7837e0fb4b62bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement locks the selected rows against concurrent updates. (See &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;The Locking Clause&lt;/a&gt; below.)</source>
          <target state="translated">경우 &lt;code&gt;FOR UPDATE&lt;/code&gt; , &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 지정되면, &lt;code&gt;SELECT&lt;/code&gt; 문은 동시 업데이트에 대한 선택한 행을 잠급니다. (아래 &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;의 잠금 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a805c0a50f5da5361e847219abae4a282083ebad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FX&lt;/code&gt; is specified, a separator in the template string matches exactly one character in the input string. But note that the input string character is not required to be the same as the separator from the template string. For example, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; works, but &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; returns an error because the second space in the template string consumes the letter &lt;code&gt;J&lt;/code&gt; from the input string.</source>
          <target state="translated">&lt;code&gt;FX&lt;/code&gt; 가 지정된 경우 템플릿 문자열의 구분 기호는 입력 문자열의 문자 하나와 정확히 일치합니다. 그러나 입력 문자열 문자가 템플릿 문자열의 구분 기호와 같을 필요는 없습니다. 예를 들어, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; 는 작동하지만 &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; 는 템플리트 문자열의 두 번째 공백 이 입력에서 문자 &lt;code&gt;J&lt;/code&gt; 를 소비하므로 오류를 리턴합니다. 끈.</target>
        </trans-unit>
        <trans-unit id="14af0e221ff15633d3dbc5822cb9a995fc47a018" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; is not specified for a registered buffer, the generic WAL record contains a delta between the old and the new page images. This delta is based on byte-by-byte comparison. This is not very compact for the case of moving data within a page, and might be improved in the future.</source>
          <target state="translated">경우 &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; 이 등록 된 버퍼를 지정하지 않은 일반 WAL 레코드 이전 및 새 페이지 이미지 사이의 델타가 포함되어 있습니다. 이 델타는 바이트 단위 비교를 기반으로합니다. 페이지 내에서 데이터를 이동하는 경우에는 그리 간단하지 않으며 앞으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5c28224428244bd7b83410c113faa1c8237d3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; is specified, only the grant option for the privilege is revoked, not the privilege itself. Otherwise, both the privilege and the grant option are revoked.</source>
          <target state="translated">경우 &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; 지정되면, 권한 만 부여 옵션은 권한 자체를하지 폐기됩니다. 그렇지 않으면 권한과 부여 옵션이 모두 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f1dbb4a5b057fd9d80b4085324de683535f1772c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified, it is not an error if the type already contains the new value: a notice is issued but no other action is taken. Otherwise, an error will occur if the new value is already present.</source>
          <target state="translated">경우 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 지정된 유형이 이미 새 값을 포함하는 경우, 에러되지 않습니다 : 통지가 발행되지만 다른 작업이 수행되지 않습니다. 그렇지 않으면 새 값이 이미 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="713b84661234cdebeb4eb076bfe7612a7ddb758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NO CYCLE&lt;/code&gt; is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, &lt;code&gt;NO CYCLE&lt;/code&gt; is the default.</source>
          <target state="translated">경우 &lt;code&gt;NO CYCLE&lt;/code&gt; 이 지정된 경우를 호출하기 &lt;code&gt;nextval&lt;/code&gt; 순서 후에는 최대 값이 오류를 반환 도달했습니다. &lt;code&gt;CYCLE&lt;/code&gt; 또는 &lt;code&gt;NO CYCLE&lt;/code&gt; 을 지정 하지 않으면 &lt;code&gt;NO CYCLE&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6bbdf1bb14119659019986a40e06a497bd2493a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NULLS LAST&lt;/code&gt; is specified, null values sort after all non-null values; if &lt;code&gt;NULLS FIRST&lt;/code&gt; is specified, null values sort before all non-null values. If neither is specified, the default behavior is &lt;code&gt;NULLS LAST&lt;/code&gt; when &lt;code&gt;ASC&lt;/code&gt; is specified or implied, and &lt;code&gt;NULLS FIRST&lt;/code&gt; when &lt;code&gt;DESC&lt;/code&gt; is specified (thus, the default is to act as though nulls are larger than non-nulls). When &lt;code&gt;USING&lt;/code&gt; is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.</source>
          <target state="translated">경우 &lt;code&gt;NULLS LAST&lt;/code&gt; 는 일종의 널 (NULL)이 아닌 모든 값 이후, 널 (null) 값을 지정; 경우 &lt;code&gt;NULLS FIRST&lt;/code&gt; 가 지정되고, 널 (null) 값 종류의 모든 null이 아닌 값 전에. 둘 다 지정하지 않으면 &lt;code&gt;ASC&lt;/code&gt; 를 지정하거나 암시 할 때 기본 동작은 &lt;code&gt;NULLS LAST&lt;/code&gt; 이고 &lt;code&gt;DESC&lt;/code&gt; 가 지정 될 때 &lt;code&gt;NULLS FIRST&lt;/code&gt; 입니다 (따라서 기본값은 널이 널이 아닌 것보다 큰 것처럼 작동 함). 때 &lt;code&gt;USING&lt;/code&gt; 지정, 기본 널 순서는 운영자가 덜 작거나보다 큰 사업자인지에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8fb56e2e9f0f01bd1fdfbdbf89ac20f3bbcae1c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PARTITION OF&lt;/code&gt; clause is specified then the table is created as a partition of &lt;code&gt;parent_table&lt;/code&gt; with specified bounds.</source>
          <target state="translated">경우 &lt;code&gt;PARTITION OF&lt;/code&gt; 절을 한 후 지정된 테이블의 파티션으로 생성 &lt;code&gt;parent_table&lt;/code&gt; 지정된 범위와.</target>
        </trans-unit>
        <trans-unit id="c7ee0e44f6b6bd7b6f554d708cd5b901ba47c152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PRIMARY KEY&lt;/code&gt; is specified, and the index's columns are not already marked &lt;code&gt;NOT NULL&lt;/code&gt;, then this command will attempt to do &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.</source>
          <target state="translated">경우 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 가 지정, 인덱스의 열이 이미 표시되지 않은 &lt;code&gt;NOT NULL&lt;/code&gt; 을 ,이 명령을 수행하려고 시도합니다 &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; 각각 같은 열에 대해. 열에 널이 없는지 확인하려면 전체 테이블 스캔이 필요합니다. 다른 모든 경우에는 빠른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="ae2eae0b6691115fff0baa447860d3557c71a926" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RECURSIVE&lt;/code&gt; is specified, it allows a &lt;code&gt;SELECT&lt;/code&gt; subquery to reference itself by name. Such a subquery must have the form</source>
          <target state="translated">경우 &lt;code&gt;RECURSIVE&lt;/code&gt; 지정, 그것은 수 있습니다 &lt;code&gt;SELECT&lt;/code&gt; 이름으로 자신을 참조하는 하위 쿼리를. 이러한 하위 쿼리는 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c5e50c2f4aff13823fb6c53c60eb5ef4318ca54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SELECT DISTINCT&lt;/code&gt; is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). &lt;code&gt;SELECT ALL&lt;/code&gt; specifies the opposite: all rows are kept; that is the default.</source>
          <target state="translated">경우 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; 가 지정된 모든 중복 행 결과 세트로부터 제거된다 (하나 개의 행이 중복되는 각 그룹에서 유지된다). &lt;code&gt;SELECT ALL&lt;/code&gt; 은 반대를 지정합니다. 모든 행이 유지됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="04b3f6938761ce362c4ded325b6abaf0a88a5df2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET LOCAL&lt;/code&gt; is used within a function that has a &lt;code&gt;SET&lt;/code&gt; option for the same variable (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;), the effects of the &lt;code&gt;SET LOCAL&lt;/code&gt; command disappear at function exit; that is, the value in effect when the function was called is restored anyway. This allows &lt;code&gt;SET LOCAL&lt;/code&gt; to be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using the &lt;code&gt;SET&lt;/code&gt; option to save and restore the caller's value. However, a regular &lt;code&gt;SET&lt;/code&gt; command overrides any surrounding function's &lt;code&gt;SET&lt;/code&gt; option; its effects will persist unless rolled back.</source>
          <target state="translated">동일한 변수에 대해 &lt;code&gt;SET&lt;/code&gt; 옵션 이있는 함수 내에서 &lt;code&gt;SET LOCAL&lt;/code&gt; 을 사용하는 경우 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조 ) &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 의 효과는 함수 종료시 사라집니다. 즉, 함수가 호출되었을 때 유효한 값이 어쨌든 복원됩니다. 이를 통해 &lt;code&gt;SET LOCAL&lt;/code&gt; 을 사용하여 함수 내에서 매개 변수를 동적으로 또는 반복적으로 변경할 수 있으며 &lt;code&gt;SET&lt;/code&gt; 옵션을 사용 하여 호출자의 값을 저장하고 복원 할 수 있습니다. 그러나 일반적인 &lt;code&gt;SET&lt;/code&gt; 명령은 모든 주변 기능의 &lt;code&gt;SET&lt;/code&gt; 옵션 보다 우선합니다 . 롤백하지 않으면 효과가 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="ec901162256017a1ee3d75cc5aa3a5194df885bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET TRANSACTION&lt;/code&gt; is executed without a prior &lt;code&gt;START TRANSACTION&lt;/code&gt; or &lt;code&gt;BEGIN&lt;/code&gt;, it emits a warning and otherwise has no effect.</source>
          <target state="translated">경우 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 이전하지 않고 실행 &lt;code&gt;START TRANSACTION&lt;/code&gt; 또는 &lt;code&gt;BEGIN&lt;/code&gt; , 그것은 경고를 방출하고, 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c679999524623fe277800e4000b75170afd22ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET&lt;/code&gt; (or equivalently &lt;code&gt;SET SESSION&lt;/code&gt;) is issued within a transaction that is later aborted, the effects of the &lt;code&gt;SET&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; (또는 동등 &lt;code&gt;SET SESSION&lt;/code&gt; 가 ) 나중에 중단 된 트랜잭션 내에서 발행,의 효과 &lt;code&gt;SET&lt;/code&gt; 의 트랜잭션이 롤백 될 때 명령은 사라집니다. 주변 트랜잭션이 커밋되면 다른 &lt;code&gt;SET&lt;/code&gt; 가 재정의하지 않는 한 세션이 끝날 때까지 효과가 지속됩니다 .</target>
        </trans-unit>
        <trans-unit id="9705e1f00e76813c6d22bc3d6eab56b5d6ef9cd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to hold &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role. Database superusers can grant or revoke membership in any role to anyone. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can grant or revoke membership in any role that is not a superuser.</source>
          <target state="translated">경우 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 지정된 역할의 멤버 캔 차례로 부여 다른 사람에게 역할의 멤버 및 REVOKE 회원뿐만 아니라. 관리자 옵션이 없으면 일반 사용자는 그렇게 할 수 없습니다. 역할은 자체적으로 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 을 보유하는 것으로 간주되지 않지만 세션 사용자가 역할과 일치하는 데이터베이스 세션에서 자체적으로 멤버 자격을 부여하거나 취소 할 수 있습니다. 데이터베이스 수퍼 유저는 모든 역할의 멤버 자격을 누구에게나 부여하거나 취소 할 수 있습니다. 가진 역할 &lt;code&gt;CREATEROLE&lt;/code&gt; 의 권한을 부여하거나 수퍼 유저가 아닌 임의의 역할에 회원 자격을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd80886f4a2be834b3e10dda7c9db6fa997569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; is specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 지정, 차례로 권한 캔의받는 사람이 다른 사람에게 부여합니다. 부여 옵션이 없으면 수신자는 그렇게 할 수 없습니다. &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 옵션을 부여 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9373b178281613a72e6b020f7636dc488a5f1d3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH HOLD&lt;/code&gt; is specified and the transaction that created the cursor successfully commits, the cursor can continue to be accessed by subsequent transactions in the same session. (But if the creating transaction is aborted, the cursor is removed.) A cursor created with &lt;code&gt;WITH HOLD&lt;/code&gt; is closed when an explicit &lt;code&gt;CLOSE&lt;/code&gt; command is issued on it, or the session ends. In the current implementation, the rows represented by a held cursor are copied into a temporary file or memory area so that they remain available for subsequent transactions.</source>
          <target state="translated">경우 &lt;code&gt;WITH HOLD&lt;/code&gt; 지정 커서를 생성 한 트랜잭션이 성공적으로 커밋되고, 커서는 같은 세션에서 후속 트랜잭션에 의해 액세스 할 수 계속할 수 있습니다. 그러나 작성 트랜잭션이 중단되면 커서가 제거됩니다. &lt;code&gt;WITH HOLD&lt;/code&gt; 로 작성된 커서 는 명시적인 &lt;code&gt;CLOSE&lt;/code&gt; 명령이 발행되거나 세션 이 종료 될 때 닫힙니다 . 현재 구현에서, 보유 커서로 표시되는 행은 임시 파일 또는 메모리 영역으로 복사되어 후속 트랜잭션에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d9dde45619a2d3c398745c13026f768d6b6b6cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\d&lt;/code&gt; is used without a &lt;code&gt;pattern&lt;/code&gt; argument, it is equivalent to &lt;code&gt;\dtvmsE&lt;/code&gt; which will show a list of all visible tables, views, materialized views, sequences and foreign tables. This is purely a convenience measure.</source>
          <target state="translated">경우 &lt;code&gt;\d&lt;/code&gt; 없이 사용 &lt;code&gt;pattern&lt;/code&gt; 인수가 동등 &lt;code&gt;\dtvmsE&lt;/code&gt; 보이는 모든 테이블의 목록이 표시되는 뷰는 뷰 시퀀스 외국 테이블을 구체화. 이것은 순전히 편의 수단입니다.</target>
        </trans-unit>
        <trans-unit id="99696408eca3e79444094829903879dfb2c22cfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\pset columns&lt;/code&gt; is zero, controls the width for the &lt;code&gt;wrapped&lt;/code&gt; format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode.</source>
          <target state="translated">경우 &lt;code&gt;\pset columns&lt;/code&gt; 제로의 폭 제어를위한 &lt;code&gt;wrapped&lt;/code&gt; 넓은 출력 페이저를 요구하거나 확장 자동 모드에서의 수직 형태로 전환되어야 하는지를 결정하기위한 포맷 및 폭.</target>
        </trans-unit>
        <trans-unit id="65d8ff6e4bb927882e0081eeca2677185a93d180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; 가 &lt;code&gt;on&lt;/code&gt; 으로 설정되어 있으면 복구 또는 대기 모드 중에 아카이버를 사용할 수 없습니다. 대기 서버가 승격 된 경우 승격 후 보관을 시작하지만 자체 생성하지 않은 WAL은 보관하지 않습니다. 아카이브에서 전체 WAL 파일 시리즈를 얻으려면 대기에 도달하기 전에 모든 WAL이 아카이브되어 있는지 확인해야합니다. 대기는 아카이브에서 찾은 파일 만 복원 할 수 있지만 스트리밍 복제가 사용 가능한 경우는 불가능하므로 파일 기반 로그 전달에서는 본질적으로 적용됩니다. 서버가 복구 모드에 있지 않으면 &lt;code&gt;on&lt;/code&gt; 모드 와 &lt;code&gt;always&lt;/code&gt; 모드 간에 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4c5e023785c0eaf8158798154829baaec24284f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note however that Readline is not used in this case (much as if &lt;code&gt;-n&lt;/code&gt; had been specified).</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 이다 &lt;code&gt;-&lt;/code&gt; (하이픈) 다음 표준 입력은 EOF 또는 표시 될 때까지 판독된다 &lt;code&gt;\q&lt;/code&gt; 메타 명령. 이것은 대화식 입력을 파일 입력과 함께 산재하는 데 사용할 수 있습니다. 그러나이 경우 Readline은 사용되지 않습니다 ( &lt;code&gt;-n&lt;/code&gt; 이 지정된 것처럼 ).</target>
        </trans-unit>
        <trans-unit id="a4833473639ec21367a52ecaec9a765427862e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note that Readline behavior will be used only if it is active at the outermost level.</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 이다 &lt;code&gt;-&lt;/code&gt; (하이픈) 다음 표준 입력은 EOF 또는 표시 될 때까지 판독된다 &lt;code&gt;\q&lt;/code&gt; 메타 명령. 이것은 대화식 입력을 파일 입력과 함께 산재하는 데 사용할 수 있습니다. Readline 동작은 가장 바깥 레벨에서 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8bdbf29f6ea734e4384d8cec6971a567637c07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is specified, the file is edited; after the editor exits, the file's content is copied into the current query buffer. If no &lt;code&gt;filename&lt;/code&gt; is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. Or, if the current query buffer is empty, the most recently executed query is copied to a temporary file and edited in the same fashion.</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 지정, 파일은 편집; 편집기가 종료되면 파일 내용이 현재 쿼리 버퍼에 복사됩니다. &lt;code&gt;filename&lt;/code&gt; 을 지정 하지 않으면 현재 쿼리 버퍼가 임시 파일로 복사 된 다음 동일한 방식으로 편집됩니다. 또는 현재 쿼리 버퍼가 비어 있으면 가장 최근에 실행 된 쿼리가 임시 파일로 복사되고 같은 방식으로 편집됩니다.</target>
        </trans-unit>
        <trans-unit id="87b5fa64a8f2d20fd3cdbf376e8372ac5be9682f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_end&lt;/code&gt; is omitted it defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;. Restrictions are that &lt;code&gt;frame_start&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt;, &lt;code&gt;frame_end&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;, and the &lt;code&gt;frame_end&lt;/code&gt; choice cannot appear earlier in the above list of &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; options than the &lt;code&gt;frame_start&lt;/code&gt; choice does &amp;mdash; for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; is not allowed.</source>
          <target state="translated">&lt;code&gt;frame_end&lt;/code&gt; 가 생략 되면 기본값은 &lt;code&gt;CURRENT ROW&lt;/code&gt; 입니다. 제한 사항이 있습니다 &lt;code&gt;frame_start&lt;/code&gt; 이 될 수 없다 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; , &lt;code&gt;frame_end&lt;/code&gt; 될 수 없습니다 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 하고 &lt;code&gt;frame_end&lt;/code&gt; 선택의 위의 목록에서 이전에 나타날 수 없습니다 &lt;code&gt;frame_start&lt;/code&gt; 및 &lt;code&gt;frame_end&lt;/code&gt; 댄 옵션 &lt;code&gt;frame_start&lt;/code&gt; 의 선택은 않습니다 - 예에 대한 &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1493aafac52b8fb4240f760d7718dc0ee8aca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genbki.pl&lt;/code&gt; needs to assign an OID to a catalog entry that does not have a manually-assigned OID, it will use a value in the range 10000&amp;mdash;11999. The server's OID counter is set to 12000 at the start of a bootstrap run. Thus objects created by regular SQL commands during the later phases of bootstrap, such as objects created while running the &lt;code&gt;information_schema.sql&lt;/code&gt; script, receive OIDs of 12000 or above.</source>
          <target state="translated">&lt;code&gt;genbki.pl&lt;/code&gt; 이 수동으로 할당 한 OID가없는 카탈로그 항목에 OID를 할당 해야하는 경우 10000&amp;mdash;11999 범위의 값을 사용합니다. 부트 스트랩 실행 시작시 서버의 OID 카운터가 12000으로 설정됩니다. 따라서 &lt;code&gt;information_schema.sql&lt;/code&gt; 스크립트 를 실행하는 동안 생성 된 객체와 같이 부트 스트랩의 이후 단계에서 일반 SQL 명령으로 생성 된 객체 는 12000 이상의 OID를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e8c7103cc04741a131a5ac6b2ff588f135e3ddcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hot_standby&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; (the default value) and there is a &lt;code&gt;standby.signal&lt;/code&gt; file present, the server will run in Hot Standby mode. However, it may take some time for Hot Standby connections to be allowed, because the server will not accept connections until it has completed sufficient recovery to provide a consistent state against which queries can run. During this period, clients that attempt to connect will be refused with an error message. To confirm the server has come up, either loop trying to connect from the application, or look for these messages in the server logs:</source>
          <target state="translated">경우 &lt;code&gt;hot_standby&lt;/code&gt; 가 이다 &lt;code&gt;on&lt;/code&gt; 있는 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 (기본값)과이 &lt;code&gt;standby.signal&lt;/code&gt; 파일 존재는, 서버는 상시 대기 모드로 실행됩니다. 그러나 핫 스탠바이 연결이 허용 되려면 시간이 걸릴 수 있습니다. 서버는 쿼리를 실행할 수있는 일관된 상태를 제공하기에 충분한 복구가 완료 될 때까지 연결을 수락하지 않기 때문입니다. 이 기간 동안 연결을 시도하는 클라이언트는 오류 메시지와 함께 거부됩니다. 서버가 작동했는지 확인하려면 루프를 응용 프로그램에서 연결하려고 시도하거나 서버 로그에서 다음 메시지를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2c8e31ec3780ebc59dc482c2ca3c59c045a41221" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be false for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; 진정한 = 일부에 대한 거짓 &lt;code&gt;val1&lt;/code&gt; 과 &lt;code&gt;base&lt;/code&gt; , 그것은 모든위한 false 여야 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; 과 같은과 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332193353c52bde38e0eb3c661ad221eb1be8b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be false for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 거짓 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;base1&lt;/code&gt; , 그것은 모든위한 false 여야 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 같은과 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa930e16baff55aa31e6852a2b74660f8ec3544e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be true for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 사실 &lt;code&gt;val1&lt;/code&gt; 및 &lt;code&gt;base&lt;/code&gt; 도 모든 마찬가지해야합니다 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; 과 같은과 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342ab2a9a17f2fb194989decac130f65bf2a3ab2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be true for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 사실 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;base1&lt;/code&gt; , 그것은 모든 마찬가지해야 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 같은과 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3506d1e84d2320597dc89468fa4fbfef68d52af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pager_min_lines&lt;/code&gt; is set to a number greater than the page height, the pager program will not be called unless there are at least this many lines of output to show. The default setting is 0.</source>
          <target state="translated">&lt;code&gt;pager_min_lines&lt;/code&gt; 가 페이지 높이보다 큰 숫자로 설정된 경우 , 표시 할 최소한이 출력 행이 없으면 호출기 프로그램이 호출되지 않습니다. 기본 설정은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ad57f5bc57449c70be03f78cafa8198c7fecd4a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pattern&lt;/code&gt; does not contain percent signs or underscores, then the pattern only represents the string itself; in that case &lt;code&gt;LIKE&lt;/code&gt; acts like the equals operator. An underscore (&lt;code&gt;_&lt;/code&gt;) in &lt;code&gt;pattern&lt;/code&gt; stands for (matches) any single character; a percent sign (&lt;code&gt;%&lt;/code&gt;) matches any sequence of zero or more characters.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 퍼센트 기호 나 밑줄이 없으면 패턴 은 문자열 자체 만 나타냅니다. 이 경우 &lt;code&gt;LIKE&lt;/code&gt; 는 equals 연산자처럼 작동합니다. &lt;code&gt;pattern&lt;/code&gt; 의 밑줄 ( &lt;code&gt;_&lt;/code&gt; )은 단일 문자를 나타냅니다 (일치). 퍼센트 기호 ( &lt;code&gt;%&lt;/code&gt; )는 0 개 이상의 문자 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="929282dbe9432a59498fc7de54e9f120a0c23fde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_resetwal&lt;/code&gt; complains that it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, you can force it to proceed anyway by specifying the &lt;code&gt;-f&lt;/code&gt; (force) option. In this case plausible values will be substituted for the missing data. Most of the fields can be expected to match, but manual assistance might be needed for the next OID, next transaction ID and epoch, next multitransaction ID and offset, and WAL starting location fields. These fields can be set using the options discussed below. If you are not able to determine correct values for all these fields, &lt;code&gt;-f&lt;/code&gt; can still be used, but the recovered database must be treated with even more suspicion than usual: an immediate dump and reload is imperative. &lt;em&gt;Do not&lt;/em&gt; execute any data-modifying operations in the database before you dump, as any such action is likely to make the corruption worse.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 이 &lt;code&gt;pg_control&lt;/code&gt; 에 유효한 데이터를 결정할 수 없다고 불평하는 경우 , &lt;code&gt;-f&lt;/code&gt; (force) 옵션 을 지정하여 강제로 진행할 수 있습니다 . 이 경우 그럴듯한 값이 누락 된 데이터로 대체됩니다. 대부분의 필드가 일치 할 것으로 예상되지만 다음 OID, 다음 트랜잭션 ID 및 에포크, 다음 다중 트랜잭션 ID 및 오프셋 및 WAL 시작 위치 필드에는 수동 지원이 필요할 수 있습니다. 이 필드는 아래에서 논의 된 옵션을 사용하여 설정할 수 있습니다. 이러한 모든 필드에 대해 올바른 값을 판별 할 수없는 경우 &lt;code&gt;-f&lt;/code&gt; 를 계속 사용할 수 있지만 복구 된 데이터베이스는 평소보다 훨씬 더 의심을 가지고 처리해야합니다. 즉각 덤프 및 재로드가 필수적입니다. &lt;em&gt;하지 마라&lt;/em&gt; 덤프하기 전에 데이터베이스에서 데이터 수정 조작을 실행하십시오. 이러한 조치는 손상을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f13d0730a2d7549daf41a4dfb84c03f31c4b1319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_upgrade&lt;/code&gt; aborted before linking started, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">링크가 시작되기 전에 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 중단 된 경우 이전 클러스터는 수정되지 않았습니다. 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e188ae9422c6dffedeb340ab362e8934b4b3e43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prokind&lt;/code&gt; indicates that the entry is for an aggregate function, there should be a matching row in &lt;code&gt;pg_aggregate&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;prokind&lt;/code&gt; 이 항목이 집합 함수임을 나타낸다에 일치하는 행이 있어야 &lt;code&gt;pg_aggregate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32186644a8227bc9629078cb6964f294409c3b69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the settings &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same synchronization level: transaction commits only wait for local flush to disk.</source>
          <target state="translated">&lt;code&gt;synchronous_standby_names&lt;/code&gt; 가 비어 있으면 , &lt;code&gt;remote_apply&lt;/code&gt; , &lt;code&gt;remote_write&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 설정 &lt;code&gt;on&lt;/code&gt; 모두 동일한 동기화 레벨을 제공합니다. 트랜잭션 커밋은 디스크에 대한 로컬 플러시 만 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e17b6ba8e8e554c6fa5ecad07078e794222b7865" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typarray&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;, which is the &amp;ldquo;true&amp;rdquo; array type having this type as element</source>
          <target state="translated">&lt;code&gt;typarray&lt;/code&gt; 가 0이 아닌 경우 &lt;code&gt;pg_type&lt;/code&gt; 에서 다른 행을 식별 합니다 .이 행은 이 유형을 요소로 사용하는 &quot;true&quot;배열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1643f010e11a8ec209a76b1daf0df11fad85a094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typdefaultbin&lt;/code&gt; is not null, it is the &lt;code&gt;nodeToString()&lt;/code&gt; representation of a default expression for the type. This is only used for domains.</source>
          <target state="translated">&lt;code&gt;typdefaultbin&lt;/code&gt; 이 널이 아닌 경우 유형에 대한 기본 표현식 의 &lt;code&gt;nodeToString()&lt;/code&gt; 표시입니다. 도메인에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a098d6d2d4ed82c302d8bd246178fb2399080947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typelem&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;. The current type can then be subscripted like an array yielding values of type &lt;code&gt;typelem&lt;/code&gt;. A &amp;ldquo;true&amp;rdquo; array type is variable length (&lt;code&gt;typlen&lt;/code&gt; = -1), but some fixed-length (&lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) types also have nonzero &lt;code&gt;typelem&lt;/code&gt;, for example &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;point&lt;/code&gt;. If a fixed-length type has a &lt;code&gt;typelem&lt;/code&gt; then its internal representation must be some number of values of the &lt;code&gt;typelem&lt;/code&gt; data type with no other data. Variable-length array types have a header defined by the array subroutines.</source>
          <target state="translated">&lt;code&gt;typelem&lt;/code&gt; 이 0 이 아니면 &lt;code&gt;pg_type&lt;/code&gt; 에서 다른 행을 식별 합니다 . 그런 다음 현재 유형을 &lt;code&gt;typelem&lt;/code&gt; 유형의 값을 생성하는 배열처럼 첨자화할 수 있습니다 . &quot;true&quot;배열 유형은 가변 길이 ( &lt;code&gt;typlen&lt;/code&gt; = -1)이지만 일부 고정 길이 ( &lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) 유형 ( 예 : &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;point&lt;/code&gt; )도 0이 아닌 &lt;code&gt;typelem&lt;/code&gt; 입니다. 고정 길이 타입이있는 경우 &lt;code&gt;typelem&lt;/code&gt; 를 다음 내부 표현의 값의 일부 수 있어야 &lt;code&gt;typelem&lt;/code&gt; 의 다른 데이터를 데이터 타입. 가변 길이 배열 유형에는 배열 서브 루틴에 의해 정의 된 헤더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="962e01512a43e6b662e513b46b2720b8eda2c536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and locale-specific numeric output.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 하나가되어야합니다 지정 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 있는 활성화 또는 소수점 마커의 왼쪽 자리의 별도의 그룹에 로케일 고유의 문자의 비활성화가 표시됩니다. 경우 &lt;code&gt;value&lt;/code&gt; 정규 로케일 특정 숫자의 출력 명령을 전환 생략한다.</target>
        </trans-unit>
        <trans-unit id="0ac5be223120c8314531a02347c6041d7cd668b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of the table footer (the &lt;code&gt;(n rows)&lt;/code&gt; count). If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles footer display on or off.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 지정되어이 중 하나 여야 &lt;code&gt;on&lt;/code&gt; 나 &lt;code&gt;off&lt;/code&gt; 있는 활성화 또는 테이블 바닥 글 (의 비활성화 표시됩니다 &lt;code&gt;(n rows)&lt;/code&gt; 카운트). 경우 &lt;code&gt;value&lt;/code&gt; 또는 해제 명령 토글 바닥 글 표시를 생략하기로한다.</target>
        </trans-unit>
        <trans-unit id="5cba26a9c2b6ebc7647fabad9eea11f281ddf193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable tuples-only mode. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 지정되어이 중 하나 여야 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 를 활성화 또는 비활성화 튜플 전용 모드 것이다. 경우 &lt;code&gt;value&lt;/code&gt; 정규 튜플 전용 출력 간의 토글 명령을 생략한다. 일반 출력에는 열 머리글, 제목 및 다양한 바닥 글과 같은 추가 정보가 포함됩니다. 튜플 전용 모드에서는 실제 테이블 데이터 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6fae09f9e5152eceff65217f721d75ba03342e63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;, which will enable or disable expanded mode, or &lt;code&gt;auto&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn't fit on the screen in the normal &amp;ldquo;horizontal&amp;rdquo; mode. In the auto setting, the expanded mode is used whenever the query output has more than one column and is wider than the screen; otherwise, the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 지정 되면 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 여야하며 확장 모드를 사용 또는 사용하지 않도록 설정하거나 &lt;code&gt;auto&lt;/code&gt; 입니다. 경우 &lt;code&gt;value&lt;/code&gt; 에 대한 설정 및 해제 사이의 명령 토글을 생략하기로한다. 확장 모드를 사용하면 왼쪽에 열 이름이 있고 오른쪽에 데이터가있는 두 개의 열에 쿼리 결과가 표시됩니다. 이 모드는 데이터가 일반 &quot;수평&quot;모드에서 화면에 맞지 않을 때 유용합니다. 자동 설정에서 확장 모드는 조회 출력에 둘 이상의 열이 있고 화면보다 넓은 경우 항상 사용됩니다. 그렇지 않으면 일반 모드가 사용됩니다. 자동 설정은 정렬 및 줄 바꿈 형식에서만 유효합니다. 다른 형식에서는 항상 확장 모드가 꺼져있는 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="ca01598c7c349232ee9c2f60f218cecf6c2e9b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is supplied, only occurrences having one of those weights are counted.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 공급되고, 그 무게 중 하나를 가진 경우에만 발생 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc5f92abbdc131542b5a63d7715ef7b5720a0a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;do_detoast&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, attribute that will be detoasted as needed. Default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;do_detoast&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 필요에 따라 제거되는 속성입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9855c6593bb788e4a7fc1baab60a566fbf901f03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is false, then the resulting XML document looks like this:</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; 은&lt;/em&gt; 거짓,이 같은 결과 XML 문서 외모 :</target>
        </trans-unit>
        <trans-unit id="c50916d42c87228c370dd43c14046f7ce4402cc5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is true, the result is an XML content fragment that looks like this:</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; 는&lt;/em&gt; 사실, 결과는 XML 콘텐츠 단편은 그 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="a00e85c8c38a440ad71ba2067ec654d399028aa3" translate="yes" xml:space="preserve">
          <source>If BC has been specified, negate the year and add one for internal storage. (There is no year zero in the Gregorian calendar, so numerically 1 BC becomes year zero.)</source>
          <target state="translated">BC가 지정된 경우 연도를 무효화하고 내부 저장 용으로 추가하십시오. 그레고리력에는 0 년이 없으므로 BC 1 년은 0 년이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6677efb7a76da9c59cedae433efda4935b91f1" translate="yes" xml:space="preserve">
          <source>If BC was not specified, and if the year field was two digits in length, then adjust the year to four digits. If the field is less than 70, then add 2000, otherwise add 1900.</source>
          <target state="translated">BC가 지정되지 않았고 연도 필드의 길이가 두 자리 인 경우 연도를 네 자리로 조정하십시오. 필드가 70보다 작 으면 2000을 추가하고, 그렇지 않으면 1900을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b50e5581cb9a085c462f20b706e74a8924f7f1" translate="yes" xml:space="preserve">
          <source>If CSV-format output is enabled in &lt;code&gt;log_destination&lt;/code&gt;, &lt;code&gt;.csv&lt;/code&gt; will be appended to the timestamped log file name to create the file name for CSV-format output. (If &lt;code&gt;log_filename&lt;/code&gt; ends in &lt;code&gt;.log&lt;/code&gt;, the suffix is replaced instead.)</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; 에서 CSV 형식 출력이 사용 가능한 경우 &lt;code&gt;.csv&lt;/code&gt; 가 시간 소인이 지정된 로그 파일 이름에 추가되어 CSV 형식 출력의 파일 이름을 작성합니다. ( &lt;code&gt;log_filename&lt;/code&gt; 이 &lt;code&gt;.log&lt;/code&gt; 로 끝나면 대신 접미사가 바뀝니다.)</target>
        </trans-unit>
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVM에 필요한 기능이있는 경우 perf가 JIT에서 생성 한 기능을 프로파일 링하는 데 필요한 데이터를 생성하십시오. &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; 파일을 씁니다 . 사용자는 원할 때 정리를 수행 할 책임이 있습니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVM에 필요한 기능이 있으면 생성 된 기능을 GDB에 등록하십시오. 이것은 디버깅을 더 쉽게 만듭니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">파일에 OID가 포함 된 경우 OID 필드는 필드 수 단어 바로 뒤에옵니다. 필드 수에 포함되지 않은 것을 제외하고는 일반 필드입니다. 현재 버전의 PostgreSQL에서는 OID 시스템 열이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">PAM이 &lt;code&gt;/etc/shadow&lt;/code&gt; 를 읽도록 설정되면 루트가 아닌 사용자가 PostgreSQL 서버를 시작하므로 인증이 실패합니다. 그러나 PAM이 LDAP 또는 다른 인증 방법을 사용하도록 구성된 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL 자체가 시스템 메모리 부족의 원인 인 경우 구성을 변경하여 문제를 피할 수 있습니다. 경우에 따라 메모리 관련 구성 매개 변수, 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt; 을 낮추는 데 도움이 될 수 있습니다 . 다른 경우에는 데이터베이스 서버 자체에 너무 많은 연결을 허용하여 문제점이 발생할 수 있습니다. 대부분의 경우 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt; 를 줄이고 대신 외부 연결 풀링 소프트웨어를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL을 LDAP 클라이언트 라이브러리로 OpenLDAP와 함께 컴파일 한 경우 &lt;code&gt;ldapserver&lt;/code&gt; 설정을 생략 할 수 있습니다. 이 경우 호스트 이름 및 포트 목록은 RFC 2782 DNS SRV 레코드를 통해 조회됩니다. &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; 이름 이 조회되며 여기서 &lt;code&gt;DOMAIN&lt;/code&gt; 은 &lt;code&gt;ldapbasedn&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">SELinux가 사용 불가능하거나 설치되지 않은 경우이 모듈을 설치하기 전에 해당 제품을 먼저 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">경우 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE의&lt;/a&gt; 명령이 실행되는 기본 백업이 수행되고, 다음이있는 템플릿 데이터베이스 동안 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 기본 백업이 진행되는 동안 수정 복사, 회복이 그 수정이에 전파하게됩니다 가능성이 있습니다 데이터베이스도 만들었습니다. 이것은 물론 바람직하지 않습니다. 이 위험을 피하려면 기본 백업을 수행하는 동안 템플릿 데이터베이스를 수정하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">경우 &lt;code&gt;DROP&lt;/code&gt; 의 명령 목록을 여러 개체, &lt;code&gt;CASCADE&lt;/code&gt; 는 오직 지정된 그룹 외부 의존성이있을 때 필요합니다. 말을 할 때 예를 들어, &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; 참조하는 외래 키의 존재 &lt;code&gt;tab1&lt;/code&gt; 에서 &lt;code&gt;tab2&lt;/code&gt; 것을 의미하지 않을 &lt;code&gt;CASCADE&lt;/code&gt; 가 성공하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절을 함수에 연결되어, 다음의 효과 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 같은 변수에 대한 함수 내에서 실행 된 명령은 기능 제한됩니다 : 구성 매개 변수의 이전 값이 여전히 기능 출구에서 복원됩니다. 그러나 &lt;code&gt;LOCAL&lt;/code&gt; 이 없는 일반 &lt;code&gt;SET&lt;/code&gt; 명령 은 이전 &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 에서와 마찬가지로 &lt;code&gt;SET&lt;/code&gt; 절을 재정의합니다 . 이러한 명령의 효과는 현재 트랜잭션이 롤백되지 않는 한 함수 종료 후에도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절이 절차에 연결되어, 그 절차는 (예를 들어, 트랜잭션 제어 문을 실행할 수 없습니다 &lt;code&gt;COMMIT&lt;/code&gt; 및 &lt;code&gt;ROLLBACK&lt;/code&gt; 언어에 따라).</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절이 절차에 연결되어, 다음의 효과 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 같은 변수에 대한 절차 내에서 실행 된 명령은 절차에 제한 : 구성 매개 변수의 이전 값이 여전히 절차 종료에 복원됩니다. 그러나 &lt;code&gt;LOCAL&lt;/code&gt; 이 없는 일반 &lt;code&gt;SET&lt;/code&gt; 명령 은 이전 &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 과 마찬가지로 &lt;code&gt;SET&lt;/code&gt; 절을 재정의합니다 . 이러한 명령의 효과는 현재 트랜잭션이 롤백되지 않는 한 프로 시저 종료 후에도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">점검 제한 조건 인 경우 표현식의 내부 표현입니다. 검사 제한 조건의 정의를 추출 하려면 &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">부모 테이블의 열이 ID 열이면 해당 속성이 상속되지 않습니다. 원하는 경우 자식 테이블의 열을 ID 열로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">열 목록이 지정되면 나열된 열에 대한 &lt;code&gt;INSERT&lt;/code&gt; 권한 만 필요합니다 . 마찬가지로 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가 지정되면 업데이트 된 것으로 나열된 열에 대한 &lt;code&gt;UPDATE&lt;/code&gt; 권한 만 필요합니다 . 그러나 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 에는 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 표현식 또는 &lt;code&gt;condition&lt;/code&gt; 에서 값을 읽는 모든 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 특권 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">열 결과가 NULL이면 해당 변수가 설정되지 않고 설정되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">열의 XPath 표현식이 XML 이외의 값 (XPath 1.0에서 string, boolean 또는 double로 제한됨)을 리턴하고 열에 &lt;code&gt;xml&lt;/code&gt; 이외의 PostgreSQL 유형 이있는 경우, 값의 문자열 표시를 다음과 같이 지정하여 열이 설정됩니다. PostgreSQL 유형. (값이 부울 인 경우 출력 열의 유형 범주가 숫자 &lt;code&gt;true&lt;/code&gt; 문자열 표현이 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 으로 , 그렇지 않으면 true 또는 &lt;code&gt;false&lt;/code&gt; 로 설정 됩니다.)</target>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">열의 XPath 표현식이 비어 있지 않은 XML 노드 세트를 리턴하고 열의 PostgreSQL 유형이 &lt;code&gt;xml&lt;/code&gt; 인 경우, 열이 문서 또는 컨텐츠 양식 인 경우 표현식 결과가 정확하게 지정됩니다. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">커밋되지 않은 트랜잭션에 의해 충돌하는 행이 삽입 된 경우 해당 삽입 기는 해당 트랜잭션이 커밋되는지 확인해야합니다. 롤백되면 충돌이 없습니다. 충돌하는 행을 다시 삭제하지 않고 커밋하면 고유성 위반이 있습니다. (실제로 다른 트랜잭션이 종료 될 때까지 기다린 다음 가시성 체크인을 다시 실행하십시오.)</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">충돌하는 유효한 행이 현재 트랜잭션에 의해 삭제 되었다면 괜찮습니다. 특히, UPDATE는 새 버전을 삽입하기 전에 항상 이전 행 버전을 삭제하므로 키를 변경하지 않고 행에서 UPDATE를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">제한 조건을 연기 할 수있는 경우이 절은 제한 조건을 점검하는 기본 시간을 지정합니다. 제한 조건이 &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; 인 경우 각 명령문 다음에 점검됩니다. 이것이 기본값입니다. 제한 조건이 &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; 인 경우 트랜잭션이 끝날 때만 점검됩니다. 제약 조건 확인 시간은 &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; 명령 으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">제한 조건 이름이 제공되면 제한 조건 이름과 일치하도록 색인 이름이 변경됩니다. 그렇지 않으면 제약 조건의 이름이 색인과 동일하게 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">저장 점이 나중에 롤백 된 후 커서가 닫히면 &lt;code&gt;CLOSE&lt;/code&gt; 는 롤백되지 않습니다. 즉, 커서는 닫힌 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">백 슬래시와 다른 이스케이프 문자가 필요한 경우 문자열 뒤에 &lt;code&gt;UESCAPE&lt;/code&gt; 절을 사용하여 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">동적으로로드 가능한 모듈을 열어야하고 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 또는 &lt;code&gt;LOAD&lt;/code&gt; 명령에 지정된 파일 이름 에 디렉토리 구성 요소가없는 경우 (즉, 이름에 슬래시가 포함되지 않은 경우) 시스템은이 경로에서 필요한 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">외래 키인 경우 FK = FK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">외래 키인 경우 PK = FK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">외래 키인 경우 PK = PK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">외래 키인 경우 참조 된 열 목록</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">외래 키인 경우 참조 테이블 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">소수 값이 단위로 지정되면 다음 작은 단위가 여러 개인 경우 반올림됩니다. 예를 들어, &lt;code&gt;30.1 GB&lt;/code&gt; 는 변환됩니다 &lt;code&gt;30822 MB&lt;/code&gt; 하지 &lt;code&gt;32319628902 B&lt;/code&gt; . 매개 변수가 정수 유형 인 경우, 단위 변환 후 정수로의 마지막 반올림이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">병렬 작업자 내에서 실행 된 함수가 리더에서 보유하지 않은 잠금 (예 : 쿼리에서 참조되지 않은 테이블을 쿼리)을 획득하면 해당 잠금은 트랜잭션 종료가 아닌 작업자 종료시 해제됩니다. 이를 수행하는 함수를 작성하고이 동작 차이가 중요한 경우 해당 함수를 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 로 표시 하여 리더에서만 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">함수가 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 와 함께 &lt;code&gt;STRICT&lt;/code&gt; 로 선언 되면 엄격 검사는 가변 배열 &lt;em&gt;이 전체적으로&lt;/em&gt; 널이 아닌지 테스트합니다 . 배열에 null 요소가 있으면 함수가 계속 호출됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">&lt;code&gt;VARIADIC&lt;/code&gt; 배열 매개 변수를 사용하여 함수를 선언 하고 호출에서 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 사용하지 않는 경우 함수는 배열 매개 변수가 호출과 일치하는 데 필요한 요소 유형의 하나 이상으로 대체 된 것처럼 처리됩니다. 이러한 확장 후 함수는 가변적이지 않은 함수와 동일한 효과적인 인수 유형을 가질 수 있습니다. 이 경우 검색 경로에서 이전에 나타나는 함수가 사용되거나 두 함수가 동일한 스키마에 있으면 비 변형적인 것이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">일반 계획을 사용중인 경우 매개 변수 기호 &lt;code&gt;$n&lt;/code&gt; 이 포함 되고 사용자 정의 계획에는 제공된 매개 변수 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">호스트 이름이 지정되면 (IP 주소 범위가 아니거나 특수 키워드가 호스트 이름으로 취급되는 경우) 해당 이름은 클라이언트 IP 주소의 역 이름 확인 결과 (예 : 역 DNS)와 비교됩니다 DNS를 사용하는 경우 조회). 호스트 이름 비교는 대소 문자를 구분하지 않습니다. 일치하는 경우 호스트 이름에 대해 정방향 이름 확인 (예 : 정방향 DNS 조회)을 수행하여 확인 된 주소 중 하나가 클라이언트의 IP 주소와 같은지 확인합니다. 두 방향이 일치하면 항목이 일치하는 것으로 간주됩니다. ( &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서 사용되는 호스트 이름클라이언트의 IP 주소의 주소 대 이름 확인이 반환되는 이름이어야합니다. 그렇지 않으면 행이 일치하지 않습니다. 일부 호스트 이름 데이터베이스에서는 IP 주소를 여러 호스트 이름과 연결할 수 있지만 운영 체제는 IP 주소를 확인하라는 메시지가 표시 될 때 하나의 호스트 이름 만 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">제한 개수를 지정하면 그보다 많은 행이 반환되지 않습니다 (단, 쿼리 자체가 더 적은 행을 생성하는 경우 더 적음). &lt;code&gt;LIMIT ALL&lt;/code&gt; 은 &lt;code&gt;LIMIT&lt;/code&gt; 절 을 생략하는 것과 동일 하며 NULL 인수를 갖는 &lt;code&gt;LIMIT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">행 번호가 지정되면 psql은 커서를 파일 또는 조회 버퍼의 지정된 행에 위치시킵니다. 하나의 모든 자릿수 인수가 제공되면 psql은 파일 이름이 아니라 행 번호라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">행 번호가 지정되면, psql은 함수 본문의 지정된 행에 커서를 위치시킵니다. 함수 본문은 일반적으로 파일의 첫 번째 줄에서 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">라인 번호가 지정되면 psql은 뷰 정의의 지정된 라인에 커서를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">열 목록이 지정된 경우 &lt;code&gt;COPY&lt;/code&gt; 는 지정된 열의 데이터 만 파일에서 또는 파일로 복사합니다. 테이블에 열 목록에없는 열이 있으면 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 해당 열의 기본값을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">새 자식 노드를 추가해야하는 경우 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgAddNode&lt;/code&gt; 로 설정 하십시오 . 집합 &lt;code&gt;nodeLabel&lt;/code&gt; 라벨에 새로운 노드를 사용하고, 설정되는 &lt;code&gt;nodeN&lt;/code&gt; 를 노드 어레이에서의 노드를 삽입하는 (제로)에서 인덱스로. 노드가 추가되면 수정 된 내부 튜플과 함께 &lt;code&gt;choose&lt;/code&gt; 함수가 다시 호출됩니다. 이 호출은 &lt;code&gt;spgMatchNode&lt;/code&gt; 결과를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">고유 인덱스의 고유성 위반과 같은 인덱스를 재 구축하는 동안 문제가 발생하면 &lt;code&gt;REINDEX&lt;/code&gt; 명령이 실패하지만 기존 인덱스 외에 &quot;잘못된&quot;새 인덱스가 남습니다. 이 인덱스는 불완전 할 수 있으므로 쿼리 목적으로 무시됩니다. 그러나 여전히 업데이트 오버 헤드를 소비합니다. psql &lt;code&gt;\d&lt;/code&gt; 명령은 &lt;code&gt;INVALID&lt;/code&gt; 와 같은 색인을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">교착 상태 또는 고유 인덱스의 고유성 위반과 같은 테이블을 스캔하는 동안 문제가 발생하면 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령이 실패하지만 &quot;유효하지 않은&quot;인덱스는 남겨 둡니다. 이 인덱스는 불완전 할 수 있으므로 쿼리 목적으로 무시됩니다. 그러나 여전히 업데이트 오버 헤드를 소비합니다. psql &lt;code&gt;\d&lt;/code&gt; 명령은 &lt;code&gt;INVALID&lt;/code&gt; 와 같은 색인을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">이와 같은 문제가 발생하면 영향을받는 데이터 정렬을 사용하여 정렬 된 각 개별 인덱스에 영향을 미치지 않을 수 있습니다. 단순히 &lt;em&gt;인덱스 된&lt;/em&gt; 값이 동작 불일치에 관계없이 동일한 절대 순서를 가질 수 있기 때문 입니다. PostgreSQL이 운영 체제 로캘 및 데이터 정렬을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;locale&quot;&gt;23.1 절&lt;/a&gt; 및 &lt;a href=&quot;collation&quot;&gt;23.2 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">쿼리에 집계 함수 호출이 포함되어 있지만 &lt;code&gt;GROUP BY&lt;/code&gt; 절이없는 경우 그룹화는 여전히 발생합니다. 결과는 단일 그룹 행이거나 단일 행이 &lt;code&gt;HAVING&lt;/code&gt; 에 의해 제거되는 경우 행이 전혀 없습니다 . 집계 함수 호출이나 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없어도 &lt;code&gt;HAVING&lt;/code&gt; 절이 포함 된 경우 에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">그렇게 할 것으로 예상되는 쿼리가 병렬 계획을 생성하지 않으면 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost를&lt;/a&gt; 줄일 수 있습니다 . 물론,이 계획은 플래너가 선호하는 일련 계획보다 느릴 수 있지만 항상 그런 것은 아닙니다. 이러한 설정 값이 매우 작은 경우에도 병렬 계획을 얻지 못한 경우 (예 : 둘 다 0으로 설정 한 후) 쿼리 플래너가 쿼리에 대한 병렬 계획을 생성 할 수없는 이유가있을 수 있습니다. 왜 그런지에 대한 정보는 &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;15.2 절&lt;/a&gt; 과 &lt;a href=&quot;parallel-safety&quot;&gt;15.4 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">쿼리 결과가 화면에 맞지 않으면이 명령을 통해 파이프됩니다. 일반적인 값은 &lt;code&gt;more&lt;/code&gt; 또는 &lt;code&gt;less&lt;/code&gt; . &lt;code&gt;PSQL_PAGER&lt;/code&gt; 또는 &lt;code&gt;PAGER&lt;/code&gt; 를 빈 문자열 로 설정 하거나 &lt;code&gt;\pset&lt;/code&gt; 명령 의 호출기 관련 옵션을 조정하여 호출기를 사용하지 않도록 설정할 수 있습니다 . 이러한 변수는 나열된 순서대로 검사됩니다. 설정된 첫 번째가 사용됩니다. 설정되지 않은 경우 기본값은 대부분의 플랫폼에서 &lt;code&gt;more&lt;/code&gt; 사용 하지만 Cygwin 에서는 &lt;code&gt;less&lt;/code&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 제공되면 (예 : &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ) 집계 함수가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">스키마 이름이 지정되면 (예 : &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ) 지정된 도메인에 도메인이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 도메인 이름은 스키마에 존재하는 유형과 도메인 중에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">스키마 이름이 지정되면 (예 : &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ) 지정된 테이블에 테이블이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 외부 테이블의 이름은 동일한 스키마에서 다른 외부 테이블, 테이블, 시퀀스, 인덱스, 뷰 또는 구체화 된 뷰의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">스키마 이름이 제공되면 (예 : &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ) 통계 오브젝트가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 통계 오브젝트의 이름은 동일한 스키마에있는 다른 통계 오브젝트의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정된 경우 (예 : &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ) 지정된 스키마에 테이블이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 테이블은 특수 스키마에 존재하므로 임시 테이블을 작성할 때 스키마 이름을 지정할 수 없습니다. 테이블 이름은 동일한 스키마에서 다른 테이블, 시퀀스, 인덱스, 뷰 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정된 경우 (예 : &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; )보기가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 뷰는 특수 스키마에 존재하므로 임시 뷰를 생성 할 때 스키마 이름을 지정할 수 없습니다. 뷰 이름은 동일한 스키마에서 다른 뷰, 테이블, 시퀀스, 인덱스 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에서 연산자 클래스가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 동일한 스키마에있는 두 개의 연산자 클래스는 다른 색인 메소드에 대해서만 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에 운영자 패밀리가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 동일한 스키마에있는 두 개의 연산자 제품군은 서로 다른 색인 메소드에 대해서만 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에서 시퀀스가 ​​작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 시퀀스는 특수 스키마에 존재하므로 임시 시퀀스를 만들 때 스키마 이름을 지정할 수 없습니다. 시퀀스 이름은 동일한 스키마에서 다른 시퀀스, 테이블, 인덱스, 뷰 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 구성이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 사전이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에 텍스트 검색 구문 분석기가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 템플리트가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에서 유형이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 유형 이름은 동일한 스키마의 기존 유형 또는 도메인 이름과 달라야합니다. (테이블에 연관된 데이터 유형이 있으므로 유형 이름도 동일한 스키마에있는 기존 테이블의 이름과 달라야합니다.)</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">스키마 이름이 포함 된 경우 지정된 스키마에 함수가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 새 함수의 이름은 동일한 스키마에서 동일한 입력 인수 유형을 가진 기존 함수 또는 프로 시저와 일치하지 않아야합니다. 그러나 다른 인수 유형의 함수 및 프로시 저는 이름을 공유 할 수 있습니다 (이를 &lt;em&gt;오버로딩&lt;/em&gt; 이라고 함 ).</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">스키마 이름이 포함 된 경우 지정된 스키마에서 프로 시저가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 새 프로 시저의 이름은 동일한 스키마에서 동일한 입력 인수 유형을 가진 기존 프로 시저 또는 함수와 일치하지 않아야합니다. 그러나 다른 인수 유형의 프로 시저 및 함수는 이름을 공유 할 수 있습니다 (이를 &lt;em&gt;오버로딩&lt;/em&gt; 이라고 함 ).</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">별도의 세션 키가 요청되면 새로운 임의의 키가 생성됩니다. 그렇지 않으면 S2K 키가 세션 키로 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">기본 매개 변수를 사용하여 시퀀스 오브젝트를 작성한 경우, 연속적인 &lt;code&gt;nextval&lt;/code&gt; 호출은 1로 시작하는 연속적인 값을 리턴합니다. &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 명령 에서 특수 매개 변수를 사용하여 다른 동작을 얻을 수 있습니다 . 자세한 내용은 해당 명령 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">구독이 복제 슬롯과 연결된 경우 트랜잭션 블록 내에서 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">수퍼 유저가 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 명령을 실행 하도록 선택한 경우 영향을받는 개체의 소유자가 명령을 실행 한 것처럼 명령이 수행됩니다. 특히, 이러한 명령을 통해 부여 된 권한은 개체 소유자가 부여한 것으로 나타납니다. (역할 멤버쉽의 경우 포함 역할 자체에서 멤버쉽을 부여한 것으로 보입니다.)</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">수퍼 유저가 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 명령을 실행 하도록 선택한 경우 영향을받는 개체의 소유자가 명령을 실행 한 것처럼 명령이 수행됩니다. 모든 권한은 궁극적으로 개체 소유자 (권한 부여 옵션 체인을 통해 간접적으로)에서 가져 오기 때문에 수퍼 유저는 모든 권한을 취소 할 수 있지만 위에서 설명한대로 &lt;code&gt;CASCADE&lt;/code&gt; 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">테이블 제약 조건 (외래 키는 포함하지만 제약 조건 트리거는 포함되지 않음) 인 경우 제약 된 열 목록</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">테이블에 하위 테이블이있는 경우 하위 테이블과 동일하게 수행하지 않고 상위 테이블의 열 유형을 추가, 이름 변경 또는 변경할 수 없습니다. 따라서 하위 항목에는 항상 상위 항목과 일치하는 열이 있습니다. 마찬가지로 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 모든 하위 항목에서 이름을 바꾸지 않고 부모에서 이름을 바꿀 수 없으므로 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건도 부모와 그 하위 항목 사이에서 일치합니다. (그러한 제한은 인덱스 기반 제한 조건에는 적용되지 않습니다.) 또한 상위 항목에서 선택하면 해당 하위 항목도 선택되므로 해당 하위 항목에도 유효한 것으로 표시되지 않으면 상위 제한 조건이 유효로 표시 될 수 없습니다. 이 경우 &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; 만 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">테이블이 &lt;code&gt;GROUP BY&lt;/code&gt; 를 사용하여 그룹화 되었지만 특정 그룹 만 관심이 있는 경우 &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사하게 &lt;code&gt;HAVING&lt;/code&gt; 절을 사용 하여 결과에서 그룹을 제거 할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">이러한 방식으로 테이블 스페이스를 재배치하면 기본 데이터 디렉토리 내의 기호 링크가 새 위치를 가리 키도록 업데이트됩니다. 따라서 새 데이터 디렉토리는 업데이트 된 위치에 모든 테이블 스페이스가있는 새 서버 인스턴스에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">이런 종류의 트랜잭션이 테이블의 데이터를 변경하려고 할 경우, 다음 사용해야 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 의 잠금 모드 대신에 &lt;code&gt;SHARE&lt;/code&gt; 의 모드. 이를 통해이 유형의 트랜잭션은 한 번에 하나만 실행됩니다. 이를 사용하지 않으면 교착 상태가 발생할 수 있습니다. 두 트랜잭션 모두 &lt;code&gt;SHARE&lt;/code&gt; 모드를 획득 한 다음 실제로 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드를 획득 하여 실제로 업데이트를 수행 할 수 없습니다 . 트랜잭션이 획득 할 수 있도록 (주 트랜잭션의 자신의 잠금 장치는 결코 충돌 것을 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 의 이 보유 할 때 모드를 &lt;code&gt;SHARE&lt;/code&gt; 의 모드 -하지만 다른 사람이 보유하지 않을 경우 &lt;code&gt;SHARE&lt;/code&gt; 를교착 상태를 피하려면 모든 트랜잭션이 동일한 오브젝트에서 동일한 순서로 잠금을 획득하고 단일 오브젝트에 대해 여러 잠금 모드가 관련된 경우 트랜잭션은 항상 가장 제한적인 모드를 먼저 획득해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">사용자에게 테이블이나 열에 대한 필요한 권한이없는 경우 대부분의 경우 쿼리에 권한 거부 오류가 발생하며이 경우이 메커니즘은 실제로 보이지 않습니다. 그러나 사용자가 보안 장벽보기에서 읽는 경우 플래너는 사용자가 액세스 할 수없는 기본 테이블의 통계를 확인할 수 있습니다. 이 경우, 작업자는 누출 방지 기능을 갖추어야합니다. 그렇지 않으면 통계가 사용되지 않습니다. 계획이 차선책 일 수 있다는 점을 제외하고는 이에 대한 직접적인 피드백은 없습니다. 이 경우에 해당되는 것으로 의심되면보다 권한있는 사용자로 쿼리를 실행하여 다른 계획의 결과를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">사용자가 권한 부여 옵션으로 권한을 보유하고 다른 사용자에게 권한을 부여한 경우 다른 사용자가 보유한 권한을 종속 권한이라고합니다. 첫 번째 사용자가 보유한 특권 또는 권한 부여 옵션이 취소되고 종속 특권이 존재하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 가 지정된 경우 해당 종속 특권도 취소됩니다 . 그렇지 않으면 취소 작업이 실패합니다. 이 재귀 취소는이 &lt;code&gt;REVOKE&lt;/code&gt; 명령 의 대상인 사용자에게 추적 가능한 사용자 체인을 통해 부여 된 권한에만 영향을줍니다 . 따라서 영향을받는 사용자는 다른 사용자를 통해서도 권한을 부여받은 경우 효과적으로 권한을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">0 바이트 ( &lt;code&gt;''&lt;/code&gt; )이면 생성 된 열이 아닙니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; = 저장됩니다. (나중에 다른 값이 추가 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">0 바이트 ( &lt;code&gt;''&lt;/code&gt; )이면 식별 열이 아닙니다. 그렇지 않으면 &lt;code&gt;a&lt;/code&gt; = 항상 생성되고 &lt;code&gt;d&lt;/code&gt; = 기본적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">모든 입력이 동일한 유형이고 &lt;code&gt;unknown&lt;/code&gt; 경우 해당 유형으로 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">모든 입력이 &lt;code&gt;unknown&lt;/code&gt; 유형 인 경우 유형 &lt;code&gt;text&lt;/code&gt; (문자열 범주의 기본 유형)로 확인하십시오. 그렇지 않으면 나머지 규칙의 목적으로 &lt;code&gt;unknown&lt;/code&gt; 입력이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">는 IF &lt;code&gt;ORDER BY&lt;/code&gt; 식이 출력 열 이름 입력 컬럼 이름이 모두 일치하는 간단한 이름은, &lt;code&gt;ORDER BY&lt;/code&gt; 는 출력 열 이름으로 해석된다. 이것은 같은 상황에서 &lt;code&gt;GROUP BY&lt;/code&gt; 가하는 선택과 반대입니다 . 이 불일치는 SQL 표준과 호환되도록 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">는 IF &lt;code&gt;existing_window_name&lt;/code&gt; 이 지정 그것은에서 이전 항목을 참조해야 &lt;code&gt;WINDOW&lt;/code&gt; 목록; 새 창은 해당 항목의 파티션 절과 순서 절 (있는 경우)을 복사합니다. 이 경우 새 창은 자체 &lt;code&gt;PARTITION BY&lt;/code&gt; 절을 지정할 수 없으며 , 복사 된 창에 &lt;code&gt;ORDER BY&lt;/code&gt; 가 없는 경우에만 ORDER BY를 지정할 수 있습니다 . 새 창은 항상 자체 프레임 절을 사용합니다. 복사 된 창은 프레임 절을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열 지정은 하나 이상의 쉼표로 구분 된 목록으로 구성되어야합니다 &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 쌍. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">기존 객체를 나타내지 않는 OID가 위 함수 중 하나에 인수로 전달되면 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">집계가 이동 집계 모드를 지원하는 경우 이동 프레임 시작이있는 창 (즉, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 이외의 프레임 시작 모드)에 대한 창 함수로 집계를 사용하면 계산 효율성이 향상됩니다.). 개념적으로, 순방향 전환 기능은 입력 값을 아래쪽에서 창 프레임으로 들어갈 때 집계 상태에 추가하고 역 이동 기능은 프레임을 맨 위에 놓을 때 다시 값을 제거합니다. 따라서 값을 제거하면 추가 된 순서대로 항상 제거됩니다. 역 전이 함수가 호출 될 때마다 가장 먼저 추가되었지만 아직 제거되지 않은 인수 값이 수신됩니다. 역 전이 함수는 가장 오래된 행을 제거한 후에도 하나 이상의 행이 현재 상태를 유지한다고 가정 할 수 있습니다. (그렇지 않으면 창 함수 메커니즘은 역 전이 함수를 사용하지 않고 단순히 새로운 집계를 시작합니다.)</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">선택 목록에서 임의의 값 표현식이 사용되면 개념적으로 리턴 된 테이블에 새 가상 컬럼을 추가합니다. 값 표현식은 각 결과 행에 대해 한 번 평가되며 행 값은 열 참조로 대체됩니다. 그러나 선택 목록의 표현식은 &lt;code&gt;FROM&lt;/code&gt; 절의 테이블 표현식에서 열을 참조 할 필요가 없습니다 . 예를 들어 상수 산술 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">자동으로 업데이트 가능한 뷰에 &lt;code&gt;WHERE&lt;/code&gt; 조건이 포함 된 경우 조건 은 뷰의 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 문으로 수정할 수있는 기본 관계의 행을 제한 합니다. 그러나 &lt;code&gt;UPDATE&lt;/code&gt; 는 행을 변경하여 더 이상 &lt;code&gt;WHERE&lt;/code&gt; 조건을 충족 시키지 않으므로 뷰를 통해 더 이상 표시되지 않습니다. 마찬가지로 &lt;code&gt;INSERT&lt;/code&gt; 명령은 &lt;code&gt;WHERE&lt;/code&gt; 조건을 충족하지 않아 뷰를 통해 볼 수 없는 기본 관계 행을 삽입 할 수 있습니다 ( &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 는 뷰를 통해 볼 수없는 기존 행에 유사하게 영향을 줄 수 있음). &lt;code&gt;CHECK OPTION&lt;/code&gt; 을 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 명령이 뷰를 통해 볼 수없는 행을 작성 하지 못하게하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">자동으로 업데이트 가능한보기가 &lt;code&gt;security_barrier&lt;/code&gt; 특성으로 표시되는 경우 모든보기의 &lt;code&gt;WHERE&lt;/code&gt; 조건 (및 &lt;code&gt;LEAKPROOF&lt;/code&gt; 로 표시된 연산자를 사용하는 모든 조건 )은 항상보기 사용자가 추가 한 조건보다 먼저 평가됩니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조 하십시오. 이로 인해 최종적으로 리턴되지 않는 행 (사용자의 &lt;code&gt;WHERE&lt;/code&gt; 조건을 전달하지 않기 때문에 )이 여전히 잠금 상태가 될 수 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 을 사용하여 관계 레벨에 적용되는 조건 (따라서 행을 잠그지 않음)과 그렇지 않은 조건을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">서버 시작시 이러한 파일에서 오류가 발견되면 서버 시작을 거부합니다. 그러나 구성을 다시로드하는 동안 오류가 감지되면 파일이 무시되고 이전 SSL 구성이 계속 사용됩니다. Windows 시스템에서이 파일의 오류가 백엔드 시작시 감지되면 해당 백엔드는 SSL 연결을 설정할 수 없습니다. 이 모든 경우에 오류 조건이 서버 로그에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">표준 시간대 약어 세트를 읽는 중에 오류가 발생하면 새 값이 적용되지 않고 이전 세트가 유지됩니다. 데이터베이스를 시작하는 동안 오류가 발생하면 시작이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">데이터베이스 스키마를 복원하는 동안 오류가 발생하면 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 종료되고 아래 &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;16 단계에&lt;/a&gt; 설명 된대로 이전 클러스터로 되돌려 야 합니다. &lt;code&gt;pg_upgrade&lt;/code&gt; 를 다시 시도하려면 pg_upgrade 스키마 복원이 성공하도록 이전 클러스터를 수정해야합니다. 문제가 &lt;code&gt;contrib&lt;/code&gt; 모듈 인 경우, 모듈을 사용하여 사용자 데이터를 저장하지 않는다고 가정하면 업그레이드 후 기존 클러스터에서 &lt;code&gt;contrib&lt;/code&gt; 모듈 을 설치 제거 하고 새 클러스터에 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">제외 제약 조건 인 경우 열별 제외 연산자 목록</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">표현식이 복합 유형 (행 유형)의 값을 생성하는 경우, 작성하여 행의 특정 필드를 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">식이 배열 유형의 값을 생성하면 다음을 작성하여 배열 값의 특정 요소를 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션으로 인덱스 빌드에 실패하면 이 인덱스는 &quot;유효하지 않은&quot;상태로 남습니다. 이러한 인덱스는 쓸모가 없지만 &lt;code&gt;REINDEX&lt;/code&gt; 를 사용 하여 다시 작성하는 것이 편리 할 수 ​​있습니다 . &lt;code&gt;REINDEX INDEX&lt;/code&gt; 만 유효하지 않은 인덱스에서 동시 빌드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">유효하지만 선택된 작동 모드와 관련이없는 옵션이 지정되면 pg_ctl은 해당 옵션을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">(가 인용되지 않은 경우 대장 &lt;code&gt;:&lt;/code&gt; )는 psql의 변수 이름 다음 인수 내에서 나타나는 바와 같이,이 변수의 값에 의해 대체된다 &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL 보간&lt;/a&gt; . 폼 &lt;code&gt;:'variable_name'&lt;/code&gt; 와 &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; 뿐만 아니라이 작품을 설명했다. &lt;code&gt;:{?variable_name}&lt;/code&gt; 구문은 변수가 정의되어 있는지 여부를 테스트 허용한다. TRUE 또는 FALSE로 대체됩니다. 백 슬래시로 콜론을 이스케이프하면 대체되지 않도록 보호합니다.</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">업스트림 대기 서버가 새 마스터로 승격 된 경우 &lt;code&gt;recovery_target_timeline&lt;/code&gt; 이 &lt;code&gt;'latest'&lt;/code&gt; (기본값)로 설정된 경우 다운 스트림 서버는 새 마스터에서 계속 스트리밍됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">차원이 슬라이스로 기록 된 경우, 즉 콜론을 포함하면 모든 차원이 슬라이스로 처리됩니다. 단일 숫자 (콜론 없음) 만있는 차원은 1에서 지정된 숫자까지 처리됩니다. 예를 들어,이 예에서와 같이 &lt;code&gt;[2]&lt;/code&gt; 는 &lt;code&gt;[1:2]&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">입력 인수가 도메인 유형 인 경우 모든 후속 단계에서 도메인의 기본 유형으로 간주하십시오. 이렇게하면 모호한 기능 해결을 위해 도메인이 기본 유형처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">입력 인수가 도메인 유형 인 경우 모든 후속 단계에서 도메인의 기본 유형으로 간주하십시오. 이를 통해 도메인은 모호한 운영자 해결을 위해 기본 유형처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">입력 인수를 &lt;code&gt;unknown&lt;/code&gt; 경우 나머지 후보가 해당 인수 위치에서 허용되는 유형 카테고리를 확인하십시오. 각 위치에서 &lt;code&gt;string&lt;/code&gt; 선택하십시오후보자가 해당 범주를 승인하면 범주. (알 수없는 유형의 리터럴이 문자열처럼 보이기 때문에 문자열에 대한이 편향이 적절합니다.) 그렇지 않은 경우 나머지 후보가 모두 동일한 유형 범주를 허용하면 해당 범주를 선택하십시오. 그렇지 않으면 더 많은 단서없이 올바른 선택을 추론 할 수 없으므로 실패합니다. 이제 선택한 유형 카테고리를 허용하지 않는 후보를 삭제하십시오. 또한, 후보가 해당 범주에서 선호되는 유형을 허용하는 경우 해당 인수에 대해 선호되지 않는 유형을 허용하는 후보를 삭제하십시오. 이 시험에서 생존하지 못하면 모든 응시자를 유지하십시오. 후보자가 하나만 남아 있으면 사용하십시오. 그렇지 않으면 다음 단계로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">입력 표현식에 명시 적 데이터 정렬 파생이있는 경우 입력 표현식에서 명시 적으로 파생 된 모든 데이터 정렬이 동일해야합니다. 그렇지 않으면 오류가 발생합니다. 명시 적으로 파생 된 데이터 정렬이 있으면 데이터 정렬 조합의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">입력이 도메인 유형 인 경우 모든 후속 단계에서 입력을 도메인의 기본 유형으로 취급하십시오. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">의 경우 &lt;code&gt;GROUPING SETS&lt;/code&gt; , &lt;code&gt;ROLLUP&lt;/code&gt; 이나 &lt;code&gt;CUBE&lt;/code&gt; 는 요소, 다음 그룹화로 존재 &lt;code&gt;GROUP BY&lt;/code&gt; 전체를 정의로 절 독립적 인 몇 개의 &lt;code&gt;grouping sets&lt;/code&gt; . 이 결과는 개별 그룹화 세트를 &lt;code&gt;GROUP BY&lt;/code&gt; 절로 사용하여 서브 쿼리간에 &lt;code&gt;UNION ALL&lt;/code&gt; 을 구성하는 것과 같습니다 . 그룹화 세트 처리에 대한 자세한 내용은 다음을 참조하십시오.&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt; 섹션 7.2.4를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">하위 테이블 중 하나가 외부 데이터 랩퍼가 지원하지 않는 외부 테이블 인 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 를 상속 통계를 수집하는 동안 해당 하위 테이블이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">테이블의 컬럼 중 하나가 TOAST 가능하면 테이블에 연관된 TOAST 테이블이 있으며 해당 테이블의 OID는 테이블의 &lt;code&gt;pg_class&lt;/code&gt; 에 저장됩니다 . &lt;code&gt;reltoastrelid&lt;/code&gt; 항목. 온 디스크 TOAST 값은 아래에 자세히 설명 된대로 TOAST 테이블에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">뷰가 참조하는 테이블 중 하나라도 임시 테이블 인 경우 뷰는 임시 뷰로 작성됩니다 ( &lt;code&gt;TEMPORARY&lt;/code&gt; 의 지정 여부 ).</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">업그레이드 후 처리가 필요한 경우 pg_upgrade는 완료 될 때 경고를 발행합니다. 또한 관리자가 실행해야하는 스크립트 파일을 생성합니다. 스크립트 파일은 업그레이드 후 처리가 필요한 각 데이터베이스에 연결됩니다. 각 스크립트는 다음을 사용하여 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">아카이브 스토리지 크기가 중요한 경우 gzip을 사용하여 아카이브 파일을 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">가능 하면 &lt;code&gt;SIGKILL&lt;/code&gt; 을 사용 하여 기본 &lt;code&gt;postgres&lt;/code&gt; 서버를 종료 &lt;em&gt;하지 마십시오&lt;/em&gt; . 그렇게하면 &lt;code&gt;postgres&lt;/code&gt; 가 종료하기 전에 보유하고있는 시스템 리소스 (예 : 공유 메모리 및 세마포어)를 해제 하지 못하게 됩니다. 이것은 새로운 &lt;code&gt;postgres&lt;/code&gt; 시작에 문제를 일으킬 수 있습니다 실행 .</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 가 모두 나타나면 반환 된 &lt;code&gt;LIMIT&lt;/code&gt; 행 수를 계산하기 전에 &lt;code&gt;OFFSET&lt;/code&gt; 행을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">표준 입력과 표준 출력이 모두 터미널 인 경우 psql은 클라이언트 인코딩을 &quot;auto&quot;로 설정하여 로케일 설정 ( 유닉스 시스템의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 환경 변수) 에서 적절한 클라이언트 인코딩을 감지합니다 . 예상대로 작동하지 않으면 환경 변수 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 을 사용하여 클라이언트 인코딩을 재정의 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">계단식 복제를 사용중인 경우 피드백이 결국 기본에 도달 할 때까지 업스트림으로 전달됩니다. 대기는 업스트림을 통과하는 것 이외의 다른 피드백을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">대 / 소문자를 구분하지 않는 일치를 지정하면 모든 대 / 소문자 구분이 알파벳에서 사라진 것처럼 효과가 나타납니다. 여러 경우에 존재하는 알파벳이 대괄호 표현식 외부의 일반 문자로 표시되면 두 경우를 모두 포함하는 대괄호 표현식으로 효과적으로 변환됩니다. 예를 들어 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;[xX]&lt;/code&gt; 가 됩니다. 대괄호 표현식 안에 나타나면 모든 대소 문자가 대괄호 표현식에 추가됩니다. 예를 들어 &lt;code&gt;[x]&lt;/code&gt; 는 &lt;code&gt;[xX]&lt;/code&gt; 가 되고 &lt;code&gt;[^x]&lt;/code&gt; 는 &lt;code&gt;[^xX]&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">열 별명이 제공되지 않으면 기본 데이터 유형을 리턴하는 함수의 경우 열 이름도 함수 이름과 동일합니다. 복합 유형을 리턴하는 함수의 경우 결과 열은 유형의 개별 속성 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">일관된 응답 시간이 업데이트 속도보다 중요한 경우 GIN 인덱스에 대한 &lt;code&gt;fastupdate&lt;/code&gt; 스토리지 매개 변수를 해제하여 보류중인 항목 사용을 비활성화 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">csvlog가 &lt;code&gt;log_destination&lt;/code&gt; 에 포함 된 경우 로그 항목은&amp;ldquo;쉼표로 구분 된 값&amp;rdquo;(CSV) 형식으로 출력되므로 프로그램에 로그를로드하는 데 편리합니다. 자세한 내용 &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;은 19.8.4 절&lt;/a&gt; 을 참조하십시오. CSV 형식의 로그 출력을 생성하려면 &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; 를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">데이터 체크섬이 활성화 된 경우 힌트 비트 업데이트는 항상 WAL로 기록되며이 설정은 무시됩니다. 데이터베이스에 데이터 체크섬이 활성화 된 경우이 설정을 사용하여 추가 WAL 로깅이 얼마나 발생하는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">어느 경우 &lt;code&gt;toptag&lt;/code&gt; 또는 &lt;code&gt;itemtag&lt;/code&gt; 가 빈 문자열, 관련 태그를 생략한다.</target>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">복구 중에 실행되면 &lt;code&gt;CHECKPOINT&lt;/code&gt; 명령은 새 검사 점을 작성하지 않고 다시 시작점 ( &lt;a href=&quot;wal-configuration&quot;&gt;29.4&lt;/a&gt; 참조)을 강제 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다. 기본값은 true이며 연결을 허용합니다 ( &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; 와 같은 다른 메커니즘에 의해 제한되는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다. &lt;code&gt;template0&lt;/code&gt; 데이터베이스가 변경되지 않도록 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">False 인 경우 인덱스가 삭제되는 중이므로 모든 용도 (HOT 안전 결정 포함)에서 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">실제 테이블에 컬럼이있는 것보다 적은 컬럼 별명이 지정되면 나머지 컬럼의 이름이 변경되지 않습니다. 이 구문은 자체 조인 또는 하위 쿼리에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">어떤 이유로 autovacuum이 테이블에서 오래된 XID를 지우지 못하는 경우 데이터베이스의 가장 오래된 XID가 랩 어라운드 지점에서 천만 건의 트랜잭션에 도달하면 시스템은 다음과 같은 경고 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">강제 색인 사용이 색인을 사용하는 경우 두 가지 가능성이 있습니다. 시스템이 올 바르고 색인을 사용하는 것이 실제로 적절하지 않거나 쿼리 계획의 비용 추정이 현실을 반영하지 않습니다. 따라서 인덱스를 사용하거나 사용하지 않고 쿼리 시간을 정해야합니다. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 명령은 여기에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">4 자리 또는 6 자리와 1 년을 이미 읽은 경우 시간 ( &lt;code&gt;HHMM&lt;/code&gt; 또는 &lt;code&gt;HHMMSS&lt;/code&gt; )으로 해석하십시오 .</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">주어진 경우, createuser는 새 사용자의 비밀번호를 묻는 프롬프트를 발행합니다. 비밀번호 인증을 사용하지 않으려는 경우에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">0보다 크면 열의 예상 고유 값 수입니다. 0보다 작은 경우 고유 값 수의 음수를 행 수로 나눈 값입니다. (거짓된 형식은 &lt;code&gt;ANALYZE&lt;/code&gt; 에서 테이블이 커짐에 따라 고유 한 값의 수가 증가 할 것으로 판단 할 때 사용되며, 양의 형식은 열에 고정 된 수의 가능한 값이있는 경우 사용됩니다.) 예를 들어, -1은 고유 값의 수가 행 수와 동일한 고유 열.</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">숫자를 인덱싱하는 경우 가능한 소수 범위를 줄이기 위해 일부 소수 자릿수를 제거 할 수 있으므로 소수점 이하 두 자리 만 유지하면 정규화 후에 &lt;em&gt;3.14&lt;/em&gt; 159265359, &lt;em&gt;3.14&lt;/em&gt; 15926, &lt;em&gt;3.14&lt;/em&gt; 가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">역 부분 줄 바꿈 구분 일치가 지정되면 이는 줄 바꿈 구분 일치와 같이 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 에 영향을 미치지 만 그렇지 않습니다 &lt;code&gt;.&lt;/code&gt; 및 괄호 표현식. 이것은 매우 유용하지는 않지만 대칭을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">비용 추정치가 잘못되었다는 것이 밝혀지면 다시 두 가지 가능성이 있습니다. 총 비용은 각 계획 노드의 행당 비용과 계획 노드의 선택성 추정값을 곱한 값으로 계산됩니다. 계획 노드에 대해 추정 된 비용은 런타임 매개 변수를 통해 조정할 수 있습니다 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;섹션 19.7.2 참조&lt;/a&gt; ). 부정확 한 선택성 추정은 불충분 한 통계로 인해 발생합니다. 통계 수집 매개 변수를 조정하여이를 개선 할 수 있습니다 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">위의 설명에 따라 로케일 지원이 작동하지 않으면 운영 체제의 로케일 지원이 올바르게 구성되어 있는지 확인하십시오. 시스템에 설치된 로케일을 확인하려면 운영 체제가 제공하는 경우 &lt;code&gt;locale -a&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">백업하는 경우 데이터베이스가 업데이트되고 있지 않은지 확인하십시오. 백업의 무결성에는 영향을 미치지 않지만 변경된 데이터는 포함되지 않습니다. 필요한 경우, &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; 파일 (또는 동등한 파일)에서 권한을 편집하여 귀하를 제외한 모든 사람이 액세스 할 수 없도록하십시오. 액세스 제어에 대한 추가 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">백업 파일을보다 유연하게 복사해야하는 경우 독립형 핫 백업에도 낮은 수준의 프로세스를 사용할 수 있습니다. 저수준 독립형 핫 백업을 준비하려면 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 이상으로 설정하고 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하고 &lt;em&gt;스위치 파일&lt;/em&gt; 이 존재 하는 경우에만 아카이브를 수행 하는 &lt;code&gt;archive_command&lt;/code&gt; 를 설정 &lt;em&gt;하십시오&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">하나 이상의 플래그 비트가 지정되면 변환이 나열된 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">둘 이상의 리프 튜플이 제공되는 경우 &lt;code&gt;picksplit&lt;/code&gt; 함수가이를 두 개 이상의 노드로 분류 할 것으로 예상 됩니다. 그렇지 않으면 리프 튜플을 여러 페이지에 분할 할 수 없으며이 작업의 최종 목적입니다. 따라서 &lt;code&gt;picksplit&lt;/code&gt; 함수가 모든 리프 튜플을 동일한 노드에 배치하면 코어 SP-GiST 코드는 해당 결정을 무시하고 리프 튜플이 동일한 레이블이 지정된 여러 노드에 무작위로 할당되는 내부 튜플을 생성합니다. 이러한 튜플은 &lt;code&gt;allTheSame&lt;/code&gt; 이 표시 되었음을 나타냅니다. 은 &lt;code&gt;choose&lt;/code&gt; 과 &lt;code&gt;inner_consistent&lt;/code&gt; 함수는 내부 튜플에 적절한주의를 기울여야합니다. 자세한 내용 &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3&lt;/a&gt;은 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">둘 이상의 옵션이 제공되면 정보는 한 줄에 한 항목 씩 순서대로 인쇄됩니다. 옵션이 제공되지 않으면 사용 가능한 모든 정보가 레이블과 함께 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">둘 이상의 테이블에 동일한 이름의 열이있는 경우 다음과 같이 테이블 이름도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">데이터베이스 서버에서 여러 CPU를 사용할 수있는 경우 pg_restore의 &lt;code&gt;--jobs&lt;/code&gt; 옵션 사용을 고려하십시오 . 이를 통해 동시 데이터로드 및 인덱스 생성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">단일 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에 여러 그룹화 항목이 지정된 경우 그룹화 세트의 최종 목록은 개별 항목의 교차 곱입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">여러 저장 점이 동일한 이름을 갖는 경우 가장 최근에 정의 된 저장 점이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">여러 스크립트 파일이 지정된 경우 평균은 각 스크립트 파일에 대해 별도로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">동일한 이벤트에 대해 동일한 종류의 트리거가 여러 개 정의되면 이름순으로 알파벳 순서대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 또는 &lt;code&gt;INSTEAD&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;ALSO&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;FOR SEARCH&lt;/code&gt; 또는 &lt;code&gt;FOR ORDER BY&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;FOR SEARCH&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">&lt;code&gt;FOR TABLE&lt;/code&gt; 또는 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 를 지정 하지 않으면 빈 테이블 집합으로 게시가 시작됩니다. 나중에 테이블을 추가 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">개행 구분 일치가 지정되면 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; 를 사용하는 대괄호 표현식 은 개행 문자와 절대 일치하지 않으므로 (RE가 명시 적으로 정렬하지 않으면 일치는 개행을 절대로 교차하지 않습니다) &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 는 개행 전후 각각의 빈 문자열과 일치합니다. 문자열. 그러나 ARE 이스케이프 &lt;code&gt;\A&lt;/code&gt; 및 &lt;code&gt;\Z&lt;/code&gt; 는 문자열의 시작 또는 끝과 &lt;em&gt;만&lt;/em&gt; 계속 일치 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">&lt;code&gt;table_alias&lt;/code&gt; 를 지정 하지 않으면 함수 이름이 테이블 이름으로 사용됩니다. (A)의 경우에는 &lt;code&gt;ROWS FROM()&lt;/code&gt; 구조체, 제 함수의 이름이 이용된다.</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 가 제공 되지 않으면 다음 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">데이터 정렬을 명시 적으로 지정하지 않으면 데이터베이스 시스템은 식에 포함 된 열에서 데이터 정렬을 파생 시키거나 식에 열이 포함되지 않은 경우 데이터베이스의 기본 데이터 정렬을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">기본값이 명시 적으로 선언되지 않은 경우 기본값은 널값입니다. 널값이 알 수없는 데이터를 나타내는 것으로 간주 될 수 있기 때문에 이는 일반적으로 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">정확히 일치하는 것이 없으면 함수 호출이 특수한 유형 변환 요청으로 나타나는지 확인하십시오. 함수 호출에 인수가 하나만 있고 함수 이름이 일부 데이터 유형의 (내부) 이름과 동일한 경우에 발생합니다. 또한 함수 인수는 알 수없는 형식 리터럴이거나 명명 된 데이터 형식에 이진 강제 형식이거나 해당 형식의 I / O 함수를 적용하여 명명 된 데이터 형식으로 변환 할 수있는 형식이어야합니다. 즉, 변환은 표준 문자열 유형 중 하나에서 또는 표준 문자열 유형으로 변환됩니다). 이러한 조건이 충족되면 함수 호출은 &lt;code&gt;CAST&lt;/code&gt; 스펙 의 형태로 처리됩니다 . &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">&lt;code&gt;to_char()&lt;/code&gt; 패턴에 사인을 명시 적으로 제공하지 않으면 사인을 위해 하나의 열이 예약되고 숫자에 고정됩니다 (왼쪽에 나타남). 경우 &lt;code&gt;S&lt;/code&gt; 는 그냥 왼쪽에 나타납니다 &lt;code&gt;9&lt;/code&gt; 의, 그것은 마찬가지로 숫자에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">함수를 지정하지 않으면 편집을 위해 빈 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 템플릿이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">잠금 모드를 지정하지 않으면 가장 제한적인 모드 인 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">이동 집계 구현이 제공되지 않으면 집계를 이동 프레임과 함께 계속 사용할 수 있지만 PostgreSQL은 프레임 시작이 이동할 때마다 전체 집계를 다시 계산합니다. 집계가 이동 집계 모드를 지원하는지 여부에 관계없이 PostgreSQL은 재 계산없이 이동 프레임 끝을 처리 할 수 ​​있습니다. 이는 집계 상태에 새 값을 계속 추가하여 수행됩니다. 이것이 창 함수로 집계를 사용하려면 최종 함수가 읽기 전용이어야합니다. 집계의 상태 값을 손상시키지 않아야하므로 한 세트의 집계 결과 값을 얻은 후에도 집계를 계속할 수 있습니다. 프레임 경계.</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 를 사용하여 출력 열 이름을 지정하지 않으면 시스템은 기본 열 이름을 지정합니다. 간단한 열 참조의 경우이 이름은 참조 된 열의 이름입니다. 함수 호출의 경우 함수 이름입니다. 복잡한 표현식의 경우 시스템은 일반 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">역할을 지정하지 않거나 특수 사용자 이름 &lt;code&gt;PUBLIC&lt;/code&gt; 을 사용하면 정책이 시스템의 모든 사용자에게 적용됩니다. 모든 사용자가 &lt;code&gt;users&lt;/code&gt; 테이블 에서 자신의 행에만 액세스 할 수 있도록 간단한 정책을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">여기에 동기 대기 이름을 지정하지 않으면 동기 복제를 사용할 수 없으며 트랜잭션 커밋이 복제를 기다리지 않습니다. 이것이 기본 구성입니다. 동기식 복제가 사용 가능하더라도 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 매개 변수를 &lt;code&gt;local&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 로 설정하여 복제를 기다리지 않도록 개별 트랜잭션을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">사용 가능한 테이블 이름이 없으면, 즉 쿼리 또는 커서를 매핑 할 때 문자열 &lt;code&gt;table&lt;/code&gt; 이 첫 번째 형식으로 사용되며 두 번째 형식으로 &lt;code&gt;row&lt;/code&gt; 이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">힙에서 삭제 된 튜플이없는 경우 다음 조건 중 하나 이상이 충족 될 때 &lt;code&gt;VACUUM&lt;/code&gt; 정리 단계 에서 B- 트리 인덱스가 계속 스캔됩니다 . 인덱스 통계가 오래되었거나 인덱스에 정리 중에 재활용 할 수있는 삭제 된 페이지가 포함되어 있습니다. . 새로 삽입 된 튜플의 수가 이전 통계 콜렉션에서 감지 한 총 힙 튜플 수의 &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; 비율을 초과하면 인덱스 통계는 오래된 것으로 간주됩니다 . 총 힙 튜플 수는 인덱스 메타 페이지에 저장됩니다. &lt;code&gt;VACUUM&lt;/code&gt; 이 죽은 튜플을 찾을 때까지 메타 페이지에는이 데이터가 포함되지 않으므로 정리 단계에서 B- 트리 인덱스 스캔은 두 번째 및 후속 &lt;code&gt;VACUUM&lt;/code&gt; 인 경우에만 건너 뛸 수 있습니다. 사이클은 죽은 튜플을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">뷰를 지정하지 않으면 빈 &lt;code&gt;CREATE VIEW&lt;/code&gt; 템플릿이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">찾을 수없는 경우, 특별한 문자열 (예를 들어, 하나 같이 토큰을 일치하는 내부 테이블을 검색 &lt;code&gt;today&lt;/code&gt; ), 일 (예를 들어, &lt;code&gt;Thursday&lt;/code&gt; (예), 월 &lt;code&gt;January&lt;/code&gt; (예) 또는 노이즈 단어 &lt;code&gt;at&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">널이 아닌 경우이 항목을 적용 할 수없는 이유를 나타내는 오류 메시지</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">널이 아닌 경우,이 행을 처리 할 수없는 이유를 나타내는 오류 메시지</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">설정하면 오류가 발생하여 현재 세션이 종료됩니다. 기본적으로 이것은 FATAL 오류만으로 세션을 종료하도록 off로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">켜져 있으면 WAL 관련 디버깅 출력을 내 보냅니다. 이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;WAL_DEBUG&lt;/code&gt; 매크로가 정의 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">켜져 있으면 경량 잠금 사용법에 대한 정보를 내 보냅니다. 경량 잠금 장치는 주로 공유 메모리 데이터 구조에 대한 액세스를 상호 배제하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">켜져 있으면 잠금 사용법에 대한 정보를 내 보냅니다. 덤프 된 정보에는 잠금 조작 유형, 잠금 유형 및 잠금 또는 잠금 해제중인 오브젝트의 고유 ID가 포함됩니다. 이 객체에 이미 부여 된 잠금 유형과이 객체에서 대기 한 잠금 유형에 대한 비트 마스크도 포함되어 있습니다. 각 잠금 유형에 대해 부여 된 잠금 및 대기 잠금의 수와 총계도 덤프됩니다. 로그 파일 출력의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">설정되어 있으면 정렬 작업 중에 리소스 사용량에 대한 정보를 내 보냅니다. 이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;TRACE_SORT&lt;/code&gt; 매크로가 정의 된 경우에만 사용 가능합니다 . 그러나 &lt;code&gt;TRACE_SORT&lt;/code&gt; 는 현재 기본적으로 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">설정하면 사용자 잠금 사용법에 대한 정보를 내 보냅니다. 출력은 권고 잠금의 경우에만 &lt;code&gt;trace_locks&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">이진 연산자 호출의 한 인수가 &lt;code&gt;unknown&lt;/code&gt; 유형이고 다른 인수가 도메인 유형 인 경우, 다음으로 도메인의 기본 유형을 정확하게 수락하는 연산자가 양쪽에 있는지 확인하십시오. 그렇다면 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">2 진 연산자 호출의 한 인수가 &lt;code&gt;unknown&lt;/code&gt; 유형 인 경우이 점검에 대한 다른 인수와 동일한 유형이라고 가정하십시오. 두 포함하는 호출이 &lt;code&gt;unknown&lt;/code&gt; 입력, 또는와 단항 연산자 &lt;code&gt;unknown&lt;/code&gt; 입력은이 단계에서 일치하는 항목을 찾을 수 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">비트 문자열 값을 &lt;code&gt;bit(n)&lt;/code&gt; 명시 적으로 캐스팅 하면 오른쪽에서 정확히 &lt;code&gt;n&lt;/code&gt; 비트가되도록 오류가 발생하지 않고 잘 리거나 0으로 채워집니다 . 마찬가지로 비트 문자열 값을 &lt;code&gt;bit varying(n)&lt;/code&gt; 으로 명시 적으로 캐스팅하는 경우 &lt;code&gt;n&lt;/code&gt; 비트 보다 크면 오른쪽에서 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">값을 &lt;code&gt;character varying(n)&lt;/code&gt; 또는 &lt;code&gt;character(n)&lt;/code&gt; 명시 적으로 캐스팅하면 길이를 초과하는 값은 오류없이 &lt;code&gt;n&lt;/code&gt; 문자 로 잘립니다 . (이 역시 SQL 표준에 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">목록 항목 중 하나가 특수 이름 &lt;code&gt;$user&lt;/code&gt; 인 경우, 해당 스키마가 있고 사용자에게 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 있으면 &lt;code&gt;CURRENT_USER&lt;/code&gt; 에 의해 리턴 된 이름을 가진 스키마 가 대체 됩니다. 그렇지 않으면 &lt;code&gt;$user&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">구문 분석기 만 지정된 경우 새 텍스트 검색 구성에는 처음에 토큰 유형에서 사전으로의 맵핑이 없으므로 모든 단어를 무시합니다. 후속 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 명령을 사용하여 구성을 유용하게하려면 맵핑을 작성해야합니다. 또는 기존 텍스트 검색 구성을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">부분 개행 구분 일치가 지정되면이 영향을 &lt;code&gt;.&lt;/code&gt; 줄 바꿈과 일치하지만 대괄호 표현식은 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">체크섬을 활성화 또는 비활성화하는 동안 pg_checksums가 중단되거나 종료되면 클러스터의 데이터 체크섬 구성은 변경되지 않고 pg_checksums를 다시 실행하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">처리하는 동안 pg_rewind가 실패하면 대상의 데이터 폴더가 복구 가능한 상태가 아닐 수 있습니다. 이 경우 새로운 백업을 새로 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">존재하는 경우 연산자 클래스는 해당 데이터 유형의 기본 연산자 클래스가됩니다. 특정 데이터 유형 및 색인 메소드에 대해 최대 하나의 연산자 클래스가 기본값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">커밋이 승인을 기다리는 동안 기본이 다시 시작되면 대기중인 트랜잭션은 기본 데이터베이스가 복구되면 완전히 커밋 된 것으로 표시됩니다. 기본 서버가 충돌 할 때 모든 대기가 모든 미해결 WAL 데이터를 수신했는지 확인할 방법이 없습니다. 일부 트랜잭션은 기본 트랜잭션에서 커밋 된 것으로 표시 되더라도 대기에서 커밋 된 것으로 표시되지 않을 수 있습니다. 우리가 제공하는 보증은 WAL 데이터가 모든 동기 대기에 의해 안전하게 수신 될 때까지 응용 프로그램이 트랜잭션의 성공적인 커밋에 대한 명시적인 승인을받지 못한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">쿼리가 수정되지 않고 브로드 캐스트 된 경우 &lt;code&gt;random()&lt;/code&gt; 과 같은 기능 , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 시퀀스는 서버마다 값이 다를 수 있습니다. 이는 각 서버가 독립적으로 작동하고 SQL 쿼리가 브로드 캐스트 (실제로 수정 된 행이 아님)이기 때문입니다. 이것이 허용되지 않는 경우, 미들웨어 또는 애플리케이션은 단일 서버에서 이러한 값을 조회 한 후 해당 값을 쓰기 조회에 사용해야합니다. 또 다른 옵션은이 복제 옵션을 기존 마스터 대기 설정과 함께 사용하는 것입니다. 즉, 데이터 수정 쿼리는 마스터로만 전송되고 복제 미들웨어가 아닌 마스터 대기 복제를 통해 대기 서버로 전파됩니다. 또한 2 단계 커밋 ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 및 &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED)을&lt;/a&gt; 사용하여 모든 트랜잭션이 모든 서버에서 커밋 또는 중단되도록주의해야합니다.). Pgpool-II 및 Continuous 텅스텐은 이러한 유형의 복제의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">복구에서 손상된 WAL 데이터를 찾으면 해당 시점에서 복구가 중지되고 서버가 시작되지 않습니다. 이러한 경우 복구 프로세스가 처음부터 다시 실행되어 손상 시점 이전에 &quot;복구 대상&quot;을 지정하여 복구가 정상적으로 완료 될 수 있습니다. 시스템 충돌과 같은 외부 이유로 인해 복구에 실패하거나 WAL 아카이브에 액세스 할 수없는 경우 복구를 다시 시작하면 거의 실패한 시점부터 다시 시작됩니다. 복구 다시 시작은 정상 작업의 검사 점과 매우 유사합니다. 서버는 주기적으로 모든 상태를 디스크로 강제 한 다음 &lt;code&gt;pg_control&lt;/code&gt; 파일을 업데이트 하여 이미 처리 된 WAL 데이터를 다시 검색 할 필요가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">백업에서 복원하는 경우 버전 별이 아닌 경우 이전 설치 디렉토리의 이름을 바꾸거나 삭제하십시오. 문제가 발생하여 되돌려 야하는 경우 디렉토리를 삭제하지 않고 이름을 바꾸는 것이 좋습니다. 디렉토리는 상당한 디스크 공간을 소비 할 수 있습니다. 디렉토리 이름을 바꾸려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">역할이 로그인 할 수있는 경우 역할이 만들 수있는 동시 연결 수를 지정합니다. -1 (기본값)은 제한이 없음을 의미합니다. 이 연결에는 일반 연결 만 계산됩니다. 준비된 트랜잭션이나 백그라운드 작업자 연결은이 제한에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">테이블에 대해 행 레벨 보안이 사용 가능하지만 적용 가능한 정책이없는 경우, &quot;기본 거부&quot;정책이 가정되므로 행이 표시되거나 갱신 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">테이블에 행 레벨 보안이 사용 가능한 경우 관련 &lt;code&gt;SELECT&lt;/code&gt; 정책이 &lt;code&gt;COPY table TO&lt;/code&gt; 문 에 적용됩니다 . 현재 &lt;code&gt;COPY FROM&lt;/code&gt; 은 행 레벨 보안이있는 테이블에 대해 지원되지 않습니다. 대신 동등한 &lt;code&gt;INSERT&lt;/code&gt; 문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">sysctl의 &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; 를 활성화하여 FreeBSD jails에서 실행하는 경우 , 다른 jail에서 실행되는 포스트 마스터는 다른 운영 체제 사용자가 실행해야합니다. 이는 루트가 아닌 사용자가 다른 감옥에서 공유 메모리 또는 세마포어를 방해하지 못하고 PostgreSQL IPC 정리 코드가 올바르게 작동 할 수있게하므로 보안을 향상시킵니다. (FreeBSD 6.0 이상에서 IPC 정리 코드는 다른 감옥에서 프로세스를 제대로 감지하지 않아서 다른 감옥의 동일한 포트에서 포스트 마스터가 실행되는 것을 방지합니다.)</target>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">0으로 설정하면 인증 된 사용자 프린시 펄의 영역 이름이 제거되어 사용자 이름 맵핑을 통과합니다 ( &lt;a href=&quot;auth-username-maps&quot;&gt;섹션 20.2&lt;/a&gt; ). &lt;code&gt;krb_realm&lt;/code&gt; 을 사용 하지 않으면 다중 영역 환경에서는 안전하지 않으므로 권장하지 않으며 주로 하위 호환성을 위해 사용 가능합니다. &lt;code&gt;include_realm&lt;/code&gt; 을 기본값 (1)으로 설정하고 주체 이름을 PostgreSQL 사용자 이름으로 변환하기 위해 &lt;code&gt;pg_ident.conf&lt;/code&gt; 에 명시 적 매핑을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">1 이하로 설정하면 psql의 대화식 세션 으로 EOF 문자 (보통 &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt; )를 보내면 응용 프로그램이 종료됩니다. 더 큰 숫자 값으로 설정하면 대화식 세션이 종료되도록 연속 된 많은 EOF 문자를 입력해야합니다. 변수가 숫자가 아닌 값으로 설정되면 10으로 해석됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">1로 설정하면 도메인의 SAM 호환 이름 (NetBIOS 이름이라고도 함)이 &lt;code&gt;include_realm&lt;/code&gt; 옵션에 사용됩니다. 이것이 기본값입니다. 0으로 설정하면 Kerberos 사용자 프린시 펄 이름의 실제 영역 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; 로 설정하면 비어 있지 않은 모든 입력 행을 읽을 때 표준 출력으로 인쇄됩니다. (대화식으로 읽은 행에는 적용되지 않습니다.) 프로그램 시작시이 동작을 선택하려면 스위치 &lt;code&gt;-a&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;queries&lt;/code&gt; 설정된 경우 psql은 서버로 전송 될 때 각 쿼리를 표준 출력으로 인쇄합니다. 이 동작을 선택하는 스위치는 &lt;code&gt;-e&lt;/code&gt; 입니다. &lt;code&gt;errors&lt;/code&gt; 로 설정되면 표준 오류 출력에 실패한 쿼리 만 표시됩니다. 이 동작의 스위치는 &lt;code&gt;-b&lt;/code&gt; 입니다. &lt;code&gt;none&lt;/code&gt; (기본값)으로 설정하면 쿼리가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; (기본값)으로 설정된 경우이 옵션을 사용하면 WAL 파일의 이름을 바꾸어 새 파일을 만들 필요없이 WAL 파일을 재활용 할 수 있습니다. COW 파일 시스템에서는 새 파일 시스템을 만드는 것이 더 빠를 수 있으므로이 동작을 비활성화하는 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">로 설정하면 &lt;code&gt;on&lt;/code&gt; (기본값)으로 경우이 옵션을 사용하면 새 WAL 파일이 0으로 채워집니다. 일부 파일 시스템에서는 WAL 레코드를 작성하기 전에 공간이 할당됩니다. 그러나 COW ( &lt;em&gt;Copy-On-Write&lt;/em&gt; ) 파일 시스템은이 기술의 이점을 얻지 못할 수 있으므로 불필요한 작업을 건너 뛰도록 옵션이 제공됩니다. &lt;code&gt;off&lt;/code&gt; 로 설정 되면 파일이 예상 크기를 갖도록 작성 될 때 최종 바이트 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">존재하지 않는 라이브러리로 설정하면 JIT를 사용할 수 없지만 오류는 발생하지 않습니다. 이를 통해 JIT 지원을 기본 PostgreSQL 패키지와 별도로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">on으로 설정하면 PostgreSQL이 대신 오류를보고하지만 나중에 검사 점에서 데이터 플러시 작업을 다시 시도 할 수 있도록 계속 실행됩니다. 후기 입 실패의 경우 운영 체제의 버퍼링 된 데이터 처리를 조사한 후에 만 ​​설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">설정된 경우이 OID 아래의 테이블에 대한 잠금을 추적하지 마십시오. (시스템 테이블에서 출력을 피하기 위해 사용)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">설정되면 교착 상태 시간 종료가 발생할 때 모든 현재 잠금에 대한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">설정된 경우 다양한 B- 트리 작업에서 시스템 리소스 사용 통계 (메모리 및 CPU)를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">설정된 경우 명령 줄에서 재정의하지 않는 한 만들 데이터베이스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">여러 개의 큰 테이블이 모두 짧은 시간 안에 진공 청소기로 청소할 수있게되면 모든 자동 진공 작업자가 해당 테이블을 오랫동안 진공 청소기로 청소할 수 있습니다. 이로 인해 작업자가 사용 가능해질 때까지 다른 테이블과 데이터베이스가 정리되지 않습니다. 단일 데이터베이스에있을 수있는 작업자 수에는 제한이 없지만 작업자는 다른 작업자가 이미 수행 한 반복 작업을 피하려고합니다. 실행중인 작업자 수는 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; 제한에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">동시 스냅 샷이 불가능한 경우 고정 된 모든 스냅 샷을 설정하기에 충분한 시간 동안 데이터베이스 서버를 종료하는 옵션이 있습니다. 또 다른 옵션은 백업 중 파일 시스템 변경에 영향을받지 않기 때문에 지속적인 아카이브 기반 백업 ( &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;25.3.2 절&lt;/a&gt; ) 을 수행하는 것 입니다. 이를 위해서는 백업 프로세스 중 지속적인 아카이브가 가능해야합니다. 지속적인 아카이브 복구 ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;25.3.4 절&lt;/a&gt; )를 사용하여 복구가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">특정 테이블의 이름이 잠금 절에 지정된 경우 해당 테이블에서 오는 행만 잠 깁니다. &lt;code&gt;SELECT&lt;/code&gt; 에 사용 된 다른 테이블 은 평상시처럼 읽습니다. 테이블 목록이없는 잠금 절은 명령문에 사용 된 모든 테이블에 영향을줍니다. 잠금 절이 뷰 또는 하위 쿼리에 적용되면 뷰 또는 하위 쿼리에 사용 된 모든 테이블에 영향을줍니다. 그러나 이러한 절은 기본 쿼리에서 참조하는 &lt;code&gt;WITH&lt;/code&gt; 쿼리 에는 적용되지 않습니다 . &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에서 행 잠금이 발생 하도록하려면 &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에 잠금 절을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">지정된 경우 시퀀스 오브젝트는이 세션에 대해서만 작성되며 세션 종료시 자동으로 삭제됩니다. 스키마 규정 이름으로 참조되지 않는 한 임시 시퀀스가 ​​존재하는 동안 동일한 이름의 기존 영구 시퀀스는이 세션에서 보이지 않습니다 (이 세션에서).</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">지정하면 테이블이 임시 테이블로 작성됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">지정하면 테이블이 임시 테이블로 작성됩니다. 임시 테이블은 세션이 끝날 때 또는 선택적으로 현재 트랜잭션이 끝날 때 자동으로 삭제됩니다 (아래의 &lt;code&gt;ON COMMIT&lt;/code&gt; 참조). 동일한 이름을 가진 기존 영구 테이블은 스키마 규정 이름으로 참조되지 않는 한 임시 테이블이 존재하는 동안 현재 세션에 표시되지 않습니다. 임시 테이블에서 생성 된 인덱스도 자동으로 임시입니다.</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">지정하면 테이블이 로그되지 않은 테이블로 작성됩니다. 기록되지 않은 테이블에 기록 된 데이터는 미리 기록 로그에 기록되지 않으므로 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;29 장&lt;/a&gt; 참조 ) 일반 테이블보다 훨씬 빠릅니다. 그러나 충돌 안전 상태는 아닙니다. 충돌 또는 부정확 한 종료 후에 로그되지 않은 테이블이 자동으로 잘립니다. 로깅되지 않은 테이블의 내용도 대기 서버로 복제되지 않습니다. 기록되지 않은 테이블에서 작성된 모든 색인도 자동으로 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">지정하면 테이블이 로그되지 않은 테이블로 작성됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">지정하면보기가 임시보기로 작성됩니다. 현재 세션이 끝나면 임시 뷰가 자동으로 삭제됩니다. 동일한 이름의 기존 영구 관계는 스키마 규정 이름으로 참조되지 않는 한 임시보기가 존재하는 동안 현재 세션에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">여전히 찾을 수 없으면 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">스트리밍 복제가 비활성화되면 일시 중지 된 상태가 문제없이 무한정 계속 될 수 있습니다. 스트리밍 복제가 진행되는 동안 WAL 레코드가 계속 수신되어 일시 중지 기간, WAL 생성 속도 및 사용 가능한 디스크 공간에 따라 사용 가능한 디스크 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">syslog가 궁극적으로 텍스트 파일에 로깅하는 경우 효과는 어느 쪽이든 동일하며 대부분의 syslog 구현은 큰 메시지를 처리 ​​할 수 ​​없거나 처리하도록 특별히 구성해야하므로 설정을 유지하는 것이 가장 좋습니다. 그러나 syslog가 궁극적으로 다른 매체에 쓰는 경우 메시지를 논리적으로 함께 유지하는 것이 필요하거나 더 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemd를 사용하는 경우 운영 체제에서 IPC 리소스 (공유 메모리 및 세마포어)를 조기에 제거하지 않도록주의해야합니다. 이것은 소스에서 PostgreSQL을 설치할 때 특히 중요합니다. 는 AS의 PostgreSQL 배포 패키지의 사용자는 영향을받을 가능성이 적습니다 &lt;code&gt;postgres&lt;/code&gt; 사용자가 다음 일반적으로 시스템 사용자로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">테이블이 파티션 인 경우 ( &lt;code&gt;relispartition&lt;/code&gt; 참조 ) 파티션의 내부 표현</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">주어진 오브젝트에 대해 &quot;액세스 권한&quot;열이 비어있는 경우, 오브젝트에 기본 권한이 있음을 의미합니다 (즉, 관련 시스템 카탈로그의 해당 권한 항목이 널임). 기본 권한은 항상 소유자에 대한 모든 권한을 포함하며 위에서 설명한대로 오브젝트 유형에 따라 &lt;code&gt;PUBLIC&lt;/code&gt; 에 대한 일부 권한을 포함 할 수 있습니다 . 객체 의 첫 번째 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 는 기본 권한을 인스턴스화합니다 (예 : &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; 생성).)을 지정한 다음 지정된 요청에 따라 수정하십시오. 마찬가지로 항목은 기본 권한이 아닌 열에 대해서만&amp;ldquo;열 권한&amp;rdquo;에 표시됩니다. (참고 :이 목적에서 &quot;기본 권한&quot;은 항상 개체 유형에 대한 기본 제공 기본 권한을 의미합니다. 권한이 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 명령의 영향을받은 개체 는 항상 효과가 포함 된 명시 적 권한 항목으로 표시됩니다. 의 &lt;code&gt;ALTER&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">경우 &lt;code&gt;--check&lt;/code&gt; 옵션을 사용, 기존의 클러스터는 수정되지 않은이었다; 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">경우 &lt;code&gt;--link&lt;/code&gt; 옵션이되었다 &lt;em&gt;없습니다&lt;/em&gt; 사용, 기존의 클러스터는 수정되지 않은이었다; 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">경우 &lt;code&gt;--link&lt;/code&gt; 옵션이 사용 된 데이터 파일은 이전과 새 클러스터간에 공유 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">경우 &lt;code&gt;DELETE&lt;/code&gt; 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절을, 결과는의 그것과 유사합니다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열과 값을 포함하는 문장 &lt;code&gt;RETURNING&lt;/code&gt; 행 (들)을 통해 계산 된 목록을 명령에 의해 삭제.</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;GROUP BY&lt;/code&gt; 절이 지정 집계 함수 호출이있는 경우, 또는, 출력은 하나 이상의 값 및 집계 함수의 결과에 일치 계산되는 행의 그룹으로 결합된다. &lt;code&gt;HAVING&lt;/code&gt; 절이 있으면 주어진 조건을 만족하지 않는 그룹을 제거합니다. (아래의 &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 조항&lt;/a&gt; 및 &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">경우] &lt;code&gt;INSERT&lt;/code&gt; 의 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절, 결과는 마찬가지 일 것이다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열 및 값 함유 문 &lt;code&gt;RETURNING&lt;/code&gt; 행 (들)을 통해 계산 된리스트에 삽입 또는 명령에 의해 갱신한다.</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;LIMIT&lt;/code&gt; (또는 &lt;code&gt;FETCH FIRST&lt;/code&gt; ) 또는 &lt;code&gt;OFFSET&lt;/code&gt; 절이 지정되면, &lt;code&gt;SELECT&lt;/code&gt; 문은 결과 행의 하위 집합을 반환합니다. (아래 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 조항&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;ORDER BY&lt;/code&gt; 절이 지정, 반환 된 행은 지정된 순서로 정렬됩니다. 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 가 지정되지, 행이 어떤 순서로 시스템의 발견 가장 빠른 생산에 반환됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">경우 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 의 명령이 어떤 이유로 실패, 그것은된다 &lt;code&gt;ROLLBACK&lt;/code&gt; : 현재 트랜잭션이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">경우 &lt;code&gt;PREPARE&lt;/code&gt; 문을 만든 문이 일부 매개 변수를 지정, 매개 변수의 호환 세트는 전달해야 &lt;code&gt;EXECUTE&lt;/code&gt; 문, 그렇지 않으면 오류가 발생합니다. (함수와 달리) 준비된 명령문은 매개 변수의 유형 또는 수에 따라 오버로드되지 않습니다. 준비된 명령문의 이름은 데이터베이스 세션 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">경우] &lt;code&gt;UPDATE&lt;/code&gt; 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절, 결과는 마찬가지 일 것이다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열 및 값 함유 문 &lt;code&gt;RETURNING&lt;/code&gt; 명령에 의해 갱신 된 행 (들)을 통해 계산 된리스트.</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">경우 &lt;code&gt;WHERE&lt;/code&gt; 의 절이 지정, 조건을 만족하지 않는 모든 행은 출력에서 제거됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">경우] &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 지정된 입력의 추가 열 &lt;code&gt;bigint&lt;/code&gt; 함수 결과 컬럼에 첨가한다. 이 열은 1부터 시작하여 함수 결과 집합의 행에 번호를 &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; (이것은 UNNEST ... WITH ORDINALITY에 대한 SQL 표준 구문의 일반화입니다 .) 기본적으로 서수 열은 &lt;code&gt;ordinality&lt;/code&gt; 라고 하지만 열 이름은 다릅니다 &lt;code&gt;AS&lt;/code&gt; 절을 사용하여 할당 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;count&lt;/code&gt; NULL로 표현 평가하여, 그것은으로 처리됩니다 &lt;code&gt;LIMIT ALL&lt;/code&gt; 즉, 제한 없음. &lt;code&gt;start&lt;/code&gt; 가 NULL로 평가 되면 &lt;code&gt;OFFSET 0&lt;/code&gt; 과 동일하게 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">경우 &lt;code&gt;dictionary&lt;/code&gt; 인수를 생략 텍스트는 사전 이름 검색 &lt;code&gt;unaccent&lt;/code&gt; 과 같은 스키마에 나타나는 &lt;code&gt;unaccent()&lt;/code&gt; 자체가 사용하는 기능.</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">는 IF &lt;code&gt;expression&lt;/code&gt; 행 값이며, 다음 &lt;code&gt;IS NULL&lt;/code&gt; 행 표현 자체가 null 인 경우 또는 사실이지만 모든 행의 필드는 null의 경우 &lt;code&gt;IS NOT NULL&lt;/code&gt; 는 행 식 자체가 null이며 모든 행의 필드는 때 사실이다 널이 아닙니다. 이 동작으로 인해 &lt;code&gt;IS NULL&lt;/code&gt; 및 &lt;code&gt;IS NOT NULL&lt;/code&gt; 이 행 값 식에 대해 항상 역 결과를 반환하지는 않습니다. 특히 null 필드와 null이 아닌 필드를 모두 포함하는 행 값 식은 두 테스트 모두에 대해 false를 반환합니다. 경우에 따라 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; 또는 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; 을 쓰는 것이 바람직 할 수 있습니다.행 필드에 대한 추가 테스트없이 전체 행 값이 null인지 간단히 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">는 IF &lt;code&gt;system-username&lt;/code&gt; 필드에 슬래시 (시작 &lt;code&gt;/&lt;/code&gt; ), 필드의 나머지는 정규 표현식으로 처리됩니다. ( PostgreSQL의 정규 표현식 구문에 대한 자세한 내용 &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;은 9.7.3.1 절을&lt;/a&gt; 참조하십시오 .) 정규 표현식에는 단일 캡처 또는 괄호로 묶인 하위 표현식이 포함될 수 있으며, &lt;code&gt;database-username&lt;/code&gt; 필드에서 &lt;code&gt;\1&lt;/code&gt; (백 슬래시-원) 으로 참조 될 수 있습니다 . 이를 통해 한 줄에 여러 사용자 이름을 매핑 할 수 있으며 이는 간단한 구문 대체에 특히 유용합니다. 예를 들어, 이러한 항목</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">상기 중간 &lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt; 와 &lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt; 어레이가 지정되며, &lt;em&gt;아머 헤더는&lt;/em&gt; 각각의 키 / 값 쌍에 대한 장갑 형태에 추가된다. 두 배열은 모두 1 차원이어야하며 길이는 같아야합니다. 키와 값은 ASCII가 아닌 문자를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">는 IF &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수가 지정이되어 &lt;code&gt;true&lt;/code&gt; 가치를,이 기능은 같은 오류 억제 &lt;code&gt;@?&lt;/code&gt; 그리고 &lt;code&gt;@@&lt;/code&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">경우] &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 인수가 지정되며, 그것은라는 변수를 포함하는 객체에 대입 될 제공 &lt;code&gt;jsonpath&lt;/code&gt; 의 발현.</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">S2K 키를 직접 사용하는 경우 S2K 설정 만 세션 키 패킷에 저장됩니다. 그렇지 않으면 세션 키가 S2K 키로 암호화되어 세션 키 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">일관된 데이터보기가 필요한 모든 쓰기 및 모든 읽기에 대해 직렬화 가능 트랜잭션 격리 레벨을 사용하는 경우 일관성을 유지하기 위해 다른 노력이 필요하지 않습니다. 일관성을 보장하기 위해 직렬화 가능 트랜잭션을 사용하도록 작성된 다른 환경의 소프트웨어는 PostgreSQL에서 이와 관련하여 &quot;작동&quot;해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">인수가 &lt;code&gt;|&lt;/code&gt; 그런 다음 행의 전체 나머지 를 실행 &lt;code&gt;command&lt;/code&gt; 으로 사용하고 변수 보간이나 백 따옴표 확장을 수행하지 않습니다. 나머지 줄은 문자 그대로 쉘로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">&lt;code&gt;json_strip_nulls&lt;/code&gt; 에 대한 인수가 임의의 오브젝트에 중복 필드 이름을 포함하는 경우, 결과의 순서에 따라 결과적으로 의미가 약간 다를 수 있습니다. 이에 대한 문제가되지 않습니다 &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; 때문에 &lt;code&gt;jsonb&lt;/code&gt; 의 값이 결코 중복 된 개체 필드 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">배열 표현식이 널 배열을 생성하면 &lt;code&gt;ALL&lt;/code&gt; 의 결과는 널이됩니다. 왼쪽 표현식이 널을 생성하는 경우 &lt;code&gt;ALL&lt;/code&gt; 의 결과 는 일반적으로 널입니다 (엄격하지 않은 비교 연산자는 다른 결과를 생성 할 수 있음). 또한 오른쪽 배열에 null 요소가 포함되어 있고 잘못된 비교 결과가 없으면 &lt;code&gt;ALL&lt;/code&gt; 의 결과는 true가 아닌 null이됩니다 (엄격한 비교 연산자를 가정 할 때). 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">배열 표현식이 널 배열을 생성하면 &lt;code&gt;ANY&lt;/code&gt; 의 결과는 널이됩니다. 왼쪽 표현식이 널을 생성하는 경우 &lt;code&gt;ANY&lt;/code&gt; 의 결과 는 일반적으로 널입니다 (엄격하지 않은 비교 연산자는 다른 결과를 생성 할 수 있음). 또한 오른쪽 배열에 null 요소가 포함되어 있고 실제 비교 결과를 얻지 못하면 &lt;code&gt;ANY&lt;/code&gt; 의 결과는 false가 아닌 null이됩니다 (엄격한 비교 연산자를 가정 할 때). 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">백업 프로세스가 백업에 필요한 모든 WAL 세그먼트 파일을 모니터링하고 성공적으로 아카이브 한 경우 &lt;code&gt;wait_for_archive&lt;/code&gt; 매개 변수 (기본값은 true)는 백업 중지 백업 레코드가 WAL에 기록되는 즉시 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 리턴 되도록 false로 설정 될 수 있습니다. . 기본적으로 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 모든 WAL이 보관 될 때까지 대기하며 시간이 다소 걸릴 수 있습니다. 이 옵션은주의해서 사용해야합니다. WAL 보관이 올바르게 모니터링되지 않으면 백업에 모든 WAL 파일이 포함되지 않을 수 있으므로 불완전하여 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">캐스트가 &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; 로 표시 되면 대상 데이터 유형의 열에 값을 지정할 때 내재적으로 호출 될 수 있습니다. 예를 들어, &lt;code&gt;foo.f1&lt;/code&gt; 이 &lt;code&gt;text&lt;/code&gt; 유형의 열 이라고 가정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">캐스트가 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 로 표시되면 할당이든 내부적 으로든 표현식에서 내재적으로 호출 할 수 있습니다. 일반적으로 이러한 유형의 캐스트를 설명하기 위해 &lt;em&gt;암시 적 캐스트&lt;/em&gt; 라는 용어를 사용합니다 . 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">카탈로그의 &lt;code&gt;.h&lt;/code&gt; 파일이 열의 기본값을 지정하고 데이터 항목의 값이 동일한 경우 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 은 데이터 파일에서이를 생략합니다. 이렇게하면 데이터 표현이 간결 해집니다.</target>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">클라이언트 문자 세트가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 로 정의 되면 서버의 문자 세트에 관계없이 인코딩 변환이 사용 불가능합니다. 서버 와 마찬가지로 모든 ASCII 데이터로 작업하지 않는 한 &lt;code&gt;SQL_ASCII&lt;/code&gt; 를 사용하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">명령이 &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; 로 작성되고 외부 테이블이 존재하지 않으면 오류가 발생하지 않습니다. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">명령이 0이 아닌 종료 상태를 리턴하면 경고 로그 메시지가 작성되고 데이터베이스는 어쨌든 시작됩니다. 예외는 명령에 의해 신호 또는 오류 (예 : 명령을 찾을 수 없음)로 종료 된 경우 데이터베이스가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">명령이 0이 아닌 종료 상태를 리턴하면 경고 로그 메시지가 작성됩니다. 단, 신호로 인해 명령이 종료되거나 쉘에 의해 오류 (예 : 명령을 찾을 수 없음)가 있으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">명령 자체에 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 포함 된 경우이 옵션은 원하는 효과를 갖지 않습니다. 또한 트랜잭션 블록 내에서 개별 명령을 실행할 수없는 경우이 옵션을 지정하면 전체 트랜잭션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">비교 된 값이 배열 가능한 데이터 유형 인 경우 표준 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 메커니즘을 사용하여 적절한 데이터 정렬 OID가 비교 지원 함수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">리프 항목에 대해 compress 메소드가 손실 된 경우 연산자 클래스는 색인 전용 스캔을 지원할 수 없으며 &lt;code&gt;fetch&lt;/code&gt; 함수를 정의하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">구성 파일에 구문 오류 또는 유효하지 않은 매개 변수 이름이 포함 된 경우 서버는 해당 설정을 적용하려고 시도하지 않으므로 &lt;code&gt;applied&lt;/code&gt; 모든 필드가 false로 읽 힙니다. 이러한 경우 문제를 나타내는 널이 아닌 &lt;code&gt;error&lt;/code&gt; 필드 가있는 하나 이상의 행이 있습니다 . 그렇지 않으면 가능하면 개별 설정이 적용됩니다. 개별 설정을 적용 할 수없는 경우 (예 : 유효하지 않은 값 또는 서버 시작 후 설정을 변경할 수없는 경우) &lt;code&gt;error&lt;/code&gt; 필드 에 적절한 메시지가 표시 됩니다. 항목이 &lt;code&gt;applied&lt;/code&gt; 되었을 수있는 다른 방법 = false는 동일한 매개 변수 이름에 대한 이후 항목으로 대체됩니다. 아무것도 나타나지 않습니다이 경우는 오류로 간주되지 않는 &lt;code&gt;error&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 가 &lt;code&gt;off&lt;/code&gt; 이면 PostgreSQL은 일반 및 이스케이프 문자열 상수에서 백 슬래시 이스케이프를 인식합니다. 그러나 PostgreSQL 9.1에서 기본값은 &lt;code&gt;on&lt;/code&gt; 이므로 백 슬래시 이스케이프는 이스케이프 문자열 상수에서만 인식됩니다. 이 동작은보다 표준을 준수하지만 백 슬래시 이스케이프가 항상 인식 된 이전 동작에 의존하는 응용 프로그램을 중단 할 수 있습니다. 이 문제를 해결하려면이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정할 수 있지만 백 슬래시 이스케이프를 사용하지 않는 것이 좋습니다. 특수 문자를 나타 내기 위해 백 슬래시 이스케이프를 사용해야하는 경우 문자열 상수를 &lt;code&gt;E&lt;/code&gt; 로 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">어떤 이유로 든 연결할 수없는 경우 (예 : 권한 부족, 대상 호스트에서 서버가 실행되지 않는 등) psql은 오류를 반환하고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">치명적이지 않은 오류로 연결이 끊어 지거나 초기에 설정할 수없는 경우 pg_receivewal은 연결을 무기한 재 시도하고 가능한 빨리 스트리밍을 다시 설정합니다. 이 동작을 피하려면 &lt;code&gt;-n&lt;/code&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">특정 문자의 변환이 불가능한 경우 - 사용자가 선택한 가정 &lt;code&gt;EUC_JP&lt;/code&gt; 를 서버와 대한 &lt;code&gt;LATIN1&lt;/code&gt; 클라이언트에 대한, 일부 일본어 문자에서 표현하지 않아도 반환되는 &lt;code&gt;LATIN1&lt;/code&gt; 를 - 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 다시 실행됩니다. 그 동작을 제외하고 , 인수가없는 &lt;code&gt;\g&lt;/code&gt; 는 기본적으로 세미콜론과 같습니다. 인수가 있는 &lt;code&gt;\g&lt;/code&gt; 는 &lt;code&gt;\o&lt;/code&gt; 명령 의 &quot;일회성&quot;대안 입니다.</target>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">현재 테이블 출력 형식이 정렬되지 않은 경우 정렬로 전환됩니다. 정렬되지 않은 경우 정렬되지 않은 것으로 설정됩니다. 이 명령은 이전 버전과의 호환성을 위해 유지됩니다. 보다 일반적인 해결책 은 &lt;code&gt;\pset&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">커서 조회에 &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 가 포함 된 경우, 이러한 옵션 을 사용하는 일반 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령과 같은 방식으로 리턴 된 행이 처음 페치 될 때 잠 깁니다 . 또한 반환 된 행은 최신 버전이됩니다. 따라서이 옵션은 SQL 표준이 &quot;민감한 커서&quot;라고 부르는 것과 동일합니다. &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 와 함께 &lt;code&gt;INSENSITIVE&lt;/code&gt; 를 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">데이터 디렉토리가 그룹 읽기 액세스를 허용하는 경우, 위에서 설명한 보안 요구 사항을 준수하기 위해 인증서 파일이 데이터 디렉토리 외부에 위치해야합니다. 일반적으로 권한이없는 사용자가 데이터베이스를 백업 할 수 있도록 그룹 액세스가 가능하며,이 경우 백업 소프트웨어는 인증서 파일을 읽을 수 없으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">데이터베이스가 비동기 커밋 트랜잭션의 WAL 기록의 작성과 위험 기간 동안 충돌하는 경우 트랜잭션이 중 다음 만든 변경됩니다 &lt;em&gt;것이다&lt;/em&gt; 손실. 백그라운드 프로세스 ( &quot;WAL 기록기&quot;)가 기록되지 않은 WAL 레코드를 &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; 밀리 초 마다 디스크로 플러시하기 때문에 위험 기간이 제한 됩니다. WAL 기록기는 사용량이 많은 기간 동안 한 번에 전체 페이지를 작성하도록 설계 되었기 때문에 위험 윈도우의 실제 최대 기간은 &lt;code&gt;wal_writer_delay&lt;/code&gt; 의 3 배 입니다.</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">리프 노드에 대해 거리 함수가 &lt;code&gt;*recheck = true&lt;/code&gt; 를 반환 하면 원래 순서 연산자의 반환 유형은 &lt;code&gt;float8&lt;/code&gt; 또는 &lt;code&gt;float4&lt;/code&gt; 여야하며 거리 함수의 결과 값은 원래 순서 연산자의 결과 값과 비교할 수 있어야합니다. 거리 함수 결과 및 재 계산 된 순서 연산자 결과. 그렇지 않으면 결과 값 의 상대 순서가 순서 연산자가 반환 한 순서와 일치하는 한 거리 함수의 결과 값은 임의의 &lt;code&gt;float8&lt;/code&gt; 값일 수 있습니다 . (무한 및 마이너스 무한대는 내부적으로 null과 같은 경우를 처리하는 데 사용되므로 &lt;code&gt;distance&lt;/code&gt; 함수가 이러한 값을 반환 하지 않는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">컬럼의 표현식이 올바른 데이터 유형이 아닌 경우 자동 유형 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">확장 이 제어 파일에 &lt;code&gt;schema&lt;/code&gt; 매개 변수를 지정하면 해당 스키마를 &lt;code&gt;SCHEMA&lt;/code&gt; 절로 대체 할 수 없습니다 . 일반적으로 &lt;code&gt;SCHEMA&lt;/code&gt; 절이 제공되고 확장의 &lt;code&gt;schema&lt;/code&gt; 매개 변수 와 충돌 하면 오류가 발생합니다 . 그러나 &lt;code&gt;CASCADE&lt;/code&gt; 절도 제공되면 &lt;code&gt;schema_name&lt;/code&gt; 은 충돌 할 때 무시됩니다. 주어진 &lt;code&gt;schema_name&lt;/code&gt; 은 제어 파일에 &lt;code&gt;schema&lt;/code&gt; 를 지정하지 않는 필요한 확장을 설치하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">파일 이름이 절대 경로가 아닌 경우 참조 구성 파일이 포함 된 디렉토리를 기준으로합니다. 포함은 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">최종 함수가 &quot;strict&quot;로 선언되면 종료 상태 값이 null 일 때 호출되지 않습니다. 대신 null 결과가 자동으로 반환됩니다. (물론 이것은 엄격한 함수의 정상적인 동작입니다.) 어쨌든 최종 함수에는 null 값을 반환하는 옵션이 있습니다. 예를 들어, 입력 행이없는 경우 &lt;code&gt;avg&lt;/code&gt; 의 최종 함수 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">첫 번째 인수가 인용되지 않은 &lt;code&gt;-n&lt;/code&gt; 이면 후행 줄 바꿈이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">함수가 &lt;code&gt;record&lt;/code&gt; 데이터 유형 을 리턴하는 것으로 정의 된 경우 별명 또는 키워드 &lt;code&gt;AS&lt;/code&gt; 가 있어야하고 양식 &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; 형식의 열 정의 목록이 있어야합니다 . 열 정의 목록은 함수가 반환 한 실제 열 수와 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">함수 이름이 스키마에서 고유 한 경우 인수 목록없이 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">인덱스 AM은 SQL 문 내에서 연속 인덱스 삽입에 걸쳐 데이터를 캐시에 원하는 경우에 공간을 할당 할 수 &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; 와의 데이터에 대한 포인터를 저장 &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (처음에 NULL이됩니다).</target>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">인덱스가 원래 인덱싱 된 데이터 값을 저장하고 손실이없는 경우 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;인덱스 전용 스캔&lt;/a&gt; 을 지원 하면 인덱스 튜플의 TID뿐만 아니라 실제 데이터 만 반환합니다. 가시성 맵에 TID가 모든 표시 가능한 페이지에있는 것으로 표시되는 경우에만 I / O를 피합니다. 그렇지 않으면 MVCC 가시성을 확인하기 위해 힙 튜플을 방문해야합니다. 그러나 그것은 액세스 방법에 대한 걱정이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">인덱스가 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;인덱스 전용 스캔을&lt;/a&gt; 지원하는 경우 (예 : &lt;code&gt;amcanreturn&lt;/code&gt; 이이를 리턴하면) 성공시 AM은 &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; 도 확인해야 하며 , true 인 경우 인덱스 항목에 대해 원래 인덱스 된 데이터를 리턴해야합니다. 데이터는 &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; 에 저장된 &lt;code&gt;IndexTuple&lt;/code&gt; 포인터 의 형식 으로 튜플 디스크립터 &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; ; 또는 tuple 디스크립터 &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; 와 함께 &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; 에 저장된 &lt;code&gt;HeapTuple&lt;/code&gt; 포인터 형태로 . 후자의 형식은 &lt;code&gt;IndexTuple&lt;/code&gt; 에 맞지 않는 데이터를 재구성 할 때 사용해야합니다..) 어느 경우 든 포인터가 참조하는 데이터 관리는 액세스 방법의 책임입니다. 다음 &lt;code&gt;amgettuple&lt;/code&gt; , &lt;code&gt;amrescan&lt;/code&gt; 또는 &lt;code&gt;amendscan&lt;/code&gt; 이 스캔을 호출 할 때까지 데이터는 양호하게 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">인덱싱 된 열이 배열 가능한 데이터 형식 인 경우 표준 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 메커니즘을 사용하여 인덱스 데이터 정렬이 모든 지원 방법으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">설치 프로세스가 오류없이 완료되면 이제 서버를 정상적으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">&lt;code&gt;box&lt;/code&gt; 의 내부 구조가 4 개의 &lt;code&gt;float4&lt;/code&gt; 요소 의 배열 인 경우 대신 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">분리 레벨, 읽기 / 쓰기 모드 또는 지연 가능 모드가 지정된 경우 새 트랜잭션은 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 이 실행 된 것처럼 이러한 특성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">검색 할 항목이 배열의 요소 인 경우 &lt;code&gt;[*]&lt;/code&gt; 연산자를 사용하여이 배열을 풀어야합니다 . 예를 들어 다음 경로는 사용 가능한 모든 트랙 세그먼트에 대한 위치 좌표를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">키가 해시 블록 크기보다 크면 먼저 해시되고 결과는 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">마지막 경로 항목이 객체 키인 경우 해당 키가 없으면 새 키가 제공됩니다. 마지막 경로 항목이 배열 인덱스 인 경우 양수인 경우 왼쪽부터 계산하여 설정할 항목을 찾고, 오른쪽부터 계산하여 음수 인 경우 &lt;code&gt;-1&lt;/code&gt; 지정하면 가장 오른쪽에있는 요소가 지정됩니다. 항목이 -array_length .. array_length -1 범위를 벗어나 있고 create_missing이 true 인 경우, 항목이 음수이면 배열의 시작 부분에 양수이면 배열의 끝에 새 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">수정 자 &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;중첩&amp;rdquo;)을 사용하거나 패턴을 지정하면 루트가 아닌 분할 관계가 포함되고 각 분할 관계의 부모를 표시하는 열이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">새 연결에 성공하면 이전 연결이 닫힙니다. 연결 시도가 실패한 경우 (잘못된 사용자 이름, 액세스 거부 등) psql이 대화식 모드 인 경우에만 이전 연결이 유지됩니다. 비 대화식 스크립트를 실행하면 처리가 즉시 오류와 함께 중지됩니다. 이 구별은 한편으로는 오타에 대한 사용자 편의성과 스크립트가 실수로 잘못된 데이터베이스에 작동하지 않는 안전 메커니즘으로 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">새 파티션이 외부 테이블 인 경우 외부 테이블의 모든 행이 파티션 제한 조건을 준수하는지 확인하기 위해 아무것도 수행되지 않습니다. 외부 테이블의 제한 조건에 대해서는 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">새 파티션이 일반 테이블 인 경우 테이블의 기존 행이 파티션 제한 조건을 위반하지 않는지 확인하기 위해 전체 테이블 스캔이 수행됩니다. 이 명령을 실행하기 전에 원하는 파티션 제한 조건을 만족시키는 행만 허용하는 테이블에 유효한 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건을 추가하여이 스캔을 피할 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 테이블이 파티션의 제약 조건을 검증하기 위해 스캔 할 필요가 없다는 것을 결정하는 데 사용됩니다. 그러나 파티션 키 중 하나가 표현식이고 파티션이 &lt;code&gt;NULL&lt;/code&gt; 값을 허용하지 않는 경우에는 작동하지 않습니다 . &lt;code&gt;NULL&lt;/code&gt; 값을 허용하지 않는 목록 파티션을 첨부하는 경우 &lt;code&gt;NOT NULL&lt;/code&gt; 도 추가하십시오. 식이 아닌 경우 파티션 키 열에 대한 제약 조건.</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">새 값이 튜플 접두사와 일치하지 않으면 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgSplitTuple&lt;/code&gt; 로 설정 하십시오 . 이 조치는 기존의 모든 노드를 새로운 하위 레벨 내부 튜플로 이동하고 기존 내부 튜플을 새 하위 레벨 내부 튜플을 가리키는 단일 다운 링크가있는 튜플로 대체합니다. 설정 &lt;code&gt;prefixHasPrefix&lt;/code&gt; 은 이렇게 설정하면 새로운 상위 튜플이 접두사를해야하는지 여부를 표시하고하는 &lt;code&gt;prefixPrefixDatum&lt;/code&gt; 을 접두사 값. 이 새로운 접두어 값은 색인화 할 새 값을 허용하기 위해 원본보다 충분히 덜 제한적이어야합니다. &lt;code&gt;prefixNNodes&lt;/code&gt; 를 새 튜플에 필요한 노드 수로 설정하고 prefixNodeLabels 를 설정 &lt;code&gt;prefixNodeLabels&lt;/code&gt; 레이블을 보유한 palloc의 배열 또는 노드 레이블이 필요하지 않은 경우 NULL 새 상단 튜플의 총 크기는 교체하는 튜플의 총 크기를 초과하지 않아야합니다. 새 접두사와 새 레이블의 길이를 제한합니다. 집합 &lt;code&gt;childNodeN&lt;/code&gt; 새로운 하위 레벨 내측 튜플 다운 링크 것이다 노드 (제로)에서의 인덱스이다. &lt;code&gt;postfixHasPrefix&lt;/code&gt; 를 설정 하여 새로운 하위 레벨 내부 튜플에 접두사가 있어야하는지 여부를 표시하고, 그렇다면 &lt;code&gt;postfixPrefixDatum&lt;/code&gt; 을 설정 하십시오.접두사 값으로. 이 두 접두사와 다운 링크 노드의 레이블 (있는 경우)의 조합은 원래 접두사와 동일한 의미를 가져야합니다. 새로운 하위 수준 튜플로 이동 한 노드 레이블을 변경하거나 다른 레이블을 변경할 수있는 기회가 없기 때문입니다. 하위 색인 항목. 노드가 분할 된 후 대체 내부 튜플과 함께 &lt;code&gt;choose&lt;/code&gt; 함수가 다시 호출됩니다. &lt;code&gt;spgSplitTuple&lt;/code&gt; 작업으로 적합한 노드를 만들지 않은 경우 해당 호출은 &lt;code&gt;spgAddNode&lt;/code&gt; 결과를 반환 할 수 있습니다 . 결국 &lt;code&gt;choose&lt;/code&gt; 반환해야합니다 &lt;code&gt;spgMatchNode&lt;/code&gt; 를 다음 단계로 내려 삽입을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">새 값이 기존 하위 노드 중 하나와 일치하면 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgMatchNode&lt;/code&gt; 로 설정 하십시오 . &lt;code&gt;nodeN&lt;/code&gt; 을 노드 배열에서 해당 노드의 인덱스 (0부터)로 설정하십시오 . 해당 노드를 통해 내림차순으로 발생하는 &lt;code&gt;level&lt;/code&gt; 증분으로 &lt;code&gt;levelAdd&lt;/code&gt; 를 설정 하거나 연산자 클래스가 레벨을 사용하지 않는 경우 0으로 두십시오. 집합 &lt;code&gt;restDatum&lt;/code&gt; 은 동일하기 &lt;code&gt;leafDatum&lt;/code&gt; 를 조작 클래스가 한 레벨에서 다음 레벨 데이텀을 수정하지 않는 경우, 또는 달리로서 사용되는 변형 된 값으로 설정 &lt;code&gt;leafDatum&lt;/code&gt; 다음 레벨.</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">알 수없는 입력이 모두 같은 유형 범주가 아닌 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">(숫자 토큰에 콜론이 포함되어있는 경우 &lt;code&gt;:&lt;/code&gt; ),이 시간 문자열입니다. 모든 후속 숫자와 콜론을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">숫자 토큰에 대시 ( &lt;code&gt;-&lt;/code&gt; ), 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 또는 둘 이상의 점 ( &lt;code&gt;.&lt;/code&gt; )이 포함 된 경우 텍스트 월이있는 날짜 문자열입니다. 날짜 토큰이 이미 표시된 경우 시간대 이름 (예 : &lt;code&gt;America/New_York&lt;/code&gt; )으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">운영 체제가 단일 프로그램 내에서 여러 로케일을 사용하여 지원 (제공하는 경우 &lt;code&gt;newlocale&lt;/code&gt; 및 관련 기능)을 ICU에 대한 지원이 구성된 경우, 또는 다음, 데이터베이스 클러스터가 초기화 될 때 &lt;code&gt;initdb&lt;/code&gt; 를 채우는 시스템 카탈로그 &lt;code&gt;pg_collation&lt;/code&gt; 을 로케일 모든 기반으로 데이터 정렬 당시 운영 체제에서 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">작업이 시간 초과 내에 완료되지 않으면 (옵션 &lt;code&gt;-t&lt;/code&gt; 참조 ) &lt;code&gt;pg_ctl&lt;/code&gt; 은 0이 아닌 종료 상태로 종료됩니다. 그러나 작업이 백그라운드에서 계속되고 결국 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">선택적 &lt;code&gt;NO CYCLE&lt;/code&gt; 키워드를 지정 하면 시퀀스가 ​​최대 값에 도달 한 후 &lt;code&gt;nextval&lt;/code&gt; 을 호출 하면 오류가 반환됩니다. &lt;code&gt;CYCLE&lt;/code&gt; 또는 &lt;code&gt;NO CYCLE&lt;/code&gt; 을 지정 하지 않으면 이전주기 동작이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">선택적 부울 매개 변수 &lt;code&gt;collatable&lt;/code&gt; 이 true 인 경우, 컬럼 정의 및 유형의 표현식은 &lt;code&gt;COLLATE&lt;/code&gt; 절 을 사용하여 데이터 정렬 정보를 전달할 수 있습니다 . 데이터 정렬 정보를 실제로 사용하는 것은 형식에서 작동하는 함수의 구현에 달려 있습니다. 이것은 단순히 유형을 collatable로 표시하여 자동으로 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">동일한 상위의 형제 순서가 중요한 경우 형제 순서를 지정할 필드를 지정 하려면 &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; 매개 변수를 포함하십시오 . 이 필드는 정렬 가능한 데이터 유형이 될 수 있습니다. &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; 가 지정된 경우에만 출력 열 목록에 최종 정수 일련 번호 열이 포함되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">출력 열이 복합 (행) 유형이고 JSON 값이 JSON 객체 인 경우 이러한 규칙을 반복적으로 적용하여 객체의 필드가 출력 행 유형의 열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">출력 열이 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 유형 인 경우 JSON 값이 그대로 재현됩니다.</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">암호가 SCRAM-SHA-256으로 암호화 된 경우 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">주어진 행에 대해 경로 표현식이 빈 노드 세트 (일반적으로 일치하지 않는 경우)를 &lt;code&gt;NULL&lt;/code&gt; 하면 &lt;code&gt;default_expression&lt;/code&gt; 이 지정 되지 않은 한 열이 NULL 로 설정 됩니다. 그런 다음 해당 표현식을 평가 한 결과 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">기본 서버가 나머지 대기 서버와 분리되어 있으면 나머지 나머지 대기 서버 중 가장 적합한 후보로 장애 조치해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">기본 서버가 실패하고 대기 서버가 새 기본 서버가 된 후 이전 기본 서버가 다시 시작되면 이전 기본 서버에 더 이상 기본 서버가 아니라고 알리는 메커니즘이 있어야합니다. 이를 STONITH (Shoot The Other Node In The Head)라고도하며, 두 시스템이 모두 기본 시스템이라고 생각하는 상황을 피해야하므로 혼란과 궁극적으로 데이터 손실이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">기본 서버에 장애가 발생하면 대기 서버는 장애 조치 절차를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">개인 키가 암호로 보호되어 있으면 서버는 암호를 입력하라는 메시지가 표시되고 암호가 입력 될 때까지 시작되지 않습니다. 비밀번호 문구를 기본적으로 사용하면 서버를 다시 시작하지 않고도 서버의 SSL 구성을 변경하는 기능이 비활성화되지만 &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload를&lt;/a&gt; 참조하십시오 . 또한 암호 구로 보호 된 개인 키는 Windows에서 전혀 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">프로 시저에 출력 매개 변수가 있으면 해당 매개 변수의 값을 포함하는 결과 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">제품 테이블을 말하자면, 너무 설정되어있는 경우 &lt;code&gt;product_id&lt;/code&gt; 기본 키입니다, 그것은에 의해 그룹에 충분하다 &lt;code&gt;product_id&lt;/code&gt; 이름과 가격이 될 것이기 때문에, 위의 예에서 &lt;em&gt;기능적으로 의존하는&lt;/em&gt; 제품 ID에 등이있을 것 각 제품 ID 그룹에 대해 반환 할 이름과 가격 값에 대한 모호함이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">쿼리에 창 기능이 포함 된 경우 ( &lt;a href=&quot;tutorial-window&quot;&gt;섹션 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21&lt;/a&gt; 및 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; 참조) 이러한 기능은 그룹화, 집계 및 &lt;code&gt;HAVING&lt;/code&gt; 필터링이 수행 된 후에 평가 됩니다. 즉, 쿼리가 집계, &lt;code&gt;GROUP BY&lt;/code&gt; 또는 &lt;code&gt;HAVING&lt;/code&gt; 을 사용하는 경우, 창 함수가 보는 행은 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; 의 원래 테이블 행 대신 그룹 행 입니다.</target>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">쿼리가 실패하거나 하나의 행을 반환하지 않으면 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">쿼리에 둘 이상의 관계 가입이 필요한 경우 단일 관계를 검색하기위한 모든 실행 가능한 계획을 찾은 후 관계 가입 계획이 고려됩니다. 사용 가능한 세 가지 조인 전략은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">쿼리가 &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 관계 보다 적은 수를 사용 하는 경우 최상의 조인 시퀀스를 찾기 위해 거의 포괄적 인 검색이 수행됩니다. 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 자격 에 해당하는 조인 절이 존재하는 두 관계 (즉, &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; 와 같은 제한 사항) 사이의 조인을 우선적으로 고려합니다 . 조인 절이없는 조인 쌍은 다른 선택이없는 경우에만, 즉 특정 관계에 다른 관계에 사용 가능한 조인 절이없는 경우에만 고려됩니다. 플래너가 고려한 모든 조인 쌍에 대해 가능한 모든 계획이 생성되며 가장 저렴한 계획이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">참조 된 열을 자주 변경하는 경우 외래 키 제약 조건과 관련된 참조 작업을보다 효율적으로 수행 할 수 있도록 참조 열에 인덱스를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 를 실행하는 역할이 둘 이상의 역할 멤버쉽 경로를 통해 간접적으로 필요한 권한을 보유하는 경우 부여를 수행 한 것으로 기록 할 포함 역할이 지정되지 않습니다. 이러한 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 을 사용 하여 &lt;code&gt;GRANT&lt;/code&gt; 를 수행하려는 특정 역할이되는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; 를 실행하는 역할이 둘 이상의 역할 멤버쉽 경로를 통해 간접적으로 권한을 보유하는 경우 명령을 수행하는 데 사용할 포함 역할이 지정되지 않습니다. 이러한 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 을 사용 하여 &lt;code&gt;REVOKE&lt;/code&gt; 를 수행하려는 특정 역할이되는 것이 가장 좋습니다 . 그렇게하지 않으면 의도 한 권한 이외의 권한을 취소하거나 전혀 권한을 취소하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">동일한 페이로드 문자열을 가진 동일한 트랜잭션에서 동일한 채널 이름이 여러 번 시그널링되면 데이터베이스 서버는 단일 알림 만 전달하기로 결정할 수 있습니다. 반면, 고유 한 페이로드 문자열이있는 알림은 항상 고유 한 알림으로 전달됩니다. 마찬가지로 다른 거래의 알림은 하나의 알림으로 접히지 않습니다. &lt;code&gt;NOTIFY&lt;/code&gt; 는 이후의 중복 알림 인스턴스를 삭제하는 것을 제외하고 동일한 트랜잭션의 알림이 전송 된 순서대로 배달되도록합니다. 서로 다른 트랜잭션의 메시지가 트랜잭션이 커밋 된 순서대로 전달되는 것도 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">동일한 컬럼 이름이 둘 이상의 상위 테이블에 존재하는 경우 컬럼의 데이터 유형이 각 상위 테이블에서 일치하지 않으면 오류가보고됩니다. 충돌이 없으면 중복 된 열이 병합되어 새 테이블에서 단일 열을 형성합니다. 새 테이블의 열 이름 목록에 상속 된 열 이름이 포함 된 경우 데이터 유형도 상속 된 열과 일치해야하며 열 정의가 하나로 병합됩니다. 새 테이블이 열의 기본값을 명시 적으로 지정하면이 기본값은 상속 된 열 선언의 기본값을 대체합니다. 그렇지 않으면 열의 기본값을 지정하는 모든 상위가 모두 동일한 기본값을 지정해야합니다. 그렇지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">저장할 값의 스케일이 선언 된 열 스케일보다 크면 시스템은 지정된 소수 자릿수로 값을 반올림합니다. 그런 다음 소수점 왼쪽의 자릿수가 선언 된 정밀도에서 선언 된 스케일을 뺀 값을 초과하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">검색 경로에서 동일한 인수 유형의 여러 함수를 찾으면 경로에서 가장 먼저 나타나는 함수 만 고려됩니다. 다른 인수 유형의 함수는 검색 경로 위치에 관계없이 동일한 기반으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">검색 경로에서 동일한 인수 유형을 가진 여러 연산자를 찾으면 경로에서 가장 빠른 연산자 만 고려됩니다. 인수 유형이 다른 연산자는 검색 경로 위치에 관계없이 동일한 기반으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">세션 사용자가 데이터베이스 수퍼 유저 인 경우 &lt;code&gt;#&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령의 결과로 데이터베이스 세션 중에이 값의 확장이 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">지정된 테이블이 파티션 된 테이블 인 경우 각 행은 해당 파티션으로 라우트되어 삽입됩니다. 지정된 테이블이 파티션 인 경우 입력 행 중 하나가 파티션 제한 조건을 위반하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">표준 및 사전 정의 된 데이터 정렬이 충분하지 않은 경우 사용자는 SQL 명령 &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION을&lt;/a&gt; 사용하여 고유 한 데이터 정렬 오브젝트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">온라인 백업 중에 대기가 마스터로 승격되면 백업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">대기 서버에 장애가 발생하면 장애 조치가 필요하지 않습니다. 대기 서버를 나중에 다시 시작할 수 있으면 나중에 다시 시작 가능한 복구를 이용하여 복구 프로세스를 즉시 다시 시작할 수도 있습니다. 대기 서버를 다시 시작할 수 없으면 완전히 새로운 대기 서버 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">대기 서버가 여전히 실행중인 경우 위의 지시 사항을 사용하여 대기 서버를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">상태 전이 함수가 &quot;엄격&quot;으로 선언되면 널 입력으로 호출 할 수 없습니다. 이러한 전환 기능을 사용하면 집계 실행은 다음과 같이 작동합니다. 널 입력 값이있는 행은 무시됩니다 (함수가 호출되지 않고 이전 상태 값이 유지됨). 초기 상태 값이 널인 경우, 첫 번째 행에서 모두 널이 아닌 입력 값으로, 첫 번째 인수 값이 상태 값을 대체하고, 이후의 각 행에서 모든 널이 아닌 입력 값으로 전이 함수가 호출됩니다. &lt;code&gt;max&lt;/code&gt; 와 같은 집계를 구현하는 데 편리합니다 . 이 동작은 &lt;code&gt;state_data_type&lt;/code&gt; 이 첫 번째 &lt;code&gt;arg_data_type&lt;/code&gt; 과 동일한 경우에만 사용할 수 있습니다.. 이러한 유형이 다르면 null이 아닌 초기 조건을 제공하거나 엄격하지 않은 전환 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">상태 전이 함수가 엄격하지 않으면 각 입력 행에서 무조건 호출되며 널 입력 및 널 상태 값 자체를 처리해야합니다. 이렇게하면 집계 작성자가 집계의 null 값 처리를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">문자열이 테이블에서 온 것처럼 &lt;code&gt;varchar&lt;/code&gt; 유형으로 선언 되면 파서는 &lt;code&gt;text&lt;/code&gt; 로 변환하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">부속 유형이 연속 값이 아닌 개별 값을 갖는 것으로 간주되는 경우 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령은 &lt;code&gt;canonical&lt;/code&gt; 함수를 지정해야 합니다. 정규화 함수는 입력 범위 값을 사용하며 범위와 형식이 다른 등가 범위 값을 반환해야합니다. 동일한 값 세트를 나타내는 두 범위의 표준 출력 (예 : 정수 범위 &lt;code&gt;[1, 7]&lt;/code&gt; 및 &lt;code&gt;[1, 8)&lt;/code&gt; 동일해야합니다. 형식이 다른 두 개의 동등한 값이 항상 같은 형식의 동일한 값에 맵핑되는 한 표준 표현으로 선택한 표현은 중요하지 않습니다. 포함 / 제외 바운드 형식을 조정하는 것 외에도 표준 함수는 원하는 단계 크기가 하위 유형이 저장할 수있는 것보다 큰 경우 경계 값을 반올림 할 수 있습니다. 예를 들어 &lt;code&gt;timestamp&lt;/code&gt; 따른 범위 유형 은 단계 크기가 1 시간으로 정의 될 수 있으며,이 경우 정규화 함수는 1 시간의 배수가 아닌 범위를 반올림하거나 대신 오류를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">서버 시스템의 시스템 관리자를 신뢰할 수없는 경우 클라이언트가 데이터를 암호화해야합니다. 이런 식으로 암호화되지 않은 데이터는 데이터베이스 서버에 나타나지 않습니다. 데이터는 서버로 전송되기 전에 클라이언트에서 암호화되며 데이터베이스 결과는 사용하기 전에 클라이언트에서 해독해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">테이블 전체가 다른 사람에 의해 독점적으로 잠긴 경우 &lt;code&gt;pgrowlocks&lt;/code&gt; 가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">분석중인 테이블에 하나 이상의 하위가있는 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 는 통계를 두 번 수집합니다. 상위 테이블의 행에서만 한 번, 모든 하위 테이블이있는 상위 테이블의 행에서 두 번째입니다. 이 두 번째 통계 세트는 전체 상속 트리를 통과하는 쿼리를 계획 할 때 필요합니다. 그러나 autovacuum 데몬은 해당 테이블에 대한 자동 분석을 트리거할지 여부를 결정할 때 상위 테이블 자체에 대한 삽입 또는 업데이트 만 고려합니다. 해당 테이블이 거의 삽입되거나 업데이트되지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 를 수동으로 실행하지 않으면 상속 통계가 최신 상태가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">분석중인 테이블이 완전히 비어 있으면 &lt;code&gt;ANALYZE&lt;/code&gt; 는 해당 테이블에 대한 새 통계를 기록하지 않습니다. 기존 통계는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">인덱스를 사용하여 테이블을 스캔하는 경우 사용중인 인덱스의 OID입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">토큰이 알파벳 문자열 인 경우 가능한 문자열과 일치 시키십시오.</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">토큰이 숫자 인 경우 단일 필드 또는 ISO 8601 연결 날짜 (예 : &lt;code&gt;19990113&lt;/code&gt; 년 1 월 13 일의 경우 19990113 ) 또는 시간 (예 : &lt;code&gt;141516&lt;/code&gt; 경우 141516)입니다.</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">토큰이 3 자리이고 1 년을 이미 읽은 경우 연도의 일자로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">토큰이 더하기 ( &lt;code&gt;+&lt;/code&gt; ) 또는 빼기 ( &lt;code&gt;-&lt;/code&gt; )로 시작하면 숫자 시간대 또는 특수 필드입니다.</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">트랜잭션이 &lt;code&gt;SET&lt;/code&gt; ( &lt;code&gt;LOCAL&lt;/code&gt; 옵션 없이)을 사용하여 런타임 매개 변수를 수정 한 경우 해당 효과는 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 후에도 지속 되며 이후 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 의 영향을받지 않습니다 . 따라서이 관점에서 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 &lt;code&gt;ROLLBACK&lt;/code&gt; 보다 &lt;code&gt;COMMIT&lt;/code&gt; 와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">주문한 유형 ( &lt;code&gt;type1&lt;/code&gt; )을 정리할 수있는 경우 표준 PG_GET_COLLATION () 메커니즘을 사용하여 적절한 조합 OID가 &lt;code&gt;in_range&lt;/code&gt; 함수 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">고유 제한 조건이 지연 가능한 경우 추가 복잡성이 있습니다. 새 행에 대한 색인 항목을 삽입 할 수 있어야하지만 명령문이 끝날 때까지 또는 이후에 고유성 위반 오류를 지연시켜야합니다. 인덱스의 불필요한 반복 검색을 피하기 위해 인덱스 액세스 방법은 초기 삽입 중에 예비 고유성 검사를 수행해야합니다. 이것이 충돌하는 라이브 튜플이 없다는 것을 보여 주면 완료됩니다. 그렇지 않으면 구속 조건을 시행 할 때 재확인이 발생하도록 스케줄합니다. 다시 검사 할 때 삽입 된 튜플과 동일한 키를 가진 다른 튜플이 모두 활성화 된 경우 오류를보고해야합니다. (이 목적을 위해, &quot;live&quot;는 실제로 &quot;인덱스 항목의 HOT 체인에있는 모든 튜플이 작동 함&quot;을 의미합니다.)이를 구현하기 위해 &lt;code&gt;aminsert&lt;/code&gt; 함수가 전달됩니다. &lt;code&gt;checkUnique&lt;/code&gt; 다음 값 중 하나를 갖는 checkUnique 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">값 &lt;code&gt;-&lt;/code&gt; (대시)가 대상 디렉토리로 지정되면 tar 컨텐츠는 표준 출력에 기록되며, 예를 들어 gzip으로의 파이프에 적합합니다. 클러스터에 추가 테이블 스페이스가없고 WAL 스트리밍이 사용되지 않는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">값이 1 (기본값) 이상이면 부동 소수점 값이 가장 짧은 형식으로 출력됩니다. &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;섹션 8.1.3&lt;/a&gt; 참조 . 생성되는 실제 자릿수는이 매개 변수의 값이 아니라 출력되는 값에만 의존합니다. &lt;code&gt;float8&lt;/code&gt; 값 에는 최대 17 자리가 , &lt;code&gt;float4&lt;/code&gt; 값에는 9 자리가 필요 합니다. 이 형식은 빠르고 정확하게 사용할 수 있으며 정확하게 읽을 때 원래 이진 부동 소수점 값을 유지합니다. 기록 호환성을 위해 최대 3 개의 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">값이 0 또는 음수이면 출력은 주어진 10 진수 정밀도로 반올림됩니다. 사용되는 정밀도 는이 매개 변수의 값에 따라 줄어든 유형의 표준 자릿수 ( 적절한 경우 &lt;code&gt;FLT_DIG&lt;/code&gt; 또는 &lt;code&gt;DBL_DIG&lt;/code&gt; )입니다. 예를 들어, -1을 지정하면 &lt;code&gt;float4&lt;/code&gt; 값이 유효 숫자 5 자리로 반올림 되고 &lt;code&gt;float8&lt;/code&gt; 값이 14 자리로 반올림됩니다.이 형식은 속도가 느리고 이진 float 값의 모든 비트를 보존하지는 않지만 더 많을 수 있습니다. 인간이 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">요소에 대해 작성된 값이 &lt;code&gt;NULL&lt;/code&gt; (경우에 따라 변형) 인 경우 요소는 NULL로 간주됩니다. 따옴표 나 백 슬래시가 있으면이를 비활성화하고 리터럴 문자열 값 &quot;NULL&quot;을 입력 할 수 있습니다. 또한 8.2 이전 버전의 PostgreSQL과의 호환성 을 위해 &lt;code&gt;NULL&lt;/code&gt; 로 NULL 을 인식 &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;하지 못하도록 array_nulls&lt;/a&gt; 구성 매개 변수를 &lt;code&gt;off&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">뷰를 자동으로 업데이트 할 수있는 경우 시스템은 뷰의 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 문을 기본 관계의 해당 문으로 변환합니다. &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 절이 있는 &lt;code&gt;INSERT&lt;/code&gt; 문 이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">너비가 함수 인수에서 오는 경우 해당 인수는 형식 지정자 값에 사용되는 인수보다 먼저 사용됩니다. width 인수가 음수이면 결과는 length &lt;code&gt;abs&lt;/code&gt; ( &lt;code&gt;width&lt;/code&gt; ) 필드 내 에서 &lt;code&gt;-&lt;/code&gt; 플래그가 지정된 것처럼 정렬 된 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">모두가있는 경우 &lt;code&gt;unknown&lt;/code&gt; 및 알려진 타입의 인수 및 알려진 모든 유형의 인수는, 동일한 유형을 가지고 있다고 가정 &lt;code&gt;unknown&lt;/code&gt; 인수는 해당 유형의, 그리고 후보가에서 해당 유형 받아 들일 수 체크 &lt;code&gt;unknown&lt;/code&gt; -argument 위치를. 정확히 하나의 응시자가이 시험을 통과하면 사용하십시오. 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">입력 표현식간에 기본이 아닌 암시 적 데이터 정렬이 충돌하는 경우 조합에 불확실한 데이터 정렬이있는 것으로 간주됩니다. 호출되는 특정 함수에 적용 할 데이터 정렬에 대한 지식이 필요한 경우가 아니면 오류 조건이 아닙니다. 그렇다면 런타임에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">8 자리 또는 6 자리가 있고 이전에 읽은 다른 날짜 필드가없는 경우 &quot;연결 날짜&quot;(예 : &lt;code&gt;19990118&lt;/code&gt; 또는 &lt;code&gt;990118&lt;/code&gt; )로 해석 하십시오. 해석은 &lt;code&gt;YYYYMMDD&lt;/code&gt; 또는 &lt;code&gt;YYMMDD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 에서 참조 된 여러 열에 별도의 인덱스가있는 경우 플래너는 인덱스의 AND 또는 OR 조합을 사용하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">대상 테이블에 트리거가있는 경우 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;38 장&lt;/a&gt; ) &lt;code&gt;RETURNING&lt;/code&gt; 에 사용 가능한 데이터 는 트리거에 의해 수정 된 행입니다. 따라서 트리거로 계산 된 열을 검사하는 것이 &lt;code&gt;RETURNING&lt;/code&gt; 의 또 다른 일반적인 사용 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">창 계산을 수행 한 후 행을 필터링하거나 그룹화해야하는 경우 하위 선택을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">LSN이 &lt;code&gt;lsn&lt;/code&gt; 과 정확히 같은 레코드가 있으면 레코드가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">인덱스가 있고 인덱스 가능한 &lt;code&gt;WHERE&lt;/code&gt; 조건을 가진 쿼리를 사용하는 경우 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 다른 계획을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">자식 테이블에 대한 직접 부모가 둘 이상인 경우 (다중 상속)이 숫자는 상속 된 열이 정렬되는 순서를 나타냅니다. 카운트는 1부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">라는 이름의 설정이없는 경우 &lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt; , &lt;code&gt;current_setting&lt;/code&gt; 이 되지 않는 오류가 발생 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; 가&lt;/em&gt; 공급하고 있습니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">LSN이 정확히 &lt;code&gt;lsn&lt;/code&gt; 과 동일한 레코드가 있으면 레코드가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">이 두 가지 기본 요구 사항이 충족되면 쿼리에 필요한 모든 데이터 값을 인덱스에서 사용할 수 있으므로 인덱스 전용 검색이 실제로 가능합니다. 그러나 PostgreSQL에는 테이블 스캔에 대한 추가 요구 사항이 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 에서 설명한 것처럼 검색된 각 행이 쿼리의 MVCC 스냅 샷에 &quot;표시&quot;되는지 확인해야합니다.. 가시성 정보는 인덱스 항목에 저장되지 않고 힙 항목에만 저장됩니다. 언뜻보기에 모든 행 검색에는 힙 액세스가 필요할 것 같습니다. 그리고 최근에 테이블 행이 수정 된 경우에도 마찬가지입니다. 그러나 데이터를 거의 변경하지 않으면이 문제를 해결할 수있는 방법이 있습니다. PostgreSQL은 테이블 힙의 각 페이지에 대해 해당 페이지에 저장된 모든 행이 현재 및 미래의 모든 트랜잭션에서 볼 수있을 정도로 오래되었는지 여부를 추적합니다. 이 정보는 테이블의 &lt;em&gt;가시성 맵에&lt;/em&gt; 약간 저장 &lt;em&gt;됩니다&lt;/em&gt;. 후보 인덱스 항목을 찾은 후 인덱스 전용 스캔은 해당 힙 페이지에 대한 가시성 맵 비트를 확인합니다. 설정된 경우 행이 표시되어 더 이상 작업하지 않고도 데이터를 반환 할 수 있습니다. 설정되지 않은 경우 힙 항목을 방문하여 가시적인지 여부를 확인해야하므로 표준 인덱스 스캔에 비해 성능 이점이 없습니다. 성공적인 경우에도이 방법은 가시성 맵 액세스를 힙 액세스로 교환합니다. 그러나 가시성 맵은 설명하는 힙보다 4 배 크기가 작으므로 액세스하기 위해 훨씬 적은 물리적 I / O가 필요합니다. 대부분의 상황에서 가시성 맵은 항상 메모리에 캐시 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">이 절을 지정하면 &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; 로 정의 된 식별 컬럼에 제공된 모든 값 이 무시되고 기본 시퀀스 생성 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">이 파일이 데이터 디렉토리에 존재하면 pg_ctl ( &lt;code&gt;restart&lt;/code&gt; 모드에서)은 &lt;code&gt;-o&lt;/code&gt; 옵션으로 재정의되지 않는 한 파일 내용을 postgres에 옵션으로 전달합니다 . 이 파일의 내용도 &lt;code&gt;status&lt;/code&gt; 모드로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">이 경우 다음과 같은 커널 메시지가 표시됩니다 (해당 메시지를 찾을 위치에 대한 시스템 설명서 및 구성을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">이것이 복합 유형 인 경우 ( &lt;code&gt;typtype&lt;/code&gt; 참조 )이 열 은 해당 테이블을 정의하는 &lt;code&gt;pg_class&lt;/code&gt; 항목을 가리 킵니다 . 독립형 복합 유형의 경우 &lt;code&gt;pg_class&lt;/code&gt; 항목은 실제로 테이블을 나타내지는 않지만 유형의 &lt;code&gt;pg_attribute&lt;/code&gt; 항목을 링크하려면 어쨌든 필요합니다 . 비 복합 유형의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">이것이 도메인 인 경우 ( &lt;code&gt;typtype&lt;/code&gt; 참조 ) &lt;code&gt;typbasetype&lt;/code&gt; 은이 도메인의 기반이되는 유형을 식별합니다. 이 유형이 도메인이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">이것이 테이블 또는 인덱스 인 경우 사용 된 액세스 방법 (힙, B- 트리, 해시 등)</target>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">켜져 있으면 &lt;code&gt;username@dbname&lt;/code&gt; 으로 사용자를 작성해야합니다 . 연결 클라이언트가 &lt;code&gt;username&lt;/code&gt; 을 전달 하면 &lt;code&gt;@&lt;/code&gt; 및 데이터베이스 이름이 사용자 이름에 추가되고 해당 데이터베이스 별 사용자 이름이 서버에서 조회됩니다. SQL 환경에서 &lt;code&gt;@&lt;/code&gt; 가 포함 된 이름을 가진 사용자를 만들 때는 사용자 이름을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">이 옵션을 &lt;code&gt;compat_realm&lt;/code&gt; 과 함께 사용하면 Kerberos UPN의 사용자 이름이 인증에 사용됩니다. 비활성화 된 경우 (기본값) SAM 호환 사용자 이름이 사용됩니다. 기본적으로이 두 이름은 새 사용자 계정에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">이 옵션을 지정하지 않고 서버가 임시 복제 슬롯 (버전 10 이상)을 지원하면 WAL 스트리밍에 임시 복제 슬롯이 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수에 &lt;code&gt;=&lt;/code&gt; 기호 가 포함 되거나 유효한 URI 접두사 ( &lt;code&gt;postgresql://&lt;/code&gt; 또는 &lt;code&gt;postgres://&lt;/code&gt; )로 시작하면 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 로 처리됩니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;33.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수에 &lt;code&gt;=&lt;/code&gt; 기호 가 포함 되거나 유효한 URI 접두사 ( &lt;code&gt;postgresql://&lt;/code&gt; 또는 &lt;code&gt;postgres://&lt;/code&gt; )로 시작하면 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 로 처리됩니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">이 매개 변수가 설정되어 있으면 PostgreSQL 서버는 &lt;code&gt;fsync()&lt;/code&gt; 시스템 호출 또는 이와 동등한 다양한 메소드 를 실행하여 업데이트가 실제로 디스크에 기록되도록 합니다 ( &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; 참조 ). 이를 통해 운영 체제 또는 하드웨어 충돌 후 데이터베이스 클러스터가 일관된 상태로 복구 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">이렇게해도 응답이 없으면이 단계는 성공한 것이므로이 섹션의 나머지 부분을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">이 테이블이 파티션 인 경우 , 상위 테이블에서 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시되면 컬럼에서 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 을 수행 할 수 없습니다 . 모든 파티션에서 &lt;code&gt;NOT NULL&lt;/code&gt; 제한 조건 을 삭제하려면 상위 테이블에서 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 을 수행 하십시오. 부모에 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 이 없더라도 원하는 경우 이러한 제약 조건을 개별 파티션에 계속 추가 할 수 있습니다. 즉, 부모가 허용하더라도 자식은 null을 허용하지 않지만 다른 방법으로는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">이 값을 단위없이 지정하면 분으로 간주됩니다. &lt;code&gt;-1&lt;/code&gt; (기본값) 값은 이 기능을 비활성화하여 스냅 샷 보존 기간을 무한대로 효과적으로 설정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">이 변수가 &lt;code&gt;ignorespace&lt;/code&gt; 로 설정 되면 공백으로 시작하는 행이 히스토리 목록에 입력되지 않습니다. &lt;code&gt;ignoredups&lt;/code&gt; 값으로 설정 하면 이전 히스토리 라인과 일치하는 라인이 입력되지 않습니다. &lt;code&gt;ignoreboth&lt;/code&gt; 값은 두 가지 옵션을 결합합니다. &lt;code&gt;none&lt;/code&gt; (기본값)으로 설정하면 대화식 모드에서 읽은 모든 행이 기록 목록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 테이블의 액세스 방법 세부 사항이 표시되지 않습니다. 이것은 주로 회귀 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">이 변수를 0보다 큰 정수 값으로 설정하면 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 결과가 표시되기 전에 전체 결과 세트를 수집하는 기본 동작이 아니라 여러 행의 그룹으로 페치되어 표시됩니다. 따라서 결과 집합의 크기에 관계없이 제한된 양의 메모리 만 사용됩니다. 이 기능을 활성화 할 때 일반적으로 100 ~ 1000의 설정이 사용됩니다. 이 기능을 사용할 때 이미 일부 행을 표시 한 후 쿼리가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">세 개 이상의 숫자가 있고 아직 날짜 필드가 없으면 연도로 해석하십시오 (나머지 날짜 필드의 yy-mm-dd 순서를 강제 함).</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">참이면이 인덱스가 &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt; 사용한 교체 ID를 사용하여&amp;ldquo;복제본 ID&amp;rdquo;로 선택되었습니다 ...</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;DELETE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">참이면 게시의 테이블에 대해 &lt;code&gt;INSERT&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;TRUNCATE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;UPDATE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">true 인 경우, 이 &lt;code&gt;pg_index&lt;/code&gt; 행 의 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;TransactionXmin&lt;/code&gt; 이벤트 수평선 아래 에 올 때까지 쿼리는 인덱스를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">true 인 경우 색인은 현재 삽입 준비가되었습니다. False는 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 조작으로 색인을 무시해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">true 인 경우 인덱스는 현재 쿼리에 유효합니다. False는 인덱스가 불완전 할 수 있음을 의미합니다. &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 조작으로 여전히 수정해야 하지만 쿼리에는 안전하게 사용할 수 없습니다. 고유 한 경우 고유성 속성도 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">true 인 경우 통계에는 지정된 관계의 값뿐만 아니라 상속 하위 열도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">true 인 경우 구독이 활성화되어 복제 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">true 인 경우 테이블이이 인덱스에서 마지막으로 클러스터되었습니다</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">참인 경우 삽입시 고유성 검사가 즉시 적용됩니다 ( &lt;code&gt;indisunique&lt;/code&gt; 이 사실이 아닌 경우 에는 관련 이 없음)</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">true 인 경우이 데이터베이스는 &lt;code&gt;CREATEDB&lt;/code&gt; 권한을 가진 모든 사용자가 복제 할 수 있습니다 . false (기본값) 인 경우 수퍼 유저 또는 데이터베이스 소유자 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">true 인 경우이 데이터베이스는 &lt;code&gt;CREATEDB&lt;/code&gt; 권한을 가진 모든 사용자가 복제 할 수 있습니다 . false 인 경우 수퍼 유저 또는 데이터베이스 소유자 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">true의 경우,이 지수는 테이블의 기본 키 (대표 &lt;code&gt;indisunique&lt;/code&gt; 이 이에 해당하는 경우 항상 참이어야 함)</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">true 인 경우이 인덱스는 제외 제약 조건을 지원합니다</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">참이면 고유 인덱스입니다</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">true 인 경우이 발행물에는 향후 생성 될 테이블을 포함하여 데이터베이스의 모든 테이블이 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">true 인 경우이 행에는 지정된 테이블의 값뿐만 아니라 상속 하위 열도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">이러한 두 거래가 동시에 계정 잔액 12345를 변경하려고하면 두 번째 거래가 계정 행의 업데이트 된 버전으로 시작되기를 원합니다. 각 명령은 미리 결정된 행에만 영향을 미치므로 행의 업데이트 된 버전을 볼 수있게한다고해서 번거로운 불일치가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">신뢰할 수없는 사용자가 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;보안 스키마 사용 패턴을&lt;/a&gt; 채택하지 않은 데이터베이스에 액세스 할 수있는 경우 &lt;code&gt;search_path&lt;/code&gt; 에서 공개적으로 쓰기 가능한 스키마를 제거하여 세션을 시작하십시오 . 연결 문자열 에 &lt;code&gt;options=-csearch_path=&lt;/code&gt; 옵션 을 추가 하거나 다른 SQL 명령 전에 &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; 를 발행 할 수 있습니다 . 이 고려 사항은 psql에만 국한되지 않습니다. 임의의 SQL 명령을 실행하기위한 모든 인터페이스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">신뢰할 수없는 사용자가 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;보안 스키마 사용 패턴을&lt;/a&gt; 채택하지 않은 데이터베이스에 액세스 할 수있는 경우 해당 데이터베이스에서 pgbench를 실행하지 마십시오. pgbench는 규정되지 않은 이름을 사용하며 검색 경로를 조작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">WAL 보관 또는 스트리밍 복제를 사용하는 경우 복원 중에 사용하지 않도록 설정하십시오. 이렇게하려면 덤프를로드하기 전에 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;off&lt;/code&gt; 로 , &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;minimal&lt;/code&gt; 로 , &lt;code&gt;max_wal_senders&lt;/code&gt; 를 0으로 설정하십시오. 그런 다음 올바른 값으로 다시 설정하고 새로운 기본 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">기본이 아닌 Unix 도메인 소켓 디렉토리를 사용하는 9.1 이전의 이전 서버 또는 새 클러스터의 기본값과 다른 기본값을 사용하는 경우 &lt;code&gt;PGHOST&lt;/code&gt; 가 이전 서버의 소켓 위치를 가리 키도록 설정 하십시오 . (Windows와는 관련이 없습니다.)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
