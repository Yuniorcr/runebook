<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">예를 들어, &lt;code&gt;UPDATE&lt;/code&gt; 가 발행되면 &lt;code&gt;ALL&lt;/code&gt; 정책은 &lt;code&gt;UPDATE&lt;/code&gt; 가 업데이트 할 행 ( &lt;code&gt;USING&lt;/code&gt; 표현식 적용)으로 선택할 수있는 항목 과 결과로 업데이트 된 행에 모두 적용 가능한지 여부에 적용됩니다. 정의 된 경우 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식을 적용하고 그렇지 않으면 &lt;code&gt;USING&lt;/code&gt; 표현식을 적용하여 테이블에 추가 할 수 있습니다 . 경우 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 의 명령 시도가 통과하지 않는 테이블에 행을 추가 &lt;code&gt;ALL&lt;/code&gt; 의 정책의 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현, 전체 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">예를 들어, &lt;code&gt;miriam&lt;/code&gt; 사용자 가 &lt;code&gt;mytable&lt;/code&gt; 테이블을 작성 하고 다음을 수행 한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">예를 들어, 내장 된 TPC-B와 유사한 트랜잭션의 전체 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">예를 들어, 다음을 통해 어디에서나 가장 높은 저온 판독 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">SQL 표준의 확장으로 PostgreSQL은 단 하나의 이스케이프-큰 따옴표 구분 기호를 사용할 수 있으며,이 경우 세 번째 정규식은 비어 있습니다. 또는 구분 기호가없는 경우 첫 번째 및 세 번째 정규식이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">다른 예로, 다음과 같은 쿼리를 자주하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">그러나 이전과 마찬가지로 PostgreSQL은 어떤 경우에도 크기 제한을 시행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">이전과 마찬가지로, 예상 행 수는 카디널리티 &lt;code&gt;tenk1&lt;/code&gt; 의 곱 에 불과합니다 .</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14 절&lt;/a&gt; 에서 설명 된 것처럼 , 표현의 부분 발현이 서로 다른 시간에 평가되는 다양한 상황이 있기 때문에&amp;ldquo; &lt;code&gt;CASE&lt;/code&gt; 는 필요한 부분 발현 만 평가한다&amp;rdquo;는 원칙 은 철폐되지 않는다. 예를 들어, 상수 &lt;code&gt;1/0&lt;/code&gt; 하위 표현식은 실행시 절대 입력되지 않는 &lt;code&gt;CASE&lt;/code&gt; 암 내에 있더라도 계획시 0으로 나누기 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">이전 섹션에서 설명한 것처럼 트랜잭션 커밋은 일반적으로 &lt;em&gt;동 기적입니다&lt;/em&gt; . 서버는 트랜잭션의 WAL 레코드가 영구 저장소로 비워 질 때까지 기다렸다가 성공 표시를 클라이언트에 반환합니다. 따라서 클라이언트는 커밋 된 것으로보고 된 트랜잭션이 서버 충돌 직후에도 보존되도록 보장합니다. 그러나 짧은 트랜잭션의 경우이 지연은 총 트랜잭션 시간의 주요 구성 요소입니다. 비동기 커밋 모드를 선택하면 트랜잭션이 논리적으로 완료 되 자마자 생성 된 WAL 레코드가 실제로 디스크로 이동하기 전에 서버가 성공을 반환합니다. 이는 소규모 트랜잭션의 처리량을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">위에서 설명한 것처럼 분할 된 테이블에 인덱스를 만들 수 있으며 전체 계층에 자동으로 적용됩니다. 기존 파티션뿐만 아니라 향후에 생성 될 파티션도 색인화되므로 매우 편리합니다. 한 가지 제한 사항은 파티션 된 인덱스를 작성할 때 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 규정 자를 사용할 수 없다는 것 입니다. 긴 잠금 시간을 극복하기 위해 파티션 된 테이블 &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; 을 사용할 수 있습니다 . 이러한 인덱스는 유효하지 않은 것으로 표시되며 파티션은 인덱스가 자동으로 적용되지 않습니다. 파티션의 인덱스를 별도로 사용하여 만들 수 &lt;code&gt;CONCURRENTLY&lt;/code&gt; , 나중에 &lt;em&gt;부착&lt;/em&gt; 하여 상위의 인덱스 &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; . 모든 파티션의 인덱스가 상위 인덱스에 연결되면 상위 인덱스가 자동으로 유효하게 표시됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-priv&quot;&gt;5.7 절&lt;/a&gt; 에서 설명한 것처럼 , 모든 객체 유형에 대한 기본 권한은 일반적으로 객체 소유자에게 부여 가능한 모든 권한을 부여하며 &lt;code&gt;PUBLIC&lt;/code&gt; 에도 일부 권한을 부여 할 수 있습니다. 그러나 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 로 전역 기본 권한을 변경하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1 절&lt;/a&gt; 에서 설명 했듯이 , 기능적 종속성은 매우 저렴하고 효율적인 통계 유형이지만 주요 제한 사항은 전역 적 특성입니다 (개별 열 값이 아닌 열 수준에서 종속성 만 추적).</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;planner-stats&quot;&gt;14.2 절&lt;/a&gt; 에서 설명한대로 플래너는 &lt;code&gt;pg_class&lt;/code&gt; 에서 얻은 페이지 및 행 수를 사용하여 &lt;code&gt;t&lt;/code&gt; 의 카디널리티를 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">기본 &lt;code&gt;tsquery&lt;/code&gt; 입력에서와 같이 가중치는 각 가중치에 연결되어 해당 가중치의 &lt;code&gt;tsvector&lt;/code&gt; 텍스쳐 만 일치하도록 제한 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">SQL의 표준과 같이 모든 함수는 인수가 NULL 인 경우 NULL을 리턴합니다. 부주의하게 사용하면 보안 위험이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">일반적인 클라이언트 / 서버 응용 프로그램과 마찬가지로 클라이언트와 서버는 다른 호스트에있을 수 있습니다. 이 경우 TCP / IP 네트워크 연결을 통해 통신합니다. 클라이언트 시스템에서 액세스 할 수있는 파일은 데이터베이스 서버 시스템에서 액세스 할 수 없거나 다른 파일 이름으로 만 액세스 할 수 있으므로이 점을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 디스크 사용량이이 설정 아래로 유지되는 한, 이전 WAL 파일은 제거되지 않고 체크 포인트에서 나중에 사용하기 위해 항상 재활용됩니다. 이는 대량 배치 작업을 실행할 때와 같이 WAL 사용량의 급증을 처리 할 수 ​​있도록 충분한 WAL 공간을 확보하기 위해 사용할 수 있습니다. 이 값을 단위없이 지정하면 메가 바이트로 간주됩니다. 기본값은 80MB입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">앞에서 언급했듯이 각 (활성) 구독은 원격 (게시) 쪽의 복제 슬롯에서 변경 사항을 수신합니다. 일반적으로 원격 복제 슬롯은 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독을 만들면 자동으로 생성 되고 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독을 삭제하면 자동으로 삭제됩니다 . 그러나 일부 상황에서는 구독과 기본 복제 슬롯을 개별적으로 조작하는 것이 유용하거나 필요할 수 있습니다. 몇 가지 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3 절&lt;/a&gt; 에서 언급했듯이 , 직렬화 가능 트랜잭션은 위험한 읽기 / 쓰기 충돌 패턴에 대한 비 차단 모니터링을 추가하는 반복 가능한 읽기 트랜잭션입니다. 명백한 실행 순서로주기를 유발할 수있는 패턴이 감지되면 관련된 트랜잭션 중 하나가 롤백되어주기를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">언급 한 바와 같이 여러 유형의 TOAST 포인터 데이텀이 있습니다. 가장 오래되고 가장 일반적인 유형은 TOAST 포인터 데이텀 자체를 포함하는 테이블과는 별개이지만 &lt;em&gt;TOAST 테이블에&lt;/em&gt; 저장된 외부 데이터에 대한 포인터입니다. 이러한 &lt;em&gt;온 디스크&lt;/em&gt; 포인터 데이텀은 디스크에 저장 될 튜플이 너무 커서 그대로 저장 될 수없는 TOAST 관리 코드 ( &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; )에 의해 작성됩니다 . 자세한 내용 &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;은 68.2.1 절에 나와 있습니다.&lt;/a&gt;. 또는 TOAST 포인터 데이텀에는 메모리의 다른 곳에 나타나는 라인 외부 데이터에 대한 포인터가 포함될 수 있습니다. 이러한 데이텀은 반드시 수명이 짧고 디스크에 표시되지 않지만 대용량 데이터 값의 복사 및 중복 처리를 피하는 데 매우 유용합니다. 자세한 내용 &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;은 68.2.2 절에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">위에서 언급 한 바와 같이 백업 중에 서버가 충돌하면 &lt;code&gt;backup_label&lt;/code&gt; 파일이 &lt;code&gt;PGDATA&lt;/code&gt; 디렉토리 에서 수동으로 삭제 될 때까지 다시 시작하지 못할 수 있습니다 . 백업을 복원 할 때 &lt;code&gt;backup_label&lt;/code&gt; 파일 을 절대로 제거하지 마십시오 . 이로 인해 손상이 발생할 수 있습니다. 이 파일을 제거하는 것이 적절한시기에 대한 혼동은이 방법을 사용할 때 데이터가 손상되는 일반적인 원인입니다. 나중에 새 마스터로 승격 될 대기를 작성하더라도 대기를 구축하거나 백업을 복원 할 때는 기존 마스터에서만 파일을 제거하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">PostgreSQL 8.4부터 &lt;code&gt;ANALYZE&lt;/code&gt; 작업이 완료되면 &lt;code&gt;amvacuumcleanup&lt;/code&gt; 도 호출 됩니다. 이 경우 &lt;code&gt;stats&lt;/code&gt; 는 항상 NULL이며 모든 반환 값은 무시됩니다. 이 경우는 &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; 를 확인하여 구별 할 수 있습니다 . 액세스 방법은 이러한 호출에서 사후 삽입 정리 외에 autovacuum 작업자 프로세스에서만 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">PostgreSQL 8.4부터는 지연 인덱싱이 사용 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;되므로이&lt;/a&gt; 조언이 덜 필요합니다 (자세한 내용은 섹션 66.4.1 참조). 그러나 매우 큰 업데이트의 경우 인덱스를 삭제하고 다시 작성하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">PostgreSQL 9.0부터 &lt;code&gt;hstore&lt;/code&gt; 는 이전 버전과 다른 내부 표현을 사용합니다. 이는 덤프에서 사용 된 텍스트 표현이 변경되지 않기 때문에 덤프 / 복원 업그레이드에 장애가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1부터 대부분의 절차 언어는 &quot;확장&quot;으로 만들어 졌으므로 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 가 아닌 CREATE &lt;a href=&quot;sql-createextension&quot;&gt;EXTENSION&lt;/a&gt; 으로 설치해야합니다 . &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 의 직접 사용 은 이제 확장 설치 스크립트에 국한되어야합니다. 업그레이드 결과 데이터베이스에 &quot;베어&quot;언어가있는 경우 &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; 를 사용하여 언어를 확장으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1부터 대부분의 절차 언어는 &quot;확장자&quot;로 만들어 졌으므로 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 가 아닌 DROP &lt;a href=&quot;sql-dropextension&quot;&gt;EXTENSION&lt;/a&gt; 으로 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">PostgreSQL 9.1부터는 인덱스에 null 키 값이 포함될 수 있습니다. 또한 null 값이거나 &lt;code&gt;extractValue&lt;/code&gt; 에 따라 키가없는 색인화 된 항목의 색인에 자리 표시 자 널이 포함됩니다 . 이를 통해 빈 항목을 찾아야하는 검색이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">PostgreSQL 9.1부터 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 &lt;code&gt;citext&lt;/code&gt; 열 또는 데이터 값에 첨부 할 수 있습니다 . 현재 &lt;code&gt;citext&lt;/code&gt; 연산자는 대소 문자를 구분하는 문자열을 비교하는 동안 기본이 아닌 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 준수 하지만 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 에 따라 (즉, &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; 가 지정된 것처럼) 소문자로의 초기 접기는 항상 수행됩니다 . 이후 릴리스에서는 두 단계 모두 입력 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 따르도록 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">앞에서 언급했듯이 JSON 값을 입력 한 후 추가 처리없이 인쇄하면 &lt;code&gt;json&lt;/code&gt; 은 입력 된 것과 동일한 텍스트를 출력하지만 &lt;code&gt;jsonb&lt;/code&gt; 는 공백과 같이 의미가 중요하지 않은 세부 정보를 유지하지 않습니다. 예를 들어 여기에 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">두 번째 예에서 볼 수 있듯이 내용 값이 열 참조 인 경우 요소 이름을 생략 할 수 있으며이 경우 기본적으로 열 이름이 사용됩니다. 그렇지 않으면 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">이 예에서 볼 수 있듯이 쿼리가 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 인 경우명령에서 테이블 변경 사항을 적용하는 실제 작업은 최상위 수준의 삽입, 업데이트 또는 삭제 계획 노드에 의해 수행됩니다. 이 노드 아래의 계획 노드는 이전 행을 찾고 새 데이터를 계산하는 작업을 수행합니다. 위와 같이, 우리는 이미 본 것과 같은 종류의 비트 맵 테이블 스캔을 보았으며 출력은 업데이트 된 행을 저장하는 업데이트 노드로 공급됩니다. 데이터 수정 노드가 상당한 양의 런타임을 소비 할 수 있지만 (여기서 시간을 엄청나게 소비하고 있음) 플래너는 현재 해당 작업을 설명하기 위해 비용 추정치에 아무것도 추가하지 않습니다. 수행 할 작업은 모든 올바른 쿼리 계획에 대해 동일하기 때문에 계획 결정에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">위에 표시된 것처럼 &lt;code&gt;union&lt;/code&gt; 함수의 첫 번째 &lt;code&gt;internal&lt;/code&gt; 인수는 실제로 &lt;code&gt;GistEntryVector&lt;/code&gt; 포인터입니다. 두 번째 인수는 정수 변수에 대한 포인터이며 무시할 수 있습니다. 이전에는 &lt;code&gt;union&lt;/code&gt; 함수가 결과 값의 크기를 해당 변수에 저장해야했지만 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">여기에 표시된대로 &lt;code&gt;rank&lt;/code&gt; 함수는 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 의해 정의 된 순서를 사용하여 현재 행의 파티션에서 각각의 고유 한 &lt;code&gt;ORDER BY&lt;/code&gt; 값에 대한 숫자 순위를 생성합니다 . &lt;code&gt;rank&lt;/code&gt; 는 동작이 &lt;code&gt;OVER&lt;/code&gt; 절에 의해 완전히 결정되므로 명시적인 매개 변수가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;표 37.2에&lt;/a&gt; 표시된 것처럼 btree 연산자 클래스는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 의 5 가지 비교 연산자를 제공해야합니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 도 연산자 클래스의 일부 여야한다고 기대할 수 있지만 인덱스 검색에서 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE 절 을 사용하는 것은 거의 유용하지 않기 때문에 그렇지 않습니다 . (계획자는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 btree 연산자 클래스와 관련된 것으로 취급 하지만 &lt;code&gt;pg_amop&lt;/code&gt; 대신 &lt;code&gt;=&lt;/code&gt; 연산자의 부정 자 링크 를 통해 해당 연산자를 찾습니다 .)</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;표 37.8에&lt;/a&gt; 표시된 것처럼 btree는 하나의 필수 및 두 개의 선택적 지원 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">이전 섹션에서 볼 수 있듯이 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 테이블 표현식 은 테이블, 뷰, 행 제거, 그룹화 등을 가능하게하여 중간 가상 테이블을 구성합니다.이 테이블은 최종적으로 &lt;em&gt;select list에&lt;/em&gt; 의해 처리로 전달됩니다 . 선택 목록 은 실제로 출력되는 중간 테이블의 &lt;em&gt;열&lt;/em&gt; 을 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">이전에 표시된 것처럼 복합 값을 쓸 때 개별 필드 값 주위에 큰 따옴표를 쓸 수 있습니다. 당신은 &lt;em&gt;해야한다&lt;/em&gt; 필드 값이 다른 복합 값 파서를 혼동한다면 그렇게. 특히 괄호, 쉼표, 큰 따옴표 또는 백 슬래시가 포함 된 필드는 큰 따옴표로 묶어야합니다. 인용 된 복합 필드 값에 큰 따옴표 또는 백 슬래시를 넣으려면 백 슬래시를 앞에 추가하십시오. 또한 큰 따옴표로 묶인 필드 값 내의 큰 따옴표 쌍은 SQL 리터럴 문자열의 작은 따옴표 규칙과 마찬가지로 큰 따옴표 문자를 나타 내기 위해 사용됩니다. 또는 인용 부호를 피하고 백 슬래시 이스케이프를 사용하여 보호 할 수 있습니다. 그렇지 않으면 복합 구문으로 간주되는 모든 데이터 문자</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">이전에 표시된 것처럼 배열 값을 쓸 때 개별 배열 요소 주위에 큰 따옴표를 사용할 수 있습니다. 당신은 &lt;em&gt;해야한다&lt;/em&gt; 요소 값이 다른 배열 값 파서를 혼동한다면 그렇게. 예를 들어 중괄호, 쉼표 (또는 데이터 형식의 구분 문자), 큰 따옴표, 백 슬래시 또는 선행 또는 후행 공백이 포함 된 요소는 큰 따옴표로 묶어야합니다. &lt;code&gt;NULL&lt;/code&gt; 이라는 단어와 일치하는 빈 문자열과 문자열 도 인용해야합니다. 큰 따옴표 또는 백 슬래시를 인용 배열 요소 값에 넣으려면 백 슬래시를 앞에옵니다. 또는 따옴표를 피하고 백 슬래시 이스케이프를 사용하여 배열 구문으로 간주되는 모든 데이터 문자를 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">표시된 것처럼 배열 데이터 유형은 배열 요소의 데이터 유형 이름에 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )를 추가하여 이름이 지정됩니다 . 위의 명령은 &lt;code&gt;text&lt;/code&gt; 유형의 열 ( &lt;code&gt;name&lt;/code&gt; ), &lt;code&gt;integer&lt;/code&gt; 유형의 1 차원 배열 ( &lt;code&gt;pay_by_quarter&lt;/code&gt; ), 분기 별 직원의 급여를 나타내는 2 차원 &lt;code&gt;text&lt;/code&gt; 배열 ( &lt;code&gt;schedule&lt;/code&gt; )을 가진 &lt;code&gt;sal_emp&lt;/code&gt; 라는 테이블을 작성 합니다. 직원의 주간 일정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">위의 예에서 알 수 있듯이 &lt;code&gt;tsquery&lt;/code&gt; 는 단순한 텍스트가 아니라 &lt;code&gt;tsvector&lt;/code&gt; 이상 입니다. &lt;code&gt;tsquery&lt;/code&gt; 는 이미 정규화 어휘이어야하며, 여러 용어, NOT 사용하여 AND, OR 결합 할 수 및 연산자 다음에 검색어가 포함되어 있습니다. 구문에 대한 자세한 내용 &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;은 8.11.2 절을&lt;/a&gt; 참조하십시오 . &lt;code&gt;to_tsquery&lt;/code&gt; , &lt;code&gt;plainto_tsquery&lt;/code&gt; 및 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 함수 는 주로 텍스트에 나타나는 단어를 정규화 하여 사용자 작성 텍스트를 적절한 &lt;code&gt;tsquery&lt;/code&gt; 로 변환하는 데 도움 이됩니다. 마찬가지로 &lt;code&gt;to_tsvector&lt;/code&gt; 문서 문자열을 구문 분석하고 정규화하는 데 사용됩니다. 실제로 텍스트 검색 일치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">마지막 예에서 알 수 있듯이 regexp split 함수는 문자열의 시작 또는 끝에서 또는 이전 일치 직후에 발생하는 길이가 0 인 일치를 무시합니다. 이는 &lt;code&gt;regexp_match&lt;/code&gt; 및 &lt;code&gt;regexp_matches&lt;/code&gt; 에 의해 구현되는 regexp 일치의 엄격한 정의와는 상반 되지만 일반적으로 실제로 가장 편리한 동작입니다. Perl과 같은 다른 소프트웨어 시스템은 유사한 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">일반적으로 행의 널값은 SQL 부울 표현식의 일반 규칙에 따라 결합됩니다. 해당하는 모든 멤버가 널이 아니고 같으면 두 행이 동일한 것으로 간주됩니다. 대응하는 멤버가 널이 아니거나 같으면 행이 동일하지 않습니다. 그렇지 않으면 해당 행 비교 결과를 알 수 없습니다 (널). 모든 행당 결과가 동일하지 않거나 널이며, 하나 이상의 널이있는 경우 &lt;code&gt;IN&lt;/code&gt; 의 결과 는 널입니다.</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">일반적으로 행의 널값은 SQL 부울 표현식의 일반 규칙에 따라 결합됩니다. 해당하는 모든 멤버가 널이 아니고 같으면 두 행이 동일한 것으로 간주됩니다. 대응하는 멤버가 널이 아니거나 같으면 행이 동일하지 않습니다. 그렇지 않으면 해당 행 비교 결과를 알 수 없습니다 (널). 모든 행당 결과가 동일하지 않거나 널 (null 이상) 인 경우 &lt;code&gt;NOT IN&lt;/code&gt; 의 결과 는 널입니다.</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">여기에서 볼 수 있듯이 JIT가 사용되었지만 인라인 및 고가의 최적화는 사용되지 않았습니다. 경우 &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost이&lt;/a&gt; 또한 감소되었다, 그 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">보시다시피 복잡한 테이블 계층에는 상당한 양의 DDL이 필요할 수 있습니다. 위의 예에서 우리는 매달 새로운 자식 테이블을 만들 것이므로 필요한 DDL을 자동으로 생성하는 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">이전 섹션에서 보았 듯이 쿼리 계획자는 쿼리 계획을 적절히 선택하기 위해 쿼리에서 검색 한 행 수를 추정해야합니다. 이 섹션에서는 시스템이 이러한 추정에 사용하는 통계를 간략하게 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; 와 마찬가지로 하위 쿼리가 완전히 평가된다고 가정하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 와 마찬가지로 백 슬래시는 이러한 메타 문자의 특수한 의미를 비활성화합니다. 또는 &lt;code&gt;ESCAPE&lt;/code&gt; 로 다른 이스케이프 문자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;SIMILAR TO&lt;/code&gt; , 지정된 패턴은 전체 데이터 문자열과 일치해야하며, 그렇지 않으면 함수가 실패하고 반환 널 (null). 일치하는 데이터 서브 스트링이 관심있는 패턴의 부분을 표시하려면 패턴에 두 개의 이스케이프 문자와 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 가 포함되어야합니다 . 이러한 구분 기호 사이의 패턴 부분과 일치하는 텍스트는 다음과 같습니다. 일치하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">처럼 &lt;code&gt;pgstattuple&lt;/code&gt; 결과는 페이지별로 누적하며, 전체 인덱스의 순간 스냅 샷을 나타내는 예상되지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">보안 설정과 마찬가지로 시스템이 예상대로 작동하는지 테스트하고 확인하는 것이 중요합니다. 위의 예를 사용하면 권한 시스템이 올바르게 작동하고 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">외부에서 액세스 할 수있는 서버 데몬과 마찬가지로 별도의 사용자 계정으로 PostgreSQL을 실행하는 것이 좋습니다. 이 사용자 계정은 서버에서 관리하는 데이터 만 소유해야하며 다른 데몬과 공유해서는 안됩니다. 예를 들어, &lt;code&gt;nobody&lt;/code&gt; 사용자를 사용 하는 것은 나쁜 생각입니다. 손상된 시스템은 자체 바이너리를 수정할 수 있으므로이 사용자가 소유 한 실행 파일을 설치하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">기본 백업과 마찬가지로 독립형 핫 백업을 생성하는 가장 쉬운 방법은 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; 도구 를 사용하는 것 입니다. 호출 할 때 &lt;code&gt;-X&lt;/code&gt; 매개 변수 를 포함하면 백업을 사용하는 데 필요한 모든 미리 쓰기 로그가 자동으로 백업에 포함되며 백업을 복원하기 위해 특별한 조치가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">열을 삭제하는 것과 마찬가지로 다른 항목이 의존하는 제약 조건을 삭제하려면 &lt;code&gt;CASCADE&lt;/code&gt; 를 추가해야합니다 . 외래 키 제약 조건은 참조 된 열의 고유 또는 기본 키 제약 조건에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">다른 PostgreSQL 텍스트 검색 구성 파일과 마찬가지로 규칙 파일은 UTF-8 인코딩으로 저장해야합니다. 데이터는로드 될 때 현재 데이터베이스의 인코딩으로 자동 변환됩니다. 변환 할 수없는 문자를 포함하는 모든 행은 자동으로 무시되므로 규칙 파일에 현재 인코딩에 적용 할 수없는 규칙이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">일반 파일 시스템 백업 기술과 마찬가지로이 방법은 서브 세트가 아닌 전체 데이터베이스 클러스터의 복원 만 지원할 수 있습니다. 또한, 많은 아카이브 스토리지가 필요합니다. 기본 백업은 부피가 클 수 있으며 사용량이 많은 시스템은 아카이브해야하는 많은 메가 바이트의 WAL 트래픽을 생성합니다. 그러나 높은 안정성이 필요한 여러 상황에서 선호되는 백업 기술입니다.</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">공간 복구를 진공 청소기로 청소하는 경우와 같이 자주 업데이트되는 테이블보다 자주 업데이트되는 테이블에 통계를 자주 업데이트하는 것이 더 유용합니다. 그러나 과도하게 업데이트 된 테이블의 경우에도 데이터의 통계적 분포가 크게 변하지 않으면 통계 업데이트가 필요하지 않을 수 있습니다. 간단한 경험 법칙은 테이블에서 열의 최소값과 최대 값이 얼마나 많이 변경되는지 생각하는 것입니다. 예를 들어 &lt;code&gt;timestamp&lt;/code&gt; 행 업데이트 시간이 포함 된 열은 행이 추가 및 업데이트 될 때 지속적으로 증가하는 최대 값을 갖습니다. 이러한 항목은 웹 사이트에서 액세스하는 페이지의 URL이 포함 된 항목보다 통계 업데이트가 더 자주 필요할 수 있습니다. URL 열은 자주 변경 사항을 수신 할 수 있지만 해당 값의 통계적 분포는 상대적으로 느리게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">보시다시피이 골격에서 &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; 데이터 유형을 처리 합니다. 이 GiST 지원 방법에 적절한 통합 알고리즘을 구현하여 그렇지 않은 경우 데이터 유형을 지원하기가 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">보시다시피 pg_dump는 결과를 표준 출력에 씁니다. 우리는 이것이 어떻게 유용한 지 아래에서 볼 것입니다. 위 명령이 텍스트 파일을 생성하는 동안 pg_dump는 다른 형식으로 파일을 생성하여 병렬 및보다 세밀한 객체 복원 제어를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">보시다시피 제약 조건 정의는 기본값 정의와 마찬가지로 데이터 유형 뒤에옵니다. 기본값 및 제약 조건은 임의의 순서로 나열 될 수 있습니다. 점검 제한 조건은 키워드 &lt;code&gt;CHECK&lt;/code&gt; 와 괄호 안의 표현식으로 구성됩니다. 점검 제한 조건 표현식은 이와 같이 제한된 열을 포함해야합니다. 그렇지 않으면 제한 조건이 너무 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">보시다시피, 새로운 값에 대한 표현식은 행의 기존 값을 참조 할 수 있습니다. 우리는 또한 &lt;code&gt;WHERE&lt;/code&gt; 절을 생략했습니다 . 생략하면 테이블의 모든 행이 업데이트됨을 의미합니다. 존재하는 경우 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 일치하는 행만 업데이트됩니다. &lt;code&gt;SET&lt;/code&gt; 절의 등호 는 할당이지만 &lt;code&gt;WHERE&lt;/code&gt; 절의 등호 는 비교이지만 모호성을 생성하지는 않습니다. 물론 &lt;code&gt;WHERE&lt;/code&gt; 조건은 평등 테스트 일 필요는 없습니다. 다른 많은 연산자도 사용할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 참조 ). 그러나 표현식은 부울 결과로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">아카이버 또는 WAL 발신자가 WAL 데이터를 처리하는 시간을 피하는 것 외에도 &lt;code&gt;wal_level&lt;/code&gt; 이 &lt;code&gt;minimal&lt;/code&gt; 경우 WAL을 전혀 쓰지 않도록 설계되어 있기 때문에 실제로는 특정 명령이 더 빨라 집니다. ( WAL을 작성하는 것보다 끝에 &lt;code&gt;fsync&lt;/code&gt; 를 수행하면 충돌 안전을보다 저렴하게 보장 할 수 있습니다 .) 이는 다음 명령에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">사이클을 방지하는 것 외에도 배열 값은 특정 행에 도달하기 위해 &quot;경로&quot;를 나타내는 것으로 종종 그 자체로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">인덱스 자체의 내부 일관성 요구 사항 외에도 동시 업데이트는 상위 테이블 ( &lt;em&gt;heap&lt;/em&gt; )과 인덱스 간의 일관성에 대한 문제를 만듭니다 . PostgreSQL은 힙 액세스 및 업데이트를 인덱스의 액세스 및 업데이트와 분리하므로 인덱스가 힙과 일치하지 않는 창이 있습니다. 우리는이 규칙을 다음 규칙으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">열 리터럴 상수 기본값 할당 &lt;code&gt;name&lt;/code&gt; 칼럼의 기본값을 준비하는 단계, &lt;code&gt;did&lt;/code&gt; 시퀀스 오브젝트의 다음 값을 선택함으로써 생성하고, 디폴트 값을 확인 &lt;code&gt;modtime&lt;/code&gt; 가 로우가 삽입되는 시점 일 :</target>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">연관된 정렬 연산자 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">다음과 같은 테이블을 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; 라는 데이터베이스를 사용자 정의 형식 덤프 파일로 덤프했다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">테이블 불리는이 있다고 가정하면 &lt;code&gt;table1&lt;/code&gt; ,이 명령은 모든 행과 모든 사용자 정의 열을 검색 할 &lt;code&gt;table1&lt;/code&gt; . (검색 방법은 클라이언트 응용 프로그램에 따라 다릅니다. 예를 들어, psql 프로그램은 화면에 ASCII 아트 테이블을 표시하고 클라이언트 라이브러리는 조회 결과에서 개별 값을 추출하는 기능을 제공합니다.) 선택 목록 스펙 &lt;code&gt;*&lt;/code&gt; 은 테이블 표현식이 제공하는 모든 열. 선택 목록은 사용 가능한 열의 서브 세트를 선택하거나 열을 사용하여 계산할 수도 있습니다. 예를 들어 &lt;code&gt;table1&lt;/code&gt; 에 이름이 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 인 열이 있는 경우 (그리고 아마도 다른 사람들) 다음 쿼리를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">비동기 커밋</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">비동기 I / O는 일부 운영 체제에없는 효과적인 &lt;code&gt;posix_fadvise&lt;/code&gt; 기능 에 의존합니다 . 기능이 없으면이 매개 변수를 0 이외의 값으로 설정하면 오류가 발생합니다. 일부 운영 체제 (예 : Solaris)에서는 기능이 있지만 실제로는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">비동기 멀티 마스터 복제</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">비동기 커밋은 데이터 손실의 위험이 있습니다. 클라이언트에 대한 트랜잭션 완료 보고서와 트랜잭션이 실제로 커밋 된 시간 사이에 짧은 시간 창이 있습니다 (즉, 서버가 충돌해도 손실되지 않음). 따라서 클라이언트가 트랜잭션이 기억 될 것이라는 가정에 의존하여 외부 조치를 취할 경우 비동기 커밋을 사용해서는 안됩니다. 예를 들어, 은행은 ATM의 현금 분배를 기록하는 트랜잭션에 대해 비동기 커밋을 사용하지 않을 것입니다. 그러나 이벤트 로깅과 같은 많은 시나리오에서는 이러한 종류의 강력한 보장이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">비동기 커밋은 &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off 설정과 다른 동작을 제공합니다 . &lt;code&gt;fsync&lt;/code&gt; 는 모든 트랜잭션의 동작을 변경하는 서버 전체 설정입니다. PostgreSQL 내에서 데이터베이스의 다른 부분에 대한 쓰기 동기화를 시도하는 모든 논리를 비활성화하므로 시스템 충돌 (PostgreSQL 자체의 장애가 아닌 하드웨어 또는 운영 체제 충돌)으로 인해 데이터베이스가 임의로 손상 될 수 있습니다. 상태. 많은 시나리오에서 비동기 커밋은 &lt;code&gt;fsync&lt;/code&gt; 를 해제하여 얻을 수 있지만 데이터 손상의 위험없이 얻을 수있는 대부분의 성능 향상을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">좀 더 기본적으로 TSP를 위해 설계된 GA 알고리즘으로 쿼리 최적화를 해결하는 것이 적절한 지 확실하지 않습니다. TSP의 경우 하위 문자열 (부분 둘러보기)과 관련된 비용은 나머지 둘러보기와 무관하지만 쿼리 최적화에는 해당되지 않습니다. 따라서, 엣지 재조합 크로스 오버가 가장 효과적인 돌연변이 절차인지는 의문의 여지가있다.</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL 은 &lt;code&gt;pg_wal/&lt;/code&gt; 에 &lt;em&gt;미리 쓰기 로그&lt;/em&gt; (WAL)를 유지합니다클러스터 데이터 디렉토리의 서브 디렉토리. 로그는 데이터베이스의 데이터 파일에 대한 모든 변경 사항을 기록합니다. 이 로그는 주로 충돌 안전을 위해 존재합니다. 시스템이 충돌하면 마지막 체크 포인트 이후에 작성된 로그 항목을 &quot;재생&quot;하여 데이터베이스를 일관성있게 복원 할 수 있습니다. 그러나 로그가 있으면 데이터베이스 백업을위한 세 번째 전략을 사용할 수 있습니다. 파일 시스템 수준 백업을 WAL 파일 백업과 결합 할 수 있습니다. 복구가 필요한 경우 파일 시스템 백업을 복원 한 다음 백업 된 WAL 파일에서 재생하여 시스템을 현재 상태로 만듭니다. 이 방법은 이전 방법 중 하나보다 관리하기가 더 복잡하지만 몇 가지 중요한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">컴파일시에, &lt;code&gt;transaction__start&lt;/code&gt; 은 매크로라고으로 변환됩니다 &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; 포함하여 볼 수 있습니다 (밑줄은 여기에 단 하나 통지), &lt;code&gt;pg_trace.h&lt;/code&gt; 을 . 소스 코드에서 적절한 위치에 매크로 호출을 추가하십시오. 이 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">버전 5.1 이상에서는 &lt;code&gt;SHMMAX&lt;/code&gt; 와 같은 매개 변수에 대해 특별한 구성을 수행 할 필요가 없습니다. 이는 모든 메모리를 공유 메모리로 사용할 수 있도록 구성된 것으로 보입니다. 이것이 DB / 2와 같은 다른 데이터베이스에 일반적으로 사용되는 일종의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">&lt;code&gt;LEFTARG&lt;/code&gt; 및 &lt;code&gt;RIGHTARG&lt;/code&gt; 중 하나 이상을 정의해야합니다. 이진 연산자의 경우 둘 다 정의해야합니다. 오른쪽 단항 연산자의 경우 &lt;code&gt;LEFTARG&lt;/code&gt; 만 정의하고 왼쪽 단항 연산자의 경우 &lt;code&gt;RIGHTARG&lt;/code&gt; 만 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">조치를 선택하려면 다음 옵션 중 하나 이상을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">이 두 가지 중 하나 이상이 보장되어야합니다. 그렇지 않으면 PostgreSQL 서버는 매우 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">구독 작업자에 대한 정보를 표시하는 구독 당 하나 이상의 행. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">현재 &lt;code&gt;WITH&lt;/code&gt; 에서 데이터 수정 명령문의 대상으로 사용되는 테이블 에는 조건문, &lt;code&gt;ALSO&lt;/code&gt; 규칙 또는 여러 명령문으로 확장 되는 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">현재, 정렬 연산자의 정렬 순서는 참조 된 연산자 제품군의 기본값 인 것으로 가정합니다 (예 : &lt;code&gt;ASC NULLS LAST&lt;/code&gt; ) . 정렬 옵션을 명시 적으로 지정하기 위해 추가 열을 추가하여 언젠가 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">현재 &lt;code&gt;soundex&lt;/code&gt; , &lt;code&gt;metaphone&lt;/code&gt; , &lt;code&gt;dmetaphone&lt;/code&gt; 및 &lt;code&gt;dmetaphone_alt&lt;/code&gt; 함수는 멀티 바이트 인코딩 (예 : UTF-8)에서 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">현재이 설정은 Linux 및 Windows에서만 지원됩니다. &lt;code&gt;try&lt;/code&gt; 로 설정하면 다른 시스템에서 설정이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">시작시 대기는 아카이브 위치에서 사용 가능한 모든 WAL을 복원하여 &lt;code&gt;restore_command&lt;/code&gt; 를 호출하여 시작합니다 . 사용 가능한 WAL의 끝에 도달하고 &lt;code&gt;restore_command&lt;/code&gt; 가 실패하면 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 에서 사용 가능한 WAL을 복원하려고 시도합니다 . 실패하고 스트리밍 복제가 구성된 경우 대기는 기본 서버에 연결을 시도하고 archive 또는 &lt;code&gt;pg_wal&lt;/code&gt; 에있는 마지막 유효한 레코드에서 스트리밍 WAL을 시작합니다 . 실패하거나 스트리밍 복제가 구성되지 않았거나 나중에 연결이 끊어지면 대기는 1 단계로 돌아가서 아카이브에서 파일을 다시 복원하려고합니다. 아카이브 &lt;code&gt;pg_wal&lt;/code&gt; 에서이 재시도 루프, 스트리밍 복제를 통해 서버가 중지되거나 장애 조치가 트리거 파일에 의해 트리거 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">상기 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 또는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션 격리 수준이 (A와 직렬화 실패 원인이 &lt;code&gt;SQLSTATE&lt;/code&gt; 의 &lt;code&gt;'40001'&lt;/code&gt; 때문에 이러한 격리 수준에 따라 순서가 열을받을 가능성은 없다).</target>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">백업 시작시 백업을 수행 한 서버에 체크 포인트를 작성해야합니다. 특히 &lt;code&gt;--checkpoint=fast&lt;/code&gt; 옵션을 사용하지 않으면 pg_basebackup이 유휴 상태 인 것으로 표시되는 데 다소 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">기본 &quot;스케일 팩터&quot;1 인 테이블에는 처음에 다음과 같은 많은 행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">각 세션이 끝나면 &lt;code&gt;UNLISTEN *&lt;/code&gt; 가 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">복구가 완료되면 준비된 트랜잭션이 보유한 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 에는 일반 잠금 테이블 항목 수의 두 배가 필요합니다. 당신이 일반적으로 가지고 동시 준비 많은 트랜잭션 중 하나를 실행하려는 경우 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 을 많이 필요 하나의 큰 거래가있는에, 또는 당신이 계획 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 을 , 당신의 더 큰 값을 선택하는 것이 좋다 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; 를 두 배의 값으로 아마만큼, 기본 서버의 매개 변수 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 의 설정 이 0 인 경우이를 고려할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">프롬프트에서 사용자는 SQL 명령을 입력 할 수 있습니다. 일반적으로 명령 종료 세미콜론에 도달하면 입력 라인이 서버로 전송됩니다. 줄의 끝은 명령을 종료하지 않습니다. 따라서 명령을 명확하게하기 위해 여러 줄로 분산시킬 수 있습니다. 명령이 오류없이 전송되고 실행 된 경우 명령 결과가 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">동시에 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 는 두 번째 문자열에서 단어의 범위를 선택합니다. 위의 예에서 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 는 단일 단어 &lt;code&gt;'words'&lt;/code&gt; 의 범위를 선택합니다.이 단어 의 트라이 그램은 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">작성시, 기존의 모든 힙 페이지가 스캔되고 끝에 불완전한 범위를 포함하여 각 범위에 대한 요약 색인 튜플이 작성됩니다. 새 페이지에 데이터가 채워지면 이미 요약 된 페이지 범위로 인해 요약 정보가 새 튜플의 데이터로 업데이트됩니다. 마지막 요약 된 범위에 속하지 않는 새 페이지가 작성되면 해당 범위는 자동으로 요약 튜플을 얻지 않습니다. 이러한 튜플은 나중에 요약 실행을 호출하여 초기 요약을 생성 할 때까지 요약되지 않은 상태로 유지됩니다. 이 프로세스는 &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; 또는 &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; 함수를 사용하여 수동으로 호출 할 수 있습니다 . &lt;code&gt;VACUUM&lt;/code&gt; 일 때 자동테이블을 처리합니다. 또는 삽입이 발생할 때 autovacuum에 의해 실행되는 자동 요약에 의해. (이 마지막 트리거는 기본적으로 비활성화되어 있으며 &lt;code&gt;autosummarize&lt;/code&gt; 매개 변수를 사용하여 활성화 할 수 있습니다 .) 반대로, &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; 함수를 사용하여 범위를 요약 해제 할 수 있습니다 . 이는 인덱스 튜플이 더 이상 좋지 않을 때 유용합니다. 기존 값이 변경 되었기 때문에 표현.</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">이 시점에서 &lt;code&gt;pg_proc.dat&lt;/code&gt; 에는 기본값이 아닌 행에만 표시되지만 &lt;code&gt;prokind&lt;/code&gt; , &lt;code&gt;proisagg&lt;/code&gt; 및 &lt;code&gt;proiswindow&lt;/code&gt; 의 세 열이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">이 시점에서 유사도 검색에 사용할 수 있는 &lt;code&gt;t&lt;/code&gt; 열에 인덱스가 있습니다 . 일반적인 검색어는</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">이 글을 작성할 때 연속 보관 기술에는 몇 가지 제한 사항이 있습니다. 다음 릴리스에서 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mytable&lt;/code&gt; 테이블에 주석을 첨부하십시오 .</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">파티션을 연결하면 연결될 테이블 및 기본 파티션 (있는 경우)의 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 외에 상위 테이블에서 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금이 획득 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">코어 파일에 대한 소프트 자원 제한을 해제하여 서버 크래쉬가 가능한 경우 플랫폼에서 코어 파일을 생성하도록 시도하십시오. 이는 실패한 서버 프로세스에서 스택 추적을 확보하여 문제점을 디버깅하거나 진단하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">재고 수량과 함께 새로운 재고 품목을 삽입하십시오. 품목이 이미 존재하는 경우 기존 품목의 재고 수를 업데이트하십시오. 전체 트랜잭션에 실패하지 않고이를 수행하려면 저장 점을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">존재하지 않는 테이블을 삭제하려고하면 오류가 발생합니다. 그럼에도 불구하고 SQL 스크립트 파일에서는 테이블을 생성하기 전에 각 테이블을 무조건 삭제 (drop)하여 오류 메시지를 무시하는 것이 일반적이므로 테이블 존재 여부에 관계없이 스크립트가 작동합니다. 원하는 경우 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 변형을 사용하여 오류 메시지를 피할 수 있지만 이는 표준 SQL이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">ISO 8601 주 번호 매기기 필드와 그레고리력 날짜 필드를 혼합하여 날짜를 입력하려고하면 의미가 없으므로 오류가 발생합니다. ISO 8601 주 번호 연도의 맥락에서 &quot;달&quot;또는 &quot;달의 날&quot;이라는 개념은 의미가 없습니다. 그레고리력 연도의 맥락에서 ISO 주간은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">검색 + 바인드 인증을 수행 할 때 검색의 사용자 이름과 일치하는 속성입니다. 속성이 지정되지 않으면 &lt;code&gt;uid&lt;/code&gt; 속성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 속성 수준 외부 데이터 래퍼 옵션</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&quot;keyword = value&quot;문자열과 같은 속성 수준 옵션</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">SSL 클라이언트 인증서를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-cert&quot;&gt;은 20.12 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">RADIUS 서버를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-radius&quot;&gt;은 20.11 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">LDAP 서버를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-ldap&quot;&gt;은 20.10 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 제공하는 BSD 인증 서비스를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-bsd&quot;&gt;은 20.14 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 제공하는 PAM (Pluggable Authentication Modules) 서비스를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-pam&quot;&gt;은 20.13 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">인증 방법</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">인증 문제</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">인증 실패 및 관련 문제는 일반적으로 다음과 같은 오류 메시지를 통해 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">인증 방법</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">자동 진공 청소</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">인덱스의 구조적 무결성에 대한 자동 검증은 논리적으로 불일치를 도입 할 수있는 새로운 또는 제안 된 PostgreSQL 기능의 일반적인 테스트에서 중요한 역할을합니다. 테이블 구조 확인 및 관련 가시성 및 트랜잭션 상태 정보도 비슷한 역할을합니다. 명백한 테스트 전략 중 하나 는 표준 회귀 테스트를 실행할 때 &lt;code&gt;amcheck&lt;/code&gt; 함수를 계속 호출 하는 것입니다. 테스트 실행에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;섹션 32.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">스키마에 포함 된 객체 (테이블, 함수 등)를 자동으로 삭제하고 해당 객체에 종속 된 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">액세스 방법에 의존하는 객체 (예 : 연산자 클래스, 운영자 패밀리 및 색인)를 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;5.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">영향을받는 객체에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">집계 함수 (예 : 함수를 사용하는 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">데이터 정렬에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">구속 조건에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">도메인에 의존하는 객체 (예 : 테이블 열)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">삭제 된 열 또는 제약 조건 (예 : 열을 참조하는 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">확장에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">외부 테이블 (예 : 뷰)에 의존하는 오브젝트를 자동으로 삭제하고 해당 오브젝트에 의존하는 모든 오브젝트를 차례로 삭제하십시오 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">외부 데이터 랩퍼 (예 : 외부 테이블 및 서버)에 의존하는 오브젝트를 자동으로 삭제하고 해당 오브젝트에 종속 된 모든 오브젝트를 차례로 삭제하십시오 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">기능에 의존하는 객체 (예 : 연산자 또는 트리거)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">색인에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">언어에 의존하는 객체 (예 : 언어 기능)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">구체화 된 뷰 (예 : 다른 구체화 된 뷰 또는 일반 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 놓습니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">연산자에 의존하는 객체 (예 : 뷰를 사용하는 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">연산자 클래스 (예 : 인덱스)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">운영자 제품군에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">절차에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">규칙에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">시퀀스에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">서버에 의존하는 객체 (예 : 사용자 매핑)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">테이블에 의존하는 객체 (예 : 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 구성에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 사전에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 파서에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 템플릿에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">변환에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">트리거에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">유형에 의존하는 객체 (예 : 테이블 열, 함수 및 연산자)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">뷰에 의존하는 객체 (예 : 다른 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">SQL 코드에서 특정 C 코드를 자동으로 생성합니다. 현재 이것은 &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">이 확장이 종속되지 않은 확장을 아직 설치하지 않은 경우 자동으로 설치하십시오. 그들의 의존성은 마찬가지로 자동적으로 재귀 적으로 설치됩니다. &lt;code&gt;SCHEMA&lt;/code&gt; 가 주어진다면 절은, 이런 식으로 설치 얻을 모든 확장에 적용됩니다. 명령문의 다른 옵션은 자동으로 설치된 확장에 적용되지 않습니다. 특히 기본 버전이 항상 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">조작을 변경중인 유형의 유형이 지정된 테이블 및 해당 하위 항목으로 자동 전파합니다.</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">잘린 테이블의 열이 소유 한 시퀀스를 자동으로 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">수신이 지정된 LSN에 도달하면 복제를 자동으로 중지하고 정상 종료 상태 0으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">이름 지정된 테이블 또는 &lt;code&gt;CASCADE&lt;/code&gt; 로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자동으로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">Autovacuum은 복구 중에 활성화되지 않습니다. 복구가 끝나면 정상적으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">Autovacuum Worker 또는 Launcher가 Autovacuum Worker의 현재 상태를 업데이트하거나 읽기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">Autovacuum 작업자는 일반적으로 다른 명령을 차단하지 않습니다. 프로세스가 autovacuum이 보유한 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 과 충돌하는 잠금을 획득하려고 시도하면 잠금 획득이 자동 진공을 중단시킵니다. 충돌하는 잠금 모드는 &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;표 13.2를&lt;/a&gt; 참조하십시오 . 그러나 트랜잭션 ID 랩 어라운드를 방지하기 위해 autovacuum이 실행중인 경우 (즉, &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기 의 autovacuum 쿼리 이름 이 &lt;code&gt;(to prevent wraparound)&lt;/code&gt; 끝남 ) autovacuum은 자동으로 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">사용 가능한 클라이언트 문자 세트</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">사용 가능한 암호 제품군 세부 사항은 OpenSSL 버전에 따라 다릅니다. &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; 명령을 사용하여 현재 설치된 OpenSSL 버전에 대한 실제 세부 사항을보십시오. 이 목록은 서버 키 유형을 기반으로 런타임에 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">리프 페이지의 평균 밀도</target>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">열 항목의 평균 너비 (바이트)</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">B- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">B- 트리 지원 기능</target>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">여러 데이터 유형에 대한 B- 트리 동등한 기능</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 를 통한 B- 트리 인덱스 : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">완전히 비워진 B- 트리 인덱스 페이지는 재사용을 위해 회수됩니다. 그러나 여전히 공간을 비효율적으로 사용할 가능성이 있습니다. 페이지에서 몇 개의 인덱스 키를 제외한 모든 키가 삭제 된 경우 페이지는 할당 된 상태로 유지됩니다. 따라서 각 범위에있는 대부분의 키가 결국 삭제되는 사용 패턴은 공간을 제대로 사용하지 않습니다. 이러한 사용 패턴의 경우 주기적 재색 인화가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">B- 트리 색인은이 매개 변수를 추가로 승인합니다.</target>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">B- 트리 인덱스를 사용하여 정렬 된 순서로 데이터를 검색 할 수도 있습니다. 이것은 간단한 스캔 및 정렬보다 항상 빠르지는 않지만 종종 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">B- 트리 버전 번호</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B- 트리, GiST 및 SP-GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B- 트리는 일부 순서로 정렬 할 수있는 데이터에 대해 동등 및 범위 쿼리를 처리 할 수 ​​있습니다. 특히 PostgreSQL 쿼리 플래너는 인덱싱 된 열이 다음 연산자 중 하나를 사용하여 비교할 때마다 B- 트리 인덱스 사용을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1. 날짜 / 시간 입력 해석</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2. 유효하지 않거나 모호한 타임 스탬프 처리</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3. 날짜 / 시간 키워드</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4. 날짜 / 시간 구성 파일</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5. 단위의 역사</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">BEGIN &amp;mdash; 거래 블록을 시작합니다</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">큰 수학</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BRE는 여러 측면에서 ERE와 다릅니다. BRE에서 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; 일반 문자이며 해당 기능에 해당하는 문자가 없습니다. 범위의 구분 기호는 &lt;code&gt;\{&lt;/code&gt; 및 &lt;code&gt;\}&lt;/code&gt; 이며 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 자체는 일반 문자입니다. 중첩 된 하위 표현식의 괄호는 &lt;code&gt;\(&lt;/code&gt; 및 &lt;code&gt;\)&lt;/code&gt; 이며, 그 자체로 일반 문자 가 &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 입니다. &lt;code&gt;^&lt;/code&gt; 는 RE의 시작 또는 괄호로 묶인 하위 표현식의 시작 ( &lt;code&gt;$&lt;/code&gt; )을 제외한 일반 문자입니다.RE의 끝 또는 괄호로 묶인 하위 표현식의 끝을 제외하고는 일반 문자이며 &lt;code&gt;*&lt;/code&gt; 는 RE의 시작 또는 괄호로 묶인 하위 표현식의 시작 부분에 나타날 수있는 경우 일반 문자입니다 (가능한 선행 &lt;code&gt;^&lt;/code&gt; 후 ). 마지막으로 한 자리 역 참조가 가능하며 &lt;code&gt;\&amp;lt;&lt;/code&gt; 및 &lt;code&gt;\&amp;gt;&lt;/code&gt; 는 각각 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 및 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 의 동의어입니다 . BRE에는 다른 탈출구가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">BRIN 색인 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">BRIN 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRIN 인덱스 (블록 범위 INdexe의 약어)는 테이블의 연속적인 물리적 블록 범위에 저장된 값에 대한 요약을 저장합니다. GiST, SP-GiST 및 GIN과 같이 BRIN은 다양한 인덱싱 전략을 지원할 수 있으며 BRIN 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략에 따라 다릅니다. 선형 정렬 순서가있는 데이터 형식의 경우 인덱스 된 데이터는 각 블록 범위에 대한 열 값의 최소값과 최대 값에 해당합니다. 이는 다음 연산자를 사용하여 인덱스 된 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRIN 색인은 다른 매개 변수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">BRIN 인덱스는 정기적 인 비트 맵 인덱스 스캔을 통해 쿼리를 만족시킬 수 있으며 인덱스에 저장된 요약 정보 가 쿼리 조건과 &lt;em&gt;일치&lt;/em&gt; 하면 각 범위 내의 모든 페이지에있는 모든 튜플을 반환합니다 . 쿼리 실행자는 이러한 튜플을 다시 확인하고 쿼리 조건과 일치하지 않는 튜플을 삭제해야합니다. 즉, 이러한 인덱스는 손실됩니다. BRIN 색인이 매우 작기 때문에 색인을 스캔하면 순차 스캔에 비해 오버 헤드가 거의 발생하지 않지만 일치하는 튜플을 포함하지 않는 것으로 알려진 테이블의 많은 부분을 스캔하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRIN은 블록 범위 색인을 나타냅니다. BRIN은 특정 열이 테이블 내의 실제 위치와 자연적으로 상관되는 매우 큰 테이블을 처리하도록 설계되었습니다. &lt;em&gt;블록 범위는&lt;/em&gt; 표에서 물리적으로 인접하는 페이지의 그룹이고; 각 블록 범위에 대해 일부 요약 정보가 색인에 의해 저장됩니다. 예를 들어, 상점의 판매 주문을 저장하는 테이블에는 각 주문이 작성된 날짜 열이있을 수 있으며 대부분의 경우 이전 주문에 대한 항목도 테이블에서 더 일찍 나타납니다. 우편 번호 열을 저장하는 테이블은 도시에 대한 모든 코드를 자연스럽게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">BSD 인증</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">PostgreSQL의 BSD 인증은 &lt;code&gt;auth-postgresql&lt;/code&gt; 로그인 유형을 사용하고 &lt;code&gt;login.conf&lt;/code&gt; 에 정의 된 경우 &lt;code&gt;postgresql&lt;/code&gt; 로그인 클래스로 인증합니다 . 기본적으로 로그인 클래스는 존재하지 않으며 PostgreSQL은 기본 로그인 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">백엔드 인터페이스</target>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">백 슬래시 &lt;code&gt;x&lt;/code&gt; 뒤에 1 ~ 2 개의 16 진 숫자가 표시되어 해당 숫자 코드로 문자를 지정합니다</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">백 슬래시 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 데이터 에서 백 슬래시 문자 ( &lt;code&gt;\&lt;/code&gt; )를 사용하여 행 또는 열 구분 기호 로 사용할 수있는 데이터 문자를 인용 할 수 있습니다. 특히, 백 슬래시 자체, 개행 문자, 캐리지 리턴 및 현재 구분 기호 문자와 같이 열 값의 일부로 표시되는 문자 &lt;em&gt;는&lt;/em&gt; 백 슬래시 앞에 와야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">백 슬래시 다음에 1 ~ 3 개의 8 진수가 해당 숫자 코드로 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">백 슬래시-세미콜론은 이전 명령과 같은 방식으로 메타 명령이 아닙니다. 오히려 추가 처리없이 쿼리 버퍼에 세미콜론이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">백 스페이스 (ASCII 8)</target>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">백업 및 복원</target>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 시스템 컬럼 을 제거하기위한 이전 버전과의 호환성 구문 으로 &lt;code&gt;oid&lt;/code&gt; 시스템 열을 더 이상 추가 할 수 없습니다, 이것은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">쿼리에 &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 가 포함되어 있으면 뒤로 가져 오기도 허용되지 않습니다 . 따라서이 경우 &lt;code&gt;SCROLL&lt;/code&gt; 을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 시스템 컬럼 을 제거하기위한 이전 버전과 호환되는 구문 . 으로 &lt;code&gt;oid&lt;/code&gt; 시스템 열을 더 이상 추가 할 수 없습니다, 이것은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">기본적으로 동의어 사전은 모든 비선호 용어를 하나의 선호 용어로 대체하고 선택적으로 색인을 위해 원래 용어도 보존합니다. PostgreSQL의 현재 시소러스 사전의 구현은 &lt;em&gt;구문&lt;/em&gt; 지원 이 추가 된 동의어 사전의 확장입니다 . 동의어 사전에는 다음 형식의 구성 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">한 번에 하나씩이 아니라 3 시간마다 전송되도록 WAL 파일 배치</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">그러나 이러한 쿼리는 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">주의하십시오 &lt;code&gt;COPY&lt;/code&gt; 이 규칙을 무시합니다. &lt;code&gt;COPY&lt;/code&gt; 를 사용 하여 데이터를 삽입하려면 마스터에 직접 저장하지 않고 올바른 하위 테이블에 복사해야합니다. &lt;code&gt;COPY&lt;/code&gt; 는 방아쇠를 사용하므로 방아쇠 접근 방식을 사용하면 정상적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">보기 열의 이름과 유형이 원하는 방식으로 할당되도록주의하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">기존 &lt;code&gt;hstore&lt;/code&gt; 오브젝트 를 설치 한 스키마를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">&lt;code&gt;CREATEROLE&lt;/code&gt; 권한에 주의하십시오 . &lt;code&gt;CREATEROLE&lt;/code&gt; 역할의 권한에 대한 상속 개념은 없습니다 . 즉, 역할에 특정 권한이 없지만 다른 역할을 만들 수있는 경우에도 자신과 다른 권한으로 다른 역할을 쉽게 만들 수 있습니다 (수퍼 유저 권한으로 역할을 만드는 경우 제외). 역할 &quot;사용자&quot;가있는 경우 예를 들어, &lt;code&gt;CREATEROLE&lt;/code&gt; 의 특권이 아니라 &lt;code&gt;CREATEDB&lt;/code&gt; 의 권한을, 그럼에도 불구하고 그것은을 가진 새로운 역할을 만들 수 있습니다 &lt;code&gt;CREATEDB&lt;/code&gt; 의 권한을. 따라서 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한 이있는 역할을 거의 수퍼 유저 역할로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">백업에 데이터베이스 클러스터 디렉토리 아래의 모든 파일이 포함되어 있는지 확인하십시오 (예 : &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ). 이 디렉토리 아래에 있지 않은 테이블 공간을 사용하는 경우 테이블 공간도 포함 시키십시오 (백업이 기호 링크를 링크로 아카이브하는지 확인하십시오. 그렇지 않으면 복원이 테이블 공간을 손상시킵니다).</target>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">왜냐하면 &lt;code&gt;...&lt;/code&gt; 널리 데이터 소스로 사용되는, 그것의 다른 철자로 허용된다 &lt;code&gt;..&lt;/code&gt; . 불행히도, 이것은 파싱 모호성을 생성합니다 &lt;code&gt;0...23&lt;/code&gt; 의 상한 이 &lt;code&gt;23&lt;/code&gt; 또는 &lt;code&gt;0.23&lt;/code&gt; 인지 여부는 확실하지 않습니다 . 이것은 &lt;code&gt;seg&lt;/code&gt; 입력의 모든 숫자에서 소수점 앞에 적어도 하나의 숫자를 요구함으로써 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 는 어떤 인덱스가 클러스터링되는지 기억 하기 때문에 처음 수동으로 클러스터링하려는 테이블을 클러스터링 한 다음 매개 변수없이 &lt;code&gt;CLUSTER&lt;/code&gt; 를 실행하는 주기적 유지 보수 스크립트를 설정 하여 원하는 테이블이 주기적으로 재 클러스터됩니다.</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">때문에 &lt;code&gt;float8&lt;/code&gt; 가 의미있는 &quot;단계&quot;가없는, 우리는이 예에서 정규화 함수를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">때문에 &lt;code&gt;nextval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 에 통화가 롤백되지 않습니다 시퀀스 번호의 &quot;끊김없는&quot;할당이 필요한 경우, 시퀀스 객체는 사용할 수 없습니다. 카운터를 포함하는 테이블의 배타적 잠금을 사용하여 공백없는 할당을 구축 할 수 있습니다. 그러나이 솔루션은 특히 많은 트랜잭션이 시퀀스 번호를 동시에 필요로하는 경우 시퀀스 오브젝트보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">때문에 &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; 및 &lt;code&gt;bigserial&lt;/code&gt; 시퀀스를 사용하여 구현되며, 어떤 행이 이제까지 삭제되지 않은 경우에도, 열에 표시 값들의 시퀀스에서 &quot;홀&quot;또는 갭이있을 수있다. 해당 값을 포함하는 행이 테이블 열에 성공적으로 삽입되지 않은 경우에도 시퀀스에서 할당 된 값은 여전히 ​​&quot;사용&quot;됩니다. 예를 들어 삽입 트랜잭션이 롤백되는 경우에 발생할 수 있습니다. 참조 &lt;code&gt;nextval()&lt;/code&gt; 에서 &lt;a href=&quot;functions-sequence&quot;&gt;제 9.16&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">때문에 &lt;code&gt;to_tsvector&lt;/code&gt; ( &lt;code&gt;NULL&lt;/code&gt; 가 ) 반환 &lt;code&gt;NULL&lt;/code&gt; 을 , 사용하는 것이 좋습니다 &lt;code&gt;coalesce&lt;/code&gt; 필드가 null 수 있습니다 때마다. 구조화 된 문서에서 &lt;code&gt;tsvector&lt;/code&gt; 를 작성하기 위해 권장되는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">JSON 포함이 중첩되어 있으므로 적절한 쿼리에서 하위 오브젝트의 명시적인 선택을 건너 뛸 수 있습니다. 예를 들어 최상위 수준에 객체가 포함 된 &lt;code&gt;doc&lt;/code&gt; 열이 있고 대부분의 객체 에 하위 객체 배열이 포함 된 &lt;code&gt;tags&lt;/code&gt; 필드가 포함되어 있다고 가정 합니다. 이 쿼리는 &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; 를 모두 포함하는 하위 오브젝트가 나타나는 반면, &lt;code&gt;tags&lt;/code&gt; 배열 외부의 이러한 키는 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">PostgreSQL은 제약 조건 이름이 스키마 내에서 고유해야 할 필요는 없지만 (테이블 당), 지정된 제약 조건 이름과 일치하는 항목이 두 개 이상있을 수 있습니다. 이 경우 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 는 모든 경기에서 작동합니다. 스키마 한정이 아닌 이름의 경우 검색 경로의 일부 스키마에서 일치하는 항목이 발견되면 해당 경로의 후반에 나타나는 스키마는 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">PostgreSQL은 오픈 소스이고 쉽게 확장되므로 많은 회사에서 PostgreSQL을 채택하여 고유 한 장애 조치, 복제 및로드 밸런싱 기능을 갖춘 상용 폐쇄 소스 솔루션을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">커밋 된 읽기 모드는 해당 순간까지 커밋 된 모든 트랜잭션을 포함하는 새 스냅 샷으로 각 명령을 시작하므로 동일한 트랜잭션의 후속 명령은 어떤 경우에도 커밋 된 동시 트랜잭션의 영향을 보게됩니다. 위의 문제는 &lt;em&gt;단일&lt;/em&gt; 명령이 데이터베이스에 대해 일관된 뷰를 보는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WAL은 충돌 후 데이터베이스 파일 내용을 복원하므로 데이터 파일 또는 WAL 파일을 안정적으로 저장하기 위해 저널 파일 시스템이 필요하지 않습니다. 실제로 저널링 오버 헤드로 인해 특히 저널링으로 인해 파일 시스템 &lt;em&gt;데이터&lt;/em&gt; 가 디스크로 플러시되는 경우 성능이 저하 될 수 있습니다. 다행히 저널링 중 데이터 플러싱은 파일 시스템 마운트 옵션 (예 : Linux ext3 파일 시스템의 &lt;code&gt;data=writeback&lt;/code&gt; ) 을 사용하여 비활성화 할 수 있습니다 . 저널 파일 시스템은 충돌 후 부팅 속도를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">때문에 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 의 기능을 소유하는 사용자의 권한으로 실행, 관리는 기능이 오용되지 않도록 필요합니다. 보안을 위해 신뢰할 수없는 사용자가 쓸 수있는 스키마를 제외하도록 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 를 설정해야합니다. 이렇게하면 악의적 인 사용자가 함수에서 사용하려는 개체를 마스크하는 개체 (예 : 테이블, 함수 및 연산자)를 만들 수 없습니다. 이와 관련하여 특히 중요한 임시 테이블 스키마는 기본적으로 먼저 검색되며 일반적으로 누구나 쓸 수 있습니다. 임시 스키마를 마지막으로 검색하도록하여 보안 배열을 확보 할 수 있습니다. 이렇게하려면 &lt;code&gt;search_path&lt;/code&gt; 의 마지막 항목으로 &lt;code&gt;pg_temp&lt;/code&gt; 를 작성 하십시오 . 이 기능은 안전한 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;CSV&lt;/code&gt; 형식 의 특수 문자가 아니기 때문에 &lt;code&gt;\.&lt;/code&gt; 데이터 끝 마커 인 데이터 값으로 표시 될 수도 있습니다. 잘못된 해석을 피하려면 &lt;code&gt;\.&lt;/code&gt; 행에서 고독 항목으로 나타나는 데이터 값은 출력시 자동으로 인용되며 입력시 인용시 데이터 끝 마커로 해석되지 않습니다. 인용되지 않은 단일 열이 있고 값이 &lt;code&gt;\.&lt;/code&gt; 다른 응용 프로그램에서 만든 파일을로드하는 경우 입력 파일에서 해당 값을 인용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 열 은 인덱스 검색 키의 일부가 아니므로 인덱스가 처리 할 수있는 데이터 형식 일 필요는 없습니다. 단지 색인에 저장되며 색인 기계 장치에 의해 해석되지 않습니다. 또한 인덱스가 고유 인덱스 인 경우</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">관련 확장 모듈을로드하지 않은 프로세스에서 사용자 지정 옵션을 설정해야 할 수 있으므로 PostgreSQL은 두 부분으로 된 매개 변수 이름에 대한 설정을 허용합니다. 이러한 변수는 자리 표시 자로 취급되며이를 정의하는 모듈이로드 될 때까지 기능이 없습니다. 확장 모듈이로드되면 변수 정의를 추가하고 해당 정의에 따라 자리 표시 자 값을 변환하며 확장 이름으로 시작하는 인식 할 수없는 자리 표시 자에 대한 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">각 btree 연산자 클래스는 데이터 유형에 정렬 순서를 부과하기 때문에 btree 연산자 클래스 (또는 실제로 연산자 패밀리)는 PostgreSQL의 정렬 의미에 대한 일반적인 표현 및 이해로 사용되었습니다. 따라서, 그들은 btree 인덱스를 지원하는 데 필요한 것 이상의 기능을 얻었으며, btree AM과 거리가 먼 시스템의 일부를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">각 작업자는 계획의 병렬 부분을 완료하기 위해 실행하기 때문에 일반적인 쿼리 계획을 여러 작업자를 사용하여 실행할 수는 없습니다. 각 작업자는 출력 결과 집합의 전체 복사본을 생성하므로 쿼리가 정상보다 빠르게 실행되지는 않지만 잘못된 결과가 생성됩니다. 대신 계획의 병렬 부분은 쿼리 최적화 프로그램에 내부적으로 &lt;em&gt;부분 계획&lt;/em&gt; 으로 알려진 것이어야합니다 . 즉, 계획을 실행하는 각 프로세스가 협력 프로세스 중 하나에 의해 각 필수 출력 행이 생성되도록 보장하는 방식으로 출력 행의 서브 세트 만 생성하도록 구성되어야합니다. 일반적으로 이는 쿼리의 구동 테이블에 대한 스캔이 병렬 인식 스캔이어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">논리적 복제는 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;물리적 스트리밍 복제&lt;/a&gt; 와 유사한 아키텍처를 기반으로하기 때문에 게시 노드에서의 모니터링은 물리적 복제 마스터의 모니터링과 유사합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;섹션 26.2.5.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">MVCC로 인해 중복 항목이 인덱스에 실제로 존재하도록해야합니다. 항목은 단일 논리 행의 연속 버전을 참조 할 수 있습니다. 실제로 적용하려는 동작은 동일한 인덱스 키를 가진 두 개의 행을 MVCC 스냅 샷에 포함시킬 수 없다는 것입니다. 이것은 고유 인덱스에 새 행을 삽입 할 때 확인해야하는 다음과 같은 경우로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">때문에 제한의 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 로 , &lt;code&gt;ambulkdelete&lt;/code&gt; 힘의 필요가 많은 튜플이 삭제 될 때 한 번 이상 호출합니다. &lt;code&gt;stats&lt;/code&gt; 인수가이 인덱스에 대한 이전 호출의 결과이다 (이것은 내 첫 번째 통화 NULL이다 &lt;code&gt;VACUUM&lt;/code&gt; 의 동작). 이를 통해 AM은 전체 작업에서 통계를 축적 할 수 있습니다. 일반적으로 &lt;code&gt;ambulkdelete&lt;/code&gt; 는 전달 된 &lt;code&gt;stats&lt;/code&gt; 가 null이 아닌 경우 동일한 구조체를 수정하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">위의 규칙으로 인해 업데이트 명령이 일치하지 않는 스냅 샷을 볼 수 있습니다. 업데이트하려는 동일한 행에서 동시 업데이트 명령의 영향을 볼 수 있지만 다른 행에서 해당 명령의 영향을 볼 수는 없습니다. 데이터베이스에서. 이 동작으로 인해 커밋 된 읽기 모드는 복잡한 검색 조건이 포함 된 명령에 적합하지 않습니다. 그러나 더 간단한 경우에 적합합니다. 예를 들어 은행 잔고를 다음과 같은 거래로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">이 동작으로 인해 단일 복합 유형 인수를 사용하여 해당 복합 유형의 필드와 동일한 이름을 갖는 함수를 제공하는 것은 현명하지 않습니다. 모호성이있는 경우 field-name 구문을 사용하면 field-name 해석이 선택되고 function-call 구문을 사용하면 함수가 선택됩니다. 그러나 11 이전의 PostgreSQL 버전은 호출 구문에서 함수 호출이 필요하지 않은 한 항상 필드 이름 해석을 선택했습니다. 이전 버전에서 함수 해석을 강제하는 한 가지 방법은 함수 이름을 스키마로 &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; 즉, schema.func (compositevalue) 작성) .</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">이 동작으로 인해 단일 &lt;code&gt;-c&lt;/code&gt; 문자열 에 둘 이상의 SQL 명령을 넣는 경우 종종 예기치 않은 결과가 발생합니다. 반복 된 &lt;code&gt;-c&lt;/code&gt; 명령 을 사용 하거나 위의 그림과 같이 echo를 사용하거나 여기에있는 문서를 통해 psql의 표준 입력에 여러 명령을 공급하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">패치에 의해 할당 된 OID의 번호를 다시 매길 가능성이 있기 때문에 패치에 의해 할당 된 OID는 패치가 공식 릴리스에 포함될 때까지 안정적인 것으로 간주되어서는 안됩니다. 그러나 릴리스 된 후 수동으로 할당 된 개체 OID는 변경되지 않으므로 여러 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">이러한 불확실성으로 인해 하위 선택 내에서만 다른 테이블을 참조하는 것이 더 안전하지만 조인을 사용하는 것보다 읽기가 어렵고 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">옵티 마이저 통계는 &lt;code&gt;pg_upgrade&lt;/code&gt; 에 의해 전송되지 않기 때문에 업그레이드가 끝날 때 해당 정보를 재생성하는 명령을 실행하도록 지시됩니다. 새 클러스터와 일치하도록 연결 매개 변수를 설정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">pg_dump는 최신 버전의 PostgreSQL로 데이터를 전송하는 데 사용되므로 pg_dump의 출력은 pg_dump 버전보다 최신 PostgreSQL 서버 버전으로로드 될 것으로 예상 할 수 있습니다. pg_dump는 자체 버전보다 오래된 PostgreSQL 서버에서도 덤프 할 수 있습니다. (현재 버전 8.0으로 돌아가는 서버가 지원됩니다.) 그러나 pg_dump는 자체 주요 버전보다 최신 PostgreSQL 서버에서 덤프 할 수 없습니다. 유효하지 않은 덤프를 만들 위험보다는 시도조차 거부합니다. 또한 덤프가 해당 버전의 서버에서 가져온 경우에도 pg_dump의 출력을 이전 주요 버전의 서버로로드 할 수 있다는 보장은 없습니다. 이전 서버로 덤프 파일을로드하면 이전 서버에서 이해하지 못하는 구문을 제거하기 위해 덤프 파일을 수동으로 편집해야 할 수 있습니다. 의 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 이 옵션은 다른 PostgreSQL 버전에서 예약어 목록을 변경하여 발생하는 문제를 방지 할 수 있으므로 버전 간 경우에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">역할은 데이터베이스 객체를 소유 할 수 있고 다른 객체에 액세스 할 수있는 권한을 보유 할 수 있으므로 역할을 삭제하는 것은 종종 빠른 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 의 문제가 아닙니다 . 역할이 소유 한 모든 객체는 먼저 다른 소유자에게 삭제하거나 다시 할당해야합니다. 역할에 부여 된 모든 권한을 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">시퀀스는 비 트랜잭션이므로 트랜잭션이 롤백되면 &lt;code&gt;setval&lt;/code&gt; 에 의한 변경 사항은 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">그 날은 그 시간대의 봄을 향한 전이 날짜 였으므로, 오전 2시 30 분의 시민 시간은 없었습니다. 시계는 오전 2시 (EST)에서 오전 3시 (EST)로 전진했습니다. PostgreSQL은 주어진 시간을 표준 시간 (UTC-5) 인 것처럼 해석 한 다음 3:30 AM EDT (UTC-4)로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">&lt;code&gt;Finalize Aggregate&lt;/code&gt; 노드는 리더 프로세스에서 실행 되므로 입력 행 수와 비교하여 비교적 많은 수의 그룹을 생성하는 쿼리는 쿼리 플래너에 덜 적합합니다. 예를 들어 최악의 시나리오에서 &lt;code&gt;Finalize Aggregate&lt;/code&gt; 노드에 표시되는 그룹 수 는 &lt;code&gt;Partial Aggregate&lt;/code&gt; 단계 에서 모든 작업자 프로세스에 표시되는 입력 행 수만큼 될 수 있습니다 . 이러한 경우 병렬 집계를 사용하면 성능상의 이점이 없습니다. 쿼리 플래너는 계획 프로세스 중에이를 고려하여이 시나리오에서 병렬 집계를 선택하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 유형은 입력 텍스트의 정확한 사본을 저장 하기 때문에 JSON 오브젝트 내에서 키 순서뿐만 아니라 토큰 사이의 의미 상 미미한 공백도 보존합니다. 또한 값 내의 JSON 오브젝트에 동일한 키가 두 번 이상 포함되어 있으면 모든 키 / 값 쌍이 유지됩니다. (처리 함수는 마지막 값을 작동 값으로 간주합니다.) 대조적으로, &lt;code&gt;jsonb&lt;/code&gt; 는 공백을 보존하지 않고 오브젝트 키의 순서를 보존하지 않으며 중복 오브젝트 키를 유지하지 않습니다. 입력에 중복 키가 지정되면 마지막 값만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">캐시는 모든 데이터베이스에서 공유되므로 일반적으로 현재 데이터베이스에 속하지 않은 관계의 페이지가 있습니다. 이는 일부 행에 대해 &lt;code&gt;pg_class&lt;/code&gt; 에 일치하는 조인 행이 없거나 잘못된 조인이있을 수도 있음을 의미합니다. &lt;code&gt;pg_class&lt;/code&gt; 에 대해 조인하려는 경우 &lt;code&gt;reldatabase&lt;/code&gt; 가 현재 데이터베이스의 OID와 같거나 0 인 행으로 조인을 제한하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">데이터 디렉토리에는 데이터베이스에 저장된 모든 데이터가 포함되므로 무단 액세스로부터 보호해야합니다. 따라서 &lt;code&gt;initdb&lt;/code&gt; 는 PostgreSQL 사용자 및 선택적으로 그룹을 제외한 모든 사용자의 액세스 권한을 취소합니다. 사용 가능한 경우 그룹 액세스는 읽기 전용입니다. 이를 통해 클러스터 소유자와 동일한 그룹의 권한이없는 사용자가 클러스터 데이터의 백업을 수행하거나 읽기 액세스 만 필요한 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">인덱스 메커니즘은 함수를 사용하기 전에 함수에 대한 액세스 권한을 검사하지 않기 때문에 연산자 클래스의 함수 또는 연산자를 포함하여 공용 실행 권한을 부여하는 것이 가장 중요합니다. 이것은 일반적으로 연산자 클래스에 유용한 일종의 함수에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">인덱스 시스템은 기능을 사용하기 전에 기능에 대한 액세스 권한을 점검하지 않기 때문에 운영자 제품군의 기능 또는 운영자를 포함하여 공개 실행 권한을 부여하는 것이 중요합니다. 이것은 일반적으로 연산자 제품군에 유용한 기능 종류에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">가능한 열 조합의 수가 매우 많으므로 다변량 통계를 자동으로 계산하는 것은 비현실적입니다. 대신, &lt;em&gt;확장 통계 개체는&lt;/em&gt; 더 자주 방금 전화 &lt;em&gt;통계 오브젝트&lt;/em&gt; , 열 흥미로운 세트에서 통계를 얻기 위해 서버를 지시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">플래너는 테이블 순서에 대한 통계를 기록 하므로 새로 클러스터 된 테이블 에서 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하는 것이 좋습니다 . 그렇지 않으면 플래너가 쿼리 계획을 잘못 선택했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">위의 색인에서 두 인수 버전의 &lt;code&gt;to_tsvector&lt;/code&gt; 가 사용 &lt;code&gt;to_tsvector&lt;/code&gt; 구성 이름이 동일한 두 인수 버전의 to_tsvector 를 사용하는 쿼리 참조 만 해당 색인을 사용합니다. 즉, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; 는 색인을 사용할 수 있지만 &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; 는 사용할 수 없습니다. 이렇게하면 인덱스 항목을 작성하는 데 사용 된 것과 동일한 구성으로 만 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">데이터 유형이 작성된 후에는 사용에 대한 제한이 없으므로 기본 유형 또는 범위 유형을 작성하는 것이 유형 정의에 언급 된 함수에 대한 공용 실행 권한을 부여하는 데 가장 중요합니다. 이것은 일반적으로 유형 정의에 유용한 함수 종류에는 문제가되지 않습니다. 그러나 &quot;비밀&quot;정보를 외부 형식으로 변환하거나 외부 형식으로 변환하는 데 필요한 방식으로 형식을 디자인하기 전에 두 번 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">이러한 기능은 자세한 페이지 수준 정보를 반환하므로 기본적으로 액세스가 제한됩니다. 기본적으로 만 역할 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 는 이 &lt;code&gt;EXECUTE&lt;/code&gt; 특권을. 물론 수퍼 유저는이 제한을 무시합니다. 확장이 설치되면 &lt;code&gt;GRANT&lt;/code&gt; 명령을 실행하여 다른 사용자가 실행할 수 있도록 기능에 대한 권한을 변경할 수 있습니다. 그러나 해당 사용자를 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 역할에 대신 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">사용자 아이덴티티는 클러스터 전체에서 사용 &lt;code&gt;pg_auth_members&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_auth_members&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">사용자 ID는 클러스터 전체에 적용 &lt;code&gt;pg_authid&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_authid&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">PostgreSQL 8.1 이전에는 시퀀스 함수의 인수는 &lt;code&gt;regclass&lt;/code&gt; 가 아닌 &lt;code&gt;text&lt;/code&gt; 유형이었으며 위에서 설명한 텍스트 문자열에서 OID 값으로의 변환은 각 호출 중에 런타임에 발생했습니다. 이전 버전과의 호환성을 위해이 기능은 여전히 ​​존재하지만 내부적으로는 함수가 호출되기 전에 &lt;code&gt;text&lt;/code&gt; 에서 &lt;code&gt;regclass&lt;/code&gt; 로의 암시 적 강제로 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2 이전에는 &lt;code&gt;.*&lt;/code&gt; 구문이 행 생성자에서 확장되지 않았으므로 &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; 작성하면 첫 번째 필드가 다른 행 값인 2 필드 행이 작성되었습니다. 새로운 행동이 일반적으로 더 유용합니다. 중첩 행 값의 이전 동작이 필요한 경우 &lt;code&gt;.*&lt;/code&gt; 없이 내부 행 값을 작성하십시오 &lt;code&gt;ROW(t, 42)&lt;/code&gt; 예 : ROW (t, 42)) .</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">PostgreSQL 8.2 이전에는 포함 연산자 &lt;code&gt;@&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;@&lt;/code&gt; 을 각각 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 라고했습니다 . 이 이름은 여전히 ​​사용 가능하지만 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">PostgreSQL 8.3 이전에는 이러한 데이터 유형에서 &lt;code&gt;text&lt;/code&gt; 로 암시적인 강제 변환이 있기 때문에 이러한 함수는 문자열이 아닌 여러 데이터 유형의 값을 자동으로 허용합니다 . 이러한 강압은 종종 놀라운 행동을 유발했기 때문에 제거되었습니다. 그러나 문자열 연결 연산자 ( &lt;code&gt;||&lt;/code&gt; )는 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;표 9.9에&lt;/a&gt; 표시된 것처럼 하나 이상의 입력이 문자열 유형 인 경우에도 문자열이 아닌 입력을 허용 합니다. 다른 경우 에는 이전 동작을 복제해야하는 경우 명시 적 강제 변환을 &lt;code&gt;text&lt;/code&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">PostgreSQL 8.4 이전에 psql은 공백없이 중간에 단일 문자 백 슬래시 명령의 첫 번째 인수가 명령 바로 다음에 시작되도록 허용했습니다. 이제 약간의 공백이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">PostgreSQL 8.4 이전에는 &lt;code&gt;OPERATOR&lt;/code&gt; 절에 &lt;code&gt;RECHECK&lt;/code&gt; 옵션 이 포함될 수있었습니다 . 인덱스 연산자의 &quot;손실&quot;여부가 런타임시 즉석에서 결정되므로 더 이상 지원되지 않습니다. 이를 통해 작업자가 손실되거나 손실되지 않는 경우를 효율적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 &lt;code&gt;pg_am&lt;/code&gt; 에 인덱스 액세스 방법의 속성을 나타내는 많은 추가 열이 포함되었습니다. 이 데이터는 이제 C 코드 레벨에서만 직접 볼 수 있습니다. 그러나 &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; 및 관련 함수가 추가되어 SQL 쿼리가 인덱스 액세스 방법 속성을 검사 할 수 있습니다. &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;표 9.68&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 스크립트 파일의 SQL 명령이 줄 바꿈으로 종료되었으므로 여러 줄에서 계속할 수 없었습니다. 이제 연속 SQL 명령을 분리 &lt;em&gt;하려면&lt;/em&gt; 세미콜론이 &lt;em&gt;필요&lt;/em&gt; 합니다 (SQL 명령 뒤에 메타 명령이있는 경우 SQL 명령이 필요하지 않음). pgbench의 이전 버전과 새 버전 모두에서 작동하는 스크립트 파일을 작성해야하는 경우 세미콜론으로 끝나는 단일 행에 각 SQL 명령을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 &lt;code&gt;-c&lt;/code&gt; 옵션에 &lt;code&gt;-X&lt;/code&gt; ( &lt;code&gt;--no-psqlrc&lt;/code&gt; )가 포함되었습니다. 이것은 더 이상 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">PostgreSQL에 &lt;code&gt;INCLUDE&lt;/code&gt; 기능 이 있기 전에 사람들은 때때로 페이로드 열을 일반 인덱스 열로 작성하여 인덱스를 덮었습니다.</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">PostgreSQL 버전 8.2 이전에는 쉘 유형 작성 구문 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 이 없었습니다. 새로운 기본 유형을 작성하는 방법은 먼저 입력 기능을 작성하는 것입니다. 이 접근법에서 PostgreSQL은 먼저 새로운 데이터 유형의 이름을 입력 함수의 반환 유형으로 인식합니다. 이 상황에서 쉘 유형이 내재적으로 작성된 후 나머지 I / O 기능의 정의에서 참조 될 수 있습니다. 이 방법은 여전히 ​​작동하지만 더 이상 사용되지 않으며 향후 릴리스에서 허용되지 않을 수 있습니다. 또한 함수 정의의 간단한 오타로 인해 실수로 쉘 유형으로 카탈로그를 복잡하게 만들지 않도록 입력 유형이 C로 작성된 경우에만 쉘 유형이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">PostgreSQL 버전 8.3 이전에는 &lt;code&gt;SET&lt;/code&gt; 절을 사용할 수 없었으므로 이전 함수에는 &lt;code&gt;search_path&lt;/code&gt; 를 저장, 설정 및 복원하기위한 복잡한 논리가 포함될 수 있습니다 . &lt;code&gt;SET&lt;/code&gt; 의 절은이 목적을 위해 사용하기에 훨씬 쉽다.</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">PostgreSQL 버전 8.3 이전에는 생성 된 배열 유형의 이름이 항상 밑줄 문자 ( &lt;code&gt;_&lt;/code&gt; )가 앞에 붙은 요소 유형의 이름 이었습니다. (따라서 유형 이름의 길이는 다른 이름보다 하나 적은 문자로 제한되었습니다.) 이것은 여전히 ​​그렇지만 최대 길이 이름이나 밑줄로 시작하는 사용자 유형 이름과 충돌하는 경우 배열 유형 이름은이 이름과 다를 수 있습니다. . 따라서이 규칙에 따른 코드 작성은 더 이상 사용되지 않습니다. 대신 &lt;code&gt;pg_type&lt;/code&gt; 을 사용하십시오 . 주어진 유형과 연관된 배열 유형을 찾기위한 &lt;code&gt;typarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">누구나 데이터베이스에 액세스하려면 데이터베이스 서버를 시작해야합니다. 데이터베이스 서버 프로그램을 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다. &lt;code&gt;postgres&lt;/code&gt; 프로그램은 어디에가 사용하도록되어 데이터를 찾을 수 알고 있어야합니다. 이것은 &lt;code&gt;-D&lt;/code&gt; 옵션으로 수행됩니다 . 따라서 서버를 시작하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">그렇게하기 전에 함수는 &lt;code&gt;offset&lt;/code&gt; 의 부호를 확인해야합니다 . 0보다 작 으면 &quot;창 함수에서 유효하지 않은 선행 또는 후속 크기&quot;와 같은 오류 텍스트로 오류 &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013)를 발생시킵니다. (비표준 연산자 패밀리는 의미 상 필요성이 거의 없기 때문에이 제한을 무시하도록 선택할 수도 있지만 이는 SQL 표준에 필요합니다.)이 요구 사항은 코어 코드를 이해할 필요가 없도록 &lt;code&gt;in_range&lt;/code&gt; 함수에 위임됩니다. 특정 데이터 유형에 대해 &quot;0보다 작은&quot;의 의미</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">SQL 덤프를 복원하기 전에 오브젝트를 소유하거나 덤프 된 데이터베이스의 오브젝트에 대한 권한이 부여 된 모든 사용자가 이미 존재해야합니다. 그렇지 않은 경우 복원은 원래 소유권 및 / 또는 권한으로 오브젝트를 다시 작성하지 못합니다. (때로는 이것이 원하는 것이지만 일반적으로 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; 명령을 실행하기 전에 테이블에서 원하는 파티션 제한 조건과 일치하도록 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 을 작성하는 것이 좋습니다 . 이렇게하면 시스템이 암시 적 파티션 제약 조건의 유효성을 검사하기 위해 검색을 건너 뛸 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 없으면 해당 파티션에서 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 을 유지 하고 부모 테이블에서 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 을 유지하면서 파티션 제약 조건을 확인하기 위해 테이블을 스캔 합니다. &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 이 완료된 후 중복 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">계속 진행하기 전에 기본 PostgreSQL 시스템 아키텍처를 이해해야합니다. PostgreSQL의 일부가 상호 작용하는 방식을 이해하면이 장이 다소 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">어떤 작업을 수행하기 전에 디스크의 데이터베이스 저장 영역을 초기화해야합니다. 이것을 &lt;em&gt;데이터베이스 클러스터&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . SQL 표준은 카탈로그 클러스터라는 용어를 사용합니다. 데이터베이스 클러스터는 실행중인 데이터베이스 서버의 단일 인스턴스로 관리되는 데이터베이스의 모음입니다. 초기화 후 데이터베이스 클러스터에는 &lt;code&gt;postgres&lt;/code&gt; 라는 데이터베이스가 포함되며 이는 유틸리티, 사용자 및 타사 응용 프로그램에서 사용하기위한 기본 데이터베이스로 사용됩니다. 데이터베이스 서버 자체에는 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 필요하지 않지만 많은 외부 유틸리티 프로그램이 존재한다고 가정합니다. 초기화 중에 각 클러스터 내에 생성 된 다른 데이터베이스를 &lt;code&gt;template1&lt;/code&gt; 이라고합니다.. 이름에서 알 수 있듯이 이것은 나중에 생성 된 데이터베이스의 템플릿으로 사용됩니다. 실제 작업에 사용해서는 안됩니다. 클러스터 내에서 새 데이터베이스를 작성하는 방법에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;22 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE EXTENSION&lt;/code&gt; 을 사용하여 확장을 데이터베이스에로드 하기 전에 확장의 지원 파일을 설치해야합니다. PostgreSQL과 함께 제공되는 확장 설치에 ​​대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;추가 제공 모듈&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">물론 PostgreSQL을 사용하려면 먼저 설치해야합니다. 운영 체제 배포에 포함되어 있거나 시스템 관리자가 이미 설치했기 때문에 PostgreSQL이 이미 사이트에 설치되었을 수 있습니다. 이 경우 운영 체제 설명서 또는 시스템 관리자로부터 PostgreSQL 액세스 방법에 대한 정보를 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">앞에서 설명한대로 대기 하는 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하여 로컬 WAL 아카이브에서 대기 서버에서 복구를 시작 하십시오 ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;25.3.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 의해 지정된 논리적 복제 슬롯 에서 신호 변경이있을 때까지 계속 변경 사항을 스트리밍하십시오 . 서버 측 변경 스트림이 서버 종료 또는 연결 끊기로 끝나는 경우 &lt;code&gt;--no-loop&lt;/code&gt; 를 지정 하지 않으면 루프에서 다시 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">데이터베이스 자체를 작성하고 작성된 데이터베이스에 다시 연결하는 명령으로 출력을 시작하십시오. 이 형식의 스크립트를 사용하면 스크립트를 실행하기 전에 대상 설치에서 어떤 데이터베이스를 연결하든 상관 없습니다. &lt;code&gt;--clean&lt;/code&gt; 도 지정하면 스크립트는 대상 데이터베이스를 다시 연결하기 전에 삭제하고 다시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">PostgreSQL 9.1부터이 인덱스 유형은 &lt;code&gt;LIKE&lt;/code&gt; 및 &lt;code&gt;ILIKE&lt;/code&gt; 에 대한 인덱스 검색도 지원 합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">PostgreSQL 9.3부터 이러한 인덱스 유형은 정규 표현식 일치 ( &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~*&lt;/code&gt; 연산자)에 대한 인덱스 검색도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">단지처럼 행동 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 그 변경을 제외하고 기능은 소비되지 않는다; 즉, 향후 통화시 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">변경 사항이 &lt;code&gt;bytea&lt;/code&gt; 로 리턴되고 변경 사항이 소비되지 않는다는 점을 제외하고 는 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 함수와 동일하게 작동합니다 . 즉, 향후 통화시 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">변경 사항이 &lt;code&gt;bytea&lt;/code&gt; 로 리턴된다는 점을 제외하고 는 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 함수와 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">검색된 각 행에서 독점 잠금이 아닌 공유 잠금을 획득한다는 점을 제외하고 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; 와 유사하게 작동 합니다. 공유 잠금은 다른 트랜잭션 이이 행에서 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 를 수행하지 못하도록하지만 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 를 수행하는 것을 막지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">잠금이 약하다는 점을 제외하고 &lt;code&gt;FOR SHARE&lt;/code&gt; 와 유사하게 작동합니다 . &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 는 차단되지만 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 는 차단 됩니다. 키 공유 로크 수행하는 블록 다른 트랜잭션 &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 다른 키 값을 변경하지만 &lt;code&gt;UPDATE&lt;/code&gt; 를 하고, 어느 쪽이 방지하지 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">획득 된 잠금이 약하다는 점을 제외하고 &lt;code&gt;FOR UPDATE&lt;/code&gt; 와 유사하게 작동합니다 .이 잠금은 동일한 행에서 잠금을 획득하려고 시도하는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 명령을 차단하지 않습니다 . 이 잠금 모드는 &lt;code&gt;FOR UPDATE&lt;/code&gt; 잠금을 획득하지 않은 &lt;code&gt;UPDATE&lt;/code&gt; 에서도 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">B- 트리 운영자 클래스의 동작</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">다음은 프로덕션 환경에서이 기능을 사용하는 방법에 대한 더 큰 예입니다. &lt;code&gt;passwd&lt;/code&gt; 테이블 은 Unix 비밀번호 파일을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">아래에서는 사전을 만들고 일부 토큰 유형을 천문학적 동의어 사전 및 영어 형태소 분석기에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">벤치마킹 옵션</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 구성 매개 변수 외에도 &lt;code&gt;SET&lt;/code&gt; 명령을 통해서만 조정할 수 있거나 특수 구문 이있는 몇 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">macOS의 최신 릴리스는 &lt;code&gt;SHMMAX&lt;/code&gt; 를 정확히 4096의 배수가 아닌 값 으로 설정하려는 시도를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">것을주의 &lt;code&gt;ROWS&lt;/code&gt; 의 경우 생성 모드가 예측할 수없는 결과를 생성 할 수 &lt;code&gt;ORDER BY&lt;/code&gt; 주문 고유 행을 주문하지 않습니다. &lt;code&gt;RANGE&lt;/code&gt; 및 &lt;code&gt;GROUPS&lt;/code&gt; 모드가에 피어 것을 행하기 위해 설계 &lt;code&gt;ORDER BY&lt;/code&gt; 프레임의 수 또는에서 제외됩니다 주어진 피어 그룹의 모든 행 : 모두 처리되는 순서를.</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">외부 쿼리 수준에 조인과 같은 추가 처리가 포함되어 있으면 집계가 계산되기 전에 하위 쿼리의 출력이 다시 정렬 될 수 있으므로이 방법이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">빅 파이브</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">이진 데이터 형식</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">이진 데이터 형식 : bytea</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">이진 형식</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">이진 문자열 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">이진 문자열 : btrim</target>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">이진 문자열 : 디코드</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">이진 문자열 : encode</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">이진 문자열 : get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">이진 문자열 : get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">이진 문자열 : 길이</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">이진 문자열 : md5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">이진 문자열 : octet_length</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">이진 문자열 : 오버레이</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">이진 문자열 : 위치</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">이진 문자열 : set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">이진 문자열 : set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">이진 문자열 : sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">이진 문자열 : sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">이진 문자열 : sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">이진 문자열 : sha512</target>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">이진 문자열 : 부분 문자열</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">이진 문자열 : 트림</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">이진 문자열 : ||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">이진 커서는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">이진 커서는주의해서 사용해야합니다. psql을 포함한 많은 응용 프로그램은 이진 커서를 처리 할 준비가되지 않았으며 데이터가 텍스트 형식으로 다시 나타날 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">비트 16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">비트 문자열 함수 및 연산자</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">비트 문자열 타입</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">비트 문자열 : #</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">비트 문자열 : &amp;amp;</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">비트 문자열 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">비트 문자열 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">비트 문자열 : |</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">비트 문자열 : ||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">비트 문자열 : ~</target>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">트리거 발생 조건을 식별하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">비트 문자열은 1과 0의 문자열입니다. 비트 마스크를 저장하거나 시각화하는 데 사용할 수 있습니다. &lt;code&gt;bit(n)&lt;/code&gt; 및 &lt;code&gt;bit varying(n)&lt;/code&gt; 두 가지 SQL 비트 유형이 있습니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 양의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">비트 열 상수 는 여는 따옴표 바로 앞에 &lt;code&gt;B&lt;/code&gt; (대문자 또는 소문자) 가있는 일반 문자열 상수처럼 보입니다 (예 : &lt;code&gt;B'1001'&lt;/code&gt; . 비트 열 상수 내에서 허용되는 유일한 문자는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">비트 열 타입</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">BitmapAnd 및 BitmapOr 노드는 구현 제한으로 인해 항상 실제 행 수를 0으로보고합니다.</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">이러한 유형의 검색을 처리하는 데 블룸이 btree보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">복어 암호</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">복어 토굴</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">복어 기반, 변형 2a</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">부울 AND</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">부울 NOT</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">부울 OR</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">부울 유형 : 부울</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">부울 집계 &lt;code&gt;bool_and&lt;/code&gt; 및 &lt;code&gt;bool_or&lt;/code&gt; 표준 SQL의 집계에 해당하는 &lt;code&gt;every&lt;/code&gt; 및 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;some&lt;/code&gt; . 에 관해서는 &lt;code&gt;any&lt;/code&gt; 및 &lt;code&gt;some&lt;/code&gt; , 표준 문법에 내장 애매함이있는 것 같습니다 :</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">부울 상수는 SQL 키워드 &lt;code&gt;TRUE&lt;/code&gt; , &lt;code&gt;FALSE&lt;/code&gt; 및 &lt;code&gt;NULL&lt;/code&gt; 로 SQL 쿼리에 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">부울 유형</target>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">부울 값은 술어를 사용하여 테스트 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">두 &lt;code&gt;CHECK&lt;/code&gt; 및 &lt;code&gt;NOT NULL&lt;/code&gt; 의 분할 된 테이블의 제약 조건은 항상 모든 파티션에 의해 상속됩니다. &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시된 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건은 파티션 된 테이블에서 작성 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 와 &lt;code&gt;target&lt;/code&gt; 은 모두 최대 255 자의 널이 아닌 문자열 일 수 있습니다. 비용 매개 변수는 각각 문자 삽입, 삭제 또는 대체에 대해 청구 할 금액을 지정합니다. 함수의 두 번째 버전에서와 같이 비용 매개 변수를 생략 할 수 있습니다. 이 경우 모두 1로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">권고 잠금 및 일반 잠금은 모두 크기가 구성 변수 &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections에&lt;/a&gt; 의해 정의되는 공유 메모리 풀에 저장됩니다 . 이 메모리를 소진하지 않도록주의해야합니다. 그렇지 않으면 서버에서 잠금을 전혀 부여 할 수 없습니다. 이는 서버가 부여 할 수있는 권고 잠금 수에 대한 상한을, 일반적으로 서버 구성 방법에 따라 수십에서 수십만으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">비트 스트링 상수의 두 가지 형식은 일반 스트링 상수와 같은 방식으로 여러 행에 걸쳐 계속 될 수 있습니다. 달러 인용 부호는 비트 열 상수에 사용될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">minmax 및 포함 연산자 클래스는 모두 데이터 형식 연산자를 지원하지만 이러한 종속성으로 인해 더 복잡해집니다. minmax 연산자 클래스는 동일한 데이터 유형을 갖는 두 인수로 정의 된 전체 연산자 세트를 필요로합니다. 추가 연산자 세트를 정의하여 추가 데이터 유형을 지원할 수 있습니다. 포함 연산자 클래스 운영자 전략은 &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;표 67.3에&lt;/a&gt; 표시된 다른 운영자 전략 또는 동일한 운영자 전략에 의존 합니다. 종속 연산자는 &lt;code&gt;STORAGE&lt;/code&gt; 데이터 유형을 왼쪽 인수로 정의하고 다른 지원되는 데이터 유형을 지원되는 연산자의 오른쪽 인수로 정의해야합니다. minmax의 예로 &lt;code&gt;float4_minmax_ops&lt;/code&gt; 를 참조하십시오. &lt;code&gt;box_inclusion_ops&lt;/code&gt; 포함의 예로 box_inclusion_ops 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 열의 최대 정밀도와 최대 스케일을 모두 구성 할 수 있습니다. &lt;code&gt;numeric&lt;/code&gt; 유형의 열을 선언하려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">스캔 위치와 마크 위치 (있는 경우)는 인덱스에서 동시에 삽입 또는 삭제 될 때 일관성있게 유지되어야합니다. 새로 시작한 항목이 검색을 시작할 때 존재했거나 해당 항목이 검색되지 않았더라도 다시 검색하거나 백업 할 때 해당 항목을 반환 한 항목을 찾은 검색에 의해 반환되지 않으면 정상입니다. 처음으로 돌아 왔습니다. 마찬가지로 동시 삭제는 스캔 결과에 반영되거나 반영되지 않을 수 있습니다. 중요한 것은 삽입 또는 삭제로 인해 스캔이 삽입 또는 삭제되지 않은 항목을 누락하거나 여러 번 반환하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">파일 이름에 대시 및 PostgreSQL 주 또는 부 릴리스 번호 (예 : &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; 또는 &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; 를 추가하여 시스템 전체 시작 파일과 사용자 개인 시작 파일을 psql 버전에 따라 지정할 수 있습니다 . psqlrc-9.2.5 . 가장 구체적인 버전 일치 파일은 버전이 아닌 파일보다 우선적으로 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">상자는 두 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">상자는 상자의 반대쪽 모서리에있는 점 쌍으로 표시됩니다. &lt;code&gt;box&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">대괄호 ( &lt;code&gt;[]&lt;/code&gt; )는 배열의 요소를 선택하는 데 사용됩니다. 배열에 대한 자세한 내용 &lt;a href=&quot;arrays&quot;&gt;은 8.15 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">입력 문자열을 토큰으로 나누고 각 토큰을 문자열, 시간, 시간대 또는 숫자로 분류하십시오.</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">브라이언 글 래드 먼</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">새로운 색인을 작성하십시오. 인덱스 관계가 실제로 작성되었지만 비어 있습니다. 액세스 방법에 필요한 고정 데이터와 테이블에 이미 존재하는 모든 튜플에 대한 항목으로 채워 져야합니다. 일반적으로 &lt;code&gt;ambuild&lt;/code&gt; 함수는 &lt;code&gt;table_index_build_scan()&lt;/code&gt; 을 호출 하여 기존 튜플에 대한 테이블을 스캔하고 인덱스에 삽입해야하는 키를 계산합니다. 이 함수는 새 인덱스에 대한 통계가 포함 된 palloc'd 구조체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">빈 인덱스를 작성 하고 지정된 관계 의 초기화 포크 ( &lt;code&gt;INIT_FORKNUM&lt;/code&gt; )에 씁니다 . 이 메소드는 로그되지 않은 인덱스에 대해서만 호출됩니다. 초기화 포크에 기록 된 빈 인덱스는 각 서버 재시작시 기본 관계 포크를 통해 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">이전 클러스터와 호환되는 &lt;code&gt;configure&lt;/code&gt; 플래그를 사용하여 새 PostgreSQL 소스를 빌드하십시오 . pg_upgrade는 업그레이드를 시작하기 전에 &lt;code&gt;pg_controldata&lt;/code&gt; 를 검사 하여 모든 설정이 호환되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">GIN 인덱스의 빌드 시간은 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 설정에 매우 민감 합니다. 인덱스 작성 중에 작업 메모리를 비축하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">동시에 인덱스 작성</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">동시 업데이트를 지원하는 인덱스 유형을 작성하려면 일반적으로 필요한 동작을 광범위하고 미묘하게 분석해야합니다. b- 트리 및 해시 인덱스 유형의 경우 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 및 &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; 와 관련된 설계 결정에 대해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">인덱스 튜플이 인덱스 전체에 흩어져 있고 인덱스가 캐시에 맞지 않을만큼 충분히 큰 경우 삽입은 많은 임의의 I / O를 수행해야하기 때문에 모든 튜플을 삽입하여 대규모 GiST 인덱스를 구축하는 것은 느리게 진행됩니다. 버전 9.2부터 PostgreSQL은 버퍼링을 기반으로 GiST 인덱스를 작성하는보다 효율적인 방법을 지원하므로 순서가없는 데이터 세트에 필요한 임의 I / O 수를 크게 줄일 수 있습니다. 잘 정렬 된 데이터 세트의 경우 한 번에 적은 수의 페이지 만 새 튜플을 수신하고 인덱스 전체가 아닌 경우에도 해당 페이지가 캐시에 적합하기 때문에 이점이 더 적거나 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">텍스트 배열에서 JSON 객체를 빌드합니다. 배열은 짝수의 멤버를 갖는 정확히 하나의 차원을 가져야하며,이 경우 교대하는 키 / 값 쌍으로 간주되거나 각 내부 배열이 정확히 두 개의 요소를 갖도록 두 차원을 가져야합니다. .</target>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">가변 인수 목록에서 JSON 객체를 작성합니다. 일반적으로 인수 목록은 대체 키와 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">이기종 인수 목록에서 이기종 유형의 JSON 배열을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSON 객체에서 임의의 레코드를 작성합니다 (아래 참고 참조). &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출자는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드의 구조를 명시 적으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSON 객체 배열에서 임의의 레코드 세트를 작성합니다 (아래 참고 참조). &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출자는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드의 구조를 명시 적으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="9cd4a830278cf917981f2492e289136d8fcb76a0" translate="yes" xml:space="preserve">
          <source>Built-in Operators</source>
          <target state="translated">내장 연산자</target>
        </trans-unit>
        <trans-unit id="e6f4065b40dff42dc088b0122b579c99bd5cdb2f" translate="yes" xml:space="preserve">
          <source>Bulk loads and deletes can be accomplished by adding or removing partitions, if that requirement is planned into the partitioning design. Doing &lt;code&gt;ALTER TABLE DETACH PARTITION&lt;/code&gt; or dropping an individual partition using &lt;code&gt;DROP TABLE&lt;/code&gt; is far faster than a bulk operation. These commands also entirely avoid the &lt;code&gt;VACUUM&lt;/code&gt; overhead caused by a bulk &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">해당 요구 사항이 분할 설계에 계획되어있는 경우 분할 영역을 추가하거나 제거하여 대량로드 및 삭제를 수행 할 수 있습니다. 이렇게 &lt;code&gt;ALTER TABLE DETACH PARTITION&lt;/code&gt; 또는 사용하여 개별 파티션 삭제 &lt;code&gt;DROP TABLE&lt;/code&gt; 훨씬 빠르게 대량 작업보다. 이러한 명령은 또한 대량 &lt;code&gt;DELETE&lt;/code&gt; 로 인한 &lt;code&gt;VACUUM&lt;/code&gt; 오버 헤드를 완전히 피합니다 .</target>
        </trans-unit>
        <trans-unit id="ba7aa498b8190a3e40ac8cc44de7a317a4821d6c" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;-o&lt;/code&gt; is specified, that replaces any previous options. To restart using port 5433, disabling &lt;code&gt;fsync&lt;/code&gt; upon restart:</source>
          <target state="translated">그러나 &lt;code&gt;-o&lt;/code&gt; 를 지정하면 이전 옵션이 바뀝니다. 포트 5433을 사용하여 다시 시작하려면 다시 시작할 때 &lt;code&gt;fsync&lt;/code&gt; 를 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="602beb3b1a1bbe225614fdbf63a5d0bd06c13935" translate="yes" xml:space="preserve">
          <source>But if we tell the planner to honor the &lt;code&gt;JOIN&lt;/code&gt; order, the second and third take less time to plan than the first. This effect is not worth worrying about for only three tables, but it can be a lifesaver with many tables.</source>
          <target state="translated">그러나 플래너에게 &lt;code&gt;JOIN&lt;/code&gt; 명령 을 따르도록 지시하면 두 번째와 세 번째는 첫 번째보다 계획 시간이 덜 걸립니다. 이 효과는 세 개의 테이블에 대해서만 걱정할 필요는 없지만 많은 테이블을 가진 생명의 은인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09b41d05f84a635c62f9f96512a903ce9737d4a8" translate="yes" xml:space="preserve">
          <source>But if you use the &lt;code&gt;-j&lt;/code&gt; command line switch, a single newline does not terminate command entry; instead, the sequence semicolon-newline-newline does. That is, type a semicolon immediately followed by a completely empty line. Backslash-newline is not treated specially in this mode. Again, there is no intelligence about such a sequence appearing within a string literal or comment.</source>
          <target state="translated">그러나 &lt;code&gt;-j&lt;/code&gt; 명령 행 스위치 를 사용하는 경우 단일 개행은 명령 입력을 종료하지 않습니다. 대신, 세미콜론-개행-개행 시퀀스가 ​​수행합니다. 즉, 세미콜론을 입력 한 다음 완전히 빈 줄을 입력하십시오. 이 모드에서는 백 슬래시-줄 바꾸기가 특별히 처리되지 않습니다. 다시 말하지만, 문자열 리터럴 또는 주석 내에 나타나는 이러한 시퀀스에 대한 정보는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f29dbb61f87fc9cd4617a00bcc7185e6a0e0f4d5" translate="yes" xml:space="preserve">
          <source>But minimal WAL does not contain enough information to reconstruct the data from a base backup and the WAL logs, so &lt;code&gt;replica&lt;/code&gt; or higher must be used to enable WAL archiving (&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;) and streaming replication.</source>
          <target state="translated">그러나 최소 WAL에는 기본 백업 및 WAL 로그의 데이터를 재구성하기에 충분한 정보가 포함되어 있지 않으므로 WAL 보관 ( &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; ) 및 스트리밍 복제 를 활성화하려면 &lt;code&gt;replica&lt;/code&gt; 이상을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ff32a7d1b246935a4ae3a58c792ebf05564a55cb" translate="yes" xml:space="preserve">
          <source>But there's a problem: the &lt;code&gt;WHERE&lt;/code&gt; clause refers to &lt;code&gt;success&lt;/code&gt; which is not available as a result column of the index. Nonetheless, an index-only scan is possible because the plan does not need to recheck that part of the &lt;code&gt;WHERE&lt;/code&gt; clause at run time: all entries found in the index necessarily have &lt;code&gt;success = true&lt;/code&gt; so this need not be explicitly checked in the plan. PostgreSQL versions 9.6 and later will recognize such cases and allow index-only scans to be generated, but older versions will not.</source>
          <target state="translated">그러나 문제가 있습니다. &lt;code&gt;WHERE&lt;/code&gt; 절은 인덱스의 결과 열로 사용할 수없는 &lt;code&gt;success&lt;/code&gt; 을 나타냅니다 . 그럼에도 불구하고 계획이 런타임시 &lt;code&gt;WHERE&lt;/code&gt; 절의 해당 부분을 다시 점검 할 필요가 없기 때문에 색인 전용 스캔이 가능 합니다. 색인에있는 모든 항목은 반드시 &lt;code&gt;success = true&lt;/code&gt; 이므로 계획에서 명시 적으로 점검 할 필요가 없습니다. PostgreSQL 버전 9.6 이상에서는 이러한 경우를 인식하고 인덱스 전용 스캔을 생성 할 수 있지만 이전 버전은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ca875b680fdb97fc74f9300d7be351d9a268b49" translate="yes" xml:space="preserve">
          <source>But these are not:</source>
          <target state="translated">그러나 이것들은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="a6f6a57b5a3f46981dddd10346050b6e06f08985" translate="yes" xml:space="preserve">
          <source>But this is an error:</source>
          <target state="translated">그러나 이것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="accaa3dea52db94367cfe201c42c88caefb30d09" translate="yes" xml:space="preserve">
          <source>But this is safe:</source>
          <target state="translated">그러나 이것은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="44cc34850e38168bd2b77ca3e32ee99a97567661" translate="yes" xml:space="preserve">
          <source>But this requires visiting both indexes, so it's not necessarily a win compared to using just one index and treating the other condition as a filter. If you vary the ranges involved you'll see the plan change accordingly.</source>
          <target state="translated">그러나 이것은 두 인덱스를 모두 방문해야하므로 하나의 인덱스를 사용하고 다른 조건을 필터로 처리하는 것과 비교할 때 반드시 승리 할 필요는 없습니다. 관련된 범위를 변경하면 그에 따라 계획이 변경되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e48dc70b851014d5e67f11a0b7f3119e8e08c81" translate="yes" xml:space="preserve">
          <source>But without multivariate statistics, the estimate for the number of groups in a query with two columns in &lt;code&gt;GROUP BY&lt;/code&gt;, as in the following example, is off by an order of magnitude:</source>
          <target state="translated">그러나 다변량 통계가 없으면 다음 예와 같이 &lt;code&gt;GROUP BY&lt;/code&gt; 에 두 개의 열이있는 쿼리의 그룹 수에 대한 추정치가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4aef23c855b410735a4672255ed03112924e3fc7" translate="yes" xml:space="preserve">
          <source>But, of course, this calendar is only valid for Great Britain and dominions, not other places. Since it would be difficult and confusing to try to track the actual calendars that were in use in various places at various times, PostgreSQL does not try, but rather follows the Gregorian calendar rules for all dates, even though this method is not historically accurate.</source>
          <target state="translated">그러나 물론이 달력은 다른 지역이 아닌 영국과 영토에만 유효합니다. 다양한 시간에 여러 장소에서 사용중인 실제 캘린더를 추적하는 것이 어렵고 혼란 스러울 수 있으므로 PostgreSQL은 시도하지 않고 모든 날짜에 대해 그레고리력 캘린더 규칙을 따르지만,이 방법은 역사적으로 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50b0ebe5a19d2b28b3ec57041c04e85532ece01c" translate="yes" xml:space="preserve">
          <source>By default (that is, when &lt;a href=&quot;runtime-config-query#GUC-PLAN-CACHE_MODE&quot;&gt;plan_cache_mode&lt;/a&gt; is set to &lt;code&gt;auto&lt;/code&gt;), the server will automatically choose whether to use a generic or custom plan for a prepared statement that has parameters. The current rule for this is that the first five executions are done with custom plans and the average estimated cost of those plans is calculated. Then a generic plan is created and its estimated cost is compared to the average custom-plan cost. Subsequent executions use the generic plan if its cost is not so much higher than the average custom-plan cost as to make repeated replanning seem preferable.</source>
          <target state="translated">기본적으로 (즉, &lt;a href=&quot;runtime-config-query#GUC-PLAN-CACHE_MODE&quot;&gt;plan_cache_mode&lt;/a&gt; 가 &lt;code&gt;auto&lt;/code&gt; 로 설정된 경우 ) 서버는 매개 변수가있는 준비된 명령문에 일반 계획 또는 사용자 정의 계획을 사용할지 자동으로 선택합니다. 이에 대한 현재 규칙은 처음 5 개의 실행이 사용자 정의 계획으로 수행되고 해당 계획의 평균 예상 비용이 계산된다는 것입니다. 그런 다음 일반 계획이 작성되고 예상 비용이 평균 사용자 정의 계획 비용과 비교됩니다. 후속 실행에서는 비용이 평균 사용자 정의 계획 비용보다 높지 않으면 일반 계획을 사용하여 반복 된 재 계획을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="13ce471ea5f04800baa0f0ecc31a88ceee3c919e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;postgres&lt;/code&gt; starts in the foreground and prints log messages to the standard error stream. In practical applications &lt;code&gt;postgres&lt;/code&gt; should be started as a background process, perhaps at boot time.</source>
          <target state="translated">기본적으로 &lt;code&gt;postgres&lt;/code&gt; 는 포 그라운드에서 시작하여 표준 오류 스트림에 로그 메시지를 인쇄합니다. 실제 응용 프로그램에서 &lt;code&gt;postgres&lt;/code&gt; 는 부팅시 백그라운드 프로세스로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c089fc5daeae114cff2ba4b221ff57c41409f19d" translate="yes" xml:space="preserve">
          <source>By default all foreign tables using &lt;code&gt;postgres_fdw&lt;/code&gt; are assumed to be updatable. This may be overridden using the following option:</source>
          <target state="translated">기본적으로 &lt;code&gt;postgres_fdw&lt;/code&gt; 를 사용하는 모든 외부 테이블 은 업데이트 가능한 것으로 간주됩니다. 다음 옵션을 사용하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f347a9a45b3a87f36b46205b565cc13692102c6" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers and members of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">기본적으로 사용은 수퍼 유저 및 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 역할의 멤버로 제한됩니다 . &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5eb9a4b1f5db5b0c40d78042f064f1e9a056def" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers and members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">기본적으로 사용은 수퍼 유저 및 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 역할의 멤버로 제한됩니다 . &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c608d37b651cf68db387435a834eaf1d2af114f" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers, members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role, and users with &lt;code&gt;SELECT&lt;/code&gt; permissions on the table.</source>
          <target state="translated">기본적으로 사용은 수퍼 유저, &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 역할의 멤버 및 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한이있는 사용자로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="35037bbd451cbdc76924f4075f03adbfb4640f34" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;\prompt&lt;/code&gt; uses the terminal for input and output. However, if the &lt;code&gt;-f&lt;/code&gt; command line switch was used, &lt;code&gt;\prompt&lt;/code&gt; uses standard input and standard output.</source>
          <target state="translated">기본적으로 &lt;code&gt;\prompt&lt;/code&gt; 는 터미널을 입력 및 출력에 사용합니다. 그러나 &lt;code&gt;-f&lt;/code&gt; 명령 행 스위치를 사용한 경우 &lt;code&gt;\prompt&lt;/code&gt; 는 표준 입력 및 표준 출력을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f78e158d60bdcbfa2aa7d2e55e101b4676b65b34" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;initdb&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;initdb&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the data directory corrupt. Generally, this option is useful for testing, but should not be used when creating a production installation.</source>
          <target state="translated">기본적으로 &lt;code&gt;initdb&lt;/code&gt; 는 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;initdb&lt;/code&gt; 가 기다리지 않고 리턴 됩니다 . 이는 더 빠르지 만 후속 운영 체제 충돌로 인해 데이터 디렉토리가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치를 작성할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ce1347bf37780a515db01fc3f42a28d865be94d4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_basebackup&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_basebackup&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the base backup corrupt. Generally, this option is useful for testing but should not be used when creating a production installation.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_basebackup&lt;/code&gt; 은 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;pg_basebackup&lt;/code&gt; 이 기다리지 않고 리턴됩니다. 이는 빠르지 만 후속 운영 체제 충돌로 인해 기본 백업이 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치를 작성할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a18a12b0f883d660ff6c8520bf255ac929ed7d2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_checksums&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_checksums&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the updated data directory corrupt. Generally, this option is useful for testing but should not be used on a production installation. This option has no effect when using &lt;code&gt;--check&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_checksums&lt;/code&gt; 는 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;pg_checksums&lt;/code&gt; 가 기다리지 않고 리턴됩니다. 이는 빠르지 만 후속 운영 체제 충돌로 인해 업데이트 된 데이터 디렉토리가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치에서는 사용하지 않아야합니다. &lt;code&gt;--check&lt;/code&gt; 를 사용할 때는이 옵션이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4d204457a7c533537a8ef60c679036dd19b2101e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_dump&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_dump&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the dump corrupt. Generally, this option is useful for testing but should not be used when dumping data from production installation.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_dump&lt;/code&gt; 는 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;pg_dump&lt;/code&gt; 가 기다리지 않고 리턴됩니다. 이는 빠르지 만 후속 운영 체제 충돌로 인해 덤프가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치에서 데이터를 덤프 할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f49fbd975cf48bcd27fb1f035994c8051d90b2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_dumpall&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_dumpall&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the dump corrupt. Generally, this option is useful for testing but should not be used when dumping data from production installation.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_dumpall&lt;/code&gt; 은 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;pg_dumpall&lt;/code&gt; 이 기다리지 않고 리턴됩니다. 이는 빠르지 만 후속 운영 체제 충돌로 인해 덤프가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치에서 데이터를 덤프 할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="67e32dd79cf143919ce3c6f7a4d75d7a165f5ad4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_rewind&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_rewind&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the synchronized data directory corrupt. Generally, this option is useful for testing but should not be used when creating a production installation.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_rewind&lt;/code&gt; 는 모든 파일이 디스크에 안전하게 기록 될 때까지 기다립니다. 이 옵션을 사용하면 &lt;code&gt;pg_rewind&lt;/code&gt; 가 기다리지 않고 리턴됩니다. 이는 빠르지 만 후속 운영 체제 충돌로 인해 동기화 된 데이터 디렉토리가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 설치를 작성할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="be51caa2ed6f2929431841a2d94a49fd4f5675c6" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_start_backup&lt;/code&gt; can take a long time to finish. This is because it performs a checkpoint, and the I/O required for the checkpoint will be spread out over a significant period of time, by default half your inter-checkpoint interval (see the configuration parameter &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;). This is usually what you want, because it minimizes the impact on query processing. If you want to start the backup as soon as possible, change the second parameter to &lt;code&gt;true&lt;/code&gt;, which will issue an immediate checkpoint using as much I/O as available.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_start_backup&lt;/code&gt; 을 완료하는 데 시간이 오래 걸릴 수 있습니다. 이는 검사 점을 수행하기 때문에 검사 ​​점에 필요한 I / O가 기본적으로 검사 점 간격의 절반 (구성 매개 변수 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt; 참조)에 걸쳐 상당한 기간 동안 분산되기 때문 입니다. 쿼리 처리에 대한 영향을 최소화하기 때문에 일반적으로 원하는 것입니다. 가능한 빨리 백업을 시작하려면 두 번째 매개 변수를 &lt;code&gt;true&lt;/code&gt; 로 변경하십시오. 그러면 가능한 많은 I / O를 사용하여 즉시 체크 포인트가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="824ed3b8d5605e6a123037241b401483b28267f6" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_start_backup&lt;/code&gt; can take a long time to finish. This is because it performs a checkpoint, and the I/O required for the checkpoint will be spread out over a significant period of time, by default half your inter-checkpoint interval (see the configuration parameter &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;). This is usually what you want, because it minimizes the impact on query processing. If you want to start the backup as soon as possible, use:</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_start_backup&lt;/code&gt; 을 완료하는 데 시간이 오래 걸릴 수 있습니다. 이는 검사 점을 수행하기 때문에 검사 ​​점에 필요한 I / O가 기본적으로 검사 점 간격의 절반 (구성 매개 변수 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt; 참조)에 걸쳐 상당한 기간 동안 분산되기 때문 입니다. 쿼리 처리에 대한 영향을 최소화하기 때문에 일반적으로 원하는 것입니다. 가능한 빨리 백업을 시작하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="727a3042f84c21b7c863ee84e972a1a5591760e4" translate="yes" xml:space="preserve">
          <source>By default, B-tree indexes store their entries in ascending order with nulls last (table TID is treated as a tiebreaker column among otherwise equal entries). This means that a forward scan of an index on column &lt;code&gt;x&lt;/code&gt; produces output satisfying &lt;code&gt;ORDER BY x&lt;/code&gt; (or more verbosely, &lt;code&gt;ORDER BY x ASC NULLS LAST&lt;/code&gt;). The index can also be scanned backward, producing output satisfying &lt;code&gt;ORDER BY x DESC&lt;/code&gt; (or more verbosely, &lt;code&gt;ORDER BY x DESC NULLS FIRST&lt;/code&gt;, since &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;ORDER BY DESC&lt;/code&gt;).</source>
          <target state="translated">기본적으로 B- 트리 인덱스는 항목을 마지막으로 null을 사용하여 오름차순으로 저장합니다 (테이블 TID는 다른 항목 중 동점 구분 열로 처리됨). 이는 &lt;code&gt;x&lt;/code&gt; 열의 인덱스에 대한 순방향 스캔이 &lt;code&gt;ORDER BY x&lt;/code&gt; (또는 &lt;code&gt;ORDER BY x ASC NULLS LAST&lt;/code&gt; )를 만족시키는 출력을 생성 함을 의미합니다 . &lt;code&gt;ORDER BY x DESC&lt;/code&gt; 를 만족하는 출력을 생성하는 (또는 더 상세하게는 &lt;code&gt;ORDER BY x DESC NULLS FIRST&lt;/code&gt; ) 인덱스를 뒤로 스캔 할 수도 있습니다. &lt;code&gt;NULLS FIRST&lt;/code&gt; 는 &lt;code&gt;ORDER BY DESC&lt;/code&gt; 의 기본값 이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f6d5d67ccaf09eaeb6ef7377a91514709c5059c7" translate="yes" xml:space="preserve">
          <source>By default, PostgreSQL allocates a very small amount of System V shared memory, as well as a much larger amount of anonymous &lt;code&gt;mmap&lt;/code&gt; shared memory. Alternatively, a single large System V shared memory region can be used (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt;). In addition a significant number of semaphores, which can be either System V or POSIX style, are created at server startup. Currently, POSIX semaphores are used on Linux and FreeBSD systems while other platforms use System V semaphores.</source>
          <target state="translated">기본적으로 PostgreSQL은 매우 적은 양의 System V 공유 메모리와 훨씬 더 많은 익명의 &lt;code&gt;mmap&lt;/code&gt; 공유 메모리를 할당 합니다. 또는 하나의 큰 System V 공유 메모리 영역을 사용할 수 있습니다 ( &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; 참조 ). 또한 System V 또는 POSIX 스타일 일 수있는 많은 수의 세마포어가 서버 시작시 작성됩니다. 현재 POSIX 세마포어는 Linux 및 FreeBSD 시스템에서 사용되는 반면 다른 플랫폼은 System V 세마포어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d5112c6a6f4a183b23febd8e6d04aee3595be29" translate="yes" xml:space="preserve">
          <source>By default, PostgreSQL assigns the names &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. to the columns of a &lt;code&gt;VALUES&lt;/code&gt; table. The column names are not specified by the SQL standard and different database systems do it differently, so it's usually better to override the default names with a table alias list, like this:</source>
          <target state="translated">기본적으로 PostgreSQL은 이름 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등을 &lt;code&gt;VALUES&lt;/code&gt; 테이블 의 열에 할당 합니다. 열 이름은 SQL 표준에 의해 지정되지 않으며 다른 데이터베이스 시스템은 다르게 수행하므로 일반적으로 다음과 같이 테이블 별명 목록으로 기본 이름을 대체하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95bcb0edee685e99045ff9209204f6710283bfbb" translate="yes" xml:space="preserve">
          <source>By default, a GiST index build switches to the buffering method when the index size reaches &lt;a href=&quot;runtime-config-query#GUC-EFFECTIVE-CACHE-SIZE&quot;&gt;effective_cache_size&lt;/a&gt;. It can be manually turned on or off by the &lt;code&gt;buffering&lt;/code&gt; parameter to the CREATE INDEX command. The default behavior is good for most cases, but turning buffering off might speed up the build somewhat if the input data is ordered.</source>
          <target state="translated">기본적으로 GiST 인덱스 빌드는 인덱스 크기가 &lt;a href=&quot;runtime-config-query#GUC-EFFECTIVE-CACHE-SIZE&quot;&gt;effective_cache_size에&lt;/a&gt; 도달하면 버퍼링 방법으로 전환됩니다 . CREATE INDEX 명령에 &lt;code&gt;buffering&lt;/code&gt; 매개 변수를 사용하여 수동으로 켜거나 끌 수 있습니다 . 기본 동작은 대부분의 경우에 좋지만 입력 데이터가 주문 된 경우 버퍼링을 끄면 빌드 속도가 다소 빨라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9518ab9b08e7bcd057eb1671276711e3db7a05db" translate="yes" xml:space="preserve">
          <source>By default, a cast can be invoked only by an explicit cast request, that is an explicit &lt;code&gt;CAST(x AS typename)&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;typename&lt;/code&gt; construct.</source>
          <target state="translated">기본적으로 캐스트는 명시 적 캐스트 요청, 즉 명시 적 &lt;code&gt;CAST(x AS typename)&lt;/code&gt; 또는 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;::&lt;/code&gt; &lt;code&gt;typename&lt;/code&gt; 구성에 의해서만 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78836ce5d2eb0478baace71feb0580df09029d89" translate="yes" xml:space="preserve">
          <source>By default, a side-effect-free &lt;code&gt;WITH&lt;/code&gt; query is folded into the primary query if it is used exactly once in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking the &lt;code&gt;WITH&lt;/code&gt; query as &lt;code&gt;MATERIALIZED&lt;/code&gt;. That might be useful, for example, if the &lt;code&gt;WITH&lt;/code&gt; query is being used as an optimization fence to prevent the planner from choosing a bad plan. PostgreSQL versions before v12 never did such folding, so queries written for older versions might rely on &lt;code&gt;WITH&lt;/code&gt; to act as an optimization fence.</source>
          <target state="translated">기본적으로 부작용이없는 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 기본 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에서 정확히 한 번만 사용되는 경우 기본 쿼리로 접 힙니다 . 이를 통해 의미 적으로 보이지 않는 상황에서 두 쿼리 수준을 공동으로 최적화 할 수 있습니다. 그러나 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 &lt;code&gt;MATERIALIZED&lt;/code&gt; 로 표시하면 이러한 폴딩을 방지 할 수 있습니다 . 예를 들어 &lt;code&gt;WITH&lt;/code&gt; 쿼리가 최적화 펜스로 사용되어 플래너가 잘못된 계획을 선택하지 못하게하는 경우 유용 할 수 있습니다 . v12 이전의 PostgreSQL 버전은 이러한 폴딩을 수행하지 않았으므로 이전 버전 용으로 작성된 쿼리는 &lt;code&gt;WITH&lt;/code&gt; 를 사용하여 최적화 펜스 역할을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f707e3c37120d93e6cd7bf3ab1d3cdf9ae694731" translate="yes" xml:space="preserve">
          <source>By default, a standby server restores WAL records from the sending server as soon as possible. It may be useful to have a time-delayed copy of the data, offering opportunities to correct data loss errors. This parameter allows you to delay recovery by a specified amount of time. For example, if you set this parameter to &lt;code&gt;5min&lt;/code&gt;, the standby will replay each transaction commit only when the system time on the standby is at least five minutes past the commit time reported by the master. If this value is specified without units, it is taken as milliseconds. The default is zero, adding no delay.</source>
          <target state="translated">기본적으로 대기 서버는 가능한 빨리 전송 서버에서 WAL 레코드를 복원합니다. 데이터 지연 시간을 수정하여 데이터 손실 오류를 수정할 수있는 기회를 제공하는 데 시간이 지연된 데이터 사본을 보유하는 것이 유용 할 수 있습니다. 이 매개 변수를 사용하면 지정된 시간만큼 복구를 지연시킬 수 있습니다. 예를 들어,이 매개 변수를 &lt;code&gt;5min&lt;/code&gt; 으로 설정 하면 대기의 시스템 시간이 마스터가보고 한 커밋 시간보다 5 분 이상 지난 경우에만 대기가 각 트랜잭션 커밋을 재생합니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 0이며 지연이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0062f220bac13d83889b8bdbd40b0e28de2cbf32" translate="yes" xml:space="preserve">
          <source>By default, all tables and views existing in a particular schema on the foreign server are imported. Optionally, the list of tables can be limited to a specified subset, or specific tables can be excluded. The new foreign tables are all created in the target schema, which must already exist.</source>
          <target state="translated">기본적으로 외부 서버의 특정 스키마에 존재하는 모든 테이블과 뷰를 가져옵니다. 선택적으로 테이블 목록을 지정된 서브 세트로 제한하거나 특정 테이블을 제외 할 수 있습니다. 새 외부 테이블은 모두 목표 스키마에 작성되며, 이미 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ff32c06ed2b330c24aacf6672aa71190f12a8e0" translate="yes" xml:space="preserve">
          <source>By default, checksums are verified and checksum failures will result in a non-zero exit status. However, the base backup will not be removed in such a case, as if the &lt;code&gt;--no-clean&lt;/code&gt; option had been used. Checksum verifications failures will also be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">기본적으로 체크섬이 확인되고 체크섬이 실패하면 종료 상태가 0이 아닙니다. 그러나 이런 경우 &lt;code&gt;--no-clean&lt;/code&gt; 옵션이 사용 된 것처럼 기본 백업은 제거되지 않습니다 . 체크섬 확인 실패도 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; 보기에 보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="a560a90f898f8246e7e4f7444eb268c641b6dc5b" translate="yes" xml:space="preserve">
          <source>By default, command processing continues after an error. When this variable is set to &lt;code&gt;on&lt;/code&gt;, processing will instead stop immediately. In interactive mode, psql will return to the command prompt; otherwise, psql will exit, returning error code 3 to distinguish this case from fatal error conditions, which are reported using error code 1. In either case, any currently running scripts (the top-level script, if any, and any other scripts which it may have in invoked) will be terminated immediately. If the top-level command string contained multiple SQL commands, processing will stop with the current command.</source>
          <target state="translated">기본적으로 명령 처리는 오류 후에 계속됩니다. 이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정하면 처리가 즉시 중지됩니다. 대화식 모드에서 psql은 명령 프롬프트로 돌아갑니다. 그렇지 않으면 psql이 종료되고 오류 코드 3을 반환하여 오류 코드 1을 사용하여보고되는 치명적 오류 조건과이 사례를 구별합니다. 두 경우 모두 현재 실행중인 스크립트 (최상위 스크립트,있는 경우) 및 기타 스크립트 호출되었을 수 있음) 즉시 종료됩니다. 최상위 명령 문자열에 여러 SQL 명령이 포함 된 경우 현재 명령으로 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="c496804ab443f5ab6f5251de611b0ed906df79f8" translate="yes" xml:space="preserve">
          <source>By default, connection log messages only show the IP address of the connecting host. Turning this parameter on causes logging of the host name as well. Note that depending on your host name resolution setup this might impose a non-negligible performance penalty. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">기본적으로 연결 로그 메시지는 연결 호스트의 IP 주소 만 표시합니다. 이 매개 변수를 켜면 호스트 이름도 기록됩니다. 호스트 이름 확인 설정에 따라 무시할 수없는 성능 저하가 발생할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2cb10f9601bf125d113e5f98b6a6bec8328b483" translate="yes" xml:space="preserve">
          <source>By default, floating point values are output in text form in their shortest precise decimal representation; the decimal value produced is closer to the true stored binary value than to any other value representable in the same binary precision. (However, the output value is currently never &lt;em&gt;exactly&lt;/em&gt; midway between two representable values, in order to avoid a widespread bug where input routines do not properly respect the round-to-even rule.) This value will use at most 17 significant decimal digits for &lt;code&gt;float8&lt;/code&gt; values, and at most 9 digits for &lt;code&gt;float4&lt;/code&gt; values.</source>
          <target state="translated">기본적으로 부동 소수점 값은 가장 짧은 정확한 10 진수 표현으로 텍스트 형식으로 출력됩니다. 생성 된 십진수 값은 동일한 이진 정밀도로 표현할 수있는 다른 값보다 실제 저장된 이진 값에 더 가깝습니다. (단, 출력 값은 결코 현재 &lt;em&gt;정확히&lt;/em&gt; 입력 루틴이 제대로 라운드에 심지어 규칙을 존중하지 않는 광범위한 버그를 방지하기 위해, 중간이 개 표현 가능한 값 사이.)이 값은 가장 17 중요한 진수에 사용 &lt;code&gt;float8&lt;/code&gt; 값 및 &lt;code&gt;float4&lt;/code&gt; 값의 경우 최대 9 자리</target>
        </trans-unit>
        <trans-unit id="b8ea675b27a48f435ea5af00f412fdb479b874ca" translate="yes" xml:space="preserve">
          <source>By default, only &lt;code&gt;WHERE&lt;/code&gt; clauses using built-in operators and functions will be considered for execution on the remote server. Clauses involving non-built-in functions are checked locally after rows are fetched. If such functions are available on the remote server and can be relied on to produce the same results as they do locally, performance can be improved by sending such &lt;code&gt;WHERE&lt;/code&gt; clauses for remote execution. This behavior can be controlled using the following option:</source>
          <target state="translated">기본적으로, 내장 연산자와 함수를 사용하는 &lt;code&gt;WHERE&lt;/code&gt; 절만 원격 서버에서 실행되는 것으로 간주됩니다. 내장 함수가 아닌 절은 행을 페치 한 후에 로컬로 점검됩니다. 이러한 기능이 원격 서버에서 사용 가능하고 로컬에서와 동일한 결과를 생성하는 데 의존 할 수있는 경우 원격 실행을 위해 &lt;code&gt;WHERE&lt;/code&gt; 절을 전송하여 성능을 향상시킬 수 있습니다 . 이 동작은 다음 옵션을 사용하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44430e6dc22e36766f26461b571e7fad5599537" translate="yes" xml:space="preserve">
          <source>By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="84eca666e9be0384ce24adaa941223dc1388c0fe" translate="yes" xml:space="preserve">
          <source>By default, pg_dump uses &lt;code&gt;COPY&lt;/code&gt;, and when it is generating a complete schema-and-data dump, it is careful to load data before creating indexes and foreign keys. So in this case several guidelines are handled automatically. What is left for you to do is to:</source>
          <target state="translated">기본적으로 pg_dump는 &lt;code&gt;COPY&lt;/code&gt; 를 사용 하며 완전한 스키마 및 데이터 덤프를 생성하는 경우 인덱스 및 외래 키를 만들기 전에 데이터를로드하는 데주의해야합니다. 따라서이 경우 몇 가지 지침이 자동으로 처리됩니다. 당신이해야 할 일은 :</target>
        </trans-unit>
        <trans-unit id="70659cc257c963a48edee3365f7ee706626aef7b" translate="yes" xml:space="preserve">
          <source>By default, probes are not available, so you will need to explicitly tell the configure script to make the probes available in PostgreSQL. To include DTrace support specify &lt;code&gt;--enable-dtrace&lt;/code&gt; to configure. See &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt; for further information.</source>
          <target state="translated">기본적으로 프로브를 사용할 수 없으므로 PostgreSQL에서 프로브를 사용할 수 있도록 configure 스크립트를 명시 적으로 알려야합니다. DTrace 지원을 포함 시키려면 &lt;code&gt;--enable-dtrace&lt;/code&gt; 를 지정 하여 구성하십시오. 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;16.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e34b0da35878a3936d296ebd79b8956e8e7181ad" translate="yes" xml:space="preserve">
          <source>By default, recovery will recover to the end of the WAL log. The following parameters can be used to specify an earlier stopping point. At most one of &lt;code&gt;recovery_target&lt;/code&gt;, &lt;code&gt;recovery_target_lsn&lt;/code&gt;, &lt;code&gt;recovery_target_name&lt;/code&gt;, &lt;code&gt;recovery_target_time&lt;/code&gt;, or &lt;code&gt;recovery_target_xid&lt;/code&gt; can be used; if more than one of these is specified in the configuration file, an error will be raised. These parameters can only be set at server start.</source>
          <target state="translated">기본적으로 복구는 WAL 로그 끝까지 복구됩니다. 다음 매개 변수를 사용하여 이전 중지 지점을 지정할 수 있습니다. &lt;code&gt;recovery_target&lt;/code&gt; , &lt;code&gt;recovery_target_lsn&lt;/code&gt; , &lt;code&gt;recovery_target_name&lt;/code&gt; , &lt;code&gt;recovery_target_time&lt;/code&gt; 또는 &lt;code&gt;recovery_target_xid&lt;/code&gt; 중 최대 하나를 사용할 수 있습니다. 구성 파일에 둘 이상이 지정된 경우 오류가 발생합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68a7fa3368775dbbe67be55a6bf41e8f9011897" translate="yes" xml:space="preserve">
          <source>By default, table data is restored even if the creation command for the table failed (e.g., because it already exists). With this option, data for such a table is skipped. This behavior is useful if the target database already contains the desired table contents. For example, auxiliary tables for PostgreSQL extensions such as PostGIS might already be loaded in the target database; specifying this option prevents duplicate or obsolete data from being loaded into them.</source>
          <target state="translated">기본적으로 테이블의 작성 명령이 실패한 경우에도 (예 : 이미 존재하기 때문에) 테이블 데이터가 복원됩니다. 이 옵션을 사용하면 해당 테이블의 데이터를 건너 뜁니다. 이 동작은 대상 데이터베이스에 원하는 테이블 내용이 이미 포함 된 경우에 유용합니다. 예를 들어 PostGIS와 같은 PostgreSQL 확장에 대한 보조 테이블이 대상 데이터베이스에 이미로드되어있을 수 있습니다. 이 옵션을 지정하면 중복되거나 더 이상 사용되지 않는 데이터가로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="938bcc328e251fd065ac790e820d24708cece22b" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_config&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_config&lt;/code&gt; 보기는 수퍼 유저 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca1e9d32f7ce039fccc5e945dfbea3cfa377ca3" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_file_settings&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_file_settings&lt;/code&gt; 뷰는 수퍼 유저 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11bc9b5dcf74fe244aef327d6abd1c9f703080a6" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_hba_file_rules&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_hba_file_rules&lt;/code&gt; 보기는 수퍼 유저 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a88f67228f7f2606ad9e9b6a422ac102dba107f7" translate="yes" xml:space="preserve">
          <source>By default, the array element type is the common type of the member expressions, determined using the same rules as for &lt;code&gt;UNION&lt;/code&gt; or &lt;code&gt;CASE&lt;/code&gt; constructs (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;). You can override this by explicitly casting the array constructor to the desired type, for example:</source>
          <target state="translated">기본적으로 배열 요소 유형은 &lt;code&gt;UNION&lt;/code&gt; 또는 &lt;code&gt;CASE&lt;/code&gt; 구문 과 동일한 규칙을 사용하여 판별되는 멤버 표현식의 공통 유형입니다 ( &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 참조 ). 배열 생성자를 원하는 형식으로 명시 적으로 캐스팅하여이를 재정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3591838c95961e914884bf460a76fd06162e5a35" translate="yes" xml:space="preserve">
          <source>By default, the lower bound index value of an array's dimensions is set to one. To represent arrays with other lower bounds, the array subscript ranges can be specified explicitly before writing the array contents. This decoration consists of square brackets (&lt;code&gt;[]&lt;/code&gt;) around each array dimension's lower and upper bounds, with a colon (&lt;code&gt;:&lt;/code&gt;) delimiter character in between. The array dimension decoration is followed by an equal sign (&lt;code&gt;=&lt;/code&gt;). For example:</source>
          <target state="translated">기본적으로 배열 차원의 하한 인덱스 값은 1로 설정됩니다. 하한이 다른 배열을 나타내려면 배열 내용을 쓰기 전에 배열 첨자 범위를 명시 적으로 지정할 수 있습니다. 이 장식은 대괄호 (구성 &lt;code&gt;[]&lt;/code&gt; (콜론, 각 배열 차원의 하부 및 상부 경계 주위) &lt;code&gt;:&lt;/code&gt; ) 사이에 구분 문자. 배열 치수 장식 다음에는 등호 ( &lt;code&gt;=&lt;/code&gt; ) 가옵니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd894373c2bb27879ba8c09c0eb0e05e4db1539e" translate="yes" xml:space="preserve">
          <source>By default, the new database will be created by cloning the standard system database &lt;code&gt;template1&lt;/code&gt;. A different template can be specified by writing &lt;code&gt;TEMPLATE name&lt;/code&gt;. In particular, by writing &lt;code&gt;TEMPLATE template0&lt;/code&gt;, you can create a virgin database containing only the standard objects predefined by your version of PostgreSQL. This is useful if you wish to avoid copying any installation-local objects that might have been added to &lt;code&gt;template1&lt;/code&gt;.</source>
          <target state="translated">기본적으로 표준 데이터베이스 데이터베이스 &lt;code&gt;template1&lt;/code&gt; 을 복제하여 새 데이터베이스가 작성됩니다 . &lt;code&gt;TEMPLATE name&lt;/code&gt; 을 작성하여 다른 템플릿을 지정할 수 있습니다 . 특히, &lt;code&gt;TEMPLATE template0&lt;/code&gt; 을 작성하면 PostgreSQL 버전으로 사전 정의 된 표준 객체 만 포함하는 처녀 데이터베이스를 만들 수 있습니다. &lt;code&gt;template1&lt;/code&gt; 에 추가되었을 수있는 설치 로컬 객체를 복사하지 않으려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f862162ca39718449320291cb0bbfd45cc6c0117" translate="yes" xml:space="preserve">
          <source>By default, the psql script will continue to execute after an SQL error is encountered. You might wish to run psql with the &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; variable set to alter that behavior and have psql exit with an exit status of 3 if an SQL error occurs:</source>
          <target state="translated">기본적으로 psql 스크립트는 SQL 오류가 발생한 후에도 계속 실행됩니다. &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; 변수를 설정하여 psql을 실행 하여 해당 동작을 변경하고 SQL 오류가 발생하는 경우 종료 상태가 3 인 psql 종료를 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87f7d852da9b9d6ce1fdafcecffc01cbd65edbd0" translate="yes" xml:space="preserve">
          <source>By default, the value created by a &lt;code&gt;ROW&lt;/code&gt; expression is of an anonymous record type. If necessary, it can be cast to a named composite type &amp;mdash; either the row type of a table, or a composite type created with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;. An explicit cast might be needed to avoid ambiguity. For example:</source>
          <target state="translated">기본적으로 &lt;code&gt;ROW&lt;/code&gt; 표현식으로 작성된 값 은 익명 레코드 유형입니다. 필요한 경우 명명 된 복합 유형 (테이블의 행 유형 또는 &lt;code&gt;CREATE TYPE AS&lt;/code&gt; 로 작성된 복합 유형)으로 캐스트 할 수 있습니다 . 모호성을 피하기 위해 명시 적 캐스트가 필요할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7a2912fb8fcc0f01a5b34a76950a5650d5bebcf" translate="yes" xml:space="preserve">
          <source>By default, these functions are executable only by superusers and members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role, with the exception of &lt;code&gt;pg_truncate_visibility_map(relation regclass)&lt;/code&gt; which can only be executed by superusers.</source>
          <target state="translated">기본적으로 이러한 기능은 수퍼 유저 만 실행할 수있는 &lt;code&gt;pg_truncate_visibility_map(relation regclass)&lt;/code&gt; 를 제외 하고 수퍼 유저 및 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 역할의 멤버 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="446669d309fb465403327b1660f824b344b44bfb" translate="yes" xml:space="preserve">
          <source>By default, this variable is set the same as &lt;code&gt;from_collapse_limit&lt;/code&gt;, which is appropriate for most uses. Setting it to 1 prevents any reordering of explicit &lt;code&gt;JOIN&lt;/code&gt;s. Thus, the explicit join order specified in the query will be the actual order in which the relations are joined. Because the query planner does not always choose the optimal join order, advanced users can elect to temporarily set this variable to 1, and then specify the join order they desire explicitly. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">기본적으로이 변수는 &lt;code&gt;from_collapse_limit&lt;/code&gt; 와 동일하게 설정 되며 대부분의 용도에 적합합니다. 1로 설정하면 명시 적 &lt;code&gt;JOIN&lt;/code&gt; 이 재정렬되지 않습니다 . 따라서 조회에 지정된 명시 적 결합 순서는 관계가 결합되는 실제 순서입니다. 쿼리 플래너가 항상 최적의 조인 순서를 선택하지는 않으므로 고급 사용자는이 변수를 일시적으로 1로 설정 한 다음 원하는 조인 순서를 명시 적으로 지정할 수 있습니다. 자세한 정보는 &lt;a href=&quot;explicit-joins&quot;&gt;14.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5fda89ea07462f31e5d8ea4c4e4b93c88a52d39" translate="yes" xml:space="preserve">
          <source>By default, users cannot access any objects in schemas they do not own. To allow that, the owner of the schema must grant the &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema. To allow users to make use of the objects in the schema, additional privileges might need to be granted, as appropriate for the object.</source>
          <target state="translated">기본적으로 사용자는 자신이 소유하지 않은 스키마의 객체에 액세스 할 수 없습니다. 이를 허용하려면 스키마 소유자가 스키마에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한을 부여해야합니다 . 사용자가 스키마에서 개체를 사용할 수있게하려면 개체에 적절한 추가 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6afb384acb9e661836b4ed370b6bfc2d551d532e" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;initdb&lt;/code&gt; determines that an error prevented it from completely creating the database cluster, it removes any files it might have created before discovering that it cannot finish the job. This option inhibits tidying-up and is thus useful for debugging.</source>
          <target state="translated">기본적으로, &lt;code&gt;initdb&lt;/code&gt; 는 오류로 인해 데이터베이스 클러스터를 완전히 작성하지 못한 것으로 판별하면 작업을 완료 할 수 없음을 발견하기 전에 작성된 파일을 제거합니다. 이 옵션은 정리를 금지하므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9f3c7c286549c13ef09a8657f7d741258feadbff" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;pg_basebackup&lt;/code&gt; aborts with an error, it removes any directories it might have created before discovering that it cannot finish the job (for example, data directory and write-ahead log directory). This option inhibits tidying-up and is thus useful for debugging.</source>
          <target state="translated">기본적으로 &lt;code&gt;pg_basebackup&lt;/code&gt; 이 오류와 함께 중단되면 작업을 완료 할 수 없음을 발견하기 전에 작성한 디렉토리 (예 : 데이터 디렉토리 및 미리 쓰기 로그 디렉토리)를 제거합니다. 이 옵션은 정리를 금지하므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5d2d5200ed36b4f1ceba70175eb5ac569f06a690" translate="yes" xml:space="preserve">
          <source>By design, ICU will accept almost any string as a locale name and match it to the closest locale it can provide, using the fallback procedure described in its documentation. Thus, there will be no direct feedback if a collation specification is composed using features that the given ICU installation does not actually support. It is therefore recommended to create application-level test cases to check that the collation definitions satisfy one's requirements.</source>
          <target state="translated">설계 상 ICU는 거의 모든 문자열을 로캘 이름으로 받아들이고 해당 설명서에 설명 된 폴백 절차를 사용하여 제공 할 수있는 가장 가까운 로캘과 일치시킵니다. 따라서 지정된 ICU 설치에서 실제로 지원하지 않는 기능을 사용하여 데이터 정렬 사양을 구성하면 직접적인 피드백이 없습니다. 따라서 데이터 정렬 정의가 요구 사항을 충족하는지 확인하기 위해 응용 프로그램 수준 테스트 사례를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a5e9693cd42a9a7f1772aa42a6b36d8781e0c7b0" translate="yes" xml:space="preserve">
          <source>By redefining the statistics object to include n-distinct counts for the two columns, the estimate is much improved:</source>
          <target state="translated">두 열에 대해 n 개의 고유 카운트를 포함하도록 통계 개체를 재정의하면 추정치가 훨씬 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="ca686ce897e1abc4af0ddbb3c8a9400c719ef37e" translate="yes" xml:space="preserve">
          <source>By using tablespaces, an administrator can control the disk layout of a PostgreSQL installation. This is useful in at least two ways. First, if the partition or volume on which the cluster was initialized runs out of space and cannot be extended, a tablespace can be created on a different partition and used until the system can be reconfigured.</source>
          <target state="translated">관리자는 테이블 스페이스를 사용하여 PostgreSQL 설치의 디스크 레이아웃을 제어 할 수 있습니다. 이것은 적어도 두 가지 방법으로 유용합니다. 먼저, 클러스터가 초기화 된 파티션 또는 볼륨에 공간이 부족하여 확장 할 수없는 경우, 다른 파티션에서 테이블 스페이스를 작성하고 시스템을 재구성 할 수있을 때까지 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc55e9079e768265d2074904a05887307e46957" translate="yes" xml:space="preserve">
          <source>By using the EXPLAIN command and the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; configuration parameter, it's possible to show the difference between a plan for which partitions have been pruned and one for which they have not. A typical unoptimized plan for this type of table setup is:</source>
          <target state="translated">EXPLAIN 명령과 &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; 구성 매개 변수 를 사용하면 분할 된 계획과 그렇지 않은 계획의 차이를 표시 할 수 있습니다. 이 유형의 테이블 설정에 대한 일반적인 최적화되지 않은 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dd73397fb8c38422ccd4664552ba4e84e357bc5" translate="yes" xml:space="preserve">
          <source>Bytes/Char</source>
          <target state="translated">Bytes/Char</target>
        </trans-unit>
        <trans-unit id="09acbb7d1da8aa3daff4c1ec8076713606974c64" translate="yes" xml:space="preserve">
          <source>CA</source>
          <target state="translated">CA</target>
        </trans-unit>
        <trans-unit id="1b3cb484695189b567d88ee9266fe7c295405a5c" translate="yes" xml:space="preserve">
          <source>CALL</source>
          <target state="translated">CALL</target>
        </trans-unit>
        <trans-unit id="419a5f50b7408f1dca60e896cea951f0e9ecd6b4" translate="yes" xml:space="preserve">
          <source>CALL &amp;mdash; invoke a procedure</source>
          <target state="translated">호출 &amp;mdash; 프로 시저 호출</target>
        </trans-unit>
        <trans-unit id="7477d3df9a8d34a128e2d80082cf97370f07e887" translate="yes" xml:space="preserve">
          <source>CHECKPOINT</source>
          <target state="translated">CHECKPOINT</target>
        </trans-unit>
        <trans-unit id="13213822c571d7742c3e15242191df8ccdfb4ba2" translate="yes" xml:space="preserve">
          <source>CHECKPOINT &amp;mdash; force a write-ahead log checkpoint</source>
          <target state="translated">CHECKPOINT-미리 쓰기 로그 체크 포인트를 강제 실행</target>
        </trans-unit>
        <trans-unit id="36977700f4822e3e205bf0238bce67dbe3b91b01" translate="yes" xml:space="preserve">
          <source>CIDR</source>
          <target state="translated">CIDR</target>
        </trans-unit>
        <trans-unit id="dbc87420347a2d9903d256035f6466489d185381" translate="yes" xml:space="preserve">
          <source>CLOSE</source>
          <target state="translated">CLOSE</target>
        </trans-unit>
        <trans-unit id="97a54a1a3cc7674867530dac20934b089b136388" translate="yes" xml:space="preserve">
          <source>CLOSE &amp;mdash; close a cursor</source>
          <target state="translated">CLOSE &amp;mdash; 커서를 닫습니다</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="6ed38588d12a88b9f02ddf8e838df59030bdc223" translate="yes" xml:space="preserve">
          <source>CLUSTER &amp;mdash; cluster a table according to an index</source>
          <target state="translated">CLUSTER &amp;mdash; 인덱스에 따라 테이블을 클러스터링</target>
        </trans-unit>
        <trans-unit id="b1a13fadf51ef7eece7dea40c4b6e6e8042822d2" translate="yes" xml:space="preserve">
          <source>COMMENT</source>
          <target state="translated">COMMENT</target>
        </trans-unit>
        <trans-unit id="24f7342cb20d190bab761b0e4961854f758b7f6b" translate="yes" xml:space="preserve">
          <source>COMMENT &amp;mdash; define or change the comment of an object</source>
          <target state="translated">주석 &amp;mdash; 객체의 주석을 정의하거나 변경합니다</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="483a6ce560e1decead0608ec6f96c5eb80c60b37" translate="yes" xml:space="preserve">
          <source>COMMIT &amp;mdash; commit the current transaction</source>
          <target state="translated">COMMIT &amp;mdash; 현재 트랜잭션 커밋</target>
        </trans-unit>
        <trans-unit id="928f39135ea222a061b51eda52616e1d70b6f4ed" translate="yes" xml:space="preserve">
          <source>COMMIT PREPARED</source>
          <target state="translated">커밋 준비</target>
        </trans-unit>
        <trans-unit id="7efac7831084dae760da22dfe2ccdf6a8467284f" translate="yes" xml:space="preserve">
          <source>COMMIT PREPARED &amp;mdash; commit a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">COMMIT PREPARED &amp;mdash; 이전에 2 단계 커밋을 위해 준비된 트랜잭션을 커밋</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="f9753e0a6bebe6b414113aa884e48a8692c57a00" translate="yes" xml:space="preserve">
          <source>COPY &amp;mdash; copy data between a file and a table</source>
          <target state="translated">COPY &amp;mdash; 파일과 테이블간에 데이터 복사</target>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="d96e1a6da4b22e767e2f00e6ac5822929d6b6431" translate="yes" xml:space="preserve">
          <source>CREATE ACCESS METHOD</source>
          <target state="translated">액세스 방법 작성</target>
        </trans-unit>
        <trans-unit id="b60ba4afed837bb62b0e217ef3453fec9b20aa8b" translate="yes" xml:space="preserve">
          <source>CREATE ACCESS METHOD &amp;mdash; define a new access method</source>
          <target state="translated">액세스 방법 작성 &amp;mdash; 새로운 액세스 방법을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="dca4577463aa3fe977b4f25b93142362498a7ab4" translate="yes" xml:space="preserve">
          <source>CREATE AGGREGATE</source>
          <target state="translated">집계 생성</target>
        </trans-unit>
        <trans-unit id="1e5d6e908efdad05a1dfb7400a1512114a9ba148" translate="yes" xml:space="preserve">
          <source>CREATE AGGREGATE &amp;mdash; define a new aggregate function</source>
          <target state="translated">CREATE AGGREGATE &amp;mdash; 새로운 집계 함수를 정의합니다</target>
        </trans-unit>
        <trans-unit id="27453be4f19eeb395ed1c1f26aee7e6994d6f565" translate="yes" xml:space="preserve">
          <source>CREATE CAST</source>
          <target state="translated">주물 만들기</target>
        </trans-unit>
        <trans-unit id="5b11bc113a182153b70257c85a8f9b6e3a11ce42" translate="yes" xml:space="preserve">
          <source>CREATE CAST &amp;mdash; define a new cast</source>
          <target state="translated">CREATE CAST &amp;mdash; 새로운 캐스트 정의</target>
        </trans-unit>
        <trans-unit id="15821e9ce820c98a60236ff18257f17f124c1103" translate="yes" xml:space="preserve">
          <source>CREATE COLLATION</source>
          <target state="translated">컬렉션 생성</target>
        </trans-unit>
        <trans-unit id="fbcbd528094c2c09b27455d50f5f56aa490f8fbc" translate="yes" xml:space="preserve">
          <source>CREATE COLLATION &amp;mdash; define a new collation</source>
          <target state="translated">CREATE COLLATION &amp;mdash; 새 데이터 정렬을 정의합니다</target>
        </trans-unit>
        <trans-unit id="9a590dab7b1573de682ed6118e55cc8e20312a59" translate="yes" xml:space="preserve">
          <source>CREATE CONVERSION</source>
          <target state="translated">변환 작성</target>
        </trans-unit>
        <trans-unit id="6193de73c2aaf0a006c421f6069d282ec6fd1764" translate="yes" xml:space="preserve">
          <source>CREATE CONVERSION &amp;mdash; define a new encoding conversion</source>
          <target state="translated">CREATE CONVERSION &amp;mdash; 새로운 인코딩 변환 정의</target>
        </trans-unit>
        <trans-unit id="7d4062ecf576482c660a1aa699cc54b88d165ea7" translate="yes" xml:space="preserve">
          <source>CREATE DATABASE</source>
          <target state="translated">데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="7c394e959f481a40604ae937a3ac22ef5ebc2056" translate="yes" xml:space="preserve">
          <source>CREATE DATABASE &amp;mdash; create a new database</source>
          <target state="translated">CREATE DATABASE &amp;mdash; 새 데이터베이스를 만듭니다</target>
        </trans-unit>
        <trans-unit id="b70b81109668b468c0c6dead2038258a2d265479" translate="yes" xml:space="preserve">
          <source>CREATE DOMAIN</source>
          <target state="translated">도메인 만들기</target>
        </trans-unit>
        <trans-unit id="e9fdc1a9b6d567085f0f98916df0ab99c45f6576" translate="yes" xml:space="preserve">
          <source>CREATE DOMAIN &amp;mdash; define a new domain</source>
          <target state="translated">CREATE DOMAIN &amp;mdash; 새 도메인을 정의합니다</target>
        </trans-unit>
        <trans-unit id="31a3846387771411310180f6f1fde6520c80f8c4" translate="yes" xml:space="preserve">
          <source>CREATE EVENT TRIGGER</source>
          <target state="translated">이벤트 트리거 만들기</target>
        </trans-unit>
        <trans-unit id="a5c622c0285b981c4bc8ab15e53228ce8796f173" translate="yes" xml:space="preserve">
          <source>CREATE EVENT TRIGGER &amp;mdash; define a new event trigger</source>
          <target state="translated">이벤트 트리거 생성 &amp;mdash; 새 이벤트 트리거를 정의</target>
        </trans-unit>
        <trans-unit id="1845fb209e3e906a586ca08a84b971749b1cc321" translate="yes" xml:space="preserve">
          <source>CREATE EXTENSION</source>
          <target state="translated">확장 만들기</target>
        </trans-unit>
        <trans-unit id="42d4ae949a8ecfb7e4238283d2d692f05b447628" translate="yes" xml:space="preserve">
          <source>CREATE EXTENSION &amp;mdash; install an extension</source>
          <target state="translated">확장 만들기 &amp;mdash; 확장 설치</target>
        </trans-unit>
        <trans-unit id="06a82006252ed34850ab2a718088e4a5f5d2d70a" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN DATA WRAPPER</source>
          <target state="translated">외국 데이터 랩퍼 만들기</target>
        </trans-unit>
        <trans-unit id="1cafc5712ed76d0e342beb2264bc63216f1effab" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN DATA WRAPPER &amp;mdash; define a new foreign-data wrapper</source>
          <target state="translated">FOREIGN DATA WRAPPER 생성 &amp;mdash; 새로운 외부 데이터 래퍼 정의</target>
        </trans-unit>
        <trans-unit id="28e78e9de49d9e5b91636b1bbba8763694ac0eec" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN TABLE</source>
          <target state="translated">외국 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="04bd70a358fbb9b0d71eac8a4feeb2dfbc87e6d1" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN TABLE &amp;mdash; define a new foreign table</source>
          <target state="translated">CREATE FOREIGN TABLE &amp;mdash; 새로운 외부 테이블을 정의합니다</target>
        </trans-unit>
        <trans-unit id="dafc718f6d046e932a269810aea29356b8b9499e" translate="yes" xml:space="preserve">
          <source>CREATE FUNCTION</source>
          <target state="translated">기능 만들기</target>
        </trans-unit>
        <trans-unit id="4cec9507d23fe9a56fcf1a6029fb62430631c6a0" translate="yes" xml:space="preserve">
          <source>CREATE FUNCTION &amp;mdash; define a new function</source>
          <target state="translated">CREATE FUNCTION &amp;mdash; 새로운 함수를 정의</target>
        </trans-unit>
        <trans-unit id="d6b838babefc8b935a94e798471ee2c10d69cf60" translate="yes" xml:space="preserve">
          <source>CREATE GROUP</source>
          <target state="translated">그룹 만들기</target>
        </trans-unit>
        <trans-unit id="7aeef0722c2ad5240f0a525f90a9c0bd8108eb20" translate="yes" xml:space="preserve">
          <source>CREATE GROUP &amp;mdash; define a new database role</source>
          <target state="translated">CREATE GROUP &amp;mdash; 새로운 데이터베이스 역할 정의</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">색인 만들기</target>
        </trans-unit>
        <trans-unit id="8f6534dfd70827bb61669df54dbb8bd9a1341019" translate="yes" xml:space="preserve">
          <source>CREATE INDEX &amp;mdash; define a new index</source>
          <target state="translated">CREATE INDEX &amp;mdash; 새 색인을 정의합니다</target>
        </trans-unit>
        <trans-unit id="9f70ff049dfe19df7fbaef8d79090867151dc257" translate="yes" xml:space="preserve">
          <source>CREATE LANGUAGE</source>
          <target state="translated">언어 만들기</target>
        </trans-unit>
        <trans-unit id="6de7b6a9d3316d1d0e3bd6f5d978cf27d9aa1514" translate="yes" xml:space="preserve">
          <source>CREATE LANGUAGE &amp;mdash; define a new procedural language</source>
          <target state="translated">언어 생성 &amp;mdash; 새로운 절차 언어 정의</target>
        </trans-unit>
        <trans-unit id="f47bf032497240f851b6a2cbfa5a310fe111bba2" translate="yes" xml:space="preserve">
          <source>CREATE MATERIALIZED VIEW</source>
          <target state="translated">머티리얼 라이즈 뷰 생성</target>
        </trans-unit>
        <trans-unit id="11a481a382a3edcec5ac2501e187bc999acf5aeb" translate="yes" xml:space="preserve">
          <source>CREATE MATERIALIZED VIEW &amp;mdash; define a new materialized view</source>
          <target state="translated">MATERIALIZED VIEW 작성 &amp;mdash; 새로운 구체화 된보기 정의</target>
        </trans-unit>
        <trans-unit id="482429da6e1c15fe2937923636acaa889a99b34a" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR</source>
          <target state="translated">운영자 작성</target>
        </trans-unit>
        <trans-unit id="7f8d16b4a8f98a6caf75fb7d72f5cf65fda233c2" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR &amp;mdash; define a new operator</source>
          <target state="translated">CREATE OPERATOR &amp;mdash; 새 연산자를 정의합니다</target>
        </trans-unit>
        <trans-unit id="d9da3f211232deee62f75b77079130f4e003ceda" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR CLASS</source>
          <target state="translated">운영자 클래스 생성</target>
        </trans-unit>
        <trans-unit id="bc11e10166a90c7c5db110a6df5c36ab3a634b02" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR CLASS &amp;mdash; define a new operator class</source>
          <target state="translated">CREATE OPERATOR CLASS &amp;mdash; 새 연산자 클래스를 정의합니다</target>
        </trans-unit>
        <trans-unit id="623a3d0a1cdac48674d70e9c6f27202077348623" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR FAMILY</source>
          <target state="translated">운영자 가족 만들기</target>
        </trans-unit>
        <trans-unit id="c97a21711f350cb8a76ed5433e8dfc9d47fb839f" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR FAMILY &amp;mdash; define a new operator family</source>
          <target state="translated">운영자 가족 작성 &amp;mdash; 새 운영자 제품군을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1668a9f7ebf5df13d023f1cec484f67c44b8448e" translate="yes" xml:space="preserve">
          <source>CREATE POLICY</source>
          <target state="translated">정책 만들기</target>
        </trans-unit>
        <trans-unit id="5020ad195efa40bf7884f98b9705c18b63503211" translate="yes" xml:space="preserve">
          <source>CREATE POLICY &amp;mdash; define a new row level security policy for a table</source>
          <target state="translated">CREATE POLICY &amp;mdash; 테이블에 대한 새로운 행 수준 보안 정책을 정의합니다</target>
        </trans-unit>
        <trans-unit id="12fa5fcaba8eae05abcc1e5b1cc620eaf6dc3ada" translate="yes" xml:space="preserve">
          <source>CREATE PROCEDURE</source>
          <target state="translated">절차 작성</target>
        </trans-unit>
        <trans-unit id="ac9f4d77ca7ed5459b8332ab6d39c4a338fc5851" translate="yes" xml:space="preserve">
          <source>CREATE PROCEDURE &amp;mdash; define a new procedure</source>
          <target state="translated">CREATE PROCEDURE &amp;mdash; 새로운 절차를 정의</target>
        </trans-unit>
        <trans-unit id="3cedff6ea63cd6d8248f94622fbbe09a93e6b39f" translate="yes" xml:space="preserve">
          <source>CREATE PUBLICATION</source>
          <target state="translated">출판물 만들기</target>
        </trans-unit>
        <trans-unit id="af6f62738c3508470b3eddf2b221111ecdcf5c7b" translate="yes" xml:space="preserve">
          <source>CREATE PUBLICATION &amp;mdash; define a new publication</source>
          <target state="translated">출판물 만들기 &amp;mdash; 새로운 출판물을 정의하십시오</target>
        </trans-unit>
        <trans-unit id="acbbb46d34a4aea4eb00f468a5dcf19d65f95778" translate="yes" xml:space="preserve">
          <source>CREATE ROLE</source>
          <target state="translated">역할 만들기</target>
        </trans-unit>
        <trans-unit id="689c6a5b0f6843ebae96c95b657e92561bccfd8f" translate="yes" xml:space="preserve">
          <source>CREATE ROLE &amp;mdash; define a new database role</source>
          <target state="translated">CREATE ROLE &amp;mdash; 새로운 데이터베이스 역할 정의</target>
        </trans-unit>
        <trans-unit id="9c9b524b6918da216fde80d8ca989b435e864567" translate="yes" xml:space="preserve">
          <source>CREATE RULE</source>
          <target state="translated">규칙 만들기</target>
        </trans-unit>
        <trans-unit id="6ff5a674c9a5d9304820c21513094f421a6fd38c" translate="yes" xml:space="preserve">
          <source>CREATE RULE &amp;mdash; define a new rewrite rule</source>
          <target state="translated">CREATE RULE &amp;mdash; 새로운 다시 쓰기 규칙을 정의합니다</target>
        </trans-unit>
        <trans-unit id="924d310847d294df10c2589c465fb5c4a6254510" translate="yes" xml:space="preserve">
          <source>CREATE SCHEMA</source>
          <target state="translated">스키마 생성</target>
        </trans-unit>
        <trans-unit id="b41fda9a07c379eb9a569e4c355aff770cd2d956" translate="yes" xml:space="preserve">
          <source>CREATE SCHEMA &amp;mdash; define a new schema</source>
          <target state="translated">CREATE SCHEMA &amp;mdash; 새로운 스키마를 정의</target>
        </trans-unit>
        <trans-unit id="bf7598785b07ca70f266afcf7d0a8eb1cf4d0316" translate="yes" xml:space="preserve">
          <source>CREATE SEQUENCE</source>
          <target state="translated">시퀀스 생성</target>
        </trans-unit>
        <trans-unit id="7525f9d62ab7c9d7125bbff19dd959a8725e6be7" translate="yes" xml:space="preserve">
          <source>CREATE SEQUENCE &amp;mdash; define a new sequence generator</source>
          <target state="translated">CREATE SEQUENCE &amp;mdash; 새로운 시퀀스 생성기 정의</target>
        </trans-unit>
        <trans-unit id="3ebe54a161c2c2fcef53be80c658d2a8423ed56d" translate="yes" xml:space="preserve">
          <source>CREATE SERVER</source>
          <target state="translated">서버 생성</target>
        </trans-unit>
        <trans-unit id="ca9eb197f9d10a52fe8fffa9f1b5348bdb60514d" translate="yes" xml:space="preserve">
          <source>CREATE SERVER &amp;mdash; define a new foreign server</source>
          <target state="translated">CREATE SERVER &amp;mdash; 새 외부 서버를 정의합니다</target>
        </trans-unit>
        <trans-unit id="157a801a877cda20c2d0084aac08e4ad59f79225" translate="yes" xml:space="preserve">
          <source>CREATE STATISTICS</source>
          <target state="translated">통계 생성</target>
        </trans-unit>
        <trans-unit id="7f09faa3466ed0240bd2e4dd2aac530863325acb" translate="yes" xml:space="preserve">
          <source>CREATE STATISTICS &amp;mdash; define extended statistics</source>
          <target state="translated">통계 생성-확장 통계 정의</target>
        </trans-unit>
        <trans-unit id="5e0c7a97306134a592b25c59e20dd36d2a769213" translate="yes" xml:space="preserve">
          <source>CREATE SUBSCRIPTION</source>
          <target state="translated">구독 만들기</target>
        </trans-unit>
        <trans-unit id="5ec0c25961be41da80c8a91b830ea4b02df4cf13" translate="yes" xml:space="preserve">
          <source>CREATE SUBSCRIPTION &amp;mdash; define a new subscription</source>
          <target state="translated">구독 만들기 &amp;mdash; 새 구독을 정의합니다</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="26d5b732dbd25f2e1b3d1fbfc02876be87c76737" translate="yes" xml:space="preserve">
          <source>CREATE TABLE &amp;mdash; define a new table</source>
          <target state="translated">CREATE TABLE &amp;mdash; 새 테이블을 정의</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="f17a1b7a9a5cdfbc14bd6e2b3bdb0943d5c8debf" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS &amp;mdash; define a new table from the results of a query</source>
          <target state="translated">CREATE TABLE AS &amp;mdash; 쿼리 결과에서 새 테이블을 정의합니다</target>
        </trans-unit>
        <trans-unit id="eb3911ee759f233a5280c04fb3873a55053eecf0" translate="yes" xml:space="preserve">
          <source>CREATE TABLESPACE</source>
          <target state="translated">테이블 스페이스 생성</target>
        </trans-unit>
        <trans-unit id="7a2efca1d1fa6b73192144d045ac62adbd5febc0" translate="yes" xml:space="preserve">
          <source>CREATE TABLESPACE &amp;mdash; define a new tablespace</source>
          <target state="translated">CREATE TABLESPACE &amp;mdash; 새로운 테이블 스페이스를 정의</target>
        </trans-unit>
        <trans-unit id="f30459fe4e8391762bf04e818af7ed45fea90e31" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH CONFIGURATION</source>
          <target state="translated">텍스트 검색 구성 만들기</target>
        </trans-unit>
        <trans-unit id="98a91abc0640991fbe46b809a84f7c096214adb9" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH CONFIGURATION &amp;mdash; define a new text search configuration</source>
          <target state="translated">텍스트 검색 구성 만들기 &amp;mdash; 새로운 텍스트 검색 구성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e0786ad367cbc7c76eebbdff0d52a92c06682a22" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH DICTIONARY</source>
          <target state="translated">텍스트 검색 사전 만들기</target>
        </trans-unit>
        <trans-unit id="90ccddfdc15f750dfec0d9f6b9bc9a22063d4b78" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH DICTIONARY &amp;mdash; define a new text search dictionary</source>
          <target state="translated">텍스트 검색 사전 만들기 &amp;mdash; 새로운 텍스트 검색 사전을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="371f770602d7c4471f374bc1d1a8431e689987db" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH PARSER</source>
          <target state="translated">텍스트 검색 파서 만들기</target>
        </trans-unit>
        <trans-unit id="b8c7383b1db46fcf9300b35b5eaa298fe202ebd2" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH PARSER &amp;mdash; define a new text search parser</source>
          <target state="translated">텍스트 검색 파서 작성 &amp;mdash; 새 텍스트 검색 파서를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="0e295842db3e33d0a4cc6e5c9a1dd12f6470851f" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH TEMPLATE</source>
          <target state="translated">텍스트 검색 템플릿 만들기</target>
        </trans-unit>
        <trans-unit id="b458565464da05d909a95f9f30c81a3354a718a7" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH TEMPLATE &amp;mdash; define a new text search template</source>
          <target state="translated">텍스트 검색 템플릿 만들기 &amp;mdash; 새 텍스트 검색 템플릿을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="43f626a434ef69424c81fa793ea2be0e2da3655f" translate="yes" xml:space="preserve">
          <source>CREATE TRANSFORM</source>
          <target state="translated">트랜스 폼 생성</target>
        </trans-unit>
        <trans-unit id="afd90f78bb312dd95d197ddbfea9bbf217cbed65" translate="yes" xml:space="preserve">
          <source>CREATE TRANSFORM &amp;mdash; define a new transform</source>
          <target state="translated">CREATE TRANSFORM &amp;mdash; 새로운 변환을 정의합니다</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">트리거 만들기</target>
        </trans-unit>
        <trans-unit id="ad28054db3468768cfafe732739590de2c31517d" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER &amp;mdash; define a new trigger</source>
          <target state="translated">CREATE TRIGGER &amp;mdash; 새 트리거를 정의합니다</target>
        </trans-unit>
        <trans-unit id="84a0c5bdfbf721756e56c1a21782a7726869fb02" translate="yes" xml:space="preserve">
          <source>CREATE TYPE</source>
          <target state="translated">유형 작성</target>
        </trans-unit>
        <trans-unit id="78ecad2beba697ded50856d8a6efbd2767878e3e" translate="yes" xml:space="preserve">
          <source>CREATE TYPE &amp;mdash; define a new data type</source>
          <target state="translated">CREATE TYPE &amp;mdash; 새 데이터 유형을 정의합니다</target>
        </trans-unit>
        <trans-unit id="b9b4f23af8e09b7f85cfa3af0d06b6b261d9ae23" translate="yes" xml:space="preserve">
          <source>CREATE USER</source>
          <target state="translated">사용자 생성</target>
        </trans-unit>
        <trans-unit id="aec95ff6b458aa9525e70591e994d88efd245a4f" translate="yes" xml:space="preserve">
          <source>CREATE USER &amp;mdash; define a new database role</source>
          <target state="translated">CREATE USER &amp;mdash; 새 데이터베이스 역할을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9d48020c90ebc18d37338a7bd718bc869e022a84" translate="yes" xml:space="preserve">
          <source>CREATE USER MAPPING</source>
          <target state="translated">사용자 매핑 만들기</target>
        </trans-unit>
        <trans-unit id="ec0fae676273fd4cdaf28c6a951c036c0cba102d" translate="yes" xml:space="preserve">
          <source>CREATE USER MAPPING &amp;mdash; define a new mapping of a user to a foreign server</source>
          <target state="translated">CREATE USER MAPPING &amp;mdash; 외부 서버에 대한 사용자의 새로운 매핑을 정의합니다</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">보기 작성</target>
        </trans-unit>
        <trans-unit id="0147b1a98a0ef41a4b049d6e7de36e860f8351d4" translate="yes" xml:space="preserve">
          <source>CREATE VIEW &amp;mdash; define a new view</source>
          <target state="translated">뷰 생성 &amp;mdash; 새로운 뷰 정의</target>
        </trans-unit>
        <trans-unit id="fa3416b89da9ef05cb9e9d2480e0fd805ea5f0a9" translate="yes" xml:space="preserve">
          <source>CRL</source>
          <target state="translated">CRL</target>
        </trans-unit>
        <trans-unit id="3281188351b89c8e2db28d6da7af4992d415de90" translate="yes" xml:space="preserve">
          <source>CSV</source>
          <target state="translated">CSV</target>
        </trans-unit>
        <trans-unit id="b3706da5e4cc32b0bedecec46b4ac426e2af6808" translate="yes" xml:space="preserve">
          <source>CSV Format</source>
          <target state="translated">CSV 형식</target>
        </trans-unit>
        <trans-unit id="e5cf7ef0f924f6d30fb5a33edb5b128eeaee7a5e" translate="yes" xml:space="preserve">
          <source>CSV format will both recognize and produce CSV files with quoted values containing embedded carriage returns and line feeds. Thus the files are not strictly one line per table row like text-format files.</source>
          <target state="translated">CSV 형식은 포함 된 캐리지 리턴 및 줄 바꿈이 포함 된 따옴표 값으로 CSV 파일을 인식하고 생성합니다. 따라서 파일은 텍스트 형식 파일과 같이 테이블 행당 한 줄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76892178b436ea8bdde6e161ad4d4ea9686b38bf" translate="yes" xml:space="preserve">
          <source>CTE</source>
          <target state="translated">CTE</target>
        </trans-unit>
        <trans-unit id="b3940909bbd68a59ba0277b02624768dfaeb6e9b" translate="yes" xml:space="preserve">
          <source>CVE</source>
          <target state="translated">CVE</target>
        </trans-unit>
        <trans-unit id="247813b3c844bd5d06cdcae1ecce2cdd4b970eef" translate="yes" xml:space="preserve">
          <source>Cache size of the sequence</source>
          <target state="translated">시퀀스의 캐시 크기</target>
        </trans-unit>
        <trans-unit id="0cb1c895a27cf7a692331abf7527a78ed40aff2a" translate="yes" xml:space="preserve">
          <source>Calculate the difference between two write-ahead log locations</source>
          <target state="translated">두 미리 쓰기 로그 위치의 차이 계산</target>
        </trans-unit>
        <trans-unit id="fea0627ce6667c0ebd9b97f7ca4a898c44a74581" translate="yes" xml:space="preserve">
          <source>Calculates a crypt(3)-style hash of &lt;em&gt;&lt;code&gt;password&lt;/code&gt;&lt;/em&gt;. When storing a new password, you need to use &lt;code&gt;gen_salt()&lt;/code&gt; to generate a new &lt;em&gt;&lt;code&gt;salt&lt;/code&gt;&lt;/em&gt; value. To check a password, pass the stored hash value as &lt;em&gt;&lt;code&gt;salt&lt;/code&gt;&lt;/em&gt;, and test whether the result matches the stored value.</source>
          <target state="translated">암호의 crypt (3) 스타일 해시를 계산 &lt;em&gt; &lt;code&gt;password&lt;/code&gt; &lt;/em&gt; . 새 비밀번호를 저장할 때 &lt;code&gt;gen_salt()&lt;/code&gt; 를 사용하여 새 &lt;em&gt; &lt;code&gt;salt&lt;/code&gt; &lt;/em&gt; 값 을 생성 해야 합니다. 비밀번호를 확인하려면 저장된 해시 값을 &lt;em&gt; &lt;code&gt;salt&lt;/code&gt; &lt;/em&gt; 로 전달 하고 결과가 저장된 값과 일치하는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="861e89fd9688c36464c88762b222ee32afefc886" translate="yes" xml:space="preserve">
          <source>Calculates hashed MAC for &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with key &lt;em&gt;&lt;code&gt;key&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; is the same as in &lt;code&gt;digest()&lt;/code&gt;.</source>
          <target state="translated">키 &lt;em&gt; &lt;code&gt;key&lt;/code&gt; &lt;/em&gt; 하여 &lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 에 대한 해시 MAC을 계산합니다 . &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;digest()&lt;/code&gt; 와 동일 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c31f29ac70693bcc792a1f5312cf3bb90f137b5" translate="yes" xml:space="preserve">
          <source>Calculates the MD5 hash of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;, returning the result in hexadecimal</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 MD5 해시를 계산하여 16 진수로 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="befefdcc641ba3007ad8e4f140dfc06f0376aadb" translate="yes" xml:space="preserve">
          <source>Call a function to log updates of &lt;code&gt;accounts&lt;/code&gt;, but only if something changed:</source>
          <target state="translated">&lt;code&gt;accounts&lt;/code&gt; 업데이트를 기록하는 기능을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="203462ce9b91673b52d9f4d2d91355f3aa6602db" translate="yes" xml:space="preserve">
          <source>Calling Functions: Mixed Notation</source>
          <target state="translated">함수 호출 : 혼합 표기법</target>
        </trans-unit>
        <trans-unit id="a536706c9ea5b680977b44c15311fa4951f2711a" translate="yes" xml:space="preserve">
          <source>Calling Functions: Named Notation</source>
          <target state="translated">함수 호출 : 명명 된 표기법</target>
        </trans-unit>
        <trans-unit id="fc4a9cc712a759cf51a3323495fcadd9bd96bc79" translate="yes" xml:space="preserve">
          <source>Calling Functions: Positional Notation</source>
          <target state="translated">함수 호출 : 위치 표기법</target>
        </trans-unit>
        <trans-unit id="da4ac9cae427158f02958852d4d2d5e7ffe27ccf" translate="yes" xml:space="preserve">
          <source>Can give wrong results when the server is running.</source>
          <target state="translated">서버가 실행 중일 때 잘못된 결과를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a93dec0f38c1b9cc3a9947f4ed876ed816928818" translate="yes" xml:space="preserve">
          <source>Can the column be scanned in order by a &amp;ldquo;distance&amp;rdquo; operator, for example &lt;code&gt;ORDER BY col &amp;lt;-&amp;gt; constant&lt;/code&gt; ?</source>
          <target state="translated">&quot;거리&quot;연산자 (예 : &lt;code&gt;ORDER BY col &amp;lt;-&amp;gt; constant&lt;/code&gt; ?)를 사용 하여 열을 순서대로 스캔 할 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="6539f7da14fafe21218e45f67919c4c481fed653" translate="yes" xml:space="preserve">
          <source>Can the column value be returned by an index-only scan?</source>
          <target state="translated">인덱스 전용 스캔으로 컬럼 값을 리턴 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0935874144556d7285be1025b3aa5607d7d0ddc3" translate="yes" xml:space="preserve">
          <source>Can the index be used in a &lt;code&gt;CLUSTER&lt;/code&gt; command?</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 명령 에서 색인을 사용할 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="b77f7d0943d5d161914d1daaa3ce278bcefc5f99" translate="yes" xml:space="preserve">
          <source>Can the scan direction be changed in mid-scan (to support &lt;code&gt;FETCH BACKWARD&lt;/code&gt; on a cursor without needing materialization)?</source>
          <target state="translated">스캔 중간에 스캔 방향을 변경할 수 있습니까 ( 구체화없이 커서에서 &lt;code&gt;FETCH BACKWARD&lt;/code&gt; 지원 )?</target>
        </trans-unit>
        <trans-unit id="9f0df21242294739bbb4a2952c632be02a94f355" translate="yes" xml:space="preserve">
          <source>Cancel a backend's current query. This is also allowed if the calling role is a member of the role whose backend is being canceled or the calling role has been granted &lt;code&gt;pg_signal_backend&lt;/code&gt;, however only superusers can cancel superuser backends.</source>
          <target state="translated">백엔드의 현재 쿼리를 취소하십시오. 호출 역할이 백엔드가 취소되거나 호출 역할에 &lt;code&gt;pg_signal_backend&lt;/code&gt; 가 부여 된 역할의 구성원 인 경우에도 허용 되지만 수퍼 유저 만 수퍼 유저 백엔드를 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9da0a3cad76feeeddc910a8b8ceb607b614bd1b" translate="yes" xml:space="preserve">
          <source>Cancel the effects of &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; 의 효과를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c1b1bf8357eb64e4252455c2cd4e94e21c1f28f" translate="yes" xml:space="preserve">
          <source>Cancel the effects of &lt;code&gt;pg_replication_origin_xact_setup()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_xact_setup()&lt;/code&gt; 의 효과를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="23032323429fac1ae297d0bcb8316e73f0646ac9" translate="yes" xml:space="preserve">
          <source>Canceled queries may be retried immediately (after beginning a new transaction, of course). Since query cancellation depends on the nature of the WAL records being replayed, a query that was canceled may well succeed if it is executed again.</source>
          <target state="translated">취소 된 쿼리는 즉시 재 시도 할 수 있습니다 (물론 새 트랜잭션을 시작한 후). 쿼리 취소는 재생중인 WAL 레코드의 특성에 따라 다르므로 취소 된 쿼리는 다시 실행하면 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693faa0292da8531e1fbe82d7b3027be66637ae6" translate="yes" xml:space="preserve">
          <source>Care must be taken when dealing with multiple character encodings on the client, server, and in the XML data passed through them. When using the text mode to pass queries to the server and query results to the client (which is the normal mode), PostgreSQL converts all character data passed between the client and the server and vice versa to the character encoding of the respective end; see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;. This includes string representations of XML values, such as in the above examples. This would ordinarily mean that encoding declarations contained in XML data can become invalid as the character data is converted to other encodings while traveling between client and server, because the embedded encoding declaration is not changed. To cope with this behavior, encoding declarations contained in character strings presented for input to the &lt;code&gt;xml&lt;/code&gt; type are &lt;em&gt;ignored&lt;/em&gt;, and content is assumed to be in the current server encoding. Consequently, for correct processing, character strings of XML data must be sent from the client in the current client encoding. It is the responsibility of the client to either convert documents to the current client encoding before sending them to the server, or to adjust the client encoding appropriately. On output, values of type &lt;code&gt;xml&lt;/code&gt; will not have an encoding declaration, and clients should assume all data is in the current client encoding.</source>
          <target state="translated">클라이언트, 서버 및이를 통해 전달되는 XML 데이터에서 여러 문자 인코딩을 처리 할 때는주의해야합니다. 텍스트 모드를 사용하여 쿼리를 서버에 전달하고 결과를 클라이언트에 쿼리하면 (일반 모드) PostgreSQL은 클라이언트와 서버간에 전달 된 모든 문자 데이터를 변환하고 그 반대도 각각의 끝 문자 인코딩으로 변환합니다. &lt;a href=&quot;multibyte&quot;&gt;섹션 23.3&lt;/a&gt; 참조. 여기에는 위의 예와 같이 XML 값의 문자열 표현이 포함됩니다. 이는 일반적으로 임베디드 인코딩 선언이 변경되지 않기 때문에 클라이언트와 서버간에 이동하는 동안 문자 데이터가 다른 인코딩으로 변환되므로 XML 데이터에 포함 된 인코딩 선언이 유효하지 않을 수 있음을 의미합니다. 이 동작에 대처하기 위해 &lt;code&gt;xml&lt;/code&gt; 유형으로 입력하기 위해 제공된 문자열에 포함 된 인코딩 선언 은 &lt;em&gt;무시됩니다.&lt;/em&gt;콘텐츠는 현재 서버 인코딩에 있다고 가정합니다. 따라서 올바른 처리를 위해 현재 클라이언트 인코딩으로 클라이언트에서 XML 데이터의 문자열을 보내야합니다. 문서를 서버로 보내기 전에 현재 클라이언트 인코딩으로 변환하거나 클라이언트 인코딩을 적절하게 조정하는 것은 클라이언트의 책임입니다. 출력시 &lt;code&gt;xml&lt;/code&gt; 유형의 값 에는 인코딩 선언이 없으며 클라이언트는 모든 데이터가 현재 클라이언트 인코딩에 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8b9c886cfee9a0088d73099139600c074f9b050" translate="yes" xml:space="preserve">
          <source>Care should be taken when granting these roles to ensure they are only used where needed and with the understanding that these roles grant access to privileged information.</source>
          <target state="translated">이러한 역할을 부여 할 때는 필요한 경우에만 사용하고 이러한 역할이 권한있는 정보에 대한 액세스 권한을 부여한다는 사실을 이해하도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="a731e5cd6aa8ed98146eab667e56ae88e3c5d7fc" translate="yes" xml:space="preserve">
          <source>Care was taken during the creation of the algorithms and they were meticulously verified against the suggested algorithms in the official ISBN, ISMN, ISSN User Manuals.</source>
          <target state="translated">알고리즘 생성 중에주의를 기울였으며 공식 ISBN, ISMN, ISSN 사용자 매뉴얼의 제안 된 알고리즘에 대해 세 심하게 검증되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c7f8a2bb8fffa23f523c6163b0903e536de65ba" translate="yes" xml:space="preserve">
          <source>Carriage return (ASCII 13)</source>
          <target state="translated">캐리지 리턴 (ASCII 13)</target>
        </trans-unit>
        <trans-unit id="2650e53427c41e8804613f092fb9a0fb7ace5eee" translate="yes" xml:space="preserve">
          <source>Carry out the command and show actual run times and other statistics. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">명령을 수행하고 실제 런타임 및 기타 통계를 표시하십시오. 이 매개 변수의 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bc75ee91fac0dcf8fbe5c9b1aeb7cbdb9f3add3" translate="yes" xml:space="preserve">
          <source>Cascading replication is currently asynchronous. Synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;) settings have no effect on cascading replication at present.</source>
          <target state="translated">계단식 복제는 현재 비동기입니다. 동기 복제 ( &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;26.2.8 절&lt;/a&gt; 참조 ) 설정은 현재 계단식 복제에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03ff4ebf1ea10982d29fb1e92aa1f028e700f862" translate="yes" xml:space="preserve">
          <source>Cast implementation functions can have one to three arguments. The first argument type must be identical to or binary-coercible from the cast's source type. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or &lt;code&gt;-1&lt;/code&gt; if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise. (Bizarrely, the SQL standard demands different behaviors for explicit and implicit casts in some cases. This argument is supplied for functions that must implement such casts. It is not recommended that you design your own data types so that this matters.)</source>
          <target state="translated">캐스트 구현 함수는 1-3 개의 인수를 가질 수 있습니다. 첫 번째 인수 유형은 캐스트의 소스 유형과 동일하거나 2 진 변환 가능해야합니다. 두 번째 인수는 &lt;code&gt;integer&lt;/code&gt; 이어야합니다 . 대상 유형과 관련된 유형 수정자를 받거나 없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 받습니다. 존재하는 경우 세 번째 인수는 &lt;code&gt;boolean&lt;/code&gt; 유형이어야합니다 . 그것은 수신 &lt;code&gt;true&lt;/code&gt; 캐스트가 명시 적 캐스트 인 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지. (바람직하게, SQL 표준은 경우에 따라 명시 적 및 암시 적 캐스트에 대해 다른 동작을 요구합니다.이 인수는 이러한 캐스트를 구현해야하는 함수에 제공됩니다.이 문제가 중요하도록 자체 데이터 유형을 디자인하지 않는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="8bfaf65bcc3bfd3f69874267680d575eefe7735d" translate="yes" xml:space="preserve">
          <source>Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left.</source>
          <target state="translated">정수를 &lt;code&gt;bit(n)&lt;/code&gt; 로 캐스팅하면 가장 오른쪽의 &lt;code&gt;n&lt;/code&gt; 비트가 복사 됩니다. 정수 자체보다 폭이 넓은 비트 열로 정수를 캐스트하면 왼쪽에서 부호 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8b12286d851a29dd1eb5cbb3a3c36eb2a6d20ae4" translate="yes" xml:space="preserve">
          <source>Catalog Name</source>
          <target state="translated">카탈로그 이름</target>
        </trans-unit>
        <trans-unit id="e39f1d43412f335d260f6d16604f35d75f9f19c8" translate="yes" xml:space="preserve">
          <source>Catalogs: System Views</source>
          <target state="translated">카탈로그 : 시스템 뷰</target>
        </trans-unit>
        <trans-unit id="cd0231f25ccdf0d0faf414b312a62b082eeb5b93" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_aggregate</source>
          <target state="translated">카탈로그 : pg_aggregate</target>
        </trans-unit>
        <trans-unit id="5a2cc7f7d79e3465c6cb75edcddc6849aa0cbe29" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_am</source>
          <target state="translated">카탈로그 : pg_am</target>
        </trans-unit>
        <trans-unit id="6f5861da97f8e27d0265b79b0e8f0602d04e3c6c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_amop</source>
          <target state="translated">카탈로그 : pg_amop</target>
        </trans-unit>
        <trans-unit id="540f25e5c7bfa6e5939b7ffa20ee2292a88850ba" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_amproc</source>
          <target state="translated">카탈로그 : pg_amproc</target>
        </trans-unit>
        <trans-unit id="a5d37bbcf80d99313d0fcf92265cf0378e3ebfda" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_attrdef</source>
          <target state="translated">카탈로그 : pg_attrdef</target>
        </trans-unit>
        <trans-unit id="809d8237b28a35759881f596677f3687a9caa14e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_attribute</source>
          <target state="translated">카탈로그 : pg_attribute</target>
        </trans-unit>
        <trans-unit id="d22f444a2f1dced1268fc5a74cc510d5853b50fb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_auth_members</source>
          <target state="translated">카탈로그 : pg_auth_members</target>
        </trans-unit>
        <trans-unit id="9e2777250a55ada681979e409c1e9f68b5f4a8e0" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_authid</source>
          <target state="translated">카탈로그 : pg_authid</target>
        </trans-unit>
        <trans-unit id="098b7f0ec7e32aaf4413dc833248e8ba2ba61dbb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_available_extension_versions</source>
          <target state="translated">카탈로그 : pg_available_extension_versions</target>
        </trans-unit>
        <trans-unit id="21541dc8fd93a658bf7fda69daeb0fc8bc3ac5fb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_available_extensions</source>
          <target state="translated">카탈로그 : pg_available_extensions</target>
        </trans-unit>
        <trans-unit id="3a492ed5f8fa73610c5f384ee71ac2af2d343280" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_cast</source>
          <target state="translated">카탈로그 : pg_cast</target>
        </trans-unit>
        <trans-unit id="214b25acc823e53a3866fac8ad4bdb58a5849695" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_class</source>
          <target state="translated">카탈로그 : pg_class</target>
        </trans-unit>
        <trans-unit id="1f95915ba59d80f58e01f2b5de8cc456bcc65284" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_collation</source>
          <target state="translated">카탈로그 : pg_collation</target>
        </trans-unit>
        <trans-unit id="45a417e5bb393b7aea80ba15614c9e574b1ec967" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_config</source>
          <target state="translated">카탈로그 : pg_config</target>
        </trans-unit>
        <trans-unit id="ef3a1d16c7beaa5ff7cde438e280c6004fc99358" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_constraint</source>
          <target state="translated">카탈로그 : pg_constraint</target>
        </trans-unit>
        <trans-unit id="e1533025c2199a2c17644351fc8d500bab2cd3bb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_conversion</source>
          <target state="translated">카탈로그 : pg_conversion</target>
        </trans-unit>
        <trans-unit id="6ee477ff028fe4897030c498b3792c6fb4efa684" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_cursors</source>
          <target state="translated">카탈로그 : pg_cursors</target>
        </trans-unit>
        <trans-unit id="53aaa0259c4a9a04e8eb75ff7858ac223e5bb9ef" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_database</source>
          <target state="translated">카탈로그 : pg_database</target>
        </trans-unit>
        <trans-unit id="dce93e6bd535d6849381dd52df6a2fe69c966a15" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_db_role_setting</source>
          <target state="translated">카탈로그 : pg_db_role_setting</target>
        </trans-unit>
        <trans-unit id="393ce7080c621e5669cea8ce22e81a4d14bce3bd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_default_acl</source>
          <target state="translated">카탈로그 : pg_default_acl</target>
        </trans-unit>
        <trans-unit id="63be8b4fe3bd96d14c425f3779c77c1bde3c7f70" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_depend</source>
          <target state="translated">카탈로그 : pg_depend</target>
        </trans-unit>
        <trans-unit id="6c7b51ab42295189697291ccc89d633240d22b4a" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_description</source>
          <target state="translated">카탈로그 : pg_description</target>
        </trans-unit>
        <trans-unit id="e81e9f736a55c37e62171851380f6909958bd1a4" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_enum</source>
          <target state="translated">카탈로그 : pg_enum</target>
        </trans-unit>
        <trans-unit id="d16a46d2e57c59ea3c662f29c4e0c310d1fac618" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_event_trigger</source>
          <target state="translated">카탈로그 : pg_event_trigger</target>
        </trans-unit>
        <trans-unit id="e2f3d74a77699443187baa8f4450089845b9cb76" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_extension</source>
          <target state="translated">카탈로그 : pg_extension</target>
        </trans-unit>
        <trans-unit id="631f07d60ad79d31d4aece900c3f41f0d9385f5e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_file_settings</source>
          <target state="translated">카탈로그 : pg_file_settings</target>
        </trans-unit>
        <trans-unit id="10bd0a6fc97d6b9d339d72472d3626185232809c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_data_wrapper</source>
          <target state="translated">카탈로그 : pg_foreign_data_wrapper</target>
        </trans-unit>
        <trans-unit id="99a0f269b04cd636dbe4eedcdc1a264689616ce6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_server</source>
          <target state="translated">카탈로그 : pg_foreign_server</target>
        </trans-unit>
        <trans-unit id="e03ca9b9ed8c896e7abecbf15858efd786ccc932" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_table</source>
          <target state="translated">카탈로그 : pg_foreign_table</target>
        </trans-unit>
        <trans-unit id="b8a522cb4849f86cc0ebd1d8e4533b981fe760e8" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_group</source>
          <target state="translated">카탈로그 : pg_group</target>
        </trans-unit>
        <trans-unit id="809afcd307ea7a846272cfe2055518e09a097e34" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_hba_file_rules</source>
          <target state="translated">카탈로그 : pg_hba_file_rules</target>
        </trans-unit>
        <trans-unit id="3ede65ae6ffe5b427435f5d68e81b9255349537a" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_index</source>
          <target state="translated">카탈로그 : pg_index</target>
        </trans-unit>
        <trans-unit id="062ebb2a310599c5c55a326d43df0384367543ce" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_indexes</source>
          <target state="translated">카탈로그 : pg_indexes</target>
        </trans-unit>
        <trans-unit id="896e4e7fa3850b76e1727ff9ae9c7894fdeb4535" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_inherits</source>
          <target state="translated">카탈로그 : pg_inherits</target>
        </trans-unit>
        <trans-unit id="a99a7230356dc633d7735302eb1f597def0d6246" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_init_privs</source>
          <target state="translated">카탈로그 : pg_init_privs</target>
        </trans-unit>
        <trans-unit id="2bc5ebd2eb94cb79767b534211814328af877d03" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_language</source>
          <target state="translated">카탈로그 : pg_language</target>
        </trans-unit>
        <trans-unit id="7475eeb141889567a43afdcbdbc39b5953c158e5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_largeobject</source>
          <target state="translated">카탈로그 : pg_largeobject</target>
        </trans-unit>
        <trans-unit id="13d246ab8635647844676127fcad44b7d85bdb7b" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_largeobject_metadata</source>
          <target state="translated">카탈로그 : pg_largeobject_metadata</target>
        </trans-unit>
        <trans-unit id="47d201ca5d48022eebb7f49698984eedf590519d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_locks</source>
          <target state="translated">카탈로그 : pg_locks</target>
        </trans-unit>
        <trans-unit id="44021f8a25348e256fc0757db930fb338b754fb7" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_matviews</source>
          <target state="translated">카탈로그 : pg_matviews</target>
        </trans-unit>
        <trans-unit id="22707cfbd7b73718bdf695d657834844b0f409b9" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_namespace</source>
          <target state="translated">카탈로그 : pg_namespace</target>
        </trans-unit>
        <trans-unit id="deb4d3669218dad9cb34ea405ff1eae78e8631dd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_opclass</source>
          <target state="translated">카탈로그 : pg_opclass</target>
        </trans-unit>
        <trans-unit id="7d7c2c3b54c2b67c28cb4558ef76babf65acfde2" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_operator</source>
          <target state="translated">카탈로그 : pg_operator</target>
        </trans-unit>
        <trans-unit id="8a758121c56b38114d101d017db33b71016f1bc2" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_opfamily</source>
          <target state="translated">카탈로그 : pg_opfamily</target>
        </trans-unit>
        <trans-unit id="9d5ccf8bfb6af0c7726d42696afbdd455a68550d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_partitioned_table</source>
          <target state="translated">카탈로그 : pg_partitioned_table</target>
        </trans-unit>
        <trans-unit id="167642e6d760a30fbfd27cf56e9be558f2930209" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_pltemplate</source>
          <target state="translated">카탈로그 : pg_pltemplate</target>
        </trans-unit>
        <trans-unit id="4dec76c5312c96a5b30ebba9a03ef220af8d85cd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_policies</source>
          <target state="translated">카탈로그 : pg_policies</target>
        </trans-unit>
        <trans-unit id="6b912e5e80b5e7c6f7e379f86297d335cb90fb66" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_policy</source>
          <target state="translated">카탈로그 : pg_policy</target>
        </trans-unit>
        <trans-unit id="37bfb758865bf592e8327a655b253ebe26b3a27c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_prepared_statements</source>
          <target state="translated">카탈로그 : pg_prepared_statements</target>
        </trans-unit>
        <trans-unit id="e0f65f36699b59cc051c4443b8c7f9448bdb976f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_prepared_xacts</source>
          <target state="translated">카탈로그 : pg_prepared_xacts</target>
        </trans-unit>
        <trans-unit id="df03f30fae73bd4555cb205dc3f229899b26e406" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_proc</source>
          <target state="translated">카탈로그 : pg_proc</target>
        </trans-unit>
        <trans-unit id="08d769cfc75bc7a5291b9cc51d62e27993c176cb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication</source>
          <target state="translated">카탈로그 : pg_publication</target>
        </trans-unit>
        <trans-unit id="663db137e4eb335b4daa441fea43166f26c3e69d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication_rel</source>
          <target state="translated">카탈로그 : pg_publication_rel</target>
        </trans-unit>
        <trans-unit id="21b9962277bcef09369bc7e2e1ad2e90cc32d817" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication_tables</source>
          <target state="translated">카탈로그 : pg_publication_tables</target>
        </trans-unit>
        <trans-unit id="2134507ad10f2206eea8739a1872a03fa790735e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_range</source>
          <target state="translated">카탈로그 : pg_range</target>
        </trans-unit>
        <trans-unit id="13a5aaf5f820d003b94c89c2cb007a9a48d202ef" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_origin</source>
          <target state="translated">카탈로그 : pg_replication_origin</target>
        </trans-unit>
        <trans-unit id="d7da07d9eaadc1b0c362176aac0724e6f8e5a48c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_origin_status</source>
          <target state="translated">카탈로그 : pg_replication_origin_status</target>
        </trans-unit>
        <trans-unit id="e8c4e3caea19df2483c4ab01f26aa94ffa837bb1" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_slots</source>
          <target state="translated">카탈로그 : pg_replication_slots</target>
        </trans-unit>
        <trans-unit id="0821b6a25a55bf7424742dbc12dc0e5ba3d591b6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_rewrite</source>
          <target state="translated">카탈로그 : pg_rewrite</target>
        </trans-unit>
        <trans-unit id="6c3b335fca2a54e90ad821652548aa0d9bb5690e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_roles</source>
          <target state="translated">카탈로그 : pg_roles</target>
        </trans-unit>
        <trans-unit id="0de354bd3294eb64fef4c4abce85b3d2d3beb830" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_rules</source>
          <target state="translated">카탈로그 : pg_rules</target>
        </trans-unit>
        <trans-unit id="0ebe4b3acf940a10a081afebef169c56d586e493" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_seclabel</source>
          <target state="translated">카탈로그 : pg_seclabel</target>
        </trans-unit>
        <trans-unit id="9814c0f5828be7c7093a5709f52e474199783220" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_seclabels</source>
          <target state="translated">카탈로그 : pg_seclabels</target>
        </trans-unit>
        <trans-unit id="daa7b2d6a686574b8a24af09f4e1b47e4eff4aa1" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_sequence</source>
          <target state="translated">카탈로그 : pg_sequence</target>
        </trans-unit>
        <trans-unit id="ce18fa6a531efc4888fbef423b3467af39c898d4" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_sequences</source>
          <target state="translated">카탈로그 : pg_sequences</target>
        </trans-unit>
        <trans-unit id="45c1c4bedc4d1a7d8867b8130599c07d2c1d577c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_settings</source>
          <target state="translated">카탈로그 : pg_settings</target>
        </trans-unit>
        <trans-unit id="3eb114fca9ffe1b0450b4530729652dcc6f0b9e6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shadow</source>
          <target state="translated">카탈로그 : pg_shadow</target>
        </trans-unit>
        <trans-unit id="f2894dea53b78d43d5b3f3281c5f27fc5f3f001b" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shdepend</source>
          <target state="translated">카탈로그 : pg_shdepend</target>
        </trans-unit>
        <trans-unit id="90da2a4e4580d6be1fc41ef0a6804e131b5d13bf" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shdescription</source>
          <target state="translated">카탈로그 : pg_shdescription</target>
        </trans-unit>
        <trans-unit id="be567ea9a42b5f126c21736241eb2ef91bbd2f79" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shseclabel</source>
          <target state="translated">카탈로그 : pg_shseclabel</target>
        </trans-unit>
        <trans-unit id="e90a15834d30c2cd762287e4d2a23a44e610c928" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic</source>
          <target state="translated">카탈로그 : pg_statistic</target>
        </trans-unit>
        <trans-unit id="fc17f5bd5df84e4c69e2cf93c15b0c0ec6bdf02c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic_ext</source>
          <target state="translated">카탈로그 : pg_statistic_ext</target>
        </trans-unit>
        <trans-unit id="edacc8fe30e9d6b9a1b1540584abcf7a77d8d1ab" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic_ext_data</source>
          <target state="translated">카탈로그 : pg_statistic_ext_data</target>
        </trans-unit>
        <trans-unit id="4fe3e6c409cd897cbd40edf5647789819cd97c3f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_stats</source>
          <target state="translated">카탈로그 : pg_stats</target>
        </trans-unit>
        <trans-unit id="97198984637b4f8081d351a59e07f627d82013d5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_stats_ext</source>
          <target state="translated">카탈로그 : pg_stats_ext</target>
        </trans-unit>
        <trans-unit id="d751befc44bc4db36e1763767ab10200eee30415" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_subscription</source>
          <target state="translated">카탈로그 : pg_subscription</target>
        </trans-unit>
        <trans-unit id="f690e18690d08756f75b3315f92011ff3ef9c963" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_subscription_rel</source>
          <target state="translated">카탈로그 : pg_subscription_rel</target>
        </trans-unit>
        <trans-unit id="15150d5768ee1b796c4e6bd2ac3c26eae2b6a8e9" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_tables</source>
          <target state="translated">카탈로그 : pg_tables</target>
        </trans-unit>
        <trans-unit id="454570cb6d83f09006014194368c60f79eb88220" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_tablespace</source>
          <target state="translated">카탈로그 : pg_tablespace</target>
        </trans-unit>
        <trans-unit id="b02dd37583faac8a36cec78042caa70a6e32ba24" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_timezone_abbrevs</source>
          <target state="translated">카탈로그 : pg_timezone_abbrevs</target>
        </trans-unit>
        <trans-unit id="51beadbc15fdfa8bc0949181b01459e3cd7f72dd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_timezone_names</source>
          <target state="translated">카탈로그 : pg_timezone_names</target>
        </trans-unit>
        <trans-unit id="c7bfdd455c3f4e8454a7846aa451fdea37a96ef5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_transform</source>
          <target state="translated">카탈로그 : pg_transform</target>
        </trans-unit>
        <trans-unit id="202390ad7b0c62ae7dce434843121dfbfde375e8" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_trigger</source>
          <target state="translated">카탈로그 : pg_trigger</target>
        </trans-unit>
        <trans-unit id="ea8a9b3d765f8be3769406083e40a166da6faf3e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_config</source>
          <target state="translated">카탈로그 : pg_ts_config</target>
        </trans-unit>
        <trans-unit id="2a1c376cf13aefc2c1504e915090505e5783d753" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_config_map</source>
          <target state="translated">카탈로그 : pg_ts_config_map</target>
        </trans-unit>
        <trans-unit id="5a3e74be33f49e3b3a1f60a75adce9f08d6c06db" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_dict</source>
          <target state="translated">카탈로그 : pg_ts_dict</target>
        </trans-unit>
        <trans-unit id="40ce6ddbc53610b063cf04785a5c8be5f7f49c6f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_parser</source>
          <target state="translated">카탈로그 : pg_ts_parser</target>
        </trans-unit>
        <trans-unit id="a326494cd8521b1cd4e545e3b34b26162b8e9726" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_template</source>
          <target state="translated">카탈로그 : pg_ts_template</target>
        </trans-unit>
        <trans-unit id="513906697155f5f42dd3f499de7692b61d383217" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_type</source>
          <target state="translated">카탈로그 : pg_type</target>
        </trans-unit>
        <trans-unit id="945e0fd46fca84cb2189e5f64036b8473468d6b7" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user</source>
          <target state="translated">카탈로그 : pg_user</target>
        </trans-unit>
        <trans-unit id="32120ec9651c7b46e5686537528ac1d2b0e2c12e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user_mapping</source>
          <target state="translated">카탈로그 : pg_user_mapping</target>
        </trans-unit>
        <trans-unit id="09c47b0dd3afb85fbf04db7e76b88c08e663ef5c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user_mappings</source>
          <target state="translated">카탈로그 : pg_user_mappings</target>
        </trans-unit>
        <trans-unit id="61e4c2d909721eba5ae80f09a9313a27e24a17ba" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_views</source>
          <target state="translated">카탈로그 : pg_views</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="c591c7836d1018a266bff5665cfa4ab9192173b9" translate="yes" xml:space="preserve">
          <source>Cause server processes to reload their configuration files</source>
          <target state="translated">서버 프로세스가 구성 파일을 다시로드하게합니다.</target>
        </trans-unit>
        <trans-unit id="061004f7a3a0616256a6ed3e84699707a6ff3354" translate="yes" xml:space="preserve">
          <source>Causes checkpoints and restartpoints to be logged in the server log. Some statistics are included in the log messages, including the number of buffers written and the time spent writing them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is off.</source>
          <target state="translated">검사 점 및 다시 시작점이 서버 로그에 기록되도록합니다. 쓴 버퍼 수와 쓴 시간을 포함하여 일부 통계가 로그 메시지에 포함됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본 설정은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04251bc5f3a68b6174a8e3288ca8639f32a8564" translate="yes" xml:space="preserve">
          <source>Causes each action executed by autovacuum to be logged if it ran for at least the specified amount of time. Setting this to zero logs all autovacuum actions. &lt;code&gt;-1&lt;/code&gt; (the default) disables logging autovacuum actions. If this value is specified without units, it is taken as milliseconds. For example, if you set this to &lt;code&gt;250ms&lt;/code&gt; then all automatic vacuums and analyzes that run 250ms or longer will be logged. In addition, when this parameter is set to any value other than &lt;code&gt;-1&lt;/code&gt;, a message will be logged if an autovacuum action is skipped due to a conflicting lock or a concurrently dropped relation. Enabling this parameter can be helpful in tracking autovacuum activity. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">autovacuum이 실행 한 각 조치가 지정된 시간 동안 실행 된 경우 로그됩니다. 이 값을 0으로 설정하면 모든 자동 진공 작업이 기록됩니다. &lt;code&gt;-1&lt;/code&gt; (기본값)은 자동 진공 작업 로깅을 비활성화합니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 예를 &lt;code&gt;250ms&lt;/code&gt; 값을 250ms 로 설정하면 250ms 이상 실행되는 모든 자동 진공 및 분석이 기록됩니다. 또한이 매개 변수가 &lt;code&gt;-1&lt;/code&gt; 이외의 값으로 설정 되면 잠금 충돌 또는 동시에 삭제 된 관계로 인해 자동 진공 조치를 건너 뛰면 메시지가 기록됩니다. 이 매개 변수를 사용하면 autovacuum 활동을 추적하는 데 도움이 될 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서만 설정할 수 있습니다파일 또는 서버 명령 행; 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1332903808bf92372d34eb563558f4978f18300e" translate="yes" xml:space="preserve">
          <source>Causes each attempted connection to the server to be logged, as well as successful completion of client authentication. Only superusers can change this parameter at session start, and it cannot be changed at all within a session. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">클라이언트 인증이 성공적으로 완료되었을뿐만 아니라 서버에 대한 각 연결 시도가 기록됩니다. 세션 시작시 수퍼 유저 만이 매개 변수를 변경할 수 있으며 세션 내에서 전혀 변경할 수 없습니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6323a01865d7f71338d51ad0db02e3accd4a99f" translate="yes" xml:space="preserve">
          <source>Causes each replication command to be logged in the server log. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for more information about replication command. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">각 복제 명령이 서버 로그에 기록되도록합니다. 복제 명령에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;52.4 절을&lt;/a&gt; 참조하십시오 . 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53cbe9c2a49f4096f57a6845a69c106f9e0a362" translate="yes" xml:space="preserve">
          <source>Causes script execution to sleep for the specified duration in microseconds (&lt;code&gt;us&lt;/code&gt;), milliseconds (&lt;code&gt;ms&lt;/code&gt;) or seconds (&lt;code&gt;s&lt;/code&gt;). If the unit is omitted then seconds are the default. &lt;code&gt;number&lt;/code&gt; can be either an integer constant or a &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt; reference to a variable having an integer value.</source>
          <target state="translated">지정된 시간 동안 마이크로 초 ( &lt;code&gt;us&lt;/code&gt; ), 밀리 초 ( &lt;code&gt;ms&lt;/code&gt; ) 또는 초 ( &lt;code&gt;s&lt;/code&gt; ) 단위로 스크립트 실행을 휴면 상태로 만듭니다. 단위를 생략하면 초가 기본값입니다. &lt;code&gt;number&lt;/code&gt; 는 정수 상수이거나 정수 값을 갖는 &lt;code&gt;variablename&lt;/code&gt; 대한 &lt;code&gt;:&lt;/code&gt; variablename 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4981e08aa03f98c21078b6ad0c5efcd341beaa55" translate="yes" xml:space="preserve">
          <source>Causes session terminations to be logged. The log output provides information similar to &lt;code&gt;log_connections&lt;/code&gt;, plus the duration of the session. Only superusers can change this parameter at session start, and it cannot be changed at all within a session. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">세션 종료가 기록됩니다. 로그 출력은 &lt;code&gt;log_connections&lt;/code&gt; 와 유사한 정보와 세션 기간을 제공합니다. 세션 시작시 수퍼 유저 만이 매개 변수를 변경할 수 있으며 세션 내에서 전혀 변경할 수 없습니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82f98319f3b2884c120297a0e6b899a808e993b2" translate="yes" xml:space="preserve">
          <source>Causes the cursor to return data in binary rather than in text format.</source>
          <target state="translated">커서가 텍스트 형식이 아닌 2 진으로 데이터를 리턴하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4b3649b306b086669f8c20b1f53cb6aced3b309c" translate="yes" xml:space="preserve">
          <source>Causes the duration of each completed statement to be logged if the statement ran for at least the specified amount of time. If this value is specified without units, it is taken as milliseconds. Setting this to zero prints all statement durations. Minus-one (the default) disables logging statement durations. For example, if you set it to &lt;code&gt;250ms&lt;/code&gt; then all SQL statements that run 250ms or longer will be logged. Enabling this parameter can be helpful in tracking down unoptimized queries in your applications. Only superusers can change this setting.</source>
          <target state="translated">명령문이 최소한 지정된 시간 동안 실행 된 경우 완료된 각 명령문의 지속 기간이 기록됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 이것을 0으로 설정하면 모든 명령문 지속 시간이 인쇄됩니다. 빼기 (기본값)는 로깅 문 기간을 비활성화합니다. 예를 들어, &lt;code&gt;250ms&lt;/code&gt; 로 설정하면 250ms 이상을 실행하는 모든 SQL 문이 기록됩니다. 이 매개 변수를 사용하면 애플리케이션에서 최적화되지 않은 쿼리를 추적하는 데 도움이 될 수 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfe7cedef9226455a66044ed2753f9a02d24e7ac" translate="yes" xml:space="preserve">
          <source>Causes the duration of every completed statement to be logged. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">완료된 모든 명령문의 지속 기간이 기록됩니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99e5772acf594c054ad0eebaeed915afc1f71c58" translate="yes" xml:space="preserve">
          <source>Causes the named index to become attached to the altered index. The named index must be on a partition of the table containing the index being altered, and have an equivalent definition. An attached index cannot be dropped by itself, and will automatically be dropped if its parent index is dropped.</source>
          <target state="translated">명명 된 인덱스가 변경된 인덱스에 첨부되도록합니다. 명명 된 인덱스는 변경되는 인덱스를 포함하는 테이블의 파티션에 있어야하며 동등한 정의를 가져야합니다. 첨부 된 색인은 단독으로 삭제 될 수 없으며 상위 색인이 삭제되면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="156e1dbe32702076721ff55ef0bffd691a236c11" translate="yes" xml:space="preserve">
          <source>Causes the system to check for duplicate values in the table when the index is created (if data already exist) and each time data is added. Attempts to insert or update data which would result in duplicate entries will generate an error.</source>
          <target state="translated">인덱스가 작성되고 (데이터가 이미 존재하는 경우) 데이터가 추가 될 때마다 시스템이 테이블에서 중복 값을 확인하도록합니다. 중복 항목을 초래하는 데이터를 삽입하거나 업데이트하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="a8acba579ef8e3069745d6a9aad2a038c0a8478f" translate="yes" xml:space="preserve">
          <source>Caution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log. &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; contains a command &lt;code&gt;\password&lt;/code&gt; that can be used to change a role's password without exposing the cleartext password.</source>
          <target state="translated">이 명령으로 암호화되지 않은 비밀번호를 지정할 때는주의해야합니다. 암호는 일반 텍스트로 서버에 전송되며 클라이언트의 명령 기록 또는 서버 로그에 기록 될 수도 있습니다. &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 에는 일반 텍스트 비밀번호를 노출시키지 않고 역할 비밀번호를 변경하는 데 사용할 수있는 &lt;code&gt;\password&lt;/code&gt; 명령이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13141094aaaae772e2304157d403fed4d04987dd" translate="yes" xml:space="preserve">
          <source>Caution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log. The command &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;, however, transmits the password encrypted. Also, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; contains a command &lt;code&gt;\password&lt;/code&gt; that can be used to safely change the password later.</source>
          <target state="translated">이 명령으로 암호화되지 않은 비밀번호를 지정할 때는주의해야합니다. 암호는 일반 텍스트로 서버에 전송되며 클라이언트의 명령 기록 또는 서버 로그에 기록 될 수도 있습니다. 그러나 &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; 명령 은 암호화 된 비밀번호를 전송합니다. 또한 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 에는 나중에 암호를 안전하게 변경하는 데 사용할 수있는 &lt;code&gt;\password&lt;/code&gt; 명령이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59c4087d8a5f9b4650eb454d2d22ed280de76447" translate="yes" xml:space="preserve">
          <source>Cautious users will want to test their client applications on the new version before switching over fully; therefore, it's often a good idea to set up concurrent installations of old and new versions. When testing a PostgreSQL major upgrade, consider the following categories of possible changes:</source>
          <target state="translated">신중한 사용자는 완전히 전환하기 전에 새 버전에서 클라이언트 응용 프로그램을 테스트하려고합니다. 따라서 이전 버전과 새 버전의 동시 설치를 설정하는 것이 좋습니다. PostgreSQL 주요 업그레이드를 테스트 할 때 다음 범주의 가능한 변경 사항을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="8318a7f7457f1a010a3cbc12c805c3073d851311" translate="yes" xml:space="preserve">
          <source>Celtic</source>
          <target state="translated">Celtic</target>
        </trans-unit>
        <trans-unit id="a2391118c8141b7f016207cb0da015ce9b3323e4" translate="yes" xml:space="preserve">
          <source>Center</source>
          <target state="translated">Center</target>
        </trans-unit>
        <trans-unit id="cd23172153f82db844b961331e1dcdc9f04798a5" translate="yes" xml:space="preserve">
          <source>Central European</source>
          <target state="translated">중앙 유럽</target>
        </trans-unit>
        <trans-unit id="9f43d8cddc33c7a1b859cf192071f47cb602514c" translate="yes" xml:space="preserve">
          <source>Certain modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FM99.99&lt;/code&gt; is the &lt;code&gt;99.99&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-NUMERICMOD-TABLE&quot;&gt;Table 9.28&lt;/a&gt; shows the modifier patterns for numeric formatting.</source>
          <target state="translated">특정 수정자를 모든 템플릿 패턴에 적용하여 동작을 변경할 수 있습니다. 예를 들어 &lt;code&gt;FM99.99&lt;/code&gt; 는 &lt;code&gt;FM&lt;/code&gt; 수정자를 사용하는 &lt;code&gt;99.99&lt;/code&gt; 패턴입니다 . &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-NUMERICMOD-TABLE&quot;&gt;표 9.28&lt;/a&gt; 은 숫자 형식에 대한 수정 자 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c951a4db63ebb3cd3179e2b26dd954d081d53c72" translate="yes" xml:space="preserve">
          <source>Certain utility commands, for instance &lt;code&gt;DROP TABLE&lt;/code&gt;, are forced to commit synchronously regardless of the setting of &lt;code&gt;synchronous_commit&lt;/code&gt;. This is to ensure consistency between the server's file system and the logical state of the database. The commands supporting two-phase commit, such as &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, are also always synchronous.</source>
          <target state="translated">&lt;code&gt;DROP TABLE&lt;/code&gt; 과 같은 특정 유틸리티 명령 은 &lt;code&gt;synchronous_commit&lt;/code&gt; 설정에 관계없이 동기식으로 커밋해야 합니다 . 이는 서버의 파일 시스템과 데이터베이스의 논리적 상태 간의 일관성을 유지하기위한 것입니다. &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 과 같은 2 단계 커밋을 지원하는 명령 도 항상 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d8565af86e7dd8fcc32e67bc814d1bb213d6be60" translate="yes" xml:space="preserve">
          <source>Certain variables are special, in that they control psql's behavior or are automatically set to reflect connection state. These variables are documented in &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">특정 변수는 psql의 동작을 제어하거나 연결 상태를 반영하도록 자동 설정된다는 점에서 특별합니다. 이러한 변수는에 설명되어 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수&lt;/a&gt; 아래.</target>
        </trans-unit>
        <trans-unit id="4cbd7bb4dc50373cab7f998cf0e909ee69411d53" translate="yes" xml:space="preserve">
          <source>Certificate Authentication</source>
          <target state="translated">인증서 인증</target>
        </trans-unit>
        <trans-unit id="d4e234a1ca3005d6b26035fb79c1b9f721db2dfa" translate="yes" xml:space="preserve">
          <source>Certificate Authority</source>
          <target state="translated">인증 기관</target>
        </trans-unit>
        <trans-unit id="c8a485438966853fda29f434c35133cbf732f0fe" translate="yes" xml:space="preserve">
          <source>Certificate Revocation List</source>
          <target state="translated">인증서 해지 목록</target>
        </trans-unit>
        <trans-unit id="17bf1f083821e0e50336e0f90f08e0b36b367e24" translate="yes" xml:space="preserve">
          <source>Change a foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt;, add option &lt;code&gt;foo&lt;/code&gt;, drop &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">외부 데이터 래퍼 &lt;code&gt;dbi&lt;/code&gt; 를 변경하고 옵션 &lt;code&gt;foo&lt;/code&gt; 추가 하고 드롭 &lt;code&gt;bar&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="32a2f5eaac3588dc682626e21196a5c2b59c5a20" translate="yes" xml:space="preserve">
          <source>Change a password expiration date, specifying that the password should expire at midday on 4th May 2015 using the time zone which is one hour ahead of UTC:</source>
          <target state="translated">2015 년 5 월 4 일 정오에 UTC보다 1 시간 빠른 시간대를 사용하여 비밀번호가 만료되도록 지정하여 비밀번호 만료 날짜를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="89136451caa26ba2ef49b9ddac14e69df14f397c" translate="yes" xml:space="preserve">
          <source>Change a role's password:</source>
          <target state="translated">역할 비밀번호 변경 :</target>
        </trans-unit>
        <trans-unit id="76a6da74954b28b8f70437a300c038dec6941d29" translate="yes" xml:space="preserve">
          <source>Change column data types</source>
          <target state="translated">열 데이터 형식 변경</target>
        </trans-unit>
        <trans-unit id="c93fcec47f72e06d06fbac297527cbd438f906f0" translate="yes" xml:space="preserve">
          <source>Change default values</source>
          <target state="translated">기본값 변경</target>
        </trans-unit>
        <trans-unit id="5b362073437f207683f5461f1b1b443c7b3b8ab4" translate="yes" xml:space="preserve">
          <source>Change options for the foreign table or one of its columns. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name). Option names and values are also validated using the foreign data wrapper library.</source>
          <target state="translated">외부 테이블 또는 해당 컬럼 중 하나에 대한 옵션을 변경하십시오. &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 및 &lt;code&gt;DROP&lt;/code&gt; 은 수행 할 조치를 지정합니다. 명시 적으로 지정된 작업이 없으면 &lt;code&gt;ADD&lt;/code&gt; 가 가정됩니다. 중복 옵션 이름은 허용되지 않습니다 (테이블 옵션과 열 옵션이 동일한 이름을 갖는 것은 괜찮지 만). 외부 데이터 랩퍼 라이브러리를 사용하여 옵션 이름 및 값도 유효성 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="55f114791e1954dfff79bd76576f13f1d557469a" translate="yes" xml:space="preserve">
          <source>Change options for the foreign-data wrapper. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; names and values are also validated using the foreign data wrapper's validator function, if any.</source>
          <target state="translated">외부 데이터 랩퍼의 옵션을 변경하십시오. &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 및 &lt;code&gt;DROP&lt;/code&gt; 은 수행 할 조치를 지정합니다. 명시 적으로 지정된 작업이 없으면 &lt;code&gt;ADD&lt;/code&gt; 가 가정됩니다. 옵션 이름은 고유해야합니다. 외부 데이터 랩퍼의 유효성 검증기 함수 (있는 경우)를 사용하여 이름과 값의 유효성도 검증합니다.</target>
        </trans-unit>
        <trans-unit id="b54efbe9196a20405fd2c83c8c58b2bd79277d4a" translate="yes" xml:space="preserve">
          <source>Change options for the server. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; names and values are also validated using the server's foreign-data wrapper library.</source>
          <target state="translated">서버의 옵션을 변경하십시오. &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 및 &lt;code&gt;DROP&lt;/code&gt; 은 수행 할 조치를 지정합니다. 명시 적으로 지정된 작업이 없으면 &lt;code&gt;ADD&lt;/code&gt; 가 가정됩니다. 옵션 이름은 고유해야합니다. 이름과 값은 서버의 외부 데이터 래퍼 라이브러리를 사용하여 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="6e9f24bb6b0408186a6ae9d3d4bfa8aed5349997" translate="yes" xml:space="preserve">
          <source>Change options for the user mapping. The new options override any previously specified options. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; options are also validated by the server's foreign-data wrapper.</source>
          <target state="translated">사용자 매핑 옵션을 변경하십시오. 새로운 옵션은 이전에 지정된 옵션보다 우선합니다. &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 및 &lt;code&gt;DROP&lt;/code&gt; 은 수행 할 조치를 지정합니다. 명시 적으로 지정된 작업이 없으면 &lt;code&gt;ADD&lt;/code&gt; 가 가정됩니다. 옵션 이름은 고유해야합니다. 옵션은 서버의 외부 데이터 래퍼에 의해서도 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="4079f921f60434a791719049a23492fea7f07a35" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;kind&lt;/code&gt; column of the table &lt;code&gt;films&lt;/code&gt; in the row on which the cursor &lt;code&gt;c_films&lt;/code&gt; is currently positioned:</source>
          <target state="translated">커서 &lt;code&gt;c_films&lt;/code&gt; 가 현재 위치한 행에서 테이블 &lt;code&gt;films&lt;/code&gt; 의 &lt;code&gt;kind&lt;/code&gt; 열을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6047ac63e307a1c73e41cea4c35cbe978e5136b" translate="yes" xml:space="preserve">
          <source>Change the estimated execution cost of the function. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information.</source>
          <target state="translated">함수의 예상 실행 비용을 변경하십시오. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7be062c0a326c001bfbc1643bf43fd4478ebdb7" translate="yes" xml:space="preserve">
          <source>Change the estimated number of rows returned by a set-returning function. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information.</source>
          <target state="translated">set-returning 함수에 의해 리턴되는 예상 행 수를 변경하십시오. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="752e27cecfa297027f38ddc03ddff0fc4b807417" translate="yes" xml:space="preserve">
          <source>Change the foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt; validator to &lt;code&gt;bob.myvalidator&lt;/code&gt;:</source>
          <target state="translated">외부 데이터 랩퍼 &lt;code&gt;dbi&lt;/code&gt; 유효성 검증기를 &lt;code&gt;bob.myvalidator&lt;/code&gt; 로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="99dd6ebc845670651ee7fd5030fcefab705a16bd" translate="yes" xml:space="preserve">
          <source>Change the owner of a custom operator &lt;code&gt;a @@ b&lt;/code&gt; for type &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">유형 &lt;code&gt;text&lt;/code&gt; 대해 사용자 정의 연산자 &lt;code&gt;a @@ b&lt;/code&gt; 의 소유자를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="f67faa872d879796ec2bc11061dcb9aa0dc35620" translate="yes" xml:space="preserve">
          <source>Change the owner of tablespace &lt;code&gt;index_space&lt;/code&gt;:</source>
          <target state="translated">테이블 스페이스 &lt;code&gt;index_space&lt;/code&gt; 의 소유자를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="822b72ef81f93836b39722295acc34f4c19b0ad4" translate="yes" xml:space="preserve">
          <source>Change the password for user mapping &lt;code&gt;bob&lt;/code&gt;, server &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">사용자 맵핑 &lt;code&gt;bob&lt;/code&gt; , server &lt;code&gt;foo&lt;/code&gt; 의 비밀번호를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6bbf58e1e213f392cf582da3a65ec34c7ff9158" translate="yes" xml:space="preserve">
          <source>Change the publication subscribed by a subscription to &lt;code&gt;insert_only&lt;/code&gt;:</source>
          <target state="translated">구독이 구독 한 발행물을 &lt;code&gt;insert_only&lt;/code&gt; 로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="34045da15d11f6b740295ddc20c0543d3c0083d2" translate="yes" xml:space="preserve">
          <source>Change the publication to publish only deletes and updates:</source>
          <target state="translated">삭제 및 업데이트 만 게시하도록 게시를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="f3a2a1e4d568c17a9cd30237edc9531469c8253f" translate="yes" xml:space="preserve">
          <source>Change the restriction and join selectivity estimator functions of a custom operator &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; for type &lt;code&gt;int[]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;int[]&lt;/code&gt; 유형 에 대한 사용자 정의 연산자 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 의 제한 및 결합 선택성 추정기 함수를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eaac47535f3006e741788eeae8fad9312a10aad" translate="yes" xml:space="preserve">
          <source>Change the volatility of the function to the specified setting. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for details.</source>
          <target state="translated">함수의 변동성을 지정된 설정으로 변경하십시오. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="60d595e67191c4d753fcf4d6f5f6b1e59875a42f" translate="yes" xml:space="preserve">
          <source>Change the word &lt;code&gt;Drama&lt;/code&gt; to &lt;code&gt;Dramatic&lt;/code&gt; in the column &lt;code&gt;kind&lt;/code&gt; of the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 의 열 &lt;code&gt;kind&lt;/code&gt; 에서 &lt;code&gt;Drama&lt;/code&gt; 라는 단어 를 &lt;code&gt;Dramatic&lt;/code&gt; 으로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="25251bc112e3a399370d96db7461370f4dac1521" translate="yes" xml:space="preserve">
          <source>Change whether the function is a security definer or not. The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is ignored for SQL conformance. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">함수가 보안 정의 자인지 여부를 변경하십시오. 키워드 &lt;code&gt;EXTERNAL&lt;/code&gt; 은 SQL 준수를 위해 무시됩니다. 이 &lt;a href=&quot;sql-createfunction&quot;&gt;기능에&lt;/a&gt; 대한 자세한 내용은 CREATE FUNCTION 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb664af015dace04548cd3bd3ebd863d23f845c0" translate="yes" xml:space="preserve">
          <source>Change whether the function is considered leakproof or not. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">기능이 누출 방지로 간주되는지 여부를 변경하십시오. 이 &lt;a href=&quot;sql-createfunction&quot;&gt;기능에&lt;/a&gt; 대한 자세한 내용은 CREATE FUNCTION 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="710f9c7b0ca4d696dc493952c70e1f717c7f158b" translate="yes" xml:space="preserve">
          <source>Change whether the function is deemed safe for parallelism. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for details.</source>
          <target state="translated">함수가 병렬 처리에 안전한 것으로 간주되는지 여부를 변경하십시오. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccc17eca5e67913c7a2e828017ca46a7b7979197" translate="yes" xml:space="preserve">
          <source>Change whether the procedure is a security definer or not. The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is ignored for SQL conformance. See &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">프로 시저가 보안 정의 자인지 여부를 변경하십시오. 키워드 &lt;code&gt;EXTERNAL&lt;/code&gt; 은 SQL 준수를 위해 무시됩니다. 이 기능에 대한 자세한 내용은 &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c22a270b73e2d826094dc62ba61207ee6ca0fc" translate="yes" xml:space="preserve">
          <source>Changes list of subscribed publications. See &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; for more information. By default this command will also act like &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">구독 한 발행물의 목록을 변경합니다. 자세한 내용은 &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; 을 참조하십시오. 기본적으로이 명령은 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="0777421bfc3abbfb82a4dcb9e3f2333e76343008" translate="yes" xml:space="preserve">
          <source>Changes the check option of the view. The value must be &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;cascaded&lt;/code&gt;.</source>
          <target state="translated">보기의 검사 옵션을 변경합니다. 값은 &lt;code&gt;local&lt;/code&gt; 이거나 &lt;code&gt;cascaded&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="777c3c6f950fa43c4d4037401ba7e0940fae4b49" translate="yes" xml:space="preserve">
          <source>Changes the current working directory to &lt;code&gt;directory&lt;/code&gt;. Without argument, changes to the current user's home directory.</source>
          <target state="translated">현재 작업 디렉토리를 &lt;code&gt;directory&lt;/code&gt; 로 변경합니다 . 인수없이 현재 사용자의 홈 디렉토리로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ddde67e94aac5719e856f9f56f12bfe3f8078cfb" translate="yes" xml:space="preserve">
          <source>Changes the password of the specified user (by default, the current user). This command prompts for the new password, encrypts it, and sends it to the server as an &lt;code&gt;ALTER ROLE&lt;/code&gt; command. This makes sure that the new password does not appear in cleartext in the command history, the server log, or elsewhere.</source>
          <target state="translated">지정된 사용자 (기본적으로 현재 사용자)의 비밀번호를 변경합니다. 이 명령은 새 비밀번호를 프롬프트하고 암호화 한 후 &lt;code&gt;ALTER ROLE&lt;/code&gt; 명령 으로 서버에 보냅니다 . 이렇게하면 새 암호가 명령 기록, 서버 로그 또는 다른 곳에 일반 텍스트로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1b27c7f777795b5a8bac186c7dd233e03b18cba" translate="yes" xml:space="preserve">
          <source>Changes the security-barrier property of the view. The value must be Boolean value, such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">뷰의 보안 장벽 속성을 변경합니다. 값은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 와 같은 부울 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7ce3845fd5b5d14e3265dc23e6b60ef23ef1b60" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. Send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt; and apply the changes. The postmaster will also forward the SIGHUP signal to its child processes so that they all pick up the new value.</source>
          <target state="translated">서버를 다시 시작하지 않고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 이러한 설정을 변경할 수 있습니다 . SIGHUP 신호를 포스트 마스터에게 &lt;code&gt;postgresql.conf&lt;/code&gt; 를 다시 읽고 변경 사항을 적용하십시오. 포스트 마스터는 또한 SIGHUP 신호를 자식 프로세스에 전달하여 새로운 가치를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0934f8a643d966fc64ef65df08c958701e8d815a" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. They can also be set for a particular session in the connection request packet (for example, via libpq's &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable), but only if the connecting user is a superuser. However, these settings never change in a session after it is started. If you change them in &lt;code&gt;postgresql.conf&lt;/code&gt;, send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt;. The new values will only affect subsequently-launched sessions.</source>
          <target state="translated">서버를 다시 시작하지 않고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 이러한 설정을 변경할 수 있습니다 . 연결 요청 패킷 (예 : libpq의 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수 를 통해)에서 특정 세션에 대해 설정할 수도 있지만 연결 사용자가 수퍼 유저 인 경우에만 가능합니다. 그러나 세션이 시작된 후에는 이러한 설정이 변경되지 않습니다. 당신이 그들을 변경하는 경우 &lt;code&gt;postgresql.conf&lt;/code&gt; , 다시 읽기에 원인이 포스트 마스터에 SIGHUP 신호를 보내 &lt;code&gt;postgresql.conf&lt;/code&gt; . 새로운 값은 이후에 시작된 세션에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="a6c05c39b940af67c715028a77dd005d7cf98570" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. They can also be set for a particular session in the connection request packet (for example, via libpq's &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable); any user can make such a change for their session. However, these settings never change in a session after it is started. If you change them in &lt;code&gt;postgresql.conf&lt;/code&gt;, send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt;. The new values will only affect subsequently-launched sessions.</source>
          <target state="translated">서버를 다시 시작하지 않고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 이러한 설정을 변경할 수 있습니다 . 연결 요청 패킷의 특정 세션에 대해 설정 될 수도 있습니다 (예 : libpq의 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수 를 통해 ). 모든 사용자는 세션을 변경할 수 있습니다. 그러나 세션이 시작된 후에는 이러한 설정이 변경되지 않습니다. 당신이 그들을 변경하는 경우 &lt;code&gt;postgresql.conf&lt;/code&gt; , 다시 읽기에 원인이 포스트 마스터에 SIGHUP 신호를 보내 &lt;code&gt;postgresql.conf&lt;/code&gt; . 새로운 값은 이후에 시작된 세션에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="51c5f5c3f24afc08ce8ad26a3d8c4257e01709ce" translate="yes" xml:space="preserve">
          <source>Changing Time Sources</source>
          <target state="translated">시간 소스 변경</target>
        </trans-unit>
        <trans-unit id="24c13713f33c06e521f24073f9a29f50dd240e05" translate="yes" xml:space="preserve">
          <source>Changing any part of a system catalog index is not permitted.</source>
          <target state="translated">시스템 카탈로그 색인의 일부를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="973bbe6ff83bf124a281e544016f1c5fb5860e0e" translate="yes" xml:space="preserve">
          <source>Changing any part of a system catalog table is not permitted.</source>
          <target state="translated">시스템 카탈로그 테이블의 일부를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="21462f78ab4f0aaa927058f48a0fc647c028e21a" translate="yes" xml:space="preserve">
          <source>Changing cluster options acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">클러스터 옵션을 변경하면 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금이 획득 됩니다.</target>
        </trans-unit>
        <trans-unit id="5877579fd9f9e91de9fa7be674c1083ea2046c3e" translate="yes" xml:space="preserve">
          <source>Changing per-attribute options acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">속성 별 옵션을 변경하면 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금이 획득 됩니다.</target>
        </trans-unit>
        <trans-unit id="7584a57d6ab8a0cf30aa0677fe9bdf7463b56891" translate="yes" xml:space="preserve">
          <source>Changing table-level options requires being a superuser or having the privileges of the default role &lt;code&gt;pg_read_server_files&lt;/code&gt; (to use a filename) or the default role &lt;code&gt;pg_execute_server_program&lt;/code&gt; (to use a program), for security reasons: only certain users should be able to control which file is read or which program is run. In principle regular users could be allowed to change the other options, but that's not supported at present.</source>
          <target state="translated">보안을 위해 테이블 ​​수준 옵션을 변경하려면 수퍼 유저이거나 기본 역할 &lt;code&gt;pg_read_server_files&lt;/code&gt; (파일 이름 사용) 또는 기본 역할 &lt;code&gt;pg_execute_server_program&lt;/code&gt; (프로그램 사용) 권한이 있어야합니다. 특정 사용자 만 어떤 파일을 제어 할 수 있어야합니다. 읽거나 실행중인 프로그램. 원칙적으로 일반 사용자는 다른 옵션을 변경할 수 있지만 현재는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec87cc74541eda23f7b65c039143416f12ea00c9" translate="yes" xml:space="preserve">
          <source>Changing the data type automatically changes the minimum and maximum values of the sequence if and only if the previous minimum and maximum values were the minimum or maximum value of the old data type (in other words, if the sequence had been created using &lt;code&gt;NO MINVALUE&lt;/code&gt; or &lt;code&gt;NO MAXVALUE&lt;/code&gt;, implicitly or explicitly). Otherwise, the minimum and maximum values are preserved, unless new values are given as part of the same command. If the minimum and maximum values do not fit into the new data type, an error will be generated.</source>
          <target state="translated">데이터 유형을 변경하면 이전 최소값 및 최대 값이 이전 데이터 유형의 최소값 또는 최대 값 인 경우에만 (즉, 시퀀스가 &lt;code&gt;NO MINVALUE&lt;/code&gt; 또는 암시 적 또는 명시 적으로 &lt;code&gt;NO MAXVALUE&lt;/code&gt; ). 그렇지 않으면, 새 값이 동일한 명령의 일부로 제공되지 않으면 최소값과 최대 값이 유지됩니다. 최소값과 최대 값이 새 데이터 유형에 맞지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7dc3983a4c99b0fe0a191c91c764c99b40a05eca" translate="yes" xml:space="preserve">
          <source>Chapter 1. Getting Started</source>
          <target state="translated">제 1 장 시작하기</target>
        </trans-unit>
        <trans-unit id="e6d40f75e780880b35096c7da5d0b6cf88f51548" translate="yes" xml:space="preserve">
          <source>Chapter 10. Type Conversion</source>
          <target state="translated">10 장. 타입 변환</target>
        </trans-unit>
        <trans-unit id="cfc60ee425037eb0cb18f43ee9772ce702d95eb9" translate="yes" xml:space="preserve">
          <source>Chapter 11. Indexes</source>
          <target state="translated">11 장. 색인</target>
        </trans-unit>
        <trans-unit id="144f77ced617edb24e991a9d443488ae927d7c88" translate="yes" xml:space="preserve">
          <source>Chapter 12. Full Text Search</source>
          <target state="translated">12 장. 전체 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="da45141dfeefeb5e789dc9ca5e0fb10036e0db6b" translate="yes" xml:space="preserve">
          <source>Chapter 13. Concurrency Control</source>
          <target state="translated">13 장. 동시성 제어</target>
        </trans-unit>
        <trans-unit id="b6ddf02aec05f48576f7b85e82401c2fb11071b2" translate="yes" xml:space="preserve">
          <source>Chapter 14. Performance Tips</source>
          <target state="translated">14 장. 성능 팁</target>
        </trans-unit>
        <trans-unit id="a623aebbb35dd440482c53dd04d3cc33587e63de" translate="yes" xml:space="preserve">
          <source>Chapter 15. Parallel Query</source>
          <target state="translated">병렬 쿼리</target>
        </trans-unit>
        <trans-unit id="0957a991197939830de983f69bedda91d4f25003" translate="yes" xml:space="preserve">
          <source>Chapter 18. Server Setup and Operation</source>
          <target state="translated">18 장. 서버 설정 및 운영</target>
        </trans-unit>
        <trans-unit id="81614972621513084f8d86c5e74b927c0877f9d6" translate="yes" xml:space="preserve">
          <source>Chapter 19. Server Configuration</source>
          <target state="translated">19 장. 서버 설정</target>
        </trans-unit>
        <trans-unit id="efd5bae0ce55fc43eb45287a5d1358eeee9c1b2a" translate="yes" xml:space="preserve">
          <source>Chapter 2. The SQL Language</source>
          <target state="translated">제 2 장 SQL 언어</target>
        </trans-unit>
        <trans-unit id="af2a556e9df470b26cc29ab94ee6bdb8e560309e" translate="yes" xml:space="preserve">
          <source>Chapter 20. Client Authentication</source>
          <target state="translated">20 장. 클라이언트 인증</target>
        </trans-unit>
        <trans-unit id="6bfff62df4428a98260ccc9d271cbb22ddc7803f" translate="yes" xml:space="preserve">
          <source>Chapter 21. Database Roles</source>
          <target state="translated">21 장. 데이터베이스 역할</target>
        </trans-unit>
        <trans-unit id="b792ed08d021d0c561b88be9f49cbde88d6ced6a" translate="yes" xml:space="preserve">
          <source>Chapter 22. Managing Databases</source>
          <target state="translated">22 장. 데이터베이스 관리</target>
        </trans-unit>
        <trans-unit id="8d2edcb13a63c18cd7431348c9c33dd52179cd7a" translate="yes" xml:space="preserve">
          <source>Chapter 23. Localization</source>
          <target state="translated">23 장. 현지화</target>
        </trans-unit>
        <trans-unit id="cc6e2a7196fcdb26bf6fc059b5192cf48cbbeb9a" translate="yes" xml:space="preserve">
          <source>Chapter 24. Routine Database Maintenance Tasks</source>
          <target state="translated">24 장. 일상적인 데이터베이스 유지 관리 작업</target>
        </trans-unit>
        <trans-unit id="999abf9a7e4b84d6e10d17d3ec4bee1b92661ec4" translate="yes" xml:space="preserve">
          <source>Chapter 25. Backup and Restore</source>
          <target state="translated">25 장. 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="2f78caaef8b16396a00b39c42fd9aa13a58d3184" translate="yes" xml:space="preserve">
          <source>Chapter 26. High Availability, Load Balancing, and Replication</source>
          <target state="translated">26 장. 고 가용성,로드 밸런싱 및 복제</target>
        </trans-unit>
        <trans-unit id="8493e0a0f186cf62af71bae82b8349af48aa3fd9" translate="yes" xml:space="preserve">
          <source>Chapter 27. Monitoring Database Activity</source>
          <target state="translated">27 장. 데이터베이스 활동 모니터링</target>
        </trans-unit>
        <trans-unit id="1d570d3d2b96fe14cfb80e65a5fe7f4b3e799cdd" translate="yes" xml:space="preserve">
          <source>Chapter 28. Monitoring Disk Usage</source>
          <target state="translated">28 장. 디스크 사용량 모니터링</target>
        </trans-unit>
        <trans-unit id="a7885f0c5b06135be5bc70fc82f008c6016fa830" translate="yes" xml:space="preserve">
          <source>Chapter 29. Reliability and the Write-Ahead Log</source>
          <target state="translated">29 장. 안정성과 미리 쓰기 로그</target>
        </trans-unit>
        <trans-unit id="97aa927595d881f2ff337f4912ea0e9b82088241" translate="yes" xml:space="preserve">
          <source>Chapter 3. Advanced Features</source>
          <target state="translated">3 장. 고급 기능</target>
        </trans-unit>
        <trans-unit id="e8e86ed3680a0da061058da829d1c17ec1464f63" translate="yes" xml:space="preserve">
          <source>Chapter 30. Logical Replication</source>
          <target state="translated">논리 복제</target>
        </trans-unit>
        <trans-unit id="0140c5595dbd5eded593d083b7cb332d49390c5f" translate="yes" xml:space="preserve">
          <source>Chapter 31. Just-in-Time Compilation (JIT)</source>
          <target state="translated">31 장. 적시 컴파일 (JIT)</target>
        </trans-unit>
        <trans-unit id="1c7e336e40970e68c4ae71ede9ff09d76f9e2079" translate="yes" xml:space="preserve">
          <source>Chapter 32. Regression Tests</source>
          <target state="translated">32 장. 회귀 테스트</target>
        </trans-unit>
        <trans-unit id="1f8599ba762099abf0b89f7dc39cca2e5a083ac4" translate="yes" xml:space="preserve">
          <source>Chapter 34</source>
          <target state="translated">제 34 장</target>
        </trans-unit>
        <trans-unit id="a93ab43c432bd443ba365612032323e07c1fc754" translate="yes" xml:space="preserve">
          <source>Chapter 4. SQL Syntax</source>
          <target state="translated">제 4 장 SQL 구문</target>
        </trans-unit>
        <trans-unit id="c2b5a541b35089953bda9d932bfef2ebf3ccf321" translate="yes" xml:space="preserve">
          <source>Chapter 49. Replication Progress Tracking</source>
          <target state="translated">복제 진행 추적</target>
        </trans-unit>
        <trans-unit id="5ea97798ce48ae5bf5d042baf817fc0df4595548" translate="yes" xml:space="preserve">
          <source>Chapter 5. Data Definition</source>
          <target state="translated">제 5 장 데이터 정의</target>
        </trans-unit>
        <trans-unit id="a8b14bc1812f9defda6a2509d441df7ef70b7425" translate="yes" xml:space="preserve">
          <source>Chapter 50. Overview of PostgreSQL Internals</source>
          <target state="translated">50 장. PostgreSQL 내부의 개요</target>
        </trans-unit>
        <trans-unit id="e23b07ca96c19b38aad6046e78d79f3afc6ca003" translate="yes" xml:space="preserve">
          <source>Chapter 51. System Catalogs</source>
          <target state="translated">시스템 카탈로그</target>
        </trans-unit>
        <trans-unit id="01a1ea702aa47902cf7384a552f9ea849e00d4bc" translate="yes" xml:space="preserve">
          <source>Chapter 52. Frontend/Backend Protocol</source>
          <target state="translated">52 장. 프론트 엔드 / 백엔드 프로토콜</target>
        </trans-unit>
        <trans-unit id="f102361cd632919e9b21dd5529b48deab47f2d3b" translate="yes" xml:space="preserve">
          <source>Chapter 59. Genetic Query Optimizer</source>
          <target state="translated">제 59 장 유전자 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="84bf92c9f2634767c3f75678e6c3b21abc348a37" translate="yes" xml:space="preserve">
          <source>Chapter 6. Data Manipulation</source>
          <target state="translated">제 6 장 데이터 조작</target>
        </trans-unit>
        <trans-unit id="00e7845f472e9e21938a52be52669507694bef24" translate="yes" xml:space="preserve">
          <source>Chapter 60. Table Access Method Interface Definition</source>
          <target state="translated">제 60 장 테이블 액세스 방법 인터페이스 정의</target>
        </trans-unit>
        <trans-unit id="50b349d477a1004af15a262946b1b1bf78f59506" translate="yes" xml:space="preserve">
          <source>Chapter 61. Index Access Method Interface Definition</source>
          <target state="translated">61 장. 인덱스 액세스 방법 인터페이스 정의</target>
        </trans-unit>
        <trans-unit id="e86751cda024c4b0057b8bc2d8e134bf6720ad4f" translate="yes" xml:space="preserve">
          <source>Chapter 62. Generic WAL Records</source>
          <target state="translated">제 62 장. 일반 WAL 레코드</target>
        </trans-unit>
        <trans-unit id="2b20988c4a380ea4a2ab94af4609d4e072cb7eb5" translate="yes" xml:space="preserve">
          <source>Chapter 63. B-Tree Indexes</source>
          <target state="translated">63 장. B- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="5890471db64af7d3bf7b87716d5092b9f512e1cb" translate="yes" xml:space="preserve">
          <source>Chapter 64. GiST Indexes</source>
          <target state="translated">64 장 GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="e56f90bfb3dacab919ac1112ea25a3efcb6c1a00" translate="yes" xml:space="preserve">
          <source>Chapter 65. SP-GiST Indexes</source>
          <target state="translated">65 장. SP-GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="c6f0f26cc9de5e585a31d9d2cf9c68cca6ec7658" translate="yes" xml:space="preserve">
          <source>Chapter 66. GIN Indexes</source>
          <target state="translated">66 장. GIN 지수</target>
        </trans-unit>
        <trans-unit id="8f2e47f95ee2acadfb5ec33dd6ae2cf9fd4a6711" translate="yes" xml:space="preserve">
          <source>Chapter 67. BRIN Indexes</source>
          <target state="translated">67 장. BRIN 색인</target>
        </trans-unit>
        <trans-unit id="6afd1fb819de09d125ca4e339c9265abf900ac85" translate="yes" xml:space="preserve">
          <source>Chapter 68. Database Physical Storage</source>
          <target state="translated">제 68 장 데이터베이스 실제 스토리지</target>
        </trans-unit>
        <trans-unit id="2fe6d5ccc8d12bd80e2fa0c2ee3d84273661e269" translate="yes" xml:space="preserve">
          <source>Chapter 69. System Catalog Declarations and Initial Contents</source>
          <target state="translated">69 장. 시스템 카탈로그 선언 및 초기 내용</target>
        </trans-unit>
        <trans-unit id="85a83fb1ee953f82a74bb0425f0e03a24516c11e" translate="yes" xml:space="preserve">
          <source>Chapter 7. Queries</source>
          <target state="translated">7 장. 쿼리</target>
        </trans-unit>
        <trans-unit id="80bc7bf38cd739b624ee0a7ea1a1d3f778334dbe" translate="yes" xml:space="preserve">
          <source>Chapter 70. How the Planner Uses Statistics</source>
          <target state="translated">플래너가 통계를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="6642f4e46001481876e1721c282938a698fb6952" translate="yes" xml:space="preserve">
          <source>Chapter 8. Data Types</source>
          <target state="translated">제 8 장 데이터 타입</target>
        </trans-unit>
        <trans-unit id="a79b450fb04e556467b32b8d86d6e908fabd3a9d" translate="yes" xml:space="preserve">
          <source>Chapter 9. Functions and Operators</source>
          <target state="translated">제 9 장 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="8fb52d46ccc67c5f0a8ba2bd734e96328d987098" translate="yes" xml:space="preserve">
          <source>Character Set Support</source>
          <target state="translated">문자 세트 지원</target>
        </trans-unit>
        <trans-unit id="86006dcd13baf1cafe09a54ad445f33fc30c6cf3" translate="yes" xml:space="preserve">
          <source>Character Types</source>
          <target state="translated">문자 종류</target>
        </trans-unit>
        <trans-unit id="4f7075e995d2056ff3899650c4361b65b9866300" translate="yes" xml:space="preserve">
          <source>Character Types: &amp;quot;char&amp;quot;</source>
          <target state="translated">문자 유형 : &quot;char&quot;</target>
        </trans-unit>
        <trans-unit id="a3a45c91003d5cefafa6107f199f7a38d0c3c890" translate="yes" xml:space="preserve">
          <source>Character Types: char</source>
          <target state="translated">문자 유형 : char</target>
        </trans-unit>
        <trans-unit id="0aee8fce8b418732e8a93fd32cc1cc805032fb73" translate="yes" xml:space="preserve">
          <source>Character Types: character</source>
          <target state="translated">문자 유형 : 문자</target>
        </trans-unit>
        <trans-unit id="184b3e9992e817890a21c13085e7efc314459161" translate="yes" xml:space="preserve">
          <source>Character Types: character varying</source>
          <target state="translated">문자 유형 : 문자 변경</target>
        </trans-unit>
        <trans-unit id="d4fd2a583804bcd76bea8c996513a8311f7ac4e9" translate="yes" xml:space="preserve">
          <source>Character Types: name</source>
          <target state="translated">문자 유형 : 이름</target>
        </trans-unit>
        <trans-unit id="0486f703899f29349943b2afc946401438fa2fb5" translate="yes" xml:space="preserve">
          <source>Character Types: text</source>
          <target state="translated">문자 유형 : text</target>
        </trans-unit>
        <trans-unit id="d4567dcae64a823d557e1c63712b4fcc9fd32502" translate="yes" xml:space="preserve">
          <source>Character Types: varchar</source>
          <target state="translated">문자 유형 : varchar</target>
        </trans-unit>
        <trans-unit id="bab88ca409704f60d81387fe2d6df281de9d2556" translate="yes" xml:space="preserve">
          <source>Character classification (&lt;code&gt;LC_CTYPE&lt;/code&gt;) to use in the new database. This affects the categorization of characters, e.g. lower, upper and digit. The default is to use the character classification of the template database. See below for additional restrictions.</source>
          <target state="translated">새 데이터베이스에서 사용할 문자 분류 ( &lt;code&gt;LC_CTYPE&lt;/code&gt; ). 이것은 문자의 분류에 영향을 미칩니다 (예 : 더 낮은, 상단 및 숫자). 디폴트는 템플리트 데이터베이스의 문자 분류를 사용하는 것입니다. 추가 제한 사항은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f3582c4ef82e94dd06e96939b0da35a20fc80c2" translate="yes" xml:space="preserve">
          <source>Character classification (What is a letter? Its upper-case equivalent?)</source>
          <target state="translated">문자 분류 (문자는 무엇입니까? 대문자와 동일합니까?)</target>
        </trans-unit>
        <trans-unit id="aa111127437686e9ef12f3077c9087864a7d1bee" translate="yes" xml:space="preserve">
          <source>Character encoding for this database (&lt;code&gt;pg_encoding_to_char()&lt;/code&gt; can translate this number to the encoding name)</source>
          <target state="translated">이 데이터베이스의 문자 인코딩 ( &lt;code&gt;pg_encoding_to_char()&lt;/code&gt; 은이 숫자를 인코딩 이름으로 변환 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="5c302c7525b7a3146ad611a4f0f12d64c21504af" translate="yes" xml:space="preserve">
          <source>Character set encoding to use in the new database. Specify a string constant (e.g., &lt;code&gt;'SQL_ASCII'&lt;/code&gt;), or an integer encoding number, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default encoding (namely, the encoding of the template database). The character sets supported by the PostgreSQL server are described in &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;Section 23.3.1&lt;/a&gt;. See below for additional restrictions.</source>
          <target state="translated">새 데이터베이스에서 사용할 문자 세트 인코딩 기본 인코딩 (즉, 템플리트 데이터베이스의 인코딩)을 사용하려면 문자열 상수 (예 : &lt;code&gt;'SQL_ASCII'&lt;/code&gt; ) 또는 정수 인코딩 번호 또는 &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정하십시오. PostgreSQL 서버가 지원하는 문자 세트는 &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;23.3.1 절에&lt;/a&gt; 설명되어 있습니다. 추가 제한 사항은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfed8165769c95c83883de51ead984f0672c66d" translate="yes" xml:space="preserve">
          <source>Character that separates two values of this type when parsing array input. Note that the delimiter is associated with the array element data type, not the array data type.</source>
          <target state="translated">배열 입력을 구문 분석 할 때이 유형의 두 값을 구분하는 문자입니다. 분리 문자는 배열 데이터 유형이 아닌 배열 요소 데이터 유형과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="0d26b57dd1b6ed08d8cfe3afbee948653ba7fb89" translate="yes" xml:space="preserve">
          <source>Character with the given code. For UTF8 the argument is treated as a Unicode code point. For other multibyte encodings the argument must designate an ASCII character. The NULL (0) character is not allowed because text data types cannot store such bytes.</source>
          <target state="translated">주어진 코드를 가진 문자. UTF8의 경우 인수는 유니 코드 코드 포인트로 처리됩니다. 다른 멀티 바이트 인코딩의 경우 인수는 ASCII 문자를 지정해야합니다. 텍스트 데이터 유형이 이러한 바이트를 저장할 수 없으므로 NULL (0) 문자는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdedfe7a4afbdacdcf985eb3b52d523de98f2bcf" translate="yes" xml:space="preserve">
          <source>Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including a &lt;code&gt;COLLATE&lt;/code&gt; clause in the &lt;code&gt;expression&lt;/code&gt;, for example &lt;code&gt;ORDER BY mycolumn COLLATE &quot;en_US&quot;&lt;/code&gt;. For more information see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-COLLATE-EXPRS&quot;&gt;Section 4.2.10&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">문자열 데이터는 정렬중인 열에 적용되는 데이터 정렬에 따라 정렬됩니다. 그는 포함하여 필요에 대체 될 수 있습니다 &lt;code&gt;COLLATE&lt;/code&gt; 에 절 &lt;code&gt;expression&lt;/code&gt; 예를 들어, &lt;code&gt;ORDER BY mycolumn COLLATE &quot;en_US&quot;&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-COLLATE-EXPRS&quot;&gt;4.2.10 &lt;/a&gt;&lt;a href=&quot;collation&quot;&gt;절&lt;/a&gt; 및 23.2 절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c5ac88bf4f0fe444e0c2465c83a58e27360537f" translate="yes" xml:space="preserve">
          <source>Chebyshev (L-inf metric) distance between a and b.</source>
          <target state="translated">a와 b 사이의 체비 쇼프 (L-inf 메트릭) 거리.</target>
        </trans-unit>
        <trans-unit id="28adc605845f7c3238135a62761fd3dab78dc6b8" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for details on possible error conditions.</source>
          <target state="translated">가능한 오류 조건에 대한 자세한 내용은 &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="881903249e105e6faf78f5aa20ebda36308bf1af" translate="yes" xml:space="preserve">
          <source>Check constraints on domains are stored here, too.</source>
          <target state="translated">도메인에 대한 점검 제한 사항도 여기에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7e37f10bc050bb609ea93daca587898aec0aab" translate="yes" xml:space="preserve">
          <source>Check for a function accepting exactly the input argument types. If one exists (there can be only one exact match in the set of functions considered), use it. Lack of an exact match creates a security hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a function found in a schema that permits untrusted users to create objects. In such situations, cast arguments to force an exact match. (Cases involving &lt;code&gt;unknown&lt;/code&gt; will never find a match at this step.)</source>
          <target state="translated">입력 인수 유형을 정확히 수락하는 함수를 확인하십시오. 하나가 존재하는 경우 (고려 된 기능 세트에서 정확히 하나만 일치 할 수 있음) 사용하십시오. 정확히 일치하지 않으면 정규화 된 이름 &lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt; 을 통해 신뢰할 수없는 사용자가 개체를 만들 수있는 스키마에있는 함수 를 호출 할 때 보안 위험이 발생 합니다. 이러한 상황에서는 인수를 캐스팅하여 정확하게 일치시킵니다. ( &lt;code&gt;unknown&lt;/code&gt; 케이스 는이 단계에서 절대 일치하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="9ec7dff9841a879a9c69437c7718d0bd7aac1d4d" translate="yes" xml:space="preserve">
          <source>Check for an exact match with the target.</source>
          <target state="translated">대상과 정확히 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e7df70bcd90516e453d9dc6d68524c573ec357e2" translate="yes" xml:space="preserve">
          <source>Check for an operator accepting exactly the input argument types. If one exists (there can be only one exact match in the set of operators considered), use it. Lack of an exact match creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.OP-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;OP-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt; (not typical), any operator found in a schema that permits untrusted users to create objects. In such situations, cast arguments to force an exact match.</source>
          <target state="translated">입력 인수 유형을 정확하게 승인하는 연산자를 확인하십시오. 하나만 존재하면 (고려 된 일련의 연산자에서 정확히 하나만 일치 할 수 있음) 사용하십시오. 정확하게 일치 하지 않으면 정규화 된 이름 &lt;a href=&quot;#ftn.OP-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;OP-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt; (전형 아님)을 통해 신뢰할 수없는 사용자가 개체를 만들 수있는 스키마에서 발견 된 연산자 를 호출 할 때 보안 위험이 발생 합니다. 이러한 상황에서는 인수를 캐스팅하여 정확하게 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="f44d969c5b8fd2af5b373e500b5ba3c82215bc10" translate="yes" xml:space="preserve">
          <source>Check that PostgreSQL is actually using the locale that you think it is. The &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings are determined when a database is created, and cannot be changed except by creating a new database. Other locale settings including &lt;code&gt;LC_MESSAGES&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; are initially determined by the environment the server is started in, but can be changed on-the-fly. You can check the active locale settings using the &lt;code&gt;SHOW&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQL이 실제로 생각하는 로케일을 사용하고 있는지 확인하십시오. &lt;code&gt;LC_COLLATE&lt;/code&gt; 와 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정은 데이터베이스가 작성 될 때 결정하고, 새 데이터베이스를 작성하여 제외하고는 변경할 수 없습니다. &lt;code&gt;LC_MESSAGES&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; 를 포함한 다른 로케일 설정 은 처음에 서버가 시작된 환경에 의해 결정되지만 즉시 변경 될 수 있습니다. &lt;code&gt;SHOW&lt;/code&gt; 명령을 사용하여 활성 로케일 설정을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">이것 좀 봐:</target>
        </trans-unit>
        <trans-unit id="d82fa7ebda1d6f869b8585a124a94f6775cc9c50" translate="yes" xml:space="preserve">
          <source>Check to see if there is a sizing cast for the target type. A sizing cast is a cast from that type to itself. If one is found in the &lt;code&gt;pg_cast&lt;/code&gt; catalog, apply it to the expression before storing into the destination column. The implementation function for such a cast always takes an extra parameter of type &lt;code&gt;integer&lt;/code&gt;, which receives the destination column's &lt;code&gt;atttypmod&lt;/code&gt; value (typically its declared length, although the interpretation of &lt;code&gt;atttypmod&lt;/code&gt; varies for different data types), and it may take a third &lt;code&gt;boolean&lt;/code&gt; parameter that says whether the cast is explicit or implicit. The cast function is responsible for applying any length-dependent semantics such as size checking or truncation.</source>
          <target state="translated">대상 유형에 대한 사이징 캐스트가 있는지 확인하십시오. 사이징 캐스트는 해당 유형에서 자체로 캐스트됩니다. &lt;code&gt;pg_cast&lt;/code&gt; 카탈로그 에있는 것이 있으면 대상 열에 저장하기 전에 식에 적용하십시오. 이러한 캐스트에 대한 구현 함수는 항상 &lt;code&gt;integer&lt;/code&gt; 유형의 추가 매개 변수를 사용합니다.이 매개 변수 는 대상 열의 &lt;code&gt;atttypmod&lt;/code&gt; 값 (일반적으로 &lt;code&gt;atttypmod&lt;/code&gt; 의 해석이 다른 데이터 유형에 따라 다르지만 선언 된 길이 )을 수신하며 세 번째 &lt;code&gt;boolean&lt;/code&gt; 매개 변수를 사용할 수 있습니다. 캐스트가 명시 적인지 암시적인지를 나타냅니다. 캐스트 기능은 크기 검사 또는 자르기와 같은 길이에 따른 의미 체계를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="488bbca005e5d656c373f536704da9574c64804b" translate="yes" xml:space="preserve">
          <source>Check whether the index can support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; on the given column, by returning the indexed column values for an index entry in the form of an &lt;code&gt;IndexTuple&lt;/code&gt;. The attribute number is 1-based, i.e. the first column's attno is 1. Returns true if supported, else false. If the access method does not support index-only scans at all, the &lt;code&gt;amcanreturn&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL.</source>
          <target state="translated">&lt;code&gt;IndexTuple&lt;/code&gt; 형식으로 색인 항목에 대한 색인화 된 열 값을 리턴하여 색인이 지정된 열에서 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;색인 전용 스캔&lt;/em&gt;&lt;/a&gt; 을 지원할 수 있는지 확인하십시오 . 속성 번호는 1부터 시작합니다. 즉, 첫 번째 열의 attno는 1입니다. 지원되는 경우 true를, 그렇지 않으면 false를 반환합니다. 액세스 방법이 인덱스 전용 스캔을 전혀 지원하지 않는 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amcanreturn&lt;/code&gt; 필드 를 NULL로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719e3d162a113b1c19b3b2856b97aaee35467c4d" translate="yes" xml:space="preserve">
          <source>Checking the MCV list, we find that the condition &lt;code&gt;stringu1 &amp;lt; 'IAAAAA'&lt;/code&gt; is satisfied by the first six entries and not the last four, so the selectivity within the MCV part of the population is</source>
          <target state="translated">MCV 목록을 확인하면 조건 &lt;code&gt;stringu1 &amp;lt; 'IAAAAA'&lt;/code&gt; 가 마지막 4 개가 아닌 처음 6 개 항목에 의해 충족되므로 모집단의 MCV 부분 내 선택성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1cda95fa689cb3d5830910d67b28feaccae1de1" translate="yes" xml:space="preserve">
          <source>Checkpoints are fairly expensive, first because they require writing out all currently dirty buffers, and second because they result in extra subsequent WAL traffic as discussed above. It is therefore wise to set the checkpointing parameters high enough so that checkpoints don't happen too often. As a simple sanity check on your checkpointing parameters, you can set the &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-WARNING&quot;&gt;checkpoint_warning&lt;/a&gt; parameter. If checkpoints happen closer together than &lt;code&gt;checkpoint_warning&lt;/code&gt; seconds, a message will be output to the server log recommending increasing &lt;code&gt;max_wal_size&lt;/code&gt;. Occasional appearance of such a message is not cause for alarm, but if it appears often then the checkpoint control parameters should be increased. Bulk operations such as large &lt;code&gt;COPY&lt;/code&gt; transfers might cause a number of such warnings to appear if you have not set &lt;code&gt;max_wal_size&lt;/code&gt; high enough.</source>
          <target state="translated">검사 점은 현재 더티 버퍼를 모두 작성해야하기 때문에 상당히 비싸고, 두 번째는 위에서 설명한대로 추가 WAL 트래픽이 발생하기 때문입니다. 따라서 검사 점이 너무 자주 발생하지 않도록 검사 점 매개 변수를 충분히 높게 설정하는 것이 좋습니다. 당신의 체크 포인트 매개 변수에 대한 간단한 전성 검사, 당신은 설정할 수 있습니다 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-WARNING&quot;&gt;checkpoint_warning의&lt;/a&gt; 매개 변수를. 검사 점이 &lt;code&gt;checkpoint_warning&lt;/code&gt; 초 보다 가깝게 발생하면 &lt;code&gt;max_wal_size&lt;/code&gt; 증가를 권장하는 메시지가 서버 로그에 출력됩니다 . 이러한 메시지가 가끔 나타나는 경우 경보가 발생하지 않지만 자주 나타나는 경우 검사 점 제어 매개 변수를 늘려야합니다. 큰 &lt;code&gt;COPY&lt;/code&gt; 와 같은 대량 작업 &lt;code&gt;max_wal_size&lt;/code&gt; 를 충분히 높게 설정하지 않으면 전송으로 인해 여러 가지 경고가 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46973d9be1a1814adf1464037fbdb1be5e8d6b47" translate="yes" xml:space="preserve">
          <source>Checks checksums. This is the default mode if nothing else is specified.</source>
          <target state="translated">체크섬을 확인합니다. 다른 것을 지정하지 않으면 이것이 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="5391fb02e831f35b55c17ace48e9218641ee801d" translate="yes" xml:space="preserve">
          <source>Checks for the presence of the invalid flag</source>
          <target state="translated">유효하지 않은 플래그가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="aa8a835e319bd1e6dac67841e62eddb79cc4e5a5" translate="yes" xml:space="preserve">
          <source>Checks whether JSON path returns any item for the specified JSON value.</source>
          <target state="translated">JSON 경로가 지정된 JSON 값에 대한 항목을 반환하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="15dc18865567bcc98554a72a8036e1b64a8b85d5" translate="yes" xml:space="preserve">
          <source>Chinese</source>
          <target state="translated">Chinese</target>
        </trans-unit>
        <trans-unit id="850f86593a110cf1f0c83911a1210546b313dfdb" translate="yes" xml:space="preserve">
          <source>Choose the first non-unknown input type which is a preferred type in that category, if there is one.</source>
          <target state="translated">해당 범주에서 선호하는 유형 인 첫 번째 알 수없는 입력 유형을 선택하십시오 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a69230bc7ed4cf6a7a2fc18f922e5c50b3e5d64e" translate="yes" xml:space="preserve">
          <source>Chooses a method for inserting a new value into an inner tuple.</source>
          <target state="translated">내부 튜플에 새 값을 삽입하는 방법을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="54fd671b5f2d22b32dc8536c4592d6154ff72dae" translate="yes" xml:space="preserve">
          <source>Choosing the target number of partitions that the table should be divided into is also a critical decision to make. Not having enough partitions may mean that indexes remain too large and that data locality remains poor which could result in low cache hit ratios. However, dividing the table into too many partitions can also cause issues. Too many partitions can mean longer query planning times and higher memory consumption during both query planning and execution. When choosing how to partition your table, it's also important to consider what changes may occur in the future. For example, if you choose to have one partition per customer and you currently have a small number of large customers, consider the implications if in several years you instead find yourself with a large number of small customers. In this case, it may be better to choose to partition by &lt;code&gt;HASH&lt;/code&gt; and choose a reasonable number of partitions rather than trying to partition by &lt;code&gt;LIST&lt;/code&gt; and hoping that the number of customers does not increase beyond what it is practical to partition the data by.</source>
          <target state="translated">테이블을 분할해야 할 대상 파티션 수를 선택하는 것도 결정해야 할 중요한 결정입니다. 파티션이 충분하지 않으면 인덱스가 너무 크게 유지되고 데이터 지역성이 열악하여 캐시 적중률이 낮아질 수 있습니다. 그러나 테이블을 너무 많은 파티션으로 나누면 문제가 발생할 수 있습니다. 파티션이 너무 많으면 쿼리 계획 시간과 실행 시간이 길어질수록 쿼리 계획 시간이 길어지고 메모리 소비가 높아질 수 있습니다. 테이블을 분할하는 방법을 선택할 때는 나중에 어떤 변경이 발생할 수 있는지 고려해야합니다. 예를 들어, 고객 당 하나의 파티션을 선택하고 현재 소수의 큰 고객이있는 경우 몇 년 내에 많은 수의 소규모 고객을 찾는 경우 그 의미를 고려하십시오. 이 경우로 파티션을 선택하는 것이 좋습니다 &lt;code&gt;HASH&lt;/code&gt; &lt;code&gt;LIST&lt;/code&gt; 로 분할하려고 시도하는 대신 해시 하고 합리적인 수의 파티션을 선택하고 고객 수가 데이터를 분할하는 것이 실용적 수준 이상으로 증가하지 않기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="8e7b59e9016961f5946b822566182155391c3900" translate="yes" xml:space="preserve">
          <source>Cipher suites that use ciphers from &lt;code&gt;HIGH&lt;/code&gt; group (e.g., AES, Camellia, 3DES)</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; 그룹의 암호를 사용하는 암호 제품군 (예 : AES, Camellia, 3DES)</target>
        </trans-unit>
        <trans-unit id="a90feb83c70049708c284c2320a5ae7640f39786" translate="yes" xml:space="preserve">
          <source>Cipher suites that use ciphers from &lt;code&gt;MEDIUM&lt;/code&gt; group (e.g., RC4, SEED)</source>
          <target state="translated">&lt;code&gt;MEDIUM&lt;/code&gt; 그룹의 암호를 사용하는 암호 제품군 (예 : RC4, SEED)</target>
        </trans-unit>
        <trans-unit id="1cc7820a08e28aa22dd2e6db74a83b75abc240f5" translate="yes" xml:space="preserve">
          <source>Circle</source>
          <target state="translated">Circle</target>
        </trans-unit>
        <trans-unit id="4c4236345bc9bfb0ad518b6ac3fbc2dd31a75604" translate="yes" xml:space="preserve">
          <source>Circles are output using the first syntax.</source>
          <target state="translated">원은 첫 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="030bbcf35146cacbbc420191a591376e72bc90d5" translate="yes" xml:space="preserve">
          <source>Circles are represented by a center point and radius. Values of type &lt;code&gt;circle&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">원은 중심점과 반지름으로 표시됩니다. &lt;code&gt;circle&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="eccded7de4a65ea6b5b06c290b5b3a845542227e" translate="yes" xml:space="preserve">
          <source>Classless Inter-Domain Routing</source>
          <target state="translated">클래스리스 도메인 간 라우팅</target>
        </trans-unit>
        <trans-unit id="a49fe44e3b0307a1bcb798968f766c04a2364f10" translate="yes" xml:space="preserve">
          <source>Clean (drop) database objects before recreating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is used, this might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">데이터베이스 오브젝트를 다시 작성하기 전에 정리하십시오. ( &lt;code&gt;--if-exists&lt;/code&gt; 경우가 아니라면 대상 데이터베이스에 개체가없는 경우 무해한 오류 메시지가 생성 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a57d1cb7f7cf6beddd5cd4dce54e99565a6b71af" translate="yes" xml:space="preserve">
          <source>Clean or analyze &lt;code&gt;table&lt;/code&gt; only. Column names can be specified only in conjunction with the &lt;code&gt;--analyze&lt;/code&gt; or &lt;code&gt;--analyze-only&lt;/code&gt; options. Multiple tables can be vacuumed by writing multiple &lt;code&gt;-t&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; 만 청소하거나 분석 하십시오 . 열 이름은 &lt;code&gt;--analyze&lt;/code&gt; 또는 &lt;code&gt;--analyze-only&lt;/code&gt; 옵션 과 함께 만 지정할 수 있습니다 . 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 정리할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="735c96393614ad7c5c2b8ceb1620f8e0925da5fa" translate="yes" xml:space="preserve">
          <source>Clean up after a &lt;code&gt;VACUUM&lt;/code&gt; operation (zero or more &lt;code&gt;ambulkdelete&lt;/code&gt; calls). This does not have to do anything beyond returning index statistics, but it might perform bulk cleanup such as reclaiming empty index pages. &lt;code&gt;stats&lt;/code&gt; is whatever the last &lt;code&gt;ambulkdelete&lt;/code&gt; call returned, or NULL if &lt;code&gt;ambulkdelete&lt;/code&gt; was not called because no tuples needed to be deleted. If the result is not NULL it must be a palloc'd struct. The statistics it contains will be used to update &lt;code&gt;pg_class&lt;/code&gt;, and will be reported by &lt;code&gt;VACUUM&lt;/code&gt; if &lt;code&gt;VERBOSE&lt;/code&gt; is given. It is OK to return NULL if the index was not changed at all during the &lt;code&gt;VACUUM&lt;/code&gt; operation, but otherwise correct stats should be returned.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 작업 후 정리 (0 회 이상의 &lt;code&gt;ambulkdelete&lt;/code&gt; 호출). 인덱스 통계를 리턴하는 것 외에는 아무것도하지 않아도되지만 빈 인덱스 페이지를 교정하는 등 대량 정리를 수행 할 수 있습니다. &lt;code&gt;stats&lt;/code&gt; 는 마지막 &lt;code&gt;ambulkdelete&lt;/code&gt; 호출이 리턴 한 값이거나 튜플을 삭제할 필요가 없어서 &lt;code&gt;ambulkdelete&lt;/code&gt; 가 호출되지 않은 경우 NULL 입니다. 결과가 NULL이 아니면 palloc'd 구조체 여야합니다. 포함 된 통계는 &lt;code&gt;pg_class&lt;/code&gt; 를 업데이트하는 데 사용되며 &lt;code&gt;VERBOSE&lt;/code&gt; 가 제공 되면 &lt;code&gt;VACUUM&lt;/code&gt; 에 의해보고됩니다 . &lt;code&gt;VACUUM&lt;/code&gt; 중에 인덱스가 전혀 변경되지 않은 경우 NULL을 리턴해도됩니다. 그렇지 않으면 올바른 통계를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ad74a5024055d7cfa2c59a9048dd8da2e960d57" translate="yes" xml:space="preserve">
          <source>Clear the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a9a4c5e05949324bf6b0fb16d4b4f3cadea624c4" translate="yes" xml:space="preserve">
          <source>Client Authentication</source>
          <target state="translated">클라이언트 인증</target>
        </trans-unit>
        <trans-unit id="357dbce503344612c0fabd6c1533f8bd69142fe2" translate="yes" xml:space="preserve">
          <source>Client Connection Defaults</source>
          <target state="translated">클라이언트 연결 기본값</target>
        </trans-unit>
        <trans-unit id="d1fc8bcb92d3397338fda7ac070162a07bf83d07" translate="yes" xml:space="preserve">
          <source>Client applications that handle server-side errors by parsing the text of the error message will obviously have problems when the server's messages are in a different language. Authors of such applications are advised to make use of the error code scheme instead.</source>
          <target state="translated">오류 메시지의 텍스트를 구문 분석하여 서버 측 오류를 처리하는 클라이언트 응용 프로그램은 서버의 메시지가 다른 언어 일 때 분명히 문제가 있습니다. 이러한 응용 프로그램의 작성자는 대신 오류 코드 체계를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7f62d9a1fbbb2ce2cddd029ed2fe28a281be2056" translate="yes" xml:space="preserve">
          <source>Client authentication for replication is controlled by a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field. For example, if the standby is running on host IP &lt;code&gt;192.168.1.100&lt;/code&gt; and the account name for replication is &lt;code&gt;foo&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file on the primary:</source>
          <target state="translated">복제를위한 클라이언트 인증 은 &lt;code&gt;database&lt;/code&gt; 필드 에서 &lt;code&gt;replication&lt;/code&gt; 를 지정 하는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 레코드에 의해 제어됩니다 . 예를 들어 대기가 호스트 IP &lt;code&gt;192.168.1.100&lt;/code&gt; 에서 실행 중이고 복제 계정 이름이 &lt;code&gt;foo&lt;/code&gt; 인 경우 관리자는 기본 행의 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일에 다음 줄을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc84a669a62f5ca232ebf922e0ad965b3deb7dd8" translate="yes" xml:space="preserve">
          <source>Client authentication is controlled by a configuration file, which traditionally is named &lt;code&gt;pg_hba.conf&lt;/code&gt; and is stored in the database cluster's data directory. (HBA stands for host-based authentication.) A default &lt;code&gt;pg_hba.conf&lt;/code&gt; file is installed when the data directory is initialized by &lt;code&gt;initdb&lt;/code&gt;. It is possible to place the authentication configuration file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-HBA-FILE&quot;&gt;hba_file&lt;/a&gt; configuration parameter.</source>
          <target state="translated">클라이언트 인증은 일반적으로 &lt;code&gt;pg_hba.conf&lt;/code&gt; 라는 구성 파일로 제어되며 데이터베이스 클러스터의 데이터 디렉토리에 저장됩니다. (HBA는 호스트 기반 인증을 나타냅니다.) 기본 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일은 데이터 디렉토리가 &lt;code&gt;initdb&lt;/code&gt; 에 의해 초기화 될 때 설치 됩니다 . 그러나 인증 구성 파일을 다른 곳에 배치 할 수도 있습니다. &lt;a href=&quot;runtime-config-file-locations#GUC-HBA-FILE&quot;&gt;hba_file&lt;/a&gt; 구성 매개 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="629b3a674ff2759a15234a0f27ca1c2b61f9c46a" translate="yes" xml:space="preserve">
          <source>Client principals can be mapped to different PostgreSQL database user names with &lt;code&gt;pg_ident.conf&lt;/code&gt;. For example, &lt;code&gt;pgusername@realm&lt;/code&gt; could be mapped to just &lt;code&gt;pgusername&lt;/code&gt;. Alternatively, you can use the full &lt;code&gt;username@realm&lt;/code&gt; principal as the role name in PostgreSQL without any mapping.</source>
          <target state="translated">클라이언트 주체는 &lt;code&gt;pg_ident.conf&lt;/code&gt; 를 사용하여 다른 PostgreSQL 데이터베이스 사용자 이름에 매핑 될 수 있습니다 . 예를 들어, &lt;code&gt;pgusername@realm&lt;/code&gt; 은 &lt;code&gt;pgusername&lt;/code&gt; 에만 매핑 될 수 있습니다 . 또는 &lt;code&gt;username@realm&lt;/code&gt; 주체를 매핑없이 PostgreSQL의 역할 이름으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5ce6d7e6024f003e8f14e4f587b6a6491740908" translate="yes" xml:space="preserve">
          <source>Client sends a SASLResponse message, with SCRAM &lt;code&gt;client-final-message&lt;/code&gt; as the content.</source>
          <target state="translated">클라이언트는 SCRAM &lt;code&gt;client-final-message&lt;/code&gt; 를 내용으로 사용하여 SASLResponse 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b8e10276e48f038db512681466dbafb12118bd5c" translate="yes" xml:space="preserve">
          <source>Client-Side Encryption</source>
          <target state="translated">클라이언트 측 암호화</target>
        </trans-unit>
        <trans-unit id="d51a6617646b13e732892d1749ba1e127309d447" translate="yes" xml:space="preserve">
          <source>Clock Hardware and Timing Accuracy</source>
          <target state="translated">클록 하드웨어 및 타이밍 정확도</target>
        </trans-unit>
        <trans-unit id="21a7e36482abe916e6a3c560955a0114009a4ca6" translate="yes" xml:space="preserve">
          <source>Clock-sweep access count</source>
          <target state="translated">클록 스윕 액세스 수</target>
        </trans-unit>
        <trans-unit id="81c141a1154555d95b94141dc24a19f7f8213aed" translate="yes" xml:space="preserve">
          <source>Close all open cursors.</source>
          <target state="translated">열린 커서를 모두 닫습니다.</target>
        </trans-unit>
        <trans-unit id="3d1b36aa8b5c70b44195178c220fe55db85afcb7" translate="yes" xml:space="preserve">
          <source>Close the cursor &lt;code&gt;liahona&lt;/code&gt;:</source>
          <target state="translated">커서 &lt;code&gt;liahona&lt;/code&gt; 를 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="84ce1963621c46f85aecb48b42fdae72b3b573d0" translate="yes" xml:space="preserve">
          <source>Closed path (similar to polygon)</source>
          <target state="translated">닫힌 경로 (다각형과 유사)</target>
        </trans-unit>
        <trans-unit id="6c6d23ffde231143c689d9a1a9d23c93cbcb98af" translate="yes" xml:space="preserve">
          <source>Closest point to first operand on second operand</source>
          <target state="translated">두 번째 피연산자의 첫 번째 피연산자에 가장 가까운 지점</target>
        </trans-unit>
        <trans-unit id="66b7e0ec8761e07b30c255551fcfb12a214a2e8c" translate="yes" xml:space="preserve">
          <source>Cluster &lt;code&gt;table&lt;/code&gt; only. Multiple tables can be clustered by writing multiple &lt;code&gt;-t&lt;/code&gt; switches.</source>
          <target state="translated">클러스터 &lt;code&gt;table&lt;/code&gt; 만. 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 클러스터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78cfb158c75c4cb2618febccbc1722937af9bc2b" translate="yes" xml:space="preserve">
          <source>Cluster all databases.</source>
          <target state="translated">모든 데이터베이스를 클러스터하십시오.</target>
        </trans-unit>
        <trans-unit id="e0943d95e87e6ca7c31ed73f1e9d681c6d1a8586" translate="yes" xml:space="preserve">
          <source>Cluster all tables in the database that have previously been clustered:</source>
          <target state="translated">이전에 클러스터 된 데이터베이스의 모든 테이블을 클러스터하십시오.</target>
        </trans-unit>
        <trans-unit id="ef48045cf823187e8b55ae44255dacd11f79eb82" translate="yes" xml:space="preserve">
          <source>Cluster the &lt;code&gt;employees&lt;/code&gt; table using the same index that was used before:</source>
          <target state="translated">이전에 사용 된 것과 동일한 인덱스를 사용하여 &lt;code&gt;employees&lt;/code&gt; 테이블을 클러스터하십시오 .</target>
        </trans-unit>
        <trans-unit id="be1f7ed6b59f3f6d3521c319a991c6f6e4456808" translate="yes" xml:space="preserve">
          <source>Cluster the table &lt;code&gt;employees&lt;/code&gt; on the basis of its index &lt;code&gt;employees_ind&lt;/code&gt;:</source>
          <target state="translated">인덱스 &lt;code&gt;employees_ind&lt;/code&gt; 기준으로 테이블 &lt;code&gt;employees&lt;/code&gt; 을 클러스터하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8fdb3b6f5d839e583d5c2ffab9262c8d2afb036" translate="yes" xml:space="preserve">
          <source>Cluster-wide data can be dumped alone using the pg_dumpall &lt;code&gt;--globals-only&lt;/code&gt; option. This is necessary to fully backup the cluster if running the pg_dump command on individual databases.</source>
          <target state="translated">pg_dumpall &lt;code&gt;--globals-only&lt;/code&gt; 옵션을 사용하여 클러스터 전체 데이터를 단독으로 덤프 할 수 있습니다 . 개별 데이터베이스에서 pg_dump 명령을 실행하는 경우 클러스터를 완전히 백업하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="c9488ec230a940ca27958b3358bb15e97a3ff0f7" translate="yes" xml:space="preserve">
          <source>Coerce the given value to text and then quote it as a literal. Embedded single-quotes and backslashes are properly doubled.</source>
          <target state="translated">주어진 값을 텍스트로 강제 변환 한 다음 리터럴로 인용하십시오. 포함 된 작은 따옴표 및 백 슬래시는 올바르게 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="12fd65533c35a7aa862d0ffcc3974cdde7cfcd86" translate="yes" xml:space="preserve">
          <source>Coerce the given value to text and then quote it as a literal; or, if the argument is null, return &lt;code&gt;NULL&lt;/code&gt;. Embedded single-quotes and backslashes are properly doubled.</source>
          <target state="translated">주어진 값을 텍스트로 강제 변환 한 다음 리터럴로 인용하십시오. 또는, 인수가 널 (null), 반환의 경우 &lt;code&gt;NULL&lt;/code&gt; 은 . 포함 된 작은 따옴표 및 백 슬래시는 올바르게 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="6f53e99e8baac8db604ea270dc09be0a2bfe89d5" translate="yes" xml:space="preserve">
          <source>Collation Support</source>
          <target state="translated">콜 레이션 지원</target>
        </trans-unit>
        <trans-unit id="cc0fb30413ed48243029d196a0e4276fcbf8bebd" translate="yes" xml:space="preserve">
          <source>Collation name (unique per namespace and encoding)</source>
          <target state="translated">데이터 정렬 이름 (네임 스페이스 및 인코딩마다 고유함)</target>
        </trans-unit>
        <trans-unit id="c0674c8e614f8ab3ac407aeb60841e6cf3375f17" translate="yes" xml:space="preserve">
          <source>Collation order (&lt;code&gt;LC_COLLATE&lt;/code&gt;) to use in the new database. This affects the sort order applied to strings, e.g. in queries with ORDER BY, as well as the order used in indexes on text columns. The default is to use the collation order of the template database. See below for additional restrictions.</source>
          <target state="translated">새 데이터베이스에서 사용할 데이터 정렬 순서 ( &lt;code&gt;LC_COLLATE&lt;/code&gt; ) 이는 문자열에 적용되는 정렬 순서 (예 : ORDER BY 쿼리) 및 텍스트 열의 인덱스에 사용 된 순서에 영향을줍니다. 기본값은 템플릿 데이터베이스의 데이터 정렬 순서를 사용하는 것입니다. 추가 제한 사항은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d3c380590b334bc9cfdd805604191d71f3646b" translate="yes" xml:space="preserve">
          <source>Collecting accurate timing information is normally done on computers using hardware clocks with various levels of accuracy. With some hardware the operating systems can pass the system clock time almost directly to programs. A system clock can also be derived from a chip that simply provides timing interrupts, periodic ticks at some known time interval. In either case, operating system kernels provide a clock source that hides these details. But the accuracy of that clock source and how quickly it can return results varies based on the underlying hardware.</source>
          <target state="translated">정확한 타이밍 정보 수집은 일반적으로 다양한 수준의 정확도를 가진 하드웨어 시계를 사용하는 컴퓨터에서 수행됩니다. 일부 하드웨어에서는 운영 체제가 시스템 클럭 시간을 거의 직접 프로그램으로 전달할 수 있습니다. 시스템 클록은 단순히 알려진 시간 간격으로 타이밍 인터럽트, 주기적 틱을 제공하는 칩에서 파생 될 수 있습니다. 두 경우 모두 운영 체제 커널은 이러한 세부 정보를 숨기는 클럭 소스를 제공합니다. 그러나 클럭 소스의 정확도와 결과를 얼마나 빨리 반환 할 수 있는지는 기본 하드웨어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1d793dfbef9f0a0e6127b407a9dbd1cb9cbbcf60" translate="yes" xml:space="preserve">
          <source>Color names can be replaced by their hexadecimal values, e.g., &lt;code&gt;red, green, blue, magenta -&amp;gt; FF0000, 00FF00, 0000FF, FF00FF&lt;/code&gt;</source>
          <target state="translated">색상 이름은 16 진수 값 (예 : &lt;code&gt;red, green, blue, magenta -&amp;gt; FF0000, 00FF00, 0000FF, FF00FF&lt;/code&gt; 으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="1439028f17fc21ee7e56500963ffcc43d546167f" translate="yes" xml:space="preserve">
          <source>Column &lt;code&gt;STORAGE&lt;/code&gt; settings are also copied from parent tables.</source>
          <target state="translated">열 &lt;code&gt;STORAGE&lt;/code&gt; 설정도 상위 테이블에서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="289cfdd6222b45e607a45739197e47437dd847a8" translate="yes" xml:space="preserve">
          <source>Column Check Constraints</source>
          <target state="translated">열 검사 제약</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="5082f7083ababbc77bb979626c5aac6366817ae3" translate="yes" xml:space="preserve">
          <source>Column data values of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not store any data values. Each array's element values are actually of the specific column's data type, or a related type such as an array's element type, so there is no way to define these columns' type more specifically than &lt;code&gt;anyarray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 적절한 종류의 열 데이터 값 이거나 슬롯 종류에 데이터 값이 저장되지 않은 경우 null입니다. 각 배열의 요소 값은 실제로 특정 열의 데이터 유형 또는 배열의 요소 유형과 같은 관련 유형이므로 &lt;code&gt;anyarray&lt;/code&gt; 보다 이러한 열의 유형을 더 구체적으로 정의 할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3452ec634a556f5804e69085fd6039486777070d" translate="yes" xml:space="preserve">
          <source>Column number targeted by the lock (the &lt;code&gt;classid&lt;/code&gt; and &lt;code&gt;objid&lt;/code&gt; refer to the table itself), or zero if the target is some other general database object, or null if the target is not a general database object</source>
          <target state="translated">잠금이 대상으로하는 열 번호 ( &lt;code&gt;classid&lt;/code&gt; 및 &lt;code&gt;objid&lt;/code&gt; 는 테이블 자체를 참조 함) 또는 대상이 다른 일반 데이터베이스 객체 인 경우 0 또는 대상이 일반 데이터베이스 객체가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="c02b6a156f26f9570640cefebee04ceb3c4781f0" translate="yes" xml:space="preserve">
          <source>Column numbers, if trigger is column-specific; otherwise an empty array</source>
          <target state="translated">트리거가 열 특정인 경우 열 번호. 그렇지 않으면 빈 배열</target>
        </trans-unit>
        <trans-unit id="4f5840e9e9eef85bc5eff199eb5320f4319160ea" translate="yes" xml:space="preserve">
          <source>Column-level access privileges, if any have been granted specifically on this column</source>
          <target state="translated">이 열에 특별히 부여 된 열 수준 액세스 권한</target>
        </trans-unit>
        <trans-unit id="37600cd17920781a24b5b7e102123d5dd57326b1" translate="yes" xml:space="preserve">
          <source>Column-level permissions will also be checked for each referenced column. &lt;code&gt;db_column:select&lt;/code&gt; is checked on not only the columns being read using &lt;code&gt;SELECT&lt;/code&gt;, but those being referenced in other DML statements; &lt;code&gt;db_column:update&lt;/code&gt; or &lt;code&gt;db_column:insert&lt;/code&gt; will also be checked for columns being modified by &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">참조 된 각 열에 대한 열 수준 권한도 확인됩니다. &lt;code&gt;db_column:select&lt;/code&gt; 는 &lt;code&gt;SELECT&lt;/code&gt; 를 사용하여 읽은 열 뿐만 아니라 다른 DML 문에서 참조되는 열에 대해 검사됩니다 . &lt;code&gt;db_column:update&lt;/code&gt; 또는 &lt;code&gt;db_column:insert&lt;/code&gt; 는 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 에 의해 수정되는 열도 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="ee56bbceca154f2098f19f6e8e425a6491c6cee7" translate="yes" xml:space="preserve">
          <source>Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause don't need appropriate operator classes; the clause can include columns whose data types don't have operator classes defined for a given access method.</source>
          <target state="translated">&lt;code&gt;INCLUDE&lt;/code&gt; 절에 나열된 열에 는 적절한 연산자 클래스가 필요하지 않습니다. 이 절에는 데이터 유형에 지정된 액세스 방법에 대해 정의 된 연산자 클래스가없는 열이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16a5643d1f00b1978a8c620cd41de3d0bb8524e" translate="yes" xml:space="preserve">
          <source>Columns may be marked &lt;code&gt;NOT NULL&lt;/code&gt;. If the &lt;code&gt;column_expression&lt;/code&gt; for a &lt;code&gt;NOT NULL&lt;/code&gt; column does not match anything and there is no &lt;code&gt;DEFAULT&lt;/code&gt; or the &lt;code&gt;default_expression&lt;/code&gt; also evaluates to null, an error is reported.</source>
          <target state="translated">열은 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시 될 수 있습니다 . 는 IF &lt;code&gt;column_expression&lt;/code&gt; A에 대한 &lt;code&gt;NOT NULL&lt;/code&gt; 열 아무것도 일치하지 않는 거기에는 없다 &lt;code&gt;DEFAULT&lt;/code&gt; 가 또는 &lt;code&gt;default_expression&lt;/code&gt; 는 또한 널 (null)로 평가 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8722c83ccb79b0cdcd5f2ed4e7529f7bf85136b9" translate="yes" xml:space="preserve">
          <source>Columns of a table are also matched by name. The order of columns in the subscriber table does not need to match that of the publisher. The data types of the columns do not need to match, as long as the text representation of the data can be converted to the target type. For example, you can replicate from a column of type &lt;code&gt;integer&lt;/code&gt; to a column of type &lt;code&gt;bigint&lt;/code&gt;. The target table can also have additional columns not provided by the published table. Any such columns will be filled with the default value as specified in the definition of the target table.</source>
          <target state="translated">테이블의 열도 이름과 일치합니다. 구독자 테이블의 열 순서는 게시자의 열 순서와 일치하지 않아도됩니다. 데이터의 텍스트 표현이 대상 유형으로 변환 될 수있는 한 열의 데이터 유형이 일치하지 않아도됩니다. 예를 들어, &lt;code&gt;integer&lt;/code&gt; 유형 의 열에서 &lt;code&gt;bigint&lt;/code&gt; 유형의 열로 복제 할 수 있습니다 . 대상 테이블에는 게시 된 테이블에서 제공하지 않은 추가 열이있을 수도 있습니다. 이러한 컬럼은 목표 테이블의 정의에 지정된대로 기본값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f6722930440001f207cb71c029960e6823ed128c" translate="yes" xml:space="preserve">
          <source>Columns that have been dropped from the table also contribute to the maximum column limit. Moreover, although the dropped column values for newly created tuples are internally marked as null in the tuple's null bitmap, the null bitmap also occupies space.</source>
          <target state="translated">테이블에서 삭제 된 열도 최대 열 제한에 영향을줍니다. 또한 새로 생성 된 튜플에 대해 삭제 된 열 값이 튜플의 null 비트 맵에서 내부적으로 null로 표시되지만 null 비트 맵도 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="7b9695a881e079b5e76a032197eee89f340ed0b0" translate="yes" xml:space="preserve">
          <source>Columns used to form &amp;ldquo;replica identity&amp;rdquo; for rows: &lt;code&gt;d&lt;/code&gt; = default (primary key, if any), &lt;code&gt;n&lt;/code&gt; = nothing, &lt;code&gt;f&lt;/code&gt; = all columns &lt;code&gt;i&lt;/code&gt; = index with &lt;code&gt;indisreplident&lt;/code&gt; set, or default</source>
          <target state="translated">행에 대한 &quot;복제본 ID&quot;를 형성하는 데 사용되는 열 : &lt;code&gt;d&lt;/code&gt; = 기본값 (기본 키,있는 경우), &lt;code&gt;n&lt;/code&gt; = 없음, &lt;code&gt;f&lt;/code&gt; = 모든 열 &lt;code&gt;i&lt;/code&gt; = &lt;code&gt;indisreplident&lt;/code&gt; 세트가있는 인덱스 또는 기본값</target>
        </trans-unit>
        <trans-unit id="ecf4938c09b7baa93df6f51766d4b9568ff8b87e" translate="yes" xml:space="preserve">
          <source>Combine function (zero if none)</source>
          <target state="translated">결합 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="b2934e3c1cc659ddbafc11f39d4747e931c97bf5" translate="yes" xml:space="preserve">
          <source>Combines both of the above options.</source>
          <target state="translated">위 옵션 모두를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="9b8c6c21748f6385c19086f65218b6f955d17f46" translate="yes" xml:space="preserve">
          <source>Combining Multiple Indexes</source>
          <target state="translated">여러 인덱스 결합</target>
        </trans-unit>
        <trans-unit id="7ed5f1795200b9a5f27686390337eb73996c75b4" translate="yes" xml:space="preserve">
          <source>Combining Queries</source>
          <target state="translated">쿼리 결합</target>
        </trans-unit>
        <trans-unit id="7d744180e2b1652f30d0b01c3ec0dffd855d81d8" translate="yes" xml:space="preserve">
          <source>Combining Queries: EXCEPT</source>
          <target state="translated">쿼리 결합 : EXCEPT</target>
        </trans-unit>
        <trans-unit id="1962bff7a417b581598656f48af3e5258db60ea1" translate="yes" xml:space="preserve">
          <source>Combining Queries: INTERSECT</source>
          <target state="translated">검색어 결합 : INTERSECT</target>
        </trans-unit>
        <trans-unit id="6cf590965ba1f9879168440f1f27eb1bd0bda058" translate="yes" xml:space="preserve">
          <source>Combining Queries: UNION</source>
          <target state="translated">쿼리 결합 : UNION</target>
        </trans-unit>
        <trans-unit id="ca19eaee08702deeaef3602966f0b70fca762ada" translate="yes" xml:space="preserve">
          <source>Comma Separated Values</source>
          <target state="translated">쉼표로 구분 된 값</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="174a63a1205957f0771a13a913b2ad84bd765510" translate="yes" xml:space="preserve">
          <source>Command executed by the &lt;code&gt;\!&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;\!&lt;/code&gt; 명령으로 실행 명령.</target>
        </trans-unit>
        <trans-unit id="278ac1cdf2ca6ded3a4a528bee443fbc9fd5a344" translate="yes" xml:space="preserve">
          <source>Command identifiers are also 32-bit quantities. This creates a hard limit of 2&lt;sup&gt;32&lt;/sup&gt; (4 billion) SQL commands within a single transaction. In practice this limit is not a problem &amp;mdash; note that the limit is on the number of SQL commands, not the number of rows processed. Also, only commands that actually modify the database contents will consume a command identifier.</source>
          <target state="translated">명령 식별자도 32 비트입니다. 이는 단일 트랜잭션 내에서 2 &lt;sup&gt;32&lt;/sup&gt; (40 억) SQL 명령 의 하드 한계를 만듭니다 . 실제로이 한계는 문제가되지 않습니다. 한계는 처리 된 행 수가 아니라 SQL 명령의 수에 있습니다. 또한 실제로 데이터베이스 내용을 수정하는 명령 만 명령 식별자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c4b8fd91008dbf8bd6354ca2c271fc25998dcdb" translate="yes" xml:space="preserve">
          <source>Command tag: type of session's current command</source>
          <target state="translated">명령 태그 : 세션의 현재 명령 유형</target>
        </trans-unit>
        <trans-unit id="232187997abcc8c310be15f9e2b1664cf9978b9d" translate="yes" xml:space="preserve">
          <source>Command tags for which this trigger will fire. If NULL, the firing of this trigger is not restricted on the basis of the command tag.</source>
          <target state="translated">이 트리거가 실행될 명령 태그. NULL 인 경우이 트리거의 실행은 명령 태그를 기반으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b25e5fb9a11f166615d93fcb65262b0c87f57e44" translate="yes" xml:space="preserve">
          <source>Command-Line Editing</source>
          <target state="translated">명령 줄 편집</target>
        </trans-unit>
        <trans-unit id="6158b615b8c54dc251e1ffff571847cadca842cf" translate="yes" xml:space="preserve">
          <source>CommandId</source>
          <target state="translated">CommandId</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="95cb369a2c1ae6926c27cd5f5544f941b4636eab" translate="yes" xml:space="preserve">
          <source>Commas (&lt;code&gt;,&lt;/code&gt;) are used in some syntactical constructs to separate the elements of a list.</source>
          <target state="translated">쉼표 ( &lt;code&gt;,&lt;/code&gt; )리스트의 요소를 분리하기 위해 일부 구문 구조에 사용된다.</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="a3bfde75e2fe305108416a7acb2609c34a1a5994" translate="yes" xml:space="preserve">
          <source>Comment string from the extension's control file</source>
          <target state="translated">확장 프로그램 제어 파일의 주석 문자열</target>
        </trans-unit>
        <trans-unit id="5b50e65179e9dde82ce934eff47ec7882e869f4f" translate="yes" xml:space="preserve">
          <source>Comments and whitespace are handled in the same way as in &lt;code&gt;pg_hba.conf&lt;/code&gt;. The &lt;code&gt;map-name&lt;/code&gt; is an arbitrary name that will be used to refer to this mapping in &lt;code&gt;pg_hba.conf&lt;/code&gt;. The other two fields specify an operating system user name and a matching database user name. The same &lt;code&gt;map-name&lt;/code&gt; can be used repeatedly to specify multiple user-mappings within a single map.</source>
          <target state="translated">주석과 공백은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 와 같은 방식으로 처리됩니다 . &lt;code&gt;map-name&lt;/code&gt; 이 매핑을 참조하는 데 사용되는 임의의 이름입니다 &lt;code&gt;pg_hba.conf&lt;/code&gt; . 다른 두 필드는 운영 체제 사용자 이름과 일치하는 데이터베이스 사용자 이름을 지정합니다. 동일한 &lt;code&gt;map-name&lt;/code&gt; 을 반복해서 사용하여 단일 맵 내에서 여러 사용자 매핑을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44a6fd86d069c0f83a2af7714ff0672a07e9a12b" translate="yes" xml:space="preserve">
          <source>Comments are preceded by &lt;code&gt;#&lt;/code&gt;, and must be on their own lines.</source>
          <target state="translated">주석 앞에는 &lt;code&gt;#&lt;/code&gt; 이 있으며 고유 한 행에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ea98a71022b615fabbb92e9b911e7731dde6a5f" translate="yes" xml:space="preserve">
          <source>Comments can be viewed using psql's &lt;code&gt;\d&lt;/code&gt; family of commands. Other user interfaces to retrieve comments can be built atop the same built-in functions that psql uses, namely &lt;code&gt;obj_description&lt;/code&gt;, &lt;code&gt;col_description&lt;/code&gt;, and &lt;code&gt;shobj_description&lt;/code&gt; (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt;).</source>
          <target state="translated">주석은 psql의 &lt;code&gt;\d&lt;/code&gt; 명령 계열을 사용하여 볼 수 있습니다 . 주석을 검색하기위한 다른 사용자 인터페이스는 psql이 사용하는 동일한 내장 함수, 즉 &lt;code&gt;obj_description&lt;/code&gt; , &lt;code&gt;col_description&lt;/code&gt; 및 &lt;code&gt;shobj_description&lt;/code&gt; 위에 구축 될 수 있습니다 ( &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;표 9.73&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5b2ac1534bc179931f5fa20ea8355d274f0ee844" translate="yes" xml:space="preserve">
          <source>Comments for the copied columns, constraints, and indexes will be copied. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments.</source>
          <target state="translated">복사 된 열, 제약 조건 및 인덱스에 대한 주석이 복사됩니다. 기본 동작은 주석을 제외하여 주석이없는 새 테이블에서 복사 된 열과 제약 조건을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a778236e17d9f01dae405aa74899721aa2f09ca" translate="yes" xml:space="preserve">
          <source>Commercial Solutions</source>
          <target state="translated">상업용 솔루션</target>
        </trans-unit>
        <trans-unit id="b8b8cad039eea4bbd93fe4a7569bc664e95f71b6" translate="yes" xml:space="preserve">
          <source>Commit the transaction identified by the transaction identifier &lt;code&gt;foobar&lt;/code&gt;:</source>
          <target state="translated">트랜잭션 식별자 &lt;code&gt;foobar&lt;/code&gt; 로 식별 된 트랜잭션을 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="f6eaa962650a97f840a2800c301825ed8d72a917" translate="yes" xml:space="preserve">
          <source>Common Options</source>
          <target state="translated">공통 옵션</target>
        </trans-unit>
        <trans-unit id="cf6f857064f7e69451a2963d2cda7e8c356ef71d" translate="yes" xml:space="preserve">
          <source>Common Table Expression</source>
          <target state="translated">공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="253e2f931e23b5f531559b7abd6d31539e0a117a" translate="yes" xml:space="preserve">
          <source>Common Vulnerabilities and Exposures</source>
          <target state="translated">일반적인 취약점 및 노출</target>
        </trans-unit>
        <trans-unit id="64c95e8ab21e68bee3d8dd4d244de519744fccc7" translate="yes" xml:space="preserve">
          <source>Communication method</source>
          <target state="translated">통신 방법</target>
        </trans-unit>
        <trans-unit id="2e5e3073095fe271a2d9297b034a848894250b4f" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;%&lt;/code&gt; 연산자의 정류자 .</target>
        </trans-unit>
        <trans-unit id="8b0f8d58d1c77eb764351a0b6f87f69add89f9d1" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; 연산자의 정류자 .</target>
        </trans-unit>
        <trans-unit id="6d875e8a794fe250e3d0d7dbbc5344c5b94699c0" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; 연산자 의 정류자 .</target>
        </trans-unit>
        <trans-unit id="1b3622e2ac284bfb523ad8fc2abbc031eb2a62d8" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; 연산자 의 정류자 .</target>
        </trans-unit>
        <trans-unit id="8f95659e3581f0b29bdb3913745fcf1dd53b5995" translate="yes" xml:space="preserve">
          <source>Commutator of this operator, if any</source>
          <target state="translated">이 연산자의 정류자 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="d124776efdf568a154cc960bb025e2ef08d7a89e" translate="yes" xml:space="preserve">
          <source>Compare a partial-match query key to an index key. Returns an integer whose sign indicates the result: less than zero means the index key does not match the query, but the index scan should continue; zero means that the index key does match the query; greater than zero indicates that the index scan should stop because no more matches are possible. The strategy number &lt;code&gt;n&lt;/code&gt; of the operator that generated the partial match query is provided, in case its semantics are needed to determine when to end the scan. Also, &lt;code&gt;extra_data&lt;/code&gt; is the corresponding element of the extra-data array made by &lt;code&gt;extractQuery&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none. Null keys are never passed to this function.</source>
          <target state="translated">부분 일치 쿼리 키와 인덱스 키를 비교하십시오. 부호가 결과를 나타내는 정수를 리턴합니다. 0보다 작 으면 인덱스 키가 쿼리와 일치하지 않지만 인덱스 스캔은 계속되어야 함을 의미합니다. 0은 인덱스 키가 쿼리와 일치 함을 의미합니다. 0보다 크면 일치하는 항목이 더 이상 없기 때문에 인덱스 스캔을 중지해야 함을 나타냅니다. 스캔을 종료 할시기를 결정하기 위해 의미가 필요한 경우 부분 일치 쿼리를 생성 한 연산자 의 전략 번호 &lt;code&gt;n&lt;/code&gt; 이 제공됩니다. 또한 &lt;code&gt;extra_data&lt;/code&gt; 는 해당 의해 여분의 데이터 어레이의 요소 &lt;code&gt;extractQuery&lt;/code&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; 없음 경우. 널 키는이 기능으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42cdd4afb9c4a9955f909a36e78ad45ab07bdac5" translate="yes" xml:space="preserve">
          <source>Compared to functional dependencies, MCV lists have two major advantages. Firstly, the list stores actual values, making it possible to decide which combinations are compatible.</source>
          <target state="translated">기능적 종속성과 비교하여 MCV 목록에는 두 가지 주요 이점이 있습니다. 첫째, 목록에는 실제 값이 저장되어 호환 가능한 조합을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04f64ce8bc8a69b417a8a154b465629b1da24aa9" translate="yes" xml:space="preserve">
          <source>Compares two keys (not indexed items!) and returns an integer less than zero, zero, or greater than zero, indicating whether the first key is less than, equal to, or greater than the second. Null keys are never passed to this function.</source>
          <target state="translated">두 개의 키 (인덱싱 된 항목 아님)를 비교하고 0보다 작은 정수, 0보다 큰 정수 또는 0보다 큰 정수를 반환하여 첫 번째 키가 두 번째보다 작거나 같거나 큰지 여부를 나타냅니다. 널 키는이 기능으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="144fad6e22d897b3948d3102d3a4ee6f98b4f0f3" translate="yes" xml:space="preserve">
          <source>Comparing two floating-point values for equality might not always work as expected.</source>
          <target state="translated">두 부동 소수점 값이 동일한 지 비교하면 항상 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82668afbd9ca9905b48bc0534a51ab3d6f379746" translate="yes" xml:space="preserve">
          <source>Comparison of Different Solutions</source>
          <target state="translated">다른 솔루션의 비교</target>
        </trans-unit>
        <trans-unit id="688d1dd068f557e23c1811d137fa9d0ee7984602" translate="yes" xml:space="preserve">
          <source>Comparison of crypt-des, crypt-md5 and bcrypt algorithms.</source>
          <target state="translated">crypt-des, crypt-md5 및 bcrypt 알고리즘 비교</target>
        </trans-unit>
        <trans-unit id="3973aa07a4403e385cc1e99e69e0be49b6cc3b61" translate="yes" xml:space="preserve">
          <source>Comparison operators are available for all relevant data types. All comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;; expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;).</source>
          <target state="translated">모든 관련 데이터 유형에 대해 비교 연산자를 사용할 수 있습니다. 모든 비교 연산자는 &lt;code&gt;boolean&lt;/code&gt; 형식의 값을 반환하는 이진 연산자입니다 . &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; 과 같은 표현식 은 유효하지 않습니다 ( 부울 값을 &lt;code&gt;3&lt;/code&gt; 과 비교할 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 없기 때문에 ).</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="9021a3ffbf0cdb7258143f75a75a99fb3bbf436c" translate="yes" xml:space="preserve">
          <source>Comparisons involving an added enum value will sometimes be slower than comparisons involving only original members of the enum type. This will usually only occur if &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; is used to set the new value's sort position somewhere other than at the end of the list. However, sometimes it will happen even though the new value is added at the end (this occurs if the OID counter &amp;ldquo;wrapped around&amp;rdquo; since the original creation of the enum type). The slowdown is usually insignificant; but if it matters, optimal performance can be regained by dropping and recreating the enum type, or by dumping and reloading the database.</source>
          <target state="translated">열거 형 값이 추가 된 비교는 때때로 열거 형의 원래 멤버 만 포함하는 비교보다 느립니다. 이는 일반적으로 &lt;code&gt;BEFORE&lt;/code&gt; 또는 &lt;code&gt;AFTER&lt;/code&gt; 를 사용하여 새 값의 정렬 위치를 목록의 끝이 아닌 다른 위치에 설정하는 경우에만 발생 합니다. 그러나 때때로 새로운 값이 끝에 추가 되더라도 발생할 수 있습니다 (이는 enum 유형의 원래 생성 이후 OID 카운터가 &quot;랩핑 된&quot;경우 발생합니다). 둔화는 일반적으로 중요하지 않습니다. 그러나 중요한 경우 열거 형 유형을 삭제하고 다시 만들거나 데이터베이스를 덤프 및 다시로드하여 최적의 성능을 다시 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72f70a808fb8dff833a9ba6a1ec891ad79c91ddf" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;gt;</source>
          <target state="translated">비교 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5fd0bc4fc993999d06759d89da7ccf387529bff" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;gt;=</source>
          <target state="translated">비교 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="6fe80c71e2e7d878eb87f66fd7e56b66f7e76985" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;</source>
          <target state="translated">비교 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ceb484cdd06746bf898467c23e5bc8299bec7c13" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;&amp;gt;</source>
          <target state="translated">비교 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0e016e19c1413324801b9522ced74a81a4c2e94d" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;=</source>
          <target state="translated">비교 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8dde29d89f59d19ce1b51c0d2e2e2bed0dee7065" translate="yes" xml:space="preserve">
          <source>Comparisons: =</source>
          <target state="translated">비교 : =</target>
        </trans-unit>
        <trans-unit id="ee5183de6e4bf275c384cea74c0400b55b746d02" translate="yes" xml:space="preserve">
          <source>Comparisons: BETWEEN</source>
          <target state="translated">비교 : BETWEEN</target>
        </trans-unit>
        <trans-unit id="aa67bacfe69a4a17e45b3d66f8f7996bc796594e" translate="yes" xml:space="preserve">
          <source>Comparisons: BETWEEN SYMMETRIC</source>
          <target state="translated">비교 : SYMMETRIC 간</target>
        </trans-unit>
        <trans-unit id="9b896fc3b06e75ccc1a09e2c9a1969d831a2d16e" translate="yes" xml:space="preserve">
          <source>Comparisons: IS DISTINCT FROM</source>
          <target state="translated">비교 : IS DISTINCT FROM</target>
        </trans-unit>
        <trans-unit id="1c79549f9e78b7beb0454a7e7d27503fd85db6ca" translate="yes" xml:space="preserve">
          <source>Comparisons: IS FALSE</source>
          <target state="translated">비교 : 거짓</target>
        </trans-unit>
        <trans-unit id="6062f3bde8f951e2d9b36c1332df7954220f7d2d" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT DISTINCT FROM</source>
          <target state="translated">비교 : 구별되지 않음</target>
        </trans-unit>
        <trans-unit id="a3a4a8777a6e8acb75d32d5cbcc1ebf8f4ee8e2b" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT FALSE</source>
          <target state="translated">비교 : 거짓이 아님</target>
        </trans-unit>
        <trans-unit id="1d15c7ea99bc16b6d7b497d14960efd81e844616" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT NULL</source>
          <target state="translated">비교 : IS NOT NULL</target>
        </trans-unit>
        <trans-unit id="d52c743eb62fbb4089e38c3bcc8ac850978f5e47" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT TRUE</source>
          <target state="translated">비교 : 사실이 아님</target>
        </trans-unit>
        <trans-unit id="d22d0b9103ac49f59b0ca02492f5189321fda490" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT UNKNOWN</source>
          <target state="translated">비교 : 알 수 없음</target>
        </trans-unit>
        <trans-unit id="9e2c3021a351b272eb8a97d468495e36ba1772c6" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NULL</source>
          <target state="translated">비교 : IS NULL</target>
        </trans-unit>
        <trans-unit id="f122aa342eb5b2de82a09c639872b8b9c03bb8a1" translate="yes" xml:space="preserve">
          <source>Comparisons: IS TRUE</source>
          <target state="translated">비교 : TRUE</target>
        </trans-unit>
        <trans-unit id="8dd19d79d059f22e6e7d35c01a28407439729301" translate="yes" xml:space="preserve">
          <source>Comparisons: IS UNKNOWN</source>
          <target state="translated">비교 : 알 수 없음</target>
        </trans-unit>
        <trans-unit id="431a3c5547cbf4fd11195bcf71b983e89940803d" translate="yes" xml:space="preserve">
          <source>Comparisons: ISNULL</source>
          <target state="translated">비교 : ISNULL</target>
        </trans-unit>
        <trans-unit id="cd0c06292093ac5d89114d79d296c85753ff7359" translate="yes" xml:space="preserve">
          <source>Comparisons: NOT BETWEEN</source>
          <target state="translated">비교 :하지 않음</target>
        </trans-unit>
        <trans-unit id="bd2796acf9e88836f98b26163186dc5132a135c1" translate="yes" xml:space="preserve">
          <source>Comparisons: NOT BETWEEN SYMMETRIC</source>
          <target state="translated">비교 : SYMMETRIC이 아닌</target>
        </trans-unit>
        <trans-unit id="406e730102d9cc93be2f47c3ba43a6e7f1a96dc9" translate="yes" xml:space="preserve">
          <source>Comparisons: NOTNULL</source>
          <target state="translated">비교 : NOTNULL</target>
        </trans-unit>
        <trans-unit id="f339b211417b72bf5bcc21878fc8760d864e1c8c" translate="yes" xml:space="preserve">
          <source>Comparisons: num_nonnulls</source>
          <target state="translated">비교 : num_nonnulls</target>
        </trans-unit>
        <trans-unit id="db31a1ea15667990f06c57c4970da4626506bd51" translate="yes" xml:space="preserve">
          <source>Comparisons: num_nulls</source>
          <target state="translated">비교 : num_nulls</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="3fcce917a99aa1e0b998f0b229bc0ee92255056a" translate="yes" xml:space="preserve">
          <source>Complex queries can involve many levels of plan nodes, but the general approach is the same: each node computes and returns its next output row each time it is called. Each node is also responsible for applying any selection or projection expressions that were assigned to it by the planner.</source>
          <target state="translated">복잡한 쿼리에는 여러 수준의 계획 노드가 포함될 수 있지만 일반적인 접근 방식은 동일합니다. 각 노드는 호출 될 때마다 다음 출력 행을 계산하고 반환합니다. 각 노드는 또한 플래너가 할당 한 선택 또는 프로젝션 표현식을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">복합 유형</target>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="translated">복합 유형</target>
        </trans-unit>
        <trans-unit id="66c4e897db42f9c56916e2de56c4ee7bced3dac9" translate="yes" xml:space="preserve">
          <source>Comprehensive Perl Archive Network</source>
          <target state="translated">포괄적 인 Perl 아카이브 네트워크</target>
        </trans-unit>
        <trans-unit id="27b6dd31d02e8ac5ef9c53dc3256e339965c8ec4" translate="yes" xml:space="preserve">
          <source>Compute the index access cost. A generic estimator might do this:</source>
          <target state="translated">인덱스 액세스 비용을 계산하십시오. 일반 추정기는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a1dbf33bf0e4db3b6761dbfa9a781b01604c7" translate="yes" xml:space="preserve">
          <source>Computes a binary hash of the given &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; is the algorithm to use. Standard algorithms are &lt;code&gt;md5&lt;/code&gt;, &lt;code&gt;sha1&lt;/code&gt;, &lt;code&gt;sha224&lt;/code&gt;, &lt;code&gt;sha256&lt;/code&gt;, &lt;code&gt;sha384&lt;/code&gt; and &lt;code&gt;sha512&lt;/code&gt;. If &lt;code&gt;pgcrypto&lt;/code&gt; was built with OpenSSL, more algorithms are available, as detailed in &lt;a href=&quot;pgcrypto#PGCRYPTO-WITH-WITHOUT-OPENSSL&quot;&gt;Table F.19&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 의 이진 해시를 계산합니다 . &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 사용할 알고리즘입니다. 표준 알고리즘은 &lt;code&gt;md5&lt;/code&gt; , &lt;code&gt;sha1&lt;/code&gt; , &lt;code&gt;sha224&lt;/code&gt; , &lt;code&gt;sha256&lt;/code&gt; , &lt;code&gt;sha384&lt;/code&gt; 및 &lt;code&gt;sha512&lt;/code&gt; 입니다. &lt;code&gt;pgcrypto&lt;/code&gt; 가 OpenSSL로 구축 된 경우 &lt;a href=&quot;pgcrypto#PGCRYPTO-WITH-WITHOUT-OPENSSL&quot;&gt;표 F.19에&lt;/a&gt; 자세히 설명 된대로 더 많은 알고리즘을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b403ea8b697b5a1271920418a675e0c16387e926" translate="yes" xml:space="preserve">
          <source>Computing time</source>
          <target state="translated">컴퓨팅 시간</target>
        </trans-unit>
        <trans-unit id="aadb86cad4563bf048f76bee72cc413d9670abc2" translate="yes" xml:space="preserve">
          <source>Concatenate all but the first argument with separators. The first argument is used as the separator string. NULL arguments are ignored.</source>
          <target state="translated">첫 번째 인수를 제외한 모든 인수를 분리 자로 연결하십시오. 첫 번째 인수는 구분 기호 문자열로 사용됩니다. NULL 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="10f9586f627cdbf27c6e355d31387bbf162dfdb1" translate="yes" xml:space="preserve">
          <source>Concatenate the text representations of all the arguments. NULL arguments are ignored.</source>
          <target state="translated">모든 인수의 텍스트 표현을 연결하십시오. NULL 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3d0c23ffb9fdb22ea46ba55d20510d1de197e6" translate="yes" xml:space="preserve">
          <source>Concatenate two &lt;code&gt;jsonb&lt;/code&gt; values into a new &lt;code&gt;jsonb&lt;/code&gt; value</source>
          <target state="translated">연결할 두 &lt;code&gt;jsonb&lt;/code&gt; 의 새로운 값으로 &lt;code&gt;jsonb&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="0fc858f9117ebe86d3894371f4487964bd12946e" translate="yes" xml:space="preserve">
          <source>Conceptually, every expression of a collatable data type has a collation. (The built-in collatable data types are &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt;. User-defined base types can also be marked collatable, and of course a domain over a collatable data type is collatable.) If the expression is a column reference, the collation of the expression is the defined collation of the column. If the expression is a constant, the collation is the default collation of the data type of the constant. The collation of a more complex expression is derived from the collations of its inputs, as described below.</source>
          <target state="translated">개념적으로, 배열 가능한 데이터 유형의 모든 표현식에는 데이터 정렬이 있습니다. 기본 제공 collatable 데이터 유형은 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 입니다. 사용자 정의 기본 유형도 collatable로 표시 할 수 있으며 물론 collatable 데이터 유형의 도메인도 collatable 가능합니다. 표현식이 열 참조 인 경우 식의 데이터 정렬은 열의 정의 된 데이터 정렬입니다. 표현식이 상수 인 경우 데이터 정렬은 상수 데이터 유형의 기본 데이터 정렬입니다. 보다 복잡한 식의 데이터 정렬은 아래 설명과 같이 해당 입력의 데이터 정렬에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="7f315b1389481e62a5048c7274c93f74a68c1f7c" translate="yes" xml:space="preserve">
          <source>Conclusion? It is nice to have a special data type that can record the limits of an interval with arbitrarily variable precision. Variable in the sense that each data element records its own precision.</source>
          <target state="translated">결론? 임의의 가변 정밀도로 구간의 한계를 기록 할 수있는 특수 데이터 유형을 갖는 것이 좋습니다. 각 데이터 요소가 자체 정밀도를 기록한다는 점에서 변수입니다.</target>
        </trans-unit>
        <trans-unit id="6297e1cbe3d6a0c06891acd5c8af4d127c0d1132" translate="yes" xml:space="preserve">
          <source>Concurrency Control</source>
          <target state="translated">동시성 제어</target>
        </trans-unit>
        <trans-unit id="bd13301a59c28852e4300d37d71af83b51e78423" translate="yes" xml:space="preserve">
          <source>Concurrent builds for indexes on partitioned tables are currently not supported. However, you may concurrently build the index on each partition individually and then finally create the partitioned index non-concurrently in order to reduce the time where writes to the partitioned table will be locked out. In this case, building the partitioned index is a metadata only operation.</source>
          <target state="translated">파티션 된 테이블의 인덱스에 대한 동시 빌드는 현재 지원되지 않습니다. 그러나 파티션 된 테이블에 대한 쓰기가 잠기는 시간을 줄이기 위해 각 파티션에서 개별적으로 인덱스를 동시에 빌드 한 다음 파티션되지 않은 인덱스를 동시에 생성 할 수 있습니다. 이 경우 파티션 된 인덱스 작성은 메타 데이터 전용 작업입니다.</target>
        </trans-unit>
        <trans-unit id="963a572c795297d4b531f2d8dc46d16e80d45499" translate="yes" xml:space="preserve">
          <source>Concurrent builds of expression indexes and partial indexes are supported. Errors occurring in the evaluation of these expressions could cause behavior similar to that described above for unique constraint violations.</source>
          <target state="translated">식 인덱스와 부분 인덱스의 동시 빌드가 지원됩니다. 이러한 표현식의 평가에서 발생하는 오류는 고유 제한 조건 위반에 대해 위에서 설명한 것과 유사한 동작을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e305b80ad043f3938d2064507fd1c4224e23df3" translate="yes" xml:space="preserve">
          <source>Condition Name</source>
          <target state="translated">조건 이름</target>
        </trans-unit>
        <trans-unit id="8a0d63179619b501ad5800876cf0df368b27a390" translate="yes" xml:space="preserve">
          <source>Conditional Expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="96981fb7d354d12e3362c85d68207f4e2f0838fc" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: CASE</source>
          <target state="translated">조건식 : CASE</target>
        </trans-unit>
        <trans-unit id="31aeb72f2f3391d030478c674c1b1e99a6bfaa65" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: COALESCE</source>
          <target state="translated">조건식 : COALESCE</target>
        </trans-unit>
        <trans-unit id="80b1183f8c1779a8f9e2e00b4b48c3ac0b91eb03" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: GREATEST and LEAST</source>
          <target state="translated">조건식 : GREATEST 및 LEAST</target>
        </trans-unit>
        <trans-unit id="82e1c19ddb5b72b2d1628f347f8bae9565387565" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: NULLIF</source>
          <target state="translated">조건식 : NULLIF</target>
        </trans-unit>
        <trans-unit id="e8bca94262e57c3a1ece8f104ce7fd307805ff70" translate="yes" xml:space="preserve">
          <source>Config: DateStyle</source>
          <target state="translated">구성 : DateStyle</target>
        </trans-unit>
        <trans-unit id="8511a3d87020c8a69f6436b1827106433ad1d2ee" translate="yes" xml:space="preserve">
          <source>Config: IntervalStyle</source>
          <target state="translated">구성 : IntervalStyle</target>
        </trans-unit>
        <trans-unit id="b144c36fb88dac3ce5285c3c981dc9351e3b98fc" translate="yes" xml:space="preserve">
          <source>Config: TimeZone</source>
          <target state="translated">구성 : TimeZone</target>
        </trans-unit>
        <trans-unit id="18a399a27b0a37f91c764c69975729a0e6573d13" translate="yes" xml:space="preserve">
          <source>Config: allow_system_table_mods</source>
          <target state="translated">구성 : allow_system_table_mods</target>
        </trans-unit>
        <trans-unit id="f0fab5fc27a2fe4c5e7760f7f7c177e385ad2591" translate="yes" xml:space="preserve">
          <source>Config: application_name</source>
          <target state="translated">구성 : application_name</target>
        </trans-unit>
        <trans-unit id="d1f6d8b6e711d4ba59b0b94f84ceac5029dbaf7e" translate="yes" xml:space="preserve">
          <source>Config: archive_cleanup_command</source>
          <target state="translated">구성 : archive_cleanup_command</target>
        </trans-unit>
        <trans-unit id="2fab064686922676e797fc47a18c333454a80fa1" translate="yes" xml:space="preserve">
          <source>Config: archive_command</source>
          <target state="translated">구성 : archive_command</target>
        </trans-unit>
        <trans-unit id="7245f5a1ef6fc61169efa659a07ddb9c10d24604" translate="yes" xml:space="preserve">
          <source>Config: archive_mode</source>
          <target state="translated">구성 : archive_mode</target>
        </trans-unit>
        <trans-unit id="840bc864a38d460630bcd6de13d3535faf7a00bf" translate="yes" xml:space="preserve">
          <source>Config: archive_timeout</source>
          <target state="translated">구성 : archive_timeout</target>
        </trans-unit>
        <trans-unit id="ba4297026f3e073c1e0dc3a2afeae0b082ebd020" translate="yes" xml:space="preserve">
          <source>Config: array_nulls</source>
          <target state="translated">구성 : array_nulls</target>
        </trans-unit>
        <trans-unit id="7bb011279372ad23a9a2b11a5c3ea59c686e271b" translate="yes" xml:space="preserve">
          <source>Config: authentication_timeout</source>
          <target state="translated">구성 : authentication_timeout</target>
        </trans-unit>
        <trans-unit id="5941e7a97778ba946038d81f471acc5a7b8af99e" translate="yes" xml:space="preserve">
          <source>Config: autovacuum</source>
          <target state="translated">구성 : autovacuum</target>
        </trans-unit>
        <trans-unit id="a43f76e1db32589e05b8c05232a61e43de7938c5" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_analyze_scale_factor</source>
          <target state="translated">구성 : autovacuum_analyze_scale_factor</target>
        </trans-unit>
        <trans-unit id="242180115535965f07118f06213c1df477e0f174" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_analyze_threshold</source>
          <target state="translated">구성 : autovacuum_analyze_threshold</target>
        </trans-unit>
        <trans-unit id="83e95fe01f4fc127940b09173f91885cf297f68d" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_freeze_max_age</source>
          <target state="translated">구성 : autovacuum_freeze_max_age</target>
        </trans-unit>
        <trans-unit id="017808f6d070e5e8e7cf3c185a5fd17fde18c054" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_max_workers</source>
          <target state="translated">구성 : autovacuum_max_workers</target>
        </trans-unit>
        <trans-unit id="53ade2cde7db11b6c4e3bb8cdf3c9a64c500c156" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_multixact_freeze_max_age</source>
          <target state="translated">구성 : autovacuum_multixact_freeze_max_age</target>
        </trans-unit>
        <trans-unit id="55d0a539086ca4d4a71bf19539eb4916a39c362b" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_naptime</source>
          <target state="translated">구성 : autovacuum_naptime</target>
        </trans-unit>
        <trans-unit id="f6de913c942c9946837babc768d0f897678d23bc" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_cost_delay</source>
          <target state="translated">구성 : autovacuum_vacuum_cost_delay</target>
        </trans-unit>
        <trans-unit id="85ac6ab8e00a08929e157f17f1a926fcb57aebb2" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_cost_limit</source>
          <target state="translated">구성 : autovacuum_vacuum_cost_limit</target>
        </trans-unit>
        <trans-unit id="658166dda413e0040c2f606fded0147b97cd7f9f" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_scale_factor</source>
          <target state="translated">구성 : autovacuum_vacuum_scale_factor</target>
        </trans-unit>
        <trans-unit id="6d09feb26281c939269c7f66dab6a858024efaeb" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_threshold</source>
          <target state="translated">구성 : autovacuum_vacuum_threshold</target>
        </trans-unit>
        <trans-unit id="3306f6d52b58797515ffd3bb2de543ee8e3b05f2" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_work_mem</source>
          <target state="translated">구성 : autovacuum_work_mem</target>
        </trans-unit>
        <trans-unit id="ce8f98d44391f786dd5f656e40b627a5a19894a4" translate="yes" xml:space="preserve">
          <source>Config: backend_flush_after</source>
          <target state="translated">구성 : backend_flush_after</target>
        </trans-unit>
        <trans-unit id="177de7ae0453e0490ad03b84788518a349cd7c38" translate="yes" xml:space="preserve">
          <source>Config: backslash_quote</source>
          <target state="translated">구성 : backslash_quote</target>
        </trans-unit>
        <trans-unit id="ed264423122a9b435d56653dfce96b0aaf843d7a" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_delay</source>
          <target state="translated">구성 : bgwriter_delay</target>
        </trans-unit>
        <trans-unit id="8248026151b19669fc716236de46e4581858ce37" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_flush_after</source>
          <target state="translated">구성 : bgwriter_flush_after</target>
        </trans-unit>
        <trans-unit id="e2ffe551d8a693157336985e8341d6853ff4096a" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_lru_maxpages</source>
          <target state="translated">구성 : bgwriter_lru_maxpages</target>
        </trans-unit>
        <trans-unit id="a5fbeda3e9d2eb6fc02dedc336a690d19d598946" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_lru_multiplier</source>
          <target state="translated">구성 : bgwriter_lru_multiplier</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
