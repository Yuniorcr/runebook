<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="98186bbeb2ed0749527f083f8213011d78644463" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing index is anything like the one that would have been created. Index name is required when &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 색인이 작성된 색인과 다름을 보증하지 않습니다. &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 가 지정된 경우 색인 이름이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="834d3460fc8005f3aea73eb04212128e25f203f6" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the one that would have been created.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 관계가 작성된 관계와 같은 것을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4468e557fbd022f362186b25d203acdff76890d2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the sequence that would have been created - it might not even be a sequence.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 관계가 생성 된 시퀀스와 유사하다는 보장은 없습니다. 심지어 시퀀스가 ​​아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b9e5f0fa59fbd950645c2dd02f46959aa59a20" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae04ab134e47fe25b398dae820484170ac9b3e0" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a server with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing server is anything like the one that would have been created.</source>
          <target state="translated">같은 이름의 서버가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 서버가 작성된 서버와 같은 서버라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcebad473dcc4eee3043b0222f58a0d2bd1e708c" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a statistics object with the same name already exists. A notice is issued in this case. Note that only the name of the statistics object is considered here, not the details of its definition.</source>
          <target state="translated">같은 이름의 통계 개체가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 통계 오브젝트의 이름 만 여기에서 고려되며 정의의 세부 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4bc72f4656e524f04810f27b3f3abd1fa036a9c0" translate="yes" xml:space="preserve">
          <source>Do not throw an error if an extension with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing extension is anything like the one that would have been created from the currently-available script file.</source>
          <target state="translated">같은 이름의 확장자가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 확장이 현재 사용 가능한 스크립트 파일에서 생성 된 확장과 동일하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="86a392087235d29d2756da6807d948d7139e08cd" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the access method does not exist. A notice is issued in this case.</source>
          <target state="translated">액세스 방법이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="d83f66a16dc09425c3a72b2eb69f4e766690024a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the aggregate does not exist. A notice is issued in this case.</source>
          <target state="translated">집계가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="08209801f14336e9d0a054fd445e99f81d3d7bce" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the cast does not exist. A notice is issued in this case.</source>
          <target state="translated">캐스트가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="7a76d68c1857062357f7d8db55de8919ef49944f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the collation does not exist. A notice is issued in this case.</source>
          <target state="translated">데이터 정렬이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8465af39f185f9c6cc5c2919c5a306f7d480deaf" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the conversion does not exist. A notice is issued in this case.</source>
          <target state="translated">변환이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c8acd7c64523763c5a343233452d4d3bdc021ed8" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the database does not exist. A notice is issued in this case.</source>
          <target state="translated">데이터베이스가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce16a031cfcc5745a9e2c0502a634517a7d81a22" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the domain does not exist. A notice is issued in this case.</source>
          <target state="translated">도메인이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="440d1746f214a514f20e24af1d13b08a9fed25ae" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the event trigger does not exist. A notice is issued in this case.</source>
          <target state="translated">이벤트 트리거가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="88d8420232fd2310619a1e4b1b65e116a3e5c2c1" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the extension does not exist. A notice is issued in this case.</source>
          <target state="translated">확장이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b53b3a5b66729e2d82cca27836b44793e319b9b" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the foreign table does not exist. A notice is issued in this case.</source>
          <target state="translated">외부 테이블이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c2bafb9e707a65189fb4c175b92b98ea2955ba9d" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the foreign-data wrapper does not exist. A notice is issued in this case.</source>
          <target state="translated">외부 데이터 랩퍼가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3d1f799bfb7ab5956e34d625575f04baeca247a1" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the function does not exist. A notice is issued in this case.</source>
          <target state="translated">함수가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b59c4ddb9070fc22cbae29d732ed6c0ba171ccc" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the index does not exist. A notice is issued in this case.</source>
          <target state="translated">색인이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7be96437ecd160ba0c5df2293ca24cdaad01c7" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the language does not exist. A notice is issued in this case.</source>
          <target state="translated">언어가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="a4cdf2a8b108d00b6d4ec4eddaf401f8eb21599a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the materialized view does not exist. A notice is issued in this case.</source>
          <target state="translated">구체화 된 뷰가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="2059447ea2ceab96cc0790936e5d53b052c338a3" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator class does not exist. A notice is issued in this case.</source>
          <target state="translated">연산자 클래스가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="e05bc4c6b98bad30fafd6399feb7591e7d17abe5" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator does not exist. A notice is issued in this case.</source>
          <target state="translated">연산자가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef7535fc3526366c6c3c344e9a1930bfa9dcfc2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator family does not exist. A notice is issued in this case.</source>
          <target state="translated">운영자 제품군이없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="77e5ef3e5fffba0904b6dbcbdde58401194934be" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the policy does not exist. A notice is issued in this case.</source>
          <target state="translated">정책이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="ba92fd4b74c7007ccb25e8c2c12a614e648815ad" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the procedure does not exist. A notice is issued in this case.</source>
          <target state="translated">절차가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="580ab3a4fca82e175fc9e041941c0bbb5606da00" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the publication does not exist. A notice is issued in this case.</source>
          <target state="translated">발행물이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8f68861705f245e6c1a0318af8fc3ad51208a6" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the role does not exist. A notice is issued in this case.</source>
          <target state="translated">역할이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b04b712e02e9f117f930897fe5aef8271beac18f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the rule does not exist. A notice is issued in this case.</source>
          <target state="translated">규칙이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9118e341b6ecc73648a291f45c5f8a2ee770317e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the schema does not exist. A notice is issued in this case.</source>
          <target state="translated">스키마가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="92aa852d80a1a3c28aea7bffd74a935b11a21f2e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the sequence does not exist. A notice is issued in this case.</source>
          <target state="translated">시퀀스가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f9d6984455f53ccd847e3b2412a66166bd91d5a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the server does not exist. A notice is issued in this case.</source>
          <target state="translated">서버가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6e60fbfe6dbe35cc5b8b5280e84e5eb192b96e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the statistics object does not exist. A notice is issued in this case.</source>
          <target state="translated">통계 오브젝트가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e879dd31b56dd9d7ceb910c29ee66a8ae5d6b7d" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the table does not exist. A notice is issued in this case.</source>
          <target state="translated">테이블이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b53d78838383e3a93ed23545557e80c808dde9b2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the tablespace does not exist. A notice is issued in this case.</source>
          <target state="translated">테이블 스페이스가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="63eab72e1b11a0effaed0332862bc36b827445c9" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search configuration does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 구성이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4ed9c5b587e515f69b4cd2fa322fc5acd20b38" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search dictionary does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 사전이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe76f21f4e80a87b0b18068cd5e209238176ef08" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search parser does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 파서가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="e6be7b21927c4294da04777cc6a6587ae3094ec2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search template does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 템플릿이없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="bdd3d494ae40a87f77adb032f6192ea525f37124" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the transform does not exist. A notice is issued in this case.</source>
          <target state="translated">변환이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="18afb1f92e7fa1b7cb2a1502a3ae88886a473bfd" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the trigger does not exist. A notice is issued in this case.</source>
          <target state="translated">트리거가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="593cb323d835a409bd58f18ebbdb6437fb9acd92" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the type does not exist. A notice is issued in this case.</source>
          <target state="translated">유형이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8c9bf79c7b56c000d4b79cd2d828190b901d3f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the user does not exist. A notice is issued in this case.</source>
          <target state="translated">사용자가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f294cf5a31c3c8e6b4053dbb5f2dca944fd8300" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the user mapping does not exist. A notice is issued in this case.</source>
          <target state="translated">사용자 매핑이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b517045375dd57c661998c97237a302fad962ca" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the view does not exist. A notice is issued in this case.</source>
          <target state="translated">보기가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="aecd31e282542c2f634ad41996eb4931eda571b4" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;trust&lt;/code&gt; unless you trust all local users on your system. &lt;code&gt;trust&lt;/code&gt; is the default for ease of installation.</source>
          <target state="translated">시스템의 모든 로컬 사용자를 &lt;code&gt;trust&lt;/code&gt; 하지 않으면 신뢰를 사용하지 마십시오 . &lt;code&gt;trust&lt;/code&gt; 설치가 용이하도록 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f9677f0bbbea4f4186994ea9ded2744a92cf57b9" translate="yes" xml:space="preserve">
          <source>Do not use Readline for line editing and do not use the command history. This can be useful to turn off tab expansion when cutting and pasting.</source>
          <target state="translated">행 편집에 Readline을 사용하지 말고 명령 기록을 사용하지 마십시오. 잘라 내기 및 붙여 넣기시 탭 확장을 끄는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea93e72f74f0d71bbeeb8070e22a9f11989cb77" translate="yes" xml:space="preserve">
          <source>Do not use indicators but instead use special values to represent null values. Historically there have been databases using this approach.</source>
          <target state="translated">인디케이터를 사용하지 말고 대신 널 (NULL) 값을 나타내는 특수 값을 사용하십시오. 역사적으로이 접근법을 사용하는 데이터베이스가있었습니다.</target>
        </trans-unit>
        <trans-unit id="034b4314ea8be40733a06e32d575d62057905398" translate="yes" xml:space="preserve">
          <source>Do not use pg_standby or similar tools with the built-in standby mode described here. &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; should return immediately if the file does not exist; the server will retry the command again if necessary. See &lt;a href=&quot;log-shipping-alternative&quot;&gt;Section 26.4&lt;/a&gt; for using tools like pg_standby.</source>
          <target state="translated">여기에 설명 된 내장 대기 모드에서 pg_standby 또는 이와 유사한 도구를 사용하지 마십시오. 파일이 존재하지 않으면 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 가 즉시 리턴해야합니다. 필요한 경우 서버가 명령을 다시 시도합니다. pg_standby와 같은 도구 사용에 대해서는 &lt;a href=&quot;log-shipping-alternative&quot;&gt;26.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8126e1ed0b6614723be2e186ee52e7d3c81c5a4f" translate="yes" xml:space="preserve">
          <source>Do not verify existing stored data for constraint validity.</source>
          <target state="translated">제한 조건 유효성에 대해 기존의 저장된 데이터를 확인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46a09fece9a4c0f8e5d9983ec48b4da9e781148b" translate="yes" xml:space="preserve">
          <source>Do not wait for the operation to complete. This is the opposite of the option &lt;code&gt;-w&lt;/code&gt;.</source>
          <target state="translated">작업이 완료 될 때까지 기다리지 마십시오. &lt;code&gt;-w&lt;/code&gt; 옵션과 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="a354e745b71c79bd26167718a30b36daeb0cb5b5" translate="yes" xml:space="preserve">
          <source>Do not wait forever to acquire shared table locks at the beginning of the dump. Instead fail if unable to lock a table within the specified &lt;code&gt;timeout&lt;/code&gt;. The timeout may be specified in any of the formats accepted by &lt;code&gt;SET statement_timeout&lt;/code&gt;. (Allowed formats vary depending on the server version you are dumping from, but an integer number of milliseconds is accepted by all versions.)</source>
          <target state="translated">덤프 시작시 공유 테이블 잠금을 획득하기 위해 영원히 기다리지 마십시오. 지정된 &lt;code&gt;timeout&lt;/code&gt; 내에 테이블을 잠글 수 없으면 대신 실패합니다 . 제한 시간은 &lt;code&gt;SET statement_timeout&lt;/code&gt; 에서 허용되는 형식으로 지정할 수 있습니다 . (허용되는 형식은 덤프하는 서버 버전에 따라 다르지만 모든 버전에서 정수 밀리 초를 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="315591fe4909ae8f4cfc10cdd40e834a565965d3" translate="yes" xml:space="preserve">
          <source>Do not wait forever to acquire shared table locks at the beginning of the dump. Instead, fail if unable to lock a table within the specified &lt;code&gt;timeout&lt;/code&gt;. The timeout may be specified in any of the formats accepted by &lt;code&gt;SET statement_timeout&lt;/code&gt;. Allowed values vary depending on the server version you are dumping from, but an integer number of milliseconds is accepted by all versions since 7.3. This option is ignored when dumping from a pre-7.3 server.</source>
          <target state="translated">덤프 시작시 공유 테이블 잠금을 획득하기 위해 영원히 기다리지 마십시오. 대신 지정된 &lt;code&gt;timeout&lt;/code&gt; 내에 테이블을 잠글 수 없으면 실패합니다 . 제한 시간은 &lt;code&gt;SET statement_timeout&lt;/code&gt; 에서 허용되는 형식으로 지정할 수 있습니다 . 허용되는 값은 덤프하는 서버 버전에 따라 다르지만 7.3 이후의 모든 버전에서 정수 밀리 초를 허용합니다. 이 옵션은 7.3 이전 서버에서 덤프 할 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1cbb6712fbb2ec963fc240a169aba9d0eaf374" translate="yes" xml:space="preserve">
          <source>Do nothing (except issuing a notice) if a schema with the same name already exists. &lt;code&gt;schema_element&lt;/code&gt; subcommands cannot be included when this option is used.</source>
          <target state="translated">동일한 이름의 스키마가 이미 존재하는 경우에는 통지를 발행하지 않습니다. 이 옵션을 사용하면 &lt;code&gt;schema_element&lt;/code&gt; 하위 명령을 포함시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c67a2c76df14834b062cbb89b0413d341b43ba5a" translate="yes" xml:space="preserve">
          <source>Documentation: Christopher Kings-Lynne</source>
          <target state="translated">문서 : Christopher Kings-Lynne</target>
        </trans-unit>
        <trans-unit id="e8534a768aff765a5fcad0aa4441beb5f2118482" translate="yes" xml:space="preserve">
          <source>Does JSON path return any item for the specified JSON value?</source>
          <target state="translated">JSON 경로가 지정된 JSON 값에 대한 항목을 반환합니까?</target>
        </trans-unit>
        <trans-unit id="1d71ff371784a348f9c12a352bc76caaae987330" translate="yes" xml:space="preserve">
          <source>Does not extend above?</source>
          <target state="translated">이상으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="253123d1162a517f04a5ee9fd02d365f25c36adc" translate="yes" xml:space="preserve">
          <source>Does not extend below?</source>
          <target state="translated">아래로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="add602c08fe405618614a22bb2c72529b335161c" translate="yes" xml:space="preserve">
          <source>Does not extend to the left of?</source>
          <target state="translated">왼쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="e07e4fa0874bbb4b32f819c4b8f203d1c6858afb" translate="yes" xml:space="preserve">
          <source>Does not extend to the right of?</source>
          <target state="translated">의 오른쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="67e33d862ea98de3a421509890f6998594008921" translate="yes" xml:space="preserve">
          <source>Does not match regular expression, case insensitive</source>
          <target state="translated">대소 문자를 구분하지 않는 정규식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b2eb54c55e1d00f4b5dc4d67d0e5f2fe84d39a" translate="yes" xml:space="preserve">
          <source>Does not match regular expression, case sensitive</source>
          <target state="translated">대소 문자를 구분하는 정규식과 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a3bdc835bceb148f38a752943d8b7b4dc4bcbc04" translate="yes" xml:space="preserve">
          <source>Does the &lt;em&gt;string&lt;/em&gt; exist as a top-level key within the JSON value?</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 이 JSON 값 내에 최상위 키로 존재 합니까 ?</target>
        </trans-unit>
        <trans-unit id="03ba5cf03bf4fbd798f77a355da2957d8284b101" translate="yes" xml:space="preserve">
          <source>Does the access method support &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and related keywords in &lt;code&gt;CREATE INDEX&lt;/code&gt;?</source>
          <target state="translated">액세스 방법 이 &lt;code&gt;CREATE INDEX&lt;/code&gt; 에서 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; 및 관련 키워드를 지원합니까 ?</target>
        </trans-unit>
        <trans-unit id="fb913abb5c49330f0377cb2bc42a471044b0555c" translate="yes" xml:space="preserve">
          <source>Does the access method support exclusion constraints?</source>
          <target state="translated">액세스 방법이 제외 제약 조건을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="879909ef15ed6acf0beaf326ab6fec44b52b3c5e" translate="yes" xml:space="preserve">
          <source>Does the access method support indexes with multiple columns?</source>
          <target state="translated">액세스 방법이 여러 열이있는 인덱스를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="6453c4c495cc610787e73fb0ae04205fd538bcbb" translate="yes" xml:space="preserve">
          <source>Does the access method support the &lt;code&gt;INCLUDE&lt;/code&gt; clause of &lt;code&gt;CREATE INDEX&lt;/code&gt;?</source>
          <target state="translated">액세스 방법 이 &lt;code&gt;CREATE INDEX&lt;/code&gt; 의 &lt;code&gt;INCLUDE&lt;/code&gt; 절을 지원합니까 ?</target>
        </trans-unit>
        <trans-unit id="cfc9c010de9381229fd83fcf505998f9b9821e8d" translate="yes" xml:space="preserve">
          <source>Does the access method support unique indexes?</source>
          <target state="translated">액세스 방법이 고유 인덱스를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="216de41f9cbdff166df017bbef3accd4d29b2eff" translate="yes" xml:space="preserve">
          <source>Does the column natively support &lt;code&gt;col = ANY(array)&lt;/code&gt; searches?</source>
          <target state="translated">열이 기본적으로 &lt;code&gt;col = ANY(array)&lt;/code&gt; 검색을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="68fd60934753d2550ca7db3f70d3a9626bf64fbc" translate="yes" xml:space="preserve">
          <source>Does the column possess any defined sort ordering?</source>
          <target state="translated">열에 정의 된 정렬 순서가 있습니까?</target>
        </trans-unit>
        <trans-unit id="44e4c108b376d30b30390dfadb54272d724d6c79" translate="yes" xml:space="preserve">
          <source>Does the column sort in ascending order on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 오름차순으로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="624b72742f7340536d8c41c26fd99d9f75165b8b" translate="yes" xml:space="preserve">
          <source>Does the column sort in descending order on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 내림차순으로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="7d5b73a8840fb440669eafdd08be2bf0f8372175" translate="yes" xml:space="preserve">
          <source>Does the column sort with nulls first on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 먼저 널로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="7e98e107338f4cd5beb68f7b54e73f00debec7aa" translate="yes" xml:space="preserve">
          <source>Does the column sort with nulls last on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 널로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="614b9c69d6588988042647fac537366e8e09fcc7" translate="yes" xml:space="preserve">
          <source>Does the column support &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; searches?</source>
          <target state="translated">열이 &lt;code&gt;IS NULL&lt;/code&gt; 및 &lt;code&gt;IS NOT NULL&lt;/code&gt; 검색을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="7242f0264cca02688205293e7aba32e21945855c" translate="yes" xml:space="preserve">
          <source>Does the index support bitmap scans?</source>
          <target state="translated">인덱스가 비트 맵 스캔을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="ef53c30eccf8ae98790d427d2faa9e7c00273781" translate="yes" xml:space="preserve">
          <source>Does the index support plain (non-bitmap) scans?</source>
          <target state="translated">인덱스가 일반 (비 비트 맵) 스캔을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="14e5a573eb1bb894fdc6ebb3db56ca889d046493" translate="yes" xml:space="preserve">
          <source>Does the left JSON value contain the right JSON path/value entries at the top level?</source>
          <target state="translated">왼쪽 JSON 값에 최상위 JSON 경로 / 값 항목이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="be846d72fad3df0bc7f1c552be7f26dd20d67401" translate="yes" xml:space="preserve">
          <source>Dollar quoting is not part of the SQL standard, but it is often a more convenient way to write complicated string literals than the standard-compliant single quote syntax. It is particularly useful when representing string constants inside other constants, as is often needed in procedural function definitions. With single-quote syntax, each backslash in the above example would have to be written as four backslashes, which would be reduced to two backslashes in parsing the original string constant, and then to one when the inner string constant is re-parsed during function execution.</source>
          <target state="translated">달러 인용은 SQL 표준의 일부가 아니지만 종종 표준 호환 작은 따옴표 구문보다 복잡한 문자열 리터럴을 작성하는 것이 더 편리한 방법입니다. 프로 시저 함수 정의에서 종종 필요한 것처럼 다른 상수 내에서 문자열 상수를 나타낼 때 특히 유용합니다. 작은 따옴표 구문을 사용하면 위 예제의 각 백 슬래시는 4 개의 백 슬래시로 작성되어야합니다. 백 슬래시는 원래 문자열 상수를 구문 분석 할 때 2 개의 백 슬래시로 감소한 다음 함수 중에 내부 문자열 상수가 다시 구문 분석 될 때 1로 감소합니다. 실행.</target>
        </trans-unit>
        <trans-unit id="299fdf04cba228f518669cf01c99ac27abcc66f7" translate="yes" xml:space="preserve">
          <source>Domain Types</source>
          <target state="translated">도메인 유형</target>
        </trans-unit>
        <trans-unit id="89eb4d5646a45612dd3ca144ea0a29e4cdfca3ab" translate="yes" xml:space="preserve">
          <source>Domain constraints, particularly &lt;code&gt;NOT NULL&lt;/code&gt;, are checked when converting a value to the domain type. It is possible for a column that is nominally of the domain type to read as null despite there being such a constraint. For example, this can happen in an outer-join query, if the domain column is on the nullable side of the outer join. A more subtle example is</source>
          <target state="translated">도메인 제약 조건, 특히 &lt;code&gt;NOT NULL&lt;/code&gt; 은 값을 도메인 유형으로 변환 할 때 확인됩니다. 도메인 유형이 공칭 인 열은 그러한 제한 조건이 있음에도 불구하고 널로 읽을 수 있습니다. 예를 들어 도메인 열이 외부 조인의 Null을 허용하는쪽에있는 경우 외부 조인 쿼리에서 발생할 수 있습니다. 더 미묘한 예는</target>
        </trans-unit>
        <trans-unit id="2abdad646fb44d4d610efcbe79a830794cd64bf9" translate="yes" xml:space="preserve">
          <source>Domains are useful for abstracting common constraints on fields into a single location for maintenance. For example, several tables might contain email address columns, all requiring the same CHECK constraint to verify the address syntax. Define a domain rather than setting up each table's constraint individually.</source>
          <target state="translated">도메인은 유지 보수를 위해 필드의 공통 제한 조건을 단일 위치로 추상화하는 데 유용합니다. 예를 들어, 여러 테이블에 이메일 주소 열이 포함될 수 있으며, 모두 주소 구문을 확인하기 위해 동일한 CHECK 제약 조건이 필요합니다. 각 테이블의 제약 조건을 개별적으로 설정하는 대신 도메인을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7b14ee932a350cc527859e6afd76cead3251e675" translate="yes" xml:space="preserve">
          <source>Domains use &lt;code&gt;typtypmod&lt;/code&gt; to record the &lt;code&gt;typmod&lt;/code&gt; to be applied to their base type (-1 if base type does not use a &lt;code&gt;typmod&lt;/code&gt;). -1 if this type is not a domain.</source>
          <target state="translated">도메인은 &lt;code&gt;typtypmod&lt;/code&gt; 를 사용 하여 기본 유형에 적용 할 &lt;code&gt;typmod&lt;/code&gt; 를 기록합니다 (기본 유형이 &lt;code&gt;typmod&lt;/code&gt; 를 사용하지 않는 경우 -1 ). 이 유형이 도메인이 아닌 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="74754f8ebf1860694f41ab11263488f49d2334f3" translate="yes" xml:space="preserve">
          <source>Don't include write-ahead log in the backup.</source>
          <target state="translated">백업에 미리 기록 로그를 포함시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="efbbc563b332126ef2578ac6901c3ec90f1dbc98" translate="yes" xml:space="preserve">
          <source>Don't leave connections dangling &amp;ldquo;idle in transaction&amp;rdquo; longer than necessary. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT&quot;&gt;idle_in_transaction_session_timeout&lt;/a&gt; may be used to automatically disconnect lingering sessions.</source>
          <target state="translated">연결이 &quot;유휴 상태&quot;에 매달려있는 동안 필요 이상으로 두지 마십시오. 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT&quot;&gt;idle_in_transaction_session_timeout을&lt;/a&gt; 사용하여 느린 세션의 연결을 자동으로 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8d45de9f00429ca5b53c7f234e4ab44bcf9705" translate="yes" xml:space="preserve">
          <source>Don't loop on connection errors. Instead, exit right away with an error.</source>
          <target state="translated">연결 오류를 반복하지 마십시오. 대신 오류가 발생하면 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f3fc27f7ea73735ee61962c17ae8611b94f64e4f" translate="yes" xml:space="preserve">
          <source>Don't put more into a single transaction than needed for integrity purposes.</source>
          <target state="translated">무결성 목적에 필요한 것보다 단일 트랜잭션에 더 많은 것을 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d1207520ff0a565537c007a53269e3261c6bd8c8" translate="yes" xml:space="preserve">
          <source>Dot (&lt;code&gt;.&lt;/code&gt;) is used for member access.</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; )은 회원 액세스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5df432c8c8dbc55f99758989ab422fd0f4ef23e0" translate="yes" xml:space="preserve">
          <source>Drop a publication:</source>
          <target state="translated">발행물을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac9f745c628bc958118f6ed763e2a1442043a73" translate="yes" xml:space="preserve">
          <source>Drop a server &lt;code&gt;foo&lt;/code&gt; if it exists:</source>
          <target state="translated">존재하는 경우 서버 &lt;code&gt;foo&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="93d5bbb17a8c38f06b908475f91177219b6e5365" translate="yes" xml:space="preserve">
          <source>Drop a subscription:</source>
          <target state="translated">구독을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0efb9df76ce6bb0c19ee2a980a677ca924beeaf3" translate="yes" xml:space="preserve">
          <source>Drop a user mapping &lt;code&gt;bob&lt;/code&gt;, server &lt;code&gt;foo&lt;/code&gt; if it exists:</source>
          <target state="translated">사용자 맵핑 &lt;code&gt;bob&lt;/code&gt; , 서버 &lt;code&gt;foo&lt;/code&gt; 가있는 경우이를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="58f0d64c8558580252204c03f90d90e1bfb7a28b" translate="yes" xml:space="preserve">
          <source>Drop any existing pgbench tables.</source>
          <target state="translated">기존 pgbench 테이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="326f543b1017ef892a8231ce1a80b0c93a80c52a" translate="yes" xml:space="preserve">
          <source>Drop multiple functions in one command:</source>
          <target state="translated">하나의 명령으로 여러 기능을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="591aefafc0cb1112269eec12b89b4b23ed9aaac5" translate="yes" xml:space="preserve">
          <source>Drop the access method &lt;code&gt;heptree&lt;/code&gt;:</source>
          <target state="translated">액세스 방법 &lt;code&gt;heptree&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="e467322a0e06a4f2e03ebed261e871f325317f57" translate="yes" xml:space="preserve">
          <source>Drop the foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt;:</source>
          <target state="translated">외부 데이터 래퍼 &lt;code&gt;dbi&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="b005b49eeb0932041751efe51bfa289cb8d388e5" translate="yes" xml:space="preserve">
          <source>Drop the index without locking out concurrent selects, inserts, updates, and deletes on the index's table. A normal &lt;code&gt;DROP INDEX&lt;/code&gt; acquires exclusive lock on the table, blocking other accesses until the index drop can be completed. With this option, the command instead waits until conflicting transactions have completed.</source>
          <target state="translated">인덱스 테이블에서 동시 선택, 삽입, 업데이트 및 삭제를 잠그지 않고 인덱스를 삭제하십시오. 일반 &lt;code&gt;DROP INDEX&lt;/code&gt; 는 테이블에서 배타적 잠금을 획득하여 인덱스 삭제가 완료 될 때까지 다른 액세스를 차단합니다. 이 옵션을 사용하면 충돌하는 트랜잭션이 완료 될 때까지 명령이 대신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="63bbc062ffd5dcec9e7d8f06903c428715c1fcfb" translate="yes" xml:space="preserve">
          <source>Drop the replication slot with the name specified by &lt;code&gt;--slot&lt;/code&gt;, then exit.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 지정된 이름으로 복제 슬롯을 삭제 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e77bdc67e0eb1a9828de69a267601200dc5b1120" translate="yes" xml:space="preserve">
          <source>Drop the replication slot with the name specified in &lt;code&gt;--slot&lt;/code&gt;, then exit.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 지정된 이름으로 복제 슬롯을 삭제 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="db6283865228ed49d3592194f4d42fbbb357949c" translate="yes" xml:space="preserve">
          <source>Dropping Roles</source>
          <target state="translated">역할 삭제</target>
        </trans-unit>
        <trans-unit id="a9cfbbdc85ccf8af404bf68b314b6c3fbe73c256" translate="yes" xml:space="preserve">
          <source>Dropping a database on the primary conflicts with sessions connected to that database on the standby.</source>
          <target state="translated">기본에서 데이터베이스를 삭제하면 대기에서 해당 데이터베이스에 연결된 세션과 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="52cfca4e5356615c98bd7dc9395f21bc36322f98" translate="yes" xml:space="preserve">
          <source>Dropping a table will still orphan any objects it contains, as the trigger is not executed. You can avoid this by preceding the &lt;code&gt;DROP TABLE&lt;/code&gt; with &lt;code&gt;DELETE FROM table&lt;/code&gt;.</source>
          <target state="translated">트리거를 실행하지 않기 때문에 테이블을 삭제하면 테이블에 포함 된 개체가 여전히 고아가됩니다. &lt;code&gt;DROP TABLE&lt;/code&gt; 을 &lt;code&gt;DELETE FROM table&lt;/code&gt; 과 함께 사용 하면이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b04562d85f79214513954b38b3c0dd5219a517e3" translate="yes" xml:space="preserve">
          <source>Dropping a tablespace on the primary conflicts with standby queries using that tablespace for temporary work files.</source>
          <target state="translated">기본에서 테이블 스페이스를 삭제하면 임시 작업 파일에 대해 해당 테이블 스페이스를 사용하는 대기 쿼리와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3bf79a210f5bff70979738390a60829a46b95975" translate="yes" xml:space="preserve">
          <source>Drops all temporary tables created in the current session.</source>
          <target state="translated">현재 세션에서 생성 된 모든 임시 테이블을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="28e3182564ff9f2b19110ace5eed1b5ef4dc68a6" translate="yes" xml:space="preserve">
          <source>Drops the physical or logical replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. Same as replication protocol command &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt;. For logical slots, this must be called when connected to the same database the slot was created on.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 물리적 또는 논리적 복제 슬롯을 삭제합니다 . 복제 프로토콜 명령 &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt; 과 동일합니다 . 논리 슬롯의 경우 슬롯이 작성된 동일한 데이터베이스에 연결될 때 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="258c60100861b523b967c0638c700489453c1860" translate="yes" xml:space="preserve">
          <source>Due to implementation restrictions, DCL operations do not check permissions.</source>
          <target state="translated">구현 제한으로 인해 DCL 작업은 권한을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28747ebea8da10721c1430a1e3600b6360d8fc6d" translate="yes" xml:space="preserve">
          <source>Due to implementation restrictions, some DDL operations do not check permissions.</source>
          <target state="translated">구현 제한으로 인해 일부 DDL 작업은 권한을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00b39d3da7dc0222f671ae4e16cb733b95cfc11d" translate="yes" xml:space="preserve">
          <source>Due to the nature of SELinux, running the regression tests for &lt;code&gt;sepgsql&lt;/code&gt; requires several extra configuration steps, some of which must be done as root. The regression tests will not be run by an ordinary &lt;code&gt;make check&lt;/code&gt; or &lt;code&gt;make installcheck&lt;/code&gt; command; you must set up the configuration and then invoke the test script manually. The tests must be run in the &lt;code&gt;contrib/sepgsql&lt;/code&gt; directory of a configured PostgreSQL build tree. Although they require a build tree, the tests are designed to be executed against an installed server, that is they are comparable to &lt;code&gt;make installcheck&lt;/code&gt; not &lt;code&gt;make check&lt;/code&gt;.</source>
          <target state="translated">SELinux의 특성상 &lt;code&gt;sepgsql&lt;/code&gt; 에 대한 회귀 테스트를 실행 하려면 몇 가지 추가 구성 단계가 필요 하며이 중 일부는 루트로 수행해야합니다. 회귀 테스트는 일반적인 &lt;code&gt;make check&lt;/code&gt; 또는 &lt;code&gt;make installcheck&lt;/code&gt; 명령 으로 실행되지 않습니다 . 구성을 설정 한 다음 테스트 스크립트를 수동으로 호출해야합니다. 테스트는 구성된 PostgreSQL 빌드 트리 의 &lt;code&gt;contrib/sepgsql&lt;/code&gt; 디렉토리 에서 실행해야합니다 . 빌드 트리가 필요하지만 테스트는 설치된 서버에 대해 실행되도록 설계되었습니다. 즉, &lt;code&gt;make installcheck&lt;/code&gt; &lt;code&gt;make check&lt;/code&gt; 하지 않도록 하는 것과 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="45ec1692682503d82d8975d2c913c5404a874c98" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). Controls the maximum number of rows per &lt;code&gt;INSERT&lt;/code&gt; command. The value specified must be a number greater than zero. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . &lt;code&gt;INSERT&lt;/code&gt; 명령 당 최대 행 수를 제어합니다 . 지정된 값은 0보다 큰 숫자 여야합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="773e7ab91120390a7da90299d9a0a911b2e1a184" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents. Note that the restore might fail altogether if you have rearranged column order. The &lt;code&gt;--column-inserts&lt;/code&gt; option is safe against column order changes, though even slower.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다. 열 순서를 재정렬하면 복원이 완전히 실패 할 수 있습니다. &lt;code&gt;--column-inserts&lt;/code&gt; 옵션도 느린 불구하고, 열 순서 변경에 대한 안전합니다.</target>
        </trans-unit>
        <trans-unit id="e7a8de54701108e6f3f264904f89316e6abaa91e" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Note that the restore might fail altogether if you have rearranged column order. The &lt;code&gt;--column-inserts&lt;/code&gt; option is safer, though even slower.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 열 순서를 재정렬하면 복원이 완전히 실패 할 수 있습니다. &lt;code&gt;--column-inserts&lt;/code&gt; 옵션도 느린하지만, 안전합니다.</target>
        </trans-unit>
        <trans-unit id="be2e3a27442d383522945fa01292f4bd454153b9" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands with explicit column names (&lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases.</source>
          <target state="translated">명시적인 열 이름을 가진 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프 합니다 ( &lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt; ). 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b2744b71a20f76757bc5ec4a25669195de11873e" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands with explicit column names (&lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents.</source>
          <target state="translated">명시 적 열 이름을 가진 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 ( &lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt; ). 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="05e13a7e94996a48baf836ba10162b8d102ea084" translate="yes" xml:space="preserve">
          <source>Dump only global objects (roles and tablespaces), no databases.</source>
          <target state="translated">데이터베이스가없는 글로벌 오브젝트 (역할 및 테이블 스페이스) 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="d9f11940d71cc1177f78da933c7fb53c94282ba1" translate="yes" xml:space="preserve">
          <source>Dump only roles, no databases or tablespaces.</source>
          <target state="translated">데이터베이스 나 테이블 스페이스가없는 역할 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="18e2fd63c0671c6e33c31501010f51773fc9ac11" translate="yes" xml:space="preserve">
          <source>Dump only schemas matching &lt;code&gt;pattern&lt;/code&gt;; this selects both the schema itself, and all its contained objects. When this option is not specified, all non-system schemas in the target database will be dumped. Multiple schemas can be selected by writing multiple &lt;code&gt;-n&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;), so multiple schemas can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 스키마 만 덤프하십시오 . 스키마 자체와 포함 된 모든 개체를 모두 선택합니다. 이 옵션을 지정하지 않으면 대상 데이터베이스의 모든 비 시스템 스키마가 덤프됩니다. 여러 개의 &lt;code&gt;-n&lt;/code&gt; 스위치 를 작성하여 여러 스키마를 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; )이므로 여러 스키마는 또한 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때 쉘이 와일드 카드를 확장하지 못하게하려면 필요한 경우 패턴을 인용하십시오. &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82d464e541415e383825ea221c467f7ff042a561" translate="yes" xml:space="preserve">
          <source>Dump only tables with names matching &lt;code&gt;pattern&lt;/code&gt;. For this purpose, &amp;ldquo;table&amp;rdquo; includes views, materialized views, sequences, and foreign tables. Multiple tables can be selected by writing multiple &lt;code&gt;-t&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;), so multiple tables can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 테이블 만 덤프하십시오 . 이를 위해&amp;ldquo;테이블&amp;rdquo;에는 뷰, 구체화 된 뷰, 시퀀스 및 외부 테이블이 포함됩니다. 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; ) 때문에 다중 테이블은 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때 쉘이 와일드 카드를 확장하지 못하게하려면 필요한 경우 패턴을 인용하십시오. &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c50b3cf78208c818ebec3a1ce26491ce4dec1b6" translate="yes" xml:space="preserve">
          <source>Dump only tablespaces, no databases or roles.</source>
          <target state="translated">데이터베이스 나 역할이없는 테이블 스페이스 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="95679ba0c9930eb2f5afc93c363ee358885b7464" translate="yes" xml:space="preserve">
          <source>Dump only the data, not the schema (data definitions).</source>
          <target state="translated">스키마가 아닌 데이터 만 덤프하십시오 (데이터 정의).</target>
        </trans-unit>
        <trans-unit id="94c497beb41584499029745f0d584ed2d822c652" translate="yes" xml:space="preserve">
          <source>Dump only the data, not the schema (data definitions). Table data, large objects, and sequence values are dumped.</source>
          <target state="translated">스키마가 아닌 데이터 만 덤프하십시오 (데이터 정의). 테이블 데이터, 큰 객체 및 시퀀스 값이 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="8d61d7a6561789d6bec3f419956bd92574a77822" translate="yes" xml:space="preserve">
          <source>Dump only the object definitions (schema), not data.</source>
          <target state="translated">데이터가 아닌 오브젝트 정의 (스키마) 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="4c41ecc9dbf8b96d131dab3f2b5bece705d874ca" translate="yes" xml:space="preserve">
          <source>Dump scripts generated by pg_dump automatically apply several, but not all, of the above guidelines. To reload a pg_dump dump as quickly as possible, you need to do a few extra things manually. (Note that these points apply while &lt;em&gt;restoring&lt;/em&gt; a dump, not while &lt;em&gt;creating&lt;/em&gt; it. The same points apply whether loading a text dump with psql or using pg_restore to load from a pg_dump archive file.)</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프 스크립트는 위의 지침 중 일부만 자동으로 적용됩니다. pg_dump 덤프를 가능한 빨리 재로드하려면 몇 가지 추가 작업을 수동으로 수행해야합니다. (이 포인트 는 덤프를 &lt;em&gt;작성&lt;/em&gt; 하는 동안이 아니라 덤프 를 &lt;em&gt;복원&lt;/em&gt; 하는 동안 적용됩니다 . psql로 텍스트 덤프를로드하거나 pg_restore를 사용하여 pg_dump 아카이브 파일에서로드 할 때 동일한 포인트가 적용됩니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaabbf2e5086464616dc82d516df8ab03c355c59" translate="yes" xml:space="preserve">
          <source>Dumps can be output in script or archive file formats. Script dumps are plain-text files containing the SQL commands required to reconstruct the database to the state it was in at the time it was saved. To restore from such a script, feed it to &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Script files can be used to reconstruct the database even on other machines and other architectures; with some modifications, even on other SQL database products.</source>
          <target state="translated">덤프는 스크립트 또는 아카이브 파일 형식으로 출력 될 수 있습니다. 스크립트 덤프는 데이터베이스를 저장된 당시의 상태로 재구성하는 데 필요한 SQL 명령이 포함 된 일반 텍스트 파일입니다. 이러한 스크립트에서 복원하려면 &lt;a href=&quot;app-psql&quot;&gt;psql에&lt;/a&gt; 공급하십시오 . 스크립트 파일을 사용하여 다른 시스템 및 다른 아키텍처에서도 데이터베이스를 재구성 할 수 있습니다. 다른 SQL 데이터베이스 제품에서도 약간의 수정이있었습니다.</target>
        </trans-unit>
        <trans-unit id="eaf1baa1f617ecb2911c60562e4fdfbca8276c9b" translate="yes" xml:space="preserve">
          <source>Dumps created by pg_dump are internally consistent, meaning, the dump represents a snapshot of the database at the time pg_dump began running. pg_dump does not block other operations on the database while it is working. (Exceptions are those operations that need to operate with an exclusive lock, such as most forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;.)</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프는 내부적으로 일관성이 있습니다. 즉, 덤프는 pg_dump가 시작된 시점의 데이터베이스 스냅 샷을 나타냅니다. pg_dump는 데이터베이스가 작동하는 동안 다른 작업을 차단하지 않습니다. (대부분의 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식과 같은 독점 잠금으로 작동해야하는 작업은 예외 입니다.)</target>
        </trans-unit>
        <trans-unit id="88534ad7513782c209091770ebf75e66a9535341" translate="yes" xml:space="preserve">
          <source>Durability is a database feature that guarantees the recording of committed transactions even if the server crashes or loses power. However, durability adds significant database overhead, so if your site does not require such a guarantee, PostgreSQL can be configured to run much faster. The following are configuration changes you can make to improve performance in such cases. Except as noted below, durability is still guaranteed in case of a crash of the database software; only abrupt operating system stoppage creates a risk of data loss or corruption when these settings are used.</source>
          <target state="translated">내구성은 서버가 중단되거나 전원이 꺼진 경우에도 커밋 된 트랜잭션의 기록을 보장하는 데이터베이스 기능입니다. 그러나 내구성으로 인해 데이터베이스 오버 헤드가 크게 증가하므로 사이트에서 이러한 보장이 필요하지 않은 경우 PostgreSQL을 훨씬 빠르게 실행하도록 구성 할 수 있습니다. 다음은 이러한 경우 성능을 향상시키기 위해 수행 할 수있는 구성 변경입니다. 아래에 언급 된 경우를 제외하고 데이터베이스 소프트웨어의 충돌시 내구성은 여전히 ​​보장됩니다. 이러한 설정을 사용하면 갑작스러운 운영 체제 중지만으로 데이터가 손실되거나 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f1f3bb500eb22bbc0932ef88126441697bb253d" translate="yes" xml:space="preserve">
          <source>Duration relative to &lt;code&gt;md5 hash&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;md5 hash&lt;/code&gt; 관련된 기간</target>
        </trans-unit>
        <trans-unit id="02c6b2056e308ac26d87da4c64b11f9b031969c7" translate="yes" xml:space="preserve">
          <source>During a daylight-savings-time transition, it is possible for a seemingly valid timestamp string to represent a nonexistent or ambiguous timestamp. Such cases are not rejected; the ambiguity is resolved by determining which UTC offset to apply. For example, supposing that the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; parameter is set to &lt;code&gt;America/New_York&lt;/code&gt;, consider</source>
          <target state="translated">일광 절약 시간제 전환 중에는 유효한 타임 스탬프 문자열이 존재하지 않거나 모호한 타임 스탬프를 나타낼 수 있습니다. 이러한 경우는 기각되지 않습니다. 적용 할 UTC 오프셋을 결정하여 모호성을 해결합니다. 예를 들어, 것을 가정하여 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대의&lt;/a&gt; 매개 변수로 설정되어 &lt;code&gt;America/New_York&lt;/code&gt; , 고려</target>
        </trans-unit>
        <trans-unit id="649d7eaff87026bc3227c40d2cbf9934eabfe840" translate="yes" xml:space="preserve">
          <source>During a query that references any remote tables on a foreign server, &lt;code&gt;postgres_fdw&lt;/code&gt; opens a transaction on the remote server if one is not already open corresponding to the current local transaction. The remote transaction is committed or aborted when the local transaction commits or aborts. Savepoints are similarly managed by creating corresponding remote savepoints.</source>
          <target state="translated">외부 서버의 원격 테이블을 참조하는 쿼리 중에 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 원격 서버에서 현재 로컬 트랜잭션에 해당하는 트랜잭션이 아직 열려 있지 않은 경우 원격 서버에서 트랜잭션을 엽니 다. 로컬 트랜잭션이 커밋되거나 중단되면 원격 트랜잭션이 커밋되거나 중단됩니다. 저장 점은 해당 원격 저장 점을 작성하여 유사하게 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="376142efafb26017135a78a9b3a0f82b773855c9" translate="yes" xml:space="preserve">
          <source>During a series of insertions into an existing GIN index that has &lt;code&gt;fastupdate&lt;/code&gt; enabled, the system will clean up the pending-entry list whenever the list grows larger than &lt;code&gt;gin_pending_list_limit&lt;/code&gt;. To avoid fluctuations in observed response time, it's desirable to have pending-list cleanup occur in the background (i.e., via autovacuum). Foreground cleanup operations can be avoided by increasing &lt;code&gt;gin_pending_list_limit&lt;/code&gt; or making autovacuum more aggressive. However, enlarging the threshold of the cleanup operation means that if a foreground cleanup does occur, it will take even longer.</source>
          <target state="translated">&lt;code&gt;fastupdate&lt;/code&gt; 활성화 된 기존 GIN 인덱스에 일련의 삽입하는 동안 시스템은 목록이 &lt;code&gt;gin_pending_list_limit&lt;/code&gt; 보다 커질 때마다 보류중인 항목 목록을 정리합니다 . 관찰 된 응답 시간의 변동을 피하기 위해, 대기-목록 정리가 백그라운드에서 발생하는 것이 바람직하다 (즉, 자동 진공을 통해). &lt;code&gt;gin_pending_list_limit&lt;/code&gt; 를 늘리 거나 autovacuum을보다 공격적으로 만들면 전경 정리 작업을 피할 수 있습니다 . 그러나 정리 작업의 임계 값을 늘리면 포 그라운드 정리가 발생하면 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="e665b83d95fa89018b4471ab2b6da31bdceb1a0a" translate="yes" xml:space="preserve">
          <source>During actual execution of the query plan. Partition pruning may also be performed here to remove partitions using values which are only known during actual query execution. This includes values from subqueries and values from execution-time parameters such as those from parameterized nested loop joins. Since the value of these parameters may change many times during the execution of the query, partition pruning is performed whenever one of the execution parameters being used by partition pruning changes. Determining if partitions were pruned during this phase requires careful inspection of the &lt;code&gt;loops&lt;/code&gt; property in the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; output. Subplans corresponding to different partitions may have different values for it depending on how many times each of them was pruned during execution. Some may be shown as &lt;code&gt;(never executed)&lt;/code&gt; if they were pruned every time.</source>
          <target state="translated">쿼리 계획을 실제로 실행하는 동안 실제 쿼리 실행 중에 만 알려진 값을 사용하여 파티션을 제거하기 위해 파티션 정리를 수행 할 수도 있습니다. 여기에는 하위 쿼리의 값과 매개 변수화 된 중첩 루프 조인의 값과 같은 실행 시간 매개 변수의 값이 포함됩니다. 이러한 매개 변수의 값은 조회 실행 중에 여러 번 변경 될 수 있으므로, 파티션 프 루닝 변경에 의해 실행 매개 변수 중 하나가 사용될 때마다 파티션 프 루닝이 수행됩니다. 이 단계에서 파티션이 프룬되었는지 판별하려면 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에서 &lt;code&gt;loops&lt;/code&gt; 특성을 신중하게 검사해야합니다.산출. 다른 파티션에 해당하는 서브 플랜은 각 파티션이 실행 중에 정리 된 횟수에 따라 다른 값을 가질 수 있습니다. 매번 정리 된 경우 일부는 &lt;code&gt;(never executed)&lt;/code&gt; 않음)으로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63efb16fc413c0d7ad6b7e818ea4ee467528e158" translate="yes" xml:space="preserve">
          <source>During hot standby, the parameter &lt;code&gt;transaction_read_only&lt;/code&gt; is always true and may not be changed. But as long as no attempt is made to modify the database, connections during hot standby will act much like any other database connection. If failover or switchover occurs, the database will switch to normal processing mode. Sessions will remain connected while the server changes mode. Once hot standby finishes, it will be possible to initiate read-write transactions (even from a session begun during hot standby).</source>
          <target state="translated">상시 대기 중 &lt;code&gt;transaction_read_only&lt;/code&gt; 매개 변수 는 항상 true이며 변경할 수 없습니다. 그러나 데이터베이스를 수정하려고 시도하지 않는 한, 핫 스탠바이 동안의 연결은 다른 데이터베이스 연결과 매우 유사하게 작동합니다. 장애 조치 또는 전환이 발생하면 데이터베이스는 일반 처리 모드로 전환됩니다. 서버가 모드를 변경하는 동안 세션은 연결된 상태로 유지됩니다. 핫 스탠바이가 완료되면 (핫 스탠바이 중에 시작된 세션에서도) 읽기-쓰기 트랜잭션을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98920c65ae127f00513b833551d1231b0ae54aef" translate="yes" xml:space="preserve">
          <source>During initialization of the query plan. Partition pruning can be performed here for parameter values which are known during the initialization phase of execution. Partitions which are pruned during this stage will not show up in the query's &lt;code&gt;EXPLAIN&lt;/code&gt; or &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. It is possible to determine the number of partitions which were removed during this phase by observing the &amp;ldquo;Subplans Removed&amp;rdquo; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">쿼리 계획을 초기화하는 동안 실행 초기화 단계에서 알려진 매개 변수 값에 대해 파티션 정리를 수행 할 수 있습니다. 이 단계에서 정리 된 파티션은 쿼리의 &lt;code&gt;EXPLAIN&lt;/code&gt; 또는 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에 표시되지 않습니다 . &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 에서 &quot;Subplans Removed&quot;속성을 관찰하여이 단계 동안 제거 된 파티션 수를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd1cf4071c0223f011ef29f707521b1833e5ad0" translate="yes" xml:space="preserve">
          <source>During installation an appropriate configuration is selected and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; is set accordingly in &lt;code&gt;postgresql.conf&lt;/code&gt;. If you are using the same text search configuration for the entire cluster you can use the value in &lt;code&gt;postgresql.conf&lt;/code&gt;. To use different configurations throughout the cluster but the same configuration within any one database, use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;. Otherwise, you can set &lt;code&gt;default_text_search_config&lt;/code&gt; in each session.</source>
          <target state="translated">설치하는 동안 적절한 구성이 선택되고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 가 설정됩니다 . 전체 클러스터에 대해 동일한 텍스트 검색 구성을 사용하는 경우 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 값을 사용할 수 있습니다 . 클러스터 전체에서 다른 구성을 사용하지만 한 데이터베이스 내에서 동일한 구성을 사용하려면 &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt; . 그렇지 않으면 각 세션에서 &lt;code&gt;default_text_search_config&lt;/code&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eccf031bb1a6ebed76c6dc48278b20f95064a8ed" translate="yes" xml:space="preserve">
          <source>During server startup, parameter settings can be passed to the &lt;code&gt;postgres&lt;/code&gt; command via the &lt;code&gt;-c&lt;/code&gt; command-line parameter. For example,</source>
          <target state="translated">서버 시작 중에 &lt;code&gt;-c&lt;/code&gt; 명령 줄 매개 변수 를 통해 매개 변수 설정을 &lt;code&gt;postgres&lt;/code&gt; 명령 으로 전달할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="079a296ff5b5be1f0458b0eea0b5b8b0a01f3f04" translate="yes" xml:space="preserve">
          <source>During the execution of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; commands, the system maintains an internal counter that keeps track of the estimated cost of the various I/O operations that are performed. When the accumulated cost reaches a limit (specified by &lt;code&gt;vacuum_cost_limit&lt;/code&gt;), the process performing the operation will sleep for a short period of time, as specified by &lt;code&gt;vacuum_cost_delay&lt;/code&gt;. Then it will reset the counter and continue execution.</source>
          <target state="translated">&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하는 동안 시스템은 수행되는 다양한 I / O 작업의 예상 비용을 추적하는 내부 카운터를 유지 관리합니다. 누적 비용이 한계에 도달하면 ( &lt;code&gt;vacuum_cost_limit&lt;/code&gt; 로 지정됨 ) vacuum_cost_delay에 지정된대로 조작을 수행하는 프로세스가 짧은 시간 동안 휴면 상태가 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; . 그런 다음 카운터를 재설정하고 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="87a76b8e4b15674f0f67d6633c956f38b093285c" translate="yes" xml:space="preserve">
          <source>Dynamic Tracing</source>
          <target state="translated">동적 추적</target>
        </trans-unit>
        <trans-unit id="713a44108c01ba93077b4f4f0d58807f38a85305" translate="yes" xml:space="preserve">
          <source>Dynamic domain transitions should be considered carefully, because they allow users to switch their label, and therefore their privileges, at their option, rather than (as in the case of a trusted procedure) as mandated by the system. Thus, the &lt;code&gt;dyntransition&lt;/code&gt; permission is only considered safe when used to switch to a domain with a smaller set of privileges than the original one. For example:</source>
          <target state="translated">동적 도메인 전환은 사용자가 시스템에서 지정한대로 (신뢰할 수있는 절차의 경우와 같이) 자신의 선택에 따라 레이블과 권한을 전환 할 수 있도록주의해서 고려해야합니다. 따라서 &lt;code&gt;dyntransition&lt;/code&gt; 권한은 원래 권한보다 더 작은 권한 집합을 가진 도메인으로 전환하는 데 사용될 때만 안전한 것으로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c124e6336755449222656c78278aee8224bd8a12" translate="yes" xml:space="preserve">
          <source>Dynamically loadable modules work, including &lt;code&gt;pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 를 포함하여 동적으로로드 가능한 모듈이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6a879b77c2521dc21654838b1ef36fe63eea51a7" translate="yes" xml:space="preserve">
          <source>E-Mail of Cryptocom OpenSSL development group: &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:openssl@cryptocom.ru&quot;&gt;openssl@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Cryptocom OpenSSL 개발 그룹의 이메일 : &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:openssl@cryptocom.ru&quot;&gt;openssl@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9444b51afb6d88079dadef6a3aae007418cea1d" translate="yes" xml:space="preserve">
          <source>EAN13 numbers aren't always ISBN13, ISMN13 or ISSN13 (some are).</source>
          <target state="translated">EAN13 번호가 항상 ISBN13, ISMN13 또는 ISSN13 (일부) 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6544628da02c21bc6dadd46248d452c1cf9af913" translate="yes" xml:space="preserve">
          <source>ECPG</source>
          <target state="translated">ECPG</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="8fac2036001ae3f80847916907033e4cfe81af30" translate="yes" xml:space="preserve">
          <source>END &amp;mdash; commit the current transaction</source>
          <target state="translated">종료 &amp;mdash; 현재 거래 커밋</target>
        </trans-unit>
        <trans-unit id="1608f513c48df25cff4b9dccf8ad4db68426771c" translate="yes" xml:space="preserve">
          <source>ESQL</source>
          <target state="translated">ESQL</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="790392d6b839abbb5b061152b6a3114de84502b4" translate="yes" xml:space="preserve">
          <source>EXECUTE</source>
          <target state="translated">EXECUTE</target>
        </trans-unit>
        <trans-unit id="c4cb7766ac2508346a678d94a4e10d75ba028e5b" translate="yes" xml:space="preserve">
          <source>EXECUTE &amp;mdash; execute a prepared statement</source>
          <target state="translated">EXECUTE &amp;mdash; 준비된 문장을 실행</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="efc2c00ebfdf6ae3c760f83f873743b150a0fd4b" translate="yes" xml:space="preserve">
          <source>EXPLAIN &amp;mdash; show the execution plan of a statement</source>
          <target state="translated">EXPLAIN &amp;mdash; 문장의 실행 계획을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="0eef064be41e6afcc8812bb71602a4ebf2f8f3c9" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;.dat&lt;/code&gt; file contains Perl data structure literals that are simply eval'd to produce an in-memory data structure consisting of an array of hash references, one per catalog row. A slightly modified excerpt from &lt;code&gt;pg_database.dat&lt;/code&gt; will demonstrate the key features:</source>
          <target state="translated">각 &lt;code&gt;.dat&lt;/code&gt; 파일에는 카탈로그 행당 하나씩 해시 참조 배열로 구성된 메모리 내 데이터 구조를 생성하기 위해 평가 된 Perl 데이터 구조 리터럴이 포함되어 있습니다. &lt;code&gt;pg_database.dat&lt;/code&gt; 에서 약간 수정 된 내용은 다음 과 같은 주요 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52629a868eedbea648b7a4a638a5af4aed7eaf71" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;amcostestimate&lt;/code&gt; function must have the signature:</source>
          <target state="translated">각 &lt;code&gt;amcostestimate&lt;/code&gt; 함수에는 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee555043838db244d6461d0e5cd48e5593131cd6" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;expression&lt;/code&gt; can be the name or ordinal number of an output column (&lt;code&gt;SELECT&lt;/code&gt; list item), or it can be an arbitrary expression formed from input-column values.</source>
          <target state="translated">각 &lt;code&gt;expression&lt;/code&gt; 은 출력 열의 이름 또는 서수 ( &lt;code&gt;SELECT&lt;/code&gt; 목록 항목)이거나 입력 열 값으로 구성된 임의의 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1490188fec78ab89e976340e8a306b20caeaa221" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;standby_name&lt;/code&gt; should have the form of a valid SQL identifier, unless it is &lt;code&gt;*&lt;/code&gt;. You can use double-quoting if necessary. But note that &lt;code&gt;standby_name&lt;/code&gt;s are compared to standby application names case-insensitively, whether double-quoted or not.</source>
          <target state="translated">각 &lt;code&gt;standby_name&lt;/code&gt; 은 &lt;code&gt;*&lt;/code&gt; 가 아닌 한 유효한 SQL 식별자 형식이어야합니다 . 필요한 경우 큰 따옴표를 사용할 수 있습니다. 그러나 &lt;code&gt;standby_name&lt;/code&gt; 은 인용 부호에 관계없이 대소 문자를 구분하지 않고 대기 애플리케이션 이름과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cfcd2e76e362b6545b1b1ab46191393e33b3c350" translate="yes" xml:space="preserve">
          <source>Each ISO 8601 week-numbering year begins with the Monday of the week containing the 4th of January, so in early January or late December the ISO year may be different from the Gregorian year. See the &lt;code&gt;week&lt;/code&gt; field for more information.</source>
          <target state="translated">각 ISO 8601 주 번호 매기기 연도는 1 월 4 일을 포함하는 주 월요일부터 시작되므로 1 월 초 또는 12 월 말에 ISO 연도가 그레고리력 연도와 다를 수 있습니다. 자세한 내용은 &lt;code&gt;week&lt;/code&gt; 필드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96f0f5a7b759cd740a7c972fd3ab3c64864cb957" translate="yes" xml:space="preserve">
          <source>Each SQL command string passed to &lt;code&gt;-c&lt;/code&gt; is sent to the server as a single request. Because of this, the server executes it as a single transaction even if the string contains multiple SQL commands, unless there are explicit &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt; commands included in the string to divide it into multiple transactions. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;Section 52.2.2.1&lt;/a&gt; for more details about how the server handles multi-query strings.) Also, psql only prints the result of the last SQL command in the string. This is different from the behavior when the same string is read from a file or fed to psql's standard input, because then psql sends each SQL command separately.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 에 전달 된 각 SQL 명령 문자열 은 단일 요청으로 서버에 전송됩니다. 이로 인해, 문자열 에 여러 트랜잭션으로 나누기 위해 명시적인 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 명령이 포함되어 있지 않으면 서버는 문자열에 여러 SQL 명령이 포함되어 있어도 단일 트랜잭션으로 서버를 실행합니다 . ( 서버가 다중 쿼리 문자열을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;52.2.2.1 단원&lt;/a&gt; 을 참조하십시오.) 또한 psql은 문자열에서 마지막 SQL 명령의 결과 만 인쇄합니다. 이는 psql이 각 SQL 명령을 개별적으로 전송하기 때문에 파일에서 동일한 문자열을 읽거나 psql의 표준 입력으로 공급할 때의 동작과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eda9854e68bbff726bf168438cbf61263c89d2cc" translate="yes" xml:space="preserve">
          <source>Each SQL transaction has an isolation level, which can be either &amp;ldquo;read uncommitted&amp;rdquo;, &amp;ldquo;read committed&amp;rdquo;, &amp;ldquo;repeatable read&amp;rdquo;, or &amp;ldquo;serializable&amp;rdquo;. This parameter controls the default isolation level of each new transaction. The default is &amp;ldquo;read committed&amp;rdquo;.</source>
          <target state="translated">각 SQL 트랜잭션에는 분리 커밋 수준이 있으며 &quot;커밋되지 않은 읽기&quot;, &quot;읽기 커밋 된&quot;, &quot;반복 가능한 읽기&quot;또는 &quot;직렬화 가능&quot;일 수 있습니다. 이 매개 변수는 각 새 트랜잭션의 기본 격리 레벨을 제어합니다. 기본값은 &quot;읽기 커밋&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2844b82e9d99613d9651694329c65d9f27ce77dc" translate="yes" xml:space="preserve">
          <source>Each TOAST-able data type specifies a default strategy for columns of that data type, but the strategy for a given table column can be altered with &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ... SET STORAGE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 TOAST 가능 데이터 유형은 해당 데이터 유형의 컬럼에 대한 기본 전략을 지정하지만 주어진 테이블 컬럼에 대한 전략은 &lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ... SET STORAGE&lt;/code&gt; &lt;/a&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55aff67e18553aba02a98a4064e139e4057218c6" translate="yes" xml:space="preserve">
          <source>Each bound value can be quoted using &lt;code&gt;&quot;&lt;/code&gt; (double quote) characters. This is necessary if the bound value contains parentheses, brackets, commas, double quotes, or backslashes, since these characters would otherwise be taken as part of the range syntax. To put a double quote or backslash in a quoted bound value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted bound value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as range syntax. Also, to write a bound value that is an empty string, write &lt;code&gt;&quot;&quot;&lt;/code&gt;, since writing nothing means an infinite bound.</source>
          <target state="translated">각 바운드 값은 &lt;code&gt;&quot;&lt;/code&gt; (큰 따옴표) 문자를 사용하여 따옴표로 묶을 수 있습니다 . 바운드 값에 괄호, 괄호, 쉼표, 큰 따옴표 또는 백 슬래시가 포함 된 경우에는 이러한 문자가 범위 구문의 일부로 사용되기 때문에 필요합니다. 따옴표로 묶인 바운드 값의 큰 따옴표 또는 백 슬래시 앞에 백 슬래시를 붙입니다. (또한 큰 따옴표로 묶인 바운드 값 내의 큰 따옴표 쌍은 SQL의 작은 따옴표 규칙과 유사하게 큰 따옴표 문자를 나타 내기 위해 사용됩니다. 리터럴 문자열.) 또는 인용 부호를 피하고 백 슬래시 이스케이프를 사용하여 범위 구문으로 간주 될 모든 데이터 문자를 보호 할 수 있으며 빈 문자열 인 바운드 값을 쓰려면 아무 것도 쓰지 않기 때문에 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 쓰십시오 무한한 한계.</target>
        </trans-unit>
        <trans-unit id="0a72f66856b3e613b196ae8833ef35864d4174d8" translate="yes" xml:space="preserve">
          <source>Each catalog that has any manually-created initial data (some do not) has a corresponding &lt;code&gt;.dat&lt;/code&gt; file that contains its initial data in an editable format.</source>
          <target state="translated">수동으로 만든 초기 데이터가있는 각 카탈로그 (일부에는없는)에는 편집 가능한 형식의 초기 데이터가 포함 된 해당 &lt;code&gt;.dat&lt;/code&gt; 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34807a2fc50e85269825ffe29ec3e43edacd5b30" translate="yes" xml:space="preserve">
          <source>Each column has a data type. The data type constrains the set of possible values that can be assigned to a column and assigns semantics to the data stored in the column so that it can be used for computations. For instance, a column declared to be of a numerical type will not accept arbitrary text strings, and the data stored in such a column can be used for mathematical computations. By contrast, a column declared to be of a character string type will accept almost any kind of data but it does not lend itself to mathematical calculations, although other operations such as string concatenation are available.</source>
          <target state="translated">각 열에는 데이터 형식이 있습니다. 데이터 형식은 열에 할당 할 수있는 가능한 값 집합을 제한하고 계산에 사용할 수 있도록 열에 저장된 데이터에 의미를 할당합니다. 예를 들어, 숫자 유형으로 선언 된 열은 임의의 텍스트 문자열을 허용하지 않으며 이러한 열에 저장된 데이터는 수학 계산에 사용될 수 있습니다. 반대로, 문자열 유형으로 선언 된 열은 거의 모든 종류의 데이터를 허용하지만 문자열 연결과 같은 다른 연산을 사용할 수는 있지만 수학 계산에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4d4f8ac998bb0bf76d30e14459d3ffb4f3fdd7a" translate="yes" xml:space="preserve">
          <source>Each column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.</source>
          <target state="translated">명시 적 또는 내재적 열 목록에없는 각 열은 기본값으로 선언 된 기본값이거나 채워지지 않은 경우 널로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="2cd0b247f063881e4120caeaa0c5cc15f8c99e31" translate="yes" xml:space="preserve">
          <source>Each column specification can be a column number (starting at 1) or a column name. The usual SQL case folding and quoting rules apply to column names. If omitted, &lt;code&gt;colV&lt;/code&gt; is taken as column 1 and &lt;code&gt;colH&lt;/code&gt; as column 2. &lt;code&gt;colH&lt;/code&gt; must differ from &lt;code&gt;colV&lt;/code&gt;. If &lt;code&gt;colD&lt;/code&gt; is not specified, then there must be exactly three columns in the query result, and the column that is neither &lt;code&gt;colV&lt;/code&gt; nor &lt;code&gt;colH&lt;/code&gt; is taken to be &lt;code&gt;colD&lt;/code&gt;.</source>
          <target state="translated">각 열 스펙은 열 번호 (1부터 시작) 또는 열 이름 일 수 있습니다. 일반적인 SQL 케이스 접기 및 인용 규칙은 열 이름에 적용됩니다. 생략하면 &lt;code&gt;colV&lt;/code&gt; 는 열 1로, &lt;code&gt;colH&lt;/code&gt; 는 열 2로 &lt;code&gt;colH&lt;/code&gt; &lt;code&gt;colV&lt;/code&gt; . colH 는 colV 와 달라야 합니다 . 경우 &lt;code&gt;colD&lt;/code&gt; 지정되어 있지 않은 경우, 정확히 3 질의 결과에서 열 및도 아닌 열이 있어야합니다 &lt;code&gt;colV&lt;/code&gt; 도 &lt;code&gt;colH&lt;/code&gt; 가 로 촬영 &lt;code&gt;colD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d401dabac1c5a63cbaa2ae914726d49a76a34df4" translate="yes" xml:space="preserve">
          <source>Each data type has an external representation determined by its input and output functions. Many of the built-in types have obvious external formats. However, several types are either unique to PostgreSQL, such as geometric paths, or have several possible formats, such as the date and time types. Some of the input and output functions are not invertible, i.e., the result of an output function might lose accuracy when compared to the original input.</source>
          <target state="translated">각 데이터 유형에는 입력 및 출력 기능에 의해 결정되는 외부 표현이 있습니다. 많은 내장 유형에는 명백한 외부 형식이 있습니다. 그러나 여러 유형은 기하학적 경로와 같은 PostgreSQL에 고유하거나 날짜 및 시간 유형과 같은 여러 가지 가능한 형식을 갖습니다. 일부 입력 및 출력 기능은 되돌릴 수 없습니다. 즉, 출력 기능의 결과는 원래 입력과 비교할 때 정확도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9202ff880e980c6a970df736a03fbff970d67727" translate="yes" xml:space="preserve">
          <source>Each enumerated data type is separate and cannot be compared with other enumerated types. See this example:</source>
          <target state="translated">열거 된 각 데이터 형식은 별개이므로 다른 열거 된 형식과 비교할 수 없습니다. 이 예제를보십시오 :</target>
        </trans-unit>
        <trans-unit id="70e86803855d294ff554c4470870fa79b45f5d14" translate="yes" xml:space="preserve">
          <source>Each function performs the visibility check for one type of database object. Note that &lt;code&gt;pg_table_is_visible&lt;/code&gt; can also be used with views, materialized views, indexes, sequences and foreign tables; &lt;code&gt;pg_function_is_visible&lt;/code&gt; can also be used with procedures and aggregates; &lt;code&gt;pg_type_is_visible&lt;/code&gt; can also be used with domains. For functions and operators, an object in the search path is visible if there is no object of the same name &lt;em&gt;and argument data type(s)&lt;/em&gt; earlier in the path. For operator classes, both name and associated index access method are considered.</source>
          <target state="translated">각 함수는 한 가지 유형의 데이터베이스 개체에 대한 가시성 검사를 수행합니다. 참고 &lt;code&gt;pg_table_is_visible&lt;/code&gt; 는 또한 뷰와 함께 사용할 수 있습니다, 뷰, 인덱스, 시퀀스 및 외국 테이블을 구체화; &lt;code&gt;pg_function_is_visible&lt;/code&gt; 은 프로 시저 및 집계와 함께 사용할 수도 있습니다. &lt;code&gt;pg_type_is_visible&lt;/code&gt; 을 도메인과 함께 사용할 수도 있습니다. 함수와 연산자의 경우 경로에 이름 &lt;em&gt;과 인수 데이터 유형&lt;/em&gt; 이 같은 개체가 없으면 검색 경로의 개체가 표시됩니다 . 연산자 클래스의 경우 이름 및 연관된 인덱스 액세스 방법이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb437189cdd5811ffdded3ab110033cbf3f1b5f" translate="yes" xml:space="preserve">
          <source>Each heap and index relation, except for hash indexes, has a Free Space Map (FSM) to keep track of available space in the relation. It's stored alongside the main relation data in a separate relation fork, named after the filenode number of the relation, plus a &lt;code&gt;_fsm&lt;/code&gt; suffix. For example, if the filenode of a relation is 12345, the FSM is stored in a file called &lt;code&gt;12345_fsm&lt;/code&gt;, in the same directory as the main relation file.</source>
          <target state="translated">해시 인덱스를 제외한 각 힙 및 인덱스 관계에는 관계에서 사용 가능한 공간을 추적하기위한 FSM (Free Space Map)이 있습니다. 주요 관계 데이터와 함께 관계의 파일 노드 번호와 &lt;code&gt;_fsm&lt;/code&gt; 접미사를 따서 명명 된 별도의 관계 포크에 저장 됩니다. 예를 들어, 관계의 파일 &lt;code&gt;12345_fsm&lt;/code&gt; 가 12345 인 경우 FSM은 기본 관계 파일과 동일한 디렉토리에 12345_fsm 이라는 파일에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="bde5bfb2a3b2ea3516a48dc94ba28c29e2c03d67" translate="yes" xml:space="preserve">
          <source>Each heap relation has a Visibility Map (VM) to keep track of which pages contain only tuples that are known to be visible to all active transactions; it also keeps track of which pages contain only frozen tuples. It's stored alongside the main relation data in a separate relation fork, named after the filenode number of the relation, plus a &lt;code&gt;_vm&lt;/code&gt; suffix. For example, if the filenode of a relation is 12345, the VM is stored in a file called &lt;code&gt;12345_vm&lt;/code&gt;, in the same directory as the main relation file. Note that indexes do not have VMs.</source>
          <target state="translated">각 힙 관계에는 모든 활성 트랜잭션에 표시되는 것으로 알려진 튜플이 포함 된 페이지를 추적하는 가시성 맵 (VM)이 있습니다. 또한 고정 된 튜플 만 포함하는 페이지를 추적합니다. 기본 관계 데이터와 함께 관계의 파일 노드 번호와 &lt;code&gt;_vm&lt;/code&gt; 접미사를 따서 명명 된 별도의 관계 포크에 저장 됩니다. 예를 들어, 관계의 파일 &lt;code&gt;12345_vm&lt;/code&gt; 가 12345 인 경우 VM은 기본 관계 파일과 동일한 디렉토리에 12345_vm 이라는 파일에 저장 됩니다. 인덱스에는 VM이 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="d83c0ee46ab5aec7f645ecee3bc6fee47067fe37" translate="yes" xml:space="preserve">
          <source>Each index access method is described by a row in the &lt;a href=&quot;catalog-pg-am&quot;&gt;&lt;code&gt;pg_am&lt;/code&gt;&lt;/a&gt; system catalog. The &lt;code&gt;pg_am&lt;/code&gt; entry specifies a name and a &lt;em&gt;handler function&lt;/em&gt; for the index access method. These entries can be created and deleted using the &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; and &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL commands.</source>
          <target state="translated">각 인덱스 액세스 방법은 &lt;a href=&quot;catalog-pg-am&quot;&gt; &lt;code&gt;pg_am&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그 의 행으로 설명됩니다 . &lt;code&gt;pg_am&lt;/code&gt; 의 항목은 이름과 지정 &lt;em&gt;핸들러 함수&lt;/em&gt; 인덱스 액세스 방법이있다. 이 항목은 &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL 명령을 사용하여 작성 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="181d4444400920b544aae648daddcab396dab897" translate="yes" xml:space="preserve">
          <source>Each individual record in a WAL file is protected by a CRC-32 (32-bit) check that allows us to tell if record contents are correct. The CRC value is set when we write each WAL record and checked during crash recovery, archive recovery and replication.</source>
          <target state="translated">WAL 파일의 각 개별 레코드는 CRC-32 (32 비트) 검사로 보호되므로 레코드 내용이 올바른지 알 수 있습니다. CRC 값은 각 WAL 레코드를 쓸 때 설정되며 응급 복구, 아카이브 복구 및 복제 중에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="542120034dc0135bcba8fedcb62c0e5f5267d887" translate="yes" xml:space="preserve">
          <source>Each job is one process or one thread, depending on the operating system, and uses a separate connection to the server.</source>
          <target state="translated">각 작업은 운영 체제에 따라 하나의 프로세스 또는 하나의 스레드이며 서버에 대한 별도의 연결을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b38f7992dc346f7b5d0eda049bdeffb8af610ff4" translate="yes" xml:space="preserve">
          <source>Each key in an &lt;code&gt;hstore&lt;/code&gt; is unique. If you declare an &lt;code&gt;hstore&lt;/code&gt; with duplicate keys, only one will be stored in the &lt;code&gt;hstore&lt;/code&gt; and there is no guarantee as to which will be kept:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 각 키 는 고유합니다. 당신이 선언하면 &lt;code&gt;hstore&lt;/code&gt; 을 중복 키를 사용하여, 하나는에 저장됩니다 &lt;code&gt;hstore&lt;/code&gt; 및 유지 될에 관해서는 보장은 없습니다 :</target>
        </trans-unit>
        <trans-unit id="11bc7d32ed41735d7a7637cde449142c78ff4596" translate="yes" xml:space="preserve">
          <source>Each line represents a group of synonyms for a single word, which is given first on the line. Synonyms are separated by whitespace, thus:</source>
          <target state="translated">각 줄은 한 단어에 대한 동의어 그룹을 나타냅니다. 동의어는 공백으로 구분되므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f37fe98f5d306326dfab1b4227b4a2ceb6a13a80" translate="yes" xml:space="preserve">
          <source>Each line represents one translation rule, consisting of a character with accent followed by a character without accent. The first is translated into the second. For example,</source>
          <target state="translated">각 줄은 하나의 변환 규칙을 나타내며 악센트가있는 문자와 악센트가없는 문자로 구성됩니다. 첫 번째는 두 번째로 번역됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8f29b2cb20607f0de648e5996c4daf9f4a539aeb" translate="yes" xml:space="preserve">
          <source>Each of the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;Table 9.58&lt;/a&gt; is associated with a window function of the same name defined in &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;. In each case, the aggregate result is the value that the associated window function would have returned for the &amp;ldquo;hypothetical&amp;rdquo; row constructed from &lt;code&gt;args&lt;/code&gt;, if such a row had been added to the sorted group of rows computed from the &lt;code&gt;sorted_args&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;표 9.58에&lt;/a&gt; 나열된 각 집계 는 &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21에&lt;/a&gt; 정의 된 동일한 이름의 창 함수와 연관됩니다 . 각각의 경우 집계 결과는 &lt;code&gt;sorted_args&lt;/code&gt; 에서 계산 된 정렬 된 행 그룹에 해당 행이 추가 된 경우 &lt;code&gt;args&lt;/code&gt; 로 구성된 &quot;가상&quot;행에 대해 연관된 창 함수가 리턴 한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="c1241bdfba73578126cf6ac1b2eac99aae13e728" translate="yes" xml:space="preserve">
          <source>Each of the groups of functions described below is provided as a separately-installable extension.</source>
          <target state="translated">아래에 설명 된 각 기능 그룹은 별도로 설치 가능한 확장으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="50960f9603aec9053de8ce026fa8b9bad3694f86" translate="yes" xml:space="preserve">
          <source>Each of these functions returns &lt;code&gt;true&lt;/code&gt; if successful and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">이러한 각 함수는 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5aadeec9bfb43fa57316615de66c4aef9c8a773" translate="yes" xml:space="preserve">
          <source>Each of these reasons dictates performing &lt;code&gt;VACUUM&lt;/code&gt; operations of varying frequency and scope, as explained in the following subsections.</source>
          <target state="translated">이러한 각 이유는 다음 하위 섹션에 설명 된대로 다양한 주파수 및 범위의 &lt;code&gt;VACUUM&lt;/code&gt; 작업을 수행하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="4cac5c8759285e213ca52d09af21f1ad8f3faebb" translate="yes" xml:space="preserve">
          <source>Each page is typically 8 kilobytes. (Remember, &lt;code&gt;relpages&lt;/code&gt; is only updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.) The file path name is of interest if you want to examine the table's disk file directly.</source>
          <target state="translated">각 페이지는 일반적으로 8 킬로바이트입니다. (기억 &lt;code&gt;relpages&lt;/code&gt; 이 만 업데이트됩니다 &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; , 몇 DDL은 다음과 같은 명령을 &lt;code&gt;CREATE INDEX&lt;/code&gt; 를 .) 파일 경로 이름은 관심을 당신이 직접 테이블의 디스크 파일을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b29fd5f9859281b104853180c6852f111f06e0a6" translate="yes" xml:space="preserve">
          <source>Each parenthesized list of expressions generates a row in the table. The lists must all have the same number of elements (i.e., the number of columns in the table), and corresponding entries in each list must have compatible data types. The actual data type assigned to each column of the result is determined using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">괄호로 묶은 각 표현식 목록은 테이블에 행을 생성합니다. 목록은 모두 동일한 수의 요소 (예 : 테이블의 열 수)를 가져야하며 각 목록의 해당 항목은 호환 가능한 데이터 유형을 가져야합니다. 결과의 각 열에 할당 된 실제 데이터 유형은 &lt;code&gt;UNION&lt;/code&gt; 과 동일한 규칙을 사용하여 결정됩니다 ( &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1744b77868ba36643b35518a8f8800e30eb35f9f" translate="yes" xml:space="preserve">
          <source>Each policy has a name and multiple policies can be defined for a table. As policies are table-specific, each policy for a table must have a unique name. Different tables may have policies with the same name.</source>
          <target state="translated">각 정책에는 이름이 있으며 테이블에 대해 여러 정책을 정의 할 수 있습니다. 정책은 테이블별로 다르므로 테이블에 대한 각 정책의 이름은 고유해야합니다. 다른 테이블에는 동일한 이름의 정책이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5bbed626ca3e97951a441f33d6e26844cab0c1" translate="yes" xml:space="preserve">
          <source>Each range type has a constructor function with the same name as the range type. Using the constructor function is frequently more convenient than writing a range literal constant, since it avoids the need for extra quoting of the bound values. The constructor function accepts two or three arguments. The two-argument form constructs a range in standard form (lower bound inclusive, upper bound exclusive), while the three-argument form constructs a range with bounds of the form specified by the third argument. The third argument must be one of the strings &amp;ldquo;&lt;code&gt;()&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;(]&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;[)&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;[]&lt;/code&gt;&amp;rdquo;. For example:</source>
          <target state="translated">각 범위 유형에는 범위 유형과 이름이 같은 생성자 함수가 있습니다. 생성자 함수를 사용하면 범위 리터럴 상수를 작성하는 것보다 바운드 값을 추가로 인용 할 필요가 없으므로 편리합니다. 생성자 함수는 2 개 또는 3 개의 인수를 허용합니다. 2 인수 형식은 표준 형식 (하한값 포함, 상한값 독점)으로 범위를 구성하는 반면 3 인수 형식은 세 번째 인수로 지정된 형식의 범위로 범위를 구성합니다. 세 번째 인수는 문자열 &quot; &lt;code&gt;()&lt;/code&gt; &quot;, &quot; &lt;code&gt;(]&lt;/code&gt; &quot;, &quot; &lt;code&gt;[)&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;[]&lt;/code&gt; &quot; 중 하나 여야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e2bf65321e7b74210e532591a945c9830329341" translate="yes" xml:space="preserve">
          <source>Each record specifies a connection type, a client IP address range (if relevant for the connection type), a database name, a user name, and the authentication method to be used for connections matching these parameters. The first record with a matching connection type, client address, requested database, and user name is used to perform authentication. There is no &amp;ldquo;fall-through&amp;rdquo; or &amp;ldquo;backup&amp;rdquo;: if one record is chosen and the authentication fails, subsequent records are not considered. If no record matches, access is denied.</source>
          <target state="translated">각 레코드는 연결 유형, 클라이언트 IP 주소 범위 (연결 유형과 관련된 경우), 데이터베이스 이름, 사용자 이름 및 이러한 매개 변수와 일치하는 연결에 사용되는 인증 방법을 지정합니다. 연결 유형, 클라이언트 주소, 요청 된 데이터베이스 및 사용자 이름이 일치하는 첫 번째 레코드가 인증을 수행하는 데 사용됩니다. &quot;fall-through&quot;또는 &quot;backup&quot;은 없습니다. 하나의 레코드를 선택하고 인증에 실패하면 후속 레코드는 고려되지 않습니다. 일치하는 레코드가 없으면 액세스가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="93486fa5bd5a52fe6d58233709c3e4afeee246ef" translate="yes" xml:space="preserve">
          <source>Each replication slot has a name, which can contain lower-case letters, numbers, and the underscore character.</source>
          <target state="translated">각 복제 슬롯에는 이름이 있으며 소문자, 숫자 및 밑줄 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714ca6d72fba05d3addae8d6cd117d5f8c7ed46e" translate="yes" xml:space="preserve">
          <source>Each row of &lt;code&gt;pg_largeobject&lt;/code&gt; holds data for one page of a large object, beginning at byte offset (&lt;code&gt;pageno * LOBLKSIZE&lt;/code&gt;) within the object. The implementation allows sparse storage: pages might be missing, and might be shorter than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes even if they are not the last page of the object. Missing regions within a large object read as zeroes.</source>
          <target state="translated">&lt;code&gt;pg_largeobject&lt;/code&gt; 의 각 행은 객체 내에서 바이트 오프셋 ( &lt;code&gt;pageno * LOBLKSIZE&lt;/code&gt; )에서 시작하여 큰 객체의 한 페이지에 대한 데이터를 보유 합니다. 이 구현은 스파 스 저장을 허용합니다. 페이지가 누락되었거나 객체의 마지막 페이지가 아닌 경우에도 &lt;code&gt;LOBLKSIZE&lt;/code&gt; 바이트 보다 짧을 수 있습니다 . 큰 객체 내에 누락 된 영역은 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7563f681a972af2d750923993e463dd76792481c" translate="yes" xml:space="preserve">
          <source>Each side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The two row values must have the same number of fields. Each side is evaluated and they are compared row-wise. Row constructor comparisons are allowed when the &lt;code&gt;operator&lt;/code&gt; is &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. Every row element must be of a type which has a default B-tree operator class or the attempted comparison may generate an error.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;4.2.13 절&lt;/a&gt; 에서 설명한 것처럼 각면은 행 생성자 입니다. 두 개의 행 값은 동일한 수의 필드를 가져야합니다. 각면이 평가되고 행 단위로 비교됩니다. &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 인 경우 행 생성자 비교가 허용됩니다 . 모든 행 요소는 기본 B- 트리 연산자 클래스가있는 유형이어야합니다. 그렇지 않으면 비교를 시도하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f52ee79936460cf46e9e8bc3284b90d60086864" translate="yes" xml:space="preserve">
          <source>Each side is evaluated and they are compared row-wise. Composite type comparisons are allowed when the &lt;code&gt;operator&lt;/code&gt; is &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;, or has semantics similar to one of these. (To be specific, an operator can be a row comparison operator if it is a member of a B-tree operator class, or is the negator of the &lt;code&gt;=&lt;/code&gt; member of a B-tree operator class.) The default behavior of the above operators is the same as for &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; for row constructors (see &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;).</source>
          <target state="translated">각면이 평가되고 행 단위로 비교됩니다. &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 이거나 이들 중 하나와 유사한 의미 가있는 경우 복합 유형 비교가 허용됩니다 . 구체적으로, 연산자는 B- 트리 연산자 클래스의 멤버이거나 B- 트리 연산자 클래스의 &lt;code&gt;=&lt;/code&gt; 멤버에 대한 부정 인 경우 행 비교 연산자 일 수 있습니다 . 위 연산자의 기본 동작 행 생성자에 대한 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 과 동일합니다 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;섹션 9.23.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3a16e416687c1027abc371b1bdfdb07eec0683b0" translate="yes" xml:space="preserve">
          <source>Each sublist of &lt;code&gt;GROUPING SETS&lt;/code&gt; may specify zero or more columns or expressions and is interpreted the same way as though it were directly in the &lt;code&gt;GROUP BY&lt;/code&gt; clause. An empty grouping set means that all rows are aggregated down to a single group (which is output even if no input rows were present), as described above for the case of aggregate functions with no &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;GROUPING SETS&lt;/code&gt; 의 각 하위 목록은 0 개 이상의 열 또는 표현식을 지정할 수 있으며 &lt;code&gt;GROUP BY&lt;/code&gt; 절에 직접있는 것처럼 동일한 방식으로 해석 됩니다. 빈 그룹화 세트는 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없는 집계 함수의 경우 위에서 설명한대로 모든 행이 단일 그룹 (입력 행이없는 경우에도 출력 됨)으로 집계됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="712d108aedc3ee50932324d38a0347254415d7fa" translate="yes" xml:space="preserve">
          <source>Each subscription will receive changes via one replication slot (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). Additional temporary replication slots may be required for the initial data synchronization of pre-existing table data.</source>
          <target state="translated">각 구독은 하나의 복제 슬롯을 통해 변경 사항을 수신합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;26.2.6 절&lt;/a&gt; 참조 ). 기존 테이블 데이터의 초기 데이터 동기화를 위해 추가 임시 복제 슬롯이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf5a50bb4ae3fd15a1d550ecd3ff88b2910e0b2" translate="yes" xml:space="preserve">
          <source>Each table access method is described by a row in the &lt;a href=&quot;catalog-pg-am&quot;&gt;&lt;code&gt;pg_am&lt;/code&gt;&lt;/a&gt; system catalog. The &lt;code&gt;pg_am&lt;/code&gt; entry specifies a name and a &lt;em&gt;handler function&lt;/em&gt; for the table access method. These entries can be created and deleted using the &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; and &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL commands.</source>
          <target state="translated">각 테이블 액세스 방법은 &lt;a href=&quot;catalog-pg-am&quot;&gt; &lt;code&gt;pg_am&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그 의 행으로 설명됩니다 . &lt;code&gt;pg_am&lt;/code&gt; 의 항목은 이름과 지정 &lt;em&gt;핸들러 함수&lt;/em&gt; 테이블 액세스 방법을. 이 항목은 &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL 명령을 사용하여 작성 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9bd474cfe905272d1ed130fc8be7d40f6eb50a6" translate="yes" xml:space="preserve">
          <source>Each table and index is stored in a separate file. For ordinary relations, these files are named after the table or index's &lt;em&gt;filenode&lt;/em&gt; number, which can be found in &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt;. But for temporary relations, the file name is of the form &lt;code&gt;tBBB_FFF&lt;/code&gt;, where &lt;code&gt;BBB&lt;/code&gt; is the backend ID of the backend which created the file, and &lt;code&gt;FFF&lt;/code&gt; is the filenode number. In either case, in addition to the main file (a/k/a main fork), each table and index has a &lt;em&gt;free space map&lt;/em&gt; (see &lt;a href=&quot;storage-fsm&quot;&gt;Section 68.3&lt;/a&gt;), which stores information about free space available in the relation. The free space map is stored in a file named with the filenode number plus the suffix &lt;code&gt;_fsm&lt;/code&gt;. Tables also have a &lt;em&gt;visibility map&lt;/em&gt;, stored in a fork with the suffix &lt;code&gt;_vm&lt;/code&gt;, to track which pages are known to have no dead tuples. The visibility map is described further in &lt;a href=&quot;storage-vm&quot;&gt;Section 68.4&lt;/a&gt;. Unlogged tables and indexes have a third fork, known as the initialization fork, which is stored in a fork with the suffix &lt;code&gt;_init&lt;/code&gt; (see &lt;a href=&quot;storage-init&quot;&gt;Section 68.5&lt;/a&gt;).</source>
          <target state="translated">각 테이블과 인덱스는 별도의 파일에 저장됩니다. 일반적인 관계의 경우 이러한 파일은 &lt;code&gt;pg_class&lt;/code&gt; 에서 찾을 수있는 테이블 또는 인덱스의 파일 &lt;em&gt;노드&lt;/em&gt; 번호를 따라 이름이 지정 됩니다. &lt;code&gt;relfilenode&lt;/code&gt; . 그러나 임시 관계의 경우 파일 이름은 &lt;code&gt;tBBB_FFF&lt;/code&gt; 형식 입니다 . 여기서 &lt;code&gt;BBB&lt;/code&gt; 는 파일을 작성한 백엔드의 백엔드 ID이고 &lt;code&gt;FFF&lt;/code&gt; 는 파일 노드 번호입니다. 두 경우 모두 메인 파일 (a / k / a 메인 포크) 외에 각 테이블과 인덱스에는 사용 가능한 여유 공간에 대한 정보를 저장 하는 &lt;em&gt;여유 공간 맵&lt;/em&gt; ( &lt;a href=&quot;storage-fsm&quot;&gt;68.3&lt;/a&gt; 참조 )이 있습니다. 여유 공간 맵은 파일 노드 번호와 접미 부가 붙은 파일에 저장됩니다&lt;em&gt;&lt;/em&gt; &lt;code&gt;_fsm&lt;/code&gt; . 표에는 또한 &lt;code&gt;_vm&lt;/code&gt; 접미사와 함께 포크에 저장 되는 &lt;em&gt;가시성 맵&lt;/em&gt; 이있어 어떤 페이지에 사용 가능한 튜플이 없는지 추적합니다. 가시성 맵은 &lt;a href=&quot;storage-vm&quot;&gt;68.4 절에&lt;/a&gt; 자세히 설명되어 있습니다. 로그되지 않은 테이블과 인덱스에는 초기화 포크라고하는 세 번째 포크가 있으며 이는 접미어 &lt;code&gt;_init&lt;/code&gt; ( &lt;a href=&quot;storage-init&quot;&gt;68.5 절&lt;/a&gt; 참조) 와 함께 포크에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="275b9850c8ac2609ae18b924589bca752bf47340" translate="yes" xml:space="preserve">
          <source>Each table has a primary heap disk file where most of the data is stored. If the table has any columns with potentially-wide values, there also might be a TOAST file associated with the table, which is used to store values too wide to fit comfortably in the main table (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;). There will be one valid index on the TOAST table, if present. There also might be indexes associated with the base table. Each table and index is stored in a separate disk file &amp;mdash; possibly more than one file, if the file would exceed one gigabyte. Naming conventions for these files are described in &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt;.</source>
          <target state="translated">각 테이블에는 대부분의 데이터가 저장되는 기본 힙 디스크 파일이 있습니다. 테이블에 잠재적으로 넓은 값을 가진 열이있는 경우, 테이블과 연관된 TOAST 파일이있을 수 있습니다.이 파일은 기본 테이블에 편안하게 맞지 않을 정도로 너무 넓은 값을 저장하는 데 사용됩니다 ( &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 참조 ). TOAST 테이블에는 유효한 인덱스가 하나 있습니다 (있는 경우). 기본 테이블과 연관된 인덱스가있을 수도 있습니다. 각 테이블과 인덱스는 별도의 디스크 파일 (파일이 1 기가 바이트를 초과 할 경우 둘 이상의 파일)에 저장됩니다. 이 파일들에 대한 명명 규칙은 &lt;a href=&quot;storage-file-layout&quot;&gt;68.1 장에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c85019013f60e190262e90fe6e11caa77e51ee" translate="yes" xml:space="preserve">
          <source>Each table is a named collection of &lt;em&gt;rows&lt;/em&gt;. Each row of a given table has the same set of named &lt;em&gt;columns&lt;/em&gt;, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).</source>
          <target state="translated">각 테이블은 명명 된 &lt;em&gt;행&lt;/em&gt; 모음입니다 . 주어진 테이블의 각 행에는 동일한 이름의 &lt;em&gt;columns&lt;/em&gt; 세트가 있으며 각 열은 특정 데이터 유형입니다. 열은 각 행마다 순서가 정해져 있지만 SQL은 표 내에서 행 순서를 보장하지 않습니다 (표시를 위해 명시 적으로 정렬 할 수는 있지만).</target>
        </trans-unit>
        <trans-unit id="685b66b0c7dcaf80c826236b5adf115b1b72905f" translate="yes" xml:space="preserve">
          <source>Each text search function that depends on a configuration has an optional &lt;code&gt;regconfig&lt;/code&gt; argument, so that the configuration to use can be specified explicitly. &lt;code&gt;default_text_search_config&lt;/code&gt; is used only when this argument is omitted.</source>
          <target state="translated">구성에 의존하는 각 텍스트 검색 기능에는 선택적 &lt;code&gt;regconfig&lt;/code&gt; 인수가 있으므로 사용할 구성을 명시 적으로 지정할 수 있습니다. &lt;code&gt;default_text_search_config&lt;/code&gt; 는이 인수가 생략 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2730705d08be86e159a9812b430c3cfef93639d7" translate="yes" xml:space="preserve">
          <source>Each trace macro has a corresponding &lt;code&gt;ENABLED&lt;/code&gt; macro.</source>
          <target state="translated">각 추적 매크로에는 해당 &lt;code&gt;ENABLED&lt;/code&gt; 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df910acc982080fcc4c6b3270ef5470d877e657" translate="yes" xml:space="preserve">
          <source>Each tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all tuples in a table will have the same count, but that might not always be true.) Then, repeated for each field in the tuple, there is a 32-bit length word followed by that many bytes of field data. (The length word does not include itself, and can be zero.) As a special case, -1 indicates a NULL field value. No value bytes follow in the NULL case.</source>
          <target state="translated">각 튜플은 튜플의 필드 수에 대한 16 비트 정수 카운트로 시작합니다. (현재 테이블의 모든 튜플의 개수는 동일하지만 항상 적용되는 것은 아닙니다.) 그런 다음 튜플의 각 필드에 대해 반복하면 32 비트 길이의 단어와 그 뒤에 많은 바이트의 필드 데이터가 있습니다. 길이 단어는 자체를 포함하지 않으며 0 일 수 있습니다. 특수한 경우 -1은 NULL 필드 값을 나타냅니다. NULL의 경우 값 바이트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2de56541538675ce5432246894338529335d8929" translate="yes" xml:space="preserve">
          <source>Each unique table constraint must name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise it would just be the same constraint listed twice.)</source>
          <target state="translated">각 고유 테이블 제약 조건은 테이블에 대해 정의 된 다른 고유 또는 기본 키 제약 조건으로 명명 된 열 집합과 다른 열 집합의 이름을 지정해야합니다. (그렇지 않으면 두 번 나열된 동일한 제약 조건 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="8bbff92e83b108022ae759643aa4ab54b925d10f" translate="yes" xml:space="preserve">
          <source>Each unlogged table, and each index on an unlogged table, has an initialization fork. The initialization fork is an empty table or index of the appropriate type. When an unlogged table must be reset to empty due to a crash, the initialization fork is copied over the main fork, and any other forks are erased (they will be recreated automatically as needed).</source>
          <target state="translated">로깅되지 않은 각 테이블과 로깅되지 않은 테이블의 각 인덱스에는 초기화 포크가 있습니다. 초기화 포크는 빈 테이블 또는 적절한 유형의 인덱스입니다. 충돌로 인해 로그되지 않은 테이블을 비우도록 재설정해야하는 경우 초기화 포크가 기본 포크에 복사되고 다른 포크는 지워집니다 (필요에 따라 자동으로 다시 작성 됨).</target>
        </trans-unit>
        <trans-unit id="a9e254619788fb33e63ce5b37d508d1966d6a8d8" translate="yes" xml:space="preserve">
          <source>Earliest transaction ID (txid) that is still active. All earlier transactions will either be committed and visible, or rolled back and dead.</source>
          <target state="translated">아직 활성화 된 가장 빠른 트랜잭션 ID (txid). 이전의 모든 트랜잭션은 커밋되고 표시되거나 롤백 및 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b9d0fad915a7ff2436d43361bd4e666886561" translate="yes" xml:space="preserve">
          <source>Echo all commands to standard output before executing them.</source>
          <target state="translated">모든 명령을 실행하기 전에 표준 출력으로 에코하십시오.</target>
        </trans-unit>
        <trans-unit id="31fb51222602fbffe196ffb2e7a990011bd130df" translate="yes" xml:space="preserve">
          <source>Echo the actual queries generated by &lt;code&gt;\d&lt;/code&gt; and other backslash commands. You can use this to study psql's internal operations. This is equivalent to setting the variable &lt;code&gt;ECHO_HIDDEN&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 및 기타 백 슬래시 명령으로 생성 된 실제 쿼리를 에코 합니다. 이것을 사용하여 psql의 내부 작업을 연구 할 수 있습니다. 이는 &lt;code&gt;ECHO_HIDDEN&lt;/code&gt; 변수 를 &lt;code&gt;on&lt;/code&gt; 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b2d12fd936b0e591c9f3ba992f2d39bfdf979b58" translate="yes" xml:space="preserve">
          <source>Echo the commands that clusterdb generates and sends to the server.</source>
          <target state="translated">clusterdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="c834bb0b0858d3c39e0ad807e49c73ad604e39eb" translate="yes" xml:space="preserve">
          <source>Echo the commands that createdb generates and sends to the server.</source>
          <target state="translated">createdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="f2fff24f50e42a42eba51d06a9742eabe4aa7f9d" translate="yes" xml:space="preserve">
          <source>Echo the commands that createuser generates and sends to the server.</source>
          <target state="translated">createuser가 생성하고 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="9d94af5551e2463ee5c6eb6201ef2f56bf3d3e29" translate="yes" xml:space="preserve">
          <source>Echo the commands that dropdb generates and sends to the server.</source>
          <target state="translated">dropdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="ac3cec1ed7d72c588fde05f0859ee42ebd61c794" translate="yes" xml:space="preserve">
          <source>Echo the commands that dropuser generates and sends to the server.</source>
          <target state="translated">dropuser가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="31938ea32c7dbab891aac5986f9157b135c1d3d3" translate="yes" xml:space="preserve">
          <source>Echo the commands that reindexdb generates and sends to the server.</source>
          <target state="translated">reindexdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="bb88bf5e806d864cde80f7a1f4ec7070ab3d3a49" translate="yes" xml:space="preserve">
          <source>Echo the commands that vacuumdb generates and sends to the server.</source>
          <target state="translated">vacuumdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="aa410e37b7eb78f6b0db88c9106078ce2821d967" translate="yes" xml:space="preserve">
          <source>Editor used by the &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, and &lt;code&gt;\ev&lt;/code&gt; commands. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;vi&lt;/code&gt; on Unix systems or &lt;code&gt;notepad.exe&lt;/code&gt; on Windows systems.</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\ef&lt;/code&gt; 및 &lt;code&gt;\ev&lt;/code&gt; 명령에서 사용하는 편집기 . 이러한 변수는 나열된 순서대로 검사됩니다. 설정된 첫 번째가 사용됩니다. 설정되지 않은 경우 기본값은 Unix 시스템 에서는 &lt;code&gt;vi&lt;/code&gt; 를 사용 하고 Windows 시스템에서는 &lt;code&gt;notepad.exe&lt;/code&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="0f11ff9075b757e9f28a73bab73613b127126f41" translate="yes" xml:space="preserve">
          <source>Eight-Bit Unicode Transformation Format</source>
          <target state="translated">8 비트 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="19d107541598c45354a43a5924575cdd88fc3077" translate="yes" xml:space="preserve">
          <source>Either form overrides whatever setting might exist for &lt;code&gt;work_mem&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Notice that underscores in parameter names can be written as either underscore or dash on the command line. Except for short-term experiments, it's probably better practice to edit the setting in &lt;code&gt;postgresql.conf&lt;/code&gt; than to rely on a command-line switch to set a parameter.</source>
          <target state="translated">어느 형식이든 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 &lt;code&gt;work_mem&lt;/code&gt; 에 대해 존재할 수있는 모든 설정을 무시합니다 . 매개 변수 이름의 밑줄은 명령 줄에서 밑줄 또는 대시로 쓸 수 있습니다. 단기 실험을 제외하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 설정을 편집하는 것이 명령 줄 스위치를 사용하여 매개 변수를 설정하는 것보다 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7f1f1f37763bf0059ec0085f40e07996ff76a200" translate="yes" xml:space="preserve">
          <source>Either way, you will only have a partially restored database. Alternatively, you can specify that the whole dump should be restored as a single transaction, so the restore is either fully completed or fully rolled back. This mode can be specified by passing the &lt;code&gt;-1&lt;/code&gt; or &lt;code&gt;--single-transaction&lt;/code&gt; command-line options to psql. When using this mode, be aware that even a minor error can rollback a restore that has already run for many hours. However, that might still be preferable to manually cleaning up a complex database after a partially restored dump.</source>
          <target state="translated">어느 쪽이든, 부분적으로 복원 된 데이터베이스 만 있습니다. 또는 전체 덤프를 단일 트랜잭션으로 복원하도록 지정하여 복원이 완전히 완료되거나 완전히 롤백되도록 지정할 수 있습니다. 이 모드는 &lt;code&gt;-1&lt;/code&gt; 또는 &lt;code&gt;--single-transaction&lt;/code&gt; 명령 행 옵션을 psql 에 전달하여 지정할 수 있습니다 . 이 모드를 사용할 때는 사소한 오류라도 이미 몇 시간 동안 이미 실행 된 복원을 롤백 할 수 있습니다. 그러나 부분적으로 복원 된 덤프 후 복잡한 데이터베이스를 수동으로 정리하는 것이 여전히 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2d216392756a3dca10170b407f8cc7f2a8ebe8" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">해시 테이블을 할당 할 병렬 해시 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="6873f61d619db679e7470f5643312237e0240439" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate more batches.</source>
          <target state="translated">더 많은 배치를 할당하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="27564de983e60879d25a8fb30933d1d02e9fefc7" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate more buckets.</source>
          <target state="translated">더 많은 버킷을 할당하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="dd07d1b2b5646cfd064828cd9f36124d4b5c4865" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">병렬 해시 참가자를 선출하여 초기 해시 테이블을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2ea1bfc4ea1822c938799e42d641a239c5778775" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">향후 배치 성장을 결정하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="3458b3ac42872c6eac5357f958184c0446ba0f65" translate="yes" xml:space="preserve">
          <source>Element and attribute names that are not valid XML names are escaped by replacing the offending characters by the sequence &lt;code&gt;_xHHHH_&lt;/code&gt;, where &lt;code&gt;HHHH&lt;/code&gt; is the character's Unicode codepoint in hexadecimal notation. For example:</source>
          <target state="translated">올바른 XML 이름이 아닌 요소 및 속성 이름은 문제가있는 문자를 &lt;code&gt;_xHHHH_&lt;/code&gt; 시퀀스로 대체하여 이스케이프됩니다 . 여기서 &lt;code&gt;HHHH&lt;/code&gt; 는 16 진 표기법으로 문자의 유니 코드 코드 포인트입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44fbc2768dbe44346b6baf10d03fef8413a56811" translate="yes" xml:space="preserve">
          <source>Element content, if specified, will be formatted according to its data type. If the content is itself of type &lt;code&gt;xml&lt;/code&gt;, complex XML documents can be constructed. For example:</source>
          <target state="translated">지정된 경우 요소 내용은 데이터 유형에 따라 형식이 지정됩니다. 컨텐츠 자체가 &lt;code&gt;xml&lt;/code&gt; 유형 인 경우 복잡한 XML 문서를 구성 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f872fe45bb2bfc5b19093ab727825b2056ae0af2" translate="yes" xml:space="preserve">
          <source>Element names that are not valid XML names are escaped as shown for &lt;code&gt;xmlelement&lt;/code&gt; above. Similarly, content data is escaped to make valid XML content, unless it is already of type &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">유효한 XML 이름이 아닌 요소 이름은 위의 &lt;code&gt;xmlelement&lt;/code&gt; 에 표시된 것처럼 이스케이프됩니다 . 마찬가지로 컨텐츠 데이터는 이미 &lt;code&gt;xml&lt;/code&gt; 유형이 아닌 한 유효한 XML 컨텐츠를 만들기 위해 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="7314da9aa08610fc7e551e14db13b15692e217a1" translate="yes" xml:space="preserve">
          <source>Eliminate explicit locks, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; where no longer needed due to the protections automatically provided by Serializable transactions.</source>
          <target state="translated">Serializable 트랜잭션에 의해 자동으로 제공되는 보호 기능으로 인해 더 이상 필요하지 않은 경우 명시 적 잠금, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c94d3175a6560565410511df2cebab9cda96027e" translate="yes" xml:space="preserve">
          <source>Email address</source>
          <target state="translated">이메일 주소</target>
        </trans-unit>
        <trans-unit id="78c45bfb7672fb0b2779428d901045aa7ce5bb61" translate="yes" xml:space="preserve">
          <source>Embedded C for PostgreSQL</source>
          <target state="translated">PostgreSQL 용 임베디드 C</target>
        </trans-unit>
        <trans-unit id="85c8d5ee732d2fb7da94ef6eea3e87e8049eee03" translate="yes" xml:space="preserve">
          <source>Embedded SQL</source>
          <target state="translated">임베디드 SQL</target>
        </trans-unit>
        <trans-unit id="0cf2ac97075bf1426575db1ed50de372ff47b973" translate="yes" xml:space="preserve">
          <source>Embedded options take effect at the &lt;code&gt;)&lt;/code&gt; terminating the sequence. They can appear only at the start of an ARE (after the &lt;code&gt;***:&lt;/code&gt; director if any).</source>
          <target state="translated">임베디드 옵션에서 효과를 가지고 &lt;code&gt;)&lt;/code&gt; 순서를 종료합니다. ARE 시작시에만 나타날 수 있습니다 ( &lt;code&gt;***:&lt;/code&gt; 감독이있는 경우).</target>
        </trans-unit>
        <trans-unit id="a80013744d7929a3261137d545cbd42a3af4f5d5" translate="yes" xml:space="preserve">
          <source>Emit binary logical decoding message. This can be used to pass generic messages to logical decoding plugins through WAL. The parameter &lt;em&gt;&lt;code&gt;transactional&lt;/code&gt;&lt;/em&gt; specifies if the message should be part of current transaction or if it should be written immediately and decoded as soon as the logical decoding reads the record. The &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt; is textual prefix used by the logical decoding plugins to easily recognize interesting messages for them. The &lt;em&gt;&lt;code&gt;content&lt;/code&gt;&lt;/em&gt; is the binary content of the message.</source>
          <target state="translated">이진 논리 디코딩 메시지를 방출합니다. WAL을 통해 일반 메시지를 논리적 디코딩 플러그인으로 전달하는 데 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;transactional&lt;/code&gt; &lt;/em&gt; 매개 변수 는 메시지가 현재 트랜잭션의 일부 여야하는지 또는 논리적 디코딩이 레코드를 읽는 즉시 메시지를 즉시 작성하고 디코딩해야하는지 지정합니다. &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/em&gt; IS 텍스트 접두사 쉽게 그들을 위해 재미있는 메시지를 인식하는 논리적 디코딩 플러그인에 의해 사용. &lt;em&gt; &lt;code&gt;content&lt;/code&gt; &lt;/em&gt; 메시지의 바이너리 콘텐츠입니다.</target>
        </trans-unit>
        <trans-unit id="7e0751c561c57bf2cbf1d1e9d274fe418b07635b" translate="yes" xml:space="preserve">
          <source>Emit text logical decoding message. This can be used to pass generic messages to logical decoding plugins through WAL. The parameter &lt;em&gt;&lt;code&gt;transactional&lt;/code&gt;&lt;/em&gt; specifies if the message should be part of current transaction or if it should be written immediately and decoded as soon as the logical decoding reads the record. The &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt; is textual prefix used by the logical decoding plugins to easily recognize interesting messages for them. The &lt;em&gt;&lt;code&gt;content&lt;/code&gt;&lt;/em&gt; is the text of the message.</source>
          <target state="translated">텍스트 논리적 디코딩 메시지를 방출합니다. WAL을 통해 일반 메시지를 논리적 디코딩 플러그인으로 전달하는 데 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;transactional&lt;/code&gt; &lt;/em&gt; 매개 변수 는 메시지가 현재 트랜잭션의 일부 여야하는지 또는 논리적 디코딩이 레코드를 읽는 즉시 메시지를 즉시 작성하고 디코딩해야하는지 지정합니다. &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/em&gt; IS 텍스트 접두사 쉽게 그들을 위해 재미있는 메시지를 인식하는 논리적 디코딩 플러그인에 의해 사용. &lt;em&gt; &lt;code&gt;content&lt;/code&gt; &lt;/em&gt; 메시지의 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="1d9158fa67b04334360a28023c58f2a63817f4c9" translate="yes" xml:space="preserve">
          <source>Empty &lt;code&gt;SELECT&lt;/code&gt; Lists</source>
          <target state="translated">빈 &lt;code&gt;SELECT&lt;/code&gt; 목록</target>
        </trans-unit>
        <trans-unit id="12d6c3df584f9cd6e2bed1f88b3a723f1f5371fd" translate="yes" xml:space="preserve">
          <source>Enable progress reporting. Turning this on will deliver a progress report while checking or enabling checksums.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 체크섬을 확인하거나 활성화하는 동안 진행률 보고서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f7a9c4f8b315d7d939ff2a001b201b4a11afef2b" translate="yes" xml:space="preserve">
          <source>Enable verbose output. Lists all checked files.</source>
          <target state="translated">자세한 출력을 활성화합니다. 확인 된 모든 파일을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6a055feda4ebabb382fa12b1358761956e1105a6" translate="yes" xml:space="preserve">
          <source>Enables SSL connections. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">SSL 연결을 활성화합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="626f01adb36a8ee098e309481b7ca3978eb10e34" translate="yes" xml:space="preserve">
          <source>Enables advertising the server's existence via Bonjour. The default is off. This parameter can only be set at server start.</source>
          <target state="translated">Bonjour를 통해 서버의 존재를 광고 할 수 있습니다. 기본 설정은 꺼져 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3410afd43005ba74c5e78a3c64358ed3118a2cb" translate="yes" xml:space="preserve">
          <source>Enables checksums.</source>
          <target state="translated">체크섬을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="78d4690c9afde1f8eefa94cd72a39b6d1a2c122d" translate="yes" xml:space="preserve">
          <source>Enables collection of statistics on database activity. This parameter is on by default, because the autovacuum daemon needs the collected information. Only superusers can change this setting.</source>
          <target state="translated">데이터베이스 활동에 대한 통계 콜렉션을 사용합니다. autovacuum 데몬에는 수집 된 정보가 필요하므로이 매개 변수는 기본적으로 켜져 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b45b9af6b6dbed04ecf07b2ffe0eb9095973ef5d" translate="yes" xml:space="preserve">
          <source>Enables display of progress messages.</source>
          <target state="translated">진행 메시지를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97255bb87514b6caf0bb2e2c2d781f5f1ac293a5" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of tar file output, and specifies the compression level (0 through 9, 0 being no compression and 9 being best compression). Compression is only available when using the tar format, and the suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all tar filenames.</source>
          <target state="translated">tar 파일 출력의 gzip 압축을 활성화하고 압축 레벨을 지정합니다 (0-9, 0은 압축되지 않고 9는 최상의 압축 임). 압축은 tar 형식을 사용할 때만 사용할 수 있으며 접미사 &lt;code&gt;.gz&lt;/code&gt; 는 모든 tar 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f90c3e668a373c21e31be412cfe3ee4c4edf41be" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of tar file output, with the default compression level. Compression is only available when using the tar format, and the suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all tar filenames.</source>
          <target state="translated">기본 압축 수준으로 tar 파일 출력의 gzip 압축을 활성화합니다. 압축은 tar 형식을 사용할 때만 사용할 수 있으며 접미사 &lt;code&gt;.gz&lt;/code&gt; 는 모든 tar 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa4f75e43a6e407c6e8a82b94739a07685c33bd" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of write-ahead logs, and specifies the compression level (0 through 9, 0 being no compression and 9 being best compression). The suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all filenames.</source>
          <target state="translated">미리 쓰기 로그의 gzip 압축을 사용하고 압축 레벨을 지정합니다 (0-9, 0은 압축되지 않고 9는 최상의 압축 임). 접미사 &lt;code&gt;.gz&lt;/code&gt; 가 모든 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4ed86902b76f841e1bca0b744a2e7335fa8f66ce" translate="yes" xml:space="preserve">
          <source>Enables logging of recovery-related debugging output that otherwise would not be logged. This parameter allows the user to override the normal setting of &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;, but only for specific messages. This is intended for use in debugging Hot Standby. Valid values are &lt;code&gt;DEBUG5&lt;/code&gt;, &lt;code&gt;DEBUG4&lt;/code&gt;, &lt;code&gt;DEBUG3&lt;/code&gt;, &lt;code&gt;DEBUG2&lt;/code&gt;, &lt;code&gt;DEBUG1&lt;/code&gt;, and &lt;code&gt;LOG&lt;/code&gt;. The default, &lt;code&gt;LOG&lt;/code&gt;, does not affect logging decisions at all. The other values cause recovery-related debug messages of that priority or higher to be logged as though they had &lt;code&gt;LOG&lt;/code&gt; priority; for common settings of &lt;code&gt;log_min_messages&lt;/code&gt; this results in unconditionally sending them to the server log. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">그렇지 않으면 기록되지 않은 복구 관련 디버깅 출력을 기록 할 수 있습니다. 이 매개 변수를 사용하면 사용자 는 특정 메시지에 대해서만 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; 의 일반 설정을 대체 할 수 있습니다 . 이것은 핫 스탠바이 디버깅에 사용하기위한 것입니다. 유효한 값은 &lt;code&gt;DEBUG5&lt;/code&gt; , &lt;code&gt;DEBUG4&lt;/code&gt; , &lt;code&gt;DEBUG3&lt;/code&gt; , &lt;code&gt;DEBUG2&lt;/code&gt; , &lt;code&gt;DEBUG1&lt;/code&gt; 및 &lt;code&gt;LOG&lt;/code&gt; 입니다. 기본값 인 &lt;code&gt;LOG&lt;/code&gt; 는 로깅 결정에 전혀 영향을 미치지 않습니다. 다른 값을 사용하면 해당 우선 순위 이상의 복구 관련 디버그 메시지가 &lt;code&gt;LOG&lt;/code&gt; 우선 순위를 갖는 것처럼 로그됩니다 . &lt;code&gt;log_min_messages&lt;/code&gt; 의 공통 설정이로 인해 무조건 서버 로그로 전송됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0bc8678d4e01747d95ba708742ba1d0ffa28593" translate="yes" xml:space="preserve">
          <source>Enables or disables genetic query optimization. This is on by default. It is usually best not to turn it off in production; the &lt;code&gt;geqo_threshold&lt;/code&gt; variable provides more granular control of GEQO.</source>
          <target state="translated">유전자 쿼리 최적화를 활성화하거나 비활성화합니다. 이것은 기본적으로 켜져 있습니다. 일반적으로 프로덕션 환경에서는 끄지 않는 것이 가장 좋습니다. &lt;code&gt;geqo_threshold&lt;/code&gt; 의 변수 GEQO보다 세밀한 제어를 제공한다.</target>
        </trans-unit>
        <trans-unit id="9b962689d04bf23cf75c28eb69f1f5503647fd60" translate="yes" xml:space="preserve">
          <source>Enables or disables index cleanup when &lt;code&gt;VACUUM&lt;/code&gt; is run on this table. The default value is &lt;code&gt;true&lt;/code&gt;. Disabling index cleanup can speed up &lt;code&gt;VACUUM&lt;/code&gt; very significantly, but may also lead to severely bloated indexes if table modifications are frequent. The &lt;code&gt;INDEX_CLEANUP&lt;/code&gt; parameter of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;, if specified, overrides the value of this option.</source>
          <target state="translated">이 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 때 인덱스 정리를 사용하거나 사용하지 않습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 인덱스 정리를 비활성화하면 &lt;code&gt;VACUUM&lt;/code&gt; 속도가 매우 빨라지 지만 테이블 수정이 빈번한 경우 인덱스가 심각하게 부 풀릴 수 있습니다. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 의 &lt;code&gt;INDEX_CLEANUP&lt;/code&gt; 매개 변수는 지정된 경우이 옵션의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b7ded5623d6f7d4469db9ae10d91b2c5b4f8e4c9" translate="yes" xml:space="preserve">
          <source>Enables or disables the autovacuum daemon for a particular table. If true, the autovacuum daemon will perform automatic &lt;code&gt;VACUUM&lt;/code&gt; and/or &lt;code&gt;ANALYZE&lt;/code&gt; operations on this table following the rules discussed in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. If false, this table will not be autovacuumed, except to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more about wraparound prevention. Note that the autovacuum daemon does not run at all (except to prevent transaction ID wraparound) if the &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; parameter is false; setting individual tables' storage parameters does not override that. Therefore there is seldom much point in explicitly setting this storage parameter to &lt;code&gt;true&lt;/code&gt;, only to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">특정 테이블에 대해 autovacuum 데몬을 활성화하거나 비활성화합니다. true 인 경우 autovacuum 데몬은 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절&lt;/a&gt; 에서 논의 된 규칙에 따라이 테이블에서 자동 &lt;code&gt;VACUUM&lt;/code&gt; 및 / 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 작업을 수행합니다 . False 인 경우이 테이블은 트랜잭션 ID 랩 어라운드를 방지하기 위해 자동 진공 청소기로 처리되지 않습니다. 랩 어라운드 방지에 대한 자세한 내용 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;은 24.1.5 절을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; 매개 변수가 false 인 경우 autovacuum 데몬은 전혀 실행되지 않습니다 (트랜잭션 ID 랩 어라운드 방지) . 개별 테이블의 스토리지 매개 변수를 설정해도이를 무시하지 않습니다. 따라서 명시 적으로이 스토리지 매개 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정 하고 &lt;code&gt;false&lt;/code&gt; 로만 설정하는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d14b153fda30f0ce055fd69a40d0d971812f5076" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's ability to eliminate a partitioned table's partitions from query plans. This also controls the planner's ability to generate query plans which allow the query executor to remove (ignore) partitions during query execution. The default is &lt;code&gt;on&lt;/code&gt;. See &lt;a href=&quot;ddl-partitioning#DDL-PARTITION-PRUNING&quot;&gt;Section 5.11.4&lt;/a&gt; for details.</source>
          <target state="translated">쿼리 계획에서 파티션 된 테이블의 파티션을 제거하는 쿼리 플래너 기능을 사용하거나 사용하지 않습니다. 또한 쿼리 실행 중에 쿼리 실행 프로그램이 파티션을 제거 (무시) ​​할 수 있도록하는 쿼리 계획을 생성하는 플래너의 기능을 제어합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;ddl-partitioning#DDL-PARTITION-PRUNING&quot;&gt;은 5.11.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="995969994dd32d0bf4b12e39bb21f11336caee94" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of TID scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 TID 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="caca9d6ce8d0139ac2e9013c1679f2c727efff8d" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of bitmap-scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 비트 맵 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b769d85abc23e2d30d27dc61faa1ee8cd8536874" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of explicit sort steps. It is impossible to suppress explicit sorts entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 명시 적 정렬 단계 사용을 활성화하거나 비활성화합니다. 명시 적 정렬을 완전히 억제하는 것은 불가능하지만,이 변수를 끄면 다른 방법이있을 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96879e71d00598fc0f4d556be7d62c9abbec4411" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of gather merge plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 수집 병합 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="21deb6a95d8d9fae5d39c1db9d16de9fde4fe130" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hash-join plan types with parallel hash. Has no effect if hash-join plans are not also enabled. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 병렬 해시와 함께 해시 조인 계획 유형을 사용하거나 사용하지 않도록 설정합니다. 해시 조인 계획도 활성화되어 있지 않으면 아무런 영향을 미치지 않습니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ec6953e4ca5a59667d50f27f71b28a7da33814e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hash-join plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 해시 조인 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf6533f43b0ca3981492c5998f149d18d7ac70d5" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hashed aggregation plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 해시 집계 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f2cf88152ca7bdcdf755fdc5e2656bab2a7a57e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of index-only-scan plan types (see &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt;). The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 인덱스 전용 스캔 계획 유형을 사용하거나 사용하지 않도록 설정합니다 ( &lt;a href=&quot;indexes-index-only-scans&quot;&gt;11.9 절&lt;/a&gt; 참조 ). 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="089511ca11c8382f30cdec2fd90407e060a0adb1" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of index-scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 인덱스 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f661c5fad3c336c0f972c99ffe732a268f196b0a" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of materialization. It is impossible to suppress materialization entirely, but turning this variable off prevents the planner from inserting materialize nodes except in cases where it is required for correctness. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 구체화 사용을 활성화하거나 비활성화합니다. 구체화를 완전히 억제하는 것은 불가능하지만이 변수를 끄면 계획자가 정확성이 필요한 경우를 제외하고 구체화 노드를 삽입 할 수 없습니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="690ff5cababf5bcdde1cb25f0adf2fc43533ddce" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of merge-join plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 병합 결합 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e00d7ba7fbb9b915299589cfef88ee157fde2ccd" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of nested-loop join plans. It is impossible to suppress nested-loop joins entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 계획자가 중첩 루프 조인 계획을 사용하거나 사용하지 않도록 설정합니다. 중첩 루프 조인을 완전히 억제하는 것은 불가능하지만이 변수를 끄면 다른 방법이있을 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d754190306e47bfd240a6fdc2ef4c38fba88f3b" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of parallel-aware append plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 병렬 인식 추가 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f36ea54e6ea533ca675dde4f1180490e7a02b1cf" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of partitionwise grouping or aggregation, which allows grouping or aggregation on a partitioned tables performed separately for each partition. If the &lt;code&gt;GROUP BY&lt;/code&gt; clause does not include the partition keys, only partial aggregation can be performed on a per-partition basis, and finalization must be performed later. Because partitionwise grouping or aggregation can use significantly more CPU time and memory during planning, the default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 파티션 단위 그룹화 또는 집계 사용을 활성화 또는 비활성화하여 각 파티션에 대해 개별적으로 수행되는 파티션 된 테이블에 대한 그룹화 또는 집계를 허용합니다. 는 IF &lt;code&gt;GROUP BY&lt;/code&gt; 절은 파티션 키를 포함하지 않는, 단지 부분적인 통합은 당 파티션 단위로 수행 할 수 있으며, 마무리는 나중에 수행해야합니다. 파티션 단위 그룹화 또는 집계는 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f9ba67905015767bb926e17fa47e22352d954b" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of partitionwise join, which allows a join between partitioned tables to be performed by joining the matching partitions. Partitionwise join currently applies only when the join conditions include all the partition keys, which must be of the same data type and have exactly matching sets of child partitions. Because partitionwise join planning can use significantly more CPU time and memory during planning, the default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 파티션 방식 조인 사용을 활성화 또는 비활성화하여 일치하는 파티션을 조인하여 파티션 된 테이블 간의 조인을 수행 할 수 있습니다. 파티션 방식 조인은 현재 조인 조건에 모든 파티션 키가 포함되어 있고 데이터 유형이 동일해야하며 정확히 일치하는 하위 파티션 세트를 가져야하는 경우에만 적용됩니다. 파티션 방식 조인 계획은 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ce1e4579696c287d022b50be0db1ba092c4338e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of sequential scan plan types. It is impossible to suppress sequential scans entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 순차 스캔 계획 유형 사용을 사용하거나 사용하지 않습니다. 순차 스캔을 완전히 억제하는 것은 불가능하지만이 변수를 끄면 다른 방법이있는 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b95c71c8efec42f210959555c75df0f25880db1" translate="yes" xml:space="preserve">
          <source>Enables or disables vacuum to try to truncate off any empty pages at the end of this table. The default value is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and autovacuum do the truncation and the disk space for the truncated pages is returned to the operating system. Note that the truncation requires &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the table. The &lt;code&gt;TRUNCATE&lt;/code&gt; parameter of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;, if specified, overrides the value of this option.</source>
          <target state="translated">이 테이블의 끝에서 빈 페이지를 잘라내도록 진공을 활성화 또는 비활성화합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; 및 자동 진공이 수행립니다 페이지의 절단 및 디스크 공간은 운영 체제에 반환됩니다. 잘림을 위해서는 테이블에 대한 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금이 필요 합니다. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 의 &lt;code&gt;TRUNCATE&lt;/code&gt; 매개 변수는 지정된 경우이 옵션의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1b31308aef37918b17682773a33dbb4bc9f00918" translate="yes" xml:space="preserve">
          <source>Enables progress reporting. Turning this on will deliver an approximate progress report during the backup. Since the database may change during the backup, this is only an approximation and may not end at exactly &lt;code&gt;100%&lt;/code&gt;. In particular, when WAL log is included in the backup, the total amount of data cannot be estimated in advance, and in this case the estimated target size will increase once it passes the total estimate without WAL.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 백업 중에 대략적인 진행률 보고서가 제공됩니다. 백업 중에 데이터베이스가 변경 될 수 있으므로 이는 대략적인 것일 뿐이며 정확히 &lt;code&gt;100%&lt;/code&gt; 끝나지 않을 수 있습니다 . 특히, WAL 로그가 백업에 포함 된 경우 총 데이터 양을 미리 예측할 수 없으며이 경우 WAL없이 총 예상치를 통과하면 예상 대상 크기가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ac15fe597310e5f701ec3560c99c834fe685738b" translate="yes" xml:space="preserve">
          <source>Enables progress reporting. Turning this on will deliver an approximate progress report while copying data from the source cluster.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 소스 클러스터에서 데이터를 복사하는 동안 대략적인 진행률 보고서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c6e8b43364e9301fa7393aaf1ee6a5531e8fd39" translate="yes" xml:space="preserve">
          <source>Enables secure connections using SSL. PostgreSQL must have been compiled with support for SSL for this option to be available. For more information on using SSL, refer to &lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;.</source>
          <target state="translated">SSL을 사용하여 보안 연결을 사용합니다. 이 옵션을 사용하려면 PostgreSQL이 SSL을 지원하도록 컴파일되어 있어야합니다. SSL 사용에 대한 자세한 내용 &lt;a href=&quot;ssl-tcp&quot;&gt;은 18.9 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="639cdb727b936af4ccbde200e725e387830f011c" translate="yes" xml:space="preserve">
          <source>Enables the collection of information on the currently executing command of each session, along with the time when that command began execution. This parameter is on by default. Note that even when enabled, this information is not visible to all users, only to superusers and the user owning the session being reported on, so it should not represent a security risk. Only superusers can change this setting.</source>
          <target state="translated">각 세션에서 현재 실행중인 명령에 대한 정보 수집과 해당 명령이 실행을 시작한 시간을 활성화합니다. 이 매개 변수는 기본적으로 켜져 있습니다. 활성화 된 경우에도이 정보는 모든 사용자에게 표시되지 않으며 수퍼 유저 및보고되는 세션을 소유 한 사용자에게만 표시되므로 보안 위험을 나타내지 않아야합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c924445fb5317940d918e85cdabb3cd269d58308" translate="yes" xml:space="preserve">
          <source>Enables the previously disabled subscription, starting the logical replication worker at the end of transaction.</source>
          <target state="translated">트랜잭션이 끝날 때 논리적 복제 작업자를 시작하여 이전에 비활성화 된 가입을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8ba9870f478d2bde43f63790fab9c752de4bfaa0" translate="yes" xml:space="preserve">
          <source>Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system. I/O timing information is displayed in &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;, in the output of &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; when the &lt;code&gt;BUFFERS&lt;/code&gt; option is used, and by &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements&lt;/a&gt;. Only superusers can change this setting.</source>
          <target state="translated">데이터베이스 I / O 호출 타이밍을 활성화합니다. 이 매개 변수는 현재 시간 동안 운영 체제를 반복해서 조회하므로 일부 플랫폼에서 상당한 오버 헤드가 발생할 수 있으므로 기본적으로 해제되어 있습니다. &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; 도구를 사용 하여 시스템의 타이밍 오버 헤드를 측정 할 수 있습니다. I / O 타이밍 정보는 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; , &lt;code&gt;BUFFERS&lt;/code&gt; 옵션 사용시 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력 및 &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements에 표시&lt;/a&gt; 됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1205b107d21f6fa21fec7f98257f15ab13c062b3" translate="yes" xml:space="preserve">
          <source>Enables tracking of function call counts and time used. Specify &lt;code&gt;pl&lt;/code&gt; to track only procedural-language functions, &lt;code&gt;all&lt;/code&gt; to also track SQL and C language functions. The default is &lt;code&gt;none&lt;/code&gt;, which disables function statistics tracking. Only superusers can change this setting.</source>
          <target state="translated">함수 호출 횟수 및 사용 시간을 추적 할 수 있습니다. 절차 언어 함수 만 추적하려면 &lt;code&gt;pl&lt;/code&gt; 을 지정 하고 &lt;code&gt;all&lt;/code&gt; SQL 및 C 언어 함수도 추적하십시오. 기본값은 &lt;code&gt;none&lt;/code&gt; 이며 함수 통계 추적을 사용하지 않습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91758902f000617c78a32904c3bce42de9ae0b26" translate="yes" xml:space="preserve">
          <source>Enables updating of the process title every time a new SQL command is received by the server. This setting defaults to &lt;code&gt;on&lt;/code&gt; on most platforms, but it defaults to &lt;code&gt;off&lt;/code&gt; on Windows due to that platform's larger overhead for updating the process title. Only superusers can change this setting.</source>
          <target state="translated">서버가 새 SQL 명령을 수신 할 때마다 프로세스 제목을 업데이트 할 수 있습니다. 이 설정은 기본값 &lt;code&gt;on&lt;/code&gt; 대부분의 플랫폼 만에 디폴트 &lt;code&gt;off&lt;/code&gt; 로 인해 프로세스 제목을 업데이트 해당 플랫폼의 더 큰 오버 헤드 Windows에서. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0770fd14bde6f2b9d7a84507b79c75b3bf13dbb" translate="yes" xml:space="preserve">
          <source>Enables verbose mode.</source>
          <target state="translated">상세 모드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be686f7be5950cf34bad6b75adc70f588a3070c6" translate="yes" xml:space="preserve">
          <source>Enables verbose mode. Will output some extra steps during startup and shutdown, as well as show the exact file name that is currently being processed if progress reporting is also enabled.</source>
          <target state="translated">상세 모드를 사용합니다. 시작 및 종료 중에 몇 가지 추가 단계를 출력 할뿐만 아니라 진행률보고가 활성화 된 경우 현재 처리중인 정확한 파일 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fe31a01f44f98b228218e52dbf8b5e37e32c2524" translate="yes" xml:space="preserve">
          <source>Enabling and disabling row security, as well as adding policies to a table, is always the privilege of the table owner only.</source>
          <target state="translated">행 보안 활성화 및 비활성화와 테이블에 정책 추가는 항상 테이블 소유자의 특권입니다.</target>
        </trans-unit>
        <trans-unit id="d88bdb1d59885197da92cd539e47bd75193672fe" translate="yes" xml:space="preserve">
          <source>Enabling checksums in a large cluster can potentially take a long time. During this operation, the cluster or other programs that write to the data directory must not be started or else data loss may occur.</source>
          <target state="translated">대규모 클러스터에서 체크섬을 활성화하면 시간이 오래 걸릴 수 있습니다. 이 작업 중에 데이터 디렉토리에 쓰는 클러스터 또는 다른 프로그램을 시작하지 않아야합니다. 그렇지 않으면 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16eb09418a7d2058bea03afe5a97ce2e66b20131" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;a href=&quot;runtime-config-developer#GUC-WAL-DEBUG&quot;&gt;wal_debug&lt;/a&gt; configuration parameter (provided that PostgreSQL has been compiled with support for it) will result in each &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt; WAL call being logged to the server log. This option might be replaced by a more general mechanism in the future.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-developer#GUC-WAL-DEBUG&quot;&gt;wal_debug&lt;/a&gt; 구성 매개 변수를 활성화하면 (PostgreSQL &lt;code&gt;XLogInsertRecord&lt;/code&gt; 를 지원하도록 컴파일 된 경우) 각 XLogInsertRecord 및 &lt;code&gt;XLogFlush&lt;/code&gt; WAL 호출이 서버 로그에 기록됩니다. 이 옵션은 향후보다 일반적인 메커니즘으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6da64af06028e20756acd4e64347dc93ae83ca" translate="yes" xml:space="preserve">
          <source>Encode binary data into a textual representation. Supported formats are: &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;hex&lt;/code&gt;, &lt;code&gt;escape&lt;/code&gt;. &lt;code&gt;escape&lt;/code&gt; converts zero bytes and high-bit-set bytes to octal sequences (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;nnn&lt;/code&gt;) and doubles backslashes.</source>
          <target state="translated">이진 데이터를 텍스트 표현으로 인코딩합니다. 지원되는 형식은 &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;hex&lt;/code&gt; , &lt;code&gt;escape&lt;/code&gt; 입니다. &lt;code&gt;escape&lt;/code&gt; 는 0 바이트 및 높은 비트 세트 바이트를 8 진 시퀀스 ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;nnn&lt;/code&gt; )로 변환하고 백 슬래시를 두 배로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0451cbe9a0060c77e165e28a5107c4842ddc570b" translate="yes" xml:space="preserve">
          <source>Encoding in which the collation is applicable, or -1 if it works for any encoding</source>
          <target state="translated">데이터 정렬이 적용되는 인코딩 또는 인코딩에 작동하는 경우 -1</target>
        </trans-unit>
        <trans-unit id="341a64b217af4e5bb3b26e6e6aaaa7a31cc97ef1" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with a public PGP key &lt;em&gt;&lt;code&gt;key&lt;/code&gt;&lt;/em&gt;. Giving this function a secret key will produce an error.</source>
          <target state="translated">공개 PGP 키 &lt;em&gt; &lt;code&gt;key&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 를 암호화하십시오 . 이 기능에 비밀 키를 부여하면 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a3990a8b9259bdb5f6a9b6abcbeffcba8897c8c" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with a symmetric PGP key &lt;em&gt;&lt;code&gt;psw&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="translated">대칭 PGP 키 &lt;em&gt; &lt;code&gt;psw&lt;/code&gt; 로&lt;/em&gt;&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 를 암호화하십시오 . &lt;em&gt; &lt;code&gt;options&lt;/code&gt; &lt;/em&gt; 아래와 같이 매개 변수는 옵션 설정을 포함 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9842995d92188012295a50b3899a0efd3fcda9d" translate="yes" xml:space="preserve">
          <source>Encrypt/decrypt data using the cipher method specified by &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt;. The syntax of the &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; string is:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type&lt;/code&gt; 에&lt;/em&gt; 지정된 암호 방법을 사용하여 데이터를 암호화 / 복호화 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 문자열 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5f8215dc00e7bd6f42b2309756207f16408e9f0" translate="yes" xml:space="preserve">
          <source>Encrypting Data Across A Network</source>
          <target state="translated">네트워크에서 데이터 암호화</target>
        </trans-unit>
        <trans-unit id="057f65baf1aec748dff67fe4eada3e2606712a49" translate="yes" xml:space="preserve">
          <source>Encryption For Specific Columns</source>
          <target state="translated">특정 열에 대한 암호화</target>
        </trans-unit>
        <trans-unit id="4533f510df88e2b0af919518ba19446d6841df20" translate="yes" xml:space="preserve">
          <source>Encryption Options</source>
          <target state="translated">암호화 옵션</target>
        </trans-unit>
        <trans-unit id="fb3559bc56acc81a8a2588665e15cc63cab9ccbc" translate="yes" xml:space="preserve">
          <source>End LSN for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; states.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;r&lt;/code&gt; 상태에 대한 LSN을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="a0004120567bc0ebdbad1553091224b55d732de5" translate="yes" xml:space="preserve">
          <source>End a scan and release resources. The &lt;code&gt;scan&lt;/code&gt; struct itself should not be freed, but any locks or pins taken internally by the access method must be released, as well as any other memory allocated by &lt;code&gt;ambeginscan&lt;/code&gt; and other scan-related functions.</source>
          <target state="translated">스캔을 종료하고 자원을 해제하십시오. &lt;code&gt;scan&lt;/code&gt; 구조체 자체가 해제되지 않아야하지만, 액세스 방식에 의해 내부적으로 취해진 잠금 또는 핀에 의해 할당 된 다른 어떤 메모리뿐만 아니라 해제되어야 &lt;code&gt;ambeginscan&lt;/code&gt; 다른 검색 관련 기능.</target>
        </trans-unit>
        <trans-unit id="73135e91289bc93517190d0e6d3559a0e3664634" translate="yes" xml:space="preserve">
          <source>End of data can be represented by a single line containing just backslash-period (&lt;code&gt;\.&lt;/code&gt;). An end-of-data marker is not necessary when reading from a file, since the end of file serves perfectly well; it is needed only when copying data to or from client applications using pre-3.0 client protocol.</source>
          <target state="translated">데이터 끝은 백 슬래시 ( &lt;code&gt;\.&lt;/code&gt; ) 만 포함하는 단일 행으로 표시 될 수 있습니다 . 파일 끝을 완벽하게 제공하므로 파일에서 읽을 때 데이터 끝 표시가 필요하지 않습니다. 3.0 이전 클라이언트 프로토콜을 사용하여 클라이언트 응용 프로그램에서 데이터를 복사하거나 클라이언트 응용 프로그램에서 데이터를 복사 할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7244ed52ecd0e00af92538864226baa5f273cc0f" translate="yes" xml:space="preserve">
          <source>Enhanced support for &lt;code&gt;int[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int[]&lt;/code&gt; 대한 향상된 지원</target>
        </trans-unit>
        <trans-unit id="1ef09b2c14360d7df9156ee864e5abbe1317f83d" translate="yes" xml:space="preserve">
          <source>Ensure that WAL archiving is enabled and working.</source>
          <target state="translated">WAL 아카이브가 사용 가능하고 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3096dbf7c9f089e5b75e6925610e01340ab4c14" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; configuration parameter is not disabled in &lt;code&gt;postgresql.conf&lt;/code&gt;; otherwise child tables may be accessed unnecessarily.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; 구성 매개 변수가 비활성화되어 있지 않은지 확인하십시오 . 그렇지 않으면 자식 테이블에 불필요하게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8c39032c5c162b802bfe063fb69e0eb9d71a9e" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; configuration parameter is not disabled in &lt;code&gt;postgresql.conf&lt;/code&gt;. If it is, queries will not be optimized as desired.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; 구성 매개 변수가 비활성화되어 있지 않은지 확인하십시오 . 그렇다면 쿼리가 원하는대로 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e907b2d96c2e0510565b023e9313668a750f15ca" translate="yes" xml:space="preserve">
          <source>Ensure that the constraints guarantee that there is no overlap between the key values permitted in different child tables. A common mistake is to set up range constraints like:</source>
          <target state="translated">제약 조건으로 인해 다른 자식 테이블에서 허용되는 키 값이 겹치지 않아야합니다. 일반적인 실수는 다음과 같은 범위 제약 조건을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74aec26e5aaa65d62267666deee0f48ec96663e2" translate="yes" xml:space="preserve">
          <source>Entering SQL Commands</source>
          <target state="translated">SQL 명령 입력</target>
        </trans-unit>
        <trans-unit id="046e4581b1c5aec34636d90839e4ed2b7307eb8a" translate="yes" xml:space="preserve">
          <source>Enum Functions</source>
          <target state="translated">열거 형 함수</target>
        </trans-unit>
        <trans-unit id="b8610d3e64c42d92c7dbc67b095e4215c3ffaaa5" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_first</source>
          <target state="translated">열거 형 함수 : enum_first</target>
        </trans-unit>
        <trans-unit id="7336a1c5ba5c19629373d430d26c38c6c87e8d09" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_last</source>
          <target state="translated">열거 형 함수 : enum_last</target>
        </trans-unit>
        <trans-unit id="be93ad7bbe09be7d1a2f12be74753766ff71b28b" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_range</source>
          <target state="translated">열거 형 함수 : enum_range</target>
        </trans-unit>
        <trans-unit id="8e316f488e30a30d5ab0c69be046123afa59e223" translate="yes" xml:space="preserve">
          <source>Enum labels are case sensitive, so &lt;code&gt;'happy'&lt;/code&gt; is not the same as &lt;code&gt;'HAPPY'&lt;/code&gt;. White space in the labels is significant too.</source>
          <target state="translated">열거 형 레이블은 대소 문자를 구분하므로 &lt;code&gt;'happy'&lt;/code&gt; 는 &lt;code&gt;'HAPPY'&lt;/code&gt; 와 다릅니다 . 레이블의 공백도 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a90b45275712d81cce74968837bc94f42d058471" translate="yes" xml:space="preserve">
          <source>Enum types</source>
          <target state="translated">열거 형 유형</target>
        </trans-unit>
        <trans-unit id="9c690fbe950b46ebdaae8dec97255d2d06e0850f" translate="yes" xml:space="preserve">
          <source>Enum types are created using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command, for example:</source>
          <target state="translated">열거 형 유형은 다음과 같이 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 명령을 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="70b0c9b305752d04f1cf7f83d022114f817e1f4b" translate="yes" xml:space="preserve">
          <source>Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the &lt;code&gt;enum&lt;/code&gt; types supported in a number of programming languages. An example of an enum type might be the days of the week, or a set of status values for a piece of data.</source>
          <target state="translated">열거 형 (enum) 유형은 정적이고 순서가 정해진 값 세트를 구성하는 데이터 유형입니다. 그것들은 많은 프로그래밍 언어에서 지원되는 &lt;code&gt;enum&lt;/code&gt; 유형 과 같습니다 . 열거 형 유형의 예로는 요일 또는 데이터 조각에 대한 상태 값 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">열거 형</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="225f38b6ef3f013c2d18dbba5fe2e96af347bda3" translate="yes" xml:space="preserve">
          <source>Equality operator</source>
          <target state="translated">평등 연산자</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="8fa1f90fe55ee69c7cc450279ce5054a76f35455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--locale=C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--locale=C&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f75ad773988ea805c001deb8afac5f240f296a82" translate="yes" xml:space="preserve">
          <source>Error Code</source>
          <target state="translated">에러 코드</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="b7d9c1592623f8da811bdb9234af75a411c93a5c" translate="yes" xml:space="preserve">
          <source>Error Reporting and Logging</source>
          <target state="translated">오류보고 및 로깅</target>
        </trans-unit>
        <trans-unit id="7bc277840854dfa75df978bf81562fcab6c7816c" translate="yes" xml:space="preserve">
          <source>Errors along the line of &amp;ldquo;could not initialize database directory&amp;rdquo; are most likely related to insufficient permissions on the data directory, a full disk, or other file system problems.</source>
          <target state="translated">&amp;ldquo;데이터베이스 디렉토리를 초기화 할 수 없음&amp;rdquo;행의 오류는 데이터 디렉토리, 전체 디스크 또는 기타 파일 시스템 문제에 대한 권한이 충분하지 않은 것과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="567e2f29b36f15d7010e15b228d15b8b57008175" translate="yes" xml:space="preserve">
          <source>Errors related to the number or types of elements might not occur if the comparison is resolved using earlier columns.</source>
          <target state="translated">이전 열을 사용하여 비교를 해결하면 요소 수 또는 유형과 관련된 오류가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="d92a0d6cc6ff18c625e4d2d10fa6f8398ba4b65d" translate="yes" xml:space="preserve">
          <source>Escaped Input Representation</source>
          <target state="translated">이스케이프 된 입력 표현</target>
        </trans-unit>
        <trans-unit id="a70529587a3b8c1eb3289010686d7afc6353fa45" translate="yes" xml:space="preserve">
          <source>Escaped Output Representation</source>
          <target state="translated">이스케이프 된 출력 표현</target>
        </trans-unit>
        <trans-unit id="69dbe5a9614224b4c161533b3c69c7a40c11a8f1" translate="yes" xml:space="preserve">
          <source>Establish a new connection for each transaction, rather than doing it just once per client session. This is useful to measure the connection overhead.</source>
          <target state="translated">클라이언트 세션 당 한 번만 수행하지 말고 각 트랜잭션마다 새 연결을 설정하십시오. 연결 오버 헤드를 측정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="47cfb90040ab1fc595e208467aae6de960b9eeb8" translate="yes" xml:space="preserve">
          <source>Establishes a new connection to a PostgreSQL server. The connection parameters to use can be specified either using a positional syntax, or using &lt;code&gt;conninfo&lt;/code&gt; connection strings as detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 서버에 대한 새로운 연결을 설정합니다. 사용할 연결 매개 변수는 위치 구문을 사용하거나 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절에&lt;/a&gt; 설명 된대로 &lt;code&gt;conninfo&lt;/code&gt; 연결 문자열을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d03a086aee28b751fe576fa4bdabc53fb0f54ece" translate="yes" xml:space="preserve">
          <source>Estimate and return the fraction of parent-table rows that will be visited based on the given qual conditions. In the absence of any index-type-specific knowledge, use the standard optimizer function &lt;code&gt;clauselist_selectivity()&lt;/code&gt;:</source>
          <target state="translated">주어진 조건에 따라 방문 할 부모 테이블 행의 비율을 추정하고 반환합니다. 인덱스 유형별 지식이없는 경우 표준 옵티 마이저 함수 &lt;code&gt;clauselist_selectivity()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bec848de4aa44a0a15fc9c8942c2c946c78e91a1" translate="yes" xml:space="preserve">
          <source>Estimate and return the number of bytes of dynamic shared memory which the access method will be needed to perform a parallel scan. (This number is in addition to, not in lieu of, the amount of space needed for AM-independent data in &lt;code&gt;ParallelIndexScanDescData&lt;/code&gt;.)</source>
          <target state="translated">병렬 스캔을 수행하기 위해 액세스 방법이 필요한 동적 공유 메모리의 바이트 수를 추정하고 리턴하십시오. (이 숫자는 &lt;code&gt;ParallelIndexScanDescData&lt;/code&gt; 의 AM 독립 데이터에 필요한 공간을 대신하는 것이 아니라 그 대신입니다 .)</target>
        </trans-unit>
        <trans-unit id="7c6211936151b852e2f185a6b6a4f2437a25bb7b" translate="yes" xml:space="preserve">
          <source>Estimate the costs of an index scan. This function is described fully in &lt;a href=&quot;index-cost-estimation&quot;&gt;Section 61.6&lt;/a&gt;, below.</source>
          <target state="translated">인덱스 스캔 비용을 추정하십시오. 이 기능은 아래 &lt;a href=&quot;index-cost-estimation&quot;&gt;61.6 절에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded5e0300c03bb82b5d8f2aac16597430daf7c7b" translate="yes" xml:space="preserve">
          <source>Estimate the index correlation. For a simple ordered index on a single field, this can be retrieved from pg_statistic. If the correlation is not known, the conservative estimate is zero (no correlation).</source>
          <target state="translated">지수 상관을 추정하십시오. 단일 필드의 간단한 정렬 된 인덱스의 경우 pg_statistic에서 검색 할 수 있습니다. 상관이 알려지지 않은 경우 보수적 추정값은 0입니다 (상관 없음).</target>
        </trans-unit>
        <trans-unit id="2e36f34dab37d809ba9546de4730f9fe0465c9de" translate="yes" xml:space="preserve">
          <source>Estimate the number of index pages that will be retrieved during the scan. This might be just &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; times the index's size in pages.</source>
          <target state="translated">스캔 중에 검색 될 인덱스 페이지 수를 추정하십시오. 이것은 &lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; &lt;/em&gt; 에 페이지 크기의 인덱스 크기를 곱한 것일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22f6d2800be54bd8d034e5f9fc23de7b2154ac60" translate="yes" xml:space="preserve">
          <source>Estimate the number of index rows that will be visited during the scan. For many index types this is the same as &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; times the number of rows in the index, but it might be more. (Note that the index's size in pages and rows is available from the &lt;code&gt;path-&amp;gt;indexinfo&lt;/code&gt; struct.)</source>
          <target state="translated">스캔 중에 방문 할 인덱스 행 수를 추정하십시오. 많은 인덱스 유형의 경우 이는 &lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; &lt;/em&gt; 와 인덱스의 행 수를 곱한 것과 같지만 더 &lt;em&gt;클&lt;/em&gt; 수 있습니다. (페이지와 행의 색인 크기는 &lt;code&gt;path-&amp;gt;indexinfo&lt;/code&gt; 구조체 에서 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="9c7c4c0dbcde2cda466ad2979c816be2d9783880" translate="yes" xml:space="preserve">
          <source>Estimated average width of rows output by this plan node (in bytes).</source>
          <target state="translated">이 계획 노드에서 출력 한 예상 평균 행 너비 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="827aaed24a33d71c3aa9bc8bd44e74adc59bb3f9" translate="yes" xml:space="preserve">
          <source>Estimated execution cost (in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;); if &lt;code&gt;proretset&lt;/code&gt;, this is cost per row returned</source>
          <target state="translated">예상 실행 비용 ( &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; 단위 ); &lt;code&gt;proretset&lt;/code&gt; 인 경우 이것은 행당 반환 된 비용입니다</target>
        </trans-unit>
        <trans-unit id="162ceaab20109a5357a32758bbe2f6408fbc1e4a" translate="yes" xml:space="preserve">
          <source>Estimated number of dead rows</source>
          <target state="translated">데드 행의 예상 수</target>
        </trans-unit>
        <trans-unit id="694bdaaaaeaf00e19172f4b998db9c74caa5dc14" translate="yes" xml:space="preserve">
          <source>Estimated number of live rows</source>
          <target state="translated">예상 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="6b46d923d47a400cec25631616b87a8ff2384267" translate="yes" xml:space="preserve">
          <source>Estimated number of result rows (zero if not &lt;code&gt;proretset&lt;/code&gt;)</source>
          <target state="translated">예상 결과 행 수 ( &lt;code&gt;proretset&lt;/code&gt; 이 아닌 경우 0 )</target>
        </trans-unit>
        <trans-unit id="7728ea9ebbd6e71eba25826b64a5b37d25d134ef" translate="yes" xml:space="preserve">
          <source>Estimated number of rows modified since this table was last analyzed</source>
          <target state="translated">이 테이블을 마지막으로 분석 한 이후 수정 된 예상 행 수</target>
        </trans-unit>
        <trans-unit id="c10501d9a9b57a73d47cb5e0b89d85408e3e48f6" translate="yes" xml:space="preserve">
          <source>Estimated number of rows output by this plan node. Again, the node is assumed to be run to completion.</source>
          <target state="translated">이 계획 노드가 출력 한 예상 행 수입니다. 다시, 노드는 실행이 완료된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="bae3d1780605a78d7cb6c307c6325610550caa57" translate="yes" xml:space="preserve">
          <source>Estimated start-up cost. This is the time expended before the output phase can begin, e.g., time to do the sorting in a sort node.</source>
          <target state="translated">예상 시작 비용. 이는 출력 단계가 시작되기 전에 소비 된 시간입니다 (예 : 정렬 노드에서 정렬을 수행하는 시간).</target>
        </trans-unit>
        <trans-unit id="1c29292196fc470907aa2bfb67dd0623f0fd1b46" translate="yes" xml:space="preserve">
          <source>Estimated total cost. This is stated on the assumption that the plan node is run to completion, i.e., all available rows are retrieved. In practice a node's parent node might stop short of reading all available rows (see the &lt;code&gt;LIMIT&lt;/code&gt; example below).</source>
          <target state="translated">총 예상 비용. 이는 계획 노드가 완료 될 때까지 실행된다는 가정하에 설명됩니다. 즉, 사용 가능한 모든 행이 검색됩니다. 실제로 노드의 상위 노드는 사용 가능한 모든 행을 읽지 못하는 것을 중지 할 수 있습니다 ( 아래 &lt;code&gt;LIMIT&lt;/code&gt; 예 참조).</target>
        </trans-unit>
        <trans-unit id="b7626dd6115dd399a5451b8ceae77eb4101118cd" translate="yes" xml:space="preserve">
          <source>Euclidean distance between a and b.</source>
          <target state="translated">a와 b 사이의 유클리드 거리.</target>
        </trans-unit>
        <trans-unit id="fe3e5f6519ca15884710875534191a619674a62c" translate="yes" xml:space="preserve">
          <source>European Article Numbers, always displayed in the EAN13 display format</source>
          <target state="translated">항상 EAN13 표시 형식으로 표시되는 유럽 품목 번호</target>
        </trans-unit>
        <trans-unit id="2125658827a39fbf69c352b9f37f15d674ff0bf3" translate="yes" xml:space="preserve">
          <source>Evaluate the non-recursive term. For &lt;code&gt;UNION&lt;/code&gt; (but not &lt;code&gt;UNION ALL&lt;/code&gt;), discard duplicate rows. Include all remaining rows in the result of the recursive query, and also place them in a temporary &lt;em&gt;working table&lt;/em&gt;.</source>
          <target state="translated">비 재귀 항을 평가하십시오. 들어 &lt;code&gt;UNION&lt;/code&gt; (그러나 &lt;code&gt;UNION ALL&lt;/code&gt; ), 중복 행을 폐기합니다. 재귀 쿼리 결과에 나머지 행을 모두 포함하고 임시 &lt;em&gt;작업 테이블&lt;/em&gt; 에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="123b32554a699621dd91baee8db3dada8e957007" translate="yes" xml:space="preserve">
          <source>Evaluate the recursive term, substituting the current contents of the working table for the recursive self-reference. For &lt;code&gt;UNION&lt;/code&gt; (but not &lt;code&gt;UNION ALL&lt;/code&gt;), discard duplicate rows and rows that duplicate any previous result row. Include all remaining rows in the result of the recursive query, and also place them in a temporary &lt;em&gt;intermediate table&lt;/em&gt;.</source>
          <target state="translated">재귀 자체 참조를 위해 작업 테이블의 현재 내용을 대체하여 재귀 용어를 평가하십시오. 들어 &lt;code&gt;UNION&lt;/code&gt; (그러나 &lt;code&gt;UNION ALL&lt;/code&gt; ), 중복 행과 이전 결과 행을 중복 행을 폐기합니다. 재귀 쿼리 결과에 나머지 행을 모두 포함하고 임시 &lt;em&gt;중간 테이블&lt;/em&gt; 에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="6aad88fc80f312751092cf88c7c06421eced67d6" translate="yes" xml:space="preserve">
          <source>Even though located outside the main PostgreSQL data directory, tablespaces are an integral part of the database cluster and &lt;em&gt;cannot&lt;/em&gt; be treated as an autonomous collection of data files. They are dependent on metadata contained in the main data directory, and therefore cannot be attached to a different database cluster or backed up individually. Similarly, if you lose a tablespace (file deletion, disk failure, etc), the database cluster might become unreadable or unable to start. Placing a tablespace on a temporary file system like a RAM disk risks the reliability of the entire cluster.</source>
          <target state="translated">기본 PostgreSQL 데이터 디렉토리 외부에 있더라도 테이블 스페이스는 데이터베이스 클러스터의 필수 부분이며 자율적 인 데이터 파일 모음으로 취급 &lt;em&gt;할 수 없습니다&lt;/em&gt; . 기본 데이터 디렉토리에 포함 된 메타 데이터에 종속되므로 다른 데이터베이스 클러스터에 연결하거나 개별적으로 백업 할 수 없습니다. 마찬가지로, 테이블 스페이스 (파일 삭제, 디스크 장애 등)가 손실되면 데이터베이스 클러스터를 읽을 수 없거나 시작할 수 없습니다. RAM 디스크와 같은 임시 파일 시스템에 테이블 스페이스를 배치하면 전체 클러스터의 안정성이 위험합니다.</target>
        </trans-unit>
        <trans-unit id="98bacc5b3624fe67c2aed3cd0d840dd98240baea" translate="yes" xml:space="preserve">
          <source>Even though most kinds of &lt;code&gt;JOIN&lt;/code&gt; don't completely constrain the join order, it is possible to instruct the PostgreSQL query planner to treat all &lt;code&gt;JOIN&lt;/code&gt; clauses as constraining the join order anyway. For example, these three queries are logically equivalent:</source>
          <target state="translated">대부분의 &lt;code&gt;JOIN&lt;/code&gt; 유형이 조인 순서를 완전히 제한하지는 않지만 PostgreSQL 쿼리 플래너가 모든 &lt;code&gt;JOIN&lt;/code&gt; 절을 조인 순서를 제한하는 것으로 취급하도록 지시 할 수 있습니다 . 예를 들어이 세 쿼리는 논리적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cd014339f1de23b1bcc5f4c392258b778fd9ab7f" translate="yes" xml:space="preserve">
          <source>Even when it is in general possible for parallel query plans to be generated, the planner will not generate them for a given query if any of the following are true:</source>
          <target state="translated">병렬 쿼리 계획을 생성하는 것이 일반적으로 가능하더라도 계획자는 다음 중 하나에 해당하는 경우 지정된 쿼리에 대해 계획을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a80c31308193949b9e4da18926b517610092195c" translate="yes" xml:space="preserve">
          <source>Even when parallel query plan is generated for a particular query, there are several circumstances under which it will be impossible to execute that plan in parallel at execution time. If this occurs, the leader will execute the portion of the plan below the &lt;code&gt;Gather&lt;/code&gt; node entirely by itself, almost as if the &lt;code&gt;Gather&lt;/code&gt; node were not present. This will happen if any of the following conditions are met:</source>
          <target state="translated">특정 쿼리에 대해 병렬 쿼리 계획이 생성 된 경우에도 실행시 해당 계획을 병렬로 실행할 수없는 몇 가지 상황이 있습니다. 이런 일이 발생하면 리더는 마치 &lt;code&gt;Gather&lt;/code&gt; 노드가없는 것처럼 &lt;code&gt;Gather&lt;/code&gt; 노드 아래에서 계획의 일부를 완전히 실행합니다 . 다음 조건 중 하나라도 충족되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24fb24cc746ad21c0ebd0ce7281b566ac42b0326" translate="yes" xml:space="preserve">
          <source>Even with this option only one &lt;code&gt;REFRESH&lt;/code&gt; at a time may run against any one materialized view.</source>
          <target state="translated">이 옵션을 사용하더라도 한 번에 하나의 &lt;code&gt;REFRESH&lt;/code&gt; 만 하나의 구체화 된보기에 대해 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="fff9768e2dd5a78de391bf51471900a97575446e" translate="yes" xml:space="preserve">
          <source>Event triggers are disabled in single-user mode (see &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;). If an erroneous event trigger disables the database so much that you can't even drop the trigger, restart in single-user mode and you'll be able to do that.</source>
          <target state="translated">단일 사용자 모드에서는 이벤트 트리거가 비활성화됩니다 ( &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 ). 잘못된 이벤트 트리거가 데이터베이스를 너무 비활성화하여 트리거를 제거 할 수없는 경우 단일 사용자 모드에서 다시 시작하면 해당 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d5400e57a51014f9b79b404545a075676f05d7" translate="yes" xml:space="preserve">
          <source>Event type that the rule is for: 1 = &lt;code&gt;SELECT&lt;/code&gt;, 2 = &lt;code&gt;UPDATE&lt;/code&gt;, 3 = &lt;code&gt;INSERT&lt;/code&gt;, 4 = &lt;code&gt;DELETE&lt;/code&gt;</source>
          <target state="translated">규칙이 적용되는 이벤트 유형 : 1 = &lt;code&gt;SELECT&lt;/code&gt; , 2 = &lt;code&gt;UPDATE&lt;/code&gt; , 3 = &lt;code&gt;INSERT&lt;/code&gt; , 4 = &lt;code&gt;DELETE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="510cbff4e121671fd1f953b5d4677d9d6b219a24" translate="yes" xml:space="preserve">
          <source>Every background worker process which is successfully started for a given parallel query will execute the parallel portion of the plan. The leader will also execute that portion of the plan, but it has an additional responsibility: it must also read all of the tuples generated by the workers. When the parallel portion of the plan generates only a small number of tuples, the leader will often behave very much like an additional worker, speeding up query execution. Conversely, when the parallel portion of the plan generates a large number of tuples, the leader may be almost entirely occupied with reading the tuples generated by the workers and performing any further processing steps which are required by plan nodes above the level of the &lt;code&gt;Gather&lt;/code&gt; node or &lt;code&gt;Gather Merge&lt;/code&gt; node. In such cases, the leader will do very little of the work of executing the parallel portion of the plan.</source>
          <target state="translated">주어진 병렬 쿼리에 대해 성공적으로 시작된 모든 백그라운드 작업자 프로세스는 계획의 병렬 부분을 실행합니다. 리더는 계획의 해당 부분을 실행하지만 추가 책임이 있습니다. 또한 작업자가 생성 한 모든 튜플을 읽어야합니다. 계획의 병렬 부분이 적은 수의 튜플 만 생성하는 경우 리더는 종종 추가 작업자와 매우 유사하게 동작하여 쿼리 실행 속도를 높입니다. 반대로, 계획의 병렬 부분이 많은 수의 튜플을 생성 할 때, 리더는 거의 전적으로 작업자가 생성 한 튜플을 읽고 &lt;code&gt;Gather&lt;/code&gt; 노드 레벨 이상의 계획 노드에 필요한 추가 처리 단계를 수행 할 수 있습니다. 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 마디. 이러한 경우 리더는 계획의 병렬 부분을 실행하는 작업을 거의 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="887b1e1617523b87a76a1697a9705c423761807a" translate="yes" xml:space="preserve">
          <source>Every connection to the database server is made using the name of some particular role, and this role determines the initial access privileges for commands issued in that connection. The role name to use for a particular database connection is indicated by the client that is initiating the connection request in an application-specific fashion. For example, the &lt;code&gt;psql&lt;/code&gt; program uses the &lt;code&gt;-U&lt;/code&gt; command line option to indicate the role to connect as. Many applications assume the name of the current operating system user by default (including &lt;code&gt;createuser&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt;). Therefore it is often convenient to maintain a naming correspondence between roles and operating system users.</source>
          <target state="translated">데이터베이스 서버에 대한 모든 연결은 특정 역할의 이름을 사용하여 이루어지며이 역할은 해당 연결에서 실행 된 명령에 대한 초기 액세스 권한을 결정합니다. 특정 데이터베이스 연결에 사용할 역할 이름은 응용 프로그램 특정 방식으로 연결 요청을 시작하는 클라이언트에 의해 표시됩니다. 예를 들어, &lt;code&gt;psql&lt;/code&gt; 프로그램은 &lt;code&gt;-U&lt;/code&gt; 명령 행 옵션을 사용하여 연결할 역할을 나타냅니다. 많은 응용 프로그램은 기본적으로 현재 운영 체제 사용자의 이름 ( &lt;code&gt;createuser&lt;/code&gt; 및 &lt;code&gt;psql&lt;/code&gt; 포함 )을 가정합니다. 따라서 역할과 운영 체제 사용자간에 이름 지정 통신을 유지하는 것이 편리한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="068f0103f321b3d8229524e3f77030d33340bd95" translate="yes" xml:space="preserve">
          <source>Every non-empty range has two bounds, the lower bound and the upper bound. All points between these values are included in the range. An inclusive bound means that the boundary point itself is included in the range as well, while an exclusive bound means that the boundary point is not included in the range.</source>
          <target state="translated">비어 있지 않은 모든 범위에는 하한과 상한의 두 가지 경계가 있습니다. 이 값 사이의 모든 지점이 범위에 포함됩니다. 포함 된 경계는 경계점 자체도 범위에 포함됨을 의미하고, 독점적 경계는 경계점이 범위에 포함되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bb703aeb5d096be9bf34789666296b83ddbb3364" translate="yes" xml:space="preserve">
          <source>Every non-holdable open cursor is implicitly closed when a transaction is terminated by &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. A holdable cursor is implicitly closed if the transaction that created it aborts via &lt;code&gt;ROLLBACK&lt;/code&gt;. If the creating transaction successfully commits, the holdable cursor remains open until an explicit &lt;code&gt;CLOSE&lt;/code&gt; is executed, or the client disconnects.</source>
          <target state="translated">트랜잭션이 &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 에 의해 종료되면 보류 불가능한 모든 열린 커서가 내재적으로 닫힙니다 . 작성 가능한 트랜잭션이 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 통해 중단되면 보류 가능 커서가 내재적으로 닫힙니다 . 작성 트랜잭션이 성공적으로 커미트되면 명시 적 &lt;code&gt;CLOSE&lt;/code&gt; 가 실행되거나 클라이언트 연결이 끊어 질 때까지 보류 가능 커서가 열린 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="a8cef86d379ae9636ed2bcb0391d594e7540897a" translate="yes" xml:space="preserve">
          <source>Every publication can have multiple subscribers.</source>
          <target state="translated">모든 발행물에는 여러 구독자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba11d62e4d7864e97ea8d9fbf2b997ccf619aaaf" translate="yes" xml:space="preserve">
          <source>Every table and index is stored as an array of &lt;em&gt;pages&lt;/em&gt; of a fixed size (usually 8 kB, although a different page size can be selected when compiling the server). In a table, all the pages are logically equivalent, so a particular item (row) can be stored in any page. In indexes, the first page is generally reserved as a &lt;em&gt;metapage&lt;/em&gt; holding control information, and there can be different types of pages within the index, depending on the index access method.</source>
          <target state="translated">모든 테이블과 인덱스는 고정 된 크기 의 &lt;em&gt;페이지&lt;/em&gt; 배열로 저장됩니다 (일반적으로 8kB이지만 서버를 컴파일 할 때 다른 페이지 크기를 선택할 수 있음). 테이블에서 모든 페이지는 논리적으로 동일하므로 특정 항목 (행)을 모든 페이지에 저장할 수 있습니다. 인덱스에서 첫 번째 페이지는 일반적으로 제어 정보를 보유 하는 &lt;em&gt;메타 페이지&lt;/em&gt; 로 예약되며 인덱스 액세스 방법에 따라 인덱스 내에 다른 유형의 페이지가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b0c5180a9306aebfb659340d557ae0f5e7b48c" translate="yes" xml:space="preserve">
          <source>Every table has several &lt;em&gt;system columns&lt;/em&gt; that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns. (Note that these restrictions are separate from whether the name is a key word or not; quoting a name will not allow you to escape these restrictions.) You do not really need to be concerned about these columns; just know they exist.</source>
          <target state="translated">Every table has several &lt;em&gt;system columns&lt;/em&gt; that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns. (Note that these restrictions are separate from whether the name is a key word or not; quoting a name will not allow you to escape these restrictions.) You do not really need to be concerned about these columns; just know they exist.</target>
        </trans-unit>
        <trans-unit id="4e5c5f63629e607e2e60e453db01fe36ebacfaa6" translate="yes" xml:space="preserve">
          <source>Every time a new timeline is created, PostgreSQL creates a &amp;ldquo;timeline history&amp;rdquo; file that shows which timeline it branched off from and when. These history files are necessary to allow the system to pick the right WAL segment files when recovering from an archive that contains multiple timelines. Therefore, they are archived into the WAL archive area just like WAL segment files. The history files are just small text files, so it's cheap and appropriate to keep them around indefinitely (unlike the segment files which are large). You can, if you like, add comments to a history file to record your own notes about how and why this particular timeline was created. Such comments will be especially valuable when you have a thicket of different timelines as a result of experimentation.</source>
          <target state="translated">새로운 타임 라인이 생성 될 때마다 PostgreSQL은 &quot;타임 라인 기록&quot;파일을 생성하여 어느 타임 라인에서 언제 시작했는지를 보여줍니다. 이 기록 파일은 여러 타임 라인이 포함 된 아카이브에서 복구 할 때 시스템이 올바른 WAL 세그먼트 파일을 선택하는 데 필요합니다. 따라서 WAL 세그먼트 파일과 마찬가지로 WAL 아카이브 영역에 아카이브됩니다. 히스토리 파일은 작은 텍스트 파일이므로 큰 세그먼트 파일과 달리 저렴하고 적절하게 보관하는 것이 좋습니다. 원하는 경우 기록 파일에 주석을 추가하여이 특정 타임 라인이 생성 된 방법과 이유에 대한 자신의 메모를 기록 할 수 있습니다. 이러한 의견은 실험 결과로 서로 다른 타임 라인이있을 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65c4690b5ee5940e1c991c2b4b010f9b8b6ec89f" translate="yes" xml:space="preserve">
          <source>Every year divisible by 4 is a leap year.</source>
          <target state="translated">매년 4로 나눌 수있는 것은 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="fa0eaf50a3a9b3fdec2a0517bd238d0ab91cd49b" translate="yes" xml:space="preserve">
          <source>Everything that is greater than or equal to 50</source>
          <target state="translated">50 이상의 모든 것</target>
        </trans-unit>
        <trans-unit id="28879d5603a0a05cd2d48100416506dd23aa25e4" translate="yes" xml:space="preserve">
          <source>Everything that is less than or equal to 0</source>
          <target state="translated">0보다 작거나 같은 모든 것</target>
        </trans-unit>
        <trans-unit id="e228d6b915ccfaec49cff235ad28c3f3c6c06405" translate="yes" xml:space="preserve">
          <source>Examining Index Usage</source>
          <target state="translated">인덱스 사용법 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="fb903849014d52641a3ffc7db73f43574d560760" translate="yes" xml:space="preserve">
          <source>Example JSON</source>
          <target state="translated">JSON 예</target>
        </trans-unit>
        <trans-unit id="66effdf0836c4ad9c2c4b516463c39866827fe51" translate="yes" xml:space="preserve">
          <source>Example Output</source>
          <target state="translated">출력 예</target>
        </trans-unit>
        <trans-unit id="0568e4ecb01023a64507eb23cb66260dfd45368e" translate="yes" xml:space="preserve">
          <source>Example Query</source>
          <target state="translated">쿼리 예</target>
        </trans-unit>
        <trans-unit id="08e254953c8903a29788b024528486e1068199ed" translate="yes" xml:space="preserve">
          <source>Example Result</source>
          <target state="translated">결과 예</target>
        </trans-unit>
        <trans-unit id="3e1793a53c9bdcb0a95661b265938b8f743356e7" translate="yes" xml:space="preserve">
          <source>Example of authentication:</source>
          <target state="translated">인증 예 :</target>
        </trans-unit>
        <trans-unit id="0b22ade5b2f97763a168cfba8698b54d3d6aa013" translate="yes" xml:space="preserve">
          <source>Example of creating such an index:</source>
          <target state="translated">그러한 색인을 작성하는 예 :</target>
        </trans-unit>
        <trans-unit id="92aaf122d1c7a2579eb3c87262fb4d3445ced618" translate="yes" xml:space="preserve">
          <source>Example of setting a new password:</source>
          <target state="translated">새 비밀번호 설정의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7f059574672fc1093b2a4e3e6c7eb57e0d0c1dc4" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Top.Countries.Europe.Russia&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;Top.Countries.Europe.Russia&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0075bd7af823016703d64e76064357a7f98bafcc" translate="yes" xml:space="preserve">
          <source>Example: To keep 24 hours of logs, one log file per hour, but also rotate sooner if the log file size exceeds 1GB, set &lt;code&gt;log_filename&lt;/code&gt; to &lt;code&gt;server_log.%H%M&lt;/code&gt;, &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;log_rotation_age&lt;/code&gt; to &lt;code&gt;60&lt;/code&gt;, and &lt;code&gt;log_rotation_size&lt;/code&gt; to &lt;code&gt;1000000&lt;/code&gt;. Including &lt;code&gt;%M&lt;/code&gt; in &lt;code&gt;log_filename&lt;/code&gt; allows any size-driven rotations that might occur to select a file name different from the hour's initial file name.</source>
          <target state="translated">예 : 로그 파일 크기가 1GB를 초과 할 경우 24 시간의 로그를 시간당 하나의 로그 파일로 유지하지만 더 빨리 회전하려면 &lt;code&gt;log_filename&lt;/code&gt; 을 &lt;code&gt;server_log.%H%M&lt;/code&gt; , &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; 을 &lt;code&gt;on&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_age&lt;/code&gt; 를 &lt;code&gt;60&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_size&lt;/code&gt; 를 &lt;code&gt;1000000&lt;/code&gt; 으로 설정하십시오 . &lt;code&gt;log_filename&lt;/code&gt; 에 &lt;code&gt;%M&lt;/code&gt; 을 포함 하면 시간의 초기 파일 이름과 다른 파일 이름을 선택하기 위해 발생할 수있는 크기 중심 회전이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9f0388078445111d3dbb9e29940a6d2e0a03fa91" translate="yes" xml:space="preserve">
          <source>Example: To keep 7 days of logs, one log file per day named &lt;code&gt;server_log.Mon&lt;/code&gt;, &lt;code&gt;server_log.Tue&lt;/code&gt;, etc, and automatically overwrite last week's log with this week's log, set &lt;code&gt;log_filename&lt;/code&gt; to &lt;code&gt;server_log.%a&lt;/code&gt;, &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;log_rotation_age&lt;/code&gt; to &lt;code&gt;1440&lt;/code&gt;.</source>
          <target state="translated">예 : 하루에 &lt;code&gt;server_log.Mon&lt;/code&gt; , &lt;code&gt;server_log.Tue&lt;/code&gt; 등으로 이름 지정된 로그 파일 7 일을 유지 하고 이번 주 로그로 지난 주 로그를 자동으로 덮어 &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; 려면 &lt;code&gt;log_filename&lt;/code&gt; 을 &lt;code&gt;server_log.%a&lt;/code&gt; , log_truncate_on_rotation 을 &lt;code&gt;on&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_age&lt;/code&gt; 로 설정하십시오. ~ &lt;code&gt;1440&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8472e2354405f69deb803796fe2c02c7737842bd" translate="yes" xml:space="preserve">
          <source>Examples (assuming the local time zone is &lt;code&gt;America/Los_Angeles&lt;/code&gt;):</source>
          <target state="translated">예 (현지 시간대가 &lt;code&gt;America/Los_Angeles&lt;/code&gt; 라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="33cdb73d833d65f495cd316014972491e84a6421" translate="yes" xml:space="preserve">
          <source>Examples (assuming the local time zone is &lt;code&gt;America/New_York&lt;/code&gt;):</source>
          <target state="translated">예 (현지 시간대가 &lt;code&gt;America/New_York&lt;/code&gt; 라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="099d24c3abaa6b8f8c50508e2936f6f3e4940ccb" translate="yes" xml:space="preserve">
          <source>Examples are given in the &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section of the &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; documentation.</source>
          <target state="translated">예는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 문서 의 &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;예&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="742c8a1506366726fbe52da33bbba1b91ba9383e" translate="yes" xml:space="preserve">
          <source>Examples in this manual can also be found in the PostgreSQL source distribution in the directory &lt;code&gt;src/tutorial/&lt;/code&gt;. (Binary distributions of PostgreSQL might not compile these files.) To use those files, first change to that directory and run make:</source>
          <target state="translated">이 매뉴얼의 예제는 &lt;code&gt;src/tutorial/&lt;/code&gt; 디렉토리의 PostgreSQL 소스 배포에서도 찾을 수 있습니다 . (PostgreSQL의 바이너리 배포판은 이러한 파일을 컴파일하지 못할 수 있습니다.) 해당 파일을 사용하려면 먼저 해당 디렉토리로 변경하고 make를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="46ada8ab8f7f6bba7ddd1881ea3bc88ca95c9039" translate="yes" xml:space="preserve">
          <source>Examples in this section are drawn from the regression test database after doing a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;, using 9.3 development sources. You should be able to get similar results if you try the examples yourself, but your estimated costs and row counts might vary slightly because &lt;code&gt;ANALYZE&lt;/code&gt;'s statistics are random samples rather than exact, and because costs are inherently somewhat platform-dependent.</source>
          <target state="translated">이 섹션의 예제는 9.3 개발 소스를 사용하여 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 를 수행 한 후 회귀 테스트 데이터베이스에서 가져옵니다 . 예제를 직접 시도하면 비슷한 결과를 얻을 수 있지만 &lt;code&gt;ANALYZE&lt;/code&gt; 의 통계는 정확한 것이 아니라 무작위 샘플이고 비용은 본질적으로 플랫폼에 따라 다르기 때문에 예상 비용과 행 수는 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83b362a5cd12ed5136add2e4a37fd6e93b3b3081" translate="yes" xml:space="preserve">
          <source>Examples of cost estimator functions can be found in &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt;.</source>
          <target state="translated">비용 견적 기능의 예는 &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5de2f10ca767c0e44c4a3cce854ed17297b86a17" translate="yes" xml:space="preserve">
          <source>Examples of requirements that might be solved within a script include:</source>
          <target state="translated">스크립트 내에서 해결 될 수있는 요구 사항의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6875ccc7e641f5de84d947d364ef4dad711ae2d8" translate="yes" xml:space="preserve">
          <source>Examples of safe circumstances for turning off &lt;code&gt;fsync&lt;/code&gt; include the initial loading of a new database cluster from a backup file, using a database cluster for processing a batch of data after which the database will be thrown away and recreated, or for a read-only database clone which gets recreated frequently and is not used for failover. High quality hardware alone is not a sufficient justification for turning off &lt;code&gt;fsync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 해제하기위한 안전한 환경의 예로는 백업 파일에서 새 데이터베이스 클러스터를 처음로드하는 것, 데이터베이스 클러스터를 사용하여 데이터베이스를 폐기하고 다시 생성 한 후 또는 읽기 전용 데이터베이스를 사용하는 것 등이 있습니다. 복제가 자주 이루어지고 장애 조치에 사용되지 않습니다. 고품질 하드웨어만으로는 &lt;code&gt;fsync&lt;/code&gt; 를 끄기에 충분하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="851cdc1cfb89f844054b6836cfc41b2c935d46b8" translate="yes" xml:space="preserve">
          <source>Examples: &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;Personal_Services&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;42&lt;/code&gt; , &lt;code&gt;Personal_Services&lt;/code&gt; _ 서비스</target>
        </trans-unit>
        <trans-unit id="35da7c6b32a24e6eed204eac089ed634cb1bf145" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;ACCESS SHARE&lt;/code&gt;, &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, and &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock modes, the PostgreSQL lock modes and the &lt;code&gt;LOCK TABLE&lt;/code&gt; syntax are compatible with those present in Oracle.</source>
          <target state="translated">를 제외하고 &lt;code&gt;ACCESS SHARE&lt;/code&gt; , &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 및 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 락 모드를, PostgreSQL의 락 모드와 &lt;code&gt;LOCK TABLE&lt;/code&gt; 구문은 오라클에서 그 존재와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fe039bd062569c687ede9f41e7b80ad57465cf" translate="yes" xml:space="preserve">
          <source>Except where noted, all the views described here are read-only.</source>
          <target state="translated">언급 된 경우를 제외하고 여기에 설명 된 모든보기는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e828254c0368c4232a43a1d8994e1832d17dfacb" translate="yes" xml:space="preserve">
          <source>Exclude large objects in the dump.</source>
          <target state="translated">덤프에서 큰 오브젝트를 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="83fdd2c71eb5fbf45469325c816eabb498d9afbf" translate="yes" xml:space="preserve">
          <source>Exclude specified foreign tables from the import. All tables existing in the foreign schema will be imported except the ones listed here.</source>
          <target state="translated">가져 오기에서 지정된 외부 테이블을 제외하십시오. 여기에 나열된 테이블을 제외하고 외부 스키마에 존재하는 모든 테이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8d1ff854ba786d4a02750ff27dbde99c53eb7679" translate="yes" xml:space="preserve">
          <source>Exclusion constraints are implemented using an index, so each specified operator must be associated with an appropriate operator class (see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt;) for the index access method &lt;code&gt;index_method&lt;/code&gt;. The operators are required to be commutative. Each &lt;code&gt;exclude_element&lt;/code&gt; can optionally specify an operator class and/or ordering options; these are described fully under &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;.</source>
          <target state="translated">제외 제약 조건은 인덱스를 사용하여 구현되므로 지정된 각 연산자는 인덱스 액세스 방법 &lt;code&gt;index_method&lt;/code&gt; 에 적합한 연산자 클래스 ( &lt;a href=&quot;indexes-opclass&quot;&gt;11.10 절&lt;/a&gt; 참조)와 연결되어야합니다 . 연산자는 정식이어야합니다. 각 &lt;code&gt;exclude_element&lt;/code&gt; 는 선택적으로 연산자 클래스 및 / 또는 순서 옵션을 지정할 수 있습니다. 이것들은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="325362b3bfcd3f16918d4d0c6750a65a1dd8f170" translate="yes" xml:space="preserve">
          <source>Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null. The syntax is:</source>
          <target state="translated">제외 제약 조건은 지정된 연산자를 사용하여 지정된 열이나 식에서 두 행을 비교하는 경우 이러한 연산자 비교 중 하나 이상이 false 또는 null을 반환합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="213cfc7597d88344bf806d4892d04bfbbc89fcea" translate="yes" xml:space="preserve">
          <source>Execute monitoring functions that may take &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on tables, potentially for a long time.</source>
          <target state="translated">잠재적으로 테이블에서 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 잠금을 수행 할 수있는 모니터링 기능을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f68d1ff40afb62998db4655ae79b633e479f56e2" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_account_update&lt;/code&gt; whenever a row of the table &lt;code&gt;accounts&lt;/code&gt; is about to be updated:</source>
          <target state="translated">테이블 &lt;code&gt;accounts&lt;/code&gt; 의 행을 업데이트 &lt;code&gt;check_account_update&lt;/code&gt; 할 때마다 check_account_update 함수를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="973f7fa817c4c00cf8cb1f780941428a1b6ce439" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_matching_pairs&lt;/code&gt; for each row to confirm that changes are made to matching pairs at the same time (by the same statement):</source>
          <target state="translated">각 행에 대해 &lt;code&gt;check_matching_pairs&lt;/code&gt; 함수를 실행하여 동일한 명령문으로 일치하는 쌍이 동시에 변경 되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80f7e2f983e8dc04b3b9350ac9e67b90053423f7" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_transfer_balances_to_zero&lt;/code&gt; for each statement to confirm that the &lt;code&gt;transfer&lt;/code&gt; rows offset to a net of zero:</source>
          <target state="translated">각 명령문에 대해 &lt;code&gt;check_transfer_balances_to_zero&lt;/code&gt; 함수를 실행하여 &lt;code&gt;transfer&lt;/code&gt; 행이 0의 순으로 오프셋 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="325bf3f48152d3c7b85e0489bf435ea01b518f1f" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;view_insert_row&lt;/code&gt; for each row to insert rows into the tables underlying a view:</source>
          <target state="translated">각 행에 대해 &lt;code&gt;view_insert_row&lt;/code&gt; 함수를 실행하여 뷰의 기초가되는 테이블에 행을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="dbc75e4af30fdf9e85a66b0417aa7a131b074cf2" translate="yes" xml:space="preserve">
          <source>Execute the restore as a single transaction (that is, wrap the emitted commands in &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt;). This ensures that either all the commands complete successfully, or no changes are applied. This option implies &lt;code&gt;--exit-on-error&lt;/code&gt;.</source>
          <target state="translated">단일 트랜잭션으로 복원을 실행하십시오 (즉, 생성 된 명령을 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 에 랩 ). 이렇게하면 모든 명령이 성공적으로 완료되거나 변경 사항이 적용되지 않습니다. 이 옵션은 &lt;code&gt;--exit-on-error&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="373f9c05993c1a03043edfc39866631c89b0f5e8" translate="yes" xml:space="preserve">
          <source>Execute the vacuum or analyze commands in parallel by running &lt;code&gt;njobs&lt;/code&gt; commands simultaneously. This option reduces the time of the processing but it also increases the load on the database server.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 명령을 동시에 실행하여 진공을 실행하거나 명령을 병렬로 실행 하십시오 . 이 옵션은 처리 시간을 줄이지 만 데이터베이스 서버의로드도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="8e26d205c84542e88787603bb1bf7d32c21bd66e" translate="yes" xml:space="preserve">
          <source>Execute transactions targeting the specified rate instead of running as fast as possible (the default). The rate is given in transactions per second. If the targeted rate is above the maximum possible rate, the rate limit won't impact the results.</source>
          <target state="translated">가능한 빨리 실행하는 대신 지정된 비율을 대상으로하는 트랜잭션을 실행하십시오 (기본값). 비율은 초당 트랜잭션으로 제공됩니다. 목표 요율이 최대 요율보다 높으면 요율 제한이 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec29950a103356b62716ea977952173d73196586" translate="yes" xml:space="preserve">
          <source>Executes the current query buffer (like &lt;code&gt;\g&lt;/code&gt;) and shows the results in a crosstab grid. The query must return at least three columns. The output column identified by &lt;code&gt;colV&lt;/code&gt; becomes a vertical header and the output column identified by &lt;code&gt;colH&lt;/code&gt; becomes a horizontal header. &lt;code&gt;colD&lt;/code&gt; identifies the output column to display within the grid. &lt;code&gt;sortcolH&lt;/code&gt; identifies an optional sort column for the horizontal header.</source>
          <target state="translated">현재 쿼리 버퍼 ( &lt;code&gt;\g&lt;/code&gt; )를 실행하고 결과를 크로스 탭 그리드에 표시합니다. 쿼리는 3 개 이상의 열을 반환해야합니다. &lt;code&gt;colV&lt;/code&gt; 로 식별 된 출력 열 은 세로 헤더 가 되고 &lt;code&gt;colH&lt;/code&gt; 로 식별 된 출력 열 은 가로 헤더가됩니다. &lt;code&gt;colD&lt;/code&gt; 는 그리드 내에 표시 할 출력 열을 식별합니다. &lt;code&gt;sortcolH&lt;/code&gt; 는 수평 헤더에 대한 선택적 정렬 열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="2a264333c89958c5123b9533cdf455a29d775b5b" translate="yes" xml:space="preserve">
          <source>Executing a command with &lt;code&gt;PROGRAM&lt;/code&gt; might be restricted by the operating system's access control mechanisms, such as SELinux.</source>
          <target state="translated">&lt;code&gt;PROGRAM&lt;/code&gt; 으로 명령을 실행하는 것은 SELinux와 같은 운영 체제의 액세스 제어 메커니즘에 의해 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="339a8528af8223bc10ea0f77d0f208de3f1ce898" translate="yes" xml:space="preserve">
          <source>Execution-time partition pruning currently only occurs for the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; node types. It is not yet implemented for the &lt;code&gt;ModifyTable&lt;/code&gt; node type, but that is likely to be changed in a future release of PostgreSQL.</source>
          <target state="translated">실행 시간 파티션 정리는 현재 &lt;code&gt;Append&lt;/code&gt; 및 &lt;code&gt;MergeAppend&lt;/code&gt; 노드 유형에 대해서만 발생합니다 . &lt;code&gt;ModifyTable&lt;/code&gt; 노드 유형에 대해서는 아직 구현되지 않았지만 향후 PostgreSQL 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f6604b7486fef57febf39070b6b5f55ece6c6b" translate="yes" xml:space="preserve">
          <source>Executor</source>
          <target state="translated">Executor</target>
        </trans-unit>
        <trans-unit id="b90fddf2bc2d6256c8e2ecb71d9c0ed9bde6a5bf" translate="yes" xml:space="preserve">
          <source>Existing &amp;amp; new rows</source>
          <target state="translated">기존 및 새 행</target>
        </trans-unit>
        <trans-unit id="934b5c9d3d27ed262c8bd429e388e9a9abd89875" translate="yes" xml:space="preserve">
          <source>Existing &amp;amp; new rows &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">기존 및 새 행 &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a6c01e5f162f19b12916d1546797cdbec555" translate="yes" xml:space="preserve">
          <source>Existing replication slots and their state can be seen in the &lt;a href=&quot;view-pg-replication-slots&quot;&gt;&lt;code&gt;pg_replication_slots&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="translated">기존 복제 슬롯 및 해당 상태는 &lt;a href=&quot;view-pg-replication-slots&quot;&gt; &lt;code&gt;pg_replication_slots&lt;/code&gt; &lt;/a&gt; 보기 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="606c3933da970b1c7e75f4ef36f3c7ad379d14ac" translate="yes" xml:space="preserve">
          <source>Existing row</source>
          <target state="translated">기존 행</target>
        </trans-unit>
        <trans-unit id="419dd50ebb1b22b3eb16972fe85c81ef88d5f9e5" translate="yes" xml:space="preserve">
          <source>Existing row &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">기존 행 &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f147bbcdc2ea57f6c81bec669ec536b253dc54b" translate="yes" xml:space="preserve">
          <source>Exit Status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="028ddb1fdd2ac3734c1e28cdf22fa5a854aaece2" translate="yes" xml:space="preserve">
          <source>Exit if an error is encountered while sending SQL commands to the database. The default is to continue and to display a count of errors at the end of the restoration.</source>
          <target state="translated">SQL 명령을 데이터베이스에 보내는 동안 오류가 발생하면 종료하십시오. 기본값은 계속되고 복원 종료시 오류 수를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd3f1eddfd61de0467e1a1bf980bcdc41ac18497" translate="yes" xml:space="preserve">
          <source>Expanded TOAST pointers are useful for complex data types whose on-disk representation is not especially suited for computational purposes. As an example, the standard varlena representation of a PostgreSQL array includes dimensionality information, a nulls bitmap if there are any null elements, then the values of all the elements in order. When the element type itself is variable-length, the only way to find the &lt;code&gt;N&lt;/code&gt;'th element is to scan through all the preceding elements. This representation is appropriate for on-disk storage because of its compactness, but for computations with the array it's much nicer to have an &amp;ldquo;expanded&amp;rdquo; or &amp;ldquo;deconstructed&amp;rdquo; representation in which all the element starting locations have been identified. The TOAST pointer mechanism supports this need by allowing a pass-by-reference Datum to point to either a standard varlena value (the on-disk representation) or a TOAST pointer that points to an expanded representation somewhere in memory. The details of this expanded representation are up to the data type, though it must have a standard header and meet the other API requirements given in &lt;code&gt;src/include/utils/expandeddatum.h&lt;/code&gt;. C-level functions working with the data type can choose to handle either representation. Functions that do not know about the expanded representation, but simply apply &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; to their inputs, will automatically receive the traditional varlena representation; so support for an expanded representation can be introduced incrementally, one function at a time.</source>
          <target state="translated">확장 된 TOAST 포인터는 온 디스크 표현이 계산 목적에 특히 적합하지 않은 복잡한 데이터 유형에 유용합니다. 예를 들어, PostgreSQL 배열의 표준 varlena 표현에는 차원 정보, 널 요소가있는 경우 널 비트 맵, 모든 요소의 값이 순서대로 포함됩니다. 요소 유형 자체가 가변 길이 인 경우 &lt;code&gt;N&lt;/code&gt; 을 찾는 유일한 방법'번째 요소는 앞의 모든 요소를 ​​스캔하는 것입니다. 이 표현은 크기가 작기 때문에 온 디스크 스토리지에 적합하지만 어레이를 사용한 계산의 경우 모든 요소 시작 위치가 식별 된 &quot;확장&quot;또는 &quot;해체&quot;표현이 훨씬 좋습니다. TOAST 포인터 메커니즘은 기준 별 기준 데이텀이 표준 varlena 값 (온 디스크 표현) 또는 메모리 어딘가의 확장 표현을 가리키는 TOAST 포인터를 가리 키도록하여 이러한 요구를 지원합니다. 이 확장 표현의 세부 사항은 데이터 유형에 따라 다르지만 표준 헤더가 있어야하고 &lt;code&gt;src/include/utils/expandeddatum.h&lt;/code&gt; 에 제공된 다른 API 요구 사항을 충족해야합니다.. 데이터 유형으로 작업하는 C 레벨 함수는 두 표현 중 하나를 처리하도록 선택할 수 있습니다. 확장 표현에 대해서는 모르지만 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 을 입력에 적용하는 함수 는 자동으로 전통적인 바레 나 표현을받습니다. 확장 된 표현에 대한 지원은 한 번에 한 기능 씩 점진적으로 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370e6267e22c067604ebc57062ada21b7609d4c3" translate="yes" xml:space="preserve">
          <source>Expands a JSON array to a set of &lt;code&gt;text&lt;/code&gt; values.</source>
          <target state="translated">JSON 배열을 일련의 &lt;code&gt;text&lt;/code&gt; 값으로 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="bf9f5179e248278db3bd9e202741f05d488c956f" translate="yes" xml:space="preserve">
          <source>Expands a JSON array to a set of JSON values.</source>
          <target state="translated">JSON 배열을 일련의 JSON 값으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="d82ee60a5062bc5b8e066e5961be39131485da38" translate="yes" xml:space="preserve">
          <source>Expands the object in &lt;code&gt;from_json&lt;/code&gt; to a row whose columns match the record type defined by &lt;code&gt;base&lt;/code&gt; (see note below).</source>
          <target state="translated">&lt;code&gt;from_json&lt;/code&gt; 의 오브젝트를 열이 &lt;code&gt;base&lt;/code&gt; 에 의해 정의 된 레코드 유형과 일치하는 행으로 확장합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="6fbf031c9047c3f5e9366977102918179b27f990" translate="yes" xml:space="preserve">
          <source>Expands the outermost JSON object into a set of key/value pairs.</source>
          <target state="translated">가장 바깥 쪽 JSON 객체를 일련의 키 / 값 쌍으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="ef70fe44bd312be7a9fa6873660eab981e4f5489" translate="yes" xml:space="preserve">
          <source>Expands the outermost JSON object into a set of key/value pairs. The returned values will be of type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">가장 바깥 쪽 JSON 객체를 일련의 키 / 값 쌍으로 확장합니다. 반환되는 값은 &lt;code&gt;text&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="07d2aad3737c433e4d588a6cebf30375bd4aeada" translate="yes" xml:space="preserve">
          <source>Expands the outermost array of objects in &lt;code&gt;from_json&lt;/code&gt; to a set of rows whose columns match the record type defined by &lt;code&gt;base&lt;/code&gt; (see note below).</source>
          <target state="translated">&lt;code&gt;from_json&lt;/code&gt; 의 가장 바깥 쪽 객체 배열을 &lt;code&gt;base&lt;/code&gt; 정의 된 레코드 유형과 일치하는 열 집합으로 확장합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="0d3b4356c136073d19e986dde8e382aa16bfea32" translate="yes" xml:space="preserve">
          <source>Experienced users should note that both row version cleanup and row version freezing will potentially conflict with standby queries. Running a manual &lt;code&gt;VACUUM FREEZE&lt;/code&gt; is likely to cause conflicts even on tables with no updated or deleted rows.</source>
          <target state="translated">숙련 된 사용자는 행 버전 정리 및 행 버전 동결이 모두 대기 쿼리와 충돌 할 수 있습니다. 수동 &lt;code&gt;VACUUM FREEZE&lt;/code&gt; 를 실행하면 업데이트되거나 삭제 된 행이없는 테이블에서도 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df0a1a0293d8d5772b31ea82ca7e2d1df56d915" translate="yes" xml:space="preserve">
          <source>Experiment with the parallel dump and restore modes of both pg_dump and pg_restore and find the optimal number of concurrent jobs to use. Dumping and restoring in parallel by means of the &lt;code&gt;-j&lt;/code&gt; option should give you a significantly higher performance over the serial mode.</source>
          <target state="translated">pg_dump 및 pg_restore의 병렬 덤프 및 복원 모드를 실험하고 사용할 최적의 동시 작업 수를 찾으십시오. &lt;code&gt;-j&lt;/code&gt; 옵션 을 사용하여 병렬로 덤프 및 복원 하면 직렬 모드보다 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="10f4c78e2d54e6fc16c1649b65551ffb5394a047" translate="yes" xml:space="preserve">
          <source>Explanation of the default value:</source>
          <target state="translated">기본값에 대한 설명 :</target>
        </trans-unit>
        <trans-unit id="bd377ba1030565fb2d84b794128302f008afe983" translate="yes" xml:space="preserve">
          <source>Explicit Locking</source>
          <target state="translated">명시 적 잠금</target>
        </trans-unit>
        <trans-unit id="07389d02cbf0907278f5b5c21ac954bccbd86d65" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Advisory Locks</source>
          <target state="translated">명시 적 잠금 : 권고 잠금</target>
        </trans-unit>
        <trans-unit id="715daa93ec48db20fc1b4a09d1802add0d50f89b" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Deadlocks</source>
          <target state="translated">명시 적 잠금 : 교착 상태</target>
        </trans-unit>
        <trans-unit id="ed518bfe5cc7ec8d2baadfa5f341c6a5faaafab9" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Page-Level Locks</source>
          <target state="translated">명시 적 잠금 : 페이지 수준 잠금</target>
        </trans-unit>
        <trans-unit id="bf8e4170549e2eb66334d6e43c2f17d676270190" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Row-Level Locks</source>
          <target state="translated">명시 적 잠금 : 행 수준 잠금</target>
        </trans-unit>
        <trans-unit id="69bc449531e08c8db82219a45329b4077d173450" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Table-Level Locks</source>
          <target state="translated">명시 적 잠금 : 테이블 수준 잠금</target>
        </trans-unit>
        <trans-unit id="8a4798d12c7f788cdaf284307c4d2130df861d48" translate="yes" xml:space="preserve">
          <source>Explicit inner join syntax (&lt;code&gt;INNER JOIN&lt;/code&gt;, &lt;code&gt;CROSS JOIN&lt;/code&gt;, or unadorned &lt;code&gt;JOIN&lt;/code&gt;) is semantically the same as listing the input relations in &lt;code&gt;FROM&lt;/code&gt;, so it does not constrain the join order.</source>
          <target state="translated">명시 적 내부 조인 구문 ( &lt;code&gt;INNER JOIN&lt;/code&gt; , &lt;code&gt;CROSS JOIN&lt;/code&gt; 또는 unadorned &lt;code&gt;JOIN&lt;/code&gt; )은 의미 적으로 &lt;code&gt;FROM&lt;/code&gt; 에 입력 관계를 나열하는 것과 동일 하므로 조인 순서를 제한하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29509d345e82da65e8974d9bce320a4045bf4357" translate="yes" xml:space="preserve">
          <source>Explicitly specifies an arbiter &lt;em&gt;constraint&lt;/em&gt; by name, rather than inferring a constraint or index.</source>
          <target state="translated">제약 조건이나 인덱스를 유추하지 않고 이름으로 중재자 &lt;em&gt;제약 조건&lt;/em&gt; 을 명시 적으로 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="365e3a9a34943313be4ba1dc166152310bb9ff19" translate="yes" xml:space="preserve">
          <source>Expression evaluation is used to evaluate &lt;code&gt;WHERE&lt;/code&gt; clauses, target lists, aggregates and projections. It can be accelerated by generating code specific to each case.</source>
          <target state="translated">식 평가는 &lt;code&gt;WHERE&lt;/code&gt; 절, 대상 목록, 집계 및 예측 을 평가하는 데 사용됩니다 . 각 경우에 맞는 코드를 생성하여 가속화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba4e5b8b6216e5d70e5f6f22f4545d9b2ac1883" translate="yes" xml:space="preserve">
          <source>Expression tree (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for partial index predicate. Null if not a partial index.</source>
          <target state="translated">부분 인덱스 술어에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현). 부분 인덱스가 아닌 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="ed5fd30c0216e18f0c9c36db6432c2bb2eccc517" translate="yes" xml:space="preserve">
          <source>Expression tree (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the trigger's &lt;code&gt;WHEN&lt;/code&gt; condition, or null if none</source>
          <target state="translated">트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 또는없는 경우 널</target>
        </trans-unit>
        <trans-unit id="016286ae409d7c91d1a1498bfae9a81ea0711739" translate="yes" xml:space="preserve">
          <source>Expression tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's qualifying condition</source>
          <target state="translated">규칙의 한정 조건에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현 형식)</target>
        </trans-unit>
        <trans-unit id="469a93adf4f3e0c5965c1ffbcb51388c4d1f61c4" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for default values. This is a list with &lt;code&gt;pronargdefaults&lt;/code&gt; elements, corresponding to the last &lt;code&gt;N&lt;/code&gt;&lt;em&gt;input&lt;/em&gt; arguments (i.e., the last &lt;code&gt;N&lt;/code&gt;&lt;code&gt;proargtypes&lt;/code&gt; positions). If none of the arguments have defaults, this field will be null.</source>
          <target state="translated">기본값의 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 마지막 &lt;code&gt;N&lt;/code&gt; 개의&lt;em&gt;입력&lt;/em&gt; 인수 (즉, 마지막 &lt;code&gt;N&lt;/code&gt; 개의 &lt;code&gt;proargtypes&lt;/code&gt; 위치)에 해당하는 &lt;code&gt;pronargdefaults&lt;/code&gt; 요소 가있는 목록입니다 . 기본값이없는 인수가 없으면이 필드는 널입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7938a326f59c4e813d7b7ad39b5fb56dac45fa45" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for index attributes that are not simple column references. This is a list with one element for each zero entry in &lt;code&gt;indkey&lt;/code&gt;. Null if all index attributes are simple references.</source>
          <target state="translated">단순한 열 참조가 아닌 인덱스 속성에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 이것은 &lt;code&gt;indkey&lt;/code&gt; 의 각 0 항목에 대해 하나의 요소가있는 목록입니다 . 모든 인덱스 속성이 간단한 참조이면 null입니다.</target>
        </trans-unit>
        <trans-unit id="534241592d7ae67f9f1ae679891827b2ed8498d6" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for partition key columns that are not simple column references. This is a list with one element for each zero entry in &lt;code&gt;partattrs&lt;/code&gt;. Null if all partition key columns are simple references.</source>
          <target state="translated">단순 열 참조가 아닌 파티션 키 열에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현). 이 목록은 &lt;code&gt;partattrs&lt;/code&gt; 의 각 0 항목에 대해 하나의 요소가있는 목록입니다 . 모든 파티션 키 열이 간단한 참조 인 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="f6adaa99da80e4400f1f7a90282b9da5f047824b" translate="yes" xml:space="preserve">
          <source>Expressions are not supported as included columns since they cannot be used in index-only scans.</source>
          <target state="translated">인덱스 전용 스캔에서는 사용할 수 없으므로 표현식은 포함 된 열로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c772de246f3ef8977c4194f44909593460fd72c" translate="yes" xml:space="preserve">
          <source>Expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause can refer both to grouped expressions and to ungrouped expressions (which necessarily involve an aggregate function).</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 절의 표현식은 그룹화 된 표현식과 그룹화되지 않은 표현식 (필수적으로 집계 함수를 포함 함)을 모두 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcee9a80b5efecec53c25e1a9558b021c463d7ea" translate="yes" xml:space="preserve">
          <source>Expressions that do not properly evaluate to true or false will generate a warning and be treated as false.</source>
          <target state="translated">true 또는 false로 올바르게 평가되지 않은 표현식은 경고를 생성하고 false로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3df35db9e658f59390afaab4ee6ca6a77c762e48" translate="yes" xml:space="preserve">
          <source>Extended DES</source>
          <target state="translated">확장 된 DES</target>
        </trans-unit>
        <trans-unit id="610ac3f96dd2b6898def2f89d8c23932807ddd84" translate="yes" xml:space="preserve">
          <source>Extended National Standard</source>
          <target state="translated">확장 된 국가 표준</target>
        </trans-unit>
        <trans-unit id="f9502e7d5dd333ff5052f41e8c24f18e62ed6956" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-CN</source>
          <target state="translated">확장 UNIX 코드 CN</target>
        </trans-unit>
        <trans-unit id="76f1a6ce7cdd954c81e01d8064d59c892a6935e9" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-JP</source>
          <target state="translated">확장 UNIX 코드 -JP</target>
        </trans-unit>
        <trans-unit id="e0d26490286dcf8cc651f76d5d159e52f88230ef" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-JP, JIS X 0213</source>
          <target state="translated">확장 UNIX 코드 -JP, JIS X 0213</target>
        </trans-unit>
        <trans-unit id="71c48b0679f5fd722af2729d8d29a635127b32bb" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-KR</source>
          <target state="translated">확장 UNIX 코드 KR</target>
        </trans-unit>
        <trans-unit id="6f052b7ecf6ec012c2c3fcbee8854db7f563b07f" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-TW</source>
          <target state="translated">확장 UNIX 코드 -TW</target>
        </trans-unit>
        <trans-unit id="ffc0097bfdee7b41005e9ec7165c9b9a978c0d17" translate="yes" xml:space="preserve">
          <source>Extended statistic object containing the definition for this data</source>
          <target state="translated">이 데이터에 대한 정의를 포함하는 확장 된 통계 개체</target>
        </trans-unit>
        <trans-unit id="23e4ded7109281c27fc76881f77dd71ff7811e57" translate="yes" xml:space="preserve">
          <source>Extended statistics are copied to the new table.</source>
          <target state="translated">확장 된 통계는 새 테이블로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="02c94538d1874480a4371b6ab14ef1e2eea48fb4" translate="yes" xml:space="preserve">
          <source>Extensibility</source>
          <target state="translated">Extensibility</target>
        </trans-unit>
        <trans-unit id="04c63ad73302c8ab810c48f3053854e7cbfe493c" translate="yes" xml:space="preserve">
          <source>Extensibility: Inlining Support for Extensions</source>
          <target state="translated">확장 성 : 확장 지원 지원</target>
        </trans-unit>
        <trans-unit id="5c32910fca448eba323615ca2bb16526e8cfcae9" translate="yes" xml:space="preserve">
          <source>Extensibility: Pluggable JIT Providers</source>
          <target state="translated">확장 성 : 플러그 가능 JIT 제공자</target>
        </trans-unit>
        <trans-unit id="d8379449b77cd40626b7ba635ee49b685b2d0526" translate="yes" xml:space="preserve">
          <source>Extensible Markup Language</source>
          <target state="translated">확장 가능한 마크 업 언어</target>
        </trans-unit>
        <trans-unit id="b209f03aa540026e6f57dfc538bb2aed73ef4f66" translate="yes" xml:space="preserve">
          <source>Extension name</source>
          <target state="translated">확장명</target>
        </trans-unit>
        <trans-unit id="13c07b09fd86c98bcc81518e9db1451bc5c4b54f" translate="yes" xml:space="preserve">
          <source>External Syntax</source>
          <target state="translated">외부 구문</target>
        </trans-unit>
        <trans-unit id="1dd06b9587505cd303a5381507906388efe27f22" translate="yes" xml:space="preserve">
          <source>External tools may also modify &lt;code&gt;postgresql.auto.conf&lt;/code&gt;. It is not recommended to do this while the server is running, since a concurrent &lt;code&gt;ALTER SYSTEM&lt;/code&gt; command could overwrite such changes. Such tools might simply append new settings to the end, or they might choose to remove duplicate settings and/or comments (as &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will).</source>
          <target state="translated">외부 도구도 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 를 수정할 수 있습니다 . 동시 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 명령이 이러한 변경 사항을 겹쳐 쓸 수 있으므로 서버가 실행 중일 때는이 작업을 수행하지 않는 것이 좋습니다 . 이러한 도구는 단순히 새로운 설정을 끝에 추가하거나 중복 설정 및 / 또는 주석을 제거하도록 선택할 수 있습니다 ( &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b8ec878cfa9ef45438a6cae306a1abbb10bc541e" translate="yes" xml:space="preserve">
          <source>Extract bit from string</source>
          <target state="translated">문자열에서 비트 추출</target>
        </trans-unit>
        <trans-unit id="efbac2c77c617feef5ed32054f6ec6f4dc45fc3c" translate="yes" xml:space="preserve">
          <source>Extract byte from string</source>
          <target state="translated">문자열에서 바이트 추출</target>
        </trans-unit>
        <trans-unit id="2f797a8b6f50a18e5a2075a9206a7b17e7ba785a" translate="yes" xml:space="preserve">
          <source>Extract substring</source>
          <target state="translated">부분 문자열 추출</target>
        </trans-unit>
        <trans-unit id="42e4ecc9582b48bbbe7ec04769377c6b3c2d2f45" translate="yes" xml:space="preserve">
          <source>Extract substring (same as &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;from&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt;)</source>
          <target state="translated">추출 문자열 (동일 &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;from&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74120afc87666fe0a0017da57004971b56a6d2b1" translate="yes" xml:space="preserve">
          <source>Extract substring matching POSIX regular expression. See &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt; for more information on pattern matching.</source>
          <target state="translated">POSIX 정규식과 일치하는 부분 문자열을 추출하십시오. 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;functions-matching&quot;&gt;은 9.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6201f97ec818d2ec790c00a0a34c900f98d2aaaa" translate="yes" xml:space="preserve">
          <source>Extract substring matching SQL regular expression. See &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt; for more information on pattern matching.</source>
          <target state="translated">SQL 정규식과 일치하는 부분 문자열을 추출하십시오. 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;functions-matching&quot;&gt;은 9.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7a71a465de60f23a58aaea7cebfe239e39640f3" translate="yes" xml:space="preserve">
          <source>F.1. adminpack</source>
          <target state="translated">F.1. adminpack</target>
        </trans-unit>
        <trans-unit id="25e26bea23097f562c5939c8d8c67e04ba7a8b4f" translate="yes" xml:space="preserve">
          <source>F.10. dblink</source>
          <target state="translated">F.10. dblink</target>
        </trans-unit>
        <trans-unit id="2ea823f8fd9afb139b70cf67092903d0e6c25b37" translate="yes" xml:space="preserve">
          <source>F.11. dict_int</source>
          <target state="translated">F.11. dict_int</target>
        </trans-unit>
        <trans-unit id="dd955bfaab7ef81b6056677b03d388fab6e57725" translate="yes" xml:space="preserve">
          <source>F.11.1. Configuration</source>
          <target state="translated">F.11.1. 구성</target>
        </trans-unit>
        <trans-unit id="90cd34db8f683504ca7feb85f746bcccec795423" translate="yes" xml:space="preserve">
          <source>F.11.2. Usage</source>
          <target state="translated">F.11.2. 용법</target>
        </trans-unit>
        <trans-unit id="e4eb1c3b3665242eea5c8771c3e66c28d9b95d26" translate="yes" xml:space="preserve">
          <source>F.12. dict_xsyn</source>
          <target state="translated">F.12. dict_xsyn</target>
        </trans-unit>
        <trans-unit id="559d903e93034a8bc26cce649452b3d7c4e09db2" translate="yes" xml:space="preserve">
          <source>F.12.1. Configuration</source>
          <target state="translated">F.12.1. 구성</target>
        </trans-unit>
        <trans-unit id="8be278f6fd96a9ff480b8439afb4a5a665d35702" translate="yes" xml:space="preserve">
          <source>F.12.2. Usage</source>
          <target state="translated">F.12.2. 용법</target>
        </trans-unit>
        <trans-unit id="ac893b7a0dcfacce489e0073e329ea96e63c563b" translate="yes" xml:space="preserve">
          <source>F.13. earthdistance</source>
          <target state="translated">F.13. 지구 거리</target>
        </trans-unit>
        <trans-unit id="ff97f4fa26386c910402ae19f89b6487e0920ace" translate="yes" xml:space="preserve">
          <source>F.13.1. Cube-Based Earth Distances</source>
          <target state="translated">F.13.1. 큐브 기반 지구 거리</target>
        </trans-unit>
        <trans-unit id="4fd65f14ed4c44985b32a94078e996104aba2da6" translate="yes" xml:space="preserve">
          <source>F.13.2. Point-Based Earth Distances</source>
          <target state="translated">F.13.2. 점 기반 지구 거리</target>
        </trans-unit>
        <trans-unit id="0dc089c0dd2cd42162c54a744ba53c987297088c" translate="yes" xml:space="preserve">
          <source>F.14. file_fdw</source>
          <target state="translated">F.14. file_fdw</target>
        </trans-unit>
        <trans-unit id="cc2bb28833eaac5566f6cf4a700a0c159682a67d" translate="yes" xml:space="preserve">
          <source>F.15. fuzzystrmatch</source>
          <target state="translated">F.15. 퍼지</target>
        </trans-unit>
        <trans-unit id="f3b8cdd7c68dccc31c5a4c3eebfa3b2fd3e60972" translate="yes" xml:space="preserve">
          <source>F.15.1. Soundex</source>
          <target state="translated">F.15.1. Soundex</target>
        </trans-unit>
        <trans-unit id="805bad02d817987c917d35cc2cda97fa20a921ad" translate="yes" xml:space="preserve">
          <source>F.15.2. Levenshtein</source>
          <target state="translated">F.15.2. 레 벤슈 테인</target>
        </trans-unit>
        <trans-unit id="72b84cc4ce4a7652ee1c055849e248af26d7acaf" translate="yes" xml:space="preserve">
          <source>F.15.3. Metaphone</source>
          <target state="translated">F.15.3. 메타 폰</target>
        </trans-unit>
        <trans-unit id="d9dcc939a71a29db0754dbbcb70da7a2cc01dcf5" translate="yes" xml:space="preserve">
          <source>F.15.4. Double Metaphone</source>
          <target state="translated">F.15.4. 이중 메타 폰</target>
        </trans-unit>
        <trans-unit id="bb9c2fb77946283e8033e242669e0f3f42028773" translate="yes" xml:space="preserve">
          <source>F.16. hstore</source>
          <target state="translated">F.16. hstore</target>
        </trans-unit>
        <trans-unit id="8fc2df587935c2448dff4335b06917a6034820c9" translate="yes" xml:space="preserve">
          <source>F.16.1. &lt;code&gt;hstore&lt;/code&gt; External Representation</source>
          <target state="translated">F.16.1. &lt;code&gt;hstore&lt;/code&gt; 외부 표현</target>
        </trans-unit>
        <trans-unit id="f61c1443f146183c037e0b1f2d2228cb582573d5" translate="yes" xml:space="preserve">
          <source>F.16.2. &lt;code&gt;hstore&lt;/code&gt; Operators and Functions</source>
          <target state="translated">F.16.2. &lt;code&gt;hstore&lt;/code&gt; 연산자 및 함수</target>
        </trans-unit>
        <trans-unit id="b7d1274db689ce60845678187d1dc8f42e9ee40e" translate="yes" xml:space="preserve">
          <source>F.16.3. Indexes</source>
          <target state="translated">F.16.3. 인덱스</target>
        </trans-unit>
        <trans-unit id="2b4c4f8198eac2368ebc714da19af84efddf447c" translate="yes" xml:space="preserve">
          <source>F.16.4. Examples</source>
          <target state="translated">F.16.4. 예</target>
        </trans-unit>
        <trans-unit id="90eff5025bc75068b267164038875e1635c8c255" translate="yes" xml:space="preserve">
          <source>F.16.5. Statistics</source>
          <target state="translated">F.16.5. 통계</target>
        </trans-unit>
        <trans-unit id="4e05f5c308dbbec0149addbb2463eaae08cc46aa" translate="yes" xml:space="preserve">
          <source>F.16.6. Compatibility</source>
          <target state="translated">F.16.6. 적합성</target>
        </trans-unit>
        <trans-unit id="8dbd0f1c1b12de81fb830bd3d477e7aff624c869" translate="yes" xml:space="preserve">
          <source>F.16.7. Transforms</source>
          <target state="translated">F.16.7. 변형</target>
        </trans-unit>
        <trans-unit id="0ed7a6c55a15524787fdd24e0a9887282515d660" translate="yes" xml:space="preserve">
          <source>F.16.8. Authors</source>
          <target state="translated">F.16.8. 저자</target>
        </trans-unit>
        <trans-unit id="ef901c5ecf993a0bec18e20827b1f5ebc01cc3cf" translate="yes" xml:space="preserve">
          <source>F.17. intagg</source>
          <target state="translated">F.17. 잉 타그</target>
        </trans-unit>
        <trans-unit id="8a846eabac892182bc4942f68dee9cb6533c96ba" translate="yes" xml:space="preserve">
          <source>F.17.1. Functions</source>
          <target state="translated">F.17.1. 기능</target>
        </trans-unit>
        <trans-unit id="096cf2f5427dd0642d7d558315e8e41f6aa0f435" translate="yes" xml:space="preserve">
          <source>F.17.2. Sample Uses</source>
          <target state="translated">F.17.2. 샘플 사용</target>
        </trans-unit>
        <trans-unit id="9d497c427457423611035a8e1138104c1a6454a8" translate="yes" xml:space="preserve">
          <source>F.18. intarray</source>
          <target state="translated">F.18. 인타 레이</target>
        </trans-unit>
        <trans-unit id="35e426f40a1fafe8fbd71778b978044b1313f6f2" translate="yes" xml:space="preserve">
          <source>F.18.1. &lt;code&gt;intarray&lt;/code&gt; Functions and Operators</source>
          <target state="translated">F.18.1. &lt;code&gt;intarray&lt;/code&gt; 함수 및 연산자</target>
        </trans-unit>
        <trans-unit id="590ecf1fe16e8463507cf8f6509beae0fac95454" translate="yes" xml:space="preserve">
          <source>F.18.2. Index Support</source>
          <target state="translated">F.18.2. 인덱스 지원</target>
        </trans-unit>
        <trans-unit id="0d7d6d82f910ac69b2bc79023a1885d00e7344d1" translate="yes" xml:space="preserve">
          <source>F.18.3. Example</source>
          <target state="translated">F.18.3. 예</target>
        </trans-unit>
        <trans-unit id="20d030c951773c391dae57ec9d360978ed9da7f9" translate="yes" xml:space="preserve">
          <source>F.18.4. Benchmark</source>
          <target state="translated">F.18.4. 기준</target>
        </trans-unit>
        <trans-unit id="32f9d82ac93f98fee1302ae4f678f7c6c937faf5" translate="yes" xml:space="preserve">
          <source>F.18.5. Authors</source>
          <target state="translated">F.18.5. 저자</target>
        </trans-unit>
        <trans-unit id="9949e04de9d9987a5e2e2d73820cb9572bdebefc" translate="yes" xml:space="preserve">
          <source>F.19. isn</source>
          <target state="translated">F.19. 이다</target>
        </trans-unit>
        <trans-unit id="f92b23aaa94e36a0b083631460692494c2541740" translate="yes" xml:space="preserve">
          <source>F.19.1. Data Types</source>
          <target state="translated">F.19.1. 데이터 타입</target>
        </trans-unit>
        <trans-unit id="824ef2156675e38b6922d9d3b5f1c62e81c74da8" translate="yes" xml:space="preserve">
          <source>F.19.2. Casts</source>
          <target state="translated">F.19.2. 캐스트</target>
        </trans-unit>
        <trans-unit id="bd4150a7873586e455ef10f2ee9fe10ea1d82054" translate="yes" xml:space="preserve">
          <source>F.19.3. Functions and Operators</source>
          <target state="translated">F.19.3. 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="8de2bcf5499966294b7a89a6d8111df3d3be5517" translate="yes" xml:space="preserve">
          <source>F.19.4. Examples</source>
          <target state="translated">F.19.4. 예</target>
        </trans-unit>
        <trans-unit id="54dd8b5077354d8f9842781edab86b35438f5df5" translate="yes" xml:space="preserve">
          <source>F.19.5. Bibliography</source>
          <target state="translated">F.19.5. 서지</target>
        </trans-unit>
        <trans-unit id="98c2220c95292d8a74cab397c3a701da35a004a9" translate="yes" xml:space="preserve">
          <source>F.19.6. Author</source>
          <target state="translated">F.19.6. 저자</target>
        </trans-unit>
        <trans-unit id="7ce29efe3aba103127578bb92d471da26a8e1c27" translate="yes" xml:space="preserve">
          <source>F.2. amcheck</source>
          <target state="translated">F.2. amcheck</target>
        </trans-unit>
        <trans-unit id="866feedaa5ba7bd021b78167df606b7bc7159ccc" translate="yes" xml:space="preserve">
          <source>F.2.1. Functions</source>
          <target state="translated">F.2.1. 기능</target>
        </trans-unit>
        <trans-unit id="bfd61595a640584e873b81cf6fa71fc6d8b5aef8" translate="yes" xml:space="preserve">
          <source>F.2.2. Optional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; Verification</source>
          <target state="translated">F.2.2. 선택적 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증</target>
        </trans-unit>
        <trans-unit id="fb374459ade3b0e685573e23d45028532781fde2" translate="yes" xml:space="preserve">
          <source>F.2.3. Using &lt;code&gt;amcheck&lt;/code&gt; Effectively</source>
          <target state="translated">F.2.3. 효과적으로 &lt;code&gt;amcheck&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5c03c3a67f58e049c3e64357a6e75f2ba616ae36" translate="yes" xml:space="preserve">
          <source>F.2.4. Repairing Corruption</source>
          <target state="translated">F.2.4. 부패 수리</target>
        </trans-unit>
        <trans-unit id="c5aac668fae89db07299f936ff73b8263417e113" translate="yes" xml:space="preserve">
          <source>F.20. lo</source>
          <target state="translated">F.20. 봐라</target>
        </trans-unit>
        <trans-unit id="7f097c1b2d299fc1bd2add0f834cf8d6748c6f0d" translate="yes" xml:space="preserve">
          <source>F.20.1. Rationale</source>
          <target state="translated">F.20.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="c9b4132cf12dff8738567aada10b65102fe62f79" translate="yes" xml:space="preserve">
          <source>F.20.2. How to Use It</source>
          <target state="translated">F.20.2. 사용 방법</target>
        </trans-unit>
        <trans-unit id="4a0ef949ca5051e3b9bb2b885b51a7ad8ff29ee0" translate="yes" xml:space="preserve">
          <source>F.20.3. Limitations</source>
          <target state="translated">F.20.3. 한계</target>
        </trans-unit>
        <trans-unit id="1123ff142a5242119d2bf382684a6c72470c9075" translate="yes" xml:space="preserve">
          <source>F.20.4. Author</source>
          <target state="translated">F.20.4. 저자</target>
        </trans-unit>
        <trans-unit id="7b3d074a1e31ac3a21aed7f7232c1047e9b97c30" translate="yes" xml:space="preserve">
          <source>F.21. ltree</source>
          <target state="translated">F.21. ltree</target>
        </trans-unit>
        <trans-unit id="e1953c5653ae6bfb304f654683ee1f77f6e74691" translate="yes" xml:space="preserve">
          <source>F.21.1. Definitions</source>
          <target state="translated">F.21.1. 정의</target>
        </trans-unit>
        <trans-unit id="7817803d1ae9f2a24f51a444d32288a38debe6c3" translate="yes" xml:space="preserve">
          <source>F.21.2. Operators and Functions</source>
          <target state="translated">F.21.2. 연산자와 함수</target>
        </trans-unit>
        <trans-unit id="ff5edf8f9c269c18e0958d380b29953bd2d87078" translate="yes" xml:space="preserve">
          <source>F.21.3. Indexes</source>
          <target state="translated">F.21.3. 인덱스</target>
        </trans-unit>
        <trans-unit id="192ce328b7167fccab29f3f2a477a993a2987060" translate="yes" xml:space="preserve">
          <source>F.21.4. Example</source>
          <target state="translated">F.21.4. 예</target>
        </trans-unit>
        <trans-unit id="d8fc608061497440e40e867e8967ad73ca799bd8" translate="yes" xml:space="preserve">
          <source>F.21.5. Transforms</source>
          <target state="translated">F.21.5. 변형</target>
        </trans-unit>
        <trans-unit id="6286519146bdf56d1bdd6acb5c5cc657edbf9085" translate="yes" xml:space="preserve">
          <source>F.21.6. Authors</source>
          <target state="translated">F.21.6. 저자</target>
        </trans-unit>
        <trans-unit id="9cd818eeaf1eaf95d1d44dff8bac406869884842" translate="yes" xml:space="preserve">
          <source>F.22. pageinspect</source>
          <target state="translated">F.22. 페이지 검사</target>
        </trans-unit>
        <trans-unit id="de632b965c073d5b3cb6bc5bcd13d127f991db35" translate="yes" xml:space="preserve">
          <source>F.22.1. General Functions</source>
          <target state="translated">F.22.1. 일반 기능</target>
        </trans-unit>
        <trans-unit id="e44f80c235d00e99a3eb77a1a02409ba129b2041" translate="yes" xml:space="preserve">
          <source>F.22.2. Heap Functions</source>
          <target state="translated">F.22.2. 힙 기능</target>
        </trans-unit>
        <trans-unit id="1c71737be20a941d4c7bf90768621397c72df758" translate="yes" xml:space="preserve">
          <source>F.22.3. B-Tree Functions</source>
          <target state="translated">F.22.3. B- 트리 기능</target>
        </trans-unit>
        <trans-unit id="34b300cac314927d744692ef92150cc67d2dd3d4" translate="yes" xml:space="preserve">
          <source>F.22.4. BRIN Functions</source>
          <target state="translated">F.22.4. 브린 기능</target>
        </trans-unit>
        <trans-unit id="5435da81280a932f2cfdafa55cf6b8963c3c9668" translate="yes" xml:space="preserve">
          <source>F.22.5. GIN Functions</source>
          <target state="translated">F.22.5. 진 기능</target>
        </trans-unit>
        <trans-unit id="b19f99ab1ffabf3311f71b36992c192b8477a00f" translate="yes" xml:space="preserve">
          <source>F.22.6. Hash Functions</source>
          <target state="translated">F.22.6. 해시 함수</target>
        </trans-unit>
        <trans-unit id="8f2b599b901de0542fc5213060869a06aec04f41" translate="yes" xml:space="preserve">
          <source>F.23. passwordcheck</source>
          <target state="translated">F.23. 비밀번호 확인</target>
        </trans-unit>
        <trans-unit id="dd69d26b0ef3fde0364251a95b289c9c283c2ca5" translate="yes" xml:space="preserve">
          <source>F.24. pg_buffercache</source>
          <target state="translated">F.24. pg_buffercache</target>
        </trans-unit>
        <trans-unit id="c4cbdb669bb06e75c07d4e7a9a03b46492702c60" translate="yes" xml:space="preserve">
          <source>F.24.1. The &lt;code&gt;pg_buffercache&lt;/code&gt; View</source>
          <target state="translated">F.24.1. &lt;code&gt;pg_buffercache&lt;/code&gt; 의 보기</target>
        </trans-unit>
        <trans-unit id="6511735718d4497449c0a7a96e48310acbfcd007" translate="yes" xml:space="preserve">
          <source>F.24.2. Sample Output</source>
          <target state="translated">F.24.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="7237b1e65b9d6babc2c271e2b1ade2e599c67443" translate="yes" xml:space="preserve">
          <source>F.24.3. Authors</source>
          <target state="translated">F.24.3. 저자</target>
        </trans-unit>
        <trans-unit id="f6c54ece16019f60246b8dfda4b639acdfd3efbb" translate="yes" xml:space="preserve">
          <source>F.25. pgcrypto</source>
          <target state="translated">F.25. pgcrypto</target>
        </trans-unit>
        <trans-unit id="1b69a53eb9fc01a412e3eb39bb09c9940b5893fe" translate="yes" xml:space="preserve">
          <source>F.25.1. General Hashing Functions</source>
          <target state="translated">F.25.1. 일반 해싱 함수</target>
        </trans-unit>
        <trans-unit id="20ef4ddd6e94a918f41c006dba66b7f9f4e2de33" translate="yes" xml:space="preserve">
          <source>F.25.1.1. &lt;code&gt;digest()&lt;/code&gt;</source>
          <target state="translated">F.25.1.1. &lt;code&gt;digest()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73bdda1ec2d12f4343e8f6ed415383cdfabd7e01" translate="yes" xml:space="preserve">
          <source>F.25.1.2. &lt;code&gt;hmac()&lt;/code&gt;</source>
          <target state="translated">F.25.1.2. &lt;code&gt;hmac()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8aed6d345ad282f7dd6852c664093afce29119a" translate="yes" xml:space="preserve">
          <source>F.25.2. Password Hashing Functions</source>
          <target state="translated">F.25.2. 비밀번호 해싱 기능</target>
        </trans-unit>
        <trans-unit id="648294b1d552ef98633615ce2c099cb17e284418" translate="yes" xml:space="preserve">
          <source>F.25.2.1. &lt;code&gt;crypt()&lt;/code&gt;</source>
          <target state="translated">F.25.2.1. &lt;code&gt;crypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f436cf61bca1c78ff4c8b5cd56400150126eee8" translate="yes" xml:space="preserve">
          <source>F.25.2.2. &lt;code&gt;gen_salt()&lt;/code&gt;</source>
          <target state="translated">F.25.2.2. &lt;code&gt;gen_salt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba94d8ceafdbe9c995cd42cc672a2052fa9f849f" translate="yes" xml:space="preserve">
          <source>F.25.3. PGP Encryption Functions</source>
          <target state="translated">F.25.3. PGP 암호화 기능</target>
        </trans-unit>
        <trans-unit id="9dc741981d2f1f646431199c235db18f4f70eaa6" translate="yes" xml:space="preserve">
          <source>F.25.3.1. &lt;code&gt;pgp_sym_encrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.1. &lt;code&gt;pgp_sym_encrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ce9c368c9322da0152d1e6c730dbd3ca796d29c" translate="yes" xml:space="preserve">
          <source>F.25.3.10. Limitations of PGP Code</source>
          <target state="translated">F.25.3.10. PGP 코드의 한계</target>
        </trans-unit>
        <trans-unit id="c3b7a720a2e61a8e29b7c0d5651d11585d728158" translate="yes" xml:space="preserve">
          <source>F.25.3.2. &lt;code&gt;pgp_sym_decrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.2. &lt;code&gt;pgp_sym_decrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1440fd16b327d52206e6bbc27209e40f3c25518b" translate="yes" xml:space="preserve">
          <source>F.25.3.3. &lt;code&gt;pgp_pub_encrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.3. &lt;code&gt;pgp_pub_encrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4511f95f7118c70ecd722deb1cf4890abad67ee" translate="yes" xml:space="preserve">
          <source>F.25.3.4. &lt;code&gt;pgp_pub_decrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.4. &lt;code&gt;pgp_pub_decrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="851ac5e05147051b81591361f3b4b9029afc4b0d" translate="yes" xml:space="preserve">
          <source>F.25.3.5. &lt;code&gt;pgp_key_id()&lt;/code&gt;</source>
          <target state="translated">F.25.3.5. &lt;code&gt;pgp_key_id()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c88a1aaf0769a9f9305f8fb7d047ded9966673d8" translate="yes" xml:space="preserve">
          <source>F.25.3.6. &lt;code&gt;armor()&lt;/code&gt;, &lt;code&gt;dearmor()&lt;/code&gt;</source>
          <target state="translated">F.25.3.6. &lt;code&gt;armor()&lt;/code&gt; , &lt;code&gt;dearmor()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b166f7f6622cb2c7c5278090124129c0f130698" translate="yes" xml:space="preserve">
          <source>F.25.3.7. &lt;code&gt;pgp_armor_headers&lt;/code&gt;</source>
          <target state="translated">F.25.3.7. &lt;code&gt;pgp_armor_headers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72ca2237372393c19189f0ae1dbe11e53949a8f6" translate="yes" xml:space="preserve">
          <source>F.25.3.8. Options for PGP Functions</source>
          <target state="translated">F.25.3.8. PGP 기능 옵션</target>
        </trans-unit>
        <trans-unit id="5bccea5eab8c2ac75c619e98f506cf7b3a7838c8" translate="yes" xml:space="preserve">
          <source>F.25.3.8.1. cipher-algo</source>
          <target state="translated">F.25.3.8.1. 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="4ff1dcef2ae938211c3e9fb4eed66f1d015acf5a" translate="yes" xml:space="preserve">
          <source>F.25.3.8.10. s2k-cipher-algo</source>
          <target state="translated">F.25.3.8.10. s2k 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="0184a6d40ce7402329bcbaaab1c15ad1f3ec81c7" translate="yes" xml:space="preserve">
          <source>F.25.3.8.11. unicode-mode</source>
          <target state="translated">F.25.3.8.11. 유니 코드 모드</target>
        </trans-unit>
        <trans-unit id="1b1f6de6ead087ad34ce3dde6ba8c8588dd79fb7" translate="yes" xml:space="preserve">
          <source>F.25.3.8.2. compress-algo</source>
          <target state="translated">F.25.3.8.2. 압축 알고리즘</target>
        </trans-unit>
        <trans-unit id="123e13a4af409a09f2921448f1c91f349c921d54" translate="yes" xml:space="preserve">
          <source>F.25.3.8.3. compress-level</source>
          <target state="translated">F.25.3.8.3. 압축 수준</target>
        </trans-unit>
        <trans-unit id="65b75e3362b8b79cafa308f084bd508871fee9a9" translate="yes" xml:space="preserve">
          <source>F.25.3.8.4. convert-crlf</source>
          <target state="translated">F.25.3.8.4. 개 심자</target>
        </trans-unit>
        <trans-unit id="d5dc7cface8b5bc0ef3d9c52244f630ff84c0e87" translate="yes" xml:space="preserve">
          <source>F.25.3.8.5. disable-mdc</source>
          <target state="translated">F.25.3.8.5. disable-mdc</target>
        </trans-unit>
        <trans-unit id="8ebebefcc75be5058839e0b78a1c9c7da4466f00" translate="yes" xml:space="preserve">
          <source>F.25.3.8.6. sess-key</source>
          <target state="translated">F.25.3.8.6. 세스 키</target>
        </trans-unit>
        <trans-unit id="f6b2059d09268d64aa31ef2ce2c067102d67e99b" translate="yes" xml:space="preserve">
          <source>F.25.3.8.7. s2k-mode</source>
          <target state="translated">F.25.3.8.7. s2k 모드</target>
        </trans-unit>
        <trans-unit id="3ec7953362b03623b0193374c90382e4f6836554" translate="yes" xml:space="preserve">
          <source>F.25.3.8.8. s2k-count</source>
          <target state="translated">F.25.3.8.8. s2k- 카운트</target>
        </trans-unit>
        <trans-unit id="7b93d3dded709dbf34f19195fd711141a7d39724" translate="yes" xml:space="preserve">
          <source>F.25.3.8.9. s2k-digest-algo</source>
          <target state="translated">F.25.3.8.9. s2k- 다이제스트-알고</target>
        </trans-unit>
        <trans-unit id="aaf39f460b7cc3fff87b2265321ff5a520b79870" translate="yes" xml:space="preserve">
          <source>F.25.3.9. Generating PGP Keys with GnuPG</source>
          <target state="translated">F.25.3.9. GnuPG로 PGP 키 생성</target>
        </trans-unit>
        <trans-unit id="9b2d739f0baf5d9701c6c85f4ff01bae0c21de15" translate="yes" xml:space="preserve">
          <source>F.25.4. Raw Encryption Functions</source>
          <target state="translated">F.25.4. 원시 암호화 기능</target>
        </trans-unit>
        <trans-unit id="9d26da86c3ede2eb658f6d30d59cab3fe6086098" translate="yes" xml:space="preserve">
          <source>F.25.5. Random-Data Functions</source>
          <target state="translated">F.25.5. 랜덤 데이터 함수</target>
        </trans-unit>
        <trans-unit id="204e00a028516b1945b846a226f3b7c88787462f" translate="yes" xml:space="preserve">
          <source>F.25.6. Notes</source>
          <target state="translated">F.25.6. 노트</target>
        </trans-unit>
        <trans-unit id="6eaf14101828f85289bf3861eca422eca65adcf8" translate="yes" xml:space="preserve">
          <source>F.25.6.1. Configuration</source>
          <target state="translated">F.25.6.1. 구성</target>
        </trans-unit>
        <trans-unit id="278a46e8c054cd1ab368f6c28c75f41eb33b3ce9" translate="yes" xml:space="preserve">
          <source>F.25.6.2. NULL Handling</source>
          <target state="translated">F.25.6.2. NULL 처리</target>
        </trans-unit>
        <trans-unit id="5a795e063ffd476cbb12cdbea7497a6a89028a71" translate="yes" xml:space="preserve">
          <source>F.25.6.3. Security Limitations</source>
          <target state="translated">F.25.6.3. 보안 제한</target>
        </trans-unit>
        <trans-unit id="0a20df0b20779a999c62ff097aac89375c902e0d" translate="yes" xml:space="preserve">
          <source>F.25.6.4. Useful Reading</source>
          <target state="translated">F.25.6.4. 유용한 독서</target>
        </trans-unit>
        <trans-unit id="a8f89e01b1a3c968473d516b54dd2a27fcff5d23" translate="yes" xml:space="preserve">
          <source>F.25.6.5. Technical References</source>
          <target state="translated">F.25.6.5. 기술 참조</target>
        </trans-unit>
        <trans-unit id="95ec7f2a276d43cdddf8d912e1dc59cff5b486a2" translate="yes" xml:space="preserve">
          <source>F.25.7. Author</source>
          <target state="translated">F.25.7. 저자</target>
        </trans-unit>
        <trans-unit id="6d87ba341737e825fea1649de07238172e85db44" translate="yes" xml:space="preserve">
          <source>F.26. pg_freespacemap</source>
          <target state="translated">F.26. pg_freespacemap</target>
        </trans-unit>
        <trans-unit id="776eea32accc24dda78b8fe28fa0f7c45dff5c2e" translate="yes" xml:space="preserve">
          <source>F.26.1. Functions</source>
          <target state="translated">F.26.1. 기능</target>
        </trans-unit>
        <trans-unit id="dbf2204ce6fc1c9faa7f16be35f1922e9a96127e" translate="yes" xml:space="preserve">
          <source>F.26.2. Sample Output</source>
          <target state="translated">F.26.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="9a3afb36a016059607419287b873395130efbcba" translate="yes" xml:space="preserve">
          <source>F.26.3. Author</source>
          <target state="translated">F.26.3. 저자</target>
        </trans-unit>
        <trans-unit id="c770ac7064fe14e68deabe20f96bd726d85a4c53" translate="yes" xml:space="preserve">
          <source>F.27. pg_prewarm</source>
          <target state="translated">F.27. pg_prewarm</target>
        </trans-unit>
        <trans-unit id="c83979c6186932e7f06c2286a6e5ae62b4f96e5d" translate="yes" xml:space="preserve">
          <source>F.27.1. Functions</source>
          <target state="translated">F.27.1. 기능</target>
        </trans-unit>
        <trans-unit id="0a4f8191cf5b90a57e9bbb4b3e3f2dbc3a1b162a" translate="yes" xml:space="preserve">
          <source>F.27.2. Configuration Parameters</source>
          <target state="translated">F.27.2. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="52e656be642fd38c2cc04fe4f0c163370650aec9" translate="yes" xml:space="preserve">
          <source>F.27.3. Author</source>
          <target state="translated">F.27.3. 저자</target>
        </trans-unit>
        <trans-unit id="f34a78f1d8034dfca697da3e2e901050c64f7389" translate="yes" xml:space="preserve">
          <source>F.28. pgrowlocks</source>
          <target state="translated">F.28. pgrowlocks</target>
        </trans-unit>
        <trans-unit id="e23ecf44779814c897e31c3fc14848fd3c39577b" translate="yes" xml:space="preserve">
          <source>F.28.1. Overview</source>
          <target state="translated">F.28.1. 개요</target>
        </trans-unit>
        <trans-unit id="722835953492c125abcca028d29b6cb31745b1f0" translate="yes" xml:space="preserve">
          <source>F.28.2. Sample Output</source>
          <target state="translated">F.28.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="a3c331c6911f6a88efd0e0be66df1e82ba2c5ba5" translate="yes" xml:space="preserve">
          <source>F.28.3. Author</source>
          <target state="translated">F.28.3. 저자</target>
        </trans-unit>
        <trans-unit id="34f192913b27a9575099b4354abfc96f154647a9" translate="yes" xml:space="preserve">
          <source>F.29. pg_stat_statements</source>
          <target state="translated">F.29. pg_stat_statements</target>
        </trans-unit>
        <trans-unit id="98d099f81eb49092c7fa45a4620f13cbca7eb4b4" translate="yes" xml:space="preserve">
          <source>F.29.1. The &lt;code&gt;pg_stat_statements&lt;/code&gt; View</source>
          <target state="translated">F.29.1. &lt;code&gt;pg_stat_statements&lt;/code&gt; 는 보기</target>
        </trans-unit>
        <trans-unit id="f604837ab61bc198722329e277e0b0f4d017c9f3" translate="yes" xml:space="preserve">
          <source>F.29.2. Functions</source>
          <target state="translated">F.29.2. 기능</target>
        </trans-unit>
        <trans-unit id="9630871d326e2082b4c0dc726cf97969a02fb58a" translate="yes" xml:space="preserve">
          <source>F.29.3. Configuration Parameters</source>
          <target state="translated">F.29.3. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="b4a60f9b108b5f6bc5f54d10335cf495a4365aaf" translate="yes" xml:space="preserve">
          <source>F.29.4. Sample Output</source>
          <target state="translated">F.29.4. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="959ad93c5611ec265d706a857a3ce74fa8c1be07" translate="yes" xml:space="preserve">
          <source>F.29.5. Authors</source>
          <target state="translated">F.29.5. 저자</target>
        </trans-unit>
        <trans-unit id="704b887fb1ff7881213018edeff2e0bef27a3135" translate="yes" xml:space="preserve">
          <source>F.3. auth_delay</source>
          <target state="translated">F.3. auth_delay</target>
        </trans-unit>
        <trans-unit id="b509ada65fd8784b515a28bc785543896ffe0c44" translate="yes" xml:space="preserve">
          <source>F.3.1. Configuration Parameters</source>
          <target state="translated">F.3.1. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="0963c804bdd94f69573ed873c878d960aaa02c67" translate="yes" xml:space="preserve">
          <source>F.3.2. Author</source>
          <target state="translated">F.3.2. 저자</target>
        </trans-unit>
        <trans-unit id="13ca2dc97e6c093802774b17400831f98e95d847" translate="yes" xml:space="preserve">
          <source>F.30. pgstattuple</source>
          <target state="translated">F.30. pgstattuple</target>
        </trans-unit>
        <trans-unit id="80820b9c19b9082fd01b22b80e375b02bdcbd982" translate="yes" xml:space="preserve">
          <source>F.30.1. Functions</source>
          <target state="translated">F.30.1. 기능</target>
        </trans-unit>
        <trans-unit id="3e8b9844693185862cd930605a318fb08f0daa62" translate="yes" xml:space="preserve">
          <source>F.30.2. Authors</source>
          <target state="translated">F.30.2. 저자</target>
        </trans-unit>
        <trans-unit id="681d27f3112d152e9b16db16fadea92227b24d55" translate="yes" xml:space="preserve">
          <source>F.31. pg_trgm</source>
          <target state="translated">F.31. pg_trgm</target>
        </trans-unit>
        <trans-unit id="c89a28a6d1f56e27f367a06ec7379fca446be6c7" translate="yes" xml:space="preserve">
          <source>F.31.1. Trigram (or Trigraph) Concepts</source>
          <target state="translated">F.31.1. Trigram (또는 Trigraph) 개념</target>
        </trans-unit>
        <trans-unit id="2d9cb416fb09a81cc6d2c51704de4c8b5ba9cfe8" translate="yes" xml:space="preserve">
          <source>F.31.2. Functions and Operators</source>
          <target state="translated">F.31.2. 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="ff85d5fa8354d2d9281d02f0b6f23de90e8c02d7" translate="yes" xml:space="preserve">
          <source>F.31.3. GUC Parameters</source>
          <target state="translated">F.31.3. GUC 매개 변수</target>
        </trans-unit>
        <trans-unit id="f3264e50a672ede496f91bd277d84fcf943750a6" translate="yes" xml:space="preserve">
          <source>F.31.4. Index Support</source>
          <target state="translated">F.31.4. 인덱스 지원</target>
        </trans-unit>
        <trans-unit id="1fcf8d6131447541df442d15baeaf11459619fc5" translate="yes" xml:space="preserve">
          <source>F.31.5. Text Search Integration</source>
          <target state="translated">F.31.5. 텍스트 검색 통합</target>
        </trans-unit>
        <trans-unit id="8dcae1083d938ff89dd80c6da49b52ea44e0b8b3" translate="yes" xml:space="preserve">
          <source>F.31.6. References</source>
          <target state="translated">F.31.6. 참고 문헌</target>
        </trans-unit>
        <trans-unit id="9df69f7c595b9652f29399e102d937ad43270ce6" translate="yes" xml:space="preserve">
          <source>F.31.7. Authors</source>
          <target state="translated">F.31.7. 저자</target>
        </trans-unit>
        <trans-unit id="66f1a37f115acc2f3f09b71c19b4ab6e4fe99b87" translate="yes" xml:space="preserve">
          <source>F.32. pg_visibility</source>
          <target state="translated">F.32 pg_visibility</target>
        </trans-unit>
        <trans-unit id="2e568ce017cd15afddab3f2b3a3623d54ce19800" translate="yes" xml:space="preserve">
          <source>F.32.1. Functions</source>
          <target state="translated">F.32.1. 기능</target>
        </trans-unit>
        <trans-unit id="983f4b75d738b3142d08500f7dc7740b0d08da84" translate="yes" xml:space="preserve">
          <source>F.32.2. Author</source>
          <target state="translated">F.32.2. 저자</target>
        </trans-unit>
        <trans-unit id="9273fa777dbf591ea861acb44c324bfc1f47c3c6" translate="yes" xml:space="preserve">
          <source>F.33. postgres_fdw</source>
          <target state="translated">F.33. postgres_fdw</target>
        </trans-unit>
        <trans-unit id="193b83877ad110c43d18c17fa85bc266b3589e87" translate="yes" xml:space="preserve">
          <source>F.33.1. FDW Options of postgres_fdw</source>
          <target state="translated">F.33.1. postgres_fdw의 FDW 옵션</target>
        </trans-unit>
        <trans-unit id="5412c884ac336714c4398df021f14f3acfc2cc8d" translate="yes" xml:space="preserve">
          <source>F.33.1.1. Connection Options</source>
          <target state="translated">F.33.1.1. 연결 옵션</target>
        </trans-unit>
        <trans-unit id="269c16164be1a1095f225f73c7ce5a51294dc815" translate="yes" xml:space="preserve">
          <source>F.33.1.2. Object Name Options</source>
          <target state="translated">F.33.1.2. 객체 이름 옵션</target>
        </trans-unit>
        <trans-unit id="dfeb9338540cd6b729a939516830d6cc198332da" translate="yes" xml:space="preserve">
          <source>F.33.1.3. Cost Estimation Options</source>
          <target state="translated">F.33.1.3. 비용 추정 옵션</target>
        </trans-unit>
        <trans-unit id="007d50d7c6a3fb29c267c851f2f73026db5294c9" translate="yes" xml:space="preserve">
          <source>F.33.1.4. Remote Execution Options</source>
          <target state="translated">F.33.1.4. 원격 실행 옵션</target>
        </trans-unit>
        <trans-unit id="939b45466c24ec90b5230dca452452bbd649bf93" translate="yes" xml:space="preserve">
          <source>F.33.1.5. Updatability Options</source>
          <target state="translated">F.33.1.5. 업데이트 가능성 옵션</target>
        </trans-unit>
        <trans-unit id="d9f27c8d768a3bb2417485f8db64eee51be52484" translate="yes" xml:space="preserve">
          <source>F.33.1.6. Importing Options</source>
          <target state="translated">F.33.1.6. 가져 오기 옵션</target>
        </trans-unit>
        <trans-unit id="2b2c01fcf10adb380e0ed33448e2d3f4238d7812" translate="yes" xml:space="preserve">
          <source>F.33.2. Connection Management</source>
          <target state="translated">F.33.2. 연결 관리</target>
        </trans-unit>
        <trans-unit id="ab6004832e8fa28f0f4237df2ffaeb324d443fa2" translate="yes" xml:space="preserve">
          <source>F.33.3. Transaction Management</source>
          <target state="translated">F.33.3. 거래 관리</target>
        </trans-unit>
        <trans-unit id="a1dfc91d53cf08246f4f53f3009e93d89b6a231c" translate="yes" xml:space="preserve">
          <source>F.33.4. Remote Query Optimization</source>
          <target state="translated">F.33.4. 원격 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="298bc93d569355f87b81fe19414a86c661d83ef1" translate="yes" xml:space="preserve">
          <source>F.33.5. Remote Query Execution Environment</source>
          <target state="translated">F.33.5. 원격 쿼리 실행 환경</target>
        </trans-unit>
        <trans-unit id="6c812df5f2650246a5da313d3d83550da9fa68f2" translate="yes" xml:space="preserve">
          <source>F.33.6. Cross-Version Compatibility</source>
          <target state="translated">F.33.6. 버전 간 호환성</target>
        </trans-unit>
        <trans-unit id="f79780fd8ba8dc90bbdc8966f8e88fd8bb05063d" translate="yes" xml:space="preserve">
          <source>F.33.7. Examples</source>
          <target state="translated">F.33.7. 예</target>
        </trans-unit>
        <trans-unit id="432a0ebb55cf26d92ead0a91a747b8341156ffc1" translate="yes" xml:space="preserve">
          <source>F.33.8. Author</source>
          <target state="translated">F.33.8. 저자</target>
        </trans-unit>
        <trans-unit id="16b654685a2d9cd826f23038130d516d1946f903" translate="yes" xml:space="preserve">
          <source>F.34. seg</source>
          <target state="translated">F.34. 세그</target>
        </trans-unit>
        <trans-unit id="d79c41978f6fcd2989e2c59dff39b1eb0e2b1ab2" translate="yes" xml:space="preserve">
          <source>F.34.1. Rationale</source>
          <target state="translated">F.34.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="f381dda45532b33f9b25ac406472931c193f29f5" translate="yes" xml:space="preserve">
          <source>F.34.2. Syntax</source>
          <target state="translated">F.34.2. 통사론</target>
        </trans-unit>
        <trans-unit id="c68c1caf01c3b9e2f432a702040137d0b1a0112d" translate="yes" xml:space="preserve">
          <source>F.34.3. Precision</source>
          <target state="translated">F.34.3. 정도</target>
        </trans-unit>
        <trans-unit id="e9928901c9ae448513c326ba6d46773618882907" translate="yes" xml:space="preserve">
          <source>F.34.4. Usage</source>
          <target state="translated">F.34.4. 용법</target>
        </trans-unit>
        <trans-unit id="487522e1f9e9fdcc603756f55afc3ba3026ea478" translate="yes" xml:space="preserve">
          <source>F.34.5. Notes</source>
          <target state="translated">F.34.5. 노트</target>
        </trans-unit>
        <trans-unit id="e01b0c3849c2815614ff98ea8042fc4d0d3a8bee" translate="yes" xml:space="preserve">
          <source>F.34.6. Credits</source>
          <target state="translated">F.34.6. 크레딧</target>
        </trans-unit>
        <trans-unit id="aaea0df06c8afc5721c399416715a43d27b1f41d" translate="yes" xml:space="preserve">
          <source>F.35. sepgsql</source>
          <target state="translated">F.35. sepgsql</target>
        </trans-unit>
        <trans-unit id="5206feae808dab22e63b8f42cce9d33f2f135f52" translate="yes" xml:space="preserve">
          <source>F.35.1. Overview</source>
          <target state="translated">F.35.1. 개요</target>
        </trans-unit>
        <trans-unit id="6068791fc5c5c74ce128385c01570e2fd8c4a48b" translate="yes" xml:space="preserve">
          <source>F.35.2. Installation</source>
          <target state="translated">F.35.2. 설치</target>
        </trans-unit>
        <trans-unit id="94f1cb62f780d101543cd8044a3dfd934adbecfc" translate="yes" xml:space="preserve">
          <source>F.35.3. Regression Tests</source>
          <target state="translated">F.35.3. 회귀 테스트</target>
        </trans-unit>
        <trans-unit id="0a70e740ffcee05fc260767a1f95581165e5376f" translate="yes" xml:space="preserve">
          <source>F.35.4. GUC Parameters</source>
          <target state="translated">F.35.4. GUC 매개 변수</target>
        </trans-unit>
        <trans-unit id="6003590508d8bec77373f3d360244ded0e767160" translate="yes" xml:space="preserve">
          <source>F.35.5. Features</source>
          <target state="translated">F.35.5. 풍모</target>
        </trans-unit>
        <trans-unit id="4a9d2250255492ada5787896be52456a102ee3be" translate="yes" xml:space="preserve">
          <source>F.35.5.1. Controlled Object Classes</source>
          <target state="translated">F.35.5.1. 제어 객체 클래스</target>
        </trans-unit>
        <trans-unit id="f03a61735b6f9f8ae6f77db6c0ff006611d25b69" translate="yes" xml:space="preserve">
          <source>F.35.5.2. DML Permissions</source>
          <target state="translated">F.35.5.2. DML 권한</target>
        </trans-unit>
        <trans-unit id="43a9568bd958ec3f010bf2ab4df6ebdfc75230e3" translate="yes" xml:space="preserve">
          <source>F.35.5.3. DDL Permissions</source>
          <target state="translated">F.35.5.3. DDL 권한</target>
        </trans-unit>
        <trans-unit id="8ef73da6478fbece425ec33df2d34fd27c99f85a" translate="yes" xml:space="preserve">
          <source>F.35.5.4. Trusted Procedures</source>
          <target state="translated">F.35.5.4. 신뢰할 수있는 절차</target>
        </trans-unit>
        <trans-unit id="e3ae8efb8c0c1c98ae79553e1966e3502b8f9585" translate="yes" xml:space="preserve">
          <source>F.35.5.5. Dynamic Domain Transitions</source>
          <target state="translated">F.35.5.5. 동적 도메인 전환</target>
        </trans-unit>
        <trans-unit id="bf5bb12781dc975cf063d2968ff739805c304822" translate="yes" xml:space="preserve">
          <source>F.35.5.6. Miscellaneous</source>
          <target state="translated">F.35.5.6. 여러 가지 잡다한</target>
        </trans-unit>
        <trans-unit id="05b9c78d7bcd4bbd6c5e9e875a0bb0adbc8122d7" translate="yes" xml:space="preserve">
          <source>F.35.6. Sepgsql Functions</source>
          <target state="translated">F.35.6. Sepgsql 함수</target>
        </trans-unit>
        <trans-unit id="bfa8e70472b0775d65efab1472dd8d042c56a6a2" translate="yes" xml:space="preserve">
          <source>F.35.7. Limitations</source>
          <target state="translated">F.35.7. 한계</target>
        </trans-unit>
        <trans-unit id="4903d823dafd075b549d4d5ea82159af1e3dfa1c" translate="yes" xml:space="preserve">
          <source>F.35.8. External Resources</source>
          <target state="translated">F.35.8. 외부 자료</target>
        </trans-unit>
        <trans-unit id="eca08e46b02dad577f925d4b88f2fbb3cc95508e" translate="yes" xml:space="preserve">
          <source>F.35.9. Author</source>
          <target state="translated">F.35.9. 저자</target>
        </trans-unit>
        <trans-unit id="403dcb3cfdeecf1876f217fac3e72c3abf223756" translate="yes" xml:space="preserve">
          <source>F.36. spi</source>
          <target state="translated">F.36. spi</target>
        </trans-unit>
        <trans-unit id="077826ec37e8b7233b4e75eb9db7221bf9399eea" translate="yes" xml:space="preserve">
          <source>F.36.1. refint &amp;mdash; Functions for Implementing Referential Integrity</source>
          <target state="translated">F.36.1. refint &amp;mdash; 참조 무결성 구현 기능</target>
        </trans-unit>
        <trans-unit id="b4ebef02a6e3cae6adef5624dc45c8c1dc1f748b" translate="yes" xml:space="preserve">
          <source>F.36.2. autoinc &amp;mdash; Functions for Autoincrementing Fields</source>
          <target state="translated">F.36.2. autoinc &amp;mdash; 자동 증분 필드 기능</target>
        </trans-unit>
        <trans-unit id="021fec897b35d84822f6b1e782db6f3db5faff68" translate="yes" xml:space="preserve">
          <source>F.36.3. insert_username &amp;mdash; Functions for Tracking Who Changed a Table</source>
          <target state="translated">F.36.3. insert_username &amp;mdash; 테이블을 변경 한 사람을 추적하는 기능</target>
        </trans-unit>
        <trans-unit id="8cb8c0687c13a8ca41e996a8275886c28cd48465" translate="yes" xml:space="preserve">
          <source>F.36.4. moddatetime &amp;mdash; Functions for Tracking Last Modification Time</source>
          <target state="translated">F.36.4. moddatetime &amp;mdash; 마지막 수정 시간 추적 기능</target>
        </trans-unit>
        <trans-unit id="d57995f7aca0c64c159764eca0ad70e7cef116d9" translate="yes" xml:space="preserve">
          <source>F.37. sslinfo</source>
          <target state="translated">F.37. sslinfo</target>
        </trans-unit>
        <trans-unit id="6e38711f605d1ea1bf029605dbbea18953a2c328" translate="yes" xml:space="preserve">
          <source>F.37.1. Functions Provided</source>
          <target state="translated">F.37.1. 제공되는 기능</target>
        </trans-unit>
        <trans-unit id="e8f10e576f9530ae876dffa73026f21b1790fdb1" translate="yes" xml:space="preserve">
          <source>F.37.2. Author</source>
          <target state="translated">F.37.2. 저자</target>
        </trans-unit>
        <trans-unit id="d15932480528eb9e164d3f8d1e0fa9c2c520f95e" translate="yes" xml:space="preserve">
          <source>F.38. tablefunc</source>
          <target state="translated">F.38. 테이블 펑크</target>
        </trans-unit>
        <trans-unit id="bc9583045d4d45aff583dd3214484f26260af7d3" translate="yes" xml:space="preserve">
          <source>F.38.1. Functions Provided</source>
          <target state="translated">F.38.1. 제공되는 기능</target>
        </trans-unit>
        <trans-unit id="1dd8d5dfb4d1b5a2cb639abc5e9229429c74316b" translate="yes" xml:space="preserve">
          <source>F.38.1.1. &lt;code&gt;normal_rand&lt;/code&gt;</source>
          <target state="translated">F.38.1.1. &lt;code&gt;normal_rand&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75cb330e2bb121fed69b21cc6897099dff250f04" translate="yes" xml:space="preserve">
          <source>F.38.1.2. &lt;code&gt;crosstab(text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.2. &lt;code&gt;crosstab(text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="accdaf833c1fc8d3e68f6365ba9a4589bb980b75" translate="yes" xml:space="preserve">
          <source>F.38.1.3. &lt;code&gt;crosstabN(text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.3. &lt;code&gt;crosstabN(text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0aeddce04c69309380516e234020d78dc1f1ccba" translate="yes" xml:space="preserve">
          <source>F.38.1.4. &lt;code&gt;crosstab(text, text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.4. &lt;code&gt;crosstab(text, text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f533800a5ac65ab86b0fc20fe9cdb1d6334280f" translate="yes" xml:space="preserve">
          <source>F.38.1.5. &lt;code&gt;connectby&lt;/code&gt;</source>
          <target state="translated">F.38.1.5. &lt;code&gt;connectby&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a17ab8d01f23f25e79997ed5e34403b5487d05" translate="yes" xml:space="preserve">
          <source>F.38.2. Author</source>
          <target state="translated">F.38.2. 저자</target>
        </trans-unit>
        <trans-unit id="80cd48066e2d9fe4d7954db8cf58f889aac317b5" translate="yes" xml:space="preserve">
          <source>F.39. tcn</source>
          <target state="translated">F.39. tcn</target>
        </trans-unit>
        <trans-unit id="e5027e63223df7517f07d367030af4c60f215a85" translate="yes" xml:space="preserve">
          <source>F.4. auto_explain</source>
          <target state="translated">F.4. auto_explain</target>
        </trans-unit>
        <trans-unit id="00ece7bcdd1d310b29789b78356ec422c388a58a" translate="yes" xml:space="preserve">
          <source>F.4.1. Configuration Parameters</source>
          <target state="translated">F.4.1. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="a0a6256879cb7cae75467d1b4ea4fe196f0404c6" translate="yes" xml:space="preserve">
          <source>F.4.2. Example</source>
          <target state="translated">F.4.2. 예</target>
        </trans-unit>
        <trans-unit id="f50a8147f2d047d7a8751be893c1ec347609e3a5" translate="yes" xml:space="preserve">
          <source>F.4.3. Author</source>
          <target state="translated">F.4.3. 저자</target>
        </trans-unit>
        <trans-unit id="fc8940df593b4b360f8e1f45a289b3b422d6f20d" translate="yes" xml:space="preserve">
          <source>F.40. test_decoding</source>
          <target state="translated">F.40. test_decoding</target>
        </trans-unit>
        <trans-unit id="03f67d82c28db2a84958e8890b5de8b5bf6347a1" translate="yes" xml:space="preserve">
          <source>F.41. tsm_system_rows</source>
          <target state="translated">F.41. tsm_system_rows</target>
        </trans-unit>
        <trans-unit id="416a3659d3a356c02da8e3d689ffdcca451ee3da" translate="yes" xml:space="preserve">
          <source>F.41.1. Examples</source>
          <target state="translated">F.41.1. 예</target>
        </trans-unit>
        <trans-unit id="9aa25fbcbbafa308d7f1a07d231f4ae202c22734" translate="yes" xml:space="preserve">
          <source>F.42. tsm_system_time</source>
          <target state="translated">F.42. tsm_system_time</target>
        </trans-unit>
        <trans-unit id="539b9cd2fd284c4cf26fd26d3168aeb51dfa147f" translate="yes" xml:space="preserve">
          <source>F.42.1. Examples</source>
          <target state="translated">F.42.1. 예</target>
        </trans-unit>
        <trans-unit id="1d99770788a99649f583440e4fb4cd1f411fed9b" translate="yes" xml:space="preserve">
          <source>F.43. unaccent</source>
          <target state="translated">F.43. 무심한</target>
        </trans-unit>
        <trans-unit id="b957a5d2e5c88500638617c009686a587a5f4c5a" translate="yes" xml:space="preserve">
          <source>F.43.1. Configuration</source>
          <target state="translated">F.43.1. 구성</target>
        </trans-unit>
        <trans-unit id="2426a96f2db13b59ffeb995ba7efbddf713709cb" translate="yes" xml:space="preserve">
          <source>F.43.2. Usage</source>
          <target state="translated">F.43.2. 용법</target>
        </trans-unit>
        <trans-unit id="a77b3be2e90d4ad5267bee4914834745ced63df4" translate="yes" xml:space="preserve">
          <source>F.43.3. Functions</source>
          <target state="translated">F.43.3. 기능</target>
        </trans-unit>
        <trans-unit id="f5487dbd0be3f95eb366af7c9d2a030d8c0eae51" translate="yes" xml:space="preserve">
          <source>F.44. uuid-ossp</source>
          <target state="translated">F.44. UUID-OSSP</target>
        </trans-unit>
        <trans-unit id="837bdea5d3e52ed4ac250bc37414453dc903790d" translate="yes" xml:space="preserve">
          <source>F.44.1. &lt;code&gt;uuid-ossp&lt;/code&gt; Functions</source>
          <target state="translated">F.44.1. &lt;code&gt;uuid-ossp&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="5637522de808bcbaadbfbedc5d103c9cea419b4e" translate="yes" xml:space="preserve">
          <source>F.44.2. Building &lt;code&gt;uuid-ossp&lt;/code&gt;</source>
          <target state="translated">F.44.2. 구축 &lt;code&gt;uuid-ossp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b6a6a63d4650a6f31a2f4856888515e66d6e02c" translate="yes" xml:space="preserve">
          <source>F.44.3. Author</source>
          <target state="translated">F.44.3. 저자</target>
        </trans-unit>
        <trans-unit id="f641301979073e6b556b7bd23c74d427bc166669" translate="yes" xml:space="preserve">
          <source>F.45. xml2</source>
          <target state="translated">F.45. xml2</target>
        </trans-unit>
        <trans-unit id="c843ec4b20006ee1af6f7ef0dcca81dad92b0374" translate="yes" xml:space="preserve">
          <source>F.45.1. Deprecation Notice</source>
          <target state="translated">F.45.1. 지원 중단 알림</target>
        </trans-unit>
        <trans-unit id="eab90c2b75ae93d1508fbcfdc1e75d4c11e98593" translate="yes" xml:space="preserve">
          <source>F.45.2. Description of Functions</source>
          <target state="translated">F.45.2. 기능 설명</target>
        </trans-unit>
        <trans-unit id="7bc5848d72a5fb71d196f91689fe900f02b6d89d" translate="yes" xml:space="preserve">
          <source>F.45.3. &lt;code&gt;xpath_table&lt;/code&gt;</source>
          <target state="translated">F.45.3. &lt;code&gt;xpath_table&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a984102dec30c0cff21eac3a7b5933e35959c053" translate="yes" xml:space="preserve">
          <source>F.45.3.1. Multivalued Results</source>
          <target state="translated">F.45.3.1. 다중 값 결과</target>
        </trans-unit>
        <trans-unit id="c7ac9fed24b1b2ae692a896b628cdab596ef2e91" translate="yes" xml:space="preserve">
          <source>F.45.4. XSLT Functions</source>
          <target state="translated">F.45.4. XSLT 기능</target>
        </trans-unit>
        <trans-unit id="cfc8c5fb6b07724425c9de739fb9ca52e19dfcd9" translate="yes" xml:space="preserve">
          <source>F.45.4.1. &lt;code&gt;xslt_process&lt;/code&gt;</source>
          <target state="translated">F.45.4.1. &lt;code&gt;xslt_process&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbca4f30190cfc2ab53ed342af0bd911de756565" translate="yes" xml:space="preserve">
          <source>F.45.5. Author</source>
          <target state="translated">F.45.5. 저자</target>
        </trans-unit>
        <trans-unit id="0c9f43206fdfe18d51f7f5571d14209ea19e37b5" translate="yes" xml:space="preserve">
          <source>F.5. bloom</source>
          <target state="translated">F.5. 꽃</target>
        </trans-unit>
        <trans-unit id="84ab20aba2d92cc1a1590909f4b482005c47645b" translate="yes" xml:space="preserve">
          <source>F.5.1. Parameters</source>
          <target state="translated">F.5.1. 매개 변수</target>
        </trans-unit>
        <trans-unit id="673e2d3f99b61c3d59eaa3f1d59e87f1bde89a66" translate="yes" xml:space="preserve">
          <source>F.5.2. Examples</source>
          <target state="translated">F.5.2. 예</target>
        </trans-unit>
        <trans-unit id="b7d7af901e503b3bd3361bcb44f2ca4e7f0f982f" translate="yes" xml:space="preserve">
          <source>F.5.3. Operator Class Interface</source>
          <target state="translated">F.5.3. 운영자 클래스 인터페이스</target>
        </trans-unit>
        <trans-unit id="406348dbcd7a4871777a0a0e27c87f1318473cdc" translate="yes" xml:space="preserve">
          <source>F.5.4. Limitations</source>
          <target state="translated">F.5.4. 한계</target>
        </trans-unit>
        <trans-unit id="dd61580c12a4f98b1cabd570abfde001db6de3d1" translate="yes" xml:space="preserve">
          <source>F.5.5. Authors</source>
          <target state="translated">F.5.5. 저자</target>
        </trans-unit>
        <trans-unit id="a89981817fb8aa3dd68bb59664597b224f16d5f0" translate="yes" xml:space="preserve">
          <source>F.6. btree_gin</source>
          <target state="translated">F.6. btree_gin</target>
        </trans-unit>
        <trans-unit id="298c7e5ff8550c0946352688d4d3e6a4b25575a8" translate="yes" xml:space="preserve">
          <source>F.6.1. Example Usage</source>
          <target state="translated">F.6.1. 사용법 예</target>
        </trans-unit>
        <trans-unit id="9b044f8ec33c35746bb232092d3cfcfa4f666672" translate="yes" xml:space="preserve">
          <source>F.6.2. Authors</source>
          <target state="translated">F.6.2. 저자</target>
        </trans-unit>
        <trans-unit id="6557988a7591a0506bac1834fde39bd8b124ef58" translate="yes" xml:space="preserve">
          <source>F.7. btree_gist</source>
          <target state="translated">F.7. btree_gist</target>
        </trans-unit>
        <trans-unit id="db6dc2c96c276017488bc338eff3b96529ea0429" translate="yes" xml:space="preserve">
          <source>F.7.1. Example Usage</source>
          <target state="translated">F.7.1. 사용법 예</target>
        </trans-unit>
        <trans-unit id="4e9e64a99b250a192332d6b3c5227a8dfbf209e9" translate="yes" xml:space="preserve">
          <source>F.7.2. Authors</source>
          <target state="translated">F.7.2. 저자</target>
        </trans-unit>
        <trans-unit id="d1f76faa362480f2e84be9515db1d46ec8bb6a6f" translate="yes" xml:space="preserve">
          <source>F.8. citext</source>
          <target state="translated">F.8. 인용문</target>
        </trans-unit>
        <trans-unit id="6cde381ccc3fba94785b363e72753335dad08a56" translate="yes" xml:space="preserve">
          <source>F.8.1. Rationale</source>
          <target state="translated">F.8.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="daae387369be9c7b6760bea450197227fccec483" translate="yes" xml:space="preserve">
          <source>F.8.2. How to Use It</source>
          <target state="translated">F.8.2. 사용 방법</target>
        </trans-unit>
        <trans-unit id="452ac339dee9be15e0568551b363547190886f57" translate="yes" xml:space="preserve">
          <source>F.8.3. String Comparison Behavior</source>
          <target state="translated">F.8.3. 문자열 비교 동작</target>
        </trans-unit>
        <trans-unit id="0638e188511f78ff49f7d5f4a67daace014f9f04" translate="yes" xml:space="preserve">
          <source>F.8.4. Limitations</source>
          <target state="translated">F.8.4. 한계</target>
        </trans-unit>
        <trans-unit id="ae62161d7090f631bab8e10ef93e795cb01ae0f1" translate="yes" xml:space="preserve">
          <source>F.8.5. Author</source>
          <target state="translated">F.8.5. 저자</target>
        </trans-unit>
        <trans-unit id="958c63dbb41d34478eb5d9903df2fbfe62fa0232" translate="yes" xml:space="preserve">
          <source>F.9. cube</source>
          <target state="translated">F.9. 입방체</target>
        </trans-unit>
        <trans-unit id="00e2e8ac74d90d0e143f1f95eb3aed8d07fdba6f" translate="yes" xml:space="preserve">
          <source>F.9.1. Syntax</source>
          <target state="translated">F.9.1. 통사론</target>
        </trans-unit>
        <trans-unit id="866d69bd804840afc072e42503476085271a3b11" translate="yes" xml:space="preserve">
          <source>F.9.2. Precision</source>
          <target state="translated">F.9.2. 정도</target>
        </trans-unit>
        <trans-unit id="26b1dd423d59d0ec9d01bc49c61bd2e3a130cde9" translate="yes" xml:space="preserve">
          <source>F.9.3. Usage</source>
          <target state="translated">F.9.3. 용법</target>
        </trans-unit>
        <trans-unit id="c3f5eb1d068801be237889607268f24e6e3ab414" translate="yes" xml:space="preserve">
          <source>F.9.4. Defaults</source>
          <target state="translated">F.9.4. 기본값</target>
        </trans-unit>
        <trans-unit id="e70fe9f6ff69447cd9c1390f81924b15d9d13996" translate="yes" xml:space="preserve">
          <source>F.9.5. Notes</source>
          <target state="translated">F.9.5. 노트</target>
        </trans-unit>
        <trans-unit id="7c4439349b83474406b10addc29c3c8578b55471" translate="yes" xml:space="preserve">
          <source>F.9.6. Credits</source>
          <target state="translated">F.9.6. 크레딧</target>
        </trans-unit>
        <trans-unit id="0ed2d7b5cdb77627bc46c6fac5026ec27b694d42" translate="yes" xml:space="preserve">
          <source>FALSE</source>
          <target state="translated">FALSE</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="89ec4fbb02681a94c7c5aceacee470704677dddd" translate="yes" xml:space="preserve">
          <source>FETCH &amp;mdash; retrieve rows from a query using a cursor</source>
          <target state="translated">FETCH &amp;mdash; 커서를 사용하여 쿼리에서 행을 검색</target>
        </trans-unit>
        <trans-unit id="3528e0aafdb15c80ec4aeb0892214fe763bf95b7" translate="yes" xml:space="preserve">
          <source>FNV-1a hash</source>
          <target state="translated">FNV-1a 해시</target>
        </trans-unit>
        <trans-unit id="eaa03e9feab1e85231315c30a563eae4cc597208" translate="yes" xml:space="preserve">
          <source>FOR KEY SHARE</source>
          <target state="translated">키 쉐어</target>
        </trans-unit>
        <trans-unit id="54a6a18e44a3063d3d591757a74e0cfec02a9176" translate="yes" xml:space="preserve">
          <source>FOR NO KEY UPDATE</source>
          <target state="translated">키 업데이트가없는 경우</target>
        </trans-unit>
        <trans-unit id="6a4900b69d309a0653aa71228c074fde940798c1" translate="yes" xml:space="preserve">
          <source>FOR SHARE</source>
          <target state="translated">공유</target>
        </trans-unit>
        <trans-unit id="380bce20ad76a7dcc21915daa6f049f535f22be2" translate="yes" xml:space="preserve">
          <source>FOR UPDATE</source>
          <target state="translated">업데이트</target>
        </trans-unit>
        <trans-unit id="a1150974d640edc4e9165f393ec148407a36653d" translate="yes" xml:space="preserve">
          <source>FSM</source>
          <target state="translated">FSM</target>
        </trans-unit>
        <trans-unit id="6d272f803d08e8669caa084ab669e54ff905af2c" translate="yes" xml:space="preserve">
          <source>Failover</source>
          <target state="translated">Failover</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="a7120cc7e891f5699da63567561c7d0959631572" translate="yes" xml:space="preserve">
          <source>Features of XQuery beyond those of XPath include:</source>
          <target state="translated">XPath의 기능 외에 XQuery의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc8415ccfe52505f1d0a74025c76b3c26c88c59d" translate="yes" xml:space="preserve">
          <source>Feb</source>
          <target state="translated">Feb</target>
        </trans-unit>
        <trans-unit id="5c3a35ef85f22d508f90171bdcb2e6d820731d20" translate="yes" xml:space="preserve">
          <source>February</source>
          <target state="translated">February</target>
        </trans-unit>
        <trans-unit id="619eaef9800d32e19402dbff39695c018eaba796" translate="yes" xml:space="preserve">
          <source>Fedora SELinux FAQ</source>
          <target state="translated">Fedora SELinux FAQ</target>
        </trans-unit>
        <trans-unit id="6f0eaf23fd0273cb96743cd0db99201691fbc2ae" translate="yes" xml:space="preserve">
          <source>Fetch all prior rows (scanning backwards).</source>
          <target state="translated">모든 이전 행을 가져옵니다 (뒤로 스캔).</target>
        </trans-unit>
        <trans-unit id="108fc4dc6fa49881adf4bb4eea1cfc55cc99332e" translate="yes" xml:space="preserve">
          <source>Fetch all remaining rows (same as &lt;code&gt;FORWARD ALL&lt;/code&gt;).</source>
          <target state="translated">나머지 모든 행을 가져옵니다 ( &lt;code&gt;FORWARD ALL&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="68bf6e4a1871298e3413b429bc1d1b24a5517a50" translate="yes" xml:space="preserve">
          <source>Fetch all remaining rows.</source>
          <target state="translated">나머지 모든 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f3984af856aedf00a083630ebeae90c1c2329b24" translate="yes" xml:space="preserve">
          <source>Fetch all tuples in the given scan and add them to the caller-supplied &lt;code&gt;TIDBitmap&lt;/code&gt; (that is, OR the set of tuple IDs into whatever set is already in the bitmap). The number of tuples fetched is returned (this might be just an approximate count, for instance some AMs do not detect duplicates). While inserting tuple IDs into the bitmap, &lt;code&gt;amgetbitmap&lt;/code&gt; can indicate that rechecking of the scan conditions is required for specific tuple IDs. This is analogous to the &lt;code&gt;xs_recheck&lt;/code&gt; output parameter of &lt;code&gt;amgettuple&lt;/code&gt;. Note: in the current implementation, support for this feature is conflated with support for lossy storage of the bitmap itself, and therefore callers recheck both the scan conditions and the partial index predicate (if any) for recheckable tuples. That might not always be true, however. &lt;code&gt;amgetbitmap&lt;/code&gt; and &lt;code&gt;amgettuple&lt;/code&gt; cannot be used in the same index scan; there are other restrictions too when using &lt;code&gt;amgetbitmap&lt;/code&gt;, as explained in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;.</source>
          <target state="translated">지정된 스캔에서 모든 튜플을 &lt;code&gt;TIDBitmap&lt;/code&gt; 호출자 제공 TIDBitmap (즉, 이미 비트 맵에있는 모든 세트에 튜플 ID 세트)에 추가합니다. 페치 된 튜플 수를 리턴합니다 (이는 대략적인 수일 수 있습니다 (예 : 일부 AM은 중복을 감지하지 않음)). 튜플 ID를 비트 맵에 삽입하는 동안 &lt;code&gt;amgetbitmap&lt;/code&gt; 은 특정 튜플 ID에 스캔 조건을 다시 확인해야 함을 나타낼 수 있습니다. 이것은 &lt;code&gt;xs_recheck&lt;/code&gt; 의 xs_recheck 출력 매개 변수와 &lt;code&gt;amgettuple&lt;/code&gt; . 참고 : 현재 구현에서이 기능에 대한 지원은 비트 맵 자체의 손실 저장에 대한 지원과 함께 제공되므로 호출자는 다시 검사 가능한 튜플에 대해 스캔 조건과 부분 인덱스 조건 자 (있는 경우)를 다시 확인합니다. 그러나 항상 그런 것은 아닙니다. &lt;code&gt;amgetbitmap&lt;/code&gt; 과 &lt;code&gt;amgettuple&lt;/code&gt; 은 동일한 인덱스 스캔에서 사용할 수 없습니다. &lt;a href=&quot;index-scanning&quot;&gt;섹션 61.3&lt;/a&gt; 에서 설명한 것처럼 &lt;code&gt;amgetbitmap&lt;/code&gt; 을 사용할 때 다른 제한 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f5012398f10dec65c55c3d7896e6e346eff005" translate="yes" xml:space="preserve">
          <source>Fetch missing table information from publisher. This will start replication of tables that were added to the subscribed-to publications since the last invocation of &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; or since &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt;.</source>
          <target state="translated">게시자로부터 누락 된 테이블 정보를 가져옵니다. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 의 마지막 호출 이후 또는 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 이후 구독 된 발행물에 추가 된 테이블의 복제가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="12be322cb6ed809af2a5a44f16e8baee5c640e43" translate="yes" xml:space="preserve">
          <source>Fetch the &lt;code&gt;count&lt;/code&gt;'th row of the query, or the &lt;code&gt;abs(count)&lt;/code&gt;'th row from the end if &lt;code&gt;count&lt;/code&gt; is negative. Position before first row or after last row if &lt;code&gt;count&lt;/code&gt; is out of range; in particular, &lt;code&gt;ABSOLUTE 0&lt;/code&gt; positions before the first row.</source>
          <target state="translated">쿼리 의 &lt;code&gt;count&lt;/code&gt; 번째 행 또는 &lt;code&gt;count&lt;/code&gt; 가 음수 이면 끝에서 &lt;code&gt;abs(count)&lt;/code&gt; '번째 행을 가져옵니다 . &lt;code&gt;count&lt;/code&gt; 가 범위를 벗어난 경우 첫 번째 행 앞 또는 마지막 행 후 위치 ; 특히, &lt;code&gt;ABSOLUTE 0&lt;/code&gt; 은 첫 번째 행 앞에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="ee66ff3651bfa860af594812c7431f4ee88f894d" translate="yes" xml:space="preserve">
          <source>Fetch the &lt;code&gt;count&lt;/code&gt;'th succeeding row, or the &lt;code&gt;abs(count)&lt;/code&gt;'th prior row if &lt;code&gt;count&lt;/code&gt; is negative. &lt;code&gt;RELATIVE 0&lt;/code&gt; re-fetches the current row, if any.</source>
          <target state="translated">페치 &lt;code&gt;count&lt;/code&gt; '번째 이후의 행 또는 &lt;code&gt;abs(count)&lt;/code&gt; '일 경우 종래의 행 &lt;code&gt;count&lt;/code&gt; 부정한다. &lt;code&gt;RELATIVE 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="ff4caca2298e6b2a18643be90f1ff4dbe3a2d96e" translate="yes" xml:space="preserve">
          <source>Fetch the first row of the query (same as &lt;code&gt;ABSOLUTE 1&lt;/code&gt;).</source>
          <target state="translated">쿼리의 첫 번째 행을 가져옵니다 ( &lt;code&gt;ABSOLUTE 1&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="c37af31bfc90a72a2a5d248d807ee535ad9886dc" translate="yes" xml:space="preserve">
          <source>Fetch the last row of the query (same as &lt;code&gt;ABSOLUTE -1&lt;/code&gt;).</source>
          <target state="translated">쿼리의 마지막 행을 가져옵니다 ( &lt;code&gt;ABSOLUTE -1&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="015f0234c411ae45e9fbeb4f8e7749dee5090740" translate="yes" xml:space="preserve">
          <source>Fetch the next &lt;code&gt;count&lt;/code&gt; rows (same as &lt;code&gt;FORWARD count&lt;/code&gt;).</source>
          <target state="translated">다음 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 ( &lt;code&gt;FORWARD count&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="37e8b8482794ca9076e152cf1e93a0dabc1fc631" translate="yes" xml:space="preserve">
          <source>Fetch the next &lt;code&gt;count&lt;/code&gt; rows. &lt;code&gt;FORWARD 0&lt;/code&gt; re-fetches the current row.</source>
          <target state="translated">다음 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 . &lt;code&gt;FORWARD 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bc7db6c5bb73a28b60746aa4dd9afa53ace9b03e" translate="yes" xml:space="preserve">
          <source>Fetch the next row (same as &lt;code&gt;NEXT&lt;/code&gt;).</source>
          <target state="translated">다음 행을 가져옵니다 ( &lt;code&gt;NEXT&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="b59bd04fef728ce25c648534357dff558bc4035b" translate="yes" xml:space="preserve">
          <source>Fetch the next row. This is the default if &lt;code&gt;direction&lt;/code&gt; is omitted.</source>
          <target state="translated">다음 행을 가져옵니다. &lt;code&gt;direction&lt;/code&gt; 이 생략 된 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="b9e61f7e1ebaad2cb2dddb47d03889f358a882d6" translate="yes" xml:space="preserve">
          <source>Fetch the next tuple in the given scan, moving in the given direction (forward or backward in the index). Returns true if a tuple was obtained, false if no matching tuples remain. In the true case the tuple TID is stored into the &lt;code&gt;scan&lt;/code&gt; structure. Note that &amp;ldquo;success&amp;rdquo; means only that the index contains an entry that matches the scan keys, not that the tuple necessarily still exists in the heap or will pass the caller's snapshot test. On success, &lt;code&gt;amgettuple&lt;/code&gt; must also set &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; to true or false. False means it is certain that the index entry matches the scan keys. true means this is not certain, and the conditions represented by the scan keys must be rechecked against the heap tuple after fetching it. This provision supports &amp;ldquo;lossy&amp;rdquo; index operators. Note that rechecking will extend only to the scan conditions; a partial index predicate (if any) is never rechecked by &lt;code&gt;amgettuple&lt;/code&gt; callers.</source>
          <target state="translated">주어진 방향으로 (인덱스에서 앞뒤로) 이동하여 주어진 스캔에서 다음 튜플을 가져옵니다. 튜플을 얻은 경우 true를, 일치하는 튜플이 남아 있지 않으면 false를 반환합니다. 실제 경우에 튜플 TID는 &lt;code&gt;scan&lt;/code&gt; 구조에 저장됩니다 . &quot;성공&quot;은 인덱스에 스캔 키와 일치하는 항목 만 포함하고 튜플이 여전히 힙에 있거나 호출자의 스냅 샷 테스트를 통과하지는 않는다는 것을 의미합니다. 성공하면 &lt;code&gt;amgettuple&lt;/code&gt; 도 &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; 를 설정해야합니다.참 또는 거짓으로. False는 인덱스 항목이 스캔 키와 일치 함을 의미합니다. true는 이것이 확실하지 않음을 의미하며 스캔 키로 표시되는 조건은 페치 후에 힙 튜플에 대해 다시 확인해야합니다. 이 조항은 &quot;손실&quot;인덱스 연산자를 지원합니다. 다시 확인하면 스캔 조건까지만 확장됩니다. &lt;code&gt;amgettuple&lt;/code&gt; 호출자 가 부분 인덱스 술어 (있는 경우)를 다시 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="794747f1afd7ec6cd3112f0f3646aa022d474d36" translate="yes" xml:space="preserve">
          <source>Fetch the prior &lt;code&gt;count&lt;/code&gt; rows (scanning backwards). &lt;code&gt;BACKWARD 0&lt;/code&gt; re-fetches the current row.</source>
          <target state="translated">이전 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 (뒤로 스캔). &lt;code&gt;BACKWARD 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="47567c2261024838c3ac160fffc8a3cee3c387c3" translate="yes" xml:space="preserve">
          <source>Fetch the prior row (same as &lt;code&gt;PRIOR&lt;/code&gt;).</source>
          <target state="translated">이전 행을 가져옵니다 ( &lt;code&gt;PRIOR&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="48d3a55ee879a7ef23c7fe13e569066bdb53be52" translate="yes" xml:space="preserve">
          <source>Fetch the prior row.</source>
          <target state="translated">이전 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c326a4660b674d2f6ea82687a1e1abae2337541f" translate="yes" xml:space="preserve">
          <source>Field</source>
          <target state="translated">Field</target>
        </trans-unit>
        <trans-unit id="1e2d2a8e9ba1e96bec6ca1b3b3837c537bc64ff3" translate="yes" xml:space="preserve">
          <source>Field values that are OIDs of other catalog entries should be represented by symbolic names rather than actual numeric OIDs. (In the example above, &lt;code&gt;dattablespace&lt;/code&gt; contains such a reference.) This is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-REFERENCES&quot;&gt;Section 69.2.3&lt;/a&gt; below.</source>
          <target state="translated">다른 카탈로그 항목의 OID 인 필드 값은 실제 숫자 OID가 아닌 기호 이름으로 표시되어야합니다. (위의 예에서, &lt;code&gt;dattablespace&lt;/code&gt; 는 그러한 참조를 포함합니다.) 이것은 아래 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-REFERENCES&quot;&gt;69.2.3 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="0d12a3f0ea99ebe85fe967431fc2aa6a3e0fd02b" translate="yes" xml:space="preserve">
          <source>File Formats</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="82598273eeb580afccf97b6a25626aefaef910ed" translate="yes" xml:space="preserve">
          <source>File Header</source>
          <target state="translated">파일 헤더</target>
        </trans-unit>
        <trans-unit id="83cab9651541d6505641439c0f1356ce8d3d088c" translate="yes" xml:space="preserve">
          <source>File Locations</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="aeac4db7a64d853e4153f7b1cd002ebc7db03bcc" translate="yes" xml:space="preserve">
          <source>File System (Block Device) Replication</source>
          <target state="translated">파일 시스템 (블록 장치) 복제</target>
        </trans-unit>
        <trans-unit id="f05e38d3789ebad590246017f1a1bf01f9623718" translate="yes" xml:space="preserve">
          <source>File System Level Backup</source>
          <target state="translated">파일 시스템 레벨 백업</target>
        </trans-unit>
        <trans-unit id="d72a124d87b5deba4a9972d8918749069bf98f69" translate="yes" xml:space="preserve">
          <source>File System Replication</source>
          <target state="translated">파일 시스템 복제</target>
        </trans-unit>
        <trans-unit id="aa5dc4b3bb787c150f84e5b8a9676302a4dddb66" translate="yes" xml:space="preserve">
          <source>File Trailer</source>
          <target state="translated">파일 예고편</target>
        </trans-unit>
        <trans-unit id="ff8be812330ed8eb012f7d2b99ed4048f24d67ce" translate="yes" xml:space="preserve">
          <source>File cloning is only supported on some operating systems and file systems. If it is selected but not supported, the pg_upgrade run will error. At present, it is supported on Linux (kernel 4.5 or later) with Btrfs and XFS (on file systems created with reflink support), and on macOS with APFS.</source>
          <target state="translated">파일 복제는 일부 운영 체제 및 파일 시스템에서만 지원됩니다. 선택되었지만 지원되지 않으면 pg_upgrade 실행에 오류가 발생합니다. 현재 Btrfs 및 XFS (reflink 지원으로 작성된 파일 시스템)가있는 Linux (커널 4.5 이상) 및 APFS가있는 macOS에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5afa53bb0ce293865ce8fe12e6764e92b21d55e8" translate="yes" xml:space="preserve">
          <source>File or path name</source>
          <target state="translated">파일 또는 경로 이름</target>
        </trans-unit>
        <trans-unit id="169f20cb38c9875b8d9b6448cf77ebcb49f4b735" translate="yes" xml:space="preserve">
          <source>File path name of the specified relation</source>
          <target state="translated">지정된 관계의 파일 경로 이름</target>
        </trans-unit>
        <trans-unit id="b5a241a4e88dea37ff234e6325621f35e769b187" translate="yes" xml:space="preserve">
          <source>File recording the log file(s) currently written to by the logging collector</source>
          <target state="translated">로깅 수집기에서 현재 기록한 로그 파일을 기록하는 파일</target>
        </trans-unit>
        <trans-unit id="8ebef13d126d46f9fd475e2e699e8aedad4eaa96" translate="yes" xml:space="preserve">
          <source>File system or storage subsystem faults where checksums happen to simply not be enabled.</source>
          <target state="translated">체크섬이 단순히 활성화되지 않는 파일 시스템 또는 스토리지 서브 시스템 결함.</target>
        </trans-unit>
        <trans-unit id="20e9dc282b64930c018dbbdebd189a315da71641" translate="yes" xml:space="preserve">
          <source>Filenode number of the relation</source>
          <target state="translated">관계의 파일 노드 번호</target>
        </trans-unit>
        <trans-unit id="dd7b439ca5a5202bf813b7c741151de540088b41" translate="yes" xml:space="preserve">
          <source>Filenode number of the specified relation</source>
          <target state="translated">지정된 관계의 파일 노드 번호</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="a827ddc455c062dd8bc05525342358ed28649c99" translate="yes" xml:space="preserve">
          <source>Files included by &lt;code&gt;@&lt;/code&gt; constructs are read as lists of names, which can be separated by either whitespace or commas. Comments are introduced by &lt;code&gt;#&lt;/code&gt;, just as in &lt;code&gt;pg_hba.conf&lt;/code&gt;, and nested &lt;code&gt;@&lt;/code&gt; constructs are allowed. Unless the file name following &lt;code&gt;@&lt;/code&gt; is an absolute path, it is taken to be relative to the directory containing the referencing file.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 구문에 포함 된 파일 은 이름 목록으로 읽 히며 공백 또는 쉼표로 구분할 수 있습니다. 주석은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서처럼 &lt;code&gt;#&lt;/code&gt; 에 의해 소개되며 중첩 된 &lt;code&gt;@&lt;/code&gt; 구문이 허용됩니다. &lt;code&gt;@&lt;/code&gt; 다음에 오는 파일 이름 이 절대 경로가 아닌 경우 참조 파일을 포함하는 디렉토리에 상대적인 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f684d3f323220fd489978388c876711f71f0edd9" translate="yes" xml:space="preserve">
          <source>Files named in a &lt;code&gt;COPY&lt;/code&gt; command are read or written directly by the server, not by the client application. Therefore, they must reside on or be accessible to the database server machine, not the client. They must be accessible to and readable or writable by the PostgreSQL user (the user ID the server runs as), not the client. Similarly, the command specified with &lt;code&gt;PROGRAM&lt;/code&gt; is executed directly by the server, not by the client application, must be executable by the PostgreSQL user. &lt;code&gt;COPY&lt;/code&gt; naming a file or command is only allowed to database superusers or users who are granted one of the default roles &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt;, or &lt;code&gt;pg_execute_server_program&lt;/code&gt;, since it allows reading or writing any file or running a program that the server has privileges to access.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 명령으로 이름 지정된 파일 은 클라이언트 응용 프로그램이 아닌 서버에서 직접 읽거나 씁니다. 따라서 클라이언트가 아닌 데이터베이스 서버 시스템에 상주하거나 액세스 할 수 있어야합니다. 클라이언트가 아닌 PostgreSQL 사용자 (서버가 실행하는 사용자 ID)가 액세스하고 읽고 쓸 수 있어야합니다. 마찬가지로 &lt;code&gt;PROGRAM&lt;/code&gt; 으로 지정된 명령 은 클라이언트 응용 프로그램이 아닌 서버에서 직접 실행되며 PostgreSQL 사용자가 실행할 수 있어야합니다. &lt;code&gt;COPY&lt;/code&gt; 파일이나 명령 이름은 기본 역할 중 하나를 부여 데이터베이스 슈퍼 유저 또는 사용자에게 허용 &lt;code&gt;pg_read_server_files&lt;/code&gt; , &lt;code&gt;pg_write_server_files&lt;/code&gt; , 또는 &lt;code&gt;pg_execute_server_program&lt;/code&gt; 서버가 액세스 권한을 가진 파일을 읽거나 쓰거나 프로그램을 실행할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8f791813a640903c10ebc229e20037ce8247e20" translate="yes" xml:space="preserve">
          <source>Fill up the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by appending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated.</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; (기본적으로 공백)을 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 &lt;em&gt;채 웁니다&lt;/em&gt; . 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이상 이미 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 후 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f60bc3c5f471357d3405d7e2039ebf2a3c18f421" translate="yes" xml:space="preserve">
          <source>Fill up the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by prepending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated (on the right).</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; 를 앞에 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 &lt;em&gt;채 웁니다&lt;/em&gt; (기본적으로 공백). 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 보다 이미 더 이상 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 다음은 (오른쪽) 잘립니다.</target>
        </trans-unit>
        <trans-unit id="3bb8242ee5d5ce7bcf8ba7f71d1da0e8901d9a45" translate="yes" xml:space="preserve">
          <source>Filter expressions must be specified right after the path evaluation step to which they are applied. The result of this step is filtered to include only those items that satisfy the provided condition. SQL/JSON defines three-valued logic, so the condition can be &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or &lt;code&gt;unknown&lt;/code&gt;. The &lt;code&gt;unknown&lt;/code&gt; value plays the same role as SQL &lt;code&gt;NULL&lt;/code&gt; and can be tested for with the &lt;code&gt;is unknown&lt;/code&gt; predicate. Further path evaluation steps use only those items for which filter expressions return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">필터 표현식은 적용되는 경로 평가 단계 직후에 지정해야합니다. 이 단계의 결과는 제공된 조건을 만족하는 항목 만 포함하도록 필터링됩니다. SQL / JSON은 3 값 논리를 정의하므로 조건이 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;unknown&lt;/code&gt; 일 수 있습니다. &lt;code&gt;unknown&lt;/code&gt; 값은 SQL과 같은 역할을한다 &lt;code&gt;NULL&lt;/code&gt; 을 하고 함께 테스트 할 수있는 &lt;code&gt;is unknown&lt;/code&gt; 조건. 추가 경로 평가 단계는 필터 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 항목 만 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="674a4d37699655591bca2da4bc50c7669f40486b" translate="yes" xml:space="preserve">
          <source>Final function (zero if none)</source>
          <target state="translated">최종 함수 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="b2f2ce3bfb7523b2f652baed7eac39cf356a1244" translate="yes" xml:space="preserve">
          <source>Final function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드의 최종 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="53ed47c708396102af0c273ef92199955b450206" translate="yes" xml:space="preserve">
          <source>Finally we will examine a query that involves a join:</source>
          <target state="translated">마지막으로 조인과 관련된 쿼리를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0bbec6f2250a9fe7d7708ab9ef4e5e279e682b97" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;NATURAL&lt;/code&gt; is a shorthand form of &lt;code&gt;USING&lt;/code&gt;: it forms a &lt;code&gt;USING&lt;/code&gt; list consisting of all column names that appear in both input tables. As with &lt;code&gt;USING&lt;/code&gt;, these columns appear only once in the output table. If there are no common column names, &lt;code&gt;NATURAL JOIN&lt;/code&gt; behaves like &lt;code&gt;JOIN ... ON TRUE&lt;/code&gt;, producing a cross-product join.</source>
          <target state="translated">마지막으로, &lt;code&gt;NATURAL&lt;/code&gt; 은 &lt;code&gt;USING&lt;/code&gt; 의 약식 입니다. 두 입력 테이블 모두에 나타나는 모든 열 이름으로 구성된 &lt;code&gt;USING&lt;/code&gt; 목록을 형성합니다 . &lt;code&gt;USING&lt;/code&gt; 과 마찬가지로이 열은 출력 테이블에 한 번만 나타납니다. 공통 열 이름이 없으면 &lt;code&gt;NATURAL JOIN&lt;/code&gt; 은 &lt;code&gt;JOIN ... ON TRUE&lt;/code&gt; 와 같이 동작 하여 교차 제품 조인을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8076b2f8f80def5a9432bb881260d2bb11a414af" translate="yes" xml:space="preserve">
          <source>Finally, a partial index can also be used to override the system's query plan choices. Also, data sets with peculiar distributions might cause the system to use an index when it really should not. In that case the index can be set up so that it is not available for the offending query. Normally, PostgreSQL makes reasonable choices about index usage (e.g., it avoids them when retrieving common values, so the earlier example really only saves index size, it is not required to avoid index usage), and grossly incorrect plan choices are cause for a bug report.</source>
          <target state="translated">마지막으로, 부분 인덱스를 사용하여 시스템의 쿼리 계획 선택을 무시할 수도 있습니다. 또한 고유 한 분포를 가진 데이터 세트로 인해 시스템이 실제로 사용하지 않아야 할 때 인덱스를 사용할 수 있습니다. 이 경우 문제가되는 쿼리에 인덱스를 사용할 수 없도록 인덱스를 설정할 수 있습니다. 일반적으로 PostgreSQL은 인덱스 사용에 대해 합리적인 선택을합니다 (예 : 공통 값을 검색 할 때이를 피하므로 앞의 예제는 실제로 인덱스 크기 만 저장하고 인덱스 사용을 피할 필요는 없습니다). 그리고 잘못된 계획 선택은 버그의 원인입니다. 보고서.</target>
        </trans-unit>
        <trans-unit id="86ba78973aa60c7a6565a34b0ffa02800cf420f9" translate="yes" xml:space="preserve">
          <source>Finally, create a server certificate signed by the new root certificate authority:</source>
          <target state="translated">마지막으로, 새로운 루트 인증 기관이 서명 한 서버 인증서를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="15ed2ff4f015b0482bf51e69c35c5b895d26b77c" translate="yes" xml:space="preserve">
          <source>Finally, in an ARE, outside bracket expressions, the sequence &lt;code&gt;(?#&lt;/code&gt;&lt;code&gt;ttt&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;ttt&lt;/code&gt; is any text not containing a &lt;code&gt;)&lt;/code&gt;) is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols, like &lt;code&gt;(?:&lt;/code&gt;. Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead.</source>
          <target state="translated">마지막으로 ARE 외부 괄호 표현식에서 시퀀스 &lt;code&gt;(?#&lt;/code&gt; &lt;code&gt;ttt&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (여기서 &lt;code&gt;ttt&lt;/code&gt; 는을 포함하지 않는 텍스트 &lt;code&gt;)&lt;/code&gt; )는 주석이며 완전히 무시됩니다. 다시 말하지만 &lt;code&gt;(?:&lt;/code&gt; . 와 같은 다중 문자 기호 문자 사이에는 허용되지 않습니다 . 이러한 주석은 유용한 기능보다 역사적인 유물이므로 더 이상 사용되지 않습니다. 대신 확장 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d5dc7a4d442f90df516e6bebea9b72e06fbc64" translate="yes" xml:space="preserve">
          <source>Finally, it should be mentioned that if you don't need a table any longer or want to recreate it differently you can remove it using the following command:</source>
          <target state="translated">마지막으로, 더 이상 테이블이 필요하지 않거나 다르게 다시 작성하려는 경우 다음 명령을 사용하여 테이블을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0593833ae070eb8197fa796874b0e02ac1b71abc" translate="yes" xml:space="preserve">
          <source>Finally, restore your data from backup with:</source>
          <target state="translated">마지막으로 다음을 사용하여 백업에서 데이터를 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="612e83a4042e46de0c9a02f14b12eb7806a107e9" translate="yes" xml:space="preserve">
          <source>Finally, run &lt;code&gt;make reformat-dat-files&lt;/code&gt; to remove the useless old entries from &lt;code&gt;pg_proc.dat&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;make reformat-dat-files&lt;/code&gt; 를 실행 하여 &lt;code&gt;pg_proc.dat&lt;/code&gt; 에서 쓸모없는 오래된 항목을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f44e5621a7452438120d0ba556957913fe9053b" translate="yes" xml:space="preserve">
          <source>Finally, run the regression test script:</source>
          <target state="translated">마지막으로 회귀 테스트 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e18f0fdeaf348134e3044f2eab682793c70b9d83" translate="yes" xml:space="preserve">
          <source>Finally, when the authentication exchange is completed successfully, the server sends an AuthenticationSASLFinal message, followed immediately by an AuthenticationOk message. The AuthenticationSASLFinal contains additional server-to-client data, whose content is particular to the selected authentication mechanism. If the authentication mechanism doesn't use additional data that's sent at completion, the AuthenticationSASLFinal message is not sent.</source>
          <target state="translated">마지막으로 인증 교환이 성공적으로 완료되면 서버는 AuthenticationSASLFinal 메시지를 보낸 다음 AuthenticationOk 메시지를 즉시 보냅니다. AuthenticationSASLFinal에는 추가 서버-클라이언트 데이터가 포함되어 있으며 해당 컨텐츠는 선택된 인증 메커니즘에 따라 다릅니다. 인증 메커니즘이 완료시 전송 된 추가 데이터를 사용하지 않으면 AuthenticationSASLFinal 메시지가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16fed1b1ce9d7613dbd3436ad2e1dd85f771ac9d" translate="yes" xml:space="preserve">
          <source>Find the relation associated with a given tablespace and filenode</source>
          <target state="translated">주어진 테이블 스페이스 및 파일 노드와 관련된 관계 찾기</target>
        </trans-unit>
        <trans-unit id="4351167b6edda62343061bf1021443ffaded3a99" translate="yes" xml:space="preserve">
          <source>Finish performing exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">단독 온라인 백업 수행 완료 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="28837b5e432b22380e4a6b15ce9678ae92f06934" translate="yes" xml:space="preserve">
          <source>Finish performing exclusive or non-exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">단독 또는 비 독점 온라인 백업 수행 완료 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="680f8d6a1be590a645a63ba3165212f3150701e2" translate="yes" xml:space="preserve">
          <source>Finite line segment</source>
          <target state="translated">유한 한 선분</target>
        </trans-unit>
        <trans-unit id="6dd4b1fa37883a130370f1fbf1595d8ffda7a5a6" translate="yes" xml:space="preserve">
          <source>First as-yet-unassigned txid. All txids greater than or equal to this are not yet started as of the time of the snapshot, and thus invisible.</source>
          <target state="translated">아직 할당되지 않은 txid입니다. 이보다 크거나 같은 모든 txid는 아직 스냅 샷 시점에 시작되지 않았으므로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a92b72f69ca6ff6bb186f802066ae0391ebc94d0" translate="yes" xml:space="preserve">
          <source>First make sure that an SSH server is running properly on the same machine as the PostgreSQL server and that you can log in using &lt;code&gt;ssh&lt;/code&gt; as some user. Then you can establish a secure tunnel with a command like this from the client machine:</source>
          <target state="translated">먼저 SSH 서버가 PostgreSQL 서버와 동일한 시스템에서 제대로 실행되고 있고 일부 사용자로 &lt;code&gt;ssh&lt;/code&gt; 를 사용하여 로그인 할 수 있는지 확인하십시오 . 그런 다음 클라이언트 시스템에서 다음과 같은 명령으로 보안 터널을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce51821c54f1d7bdbd595d320e5ee7c12e340da7" translate="yes" xml:space="preserve">
          <source>First set the configuration options in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 구성 옵션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4c575efa87d0a2df5442b6dd3794eb5790de14d" translate="yes" xml:space="preserve">
          <source>First timeline number used when WAL receiver is started</source>
          <target state="translated">WAL 수신기가 시작될 때 사용 된 첫 번째 타임 라인 번호</target>
        </trans-unit>
        <trans-unit id="da1cd65fbb15acd2e7834eed28e35abcbc8c82ad" translate="yes" xml:space="preserve">
          <source>First write-ahead log location used when WAL receiver is started</source>
          <target state="translated">WAL 수신자가 시작될 때 사용 된 최초 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="3d68839eda494d2d4c816d693a636ee1fdff60af" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Also, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T2의 행과의 결합 조건을 만족하지 않는 T1의 각 행에 대해 결합 된 행은 T2의 열에 널값으로 추가됩니다. 또한 T1의 행과의 조인 조건을 만족하지 않는 T2의 각 행에 대해 T1의 열에 널값이있는 조인 된 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bf68160bb0b09be302c80f5a6377c6068618a82e" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Thus, the joined table always has at least one row for each row in T1.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T2의 행과의 결합 조건을 만족하지 않는 T1의 각 행에 대해 결합 된 행은 T2의 열에 널값으로 추가됩니다. 따라서 조인 된 테이블에는 항상 T1의 각 행에 대해 하나 이상의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbacc69c4a250767394293662a5c10dcd05d405" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T2 that does not satisfy the join condition with any row in T1, a joined row is added with null values in columns of T1. This is the converse of a left join: the result table will always have a row for each row in T2.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T1의 행과의 조인 조건을 만족하지 않는 T2의 각 행에 대해 조인 된 행은 T1의 열에 널값으로 추가됩니다. 이것은 왼쪽 조인의 반대입니다. 결과 테이블에는 항상 T2의 각 행에 대한 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="112f7a7760de963ce73e2b79934214d9ac1a3666" translate="yes" xml:space="preserve">
          <source>First, set up &lt;code&gt;sepgsql&lt;/code&gt; in a working database according to the instructions in &lt;a href=&quot;sepgsql#SEPGSQL-INSTALLATION&quot;&gt;Section F.35.2&lt;/a&gt;. Note that the current operating system user must be able to connect to the database as superuser without password authentication.</source>
          <target state="translated">먼저 &lt;code&gt;sepgsql&lt;/code&gt; &lt;a href=&quot;sepgsql#SEPGSQL-INSTALLATION&quot;&gt;절의&lt;/a&gt; 지시 사항에 따라 작업중인 데이터베이스에 sepgsql을 설정하십시오 . 현재 운영 체제 사용자는 비밀번호 인증없이 데이터베이스에 수퍼 유저로 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ef0e65838b9c348fc778edd09543e18bd957409" translate="yes" xml:space="preserve">
          <source>Flag bits</source>
          <target state="translated">플래그 비트</target>
        </trans-unit>
        <trans-unit id="ea519240a9625ab43f20185bccd0e6d889013f94" translate="yes" xml:space="preserve">
          <source>Flags field</source>
          <target state="translated">플래그 필드</target>
        </trans-unit>
        <trans-unit id="085e4cb0a6de22bf43046dc7ac72d42d6d84b37b" translate="yes" xml:space="preserve">
          <source>Flush the WAL data to disk immediately after it has been received. Also send a status packet back to the server immediately after flushing, regardless of &lt;code&gt;--status-interval&lt;/code&gt;.</source>
          <target state="translated">WAL 데이터를받은 직후 디스크로 플러시하십시오. &lt;code&gt;--status-interval&lt;/code&gt; 에 관계없이 플러시 직후 서버에 상태 패킷을 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="2fd5404dbcdae2377752d6efc221270ab4825d00" translate="yes" xml:space="preserve">
          <source>Following the page header are item identifiers (&lt;code&gt;ItemIdData&lt;/code&gt;), each requiring four bytes. An item identifier contains a byte-offset to the start of an item, its length in bytes, and a few attribute bits which affect its interpretation. New item identifiers are allocated as needed from the beginning of the unallocated space. The number of item identifiers present can be determined by looking at &lt;code&gt;pd_lower&lt;/code&gt;, which is increased to allocate a new identifier. Because an item identifier is never moved until it is freed, its index can be used on a long-term basis to reference an item, even when the item itself is moved around on the page to compact free space. In fact, every pointer to an item (&lt;code&gt;ItemPointer&lt;/code&gt;, also known as &lt;code&gt;CTID&lt;/code&gt;) created by PostgreSQL consists of a page number and the index of an item identifier.</source>
          <target state="translated">페이지 헤더 다음에는 각각 4 바이트가 필요한 항목 식별자 ( &lt;code&gt;ItemIdData&lt;/code&gt; )가 있습니다. 항목 식별자에는 항목 시작에 대한 바이트 오프셋, 길이 (바이트) 및 해석에 영향을주는 몇 가지 속성 비트가 포함됩니다. 새 항목 식별자는 할당되지 않은 공간의 시작부터 필요에 따라 할당됩니다. 존재하는 아이템 식별자의 수 는 새로운 식별자를 할당하기 위해 증가되는 &lt;code&gt;pd_lower&lt;/code&gt; 를보고 결정될 수있다 . 항목 식별자는 해제 될 때까지 이동되지 않으므로 항목 자체를 페이지에서 이동하여 여유 공간을 줄이더라도 색인을 사용하여 항목을 참조 할 수 있습니다. 실제로 항목에 대한 모든 포인터 ( &lt;code&gt;ItemPointer&lt;/code&gt; , &lt;code&gt;CTID&lt;/code&gt; 라고도 함)PostgreSQL에 의해 생성 된)는 페이지 번호와 항목 식별자의 색인으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6c883e61266aaca99ae374d0bc028890e49de7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; statements, &lt;code&gt;WITH CHECK&lt;/code&gt; expressions are enforced after &lt;code&gt;BEFORE&lt;/code&gt; triggers are fired, and before any actual data modifications are made. Thus a &lt;code&gt;BEFORE ROW&lt;/code&gt; trigger may modify the data to be inserted, affecting the result of the security policy check. &lt;code&gt;WITH CHECK&lt;/code&gt; expressions are enforced before any other constraints.</source>
          <target state="translated">들어 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 문, &lt;code&gt;WITH CHECK&lt;/code&gt; 표현은 이후에 적용됩니다 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 해고하고, 실제 데이터 수정이되기 전에. 따라서 &lt;code&gt;BEFORE ROW&lt;/code&gt; 트리거는 삽입 할 데이터를 수정하여 보안 정책 검사 결과에 영향을 줄 수 있습니다. &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식은 다른 제한 조건보다 먼저 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="99deed17908e48271fc11c71fccf1c3dff1b0821" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; queries a RETURNING clause must be provided, and the target relation must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">들어 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 쿼리 복귀 절을 제공해야하며, 대상 관계는 조건부 규칙도 아니다 없어야합니다 &lt;code&gt;ALSO&lt;/code&gt; 의 규칙을,도 아니다은 &lt;code&gt;INSTEAD&lt;/code&gt; 여러 문에 그 팽창을 지배.</target>
        </trans-unit>
        <trans-unit id="0e7b7a49d626091f4506fce89e08d0ff24c020c0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UPDATE&lt;/code&gt; events, it is possible to specify a list of columns using this syntax:</source>
          <target state="translated">들어 &lt;code&gt;UPDATE&lt;/code&gt; 의 이벤트,이 구문을 사용하여 열 목록을 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="13c83d161616830e1f33c382b701d227cd558a73" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445725043f2e2c6f25fb417e94f2563fb378bf70" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;[a-z]&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;[a-z]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75b922537c547ae7448037c7c6ad96a06167147a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\copy ... from stdin&lt;/code&gt;, data rows are read from the same source that issued the command, continuing until &lt;code&gt;\.&lt;/code&gt; is read or the stream reaches EOF. This option is useful for populating tables in-line within a SQL script file. For &lt;code&gt;\copy ... to stdout&lt;/code&gt;, output is sent to the same place as psql command output, and the &lt;code&gt;COPY count&lt;/code&gt; command status is not printed (since it might be confused with a data row). To read/write psql's standard input or output regardless of the current command source or &lt;code&gt;\o&lt;/code&gt; option, write &lt;code&gt;from pstdin&lt;/code&gt; or &lt;code&gt;to pstdout&lt;/code&gt;.</source>
          <target state="translated">를 들어 &lt;code&gt;\copy ... from stdin&lt;/code&gt; 데이터 행이 될 때까지 계속 명령을 발행 한 같은 소스에서 읽 &lt;code&gt;\.&lt;/code&gt; 읽거나 스트림이 EOF에 도달합니다. 이 옵션은 SQL 스크립트 파일 내에서 테이블을 인라인으로 채우는 데 유용합니다. 들면 &lt;code&gt;\copy ... to stdout&lt;/code&gt; , 출력 명령 psql의 출력과 동일한 장소에 전송되고, &lt;code&gt;COPY count&lt;/code&gt; (이 데이터 행과 혼동 될 수 있기 때문) 명령 상태는 인쇄되지 않는다. 현재 명령 소스 또는 &lt;code&gt;\o&lt;/code&gt; 옵션에 관계없이 psql의 표준 입력 또는 출력을 읽거나 쓰려면 &lt;code&gt;from pstdin&lt;/code&gt; 또는 &lt;code&gt;to pstdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbe40a2f96bfb1794b52f2ae977f36a6df890e78" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp with time zone&lt;/code&gt; values, the number of seconds since 1970-01-01 00:00:00 UTC (can be negative); for &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;timestamp&lt;/code&gt; values, the number of seconds since 1970-01-01 00:00:00 local time; for &lt;code&gt;interval&lt;/code&gt; values, the total number of seconds in the interval</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 값이 있는 시간 소인의 경우 1970-01-01 00:00:00 UTC 이후의 초 수 (음수 일 수 있음). 위한 &lt;code&gt;date&lt;/code&gt; 및 &lt;code&gt;timestamp&lt;/code&gt; 값, 1970-01-01 0시 0분 0초 로컬 시간 보낸 초; 대 &lt;code&gt;interval&lt;/code&gt; 값 간격 (초) 총 개수</target>
        </trans-unit>
        <trans-unit id="022c7b4734aca13c0e569da1037faae44d208be0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp with time zone&lt;/code&gt;, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT). An input value that has an explicit time zone specified is converted to UTC using the appropriate offset for that time zone. If no time zone is stated in the input string, then it is assumed to be in the time zone indicated by the system's &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; parameter, and is converted to UTC using the offset for the &lt;code&gt;timezone&lt;/code&gt; zone.</source>
          <target state="translated">들어 &lt;code&gt;timestamp with time zone&lt;/code&gt; , 내부적으로 저장된 값은 UTC (전통적으로 그리니치 표준시, GMT로 알려진 표준시)에 항상이다. 명시 적 시간대가 지정된 입력 값은 해당 시간대에 대한 적절한 오프셋을 사용하여 UTC로 변환됩니다. 입력 문자열에 시간대가 지정되어 있지 않으면 시스템의 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 매개 변수로 표시된 시간대에있는 것으로 가정 하고 &lt;code&gt;timezone&lt;/code&gt; 대한 오프셋을 사용하여 UTC로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbd7164f3c2b0f4f4f5eac0a4b59bfa56e2902cb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the day (of the month) field (1 - 31) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of days</source>
          <target state="translated">시간 &lt;code&gt;timestamp&lt;/code&gt; 값의 경우, 일 (월) 필드 (1-31); 대 &lt;code&gt;interval&lt;/code&gt; 값 일수</target>
        </trans-unit>
        <trans-unit id="3546baced469dfb3851387c39eb316d80942a913" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the number of the month within the year (1 - 12) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of months, modulo 12 (0 - 11)</source>
          <target state="translated">대한 &lt;code&gt;timestamp&lt;/code&gt; 값, 올해 (1-12) 내에서 달의 수 위한 &lt;code&gt;interval&lt;/code&gt; 값 월수는 모듈로 (12) (0-11)</target>
        </trans-unit>
        <trans-unit id="b666b88755ac187f5a8ca6b56b29e5e20fd687c8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;xdes&lt;/code&gt; there is an additional limitation that the iteration count must be an odd number.</source>
          <target state="translated">들면 &lt;code&gt;xdes&lt;/code&gt; 반복 수가 홀수이어야한다는 추가적인 제약이있다.</target>
        </trans-unit>
        <trans-unit id="58dbe42e8e8c3048bd4768729e3a37b374beaf95" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;major&lt;/em&gt; releases of PostgreSQL, the internal data storage format is subject to change, thus complicating upgrades. The traditional method for moving data to a new major version is to dump and reload the database, though this can be slow. A faster method is &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt;. Replication methods are also available, as discussed below.</source>
          <target state="translated">들어 &lt;em&gt;주요&lt;/em&gt; PostgreSQL의 릴리스, 내부 데이터 저장 형식 따라서 업그레이드를 복잡하게 변경 될 수 있습니다. 데이터를 새로운 주요 버전으로 옮기는 전통적인 방법은 데이터베이스를 덤프하고 다시로드하는 것입니다. 더 빠른 방법은 &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt; 입니다. 아래에 설명 된대로 복제 방법도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e579402933c607f670c845aa7f8cfca193a4e5" translate="yes" xml:space="preserve">
          <source>For FreeBSD, look at the file &lt;code&gt;contrib/start-scripts/freebsd&lt;/code&gt; in the PostgreSQL source distribution.</source>
          <target state="translated">FreeBSD의 경우 PostgreSQL 소스 배포에서 &lt;code&gt;contrib/start-scripts/freebsd&lt;/code&gt; 파일을보십시오 .</target>
        </trans-unit>
        <trans-unit id="65a36d32e3a8fe156cfc690cdec561261e81aec6" translate="yes" xml:space="preserve">
          <source>For RSA encryption you must create either DSA or RSA sign-only key as master and then add an RSA encryption subkey with &lt;code&gt;gpg --edit-key&lt;/code&gt;.</source>
          <target state="translated">RSA 암호화의 경우 DSA 또는 RSA 서명 전용 키를 마스터로 생성 한 다음 &lt;code&gt;gpg --edit-key&lt;/code&gt; 를 사용하여 RSA 암호화 하위 키를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5dd1f47d5dc0087dbc26af3dcfa192ab806aa921" translate="yes" xml:space="preserve">
          <source>For Windows users, you must be logged into an administrative account, and then start a shell as the &lt;code&gt;postgres&lt;/code&gt; user and set the proper path:</source>
          <target state="translated">Windows 사용자의 경우 관리 계정으로 로그인 한 후 &lt;code&gt;postgres&lt;/code&gt; 사용자 로 쉘을 시작 하고 올바른 경로를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea1047057136e71c7f021f5dae197764108e8152" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;hostssl&lt;/code&gt; entry with &lt;code&gt;clientcert=verify-ca&lt;/code&gt;, the server will verify that the client's certificate is signed by one of the trusted certificate authorities. If &lt;code&gt;clientcert=verify-full&lt;/code&gt; is specified, the server will not only verify the certificate chain, but it will also check whether the username or its mapping matches the &lt;code&gt;cn&lt;/code&gt; (Common Name) of the provided certificate. Note that certificate chain validation is always ensured when the &lt;code&gt;cert&lt;/code&gt; authentication method is used (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;clientcert=verify-ca&lt;/code&gt; 가 있는 &lt;code&gt;hostssl&lt;/code&gt; 항목의 경우, 서버는 클라이언트의 인증서가 신뢰할 수있는 인증 기관 중 하나에 의해 서명되었는지 확인합니다. 경우 &lt;code&gt;clientcert=verify-full&lt;/code&gt; 지정되면, 서버는 인증서 체인을 확인하지 않습니다, 그러나 그것은 또한 사용자 이름 또는 매핑이 일치하는지 여부를 확인합니다 &lt;code&gt;cn&lt;/code&gt; 제공된 인증서 (공통 이름). &lt;code&gt;cert&lt;/code&gt; 인증 방법을 사용 하면 인증서 체인 유효성 검사가 항상 보장 됩니다 ( &lt;a href=&quot;auth-cert&quot;&gt;섹션 20.12&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0e7295a68549852c29d6fecae79435a579540b69" translate="yes" xml:space="preserve">
          <source>For a Gaussian distribution, the interval is mapped onto a standard normal distribution (the classical bell-shaped Gaussian curve) truncated at &lt;code&gt;-parameter&lt;/code&gt; on the left and &lt;code&gt;+parameter&lt;/code&gt; on the right. Values in the middle of the interval are more likely to be drawn. To be precise, if &lt;code&gt;PHI(x)&lt;/code&gt; is the cumulative distribution function of the standard normal distribution, with mean &lt;code&gt;mu&lt;/code&gt; defined as &lt;code&gt;(max + min) / 2.0&lt;/code&gt;, with</source>
          <target state="translated">가우스 분포를 들어, 간격은 절단 표준 정규 분포 (고전 종 모양의 가우스 곡선)에 매핑된다 &lt;code&gt;-parameter&lt;/code&gt; 왼쪽에 &lt;code&gt;+parameter&lt;/code&gt; 오른쪽. 구간 중간의 값이 더 많이 그려 질 수 있습니다. 만약 정확한 될 &lt;code&gt;PHI(x)&lt;/code&gt; , 평균, 표준 정규 분포의 누적 분포 함수 &lt;code&gt;mu&lt;/code&gt; 정의 &lt;code&gt;(max + min) / 2.0&lt;/code&gt; 으로,</target>
        </trans-unit>
        <trans-unit id="c70c859349570f9d2df772492a1cca445d1bebc6" translate="yes" xml:space="preserve">
          <source>For a comment on a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 컬럼에 코멘트의 경우, 이것은 열 번호입니다합니다 ( &lt;code&gt;objoid&lt;/code&gt; 가 와 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c77c040fe7ed64266629248efa7e92eaaf49a102" translate="yes" xml:space="preserve">
          <source>For a consistent backup, the database server needs to support synchronized snapshots, a feature that was introduced in PostgreSQL 9.2 for primary servers and 10 for standbys. With this feature, database clients can ensure they see the same data set even though they use different connections. &lt;code&gt;pg_dump -j&lt;/code&gt; uses multiple database connections; it connects to the database once with the master process and once again for each worker job. Without the synchronized snapshot feature, the different worker jobs wouldn't be guaranteed to see the same data in each connection, which could lead to an inconsistent backup.</source>
          <target state="translated">일관된 백업을 위해서는 데이터베이스 서버가 PostgreSQL 9.2 (기본 서버의 경우 10 개, 대기의 경우 10 개)에 도입 된 기능인 동기화 된 스냅 샷을 지원해야합니다. 이 기능을 사용하면 데이터베이스 클라이언트는 다른 연결을 사용하더라도 동일한 데이터 세트를 볼 수 있습니다. &lt;code&gt;pg_dump -j&lt;/code&gt; 는 여러 데이터베이스 연결을 사용합니다. 마스터 프로세스로 한 번 데이터베이스에 연결하고 각 작업자 작업마다 다시 연결합니다. 동기화 된 스냅 샷 기능이 없으면 서로 다른 작업자 작업이 각 연결에서 동일한 데이터를 보도록 보장 할 수 없으므로 백업이 일관되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b742e0426def8e161b548a97e5e242fbcf821e02" translate="yes" xml:space="preserve">
          <source>For a detailed description of the Linux huge pages feature have a look at &lt;a href=&quot;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&quot;&gt;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&lt;/a&gt;.</source>
          <target state="translated">Linux 거대한 페이지 기능에 대한 자세한 설명은 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&quot;&gt;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f619524dce98e4031aba392da00393e55b558403" translate="yes" xml:space="preserve">
          <source>For a fixed-size type, &lt;code&gt;typlen&lt;/code&gt; is the number of bytes in the internal representation of the type. But for a variable-length type, &lt;code&gt;typlen&lt;/code&gt; is negative. -1 indicates a &amp;ldquo;varlena&amp;rdquo; type (one that has a length word), -2 indicates a null-terminated C string.</source>
          <target state="translated">고정 크기 유형의 경우 &lt;code&gt;typlen&lt;/code&gt; 은 유형 의 내부 표현에서 바이트 수입니다. 그러나 가변 길이 유형의 경우 &lt;code&gt;typlen&lt;/code&gt; 은 음수입니다. -1은 &quot;varlena&quot;유형 (길이 워드가있는 유형)을 나타내고 -2는 널 종료 C 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c716c97bef682a5580619511cc00e4ae11e29df3" translate="yes" xml:space="preserve">
          <source>For a foreign table using &lt;code&gt;file_fdw&lt;/code&gt;, &lt;code&gt;EXPLAIN&lt;/code&gt; shows the name of the file to be read or program to be run. For a file, unless &lt;code&gt;COSTS OFF&lt;/code&gt; is specified, the file size (in bytes) is shown as well.</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 를 사용하는 외부 테이블의 경우 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 읽을 파일 이름 또는 실행할 프로그램 이름을 표시합니다. 파일의 경우 &lt;code&gt;COSTS OFF&lt;/code&gt; 를 지정 하지 않으면 파일 크기 (바이트)도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fb6748fc19be0ed0a5abf4e0f452d7dd4259e2" translate="yes" xml:space="preserve">
          <source>For a function or operator call, the collation that is derived by examining the argument collations is used at run time for performing the specified operation. If the result of the function or operator call is of a collatable data type, the collation is also used at parse time as the defined collation of the function or operator expression, in case there is a surrounding expression that requires knowledge of its collation.</source>
          <target state="translated">함수 또는 연산자 호출의 경우 인수 데이터 정렬을 검사하여 파생 된 데이터 정렬은 런타임에 지정된 작업을 수행하는 데 사용됩니다. 함수 또는 연산자 호출의 결과가 데이터 정렬 가능 유형 인 경우 데이터 정렬에 대한 지식이 필요한 주변 표현식이있는 경우 구문 분석시 함수 또는 연산자 표현식의 정의 된 데이터 정렬로 구문 분석 시간도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="873de634341e3f4f17aa404bfb78db0b8b1d7819" translate="yes" xml:space="preserve">
          <source>For a language not known in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog, a sequence such as this is needed:</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그에 알려지지 않은 언어의 경우 다음 과 같은 순서가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51c1f1c841407e1e55f78883fd3c8f0203af376b" translate="yes" xml:space="preserve">
          <source>For a more extensive demonstration, we first create a &lt;code&gt;public.english&lt;/code&gt; configuration and Ispell dictionary for the English language:</source>
          <target state="translated">보다 광범위한 데모를 위해 먼저 영어 용 &lt;code&gt;public.english&lt;/code&gt; 구성 및 Ispell 사전을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="790cb0afd5e6474475083710292021c180b53bde" translate="yes" xml:space="preserve">
          <source>For a security label on a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 컬럼에 대한 보안 레이블의 경우,이 열 번호입니다합니다 ( &lt;code&gt;objoid&lt;/code&gt; 가 와 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="65033bc1e9e88185caf62bac78563d365080e3d5" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;objid&lt;/code&gt; and &lt;code&gt;classid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 열의 경우 열 번호입니다 ( &lt;code&gt;objid&lt;/code&gt; 및 &lt;code&gt;classid&lt;/code&gt; 는 테이블 자체를 나타냄). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c5ce9480f6b6749d12052ad99ca0fb55409dd48e" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 항목은이 열 번호 ( &lt;code&gt;objoid&lt;/code&gt; 은 과 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="649ae99e00f56ecf560264794b88e680e3e3769c" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;refobjid&lt;/code&gt; and &lt;code&gt;refclassid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 열의 경우 열 번호입니다 ( &lt;code&gt;refobjid&lt;/code&gt; 및 &lt;code&gt;refclassid&lt;/code&gt; 는 테이블 자체를 나타냄). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="eabd8eb6f239223b555e1ca5f4a755e59810f860" translate="yes" xml:space="preserve">
          <source>For a target column declared as &lt;code&gt;character(20)&lt;/code&gt; the following statement shows that the stored value is sized correctly:</source>
          <target state="translated">&lt;code&gt;character(20)&lt;/code&gt; 로 선언 된 대상 열의 경우 다음 명령문은 저장된 값의 크기가 올바르게 지정되었음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e7c0ff43494255c9b4e4649e18a3ecb09a7c13cb" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;37.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8ec9455b3b3ecef5cd6da5c8b1451f7a76196b" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;.</source>
          <target state="translated">추가 세부 사항은 &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 및 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bc2c859a66cc47f7ab253d738eacf7f06902a6f" translate="yes" xml:space="preserve">
          <source>For additional information on tuning these settings, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</source>
          <target state="translated">이러한 설정 조정에 대한 자세한 내용 &lt;a href=&quot;wal-configuration&quot;&gt;은 29.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3269f32ce55507d4303558fb95944d5f97b55201" translate="yes" xml:space="preserve">
          <source>For additional information see &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6de3939693bb1f9d3d1fe45488c69d0a8681aad2" translate="yes" xml:space="preserve">
          <source>For additional information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;, &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;, &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;, and &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt; , &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt; , &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt; , &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 및 &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8aca49f3e5f06e066139112539b79576ab0035" translate="yes" xml:space="preserve">
          <source>For additional variables that affect the server, see &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;.</source>
          <target state="translated">서버에 영향을주는 추가 변수는 &lt;a href=&quot;app-postgres&quot;&gt;postgres를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdf9570df93b845cb267b78130d56401af562fa2" translate="yes" xml:space="preserve">
          <source>For aggregate functions whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, the &lt;code&gt;combinefunc&lt;/code&gt; must not be strict. In this case the &lt;code&gt;combinefunc&lt;/code&gt; must ensure that null states are handled correctly and that the state being returned is properly stored in the aggregate memory context.</source>
          <target state="translated">누구의 집계 함수의 &lt;code&gt;state_data_type&lt;/code&gt; 입니다 &lt;code&gt;internal&lt;/code&gt; 의 &lt;code&gt;combinefunc&lt;/code&gt; 은 엄격하지 않아야합니다. 이 경우 &lt;code&gt;combinefunc&lt;/code&gt; 는 널 (null) 상태가 올바르게 처리되고 리턴되는 상태가 집계 메모리 컨텍스트에 올바르게 저장되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="96ebaaa890b3287a6cc4cc73ddb31fd495f4b938" translate="yes" xml:space="preserve">
          <source>For all types of in-memory TOAST pointer, the TOAST management code ensures that no such pointer datum can accidentally get stored on disk. In-memory TOAST pointers are automatically expanded to normal in-line varlena values before storage &amp;mdash; and then possibly converted to on-disk TOAST pointers, if the containing tuple would otherwise be too big.</source>
          <target state="translated">모든 유형의 인 메모리 TOAST 포인터의 경우 TOAST 관리 코드는 이러한 포인터 데이텀이 실수로 디스크에 저장되지 않도록합니다. 인 메모리 TOAST 포인터는 저장 전에 자동으로 일반 인라인 varlena 값으로 확장 된 다음 포함 튜플이 너무 큰 경우 디스크상의 TOAST 포인터로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c5f8e7c27807a2274e36cb656c8abd549f0c2f" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; command, the publication will publish the operation that actually results from the command. So depending of the outcome, it may be published as either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or it may not be published at all.</source>
          <target state="translated">를 들어 &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; 명령을 게시는 것을 실제로 명령의 결과 작업을 게시합니다. 따라서 결과에 따라 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 로 게시되거나 전혀 게시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c28bd7503d02aa54b1f5bc7ca2e5f40da183d1" translate="yes" xml:space="preserve">
          <source>For an MD5 encrypted password, &lt;code&gt;rolpassword&lt;/code&gt; column will begin with the string &lt;code&gt;md5&lt;/code&gt; followed by a 32-character hexadecimal MD5 hash. The MD5 hash will be of the user's password concatenated to their user name. For example, if user &lt;code&gt;joe&lt;/code&gt; has password &lt;code&gt;xyzzy&lt;/code&gt;, PostgreSQL will store the md5 hash of &lt;code&gt;xyzzyjoe&lt;/code&gt;.</source>
          <target state="translated">MD5 암호화 비밀번호의 경우 &lt;code&gt;rolpassword&lt;/code&gt; 열은 문자열 &lt;code&gt;md5&lt;/code&gt; 로 시작 하고 32 자 16 진 MD5 해시가옵니다. MD5 해시는 사용자 이름과 연결된 사용자 암호입니다. 예를 들어, &lt;code&gt;joe&lt;/code&gt; 사용자 에게 암호 &lt;code&gt;xyzzy&lt;/code&gt; 가 있으면 PostgreSQL은 &lt;code&gt;xyzzyjoe&lt;/code&gt; 의 md5 해시를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="a8f9fac8435c636eaa9948982c5c6b1419a33356" translate="yes" xml:space="preserve">
          <source>For an exponential distribution, &lt;code&gt;parameter&lt;/code&gt; controls the distribution by truncating a quickly-decreasing exponential distribution at &lt;code&gt;parameter&lt;/code&gt;, and then projecting onto integers between the bounds. To be precise, with</source>
          <target state="translated">지수 분포를 들어, &lt;code&gt;parameter&lt;/code&gt; 에 재 빠르게 감소 지수 분포를 절단함으로써 분배 제어 &lt;code&gt;parameter&lt;/code&gt; 다음 범위의 정수에 투사한다. 정확히 말하자면</target>
        </trans-unit>
        <trans-unit id="65c3010f7ad4d8ce5cd9ffc778600e650d4f3866" translate="yes" xml:space="preserve">
          <source>For an operator family supporting multiple data types, the above laws must hold when &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; are taken from any data types in the family. The transitive laws are the trickiest to ensure, as in cross-type situations they represent statements that the behaviors of two or three different operators are consistent. As an example, it would not work to put &lt;code&gt;float8&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; into the same operator family, at least not with the current semantics that &lt;code&gt;numeric&lt;/code&gt; values are converted to &lt;code&gt;float8&lt;/code&gt; for comparison to a &lt;code&gt;float8&lt;/code&gt;. Because of the limited accuracy of &lt;code&gt;float8&lt;/code&gt;, this means there are distinct &lt;code&gt;numeric&lt;/code&gt; values that will compare equal to the same &lt;code&gt;float8&lt;/code&gt; value, and thus the transitive law would fail.</source>
          <target state="translated">여러 데이터 유형을 지원하는 운영자 제품군의 경우 패밀리의 모든 데이터 유형에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 를 가져 오는 경우 위의 법률에 따라야합니다 . 전 이적 법칙은 교차 유형 상황에서 두세 명의 다른 연산자의 행동이 일관된다는 진술을 나타 내기 때문에 가장 까다로울 수 있습니다. 예를 들어, 안 작업 넣는 것 &lt;code&gt;float8&lt;/code&gt; 와 &lt;code&gt;numeric&lt;/code&gt; 적어도 않는 것이 현재의 의미와 동일한 조작 집안 &lt;code&gt;numeric&lt;/code&gt; 값으로 변환 &lt;code&gt;float8&lt;/code&gt; (A)에 비교 &lt;code&gt;float8&lt;/code&gt; . &lt;code&gt;float8&lt;/code&gt; 의 정확도가 제한되어 있기 때문에 이는 고유 한 &lt;code&gt;numeric&lt;/code&gt; 가 있음을 의미합니다동일한 &lt;code&gt;float8&lt;/code&gt; 값 과 동일하게 비교 될 수 있으므로 전이 법칙은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fb67d8e335116f8d04cb145c346f347c48295886" translate="yes" xml:space="preserve">
          <source>For analyze, a similar condition is used: the threshold, defined as:</source>
          <target state="translated">분석을 위해 유사한 조건이 사용됩니다. 임계 값은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ad010e024a4439cd621de2da500fdb418cf81a" translate="yes" xml:space="preserve">
          <source>For any pattern, to install shared applications (tables to be used by everyone, additional functions provided by third parties, etc.), put them into separate schemas. Remember to grant appropriate privileges to allow the other users to access them. Users can then refer to these additional objects by qualifying the names with a schema name, or they can put the additional schemas into their search path, as they choose.</source>
          <target state="translated">모든 패턴에 대해 공유 응용 프로그램 (모든 사람이 사용할 테이블, 타사에서 제공하는 추가 기능 등)을 설치하려면 별도의 스키마에 넣으십시오. 다른 사용자가 액세스 할 수 있도록 적절한 권한을 부여하십시오. 그런 다음 사용자는 이름을 스키마 이름으로 규정하여 이러한 추가 오브젝트를 참조하거나 추가 스키마를 원하는대로 검색 경로에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16a497bd5483558f99655038b89f96368461a1c5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">이전 버전과의 호환성을 위해 이름을 작은 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca86393d893511ed217c26aec47e69fc362ff707" translate="yes" xml:space="preserve">
          <source>For both &lt;code&gt;LIKE&lt;/code&gt; and regular-expression searches, keep in mind that a pattern with no extractable trigrams will degenerate to a full-index scan.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;LIKE&lt;/code&gt; 와 정규 표현 검색, 아니 추출 괘와 패턴이 전체 인덱스 스캔으로 변질 것을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="7c873bea9ea29f067ffabebef48d2954f71baefe" translate="yes" xml:space="preserve">
          <source>For both these functions, the optional &lt;code&gt;weights&lt;/code&gt; argument offers the ability to weigh word instances more or less heavily depending on how they are labeled. The weight arrays specify how heavily to weigh each category of word, in the order:</source>
          <target state="translated">이 두 기능 모두에 대해 선택적 &lt;code&gt;weights&lt;/code&gt; 인수는 레이블이 지정된 방식에 따라 단어 인스턴스의 무게를 어느 정도 줄일 수 있습니다. 가중치 배열은 다음과 같은 순서로 각 단어 범주를 얼마나 크게 계량 할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0b0722cabc6ab2e548afa613aa4953b992a05e07" translate="yes" xml:space="preserve">
          <source>For clarity we omitted the &lt;code&gt;coalesce&lt;/code&gt; function calls which would be needed to find rows that contain &lt;code&gt;NULL&lt;/code&gt; in one of the two fields.</source>
          <target state="translated">명확성 을 위해 두 필드 중 하나에 &lt;code&gt;NULL&lt;/code&gt; 을 포함하는 행을 찾는 데 필요한 &lt;code&gt;coalesce&lt;/code&gt; 함수 호출을 생략했습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4475c3ea46bdd2013d00d5535373f530d5c349" translate="yes" xml:space="preserve">
          <source>For clarity, you can also request default values explicitly, for individual columns or for the entire row:</source>
          <target state="translated">명확하게하기 위해 개별 열 또는 전체 행에 대해 기본값을 명시 적으로 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="93860c51a978bc4e5066beb2f011be832a913dba" translate="yes" xml:space="preserve">
          <source>For clients using extended query protocol, durations of the Parse, Bind, and Execute steps are logged independently.</source>
          <target state="translated">확장 쿼리 프로토콜을 사용하는 클라이언트의 경우 구문 분석, 바인드 및 실행 단계의 지속 기간이 독립적으로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="642c28fcef80f55a7fa8a09654289e47fe6125b8" translate="yes" xml:space="preserve">
          <source>For comparison, the PostgreSQL 8.1 documentation contained 10,441 unique words, a total of 335,420 words, and the most frequent word &amp;ldquo;postgresql&amp;rdquo; was mentioned 6,127 times in 655 documents.</source>
          <target state="translated">비교를 위해 PostgreSQL 8.1 설명서에는 10,441 개의 고유 한 단어, 총 335,420 개의 단어가 포함되어 있으며 가장 빈번한 단어 &quot;postgresql&quot;은 655 개 문서에서 6,127 번 언급되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e2967140afc307af479be8f80698d1858dbc62a" translate="yes" xml:space="preserve">
          <source>For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for &lt;code&gt;float4&lt;/code&gt;) or 15 (for &lt;code&gt;float8&lt;/code&gt;) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively.</source>
          <target state="translated">이전 버전의 PostgreSQL에서 생성 된 출력과 호환되고 출력 정밀도를 &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;낮추기&lt;/a&gt; 위해 extra_float_digits 매개 변수를 사용하여 반올림 된 십진 출력을 대신 선택할 수 있습니다. 값을 0으로 설정하면 값을 6 ( &lt;code&gt;float4&lt;/code&gt; ) 또는 15 ( &lt;code&gt;float8&lt;/code&gt; )의 유효 10 진수로 반올림하는 이전 기본값이 복원 됩니다. 음수 값을 설정하면 자릿수가 더 줄어 듭니다. 예를 들어 -2는 출력을 각각 4 또는 13 자리로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="82e33c9e09cc041982adc16695f27c2ebea4aeea" translate="yes" xml:space="preserve">
          <source>For compatibility with some other database systems, &lt;code&gt;argmode&lt;/code&gt; can be written either before or after &lt;code&gt;argname&lt;/code&gt;. But only the first way is standard-compliant.</source>
          <target state="translated">다른 데이터베이스 시스템과의 호환성을 위해 &lt;code&gt;argmode&lt;/code&gt; 는 이전 또는 이후에 기록 될 수 &lt;code&gt;argname&lt;/code&gt; . 그러나 첫 번째 방법 만 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="28fead7bc1a5393ae5055409c79f82dc0d627975" translate="yes" xml:space="preserve">
          <source>For compatibility's sake, PostgreSQL will accept the &lt;code&gt;GLOBAL&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; keywords in a temporary table declaration, but they currently have no effect. Use of these keywords is discouraged, since future versions of PostgreSQL might adopt a more standard-compliant interpretation of their meaning.</source>
          <target state="translated">호환성을 위해 PostgreSQL은 임시 테이블 선언에서 &lt;code&gt;GLOBAL&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 키워드를 허용 하지만 현재는 효과가 없습니다. 이후 버전의 PostgreSQL에서는 의미에 대한보다 표준적인 해석을 채택 할 수 있으므로 이러한 키워드는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cb0d695c453e288497b0e820fe56bdd716e52946" translate="yes" xml:space="preserve">
          <source>For compiled functions, both built-in and dynamically loaded, &lt;code&gt;prosrc&lt;/code&gt; contains the function's C-language name (link symbol). For all other currently-known language types, &lt;code&gt;prosrc&lt;/code&gt; contains the function's source text. &lt;code&gt;probin&lt;/code&gt; is unused except for dynamically-loaded C functions, for which it gives the name of the shared library file containing the function.</source>
          <target state="translated">내장 및 동적으로로드 된 컴파일 된 함수의 경우 &lt;code&gt;prosrc&lt;/code&gt; 에는 함수의 C 언어 이름 (링크 기호)이 포함됩니다. 현재 알려진 다른 모든 언어 유형의 경우 &lt;code&gt;prosrc&lt;/code&gt; 에는 함수의 소스 텍스트가 포함됩니다. &lt;code&gt;probin&lt;/code&gt; 은 동적으로로드 된 C 함수를 제외하고는 사용되지 않으며 함수를 포함하는 공유 라이브러리 파일의 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1593a37c3e4bef998076b51ab60cf493f14debc2" translate="yes" xml:space="preserve">
          <source>For conditional purposes, non zero numerical values are &lt;code&gt;TRUE&lt;/code&gt;, zero numerical values and &lt;code&gt;NULL&lt;/code&gt; are &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">조건부 목적으로, 0이 아닌 숫자 값은 &lt;code&gt;TRUE&lt;/code&gt; , 0 숫자 값 및 &lt;code&gt;NULL&lt;/code&gt; 은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca450dc70846b4e702e0834dc4a1ac754f8335c" translate="yes" xml:space="preserve">
          <source>For convenience there are also single letter command-line option switches available for some parameters. They are described in &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;Table 19.2&lt;/a&gt;. Some of these options exist for historical reasons, and their presence as a single-letter option does not necessarily indicate an endorsement to use the option heavily.</source>
          <target state="translated">편의상 일부 매개 변수에 사용 가능한 단일 문자 명령 행 옵션 스위치도 있습니다. 그것들은 &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;표 19.2에&lt;/a&gt; 설명되어 있습니다. 이러한 옵션 중 일부는 역사적 이유로 존재하며 단일 문자 옵션으로 존재한다고해서 옵션을 많이 사용한다고 보증하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f4b1609541244f90c1469cfda93f87205751028" translate="yes" xml:space="preserve">
          <source>For convenience, the programs &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; and &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; are provided as wrappers around these SQL commands that can be called from the shell command line:</source>
          <target state="translated">편의상 &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; 및 &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; 프로그램 은 쉘 명령 행에서 호출 할 수있는 이러한 SQL 명령 주위에 랩퍼로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3832912e6c9f91aa4902ff08b60d0cbcee1c2ac8" translate="yes" xml:space="preserve">
          <source>For convenience, there is also a shell program to drop databases, &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;:</source>
          <target state="translated">편의를 위해 데이터베이스를 삭제하는 쉘 프로그램 &lt;a href=&quot;app-dropdb&quot;&gt;dropdb도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2086e8168bb5d57d0ea6881d92ef9c3d377f6179" translate="yes" xml:space="preserve">
          <source>For crash safety, an AM can use postgres' &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt;, or a custom implementation. If WAL is chosen, either &lt;a href=&quot;generic-wal&quot;&gt;Generic WAL Records&lt;/a&gt; can be used, or a new type of WAL records can be implemented. Generic WAL Records are easy, but imply higher WAL volume. Implementation of a new type of WAL record currently requires modifications to core code (specifically, &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt;).</source>
          <target state="translated">충돌 안전을 위해 AM은 postgres의 &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt; 또는 사용자 정의 구현을 사용할 수 있습니다 . WAL을 선택하면 &lt;a href=&quot;generic-wal&quot;&gt;일반 WAL 레코드&lt;/a&gt; 를 사용하거나 새로운 유형의 WAL 레코드를 구현할 수 있습니다. 일반 WAL 레코드는 쉽지만 더 높은 WAL 볼륨을 의미합니다. 새로운 유형의 WAL 레코드를 구현하려면 현재 핵심 코드 (특히 &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt; )를 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c062e145de387371ec37dc656ac5b92503663ca" translate="yes" xml:space="preserve">
          <source>For databases, allows new schemas and publications to be created within the database.</source>
          <target state="translated">데이터베이스의 경우 데이터베이스 내에 새 스키마 및 게시를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4984c57688cb1cee66323a19c7444a0a9bb0477" translate="yes" xml:space="preserve">
          <source>For declarative partitioning, partitions must have exactly the same set of columns as the partitioned table, whereas with table inheritance, child tables may have extra columns not present in the parent.</source>
          <target state="translated">선언적 분할의 경우 분할 영역은 분할 된 테이블과 정확히 동일한 열 집합을 가져야하지만 테이블 상속을 사용하면 자식 테이블에 부모에 추가 열이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8cd79e49912cef7e36a49a72250f6cd15cb54e" translate="yes" xml:space="preserve">
          <source>For deployment testing, create a schema-only copy of the old cluster, insert dummy data, and upgrade that.</source>
          <target state="translated">배치 테스트를 위해 이전 클러스터의 스키마 전용 사본을 작성하고 더미 데이터를 삽입 한 후 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="23fcbc4c69f038c631978df5d852e7c988638319" translate="yes" xml:space="preserve">
          <source>For details about proper usage of these functions, see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;.</source>
          <target state="translated">이 기능의 올바른 사용법에 대한 자세한 내용은 &lt;a href=&quot;continuous-archiving&quot;&gt;25.3 절을&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="7a67dca85d30cbed66dc7cc81857442fa00d590c" translate="yes" xml:space="preserve">
          <source>For details on using &lt;code&gt;jsonpath&lt;/code&gt; expressions with SQL/JSON query functions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.15.2&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 쿼리 함수와 함께 &lt;code&gt;jsonpath&lt;/code&gt; 표현식 사용에 대한 자세한 내용 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;은 9.15.2 절을&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="aba8e3841c67fc994b221c5d39e6ca9666653d88" translate="yes" xml:space="preserve">
          <source>For developers familiar with XQuery and XPath 2.0 or later, XPath 1.0 presents a number of differences to contend with:</source>
          <target state="translated">XQuery 및 XPath 2.0 이상에 익숙한 개발자에게 XPath 1.0은 다음과 같은 여러 가지 차이점을 제시합니다.</target>
        </trans-unit>
        <trans-unit id="444e073c791a9db99f3d6ee4275247eb7942a2d4" translate="yes" xml:space="preserve">
          <source>For development and debugging purposes a few additional configuration parameters exist, as described in &lt;a href=&quot;runtime-config-developer&quot;&gt;Section 19.17&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-developer&quot;&gt;19.17 절&lt;/a&gt; 에서 설명한 것처럼 개발 및 디버깅 목적으로 몇 가지 추가 구성 매개 변수가 있습니다. .</target>
        </trans-unit>
        <trans-unit id="2f6d0f2ed640d213e669a2d88363956decb0dc50" translate="yes" xml:space="preserve">
          <source>For each child table, create an index on the key column(s), as well as any other indexes you might want.</source>
          <target state="translated">각 하위 테이블에 대해 키 열에 인덱스 및 원하는 다른 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="25abda91cdb6a3bbf8ff5bdcb98364248d703bc8" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the collation to use for the index, or zero if the column is not of a collatable data type.</source>
          <target state="translated">색인 키의 각 열 ( &lt;code&gt;indnkeyatts&lt;/code&gt; 값)에 대해 인덱스에 사용할 데이터 정렬의 OID가 포함되거나 열이 데이터 형식이 아닌 경우 0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc7ad5122e2bfa01daa15f6eed504af7d2b8967" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">인덱스 키의 각 열 ( &lt;code&gt;indnkeyatts&lt;/code&gt; 값)에 사용할 연산자 클래스의 OID가 포함됩니다. &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51f668b2a5a8c54bfcef88243c43a45aa5a55a09" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the collation to use for partitioning, or zero if the column is not of a collatable data type.</source>
          <target state="translated">파티션 키의 각 열에 대해 파티셔닝에 사용할 데이터 정렬의 OID가 포함되거나 열이 데이터 형식이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="3edc803302a59c643149e81e1e75d11544ede04f" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">파티션 키의 각 열마다 사용할 연산자 클래스의 OID가 포함됩니다. 자세한 내용은 &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ccb1aca150cd3fd2a76eea5ce2e2c6866c56ef1" translate="yes" xml:space="preserve">
          <source>For each column that will contain unique references to large objects, create a &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; trigger, and give the column name as the sole trigger argument. You can also restrict the trigger to only execute on updates to the column by using &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt;. If you need multiple &lt;code&gt;lo&lt;/code&gt; columns in the same table, create a separate trigger for each one, remembering to give a different name to each trigger on the same table.</source>
          <target state="translated">큰 개체에 대한 고유 한 참조를 포함 할 각 열에 대해 &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; 트리거를 만들고 열 이름을 유일한 트리거 인수로 지정하십시오. &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; 을 사용하여 트리거가 열 업데이트에서만 실행되도록 제한 할 수도 있습니다 . 동일한 테이블에 여러 &lt;code&gt;lo&lt;/code&gt; 열 이 필요한 경우 동일한 테이블의 각 트리거에 다른 이름을 지정하는 것을 기억하여 각각에 대해 별도의 트리거를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="dc93abd020281b000ae47dfd8ef843f236c6a3a8" translate="yes" xml:space="preserve">
          <source>For each combination of data types that a btree operator family provides comparison operators for, it must provide a comparison support function, registered in &lt;code&gt;pg_amproc&lt;/code&gt; with support function number 1 and &lt;code&gt;amproclefttype&lt;/code&gt;/&lt;code&gt;amprocrighttype&lt;/code&gt; equal to the left and right data types for the comparison (i.e., the same data types that the matching operators are registered with in &lt;code&gt;pg_amop&lt;/code&gt;). The comparison function must take two non-null values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and return an &lt;code&gt;int32&lt;/code&gt; value that is &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, or &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, respectively. A null result is disallowed: all values of the data type must be comparable. See &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; for examples.</source>
          <target state="translated">btree 연산자 제품군이 비교 연산자를 제공하는 각 데이터 유형 조합에 대해 지원 기능 번호 1 및 비교를위한 왼쪽 및 오른쪽 데이터 유형과 동일한 &lt;code&gt;amproclefttype&lt;/code&gt; / &lt;code&gt;amprocrighttype&lt;/code&gt; 과 함께 &lt;code&gt;pg_amproc&lt;/code&gt; 에 등록 된 비교 지원 기능을 제공해야합니다 (예 : 일치하는 연산자가 &lt;code&gt;pg_amop&lt;/code&gt; 에 등록 된 것과 동일한 데이터 유형 ). 비교 함수는 널이 아닌 두 개의 값 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 를 가져 와서 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 인 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;int32&lt;/code&gt; 값을 리턴해야합니다 . &lt;code&gt;A&lt;/code&gt; 인 . &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 각각. 널 (NULL) 결과는 허용되지 않습니다. 데이터 유형의 모든 값이 비교 가능해야합니다. 예는 &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816bbd53914791af08e63dd703c10a6ffd0c4825" translate="yes" xml:space="preserve">
          <source>For each database in the cluster there is a subdirectory within &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/base&lt;/code&gt;, named after the database's OID in &lt;code&gt;pg_database&lt;/code&gt;. This subdirectory is the default location for the database's files; in particular, its system catalogs are stored there.</source>
          <target state="translated">클러스터의 각 데이터베이스마다 &lt;code&gt;pg_database&lt;/code&gt; &lt;code&gt;/base&lt;/code&gt; 의 데이터베이스 OID 이름을 따서 명명 된 &lt;code&gt;PGDATA&lt;/code&gt; / base 내에 서브 디렉토리가 있습니다 . 이 서브 디렉토리는 데이터베이스 파일의 기본 위치입니다. 특히 해당 시스템 카탈로그가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5a93df004449e3d17d4da507b5cc8728f0ee8920" translate="yes" xml:space="preserve">
          <source>For each of these hypothetical-set aggregates, the list of direct arguments given in &lt;code&gt;args&lt;/code&gt; must match the number and types of the aggregated arguments given in &lt;code&gt;sorted_args&lt;/code&gt;. Unlike most built-in aggregates, these aggregates are not strict, that is they do not drop input rows containing nulls. Null values sort according to the rule specified in the &lt;code&gt;ORDER BY&lt;/code&gt; clause.</source>
          <target state="translated">이러한 가상 집합 집계 각각에 대해 &lt;code&gt;args&lt;/code&gt; 에 지정된 직접 인수 목록은 &lt;code&gt;sorted_args&lt;/code&gt; 에 제공된 집계 인수의 수와 유형과 일치해야합니다 . 대부분의 기본 제공 집계와 달리 이러한 집계는 엄격하지 않습니다. 즉, null을 포함하는 입력 행을 삭제하지 않습니다. 널값은 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 규칙에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cc9c8be16b2cd2bfdfefa12d9931dcf7459faa0" translate="yes" xml:space="preserve">
          <source>For each query, output performance statistics of the respective module to the server log. This is a crude profiling instrument, similar to the Unix &lt;code&gt;getrusage()&lt;/code&gt; operating system facility. &lt;code&gt;log_statement_stats&lt;/code&gt; reports total statement statistics, while the others report per-module statistics. &lt;code&gt;log_statement_stats&lt;/code&gt; cannot be enabled together with any of the per-module options. All of these options are disabled by default. Only superusers can change these settings.</source>
          <target state="translated">각 쿼리마다 해당 모듈의 성능 통계를 서버 로그에 출력합니다. 이것은 Unix &lt;code&gt;getrusage()&lt;/code&gt; 운영 체제 기능 과 유사한 조잡한 프로파일 링 도구 입니다. &lt;code&gt;log_statement_stats&lt;/code&gt; 는 전체 명령문 통계를보고하고 나머지는 모듈 별 통계를보고합니다. &lt;code&gt;log_statement_stats&lt;/code&gt; 는 모듈 별 옵션과 함께 사용할 수 없습니다. 이러한 옵션은 모두 기본적으로 비활성화되어 있습니다. 수퍼 유저 만 이러한 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ba598fc8c9be134161735a51a95dc2f9f525608" translate="yes" xml:space="preserve">
          <source>For each relation (table, view, materialized view, index, sequence, or foreign table) or composite type matching the &lt;code&gt;pattern&lt;/code&gt;, show all columns, their types, the tablespace (if not the default) and any special attributes such as &lt;code&gt;NOT NULL&lt;/code&gt; or defaults. Associated indexes, constraints, rules, and triggers are also shown. For foreign tables, the associated foreign server is shown as well. (&amp;ldquo;Matching the pattern&amp;rdquo; is defined in &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 각 관계 (테이블, 뷰, 구체화 된 뷰, 인덱스, 시퀀스 또는 외부 테이블) 또는 복합 유형에 대해 모든 열, 해당 유형, 테이블 스페이스 (기본값이 아닌 경우) 및 &lt;code&gt;NOT NULL&lt;/code&gt; 또는 기본값. 관련 인덱스, 제약 조건, 규칙 및 트리거도 표시됩니다. 외부 테이블의 경우 연관된 외부 서버도 표시됩니다. (&amp;ldquo;패턴 일치&amp;rdquo;는 아래 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴에&lt;/a&gt; 정의되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="77b4eaff32602e55630fc25f0d7615181a46a544" translate="yes" xml:space="preserve">
          <source>For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1.</source>
          <target state="translated">T1의 각 행 R1에 대해 결합 된 테이블에는 R1과의 결합 조건을 만족시키는 T2의 각 행에 대한 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8594ae1b752513c4090775efefd1243bce43044f" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt; are not updated on-the-fly, and so they usually contain somewhat out-of-date values. They are updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;. A &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; operation that does not scan the entire table (which is commonly the case) will incrementally update the &lt;code&gt;reltuples&lt;/code&gt; count on the basis of the part of the table it did scan, resulting in an approximate value. In any case, the planner will scale the values it finds in &lt;code&gt;pg_class&lt;/code&gt; to match the current physical table size, thus obtaining a closer approximation.</source>
          <target state="translated">효율성상의 이유로 &lt;code&gt;reltuples&lt;/code&gt; 와 &lt;code&gt;relpages&lt;/code&gt; 는 즉시 업데이트되지 않으므로 일반적으로 다소 오래된 값을 포함합니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 . &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;ANALYZE&lt;/code&gt; (경우에 통상적 인) 전체 테이블을 검색하지 않고 점진적으로 업데이트 할 동작 &lt;code&gt;reltuples&lt;/code&gt; 는 근사치의 결과는 스캔 한 테이블의 일부에 기초하여 계산. 어쨌든 플래너는 &lt;code&gt;pg_class&lt;/code&gt; 에서 찾은 값을 현재 실제 테이블 크기와 일치하도록 스케일링하여 더 가까운 근사값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2498c1aea650efa3ff6e721df8f862e425ed274a" translate="yes" xml:space="preserve">
          <source>For enum types (described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;Table 9.33&lt;/a&gt;. The examples assume an enum type created as:</source>
          <target state="translated">열거 형의 경우 ( &lt;a href=&quot;datatype-enum&quot;&gt;8.7 장&lt;/a&gt; 에서 설명 ), 열거 형의 특정 값을 하드 코딩하지 않고보다 깔끔한 프로그래밍을 가능하게하는 몇 가지 기능이 있습니다. 이것들은 &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;표 9.33에&lt;/a&gt; 나열되어 있습니다. 예제에서는 다음과 같이 열거 형 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a25a74babc64151f8b4ea2da440ad370951a8d59" translate="yes" xml:space="preserve">
          <source>For every possible combination of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (i.e., a Cartesian product), the joined table will contain a row consisting of all columns in &lt;code&gt;T1&lt;/code&gt; followed by all columns in &lt;code&gt;T2&lt;/code&gt;. If the tables have N and M rows respectively, the joined table will have N * M rows.</source>
          <target state="translated">행에서의 모든 가능한 조합에 대해 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; (즉, 데카르트 제품), 조인 테이블의 모든 열 이루어진 연속 포함 &lt;code&gt;T1&lt;/code&gt; 은 모든 열 뒤에 &lt;code&gt;T2&lt;/code&gt; . 테이블에 N 및 M 행이 각각있는 경우 결합 된 테이블에는 N * M 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6d96910fe12ae8175afb9cb9ebf00927346590" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant commands without requiring spaces between tokens.</source>
          <target state="translated">예를 들어 &lt;code&gt;@-&lt;/code&gt; 는 허용되는 연산자 이름이지만 &lt;code&gt;*-&lt;/code&gt; 는 아닙니다. 이 제한 사항으로 PostgreSQL은 토큰 사이에 공백없이 SQL 호환 명령을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7420785e3365d78ac1f9c68594d975825431286b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant queries without requiring spaces between tokens.</source>
          <target state="translated">예를 들어 &lt;code&gt;@-&lt;/code&gt; 는 허용되는 연산자 이름이지만 &lt;code&gt;*-&lt;/code&gt; 는 아닙니다. 이 제한 사항으로 PostgreSQL은 토큰 사이에 공백없이 SQL 호환 쿼리를 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1270acc7d371bd67bf727e789543eb2fb05a795a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;count(*)&lt;/code&gt; yields the total number of input rows; &lt;code&gt;count(f1)&lt;/code&gt; yields the number of input rows in which &lt;code&gt;f1&lt;/code&gt; is non-null, since &lt;code&gt;count&lt;/code&gt; ignores nulls; and &lt;code&gt;count(distinct f1)&lt;/code&gt; yields the number of distinct non-null values of &lt;code&gt;f1&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;count(*)&lt;/code&gt; 는 총 입력 행 수를 산출합니다. &lt;code&gt;count(f1)&lt;/code&gt; 된 입력 행수 산출 &lt;code&gt;f1&lt;/code&gt; 때문에, 비 - 널 &lt;code&gt;count&lt;/code&gt; 널이 무시; 그리고 &lt;code&gt;count(distinct f1)&lt;/code&gt; 의 별개의 비 - 널 값의 개수 산출 &lt;code&gt;f1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="241e368bd5f84d8bd9b37213abb0c1ce606628ca" translate="yes" xml:space="preserve">
          <source>For example, &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; might produce a set something like:</source>
          <target state="translated">예를 들어 &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 은 다음과 같은 집합을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="155faecb9306b9147a2e7777bee4e12a795c5623" translate="yes" xml:space="preserve">
          <source>For example, a common way to do case-insensitive comparisons is to use the &lt;code&gt;lower&lt;/code&gt; function:</source>
          <target state="translated">예를 들어 대소 문자를 구분하지 않는 비교를 수행하는 일반적인 방법은 &lt;code&gt;lower&lt;/code&gt; 함수 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5c31174366767191298875589e027e626f3481e" translate="yes" xml:space="preserve">
          <source>For example, an application workload might consist of: 10% of changes are important customer details, while 90% of changes are less important data that the business can more easily survive if it is lost, such as chat messages between users.</source>
          <target state="translated">예를 들어, 애플리케이션 워크로드는 다음과 같이 구성 될 수 있습니다. 10 %의 변경은 중요한 고객 세부 사항이며 90 %의 변경은 비즈니스 간의 손실 메시지 (예 : 사용자 간의 대화 메시지)와 같이 비즈니스에서 더 쉽게 생존 할 수있는 덜 중요한 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="130ff877846a9ba145c6084d6c6d927c9f6f130d" translate="yes" xml:space="preserve">
          <source>For example, consider a bank database that contains balances for various customer accounts, as well as total deposit balances for branches. Suppose that we want to record a payment of $100.00 from Alice's account to Bob's account. Simplifying outrageously, the SQL commands for this might look like:</source>
          <target state="translated">예를 들어, 다양한 고객 계정에 대한 잔액과 지점에 대한 총 예금 잔액이 포함 된 은행 데이터베이스를 고려하십시오. Alice의 계정에서 Bob의 계정으로 $ 100.00의 지불을 기록하려고한다고 가정하십시오. 터무니없이 단순화하기위한 SQL 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f3682a6f9ea0b208434ae010d3a1a17fff514e9" translate="yes" xml:space="preserve">
          <source>For example, consider the definition of a function, &lt;code&gt;dept&lt;/code&gt;, as:</source>
          <target state="translated">예를 들어, 함수 &lt;code&gt;dept&lt;/code&gt; 의 정의를 다음과 같이 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e0f997381e2092937165cc0bbee1c5517c59395" translate="yes" xml:space="preserve">
          <source>For example, consider this table definition:</source>
          <target state="translated">예를 들어,이 테이블 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c33bc524f5320aea55d00b964061ae906c69106d" translate="yes" xml:space="preserve">
          <source>For example, if for some reason you want to disable the GEQO optimizer for a given database, you'd ordinarily have to either disable it for all databases or make sure that every connecting client is careful to issue &lt;code&gt;SET geqo TO off&lt;/code&gt;. To make this setting the default within a particular database, you can execute the command:</source>
          <target state="translated">예를 들어, 어떤 이유로 특정 데이터베이스에 대해 GEQO 옵티 마이저를 사용하지 않으려면 일반적으로 모든 데이터베이스에 대해 GEQO 옵티 마이저를 사용 안함으로 설정하거나 모든 연결 클라이언트가 &lt;code&gt;SET geqo TO off&lt;/code&gt; 을 발행하도록주의를 기울여야합니다 . 이 설정을 특정 데이터베이스 내에서 기본값으로 설정하려면 다음 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3496b62777d29ce14330d5cf671f27e158b5c5b3" translate="yes" xml:space="preserve">
          <source>For example, in an &lt;code&gt;UPDATE&lt;/code&gt; command requiring both &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; permissions, if there are multiple applicable policies of each type, they will be combined as follows:</source>
          <target state="translated">예를 들어, &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이 모두 필요한 &lt;code&gt;UPDATE&lt;/code&gt; 명령 에서 각 유형에 적용 가능한 정책이 여러 개인 경우 다음과 같이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8f2f938fa83461064d386cea51bbcdc598d202" translate="yes" xml:space="preserve">
          <source>For example, suppose you have some JSON data from a GPS tracker that you would like to parse, such as:</source>
          <target state="translated">예를 들어 다음과 같이 구문 분석하려는 GPS 추적기의 JSON 데이터가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="06aef20d242f4af58541238d6758845220aef49a" translate="yes" xml:space="preserve">
          <source>For example, the following computes the square root of 2:</source>
          <target state="translated">예를 들어, 다음은 제곱근 2를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d06f05887749d75fd3c1c2ace4acae1fa3061b96" translate="yes" xml:space="preserve">
          <source>For example, the following finds the largest city population in each state:</source>
          <target state="translated">예를 들어 다음은 각 주에서 가장 큰 도시 인구를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="da6cc196eb1d7b4036c8cbb26afabb02667647d5" translate="yes" xml:space="preserve">
          <source>For example, the following is (syntactically) valid SQL input:</source>
          <target state="translated">예를 들어, 다음은 (구문 적으로) 유효한 SQL 입력입니다.</target>
        </trans-unit>
        <trans-unit id="471cd6e5da58fc5eff7b7a62ed009e72a5a73a36" translate="yes" xml:space="preserve">
          <source>For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">예를 들어 다음 쿼리는 주 수도를 포함하여 500 피트 이상의 고도에있는 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8766b8f0ef1ada9c82b69e07f58a59c6fe1e88b5" translate="yes" xml:space="preserve">
          <source>For example, the operating system might provide a locale named &lt;code&gt;de_DE.utf8&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; would then create a collation named &lt;code&gt;de_DE.utf8&lt;/code&gt; for encoding &lt;code&gt;UTF8&lt;/code&gt; that has both &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; set to &lt;code&gt;de_DE.utf8&lt;/code&gt;. It will also create a collation with the &lt;code&gt;.utf8&lt;/code&gt; tag stripped off the name. So you could also use the collation under the name &lt;code&gt;de_DE&lt;/code&gt;, which is less cumbersome to write and makes the name less encoding-dependent. Note that, nevertheless, the initial set of collation names is platform-dependent.</source>
          <target state="translated">예를 들어, 운영 체제는 &lt;code&gt;de_DE.utf8&lt;/code&gt; 로케일을 제공 할 수 있습니다 . 그러면 &lt;code&gt;initdb&lt;/code&gt; 는 &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이 모두 &lt;code&gt;de_DE.utf8&lt;/code&gt; 로 설정된 &lt;code&gt;UTF8&lt;/code&gt; 인코딩을 위해 &lt;code&gt;de_DE.utf8&lt;/code&gt; 이라는 데이터 정렬을 작성합니다 . 또한 이름 에서 &lt;code&gt;.utf8&lt;/code&gt; 태그가 제거 된 데이터 정렬을 만듭니다 . 따라서 &lt;code&gt;de_DE&lt;/code&gt; 라는 이름으로 데이터 정렬을 사용할 수도 있습니다. 이는 쓰기가 덜 번거롭고 이름이 인코딩 종속적이지 않습니다. 그럼에도 불구하고 초기 데이터 정렬 이름 집합은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3d1092481b703760dda3e1ee7578a2b981f6cc15" translate="yes" xml:space="preserve">
          <source>For example, the provided query might produce a set something like:</source>
          <target state="translated">예를 들어 제공된 쿼리는 다음과 같은 세트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52791448958e771d66ed4c02517edcf92f08b5b5" translate="yes" xml:space="preserve">
          <source>For example, this call requests 1000 values with a mean of 5 and a standard deviation of 3:</source>
          <target state="translated">예를 들어이 호출은 평균이 5이고 표준 편차가 3 인 1000 개의 값을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="2183a836f537bf498dab36fed767383696d0c956" translate="yes" xml:space="preserve">
          <source>For example, this command updates all products that have a price of 5 to have a price of 10:</source>
          <target state="translated">예를 들어,이 명령은 가격이 5 인 모든 제품을 가격이 10으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b9b7cfd87b1d0ccc58641762031f79d95fb10548" translate="yes" xml:space="preserve">
          <source>For example, to find the ten most frequent words in a document collection:</source>
          <target state="translated">예를 들어, 문서 모음에서 가장 빈번한 단어 10 개를 찾으려면</target>
        </trans-unit>
        <trans-unit id="e1319ad17250aad6d336666b42f8c3fc3dd702af" translate="yes" xml:space="preserve">
          <source>For example, we could create a domain over integers that accepts only positive integers:</source>
          <target state="translated">예를 들어 양의 정수만 허용하는 정수 이상의 도메인을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f07a23cd87e159d728d36de17c8370d8afa3c6" translate="yes" xml:space="preserve">
          <source>For example, when querying the GPS data listed above, you can abstract from the fact that it stores an array of segments when using the lax mode:</source>
          <target state="translated">예를 들어, 위에 나열된 GPS 데이터를 쿼리 할 때 lax 모드를 사용할 때 세그먼트 배열을 저장한다는 사실을 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d772c743b871fd1a2436437c4b730a2cfa282c" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/cube.sql&lt;/code&gt;.</source>
          <target state="translated">사용법의 예는 회귀 테스트 &lt;code&gt;sql/cube.sql&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fc3e3d4179a2417bcd2f2e1fa817b3ae7d39bff" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/seg.sql&lt;/code&gt;.</source>
          <target state="translated">사용법의 예는 회귀 테스트 &lt;code&gt;sql/seg.sql&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20343bba651c5588f7a79e82c05205aaef985eca" translate="yes" xml:space="preserve">
          <source>For foreign servers, allows creation of foreign tables using the server. Grantees may also create, alter, or drop their own user mappings associated with that server.</source>
          <target state="translated">외부 서버의 경우 서버를 사용하여 외부 테이블을 작성할 수 있습니다. 피부 여자는 해당 서버와 관련된 자신의 사용자 매핑을 생성, 변경 또는 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b32aab859f58749932d6c6be03c33f6bd3e7d6" translate="yes" xml:space="preserve">
          <source>For foreign-data wrappers, allows creation of new servers using the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 래퍼의 경우 외부 데이터 래퍼를 사용하여 새 서버를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db80d63b0cfce8e9c534eefc3bfa1133ade5f443" translate="yes" xml:space="preserve">
          <source>For functions built into PostgreSQL itself, the bitcode is installed into &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 자체에 내장 된 함수의 경우 비트 코드는 &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt; 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="76b109732d62dd01020a7a1cd75adf97d78489a2" translate="yes" xml:space="preserve">
          <source>For functions, &lt;code&gt;db_procedure:{execute}&lt;/code&gt; will be checked when user tries to execute a function as a part of query, or using fast-path invocation. If this function is a trusted procedure, it also checks &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; permission to check whether it can perform as entry point of trusted procedure.</source>
          <target state="translated">함수의 경우 사용자가 쿼리의 일부로 함수를 실행하거나 빠른 경로 호출을 사용 하면 &lt;code&gt;db_procedure:{execute}&lt;/code&gt; 가 점검됩니다. 이 함수가 신뢰할 수있는 프로 시저 인 경우 &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; 권한을 확인하여 신뢰할 수있는 프로 시저의 시작점으로 수행 할 수 있는지 여부를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="50f73f941e99db6aff704bfc76eaf9cb53fc581b" translate="yes" xml:space="preserve">
          <source>For further examples of scripts used for bulk editing, see &lt;code&gt;convert_oid2name.pl&lt;/code&gt; and &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; attached to this message: &lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&lt;/a&gt;</source>
          <target state="translated">대량 편집에 사용되는 스크립트의 추가 예는 다음 메시지에 첨부 된 &lt;code&gt;convert_oid2name.pl&lt;/code&gt; 및 &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; 을 참조하십시오 . &lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3Shfmail.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95d0a9533934206493197f921cdd921bcea9067d" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with sequences too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with sequences are equivalent to the forms shown above.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도 시퀀스와 함께 사용할 수 있습니다. 그러나 시퀀스에 허용되는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 유일한 변형은 위에 표시된 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="821eb91f933952c5c235fc4f1d7ebbeff4650e0a" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with views too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with views are equivalent to the ones shown above.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도 뷰와 함께 사용할 수 있습니다. 그러나 뷰에 허용되는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 유일한 변형은 위에 표시된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fd9d930dc3517bba2d1837bdddba003f94a1e402" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;inet_ops&lt;/code&gt; operator class is not the default class for types &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;. To use it, mention the class name in &lt;code&gt;CREATE INDEX&lt;/code&gt;, for example</source>
          <target state="translated">역사적 이유로 &lt;code&gt;inet_ops&lt;/code&gt; 연산자 클래스는 &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;cidr&lt;/code&gt; 유형의 기본 클래스가 아닙니다 . 그것을 사용하려면에서 클래스 이름 언급 &lt;code&gt;CREATE INDEX&lt;/code&gt; 예를 들어,</target>
        </trans-unit>
        <trans-unit id="c4d4c412fef208bbedad98fd29f400c744b1038b" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;penalty&lt;/code&gt; function doesn't just return a &lt;code&gt;float&lt;/code&gt; result; instead it has to store the value at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;penalty&lt;/code&gt; 함수는 &lt;code&gt;float&lt;/code&gt; 결과 만 반환하지 않습니다 . 대신 세 번째 인수로 표시된 위치에 값을 저장해야합니다. 반환 값 자체는 무시되지만 해당 인수의 주소를 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="602a56377f9c453998804c9239a3f0e16670f12d" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;same&lt;/code&gt; function doesn't just return a Boolean result; instead it has to store the flag at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;same&lt;/code&gt; 함수는 부울 결과 만 반환하지 않습니다. 대신 세 번째 인수로 표시된 위치에 플래그를 저장해야합니다. 반환 값 자체는 무시되지만 해당 인수의 주소를 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="edf5a6774e8ddac6655d000c335cd8365c752c22" translate="yes" xml:space="preserve">
          <source>For identity columns, the &lt;code&gt;COPY FROM&lt;/code&gt; command will always write the column values provided in the input data, like the &lt;code&gt;INSERT&lt;/code&gt; option &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;.</source>
          <target state="translated">식별 컬럼의 경우 &lt;code&gt;COPY FROM&lt;/code&gt; 명령은 항상 &lt;code&gt;INSERT&lt;/code&gt; 옵션 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 와 같이 입력 데이터에 제공된 컬럼 값을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="330e059840df0474749e60d131c132790cef269d" translate="yes" xml:space="preserve">
          <source>For index methods that support ordered scans (currently, only B-tree), the optional clauses &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; can be specified to modify the sort ordering of the index. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single-column &lt;code&gt;DESC&lt;/code&gt; index &amp;mdash; that sort ordering is already available with a regular index. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed-ordering query, such as &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt;. The &lt;code&gt;NULLS&lt;/code&gt; options are useful if you need to support &amp;ldquo;nulls sort low&amp;rdquo; behavior, rather than the default &amp;ldquo;nulls sort high&amp;rdquo;, in queries that depend on indexes to avoid sorting steps.</source>
          <target state="translated">정렬 된 스캔 (현재 B- 트리 만)을 지원하는 인덱스 메소드의 경우 인덱스 의 정렬 순서를 수정하기 위해 선택적 절 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 및 / 또는 &lt;code&gt;NULLS LAST&lt;/code&gt; 를 지정할 수 있습니다. 정렬 된 인덱스는 정방향 또는 역방향으로 스캔 할 수 있으므로 단일 컬럼 &lt;code&gt;DESC&lt;/code&gt; 인덱스 를 작성하는 것은 일반적으로 유용하지 않습니다. 정렬 순서는 이미 일반 인덱스에서 사용 가능합니다. 이 옵션의 값은 &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt; 와 같이 혼합 순서 쿼리에서 요청한 정렬 순서와 일치하는 다중 열 인덱스를 만들 수 있다는 것입니다 . &lt;code&gt;NULLS&lt;/code&gt; 정렬 단계를 피하기 위해 인덱스에 의존하는 쿼리에서 기본 &quot;nulls sort high&quot;대신 &quot;nulls sort low&quot;동작을 지원해야하는 경우 옵션이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b918ccfc93956e12afed439ea7d7ee85b4aa64b" translate="yes" xml:space="preserve">
          <source>For indexes, what is tracked is entirely-unused pages, rather than free space within pages. Therefore, the values are not meaningful, just whether a page is full or empty.</source>
          <target state="translated">색인의 경우, 추적되는 것은 페이지 내의 여유 공간이 아니라 완전히 사용되지 않은 페이지입니다. 따라서 값이 페이지가 가득 찼거나 비어 있는지 여부는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4513c5edb4e83b5f0af5e4602920aeca55f3099c" translate="yes" xml:space="preserve">
          <source>For information about writing new extensions, see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="translated">새로운 확장 기능 작성에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;섹션 37.17을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac175c388fdbc502fc95fbb47ec000df9ac1c1ac" translate="yes" xml:space="preserve">
          <source>For instance, the example given in the previous section would also work as</source>
          <target state="translated">예를 들어, 이전 섹션에 제공된 예제는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa594066fb4185dd4bf2bb314c6dc858ea1dc91b" translate="yes" xml:space="preserve">
          <source>For large tables, &lt;code&gt;ANALYZE&lt;/code&gt; takes a random sample of the table contents, rather than examining every row. This allows even very large tables to be analyzed in a small amount of time. Note, however, that the statistics are only approximate, and will change slightly each time &lt;code&gt;ANALYZE&lt;/code&gt; is run, even if the actual table contents did not change. This might result in small changes in the planner's estimated costs shown by &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;. In rare situations, this non-determinism will cause the planner's choices of query plans to change after &lt;code&gt;ANALYZE&lt;/code&gt; is run. To avoid this, raise the amount of statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;, as described below.</source>
          <target state="translated">큰 테이블의 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 는 모든 행을 검사하지 않고 테이블 내용의 임의 샘플을 가져옵니다. 이를 통해 아주 큰 테이블도 적은 시간에 분석 할 수 있습니다. 그러나 통계는 대략적인 것이므로 실제 테이블 내용이 변경되지 않은 경우에도 &lt;code&gt;ANALYZE&lt;/code&gt; 가 실행될 때마다 약간 변경됩니다. 이로 인해 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN으로&lt;/a&gt; 표시되는 플래너의 예상 비용이 약간 변경 될 수 있습니다 . 드문 경우이지만이 비결 정성으로 인해 &lt;code&gt;ANALYZE&lt;/code&gt; 가 실행 된 후 플래너의 쿼리 계획 선택이 변경 됩니다. 이를 피하려면 아래 설명과 같이 &lt;code&gt;ANALYZE&lt;/code&gt; 가 수집 한 통계량을 늘리 십시오.</target>
        </trans-unit>
        <trans-unit id="d9def7e76f8e004e7c6ff9a43935027a0e8494d2" translate="yes" xml:space="preserve">
          <source>For magnetic drives, a good starting point for this setting is the number of separate drives comprising a RAID 0 stripe or RAID 1 mirror being used for the database. (For RAID 5 the parity drive should not be counted.) However, if the database is often busy with multiple queries issued in concurrent sessions, lower values may be sufficient to keep the disk array busy. A value higher than needed to keep the disks busy will only result in extra CPU overhead. SSDs and other memory-based storage can often process many concurrent requests, so the best value might be in the hundreds.</source>
          <target state="translated">마그네틱 드라이브의 경우이 설정의 좋은 출발점은 데이터베이스에 사용되는 RAID 0 스트라이프 또는 RAID 1 미러를 포함하는 개별 드라이브의 수입니다. (RAID 5의 경우 패리티 드라이브는 계산되지 않아야합니다.) 그러나 데이터베이스가 종종 동시 세션에서 여러 쿼리를 발행하여 사용중인 경우, 디스크 어레이를 사용 중으로 유지하기 위해 더 낮은 값으로 충분할 수 있습니다. 디스크를 사용 중 상태로 유지하는 데 필요한 값보다 높은 값은 추가 CPU 오버 헤드 만 발생합니다. SSD 및 기타 메모리 기반 스토리지는 종종 많은 동시 요청을 처리 할 수 ​​있으므로 최상의 가치는 수백 개에 달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0641cab9eeea26c49a646ff42537d081fed018" translate="yes" xml:space="preserve">
          <source>For more detail see &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. Row constructors can also be used in connection with subqueries, as discussed in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;functions-comparisons&quot;&gt;은 9.23 절을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;functions-subquery&quot;&gt;9.22 절&lt;/a&gt; 에서 논의 된 것처럼 행 생성자는 서브 쿼리와 관련하여 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb8d2224d716120397e37c095ccc4fc811af648" translate="yes" xml:space="preserve">
          <source>For more details see &lt;code&gt;man gpg&lt;/code&gt;, &lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;The GNU Privacy Handbook&lt;/a&gt; and other documentation on &lt;a href=&quot;https://www.gnupg.org/&quot;&gt;https://www.gnupg.org/&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;man gpg&lt;/code&gt; , &lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;GNU Privacy Handbook&lt;/a&gt; 및 &lt;a href=&quot;https://www.gnupg.org/&quot;&gt;https://www.gnupg.org/의&lt;/a&gt; 기타 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c6217eaee5aceb86ffc3acacd99e4351f7c6bdf" translate="yes" xml:space="preserve">
          <source>For more examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;.</source>
          <target state="translated">경로 표현식 내에서 &lt;code&gt;jsonpath&lt;/code&gt; 연산자 및 메소드 를 사용하는 예는 9.15.2.3 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79cf6e3cf917058a0ed742c04d1ca6289aff5a38" translate="yes" xml:space="preserve">
          <source>For more information on each row-level lock mode, refer to &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;Section 13.3.2&lt;/a&gt;.</source>
          <target state="translated">각 행 수준 잠금 모드에 대한 자세한 내용 &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;은 13.3.2 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2f8f8e747ece8758e1b6ba702e3c8c61e76fde3" translate="yes" xml:space="preserve">
          <source>For more information on parallel query, see &lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;Chapter 15&lt;/a&gt;.</source>
          <target state="translated">병렬 쿼리에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;15 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e9f192fbf0623739197082afd424ce16d42f59b" translate="yes" xml:space="preserve">
          <source>For more information on prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d65fb0f770cbb9d7773305feb7d0f9aff8503a9d" translate="yes" xml:space="preserve">
          <source>For more information on query planning and the statistics collected by PostgreSQL for that purpose, see the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; documentation.</source>
          <target state="translated">이러한 목적으로 PostgreSQL에서 수집 한 통계 및 쿼리 계획에 대한 자세한 내용은 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b483319bfce6914eeb2d77590a6f05860cc2822" translate="yes" xml:space="preserve">
          <source>For more information on row security policies, see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">행 보안 정책에 대한 자세한 정보는 &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cd57e75dd7c6d9a0bba32ec8cf0aedac82282ff" translate="yes" xml:space="preserve">
          <source>For more information on schema handling, see &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;. In particular, the default configuration is suitable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">스키마 처리에 대한 자세한 내용은 &lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9를&lt;/a&gt; 참조하십시오 . 특히, 기본 구성은 데이터베이스에 단일 사용자 또는 소수의 상호 신뢰 사용자가있는 경우에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="7a7cfc539431d71689ab3e6fc5a89a4a3ad68497" translate="yes" xml:space="preserve">
          <source>For more information on tablespaces, see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">테이블 스페이스에 대한 자세한 정보는 &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;22.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="156d896fc36c27213e33f6486192aeb35b072ae4" translate="yes" xml:space="preserve">
          <source>For more information on the creation and usage of prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문의 작성 및 사용법에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5233548445314b3aa1fa8672502b639b8263c6c7" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;sql-values&quot;&gt;VALUES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c85bc4c828173ae286d66f5092152fb72a510a4c" translate="yes" xml:space="preserve">
          <source>For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</source>
          <target state="translated">복제 슬롯에 대한 자세한 내용 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;은 26.2.6 절&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f67c610531547fa3cca67f0d1f83f00712e9e930" translate="yes" xml:space="preserve">
          <source>For most English-text-searching applications the above words would be considered non-normalized, but &lt;code&gt;tsvector&lt;/code&gt; doesn't care. Raw document text should usually be passed through &lt;code&gt;to_tsvector&lt;/code&gt; to normalize the words appropriately for searching:</source>
          <target state="translated">대부분의 영어 텍스트 검색 응용 프로그램에서 위의 단어는 정규화되지 않은 것으로 간주되지만 &lt;code&gt;tsvector&lt;/code&gt; 는 신경 쓰지 않습니다. 원시 문서 텍스트는 일반적으로 &lt;code&gt;to_tsvector&lt;/code&gt; 를 통해 검색 하기에 적합하게 단어를 정규화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d11cb8ba24b12fd4341f66b81cfe8da1a67ba46b" translate="yes" xml:space="preserve">
          <source>For most index methods, the speed of creating an index is dependent on the setting of &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;. Larger values will reduce the time needed for index creation, so long as you don't make it larger than the amount of memory really available, which would drive the machine into swapping.</source>
          <target state="translated">대부분의 색인 메소드의 경우 색인 작성 속도는 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 설정에 따라 다릅니다 . 값이 클수록 실제로 사용 가능한 메모리 양보다 크게 만들지 않는 한 인덱스 생성에 필요한 시간이 줄어들어 시스템이 스와핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0c13a44404e4e32e101f6de95dbe745d7a8d8623" translate="yes" xml:space="preserve">
          <source>For most kinds of object, only the object's owner can set the comment. Roles don't have owners, so the rule for &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; is that you must be superuser to comment on a superuser role, or have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege to comment on non-superuser roles. Likewise, access methods don't have owners either; you must be superuser to comment on an access method. Of course, a superuser can comment on anything.</source>
          <target state="translated">대부분의 개체 유형의 경우 개체 소유자 만 설명을 설정할 수 있습니다. 역할에는 소유자가 없으므로 &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; 의 규칙은 수퍼 유저 여야 슈퍼 유저 역할 에 댓글을 달거나 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한 이 있어야 비 수퍼 유저 역할에 댓글을 달 수 있습니다. 마찬가지로 액세스 방법에도 소유자가 없습니다. 액세스 방법에 대해 언급하려면 수퍼 유저 여야합니다. 물론 수퍼 유저는 무엇이든 언급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9837f0c6ad7a5aa6e60539d85268c2d3ed2d116e" translate="yes" xml:space="preserve">
          <source>For new relations being written during a DDL operation that requires a table rewrite, this contains the OID of the original relation; otherwise 0. That state is only visible internally; this field should never contain anything other than 0 for a user-visible relation.</source>
          <target state="translated">테이블 재 작성이 필요한 DDL 조작 중에 작성되는 새 관계의 경우 원래 관계의 OID가 포함됩니다. 그렇지 않으면 0입니다. 해당 상태는 내부적으로 만 볼 수 있습니다. 이 필드는 사용자가 볼 수있는 관계에 대해 0 이외의 다른 것을 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="db2d4f573696790d499c4fdcbed43171e9eb9774" translate="yes" xml:space="preserve">
          <source>For non-anonymous binds, &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt; must be specified as separate options.</source>
          <target state="translated">익명이 아닌 바인드의 경우 &lt;code&gt;ldapbinddn&lt;/code&gt; 및 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 를 별도의 옵션으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e8b858bd4de863389670e9fe6770c7877741b6a" translate="yes" xml:space="preserve">
          <source>For non-null inputs, &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; is the same as the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. However, if both inputs are null it returns false, and if only one input is null it returns true. Similarly, &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; is identical to &lt;code&gt;=&lt;/code&gt; for non-null inputs, but it returns true when both inputs are null, and false when only one input is null. Thus, these predicates effectively act as though null were a normal data value, rather than &amp;ldquo;unknown&amp;rdquo;.</source>
          <target state="translated">널이 아닌 입력의 경우 &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; 은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 와 동일합니다 . 그러나 두 입력이 모두 null이면 false를 반환하고 하나의 입력 만 null이면 true를 반환합니다. 마찬가지로 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 은 널이 아닌 입력의 경우 &lt;code&gt;=&lt;/code&gt; 와 동일 하지만 두 입력이 모두 널이면 true를, 하나의 입력 만 널이면 false를 리턴합니다. 따라서 이러한 술어는 널이 &quot;알 수 없음&quot;이 아닌 정상적인 데이터 값인 것처럼 효과적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="452c316e78163cb01fa71da21305864e3d992733" translate="yes" xml:space="preserve">
          <source>For noninternal languages this references the language handler, which is a special function that is responsible for executing all functions that are written in the particular language</source>
          <target state="translated">내부 언어가 아닌 언어의 경우 특정 언어로 작성된 모든 함수를 실행하는 특수 함수 인 언어 핸들러를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="08f7ad6afcfac3234695bfac00c247d3c8fb6960" translate="yes" xml:space="preserve">
          <source>For operator classes that do not use prefixes, &lt;code&gt;prefixType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. Likewise, for operator classes that do not use node labels, &lt;code&gt;labelType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. &lt;code&gt;canReturnData&lt;/code&gt; should be set true if the operator class is capable of reconstructing the originally-supplied index value. &lt;code&gt;longValuesOK&lt;/code&gt; should be set true only when the &lt;code&gt;attType&lt;/code&gt; is of variable length and the operator class is capable of segmenting long values by repeated suffixing (see &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;Section 65.4.1&lt;/a&gt;).</source>
          <target state="translated">접두사를 사용하지 않는 연산자 클래스의 경우 &lt;code&gt;prefixType&lt;/code&gt; 을 &lt;code&gt;VOIDOID&lt;/code&gt; 로 설정할 수 있습니다 . 마찬가지로 노드 레이블을 사용하지 않는 연산자 클래스의 경우 &lt;code&gt;labelType&lt;/code&gt; 을 &lt;code&gt;VOIDOID&lt;/code&gt; 로 설정할 수 있습니다 . 연산자 클래스가 원래 제공된 색인 값을 재구성 할 수있는 경우 &lt;code&gt;canReturnData&lt;/code&gt; 를 true로 설정해야합니다. &lt;code&gt;longValuesOK&lt;/code&gt; 는 &lt;code&gt;attType&lt;/code&gt; 이 가변 길이이고 연산자 클래스가 접미사를 반복하여 긴 값을 세그먼트 화할 수있는 경우에만 true로 설정해야합니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;65.4.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8734e694c951a6833bd37344ff08949a24e29e7a" translate="yes" xml:space="preserve">
          <source>For optimal performance when relying on Serializable transactions for concurrency control, these issues should be considered:</source>
          <target state="translated">동시성 제어를 위해 직렬화 가능 트랜잭션에 의존 할 때 최적의 성능을 얻으려면 다음 문제를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="6009f4ee46750a96d20ce23527cf9e0e8cb726de" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments.</source>
          <target state="translated">순서 집합 (가설 집합 포함) 집계의 경우 최종 함수는 최종 상태 값뿐만 아니라 모든 직접 인수의 값도받습니다.</target>
        </trans-unit>
        <trans-unit id="be6a9c4c63ed11fa1c2795f316b3b8e9e65b1b58" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the state transition function receives only the current state value and the aggregated arguments, not the direct arguments. Otherwise it is the same.</source>
          <target state="translated">순서 집합 (가설 집합 포함) 집계의 경우 상태 전이 함수는 직접 인수가 아닌 현재 상태 값과 집계 된 인수 만받습니다. 그렇지 않으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6c0d59e1cc0d04f93b79c02798466c5f3e582923" translate="yes" xml:space="preserve">
          <source>For ordered-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) arguments. The &lt;code&gt;HYPOTHETICAL&lt;/code&gt; flag has no effect on run-time behavior, only on parse-time resolution of the data types and collations of the aggregate's arguments.</source>
          <target state="translated">순서 집합 집합의 경우에만이 플래그는 집합 인수가 가정 집합 집합의 요구 사항에 따라 처리되도록 지정합니다. 즉, 마지막 몇 개의 직접 인수는 집합의 데이터 형식과 일치해야합니다 ( &lt;code&gt;WITHIN GROUP&lt;/code&gt; ) 인수 . &lt;code&gt;HYPOTHETICAL&lt;/code&gt; 플래그는 데이터 유형 및 집계의 인수의 정렬의 구문 분석 시간 해상도에 런타임 동작에 아무런 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b1b26b35f07e3a875d44019b004753915b48df" translate="yes" xml:space="preserve">
          <source>For pages that cannot be skipped, it scans each tuple, recording its presence and size in the appropriate counters, and adding up the free space on the page. At the end, it estimates the total number of live tuples based on the number of pages and tuples scanned (in the same way that VACUUM estimates pg_class.reltuples).</source>
          <target state="translated">건너 뛸 수없는 페이지의 경우 각 튜플을 스캔하여 해당 카운터의 존재 여부와 크기를 적절한 카운터에 기록하고 페이지에 여유 공간을 추가합니다. 결국, VACUUM이 pg_class.reltuples를 추정하는 것과 같은 방식으로 스캔 된 페이지 및 튜플의 수를 기반으로 총 라이브 튜플 수를 추정합니다.</target>
        </trans-unit>
        <trans-unit id="868352f139d86028da2fe3079d740960bf5a0c0a" translate="yes" xml:space="preserve">
          <source>For parameter defaults, the SQL standard specifies only the syntax with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. The syntax with &lt;code&gt;=&lt;/code&gt; is used in T-SQL and Firebird.</source>
          <target state="translated">매개 변수 기본값의 경우 SQL 표준은 &lt;code&gt;DEFAULT&lt;/code&gt; 키워드를 사용 하는 구문 만 지정합니다 . 문법 &lt;code&gt;=&lt;/code&gt; 가 포함 은 T-SQL 및 Firebird에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d24bbed3cf952c936ab011c509488bf0467fa622" translate="yes" xml:space="preserve">
          <source>For policies that can have both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; expressions (&lt;code&gt;ALL&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt;), if no &lt;code&gt;WITH CHECK&lt;/code&gt; expression is defined, then the &lt;code&gt;USING&lt;/code&gt; expression will be used both to determine which rows are visible (normal &lt;code&gt;USING&lt;/code&gt; case) and which new rows will be allowed to be added (&lt;code&gt;WITH CHECK&lt;/code&gt; case).</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 및 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식 ( &lt;code&gt;ALL&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; ) 을 모두 가질 수있는 정책의 경우 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식이 정의 되지 않은 경우 &lt;code&gt;USING&lt;/code&gt; 표현식을 사용하여 볼 수있는 행 (일반적인 &lt;code&gt;USING&lt;/code&gt; 경우)과 새 행을 결정합니다. 추가 가능 ( &lt;code&gt;WITH CHECK&lt;/code&gt; case).</target>
        </trans-unit>
        <trans-unit id="82d5e1c9db6a18c117c8031e2597235ae83ea517" translate="yes" xml:space="preserve">
          <source>For procedural languages, allows use of the language for the creation of functions in that language. This is the only type of privilege that is applicable to procedural languages.</source>
          <target state="translated">절차 적 언어의 경우 해당 언어로 함수를 작성하기 위해 언어를 사용할 수 있습니다. 이것은 절차 언어에 적용 할 수있는 유일한 권한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="72ae8edf284efd5793c4ac2e8558efa80968a775" translate="yes" xml:space="preserve">
          <source>For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output column name.</source>
          <target state="translated">향후 키워드 추가 가능성을 방지하려면 항상 다음 중 하나를 작성하는 것이 좋습니다. &lt;code&gt;AS&lt;/code&gt; 출력 열 이름을 AS로 쓰거나 큰 따옴표로 묶는 .</target>
        </trans-unit>
        <trans-unit id="90dfd308078c52df87fcfcab656bb11ad21b3919" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the commas between successive &lt;code&gt;transaction_modes&lt;/code&gt; can be omitted.</source>
          <target state="translated">이전 버전과의 호환성을 위해 연속적인 &lt;code&gt;transaction_modes&lt;/code&gt; 사이의 쉼표 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee31746206f7099bf155b9a7de2ea519f45916ff" translate="yes" xml:space="preserve">
          <source>For reference purposes, a standard installation also contains files &lt;code&gt;Africa.txt&lt;/code&gt;, &lt;code&gt;America.txt&lt;/code&gt;, etc, containing information about every time zone abbreviation known to be in use according to the IANA timezone database. The zone name definitions found in these files can be copied and pasted into a custom configuration file as needed. Note that these files cannot be directly referenced as &lt;code&gt;timezone_abbreviations&lt;/code&gt; settings, because of the dot embedded in their names.</source>
          <target state="translated">참조 목적으로 표준 설치에는 IANA 시간대 데이터베이스에 따라 사용중인 것으로 알려진 모든 시간대 약어에 대한 정보가 들어있는 &lt;code&gt;Africa.txt&lt;/code&gt; , &lt;code&gt;America.txt&lt;/code&gt; 등의 파일도 포함되어 있습니다 . 이러한 파일에서 찾은 영역 이름 정의는 필요에 따라 사용자 정의 구성 파일에 복사하여 붙여 넣을 수 있습니다. 이러한 파일은 이름에 포함 된 점 때문에 &lt;code&gt;timezone_abbreviations&lt;/code&gt; 설정 으로 직접 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="124811ada3de0016b7583028ff8e0587746fbc22" translate="yes" xml:space="preserve">
          <source>For reliable recovery when changing &lt;code&gt;fsync&lt;/code&gt; off to on, it is necessary to force all modified buffers in the kernel to durable storage. This can be done while the cluster is shutdown or while &lt;code&gt;fsync&lt;/code&gt; is on by running &lt;code&gt;initdb --sync-only&lt;/code&gt;, running &lt;code&gt;sync&lt;/code&gt;, unmounting the file system, or rebooting the server.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 on으로 변경할 때 안정적인 복구를 위해서는 커널에서 수정 된 모든 버퍼를 영구 저장소로 강제 실행해야합니다. &lt;code&gt;initdb --sync-only&lt;/code&gt; 를 실행 하여 클러스터가 종료되거나 &lt;code&gt;fsync&lt;/code&gt; 가 켜져있는 동안 수행 할 수 있습니다. &lt;code&gt;sync&lt;/code&gt; , 파일 시스템을 마운트 해제하거나 서버를 다시 부팅.</target>
        </trans-unit>
        <trans-unit id="319e6f276af3394d5ebbac353d76e4013f542a01" translate="yes" xml:space="preserve">
          <source>For roles that can log in, this sets maximum number of concurrent connections this role can make. -1 means no limit.</source>
          <target state="translated">로그인 할 수있는 역할의 경우이 역할로 만들 수있는 최대 동시 연결 수를 설정합니다. -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a4172c7b4024e73e796b850c139c38ecd17203c" translate="yes" xml:space="preserve">
          <source>For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g. by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</source>
          <target state="translated">스키마의 경우 스키마에 포함 된 개체에 대한 액세스를 허용합니다 (개체 자신의 권한 요구 사항도 충족한다고 가정). 기본적으로이를 통해 피부 여자는 스키마 내에서 개체를 &quot;찾을&quot;수 있습니다. 이 권한이 없으면 시스템 카탈로그 조회와 같은 오브젝트 이름을 여전히 볼 수 있습니다. 또한이 권한을 취소 한 후 기존 세션에 이전에이 조회를 수행 한 명령문이있을 수 있으므로 이는 오브젝트 액세스를 막는 완전히 안전한 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ca22692db97a2637a8e751de3cc8e36b4187aab7" translate="yes" xml:space="preserve">
          <source>For schemas, allows new objects to be created within the schema. To rename an existing object, you must own the object &lt;em&gt;and&lt;/em&gt; have this privilege for the containing schema.</source>
          <target state="translated">스키마의 경우 스키마 내에서 새 객체를 만들 수 있습니다. 기존 객체의 이름을 바꾸려면 객체를 소유 &lt;em&gt;하고&lt;/em&gt; 포함하는 스키마이 권한을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="77c0cf444f37221ad1fe5a6fc24e9c33e4046529" translate="yes" xml:space="preserve">
          <source>For searches within PostgreSQL, a document is normally a textual field within a row of a database table, or possibly a combination (concatenation) of such fields, perhaps stored in several tables or obtained dynamically. In other words, a document can be constructed from different parts for indexing and it might not be stored anywhere as a whole. For example:</source>
          <target state="translated">PostgreSQL 내에서 검색하는 경우, 문서는 일반적으로 데이터베이스 테이블의 행 내의 텍스트 필드이거나 여러 필드에 저장되거나 동적으로 얻을 수있는 이러한 필드의 조합 (연결)입니다. 즉, 문서는 색인을 생성하기 위해 여러 부분으로 구성 될 수 있으며 전체적으로 저장되지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a142a9753e3ece701e9f2b90c2d239cb6b9b44cd" translate="yes" xml:space="preserve">
          <source>For security reasons the new cluster created by &lt;code&gt;initdb&lt;/code&gt; will only be accessible by the cluster owner by default. The &lt;code&gt;--allow-group-access&lt;/code&gt; option allows any user in the same group as the cluster owner to read files in the cluster. This is useful for performing backups as a non-privileged user.</source>
          <target state="translated">보안상의 이유로 &lt;code&gt;initdb&lt;/code&gt; 에 의해 생성 된 새 클러스터 는 기본적으로 클러스터 소유자 만 액세스 할 수 있습니다. &lt;code&gt;--allow-group-access&lt;/code&gt; 옵션은 클러스터 소유자와 동일한 그룹의 모든 사용자가 클러스터에 파일을 읽을 수 있습니다. 권한이없는 사용자로 백업을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f1663e5a58c2af0c67ac06b0e2e7c597b770b66" translate="yes" xml:space="preserve">
          <source>For security reasons, only superusers and members of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role are allowed to see the SQL text and &lt;code&gt;queryid&lt;/code&gt; of queries executed by other users. Other users can see the statistics, however, if the view has been installed in their database.</source>
          <target state="translated">보안상의 이유로 수퍼 유저와 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 역할의 구성원 만 다른 사용자가 실행 한 쿼리 의 SQL 텍스트 및 &lt;code&gt;queryid&lt;/code&gt; 를 볼 수 있습니다. 그러나 뷰가 데이터베이스에 설치된 경우 다른 사용자는 통계를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2387fb268a4aad1cb27f4814253a95ea4053932" translate="yes" xml:space="preserve">
          <source>For sequences, &lt;code&gt;db_sequence:get_value&lt;/code&gt; is checked when we reference a sequence object using &lt;code&gt;SELECT&lt;/code&gt;; however, note that we do not currently check permissions on execution of corresponding functions such as &lt;code&gt;lastval()&lt;/code&gt;.</source>
          <target state="translated">시퀀스의 경우, &lt;code&gt;SELECT&lt;/code&gt; 를 사용하여 시퀀스 객체를 참조 할 때 &lt;code&gt;db_sequence:get_value&lt;/code&gt; 가 검사됩니다 . 그러나 현재 &lt;code&gt;lastval()&lt;/code&gt; 과 같은 해당 함수의 실행에 대한 권한은 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a6107c5c35722f41cd50e68f08c51a50459956c5" translate="yes" xml:space="preserve">
          <source>For sequences, allows use of the &lt;code&gt;currval&lt;/code&gt; and &lt;code&gt;nextval&lt;/code&gt; functions.</source>
          <target state="translated">시퀀스의 경우 &lt;code&gt;currval&lt;/code&gt; 및 &lt;code&gt;nextval&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41c9e0790209171bd641f0e2a59f5f0172d7ebb1" translate="yes" xml:space="preserve">
          <source>For servers that are not regularly connected or have slow communication links, like laptops or remote servers, keeping data consistent among servers is a challenge. Using asynchronous multimaster replication, each server works independently, and periodically communicates with the other servers to identify conflicting transactions. The conflicts can be resolved by users or conflict resolution rules. Bucardo is an example of this type of replication.</source>
          <target state="translated">정기적으로 연결되지 않거나 랩톱 또는 원격 서버와 같이 통신 연결 속도가 느린 서버의 경우 서버간에 데이터를 일관성있게 유지하는 것은 어려운 일입니다. 비동기 멀티 마스터 복제를 사용하면 각 서버가 독립적으로 작동하고 주기적으로 다른 서버와 통신하여 충돌하는 트랜잭션을 식별합니다. 사용자 또는 충돌 해결 규칙으로 충돌을 해결할 수 있습니다. Bucardo는 이러한 유형의 복제의 예입니다.</target>
        </trans-unit>
        <trans-unit id="62b0a1b5925a4635226ab51bcd1ee55bb85746c9" translate="yes" xml:space="preserve">
          <source>For simple &lt;code&gt;IN&lt;/code&gt; tests, it's better to rely on the &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;list-of-scalars&lt;/a&gt; form of &lt;code&gt;IN&lt;/code&gt; than to write a &lt;code&gt;VALUES&lt;/code&gt; query as shown above. The list of scalars method requires less writing and is often more efficient.</source>
          <target state="translated">간단한 &lt;code&gt;IN&lt;/code&gt; 테스트의 경우 위와 같이 &lt;code&gt;VALUES&lt;/code&gt; 쿼리 를 작성하는 것보다 &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;스칼라 목록&lt;/a&gt; 형식의 &lt;code&gt;IN&lt;/code&gt; 을 사용하는 것이 좋습니다 . 스칼라리스트 방법은 적은 쓰기를 요구하며 종종 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1c8ca5d9d323066d6d659aa5ff3196102b40293c" translate="yes" xml:space="preserve">
          <source>For some types of errors, the server reports the name of a database object (a table, table column, data type, or constraint) associated with the error; for example, the name of the unique constraint that caused a &lt;code&gt;unique_violation&lt;/code&gt; error. Such names are supplied in separate fields of the error report message so that applications need not try to extract them from the possibly-localized human-readable text of the message. As of PostgreSQL 9.3, complete coverage for this feature exists only for errors in SQLSTATE class 23 (integrity constraint violation), but this is likely to be expanded in future.</source>
          <target state="translated">일부 유형의 오류의 경우, 서버는 오류와 연관된 데이터베이스 오브젝트 (테이블, 테이블 열, 데이터 유형 또는 제한 조건)의 이름을보고합니다. 예를 들어, &lt;code&gt;unique_violation&lt;/code&gt; 오류 를 일으킨 고유 제한 조건의 이름입니다 . 이러한 이름은 오류 보고서 메시지의 개별 필드에 제공되므로 응용 프로그램은 지역화 된 사람이 읽을 수있는 메시지의 텍스트에서 이름을 추출 할 필요가 없습니다. PostgreSQL 9.3부터이 기능에 대한 완전한 적용 범위는 SQLSTATE 클래스 23의 오류 (무결성 제한 위반)에 대해서만 존재하지만 향후 확장 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="b6625213e6e6fa2bc1eaac3fdaba176e51b962e6" translate="yes" xml:space="preserve">
          <source>For some types of relation, &lt;code&gt;\d&lt;/code&gt; shows additional information for each column: column values for sequences, indexed expressions for indexes, and foreign data wrapper options for foreign tables.</source>
          <target state="translated">일부 관계 유형의 경우 &lt;code&gt;\d&lt;/code&gt; 는 각 열에 대한 추가 정보 (시퀀스의 열 값, 인덱스의 인덱스 표현식 및 외부 테이블의 외래 데이터 래퍼 옵션)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="96c3119cad566b7b88d64ca07bab7df7991bc93e" translate="yes" xml:space="preserve">
          <source>For source installs, if you wish to install the new server in a custom location, use the &lt;code&gt;prefix&lt;/code&gt; variable:</source>
          <target state="translated">소스 설치의 경우 사용자 정의 위치에 새 서버를 설치하려면 &lt;code&gt;prefix&lt;/code&gt; 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="02535fa4807bcb15e6b90f67411bc5308adeb97f" translate="yes" xml:space="preserve">
          <source>For tables with GIN indexes, &lt;code&gt;VACUUM&lt;/code&gt; (in any form) also completes any pending index insertions, by moving pending index entries to the appropriate places in the main GIN index structure. See &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details.</source>
          <target state="translated">GIN 인덱스가있는 테이블의 경우 &lt;code&gt;VACUUM&lt;/code&gt; (모든 형식)은 보류중인 인덱스 항목을 기본 GIN 인덱스 구조의 적절한 위치로 이동하여 보류중인 인덱스 삽입을 완료합니다. 자세한 내용 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;은 66.4.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c91c055bfb7a26b615975cdc96ae00a408c07dd3" translate="yes" xml:space="preserve">
          <source>For tables, &lt;code&gt;db_table:select&lt;/code&gt;, &lt;code&gt;db_table:insert&lt;/code&gt;, &lt;code&gt;db_table:update&lt;/code&gt; or &lt;code&gt;db_table:delete&lt;/code&gt; are checked for all the referenced target tables depending on the kind of statement; in addition, &lt;code&gt;db_table:select&lt;/code&gt; is also checked for all the tables that contain columns referenced in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;RETURNING&lt;/code&gt; clause, as a data source for &lt;code&gt;UPDATE&lt;/code&gt;, and so on.</source>
          <target state="translated">테이블의 경우 &lt;code&gt;db_table:select&lt;/code&gt; , &lt;code&gt;db_table:insert&lt;/code&gt; , &lt;code&gt;db_table:update&lt;/code&gt; 또는 &lt;code&gt;db_table:delete&lt;/code&gt; 는 명령문의 종류에 따라 참조 된 모든 대상 테이블에 대해 점검됩니다. 또한 &lt;code&gt;db_table:select&lt;/code&gt; 는 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;RETURNING&lt;/code&gt; 절 에서 참조 된 컬럼을 포함하는 모든 테이블에 대해 &lt;code&gt;UPDATE&lt;/code&gt; 등 의 데이터 소스로 검사 됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7df8e7cc19f2604588ffd58fd2bd20e5c27f91" translate="yes" xml:space="preserve">
          <source>For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace. (Note that revoking this privilege will not alter the placement of existing objects.)</source>
          <target state="translated">테이블 스페이스의 경우 테이블 스페이스 내에서 테이블, 인덱스 및 임시 파일을 작성할 수 있으며 테이블 스페이스가 기본 테이블 스페이스 인 데이터베이스를 작성할 수 있습니다. (이 권한을 취소해도 기존 개체의 위치는 변경되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8ed1cb94cb2f097d1a4265a2618f61e0b1b1ddd6" translate="yes" xml:space="preserve">
          <source>For testing purposes, it is possible to run both primary and standby servers on the same system. This does not provide any worthwhile improvement in server robustness, nor would it be described as HA.</source>
          <target state="translated">테스트 목적으로 동일한 시스템에서 기본 및 대기 서버를 모두 실행할 수 있습니다. 이것은 서버 견고성에있어 가치있는 개선을 제공하지 않으며 HA로 설명되지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="14326aec7784d590e8d770eaca8e03f0b4af843b" translate="yes" xml:space="preserve">
          <source>For text search purposes, each document must be reduced to the preprocessed &lt;code&gt;tsvector&lt;/code&gt; format. Searching and ranking are performed entirely on the &lt;code&gt;tsvector&lt;/code&gt; representation of a document &amp;mdash; the original text need only be retrieved when the document has been selected for display to a user. We therefore often speak of the &lt;code&gt;tsvector&lt;/code&gt; as being the document, but of course it is only a compact representation of the full document.</source>
          <target state="translated">텍스트 검색을 위해 각 문서는 사전 처리 된 &lt;code&gt;tsvector&lt;/code&gt; 형식 으로 축소되어야 합니다. 검색 및 순위는 전적으로 문서 의 &lt;code&gt;tsvector&lt;/code&gt; 표현 에서 수행됩니다. 원본 텍스트는 사용자에게 표시 할 문서를 선택한 경우에만 검색해야합니다. 따라서 우리는 종종 &lt;code&gt;tsvector&lt;/code&gt; 를 문서라고 말하지만 물론 전체 문서를 간단히 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7a000de4f9a94a7302faa3da1d5fa7c3f403c9e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases, the row elements are compared left-to-right, stopping as soon as an unequal or null pair of elements is found. If either of this pair of elements is null, the result of the row comparison is unknown (null); otherwise comparison of this pair of elements determines the result. For example, &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; yields true, not null, because the third pair of elements are not considered.</source>
          <target state="translated">들어 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 경우, 로우 요소는 왼쪽에서 오른쪽으로, 즉시 정지 요소의 불균등 또는 null 쌍이 발견으로 비교된다. 이 요소 쌍 중 하나가 널이면 행 비교 결과를 알 수 없습니다 (널). 그렇지 않으면이 요소 쌍의 비교가 결과를 결정합니다. 예를 들어, &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; 은 세 번째 요소 쌍이 고려되지 않으므로 null이 아닌 true를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dfc3c21d9ddee1f916ca1387da5b3a8a58887534" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; join types, a join condition must be specified, namely exactly one of &lt;code&gt;NATURAL&lt;/code&gt;, &lt;code&gt;ON join_condition&lt;/code&gt;, or &lt;code&gt;USING (join_column [, ...])&lt;/code&gt;. See below for the meaning. For &lt;code&gt;CROSS JOIN&lt;/code&gt;, none of these clauses can appear.</source>
          <target state="translated">들어 &lt;code&gt;INNER&lt;/code&gt; 및 &lt;code&gt;OUTER&lt;/code&gt; 형태를 가입하는 조건 중 하나, 즉 정확하게 지정해야 가입 &lt;code&gt;NATURAL&lt;/code&gt; , &lt;code&gt;ON join_condition&lt;/code&gt; 또는 &lt;code&gt;USING (join_column [, ...])&lt;/code&gt; . 의미는 아래를 참조하십시오. 들어 &lt;code&gt;CROSS JOIN&lt;/code&gt; ,이 조항의 어느 것도 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dad37c11367f0fd32c32e9bf08cc2fd30c405130" translate="yes" xml:space="preserve">
          <source>For the default TPC-B-like test scenario, the initialization scale factor (&lt;code&gt;-s&lt;/code&gt;) should be at least as large as the largest number of clients you intend to test (&lt;code&gt;-c&lt;/code&gt;); else you'll mostly be measuring update contention. There are only &lt;code&gt;-s&lt;/code&gt; rows in the &lt;code&gt;pgbench_branches&lt;/code&gt; table, and every transaction wants to update one of them, so &lt;code&gt;-c&lt;/code&gt; values in excess of &lt;code&gt;-s&lt;/code&gt; will undoubtedly result in lots of transactions blocked waiting for other transactions.</source>
          <target state="translated">기본 TPC-B와 유사한 테스트 시나리오의 경우 초기화 스케일 팩터 ( &lt;code&gt;-s&lt;/code&gt; )는 테스트하려는 최대 클라이언트 수 ( &lt;code&gt;-c&lt;/code&gt; ) 만큼 커야합니다 . 그렇지 않으면 대부분 업데이트 경합을 측정하게됩니다. 이 전용 &lt;code&gt;-s&lt;/code&gt; 행 &lt;code&gt;pgbench_branches&lt;/code&gt; 의 테이블은 모든 트랜잭션은 그래서 그들 중 하나를 업데이트하려고합니다 &lt;code&gt;-c&lt;/code&gt; 를 초과하는 값 &lt;code&gt;-s&lt;/code&gt; 는 의심 할 여지없이 다른 트랜잭션을 기다리고 차단 된 트랜잭션이 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5751609fa3abe5700d0557e4f26ffe5f05018e3" translate="yes" xml:space="preserve">
          <source>For the default script, the output will look similar to this:</source>
          <target state="translated">기본 스크립트의 경우 출력은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9007ccafafbe06f38e92e2d086ee0438ce1eec15" translate="yes" xml:space="preserve">
          <source>For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSON 값을 구성하고 처리하는 데 사용할 수있는 내장 함수 및 연산자 목록은 &lt;a href=&quot;functions-json&quot;&gt;섹션 9.15를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6a1288823da614ad6ddd8076b29a2c859b00b3d" translate="yes" xml:space="preserve">
          <source>For the purpose of a unique constraint, null values are not considered equal.</source>
          <target state="translated">고유 제한 조건의 목적으로 널값은 동일한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5aa91a6ae5978dfba449fc8f21af598ecb84b63" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the multixact ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">이 옵션의 목적 상, 관계의 멀티 플렉스 ID 연령은 기본 관계 및 연관된 TOAST 테이블이있는 경우 가장 깁니다. vacuumdb가 실행 한 명령은 필요한 경우 관계에 대한 TOAST 테이블도 처리하므로 별도로 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a930282601dc6d73b8f0cbaf1770a134e812692" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the transaction ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">이 옵션의 목적 상, 관계의 트랜잭션 ID 연령은 기본 관계 및 연관된 TOAST 테이블이있는 경우 가장 깁니다. vacuumdb가 실행 한 명령은 필요한 경우 관계에 대한 TOAST 테이블도 처리하므로 별도로 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7dd494ba670198b28ebfc500d18e95c5d26c155" translate="yes" xml:space="preserve">
          <source>For the regexp functions, if you want to match case-sensitively, you can specify the &amp;ldquo;c&amp;rdquo; flag to force a case-sensitive match. Otherwise, you must cast to &lt;code&gt;text&lt;/code&gt; before using one of these functions if you want case-sensitive behavior.</source>
          <target state="translated">정규식 함수의 경우 대소 문자를 구분하려면 &quot;c&quot;플래그를 지정하여 대소 문자를 구분할 수 있습니다. 그렇지 않으면 대소 문자 구분 동작을 원하는 경우 이러한 기능 중 하나를 사용하기 전에 &lt;code&gt;text&lt;/code&gt; 캐스트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d78645291bcc7701c1b16378879f0e6ec0613a1b" translate="yes" xml:space="preserve">
          <source>For this purpose, white-space characters are blank, tab, newline, and any character that belongs to the &lt;code&gt;space&lt;/code&gt; character class.</source>
          <target state="translated">이를 위해 공백 문자는 공백, 탭, 줄 바꿈 및 &lt;code&gt;space&lt;/code&gt; 문자 클래스에 속하는 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="74af73ce47f8b4a950cf1dc74d44af070dbfb80a" translate="yes" xml:space="preserve">
          <source>For those interested in further details, estimation of the size of a table (before any &lt;code&gt;WHERE&lt;/code&gt; clauses) is done in &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt;. The generic logic for clause selectivities is in &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt;. The operator-specific selectivity functions are mostly found in &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt;.</source>
          <target state="translated">추가 세부 사항에 관심이있는 사용자의 경우 테이블 크기 ( &lt;code&gt;WHERE&lt;/code&gt; 절 이전)의 추정은 &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt; 에서 수행 됩니다. 절 선택성의 일반적인 논리는 &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt; 에 있습니다. 운영자 별 선택 기능은 주로 &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63222727e6629be4e7161b8b3cc8abbda85cb89" translate="yes" xml:space="preserve">
          <source>For those not using autovacuum, a typical approach is to schedule a database-wide &lt;code&gt;VACUUM&lt;/code&gt; once a day during a low-usage period, supplemented by more frequent vacuuming of heavily-updated tables as necessary. (Some installations with extremely high update rates vacuum their busiest tables as often as once every few minutes.) If you have multiple databases in a cluster, don't forget to &lt;code&gt;VACUUM&lt;/code&gt; each one; the program &lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt; might be helpful.</source>
          <target state="translated">autovacuum을 사용하지 않는 사람들의 경우, 일반적인 방법은 사용량이 적을 때 하루에 한 번 데이터베이스 전체 &lt;code&gt;VACUUM&lt;/code&gt; 을 예약하고 필요에 따라 많이 업데이트 된 테이블을 더 자주 진공 청소기로 청소하는 것입니다. (매우 높은 업데이트 속도를 가진 일부 설치는 몇 분마다 한 번씩 자주 가장 바쁜 테이블을 진공 청소기로 청소합니다.) 클러스터에 여러 데이터베이스가있는 경우 각 데이터베이스를 &lt;code&gt;VACUUM&lt;/code&gt; 하는 것을 잊지 마십시오 . &lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt; 프로그램 이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b55b171eb70ee6df74b6fa93a4927e18a0f903" translate="yes" xml:space="preserve">
          <source>For tranches registered by extensions, the name is specified by extension and this will be displayed as &lt;code&gt;wait_event&lt;/code&gt;. It is quite possible that user has registered the tranche in one of the backends (by having allocation in dynamic shared memory) in which case other backends won't have that information, so we display &lt;code&gt;extension&lt;/code&gt; for such cases.</source>
          <target state="translated">확장자로 등록 된 트랜치의 경우 이름은 확장자로 지정되며 이는 &lt;code&gt;wait_event&lt;/code&gt; 로 표시됩니다 . 사용자가 백엔드 중 하나 (동적 공유 메모리에 할당하여)에 트랜치를 등록했을 가능성이 있으며,이 경우 다른 백엔드는 해당 정보를 갖지 않으므로 그러한 경우에 대한 &lt;code&gt;extension&lt;/code&gt; 을 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="6ededecf7230bd098333895398724d8cf30ca646" translate="yes" xml:space="preserve">
          <source>For typed tables, the OID of the underlying composite type, zero for all other relations</source>
          <target state="translated">유형이 지정된 테이블의 경우 기본 복합 유형의 OID, 다른 모든 관계의 경우 0</target>
        </trans-unit>
        <trans-unit id="27c45ad1aa00e6a5905b5f896364ccf8b4773847" translate="yes" xml:space="preserve">
          <source>For types and domains, allows use of the type or domain in the creation of tables, functions, and other schema objects. (Note that this privilege does not control all &amp;ldquo;usage&amp;rdquo; of the type, such as values of the type appearing in queries. It only prevents objects from being created that depend on the type. The main purpose of this privilege is controlling which users can create dependencies on a type, which could prevent the owner from changing the type later.)</source>
          <target state="translated">유형 및 도메인의 경우 테이블, 함수 및 기타 스키마 객체를 만들 때 유형 또는 도메인을 사용할 수 있습니다. (이 권한은 쿼리에 나타나는 유형의 값과 같은 유형의 모든 &quot;사용&quot;을 제어하지는 않습니다. 유형에 따라 개체가 생성되는 것을 막을뿐입니다.이 권한의 주된 목적은 사용자를 제어 할 수있는 것입니다. 유형에 대한 종속성을 작성하여 소유자가 나중에 유형을 변경하지 못하게 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="bff214879bf946c9914852230e9d3373cec1aabc" translate="yes" xml:space="preserve">
          <source>For types used in system tables, it is critical that the size and alignment defined in &lt;code&gt;pg_type&lt;/code&gt; agree with the way that the compiler will lay out the column in a structure representing a table row.</source>
          <target state="translated">시스템 테이블에 사용되는 유형의 경우 &lt;code&gt;pg_type&lt;/code&gt; 에 정의 된 크기와 정렬 이 컴파일러가 테이블 행을 나타내는 구조에서 열을 레이아웃하는 방식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e1106a91cc01fcaaeb464887fd19957f0820912" translate="yes" xml:space="preserve">
          <source>For unlogged relations, everything works the same except that no actual WAL record is emitted. Thus, you typically do not need to do any explicit checks for unlogged relations.</source>
          <target state="translated">기록되지 않은 관계의 경우 실제 WAL 레코드가 생성되지 않는 것을 제외하고 모든 것이 동일하게 작동합니다. 따라서 일반적으로 기록되지 않은 관계에 대한 명시 적 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="85b738e0688a60aa0821e2d9571d4dd56271215e" translate="yes" xml:space="preserve">
          <source>For user-defined functions, PostgreSQL tracks dependencies associated with a function's externally-visible properties, such as its argument and result types, but &lt;em&gt;not&lt;/em&gt; dependencies that could only be known by examining the function body. As an example, consider this situation:</source>
          <target state="translated">사용자 정의 함수의 경우 PostgreSQL은 인수 및 결과 유형과 같이 함수의 외부에서 볼 수있는 속성과 관련된 종속성을 추적하지만 함수 본문을 검사해야만 알 수있는 종속성은 추적 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cd43cb783f81232deb1bffc73b358dcab3c75399" translate="yes" xml:space="preserve">
          <source>For very large databases, you might need to combine &lt;code&gt;split&lt;/code&gt; with one of the other two approaches.</source>
          <target state="translated">매우 큰 데이터베이스의 경우 &lt;code&gt;split&lt;/code&gt; 을 다른 두 가지 방법 중 하나와 결합해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33f690385f50f3c83dc2195d926f5a45ebb2cb63" translate="yes" xml:space="preserve">
          <source>For views, &lt;code&gt;db_view:expand&lt;/code&gt; will be checked, then any other required permissions will be checked on the objects being expanded from the view, individually.</source>
          <target state="translated">뷰의 경우 &lt;code&gt;db_view:expand&lt;/code&gt; 가 확인 된 후, 다른 필수 권한이 ​​뷰에서 확장되는 오브젝트에 대해 개별적으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf29d0c0afb407846366a836c4874ef5e6ab74c" translate="yes" xml:space="preserve">
          <source>Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt; 명령 실행을 금지하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e74aa9c02843996563e83950d619d1a48cca853" translate="yes" xml:space="preserve">
          <source>Forbids the use of particular scan and join methods: &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; disable sequential and index scans respectively, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; disable index-only scans, bitmap index scans, and TID scans respectively, while &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; disable nested-loop, merge and hash joins respectively.</source>
          <target state="translated">금지 특히 주사의 사용 및 방법을 조인 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;i&lt;/code&gt; 비활성화 순차 인덱스를 각각 검사 &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 비활성화 인덱스 만 스캔, 비트 맵 인덱스 스캔 및 TID는 동안, 각각 검사 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , 및 &lt;code&gt;h&lt;/code&gt; 비활성화 nested- 루프, 병합 및 해시 조인.</target>
        </trans-unit>
        <trans-unit id="6b54925430ba39c29285400ee9438bd06b14498b" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;pg_resetwal&lt;/code&gt; to proceed even if it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, as explained above.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;pg_control&lt;/code&gt; 의 유효한 데이터를 판별 할 수없는 경우에도 &lt;code&gt;pg_resetwal&lt;/code&gt; 을 강제 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eac8549c0aec6316f92f1df6ba514101db909c7" translate="yes" xml:space="preserve">
          <source>Force clusterdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 clusterdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b0925c99f8012867ed4e28694186256d8b497b07" translate="yes" xml:space="preserve">
          <source>Force createdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 createdb가 암호를 입력하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="919f499ede6938621bb948df3ec55861e7b6e806" translate="yes" xml:space="preserve">
          <source>Force createuser to prompt for a password (for connecting to the server, not for the password of the new user).</source>
          <target state="translated">createuser가 암호를 요구하도록합니다 (새 사용자의 암호가 아닌 서버에 연결하기 위해).</target>
        </trans-unit>
        <trans-unit id="0f5754485fd77647fa947500ba7d7eb3887d6390" translate="yes" xml:space="preserve">
          <source>Force dropdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 dropdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="873b3fb51bdfb58a81fcee07b36cfd295d4a25ba" translate="yes" xml:space="preserve">
          <source>Force dropuser to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 dropuser가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="68791460318431f1565f0db6649c38933e1c99f9" translate="yes" xml:space="preserve">
          <source>Force pg_basebackup to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_basebackup이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e1db6640e8674298e7ff463f7c01bcb7d3c09291" translate="yes" xml:space="preserve">
          <source>Force pg_dump to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_dump가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0bf671184854c4cafab424f289da944581383f7f" translate="yes" xml:space="preserve">
          <source>Force pg_dumpall to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_dumpall이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cd46ad236b5565bc59849836637665c81e945654" translate="yes" xml:space="preserve">
          <source>Force pg_receivewal to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_receivewal이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cb0cb6641f18ac0a5ebc128cc7585e9485375d09" translate="yes" xml:space="preserve">
          <source>Force pg_recvlogical to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_recvlogical이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4333d7ad34894773d7724c896ba1ace5baa2e67d" translate="yes" xml:space="preserve">
          <source>Force pg_restore to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_restore가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="060988688e7df93b56005121dd07764d70ac7fe5" translate="yes" xml:space="preserve">
          <source>Force psql to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 psql이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b0cd7fd585ccc7a582ee1111bc67d7d89a04cf8e" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dump's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dump quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">모든 식별자를 강제로 인용합니다. 이 옵션은 PostgreSQL 주 버전이 pg_dump와 다른 서버에서 데이터베이스를 덤프하거나 출력을 다른 주 버전의 서버로로드 할 때 권장됩니다. 기본적으로 pg_dump는 자체 주 버전에서 예약어 인 식별자 만 인용합니다. 이로 인해 예약어가 약간 다른 다른 버전의 서버를 처리 할 때 호환성 문제가 발생하는 경우가 있습니다. 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 힘들어 읽기 덤프 스크립트의 가격으로, 이러한 문제 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b22bd3cb5e64bd74dfce653c7bff0f559c9c1f26" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dumpall's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dumpall quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">모든 식별자를 강제로 인용합니다. 이 옵션은 PostgreSQL 주 버전이 pg_dumpall과 다른 서버에서 데이터베이스를 덤프하거나 출력을 다른 주 버전의 서버로로드 할 때 권장됩니다. 기본적으로 pg_dumpall은 자체 주 버전의 예약어 인 식별자 만 인용합니다. 이로 인해 예약어가 약간 다른 다른 버전의 서버를 처리 할 때 호환성 문제가 발생하는 경우가 있습니다. 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 힘들어 읽기 덤프 스크립트의 가격으로, 이러한 문제 방지합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
