<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="529b5d98779f3a599ef6687154fe8084cc70faf2" translate="yes" xml:space="preserve">
          <source>pg_basebackup makes a binary copy of the database cluster files, while making sure the system is put in and out of backup mode automatically. Backups are always taken of the entire database cluster; it is not possible to back up individual databases or database objects. For individual database backups, a tool such as &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; must be used.</source>
          <target state="translated">pg_basebackup은 데이터베이스 클러스터 파일의 이진 복사본을 만들면서 시스템이 자동으로 백업 모드로 들어오고 나가도록합니다. 백업은 항상 전체 데이터베이스 클러스터에서 수행됩니다. 개별 데이터베이스 또는 데이터베이스 오브젝트를 백업 할 수 없습니다. 개별 데이터베이스 백업의 경우 &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 와 같은 도구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="514864905a59f04cafc63fb115ff6c89ac46442c" translate="yes" xml:space="preserve">
          <source>pg_basebackup will preserve group permissions in both the &lt;code&gt;plain&lt;/code&gt; and &lt;code&gt;tar&lt;/code&gt; formats if group permissions are enabled on the source cluster.</source>
          <target state="translated">pg_basebackup은 소스 클러스터에서 그룹 권한이 활성화 된 경우 &lt;code&gt;plain&lt;/code&gt; 및 &lt;code&gt;tar&lt;/code&gt; 형식으로 그룹 권한을 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="d5c0a45d584ad544772564f26127f5f7417699df" translate="yes" xml:space="preserve">
          <source>pg_basebackup works with servers of the same or an older major version, down to 9.1. However, WAL streaming mode (&lt;code&gt;-X stream&lt;/code&gt;) only works with server version 9.3 and later, and tar format mode (&lt;code&gt;--format=tar&lt;/code&gt;) of the current version only works with server version 9.5 or later.</source>
          <target state="translated">pg_basebackup은 동일하거나 이전 버전의 서버에서 9.1까지 작동합니다. 그러나 WAL 스트리밍 모드 ( &lt;code&gt;-X stream&lt;/code&gt; )는 서버 버전 9.3 이상 에서만 작동하며 현재 버전의 tar 형식 모드 ( &lt;code&gt;--format=tar&lt;/code&gt; )는 서버 버전 9.5 이상에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d8acf563c6d1625620f15257a63efd86cebe4313" translate="yes" xml:space="preserve">
          <source>pg_buffercache</source>
          <target state="translated">pg_buffercache</target>
        </trans-unit>
        <trans-unit id="0ef4ea3aa256d585ec00df5a99879d369be85ddc" translate="yes" xml:space="preserve">
          <source>pg_checksums</source>
          <target state="translated">pg_checksums</target>
        </trans-unit>
        <trans-unit id="90ae66d70a624ae9b96be5b203ad12dc8e7d5d60" translate="yes" xml:space="preserve">
          <source>pg_checksums &amp;mdash; enable, disable or check data checksums in a PostgreSQL database cluster</source>
          <target state="translated">pg_checksums &amp;mdash; PostgreSQL 데이터베이스 클러스터에서 데이터 체크섬을 활성화, 비활성화 또는 확인</target>
        </trans-unit>
        <trans-unit id="813cc0376462b15e12355d4c4548e39a8d18f17d" translate="yes" xml:space="preserve">
          <source>pg_checksums checks, enables or disables data checksums in a PostgreSQL cluster. The server must be shut down cleanly before running pg_checksums. When verifying checksums, the exit status is zero if there are no checksum errors, and nonzero if at least one checksum failure is detected. When enabling or disabling checksums, the exit status is nonzero if the operation failed.</source>
          <target state="translated">pg_checksums는 PostgreSQL 클러스터에서 데이터 체크섬을 확인, 활성화 또는 비활성화합니다. pg_checksums를 실행하기 전에 서버를 완전히 종료해야합니다. 체크섬을 확인할 때 체크섬 오류가 없으면 종료 상태는 0이고 하나 이상의 체크섬 오류가 감지되면 0이 아닙니다. 체크섬을 활성화 또는 비활성화 할 때 작업이 실패하면 종료 상태는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5162f3429af1a80afacc7254235d05a6025e64e7" translate="yes" xml:space="preserve">
          <source>pg_config</source>
          <target state="translated">pg_config</target>
        </trans-unit>
        <trans-unit id="8073aa64da0eac2c81292a0bbb8ce41a0e7ed8ad" translate="yes" xml:space="preserve">
          <source>pg_config &amp;mdash; retrieve information about the installed version of PostgreSQL</source>
          <target state="translated">pg_config &amp;mdash; 설치된 PostgreSQL 버전 정보를 검색합니다</target>
        </trans-unit>
        <trans-unit id="d4e2f9e6b20f7fa1b0903cc040828b9640af4021" translate="yes" xml:space="preserve">
          <source>pg_controldata</source>
          <target state="translated">pg_controldata</target>
        </trans-unit>
        <trans-unit id="07b40a5b14c9b384ac8f11af731819d5a1551f54" translate="yes" xml:space="preserve">
          <source>pg_controldata &amp;mdash; display control information of a PostgreSQL database cluster</source>
          <target state="translated">pg_controldata &amp;mdash; PostgreSQL 데이터베이스 클러스터의 제어 정보를 표시합니다</target>
        </trans-unit>
        <trans-unit id="e0be30c91582acee8b973587f46378305af0cb5c" translate="yes" xml:space="preserve">
          <source>pg_ctl</source>
          <target state="translated">pg_ctl</target>
        </trans-unit>
        <trans-unit id="c85445e36f769fbbf11c683aeb1c9ab391ab69fe" translate="yes" xml:space="preserve">
          <source>pg_ctl &amp;mdash; initialize, start, stop, or control a PostgreSQL server</source>
          <target state="translated">pg_ctl &amp;mdash; PostgreSQL 서버 초기화, 시작, 중지 또는 제어</target>
        </trans-unit>
        <trans-unit id="29ba8cdfd9f0d2b0d68d584548245b17bf5288d3" translate="yes" xml:space="preserve">
          <source>pg_ctl examines this file in the data directory to determine whether the server is currently running.</source>
          <target state="translated">pg_ctl은 데이터 디렉토리에서이 파일을 검사하여 서버가 현재 실행 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5b70ba2b76746357ee9da1bcb461f7befd1620bb" translate="yes" xml:space="preserve">
          <source>pg_ctl is a utility for initializing a PostgreSQL database cluster, starting, stopping, or restarting the PostgreSQL database server (&lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;), or displaying the status of a running server. Although the server can be started manually, pg_ctl encapsulates tasks such as redirecting log output and properly detaching from the terminal and process group. It also provides convenient options for controlled shutdown.</source>
          <target state="translated">pg_ctl은 PostgreSQL 데이터베이스 클러스터를 초기화하거나 PostgreSQL 데이터베이스 서버 ( &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; )를 시작, 중지 또는 재시작 하거나 실행중인 서버의 상태를 표시 하는 유틸리티입니다 . 서버를 수동으로 시작할 수 있지만 pg_ctl은 로그 출력 리디렉션 및 터미널 및 프로세스 그룹에서 올바르게 분리하는 등의 작업을 캡슐화합니다. 또한 제어 된 종료를위한 편리한 옵션도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea826551b10fb6c5e564f99e7c4e25be3158639b" translate="yes" xml:space="preserve">
          <source>pg_dump</source>
          <target state="translated">pg_dump</target>
        </trans-unit>
        <trans-unit id="d8da13e92102bd85260ade5ff9c13d51ca40faef" translate="yes" xml:space="preserve">
          <source>pg_dump &amp;mdash; extract a PostgreSQL database into a script file or other archive file</source>
          <target state="translated">pg_dump &amp;mdash; PostgreSQL 데이터베이스를 스크립트 파일 또는 다른 아카이브 파일로 추출</target>
        </trans-unit>
        <trans-unit id="b8ea28acb24d80028b25ae201709e6bb00490da1" translate="yes" xml:space="preserve">
          <source>pg_dump and pg_dumpall do not produce file-system-level backups and cannot be used as part of a continuous-archiving solution. Such dumps are &lt;em&gt;logical&lt;/em&gt; and do not contain enough information to be used by WAL replay.</source>
          <target state="translated">pg_dump 및 pg_dumpall은 파일 시스템 수준 백업을 생성하지 않으며 연속 보관 솔루션의 일부로 사용할 수 없습니다. 이러한 덤프는 &lt;em&gt;논리적&lt;/em&gt; 이며 WAL 재생에 사용하기에 충분한 정보를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e47ad46f08cc11e1f2a426da16dbef9d16e18818" translate="yes" xml:space="preserve">
          <source>pg_dump dumps only a single database at a time, and it does not dump information about roles or tablespaces (because those are cluster-wide rather than per-database). To support convenient dumping of the entire contents of a database cluster, the &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt; program is provided. pg_dumpall backs up each database in a given cluster, and also preserves cluster-wide data such as role and tablespace definitions. The basic usage of this command is:</source>
          <target state="translated">pg_dump는 한 번에 하나의 데이터베이스 만 덤프하며 역할 또는 테이블 스페이스에 대한 정보는 덤프하지 않습니다 (데이터베이스가 아닌 클러스터 전체이기 때문에). 데이터베이스 클러스터의 전체 내용을 편리하게 덤프 할 수 있도록 &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt; 프로그램이 제공됩니다. pg_dumpall은 지정된 클러스터의 각 데이터베이스를 백업하고 역할 및 테이블 스페이스 정의와 같은 클러스터 전체의 데이터를 보존합니다. 이 명령의 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0154d094296b519cfc7459beede252e12c93fe9" translate="yes" xml:space="preserve">
          <source>pg_dump internally executes &lt;code&gt;SELECT&lt;/code&gt; statements. If you have problems running pg_dump, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">pg_dump는 내부적으로 &lt;code&gt;SELECT&lt;/code&gt; 문을 실행 합니다. pg_dump를 실행하는 데 문제가있는 경우 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 등을 사용하여 데이터베이스에서 정보를 선택할 수 있는지 확인하십시오 . 또한 libpq 프론트 엔드 라이브러리가 사용하는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc054a0de3b70e851fabffa910222129ed95340c" translate="yes" xml:space="preserve">
          <source>pg_dump is a regular PostgreSQL client application (albeit a particularly clever one). This means that you can perform this backup procedure from any remote host that has access to the database. But remember that pg_dump does not operate with special permissions. In particular, it must have read access to all tables that you want to back up, so in order to back up the entire database you almost always have to run it as a database superuser. (If you do not have sufficient privileges to back up the entire database, you can still back up portions of the database to which you do have access using options such as &lt;code&gt;-n schema&lt;/code&gt; or &lt;code&gt;-t table&lt;/code&gt;.)</source>
          <target state="translated">pg_dump는 일반적인 PostgreSQL 클라이언트 응용 프로그램입니다 (특히 영리한 응용 프로그램 임). 이는 데이터베이스에 액세스 할 수있는 원격 호스트에서이 백업 절차를 수행 할 수 있음을 의미합니다. 그러나 pg_dump는 특별한 권한으로 작동하지 않습니다. 특히 백업하려는 모든 테이블에 대한 읽기 액세스 권한이 있어야하므로 전체 데이터베이스를 백업하려면 거의 항상 데이터베이스 수퍼 유저로 실행해야합니다. (전체 데이터베이스를 백업하기에 충분한 권한이없는 경우에도 &lt;code&gt;-n schema&lt;/code&gt; 또는 &lt;code&gt;-t table&lt;/code&gt; 과 같은 옵션을 사용하여 액세스 할 수있는 데이터베이스의 일부를 백업 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="322f1ec764d24ca5c75f49cbfca0f5142b5381d7" translate="yes" xml:space="preserve">
          <source>pg_dump is a utility for backing up a PostgreSQL database. It makes consistent backups even if the database is being used concurrently. pg_dump does not block other users accessing the database (readers or writers).</source>
          <target state="translated">pg_dump는 PostgreSQL 데이터베이스를 백업하기위한 유틸리티입니다. 데이터베이스를 동시에 사용하더라도 일관된 백업을 수행합니다. pg_dump는 데이터베이스 (리더 또는 라이터)에 액세스하는 다른 사용자를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9285b9852f91f9bf38ce8586513844d04b82de91" translate="yes" xml:space="preserve">
          <source>pg_dump only dumps a single database. To back up an entire cluster, or to back up global objects that are common to all databases in a cluster (such as roles and tablespaces), use &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">pg_dump는 단일 데이터베이스 만 덤프합니다. 전체 클러스터를 백업하거나 클러스터의 모든 데이터베이스 (예 : 역할 및 테이블 공간)에 공통적 인 전역 객체를 백업하려면 &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2a92aec7942642c03a7f7e44eb999c08afa7bae" translate="yes" xml:space="preserve">
          <source>pg_dump will open &lt;code&gt;njobs&lt;/code&gt; + 1 connections to the database, so make sure your &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; setting is high enough to accommodate all connections.</source>
          <target state="translated">pg_dump는 데이터베이스에 &lt;code&gt;njobs&lt;/code&gt; + 1 개의 연결을 열 므로 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 설정이 모든 연결을 수용 할 수있을만큼 충분히 높아야합니다.</target>
        </trans-unit>
        <trans-unit id="57a436913fcb30038b4168179b5f7bd99782c1b6" translate="yes" xml:space="preserve">
          <source>pg_dumpall</source>
          <target state="translated">pg_dumpall</target>
        </trans-unit>
        <trans-unit id="3579ff641791cc87ba3443578d0893e8f967308d" translate="yes" xml:space="preserve">
          <source>pg_dumpall &amp;mdash; extract a PostgreSQL database cluster into a script file</source>
          <target state="translated">pg_dumpall &amp;mdash; PostgreSQL 데이터베이스 클러스터를 스크립트 파일로 추출</target>
        </trans-unit>
        <trans-unit id="6d9e15c0ba3f2c3a890f79cf69bfe7b4f89e81f1" translate="yes" xml:space="preserve">
          <source>pg_dumpall is a utility for writing out (&amp;ldquo;dumping&amp;rdquo;) all PostgreSQL databases of a cluster into one script file. The script file contains SQL commands that can be used as input to &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; to restore the databases. It does this by calling &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for each database in the cluster. pg_dumpall also dumps global objects that are common to all databases, that is, database roles and tablespaces. (pg_dump does not save these objects.)</source>
          <target state="translated">pg_dumpall은 클러스터의 모든 PostgreSQL 데이터베이스를 하나의 스크립트 파일에 기록 ( &quot;덤핑&quot;)하는 유틸리티입니다. 스크립트 파일에는 데이터베이스를 복원 하기 위해 &lt;a href=&quot;app-psql&quot;&gt;psql에&lt;/a&gt; 대한 입력으로 사용할 수있는 SQL 명령이 포함되어 있습니다. 클러스터의 각 데이터베이스에 대해 &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 를 호출 하여이를 수행합니다. pg_dumpall은 또한 모든 데이터베이스, 즉 데이터베이스 역할 및 테이블 공간에 공통적 인 전역 객체를 덤프합니다. (pg_dump는 이러한 객체를 저장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="2503e589c33511a1a65bd54eb7a0dcc83e8ad567" translate="yes" xml:space="preserve">
          <source>pg_dumpall needs to connect several times to the PostgreSQL server (once per database). If you use password authentication it will ask for a password each time. It is convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file in such cases. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">pg_dumpall은 PostgreSQL 서버에 여러 번 연결해야합니다 (데이터베이스 당 한 번). 비밀번호 인증을 사용하는 경우 매번 비밀번호를 묻습니다. 이런 경우 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용 하는 것이 편리합니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;33.15 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="974bcea1e9898acafbb490060238b693f28c2cc4" translate="yes" xml:space="preserve">
          <source>pg_dumpall requires all needed tablespace directories to exist before the restore; otherwise, database creation will fail for databases in non-default locations.</source>
          <target state="translated">pg_dumpall을 사용하려면 복원하기 전에 필요한 모든 테이블 스페이스 디렉토리가 있어야합니다. 그렇지 않으면 기본 위치가 아닌 데이터베이스에 대한 데이터베이스 작성이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a1dad65c3aac45f76a12712aa519b21363527f94" translate="yes" xml:space="preserve">
          <source>pg_dumpall works by emitting commands to re-create roles, tablespaces, and empty databases, then invoking pg_dump for each database. This means that while each database will be internally consistent, the snapshots of different databases are not synchronized.</source>
          <target state="translated">pg_dumpall은 역할, 테이블 스페이스 및 빈 데이터베이스를 다시 생성하는 명령을 내 보낸 다음 각 데이터베이스에 대해 pg_dump를 호출하여 작동합니다. 즉, 각 데이터베이스는 내부적으로 일관성이 있지만 다른 데이터베이스의 스냅 샷은 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="578edb4f43436295397597e57e832bbca8c9e27d" translate="yes" xml:space="preserve">
          <source>pg_execute_server_program</source>
          <target state="translated">pg_execute_server_program</target>
        </trans-unit>
        <trans-unit id="79ef7796e352e674bd306ff0a5433ea164b3ea6d" translate="yes" xml:space="preserve">
          <source>pg_freespacemap</source>
          <target state="translated">pg_freespacemap</target>
        </trans-unit>
        <trans-unit id="c3445e0d6cf1955fea5138d496261730712eca98" translate="yes" xml:space="preserve">
          <source>pg_hba.conf File</source>
          <target state="translated">pg_hba.conf 파일</target>
        </trans-unit>
        <trans-unit id="b6243f91ed5c8d268f7cf5a522cd0c13955153be" translate="yes" xml:space="preserve">
          <source>pg_isready</source>
          <target state="translated">pg_isready</target>
        </trans-unit>
        <trans-unit id="3e4613393d05f200ab7e38fba9819b80caeafcba" translate="yes" xml:space="preserve">
          <source>pg_isready &amp;mdash; check the connection status of a PostgreSQL server</source>
          <target state="translated">pg_isready &amp;mdash; PostgreSQL 서버의 연결 상태를 확인합니다</target>
        </trans-unit>
        <trans-unit id="42c6a3314dc52f63b8f63f7950410b2aead89f72" translate="yes" xml:space="preserve">
          <source>pg_isready is a utility for checking the connection status of a PostgreSQL database server. The exit status specifies the result of the connection check.</source>
          <target state="translated">pg_isready는 PostgreSQL 데이터베이스 서버의 연결 상태를 확인하는 유틸리티입니다. 종료 상태는 연결 확인 결과를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f61c89ddb8129241f13a5c2059dc6cdcf68d836d" translate="yes" xml:space="preserve">
          <source>pg_isready returns &lt;code&gt;0&lt;/code&gt; to the shell if the server is accepting connections normally, &lt;code&gt;1&lt;/code&gt; if the server is rejecting connections (for example during startup), &lt;code&gt;2&lt;/code&gt; if there was no response to the connection attempt, and &lt;code&gt;3&lt;/code&gt; if no attempt was made (for example due to invalid parameters).</source>
          <target state="translated">서버가 정상적으로 연결을 수락하면 pg_isready는 셸에 &lt;code&gt;0&lt;/code&gt; 을 반환 하고, &lt;code&gt;1&lt;/code&gt; 은 서버가 연결을 거부하는 경우 (예 : 시작 중), &lt;code&gt;2&lt;/code&gt; 는 연결 시도에 대한 응답이없는 경우 , &lt;code&gt;3&lt;/code&gt; 은 시도하지 않은 경우 (예 : 유효하지 않은 매개 변수).</target>
        </trans-unit>
        <trans-unit id="c089e765ee8d5f8d020c7c5e53128dda4a88cd81" translate="yes" xml:space="preserve">
          <source>pg_lsn</source>
          <target state="translated">pg_lsn</target>
        </trans-unit>
        <trans-unit id="916d0cf004c1a6325c661a9e22a82a1c57c4f72d" translate="yes" xml:space="preserve">
          <source>pg_lsn Type</source>
          <target state="translated">pg_lsn 유형</target>
        </trans-unit>
        <trans-unit id="04db75756af42b2f9bb20ed5e8d8cc3abda15a5f" translate="yes" xml:space="preserve">
          <source>pg_monitor</source>
          <target state="translated">pg_monitor</target>
        </trans-unit>
        <trans-unit id="1e568301d754266eab1d7e428c19202117954bbb" translate="yes" xml:space="preserve">
          <source>pg_notify</source>
          <target state="translated">pg_notify</target>
        </trans-unit>
        <trans-unit id="0caa58cf689e0ddc74445101967dc7faa51dcdc3" translate="yes" xml:space="preserve">
          <source>pg_prewarm</source>
          <target state="translated">pg_prewarm</target>
        </trans-unit>
        <trans-unit id="a90d50f249d5bb779aed594463314495d73b87e3" translate="yes" xml:space="preserve">
          <source>pg_read_all_settings</source>
          <target state="translated">pg_read_all_settings</target>
        </trans-unit>
        <trans-unit id="ce40e10cf48163abe2e4467d9b8fefdd34e99d39" translate="yes" xml:space="preserve">
          <source>pg_read_all_stats</source>
          <target state="translated">pg_read_all_stats</target>
        </trans-unit>
        <trans-unit id="672ccde4199244371d3187022b0c77cb6aba0242" translate="yes" xml:space="preserve">
          <source>pg_read_server_files</source>
          <target state="translated">pg_read_server_files</target>
        </trans-unit>
        <trans-unit id="2efd5ab30369a88508d8585f1cc52aa1ff6d58ab" translate="yes" xml:space="preserve">
          <source>pg_receivewal</source>
          <target state="translated">pg_receivewal</target>
        </trans-unit>
        <trans-unit id="666f6b0c830ac42867979e7e4d28a769aa449122" translate="yes" xml:space="preserve">
          <source>pg_receivewal &amp;mdash; stream write-ahead logs from a PostgreSQL server</source>
          <target state="translated">pg_receivewal &amp;mdash; PostgreSQL 서버에서 미리 쓰기 로그 스트림</target>
        </trans-unit>
        <trans-unit id="57337d575e5d67e54753c5901e40708eeba5bfa3" translate="yes" xml:space="preserve">
          <source>pg_receivewal can perform one of the two following actions in order to control physical replication slots:</source>
          <target state="translated">pg_receivewal은 물리적 복제 슬롯을 제어하기 위해 다음 두 가지 작업 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b99d484557f926ba9322617cdc90fdac93c874fa" translate="yes" xml:space="preserve">
          <source>pg_receivewal is used to stream the write-ahead log from a running PostgreSQL cluster. The write-ahead log is streamed using the streaming replication protocol, and is written to a local directory of files. This directory can be used as the archive location for doing a restore using point-in-time recovery (see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;).</source>
          <target state="translated">pg_receivewal은 실행중인 PostgreSQL 클러스터에서 미리 쓰기 로그를 스트리밍하는 데 사용됩니다. 미리 쓰기 로그는 스트리밍 복제 프로토콜을 사용하여 스트리밍되며 파일의 로컬 디렉토리에 기록됩니다. 이 디렉토리는 특정 시점 복구를 사용하여 복원을 수행하기위한 아카이브 위치로 사용될 수 있습니다 ( &lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ff89740628485b49733ba40c63ee1bd2c5fc5341" translate="yes" xml:space="preserve">
          <source>pg_receivewal streams the write-ahead log in real time as it's being generated on the server, and does not wait for segments to complete like &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; does. For this reason, it is not necessary to set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; when using pg_receivewal.</source>
          <target state="translated">pg_receivewal은 미리 쓰기 로그를 서버에서 생성 될 때 실시간으로 스트리밍하며 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 처럼 세그먼트가 완료 될 때까지 기다리지 않습니다. 따라서 pg_receivewal을 사용할 때 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; 을 설정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="db4efe6f6a91f9ac4c22014235d4941903efcda3" translate="yes" xml:space="preserve">
          <source>pg_receivewal will exit with status 0 when terminated by the SIGINT signal. (That is the normal way to end it. Hence it is not an error.) For fatal errors or other signals, the exit status will be nonzero.</source>
          <target state="translated">pg_receivewal은 SIGINT 신호에 의해 종료되면 상태 0으로 종료됩니다. (종료하는 일반적인 방법입니다. 따라서 오류가 아닙니다.) 치명적인 오류 또는 기타 신호의 경우 종료 상태는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="26440cf76205c66bbba0f1ef7928c60c117d0476" translate="yes" xml:space="preserve">
          <source>pg_receivewal will preserve group permissions on the received WAL files if group permissions are enabled on the source cluster.</source>
          <target state="translated">pg_receivewal은 소스 클러스터에서 그룹 권한이 활성화 된 경우 수신 된 WAL 파일에 대한 그룹 권한을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f518b9d9af81fd4207ef9135fe7fb771aaa09697" translate="yes" xml:space="preserve">
          <source>pg_recvlogical</source>
          <target state="translated">pg_recvlogical</target>
        </trans-unit>
        <trans-unit id="6da88adcafce4a1cb80eb5eae2a7affb239d8ddd" translate="yes" xml:space="preserve">
          <source>pg_recvlogical &amp;mdash; control PostgreSQL logical decoding streams</source>
          <target state="translated">pg_recvlogical &amp;mdash; PostgreSQL 논리 디코딩 스트림 제어</target>
        </trans-unit>
        <trans-unit id="f138a3233f7701f7bd0d97da69582123628c5a61" translate="yes" xml:space="preserve">
          <source>pg_recvlogical will preserve group permissions on the received WAL files if group permissions are enabled on the source cluster.</source>
          <target state="translated">pg_recvlogical은 소스 클러스터에서 그룹 권한이 활성화 된 경우 수신 된 WAL 파일에 대한 그룹 권한을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="754dc09cceaf6ea233c5f5643ba3aca03c10ebc7" translate="yes" xml:space="preserve">
          <source>pg_resetwal</source>
          <target state="translated">pg_resetwal</target>
        </trans-unit>
        <trans-unit id="818d00beab76c8e586ff07e5b2087a573e1add8b" translate="yes" xml:space="preserve">
          <source>pg_resetwal &amp;mdash; reset the write-ahead log and other control information of a PostgreSQL database cluster</source>
          <target state="translated">pg_resetwal &amp;mdash; PostgreSQL 데이터베이스 클러스터의 미리 쓰기 로그 및 기타 제어 정보를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="c6234470bdef81a74befac78cc2c427e186dfa6f" translate="yes" xml:space="preserve">
          <source>pg_restore</source>
          <target state="translated">pg_restore</target>
        </trans-unit>
        <trans-unit id="ca95d01c7a33bf71c3eea328ddfcdb1e56431966" translate="yes" xml:space="preserve">
          <source>pg_restore &amp;mdash; restore a PostgreSQL database from an archive file created by pg_dump</source>
          <target state="translated">pg_restore &amp;mdash; pg_dump에 의해 생성 된 아카이브 파일에서 PostgreSQL 데이터베이스를 복원</target>
        </trans-unit>
        <trans-unit id="ab496d205ea98a853ee3c68b03e5ccb4380184fd" translate="yes" xml:space="preserve">
          <source>pg_restore accepts the following command line arguments.</source>
          <target state="translated">pg_restore는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="19db1b034924755f0e95004ffeeaf863aa074742" translate="yes" xml:space="preserve">
          <source>pg_restore also accepts the following command line arguments for connection parameters:</source>
          <target state="translated">pg_restore는 연결 매개 변수에 대해 다음 명령 행 인수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4be105d36dd859e85e4e529a3d0c42289206d20c" translate="yes" xml:space="preserve">
          <source>pg_restore can operate in two modes. If a database name is specified, pg_restore connects to that database and restores archive contents directly into the database. Otherwise, a script containing the SQL commands necessary to rebuild the database is created and written to a file or standard output. This script output is equivalent to the plain text output format of pg_dump. Some of the options controlling the output are therefore analogous to pg_dump options.</source>
          <target state="translated">pg_restore는 두 가지 모드로 작동 할 수 있습니다. 데이터베이스 이름이 지정되면 pg_restore는 해당 데이터베이스에 연결하고 아카이브 내용을 데이터베이스에 직접 복원합니다. 그렇지 않으면 데이터베이스를 다시 빌드하는 데 필요한 SQL 명령이 포함 된 스크립트가 작성되어 파일 또는 표준 출력에 작성됩니다. 이 스크립트 출력은 pg_dump의 일반 텍스트 출력 형식과 같습니다. 따라서 출력을 제어하는 ​​일부 옵션은 pg_dump 옵션과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e3cc457529707f81114cd1448474b5e02b6e8f99" translate="yes" xml:space="preserve">
          <source>pg_restore cannot restore large objects selectively; for instance, only those for a specific table. If an archive contains large objects, then all large objects will be restored, or none of them if they are excluded via &lt;code&gt;-L&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, or other options.</source>
          <target state="translated">pg_restore는 큰 객체를 선택적으로 복원 할 수 없습니다. 예를 들어, 특정 테이블에 대한 것만. 아카이브에 큰 개체가 포함 된 경우 모든 큰 개체가 복원되거나 &lt;code&gt;-L&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; 또는 기타 옵션을 통해 제외 된 개체는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="956f1c367931d9683e268fe8d0c78e3b19e36f3a" translate="yes" xml:space="preserve">
          <source>pg_restore is a utility for restoring a PostgreSQL database from an archive created by &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; in one of the non-plain-text formats. It will issue the commands necessary to reconstruct the database to the state it was in at the time it was saved. The archive files also allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive files are designed to be portable across architectures.</source>
          <target state="translated">pg_restore는 &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 가 생성 한 아카이브 에서 일반 텍스트가 아닌 형식 으로 PostgreSQL 데이터베이스를 복원하는 유틸리티입니다 . 데이터베이스를 저장된 당시의 상태로 재구성하는 데 필요한 명령을 발행합니다. 아카이브 파일을 사용하면 pg_restore가 복원 대상을 선택하거나 복원하기 전에 항목을 다시 정렬 할 수도 있습니다. 아카이브 파일은 여러 아키텍처에서 이식 가능하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f80bd451e260233a7c84d3bfd4e0034f9f613a4" translate="yes" xml:space="preserve">
          <source>pg_rewind</source>
          <target state="translated">pg_rewind</target>
        </trans-unit>
        <trans-unit id="6636be6c84c6409c9a35bbfb0dbc37537161e15a" translate="yes" xml:space="preserve">
          <source>pg_rewind &amp;mdash; synchronize a PostgreSQL data directory with another data directory that was forked from it</source>
          <target state="translated">pg_rewind &amp;mdash; PostgreSQL 데이터 디렉토리를 분기 된 다른 데이터 디렉토리와 동기화</target>
        </trans-unit>
        <trans-unit id="1a5f33fb21f68bcc0a6323ed0e740d0bd790eb74" translate="yes" xml:space="preserve">
          <source>pg_rewind accepts the following command-line arguments:</source>
          <target state="translated">pg_rewind는 다음과 같은 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="53c10c8e611dacfe47f7b1a2084a81f3fd2dc876" translate="yes" xml:space="preserve">
          <source>pg_rewind examines the timeline histories of the source and target clusters to determine the point where they diverged, and expects to find WAL in the target cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory reaching all the way back to the point of divergence. The point of divergence can be found either on the target timeline, the source timeline, or their common ancestor. In the typical failover scenario where the target cluster was shut down soon after the divergence, this is not a problem, but if the target cluster ran for a long time after the divergence, the old WAL files might no longer be present. In that case, they can be manually copied from the WAL archive to the &lt;code&gt;pg_wal&lt;/code&gt; directory, or fetched on startup by configuring &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; or &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;. The use of pg_rewind is not limited to failover, e.g. a standby server can be promoted, run some write transactions, and then rewinded to become a standby again.</source>
          <target state="translated">pg_rewind는 소스 및 대상 클러스터의 타임 라인 기록을 검사하여 분기 지점을 확인하고 대상 클러스터의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에서 분기 지점까지 계속 도달 하는 WAL을 찾습니다 . 분기 지점은 대상 타임 라인, 소스 타임 라인 또는 공통 조상에서 찾을 수 있습니다. 분기 후 대상 클러스터가 곧 종료되는 일반적인 장애 조치 시나리오에서는 이것이 문제가되지 않지만 분기 후 오랫동안 대상 클러스터가 실행 된 경우 이전 WAL 파일이 더 이상 존재하지 않을 수 있습니다. 이 경우 WAL 아카이브에서 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 로 수동으로 복사 하거나 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 를 구성하여 시작시 가져올 수 있습니다. pg_rewind의 사용은 장애 조치로 제한되지 않습니다. 예를 들어 대기 서버를 승격시키고 일부 쓰기 트랜잭션을 실행 한 다음 되감기를 다시 대기 상태로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdc8d4062fab160de9805afabf418913c60bc57" translate="yes" xml:space="preserve">
          <source>pg_rewind is a tool for synchronizing a PostgreSQL cluster with another copy of the same cluster, after the clusters' timelines have diverged. A typical scenario is to bring an old master server back online after failover as a standby that follows the new master.</source>
          <target state="translated">pg_rewind는 클러스터의 타임 라인이 분기 된 후 PostgreSQL 클러스터를 동일한 클러스터의 다른 복사본과 동기화하는 도구입니다. 일반적인 시나리오는 새 마스터를 따르는 대기 모드로 장애 조치 후 이전 마스터 서버를 다시 온라인 상태로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d64189cb4ba992fd9873d2591fb756a57f4b1e2c" translate="yes" xml:space="preserve">
          <source>pg_rewind requires that the target server either has the &lt;a href=&quot;runtime-config-wal#GUC-WAL-LOG-HINTS&quot;&gt;wal_log_hints&lt;/a&gt; option enabled in &lt;code&gt;postgresql.conf&lt;/code&gt; or data checksums enabled when the cluster was initialized with initdb. Neither of these are currently on by default. &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but is enabled by default.</source>
          <target state="translated">pg_rewind를 사용하려면 대상 서버가 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LOG-HINTS&quot;&gt;wal_log_hints&lt;/a&gt; 옵션을 활성화 하거나 initdb로 클러스터를 초기화 할 때 데이터 체크섬을 활성화해야합니다. 이들 중 어느 것도 현재 기본적으로 켜져 있지 않습니다. &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 도 &lt;code&gt;on&lt;/code&gt; 으로 설정해야 하지만 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74f82f642c7becfe7ad885d63165ce9b214dce23" translate="yes" xml:space="preserve">
          <source>pg_rewind will fail immediately if it finds files it cannot write directly to. This can happen for example when the source and the target server use the same file mapping for read-only SSL keys and certificates. If such files are present on the target server it is recommended to remove them before running pg_rewind. After doing the rewind, some of those files may have been copied from the source, in which case it may be necessary to remove the data copied and restore back the set of links used before the rewind.</source>
          <target state="translated">pg_rewind는 직접 쓸 수없는 파일을 찾으면 즉시 실패합니다. 예를 들어, 소스와 대상 서버가 읽기 전용 SSL 키 및 인증서에 동일한 파일 맵핑을 사용하는 경우에 발생할 수 있습니다. 이러한 파일이 대상 서버에있는 경우 pg_rewind를 실행하기 전에 해당 파일을 제거하는 것이 좋습니다. 되감기를 수행 한 후 해당 파일 중 일부가 소스에서 복사되었을 수 있습니다.이 경우 복사 된 데이터를 제거하고 되감기 전에 사용 된 링크 세트를 다시 복원해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e80101e20d2867b25293eefce9d4a04d672b2671" translate="yes" xml:space="preserve">
          <source>pg_signal_backend</source>
          <target state="translated">pg_signal_backend</target>
        </trans-unit>
        <trans-unit id="aad2c0e43071f13f3222c0ba6eab09b7f30893b7" translate="yes" xml:space="preserve">
          <source>pg_standby</source>
          <target state="translated">pg_standby</target>
        </trans-unit>
        <trans-unit id="a56e931b58520268d70eefc4c64a9aa8bd3ed0c7" translate="yes" xml:space="preserve">
          <source>pg_stat_scan_tables</source>
          <target state="translated">pg_stat_scan_tables</target>
        </trans-unit>
        <trans-unit id="c182f3e761e7613ccff958112c789958486117fb" translate="yes" xml:space="preserve">
          <source>pg_stat_statements</source>
          <target state="translated">pg_stat_statements</target>
        </trans-unit>
        <trans-unit id="564e0a7d640b2d6ab107346798a953a06901e12c" translate="yes" xml:space="preserve">
          <source>pg_test_fsync</source>
          <target state="translated">pg_test_fsync</target>
        </trans-unit>
        <trans-unit id="d4a3eb8509e2f05ae585a775b4578c9dc9c7de51" translate="yes" xml:space="preserve">
          <source>pg_test_fsync &amp;mdash; determine fastest &lt;code&gt;wal_sync_method&lt;/code&gt; for PostgreSQL</source>
          <target state="translated">pg_test_fsync &amp;mdash; PostgreSQL에서 가장 빠른 &lt;code&gt;wal_sync_method&lt;/code&gt; 결정</target>
        </trans-unit>
        <trans-unit id="f6976c1c9983406c54c1e8e5692258977a8a0bbd" translate="yes" xml:space="preserve">
          <source>pg_test_fsync accepts the following command-line options:</source>
          <target state="translated">pg_test_fsync는 다음 명령 줄 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="35f3c773e39a7f66548a7f91bdc6fc654aeb8b43" translate="yes" xml:space="preserve">
          <source>pg_test_fsync is intended to give you a reasonable idea of what the fastest &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; is on your specific system, as well as supplying diagnostic information in the event of an identified I/O problem. However, differences shown by pg_test_fsync might not make any significant difference in real database throughput, especially since many database servers are not speed-limited by their write-ahead logs. pg_test_fsync reports average file sync operation time in microseconds for each &lt;code&gt;wal_sync_method&lt;/code&gt;, which can also be used to inform efforts to optimize the value of &lt;a href=&quot;runtime-config-wal#GUC-COMMIT-DELAY&quot;&gt;commit_delay&lt;/a&gt;.</source>
          <target state="translated">pg_test_fsync는 특정 시스템 에서 가장 빠른 &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; 가 무엇인지에 대한 합리적인 아이디어 를 제공하고 식별 된 I / O 문제 발생시 진단 정보를 제공하기위한 것입니다. 그러나 pg_test_fsync에 표시된 차이는 실제 데이터베이스 처리량에 큰 영향을 미치지 않을 수 있습니다. 특히 많은 데이터베이스 서버가 미리 쓰기 로그에 의해 속도 제한을받지 않기 때문입니다. pg_test_fsync는 각 &lt;code&gt;wal_sync_method&lt;/code&gt; 에 대한 평균 파일 동기화 작업 시간을 마이크로 초 단위로보고 하며 &lt;a href=&quot;runtime-config-wal#GUC-COMMIT-DELAY&quot;&gt;commit_delay&lt;/a&gt; 값을 최적화하기위한 노력을 알려주는 데 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83cc2633e28e387aaf13db93d466eb64fbb23327" translate="yes" xml:space="preserve">
          <source>pg_test_timing</source>
          <target state="translated">pg_test_timing</target>
        </trans-unit>
        <trans-unit id="f3f198929c632c68bfd97792c716e58ff1f864bf" translate="yes" xml:space="preserve">
          <source>pg_test_timing &amp;mdash; measure timing overhead</source>
          <target state="translated">pg_test_timing &amp;mdash; 타이밍 오버 헤드 측정</target>
        </trans-unit>
        <trans-unit id="e7e7fd0480719760f05328974c70beb596e23fe4" translate="yes" xml:space="preserve">
          <source>pg_test_timing accepts the following command-line options:</source>
          <target state="translated">pg_test_timing은 다음 명령 줄 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b9d0be3c84d75586efb4426191f97be9944b103e" translate="yes" xml:space="preserve">
          <source>pg_test_timing is a tool to measure the timing overhead on your system and confirm that the system time never moves backwards. Systems that are slow to collect timing data can give less accurate &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; results.</source>
          <target state="translated">pg_test_timing은 시스템의 타이밍 오버 헤드를 측정하고 시스템 시간이 절대로 뒤로 이동하지 않는지 확인하는 도구입니다. 타이밍 데이터 수집 속도가 느린 시스템은 덜 정확한 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 결과를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1a36c2a002cdeabf0a45ed04c4935a47efbcdf5" translate="yes" xml:space="preserve">
          <source>pg_trgm</source>
          <target state="translated">pg_trgm</target>
        </trans-unit>
        <trans-unit id="cba44b607c1052a326dda79f1d0ce35cdd115465" translate="yes" xml:space="preserve">
          <source>pg_upgrade</source>
          <target state="translated">pg_upgrade</target>
        </trans-unit>
        <trans-unit id="db12765aee1e8acd735eaba4a5cefc9809c12bc5" translate="yes" xml:space="preserve">
          <source>pg_upgrade &amp;mdash; upgrade a PostgreSQL server instance</source>
          <target state="translated">pg_upgrade &amp;mdash; PostgreSQL 서버 인스턴스 업그레이드</target>
        </trans-unit>
        <trans-unit id="1a476ffdc14a7d4aeeb3284fd6b093dea66779db" translate="yes" xml:space="preserve">
          <source>pg_upgrade (formerly called pg_migrator) allows data stored in PostgreSQL data files to be upgraded to a later PostgreSQL major version without the data dump/reload typically required for major version upgrades, e.g. from 9.5.8 to 9.6.4 or from 10.7 to 11.2. It is not required for minor version upgrades, e.g. from 9.6.2 to 9.6.3 or from 10.1 to 10.2.</source>
          <target state="translated">pg_upgrade (이전의 pg_migrator)를 사용하면 PostgreSQL 데이터 파일에 저장된 데이터를 주요 버전 업그레이드에 일반적으로 필요한 데이터 덤프 / 재로드없이 (예 : 9.5.8에서 9.6.4 또는 10.7에서 11.2) PostgreSQL 주 버전으로 업그레이드 할 수 있습니다. 부 버전 업그레이드에는 필요하지 않습니다 (예 : 9.6.2에서 9.6.3 또는 10.1에서 10.2).</target>
        </trans-unit>
        <trans-unit id="932eaff886c3896eeb52c391ab6acb1368335bbe" translate="yes" xml:space="preserve">
          <source>pg_upgrade accepts the following command-line arguments:</source>
          <target state="translated">pg_upgrade는 다음과 같은 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2d75641e412966ab64583947d2b63323e7cafe1a" translate="yes" xml:space="preserve">
          <source>pg_upgrade creates various working files, such as schema dumps, in the current working directory. For security, be sure that that directory is not readable or writable by any other users.</source>
          <target state="translated">pg_upgrade는 현재 작업 디렉토리에 스키마 덤프와 같은 다양한 작업 파일을 만듭니다. 보안을 위해 다른 사용자가 해당 디렉토리를 읽거나 쓸 수 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="578bd193f3c9b3d85257ebce226541a1e984626b" translate="yes" xml:space="preserve">
          <source>pg_upgrade does its best to make sure the old and new clusters are binary-compatible, e.g. by checking for compatible compile-time settings, including 32/64-bit binaries. It is important that any external modules are also binary compatible, though this cannot be checked by pg_upgrade.</source>
          <target state="translated">pg_upgrade는 예를 들어 32/64 비트 바이너리를 포함하여 호환 가능한 컴파일 시간 설정을 확인하여 이전 클러스터와 새 클러스터가 이진 호환 가능하도록 최선을 다합니다. pg_upgrade로 확인할 수는 없지만 모든 외부 모듈도 바이너리와 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f51d2be0d71ad87b7891c8abc6b1dd7e1c78b56" translate="yes" xml:space="preserve">
          <source>pg_upgrade does not support upgrading of databases containing table columns using these &lt;code&gt;reg*&lt;/code&gt; OID-referencing system data types: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. (&lt;code&gt;regtype&lt;/code&gt; can be upgraded.)</source>
          <target state="translated">pg_upgrade이 사용하는 테이블 컬럼 포함 된 데이터베이스의 업그레이드를 지원하지 않습니다 &lt;code&gt;reg*&lt;/code&gt; OID 참조하는 시스템 데이터 유형 : &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; 및 &lt;code&gt;regdictionary&lt;/code&gt; 을 . ( &lt;code&gt;regtype&lt;/code&gt; 을 업그레이드 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3e3d172eb2170af33d67a25363a94103aabed12a" translate="yes" xml:space="preserve">
          <source>pg_upgrade launches short-lived postmasters in the old and new data directories. Temporary Unix socket files for communication with these postmasters are, by default, made in the current working directory. In some situations the path name for the current directory might be too long to be a valid socket name. In that case you can use the &lt;code&gt;-s&lt;/code&gt; option to put the socket files in some directory with a shorter path name. For security, be sure that that directory is not readable or writable by any other users. (This is not relevant on Windows.)</source>
          <target state="translated">pg_upgrade는 기존 및 새 데이터 디렉토리에서 단기 포스트 마스터를 시작합니다. 이러한 포스트 마스터와 통신하기위한 임시 Unix 소켓 파일은 기본적으로 현재 작업 디렉토리에 작성됩니다. 경우에 따라 현재 디렉토리의 경로 이름이 너무 길어서 유효한 소켓 이름이 될 수 없습니다. 이 경우 &lt;code&gt;-s&lt;/code&gt; 옵션을 사용하여 소켓 파일을 경로 이름이 더 짧은 일부 디렉토리에 넣을 수 있습니다 . 보안을 위해 다른 사용자가 해당 디렉토리를 읽거나 쓸 수 없는지 확인하십시오. (Windows와는 관련이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="15ac306bacc2a60a72c1c9360e893d17d00be783" translate="yes" xml:space="preserve">
          <source>pg_upgrade supports upgrades from 8.4.X and later to the current major release of PostgreSQL, including snapshot and beta releases.</source>
          <target state="translated">pg_upgrade는 8.4.X 이상에서 스냅 샷 및 베타 릴리스를 포함한 PostgreSQL의 현재 주요 릴리스로의 업그레이드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="37c686f398a9bb31c2422ff4b08aeb2b525d7834" translate="yes" xml:space="preserve">
          <source>pg_visibility</source>
          <target state="translated">pg_visibility</target>
        </trans-unit>
        <trans-unit id="546e23c144574eee6d557036b662070f16964bb9" translate="yes" xml:space="preserve">
          <source>pg_waldump</source>
          <target state="translated">pg_waldump</target>
        </trans-unit>
        <trans-unit id="88429903c93bfb0478c87d3bda8bb2d8c8bf280f" translate="yes" xml:space="preserve">
          <source>pg_waldump &amp;mdash; display a human-readable rendering of the write-ahead log of a PostgreSQL database cluster</source>
          <target state="translated">pg_waldump &amp;mdash; PostgreSQL 데이터베이스 클러스터의 미리 쓰기 로그를 사람이 읽을 수있는 렌더링으로 표시합니다</target>
        </trans-unit>
        <trans-unit id="b40058a7035f42d82f70789b37d25d93facc1f44" translate="yes" xml:space="preserve">
          <source>pg_waldump cannot read WAL files with suffix &lt;code&gt;.partial&lt;/code&gt;. If those files need to be read, &lt;code&gt;.partial&lt;/code&gt; suffix needs to be removed from the file name.</source>
          <target state="translated">pg_waldump는 접미사가 &lt;code&gt;.partial&lt;/code&gt; 인 WAL 파일을 읽을 수 없습니다 . 해당 파일을 읽어야 하는 경우 파일 이름에서 &lt;code&gt;.partial&lt;/code&gt; 접미사를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2282bf04ae8a7a1e4aa1896740ba86b32012320" translate="yes" xml:space="preserve">
          <source>pg_write_server_files</source>
          <target state="translated">pg_write_server_files</target>
        </trans-unit>
        <trans-unit id="fe4faa584d303fc2dd774e2a7ced9c19e26a1c1d" translate="yes" xml:space="preserve">
          <source>pgbench</source>
          <target state="translated">pgbench</target>
        </trans-unit>
        <trans-unit id="245c76923352f6a7de2f5a1b3e955b0edd1157e6" translate="yes" xml:space="preserve">
          <source>pgbench &amp;mdash; run a benchmark test on PostgreSQL</source>
          <target state="translated">pgbench &amp;mdash; PostgreSQL에서 벤치 마크 테스트 실행</target>
        </trans-unit>
        <trans-unit id="190bcecdd132d2a68519fb2b781a6adfb4ddc0e3" translate="yes" xml:space="preserve">
          <source>pgbench accepts the following command-line benchmarking arguments:</source>
          <target state="translated">pgbench는 다음과 같은 명령 줄 벤치마킹 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="68b9788cb122c3e8aa31861bd9d7a75c5229ba5e" translate="yes" xml:space="preserve">
          <source>pgbench accepts the following command-line common arguments:</source>
          <target state="translated">pgbench는 다음과 같은 명령 줄 공통 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1405ebd8a8650e87de5d39651f4d5b65343f474b" translate="yes" xml:space="preserve">
          <source>pgbench accepts the following command-line initialization arguments:</source>
          <target state="translated">pgbench는 다음 명령 줄 초기화 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9746116a3b23b867ca385a3589051115eb6b8768" translate="yes" xml:space="preserve">
          <source>pgbench executes test scripts chosen randomly from a specified list. They include built-in scripts with &lt;code&gt;-b&lt;/code&gt; and user-provided custom scripts with &lt;code&gt;-f&lt;/code&gt;. Each script may be given a relative weight specified after a &lt;code&gt;@&lt;/code&gt; so as to change its drawing probability. The default weight is &lt;code&gt;1&lt;/code&gt;. Scripts with a weight of &lt;code&gt;0&lt;/code&gt; are ignored.</source>
          <target state="translated">pgbench는 지정된 목록에서 무작위로 선택된 테스트 스크립트를 실행합니다. 여기에는 &lt;code&gt;-b&lt;/code&gt; 가 포함 된 내장 스크립트와 &lt;code&gt;-f&lt;/code&gt; 가 포함 된 사용자 제공 사용자 정의 스크립트가 포함됩니다 . 각 스크립트에는 &lt;code&gt;@&lt;/code&gt; 다음에 지정된 상대 가중치가 부여되어 그리기 확률을 변경할 수 있습니다. 기본 가중치는 &lt;code&gt;1&lt;/code&gt; 입니다. 가중치가 &lt;code&gt;0&lt;/code&gt; 인 스크립트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aec38f1f442d7ff16e1fb7ab9b99473afffa334c" translate="yes" xml:space="preserve">
          <source>pgbench has support for running custom benchmark scenarios by replacing the default transaction script (described above) with a transaction script read from a file (&lt;code&gt;-f&lt;/code&gt; option). In this case a &amp;ldquo;transaction&amp;rdquo; counts as one execution of a script file.</source>
          <target state="translated">pgbench는 기본 트랜잭션 스크립트 (위에서 설명 함)를 파일에서 읽은 트랜잭션 스크립트 ( &lt;code&gt;-f&lt;/code&gt; 옵션) 로 대체하여 사용자 정의 벤치 마크 시나리오 실행을 지원합니다 . 이 경우 &quot;트랜잭션&quot;은 스크립트 파일의 한 번의 실행으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="babde96d8ded7d5bdc20bc24ab75503073b3895f" translate="yes" xml:space="preserve">
          <source>pgbench is a simple program for running benchmark tests on PostgreSQL. It runs the same sequence of SQL commands over and over, possibly in multiple concurrent database sessions, and then calculates the average transaction rate (transactions per second). By default, pgbench tests a scenario that is loosely based on TPC-B, involving five &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; commands per transaction. However, it is easy to test other cases by writing your own transaction script files.</source>
          <target state="translated">pgbench는 PostgreSQL에서 벤치 마크 테스트를 실행하기위한 간단한 프로그램입니다. 여러 동시 데이터베이스 세션에서 동일한 SQL 명령 시퀀스를 반복해서 실행 한 다음 평균 트랜잭션 속도 (초당 트랜잭션)를 계산합니다. 기본적으로 pgbench 는 트랜잭션 당 5 개의 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; 명령이 포함 된 TPC-B를 기반으로하는 시나리오를 테스트 합니다. 그러나 자체 트랜잭션 스크립트 파일을 작성하여 다른 사례를 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fab810234a95f67305254aa81ec2b657d21bac4" translate="yes" xml:space="preserve">
          <source>pgbench's implementation is based on &quot;Non-Uniform Random Variate Generation&quot;, Luc Devroye, p. 550-551, Springer 1986. Due to limitations of that algorithm, the &lt;code&gt;parameter&lt;/code&gt; value is restricted to the range [1.001, 1000].</source>
          <target state="translated">pgbench의 구현은 &quot;비 균일 무작위 변형 생성&quot;, Luc Devroye, p. 550-551, Springer 1986.이 알고리즘의 한계로 인해 &lt;code&gt;parameter&lt;/code&gt; 값은 [1.001, 1000] 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="630caf5598ccb0bc5c66255e525f41ce5c906c41" translate="yes" xml:space="preserve">
          <source>pgcrypto</source>
          <target state="translated">pgcrypto</target>
        </trans-unit>
        <trans-unit id="9a9bd59965b3ffd5f41cb5b0367c199ea55c00b3" translate="yes" xml:space="preserve">
          <source>pgpool-II</source>
          <target state="translated">pgpool-II</target>
        </trans-unit>
        <trans-unit id="9489f59aeab8215239a1109df9f4ca10adf1fe8e" translate="yes" xml:space="preserve">
          <source>pgrowlocks</source>
          <target state="translated">pgrowlocks</target>
        </trans-unit>
        <trans-unit id="1cd76ab24bde38e5fa0a0e278f738a576c68fc4d" translate="yes" xml:space="preserve">
          <source>pgstattuple</source>
          <target state="translated">pgstattuple</target>
        </trans-unit>
        <trans-unit id="0b6b7db1f468b507eab5c49dd59287bcfd5c48c3" translate="yes" xml:space="preserve">
          <source>phantom read</source>
          <target state="translated">팬텀 읽기</target>
        </trans-unit>
        <trans-unit id="6cfbf2e993e254c5b33748bce7c5b2fef2c905de" translate="yes" xml:space="preserve">
          <source>planner statistics</source>
          <target state="translated">플래너 통계</target>
        </trans-unit>
        <trans-unit id="b5447bde33f10b6359a65bcf167f9f8778a245da" translate="yes" xml:space="preserve">
          <source>plus sign in specified position (if number &amp;gt; 0)</source>
          <target state="translated">지정된 위치에 더하기 부호 (숫자&amp;gt; 0 인 경우)</target>
        </trans-unit>
        <trans-unit id="4eabb21ebd678c553f80333411576e18b7c6113e" translate="yes" xml:space="preserve">
          <source>plus/minus sign in specified position</source>
          <target state="translated">지정된 위치의 더하기 / 빼기 기호</target>
        </trans-unit>
        <trans-unit id="339dc3363c545578a35444d39ca9832d8fed2693" translate="yes" xml:space="preserve">
          <source>point to empty box</source>
          <target state="translated">빈 상자를 가리킴</target>
        </trans-unit>
        <trans-unit id="469ea8ee30e53a20d2b688c624f215eea08e0b21" translate="yes" xml:space="preserve">
          <source>points to box</source>
          <target state="translated">상자를 가리킴</target>
        </trans-unit>
        <trans-unit id="75cb84871a07d724e7282a8e54779a0bca207e4c" translate="yes" xml:space="preserve">
          <source>points to line</source>
          <target state="translated">선을 가리킴</target>
        </trans-unit>
        <trans-unit id="7eaf8061fddd8df9a3125cdf60df4bc0c9a066c1" translate="yes" xml:space="preserve">
          <source>points to line segment</source>
          <target state="translated">선분을 가리킴</target>
        </trans-unit>
        <trans-unit id="e757f5e64a2b87ba44d756bec784fbc3b9b25240" translate="yes" xml:space="preserve">
          <source>policies</source>
          <target state="translated">policies</target>
        </trans-unit>
        <trans-unit id="408a5771606748ff56935b5d1da14d2d738d90b8" translate="yes" xml:space="preserve">
          <source>polygon</source>
          <target state="translated">polygon</target>
        </trans-unit>
        <trans-unit id="1fe627e496249ff689da09f1af8a3f608320f1a2" translate="yes" xml:space="preserve">
          <source>polygon to box</source>
          <target state="translated">상자에 다각형</target>
        </trans-unit>
        <trans-unit id="e65c8a6ee032bad896e52a6d51df628bb54741d8" translate="yes" xml:space="preserve">
          <source>polygon to circle</source>
          <target state="translated">다각형 대 원</target>
        </trans-unit>
        <trans-unit id="075b578ac8e782d35cac54fab519b2a2981bc89f" translate="yes" xml:space="preserve">
          <source>polygon to path</source>
          <target state="translated">경로에 다각형</target>
        </trans-unit>
        <trans-unit id="c3c4ff64c117cb4046ac95814764274a611eadc9" translate="yes" xml:space="preserve">
          <source>population covariance</source>
          <target state="translated">인구 공분산</target>
        </trans-unit>
        <trans-unit id="b452fd4c478086ef7a14516e40b822a09ff62833" translate="yes" xml:space="preserve">
          <source>population standard deviation of the input values</source>
          <target state="translated">입력 값의 모집단 표준 편차</target>
        </trans-unit>
        <trans-unit id="f740a71816fcb8405e1c34d0bbda7430e02f052e" translate="yes" xml:space="preserve">
          <source>population variance of the input values (square of the population standard deviation)</source>
          <target state="translated">입력 값의 모집단 분산 (집단 표준 편차의 제곱)</target>
        </trans-unit>
        <trans-unit id="ddbaa205a7ea7a2d200998c54ca41d802bcbfd44" translate="yes" xml:space="preserve">
          <source>port of the local connection</source>
          <target state="translated">로컬 연결 포트</target>
        </trans-unit>
        <trans-unit id="87064c70cafd74317278b63c5b157cd735fdf360" translate="yes" xml:space="preserve">
          <source>port of the remote connection</source>
          <target state="translated">원격 연결 포트</target>
        </trans-unit>
        <trans-unit id="96a7749d440357880e5a976d2fd59e31720bb064" translate="yes" xml:space="preserve">
          <source>portion of array starting at position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 에서 시작하는 배열의 일부&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6779ce971cf67554824777a128c0dad919c2eb2" translate="yes" xml:space="preserve">
          <source>portion of array starting at position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; elements</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 에서 시작하는 배열의 일부 , &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 요소</target>
        </trans-unit>
        <trans-unit id="4645518782ef67f072236132657362fb96e3e1c1" translate="yes" xml:space="preserve">
          <source>position of first occurrence of &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt; in &lt;em&gt;&lt;code&gt;a&lt;/code&gt;&lt;/em&gt;, searching starting at &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;; negative &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; means start &lt;em&gt;&lt;code&gt;-offset&lt;/code&gt;&lt;/em&gt; labels from the end of the path</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작하여 검색 &lt;em&gt; &lt;code&gt;a&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt; 에서 &lt;em&gt;b&lt;/em&gt; 의 첫 번째 발생 위치 ; 음수 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 은 경로 끝에서 시작 &lt;em&gt; &lt;code&gt;-offset&lt;/code&gt; &lt;/em&gt; 레이블을 의미 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1bd6b6e8ca0e52e97dc3a0c4f3cebf095aa90b7" translate="yes" xml:space="preserve">
          <source>position of first occurrence of &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt; in &lt;em&gt;&lt;code&gt;a&lt;/code&gt;&lt;/em&gt;; -1 if not found</source>
          <target state="translated">처음 나타나는 위치 &lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt; 에서 ; 찾을 수없는 경우 -1&lt;em&gt; &lt;code&gt;a&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="afc848c316af1a89d49826c5ae9d00ed769415f3" translate="yes" xml:space="preserve">
          <source>postgres</source>
          <target state="translated">postgres</target>
        </trans-unit>
        <trans-unit id="8390740c441882222c2362f52cee5c919ebfa7e2" translate="yes" xml:space="preserve">
          <source>postgres &amp;mdash; PostgreSQL database server</source>
          <target state="translated">postgres &amp;mdash; PostgreSQL 데이터베이스 서버</target>
        </trans-unit>
        <trans-unit id="f5b569dfbe79173f90e1b22c4a9d9ef1d17d6ff5" translate="yes" xml:space="preserve">
          <source>postgres_fdw</source>
          <target state="translated">postgres_fdw</target>
        </trans-unit>
        <trans-unit id="97607be36098a11ebbd418e8cb692e80c46220f1" translate="yes" xml:space="preserve">
          <source>postmaster</source>
          <target state="translated">postmaster</target>
        </trans-unit>
        <trans-unit id="db9882a50c59d73039601dcb6fde5eebfad74950" translate="yes" xml:space="preserve">
          <source>postmaster &amp;mdash; PostgreSQL database server</source>
          <target state="translated">postmaster &amp;mdash; PostgreSQL 데이터베이스 서버</target>
        </trans-unit>
        <trans-unit id="61fb54e7e590d7cad09c692298af99246641fc3b" translate="yes" xml:space="preserve">
          <source>prepared statements</source>
          <target state="translated">준비된 진술</target>
        </trans-unit>
        <trans-unit id="9350bfebf12d74a4f13ad68c3478192c9952b02c" translate="yes" xml:space="preserve">
          <source>prepared transactions</source>
          <target state="translated">준비된 거래</target>
        </trans-unit>
        <trans-unit id="c7a0eda00d411aa762901238aba5394b820b1e5f" translate="yes" xml:space="preserve">
          <source>print &lt;code&gt;a&lt;/code&gt; to stderr, and return &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">stderr에 &lt;code&gt;a&lt;/code&gt; 를 인쇄 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd13efcdda80e14e3ff6f29792578d886340f030" translate="yes" xml:space="preserve">
          <source>probably means your kernel's limit on the size of shared memory is smaller than the work area PostgreSQL is trying to create (4011376640 bytes in this example). Or it could mean that you do not have System-V-style shared memory support configured into your kernel at all. As a temporary workaround, you can try starting the server with a smaller-than-normal number of buffers (&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;). You will eventually want to reconfigure your kernel to increase the allowed shared memory size. You might also see this message when trying to start multiple servers on the same machine, if their total space requested exceeds the kernel limit.</source>
          <target state="translated">아마도 공유 메모리 크기에 대한 커널의 제한이 PostgreSQL이 생성하려고하는 작업 영역 (이 예에서는 4011376640 바이트)보다 작다는 것을 의미합니다. 또는 커널에 System-V 스타일 공유 메모리 지원이 전혀 구성되어 있지 않을 수도 있습니다. 임시 해결 방법으로, 정상보다 적은 수의 버퍼 ( &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; )로 서버를 시작할 수 있습니다 . 허용 된 공유 메모리 크기를 늘리기 위해 커널을 재구성하려고 할 것입니다. 요청 된 총 공간이 커널 한계를 초과하는 경우 동일한 시스템에서 여러 서버를 시작하려고 할 때이 메시지가 표시 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5eb476d6ced75dc0f494167f046c38238d16ca3" translate="yes" xml:space="preserve">
          <source>produce &lt;code&gt;tsquery&lt;/code&gt; from a web search style query</source>
          <target state="translated">웹 검색 스타일 쿼리에서 &lt;code&gt;tsquery&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="d843088914396896c8a6ccbd1400e89c8769a944" translate="yes" xml:space="preserve">
          <source>produce &lt;code&gt;tsquery&lt;/code&gt; ignoring punctuation</source>
          <target state="translated">문장 부호를 무시하고 &lt;code&gt;tsquery&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="737a676c9e9772615b88a960070fc05c74241bc2" translate="yes" xml:space="preserve">
          <source>produce &lt;code&gt;tsquery&lt;/code&gt; that searches for a phrase, ignoring punctuation</source>
          <target state="translated">문장 부호를 무시하고 구문을 검색 하는 &lt;code&gt;tsquery&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="d11e992305f12419f753193a9fd40fdcec1d7209" translate="yes" xml:space="preserve">
          <source>produce debugging output in &lt;code&gt;cleanup.log&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cleanup.log&lt;/code&gt; 에서 디버깅 출력 생성</target>
        </trans-unit>
        <trans-unit id="cf7f38c1536eab5569d86ce758482414f719bea3" translate="yes" xml:space="preserve">
          <source>proves server certificate was sent by the owner; does not indicate certificate owner is trustworthy</source>
          <target state="translated">소유자가 서버 인증서를 보냈다는 것을 증명합니다. 인증서 소유자가 신뢰할 수 있음을 나타내지 않습니다</target>
        </trans-unit>
        <trans-unit id="15fbbe3ec90e89c9a42166e95d352669a7d04728" translate="yes" xml:space="preserve">
          <source>psql</source>
          <target state="translated">psql</target>
        </trans-unit>
        <trans-unit id="fca46a43005a869700891f785840854a10a5e6c1" translate="yes" xml:space="preserve">
          <source>psql &amp;mdash; PostgreSQL interactive terminal</source>
          <target state="translated">psql &amp;mdash; PostgreSQL 대화식 터미널</target>
        </trans-unit>
        <trans-unit id="347fa40df625faa5bd528852ecb450c286d4db96" translate="yes" xml:space="preserve">
          <source>psql Command</source>
          <target state="translated">psql 명령</target>
        </trans-unit>
        <trans-unit id="a5e04b58c747ee3884ce2400c147b7d3bcf98e2f" translate="yes" xml:space="preserve">
          <source>psql Support</source>
          <target state="translated">psql 지원</target>
        </trans-unit>
        <trans-unit id="95e125fea70f6101322b293b37180b375e82e943" translate="yes" xml:space="preserve">
          <source>psql is a regular PostgreSQL client application. In order to connect to a database you need to know the name of your target database, the host name and port number of the server, and what user name you want to connect as. psql can be told about those parameters via command line options, namely &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and &lt;code&gt;-U&lt;/code&gt; respectively. If an argument is found that does not belong to any option it will be interpreted as the database name (or the user name, if the database name is already given). Not all of these options are required; there are useful defaults. If you omit the host name, psql will connect via a Unix-domain socket to a server on the local host, or via TCP/IP to &lt;code&gt;localhost&lt;/code&gt; on machines that don't have Unix-domain sockets. The default port number is determined at compile time. Since the database server uses the same default, you will not have to specify the port in most cases. The default user name is your operating-system user name, as is the default database name. Note that you cannot just connect to any database under any user name. Your database administrator should have informed you about your access rights.</source>
          <target state="translated">psql은 일반적인 PostgreSQL 클라이언트 응용 프로그램입니다. 데이터베이스에 연결하려면 대상 데이터베이스의 이름, 서버의 호스트 이름 및 포트 번호 및 연결하려는 사용자 이름을 알아야합니다. psql은 명령 행 옵션, 즉 각각 &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;-U&lt;/code&gt; 를 통해 이러한 매개 변수에 대해 알 수 있습니다 . 옵션에 속하지 않는 인수가 있으면 데이터베이스 이름 (또는 데이터베이스 이름이 이미 제공된 경우 사용자 이름)으로 해석됩니다. 이러한 옵션이 모두 필요한 것은 아닙니다. 유용한 기본값이 있습니다. 호스트 이름을 생략하면 psql은 Unix 도메인 소켓을 통해 로컬 호스트의 서버에 연결하거나 TCP / IP를 통해 &lt;code&gt;localhost&lt;/code&gt; 에 연결합니다.유닉스 도메인 소켓이없는 머신에서. 기본 포트 번호는 컴파일 타임에 결정됩니다. 데이터베이스 서버는 동일한 기본값을 사용하므로 대부분의 경우 포트를 지정할 필요가 없습니다. 기본 사용자 이름은 기본 데이터베이스 이름과 마찬가지로 운영 체제 사용자 이름입니다. 사용자 이름으로 데이터베이스에 연결할 수는 없습니다. 데이터베이스 관리자가 액세스 권한에 대해 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b7bd245882c2b30f2066333f8b2b51dbe7b4bee" translate="yes" xml:space="preserve">
          <source>psql is a terminal-based front-end to PostgreSQL. It enables you to type in queries interactively, issue them to PostgreSQL, and see the query results. Alternatively, input can be from a file or from command line arguments. In addition, psql provides a number of meta-commands and various shell-like features to facilitate writing scripts and automating a wide variety of tasks.</source>
          <target state="translated">psql은 PostgreSQL의 터미널 기반 프런트 엔드입니다. 대화식으로 쿼리를 입력하고 PostgreSQL에 쿼리하고 쿼리 결과를 볼 수 있습니다. 또는 입력은 파일 또는 명령 행 인수에서 입력 될 수 있습니다. 또한 psql은 스크립트 작성 및 다양한 작업 자동화를 용이하게하는 여러 가지 메타 명령과 다양한 쉘 유사 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b22c3083f3acff373849bd925841c6ca17029691" translate="yes" xml:space="preserve">
          <source>psql is built as a &amp;ldquo;console application&amp;rdquo;. Since the Windows console windows use a different encoding than the rest of the system, you must take special care when using 8-bit characters within psql. If psql detects a problematic console code page, it will warn you at startup. To change the console code page, two things are necessary:</source>
          <target state="translated">psql은&amp;ldquo;콘솔 응용 프로그램&amp;rdquo;으로 구축되었습니다. Windows 콘솔 창은 나머지 시스템과 다른 인코딩을 사용하므로 psql 내에서 8 비트 문자를 사용할 때는 특히주의해야합니다. psql이 문제가있는 콘솔 코드 페이지를 감지하면 시작시 경고를 표시합니다. 콘솔 코드 페이지를 변경하려면 두 가지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f42826a99d3a8b74d1cfec2913f0d508a2a89747" translate="yes" xml:space="preserve">
          <source>psql provides variable substitution features similar to common Unix command shells. Variables are simply name/value pairs, where the value can be any string of any length. The name must consist of letters (including non-Latin letters), digits, and underscores.</source>
          <target state="translated">psql은 일반적인 Unix 명령 쉘과 유사한 변수 대체 기능을 제공합니다. 변수는 단순히 이름 / 값 쌍이며, 값은 임의 길이의 문자열 일 수 있습니다. 이름은 문자 (라틴 문자 이외의 문자 포함), 숫자 및 밑줄로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6e54522ea4611b9507672c9989cd73e23e597ad" translate="yes" xml:space="preserve">
          <source>psql returns 0 to the shell if it finished normally, 1 if a fatal error of its own occurs (e.g. out of memory, file not found), 2 if the connection to the server went bad and the session was not interactive, and 3 if an error occurred in a script and the variable &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; was set.</source>
          <target state="translated">psql이 정상적으로 완료되면 0을 쉘에 반환하고, 자체 치명적인 오류 (예 : 메모리 부족, 파일을 찾을 수 없음)가 발생하면 2, 서버에 대한 연결이 잘못되어 세션이 대화식이 아닌 경우 3, 스크립트에서 오류가 발생했으며 변수 &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; 이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb629d8072664137a941709037828dd50c9b9da4" translate="yes" xml:space="preserve">
          <source>psql supports the Readline library for convenient line editing and retrieval. The command history is automatically saved when psql exits and is reloaded when psql starts up. Tab-completion is also supported, although the completion logic makes no claim to be an SQL parser. The queries generated by tab-completion can also interfere with other SQL commands, e.g. &lt;code&gt;SET TRANSACTION ISOLATION LEVEL&lt;/code&gt;. If for some reason you do not like the tab completion, you can turn it off by putting this in a file named &lt;code&gt;.inputrc&lt;/code&gt; in your home directory:</source>
          <target state="translated">psql은 편리한 라인 편집 및 검색을 위해 Readline 라이브러리를 지원합니다. psql이 종료되면 명령 기록이 자동으로 저장되고 psql이 시작되면 다시로드됩니다. 완료 논리가 SQL 구문 분석기라고 주장하지는 않지만 탭 완성도 지원됩니다. 탭 완성으로 생성 된 쿼리는 다른 SQL 명령 (예 : &lt;code&gt;SET TRANSACTION ISOLATION LEVEL&lt;/code&gt; )을 방해 할 수도 있습니다 . 어떤 이유로 탭 완성이 마음에 들지 않으면이를 홈 디렉토리의 &lt;code&gt;.inputrc&lt;/code&gt; 라는 파일에 넣어서 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a16e3c52a81da60949a222ec1f2beace78fd46bd" translate="yes" xml:space="preserve">
          <source>psql will print this command tag only if the command was not &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt;, or the equivalent psql meta-command &lt;code&gt;\copy ... to stdout&lt;/code&gt;. This is to prevent confusing the command tag with the data that was just printed.</source>
          <target state="translated">psql은 명령이 &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; 이 아니 거나 동등한 psql meta-command &lt;code&gt;\copy ... to stdout&lt;/code&gt; 경우에만이 명령 태그를 인쇄합니다 . 이것은 명령 태그를 방금 인쇄 된 데이터와 혼동하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9030a8d8a8e0a797144de8dad2ab91ccd68b521" translate="yes" xml:space="preserve">
          <source>psql works best with servers of the same or an older major version. Backslash commands are particularly likely to fail if the server is of a newer version than psql itself. However, backslash commands of the &lt;code&gt;\d&lt;/code&gt; family should work with servers of versions back to 7.4, though not necessarily with servers newer than psql itself. The general functionality of running SQL commands and displaying query results should also work with servers of a newer major version, but this cannot be guaranteed in all cases.</source>
          <target state="translated">psql은 동일하거나 이전 버전의 서버에서 가장 잘 작동합니다. 서버가 psql 자체보다 최신 버전 인 경우 특히 백 ​​슬래시 명령이 실패 할 수 있습니다. 그러나 &lt;code&gt;\d&lt;/code&gt; 제품군 의 백 슬래시 명령은 psql 자체보다 새로운 서버 일 필요는 없지만 버전 7.4의 서버에서는 작동해야합니다. SQL 명령을 실행하고 쿼리 결과를 표시하는 일반적인 기능도 최신 주 버전의 서버에서 작동해야하지만 모든 경우에 이것이 보장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f688be98f5b8c1f64cb5029d985e2970051ea65a" translate="yes" xml:space="preserve">
          <source>publications and their associated tables</source>
          <target state="translated">간행물 및 관련 테이블</target>
        </trans-unit>
        <trans-unit id="32cdbe585cee84aaf7b83fff94029a9d86ceddaa" translate="yes" xml:space="preserve">
          <source>publications for logical replication</source>
          <target state="translated">논리적 복제를위한 출판물</target>
        </trans-unit>
        <trans-unit id="09b662744d3b70e3c297a816849f207244de2aa4" translate="yes" xml:space="preserve">
          <source>push element onto array (add it to end of array)</source>
          <target state="translated">요소를 배열로 푸시 (배열 끝에 추가)</target>
        </trans-unit>
        <trans-unit id="7fa1f94325c1f93ccb98d699eacb2bfd7d300dc2" translate="yes" xml:space="preserve">
          <source>quarter</source>
          <target state="translated">quarter</target>
        </trans-unit>
        <trans-unit id="25254f339a98dbc5a3b1dfb9ae984fdeecd56b20" translate="yes" xml:space="preserve">
          <source>query rewrite rules</source>
          <target state="translated">쿼리 다시 쓰기 규칙</target>
        </trans-unit>
        <trans-unit id="642953c903e225c7ba0c3da75015e01837b730d3" translate="yes" xml:space="preserve">
          <source>radians to degrees</source>
          <target state="translated">라디안을도</target>
        </trans-unit>
        <trans-unit id="101ff7a6595f39b284bb822cf9f8e2f159302ecf" translate="yes" xml:space="preserve">
          <source>radius of circle</source>
          <target state="translated">원의 반경</target>
        </trans-unit>
        <trans-unit id="d06226ac77f8f5ba216268c5c76122beb3306150" translate="yes" xml:space="preserve">
          <source>random generator seed (unless overwritten with &lt;code&gt;-D&lt;/code&gt;)</source>
          <target state="translated">랜덤 생성기 시드 ( &lt;code&gt;-D&lt;/code&gt; 로 덮어 쓰지 않는 한 )</target>
        </trans-unit>
        <trans-unit id="991aabe67a8a06e97c39a7db711c50ff461e9b21" translate="yes" xml:space="preserve">
          <source>random value in the range 0.0 &amp;lt;= x &amp;lt; 1.0</source>
          <target state="translated">0.0 &amp;lt;= x &amp;lt;1.0 범위의 난수</target>
        </trans-unit>
        <trans-unit id="2613a16780a46e105e48eb6131089e98895939e1" translate="yes" xml:space="preserve">
          <source>range containment, set membership, string matching</source>
          <target state="translated">범위 억제, 멤버십 설정, 문자열 일치</target>
        </trans-unit>
        <trans-unit id="dbd5a79f25e51a24132457cea5c33398a113cab2" translate="yes" xml:space="preserve">
          <source>range is contained by</source>
          <target state="translated">범위는</target>
        </trans-unit>
        <trans-unit id="d64c6f39222c05f598d1e3361aa6949b4308b3a8" translate="yes" xml:space="preserve">
          <source>range's element type</source>
          <target state="translated">범위의 요소 유형</target>
        </trans-unit>
        <trans-unit id="069624e6963a6be975b7cc2a6d79ce1e4e392e23" translate="yes" xml:space="preserve">
          <source>rank document for query</source>
          <target state="translated">검색어 순위 문서</target>
        </trans-unit>
        <trans-unit id="7905619b1f220805fc4b27c39f18646781254c7a" translate="yes" xml:space="preserve">
          <source>rank document for query using cover density</source>
          <target state="translated">표지 밀도를 사용하여 쿼리에 대한 순위 문서</target>
        </trans-unit>
        <trans-unit id="42e62ae935036c81180fd1b96a0d131ace6d62cd" translate="yes" xml:space="preserve">
          <source>rank of the current row with gaps; same as &lt;code&gt;row_number&lt;/code&gt; of its first peer</source>
          <target state="translated">간격이있는 현재 행의 순위; 첫 번째 피어의 &lt;code&gt;row_number&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="1c957e7d462191d34d9b87b7a9dfb0016feca8ae" translate="yes" xml:space="preserve">
          <source>rank of the current row without gaps; this function counts peer groups</source>
          <target state="translated">간격없이 현재 행의 순위; 이 함수는 피어 그룹을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="15e40867aed4cd80a2d2990e6249bf25cd91e548" translate="yes" xml:space="preserve">
          <source>rank of the hypothetical row, with gaps for duplicate rows</source>
          <target state="translated">중복 행의 간격이있는 가상 행의 순위</target>
        </trans-unit>
        <trans-unit id="1a0a39c75abd6da6c39b8fac3443be9d12755c52" translate="yes" xml:space="preserve">
          <source>rank of the hypothetical row, without gaps</source>
          <target state="translated">간격없이 가상 행의 순위</target>
        </trans-unit>
        <trans-unit id="82b524d90dbcf160ddb4a560d1503123520ae7c4" translate="yes" xml:space="preserve">
          <source>rather than:</source>
          <target state="translated">오히려</target>
        </trans-unit>
        <trans-unit id="e2f19716babfc608f3ce223697ed0ba39d2f7f7f" translate="yes" xml:space="preserve">
          <source>rectangular box on a plane</source>
          <target state="translated">평면에 직사각형 상자</target>
        </trans-unit>
        <trans-unit id="37151e24d7e9197d44b4f0dc711ed6382e5e405a" translate="yes" xml:space="preserve">
          <source>reduce document text to &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 로 문서 텍스트 축소</target>
        </trans-unit>
        <trans-unit id="79dbda1f3b73509078526efded3d2f3d32809d63" translate="yes" xml:space="preserve">
          <source>reduce each string value in the document to a &lt;code&gt;tsvector&lt;/code&gt;, and then concatenate those in document order to produce a single &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">문서의 각 문자열 값을 &lt;code&gt;tsvector&lt;/code&gt; 로 줄이고 문서의 문자열 값 을 연결하여 단일 &lt;code&gt;tsvector&lt;/code&gt; 를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1250b7cb90774e995b4514a5d5654a66de678684" translate="yes" xml:space="preserve">
          <source>reduce each value in the document, specified by &lt;code&gt;filter&lt;/code&gt; to a &lt;code&gt;tsvector&lt;/code&gt;, and then concatenate those in document order to produce a single &lt;code&gt;tsvector&lt;/code&gt;. &lt;code&gt;filter&lt;/code&gt; is a &lt;code&gt;jsonb&lt;/code&gt; array, that enumerates what kind of elements need to be included into the resulting &lt;code&gt;tsvector&lt;/code&gt;. Possible values for &lt;code&gt;filter&lt;/code&gt; are &lt;code&gt;&quot;string&quot;&lt;/code&gt; (to include all string values), &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; (to include all numeric values in the string format), &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; (to include all Boolean values in the string format &lt;code&gt;&quot;true&quot;&lt;/code&gt;/&lt;code&gt;&quot;false&quot;&lt;/code&gt;), &lt;code&gt;&quot;key&quot;&lt;/code&gt; (to include all keys) or &lt;code&gt;&quot;all&quot;&lt;/code&gt; (to include all above). These values can be combined together to include, e.g. all string and numeric values.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 로 지정된 문서의 각 값을 &lt;code&gt;tsvector&lt;/code&gt; 로 줄이고 문서의 값 을 연결하여 단일 &lt;code&gt;tsvector&lt;/code&gt; 를 만듭니다 . &lt;code&gt;filter&lt;/code&gt; 는 &lt;code&gt;jsonb&lt;/code&gt; 배열이며, 결과 &lt;code&gt;tsvector&lt;/code&gt; 에 어떤 종류의 요소를 포함 해야하는지 열거 합니다. &lt;code&gt;filter&lt;/code&gt; 사용할 수있는 값 은 &lt;code&gt;&quot;string&quot;&lt;/code&gt; (모든 문자열 값 포함), &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; (문자열 형식의 모든 숫자 값 포함), &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; (문자열 형식의 모든 부울 값 포함 &lt;code&gt;&quot;true&quot;&lt;/code&gt; / &lt;code&gt;&quot;false&quot;&lt;/code&gt; ), &lt;code&gt;&quot;key&quot;&lt;/code&gt; (모든 키 포함) 또는 &lt;code&gt;&quot;all&quot;&lt;/code&gt; (위에 모두 포함) 이러한 값을 결합하여 모든 문자열 및 숫자 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4039072cefb5e0e74fe21ef2eb4a0339c3c8dc4e" translate="yes" xml:space="preserve">
          <source>regional style</source>
          <target state="translated">지역 스타일</target>
        </trans-unit>
        <trans-unit id="926c6c489eca334e575a3c27916c7d476217b0a9" translate="yes" xml:space="preserve">
          <source>registered replication origins</source>
          <target state="translated">등록 된 복제 출처</target>
        </trans-unit>
        <trans-unit id="30cc491139c5bb6825ec1bb708cbc29e19e42c6e" translate="yes" xml:space="preserve">
          <source>reindexdb</source>
          <target state="translated">reindexdb</target>
        </trans-unit>
        <trans-unit id="083d684ba690a7c535599e3ad84d043b25bbe13a" translate="yes" xml:space="preserve">
          <source>reindexdb &amp;mdash; reindex a PostgreSQL database</source>
          <target state="translated">reindexdb &amp;mdash; PostgreSQL 데이터베이스를 재색 인</target>
        </trans-unit>
        <trans-unit id="f1b9275c96db955794a0d238bdcaa339012cd19d" translate="yes" xml:space="preserve">
          <source>reindexdb accepts the following command-line arguments:</source>
          <target state="translated">reindexdb는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="82c90da5e98614fb40487a8c5028bb77858ddea5" translate="yes" xml:space="preserve">
          <source>reindexdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">reindexdb는 또한 연결 매개 변수에 대해 다음 명령 행 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9269293224da190486779e55d8f6b94e5d6d1201" translate="yes" xml:space="preserve">
          <source>reindexdb is a utility for rebuilding indexes in a PostgreSQL database.</source>
          <target state="translated">reindexdb는 PostgreSQL 데이터베이스에서 인덱스를 다시 작성하는 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="0d4846cca29f724c060a9881a5e641df632902bd" translate="yes" xml:space="preserve">
          <source>reindexdb is a wrapper around the SQL command &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;. There is no effective difference between reindexing databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">reindexdb는 SQL 명령 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 주위의 래퍼 입니다. 이 유틸리티와 서버 액세스를위한 다른 방법을 통한 데이터베이스 재 인덱싱 사이에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c386b54f02652791115877233ca0ba1ce06ebef8" translate="yes" xml:space="preserve">
          <source>reindexdb might need to connect several times to the PostgreSQL server, asking for a password each time. It is convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file in such cases. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">reindexdb는 매번 암호를 요구하여 PostgreSQL 서버에 여러 번 연결해야 할 수도 있습니다. 이런 경우 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용 하는 것이 편리합니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;33.15 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3714b0aaa498a583b571049556e19a91f7bef9e6" translate="yes" xml:space="preserve">
          <source>relation access methods</source>
          <target state="translated">관계 액세스 방법</target>
        </trans-unit>
        <trans-unit id="4f400895dee5339e40297de7a78009334a356660" translate="yes" xml:space="preserve">
          <source>relation name</source>
          <target state="translated">관계 이름</target>
        </trans-unit>
        <trans-unit id="b3dbaa46992ab2c1ab0d9fdb8024b94ae7c97076" translate="yes" xml:space="preserve">
          <source>relation size</source>
          <target state="translated">관계 크기</target>
        </trans-unit>
        <trans-unit id="fe32d19bfff33ad58517c3fc62382bd3f2859f20" translate="yes" xml:space="preserve">
          <source>relation state for subscriptions</source>
          <target state="translated">구독 관계 상태</target>
        </trans-unit>
        <trans-unit id="9c407d5c54a039db27fa9d1f28eff43a65bd023a" translate="yes" xml:space="preserve">
          <source>relation to publication mapping</source>
          <target state="translated">출판물 매핑과의 관계</target>
        </trans-unit>
        <trans-unit id="3ecaec07c66f8d55696d8e38bb71c94f66d69c3f" translate="yes" xml:space="preserve">
          <source>relations per database</source>
          <target state="translated">데이터베이스 당 관계</target>
        </trans-unit>
        <trans-unit id="2f2cb6cd22a564475f9a31aaec7a99bd69db2284" translate="yes" xml:space="preserve">
          <source>relative rank of the current row: (&lt;code&gt;rank&lt;/code&gt; - 1) / (total partition rows - 1)</source>
          <target state="translated">현재 행의 상대 순위 : ( &lt;code&gt;rank&lt;/code&gt; -1) / (총 파티션 행-1)</target>
        </trans-unit>
        <trans-unit id="24bf28d5d4bd6d0f16802dfd07220b0a5a687110" translate="yes" xml:space="preserve">
          <source>relative rank of the hypothetical row, ranging from 0 to 1</source>
          <target state="translated">0에서 1까지의 가상 행의 상대 순위</target>
        </trans-unit>
        <trans-unit id="0d774b57696232aac3e604d7200bbba22b10a765" translate="yes" xml:space="preserve">
          <source>relative rank of the hypothetical row, ranging from 1/&lt;code&gt;N&lt;/code&gt; to 1</source>
          <target state="translated">1 /에서부터 가상 행의 상대적인 순위 &lt;code&gt;N&lt;/code&gt; (1)</target>
        </trans-unit>
        <trans-unit id="a7baab710de6a3acc2e604844ea0beee2b050c68" translate="yes" xml:space="preserve">
          <source>remainder of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; 의&lt;/em&gt; 나머지&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="250d4ef2cf0b2baba4d4ce6be41e56e6bfe2aa66" translate="yes" xml:space="preserve">
          <source>remove adjacent duplicates</source>
          <target state="translated">인접한 중복 제거</target>
        </trans-unit>
        <trans-unit id="38dd1de42138997a66af4f3b8bc7e57dac1b0c88" translate="yes" xml:space="preserve">
          <source>remove all elements equal to the given value from the array (array must be one-dimensional)</source>
          <target state="translated">주어진 값과 같은 모든 요소를 ​​배열에서 제거하십시오 (배열은 1 차원이어야합니다)</target>
        </trans-unit>
        <trans-unit id="8dd16a7aac4245908ba8e61e1b938465ae69c6ba" translate="yes" xml:space="preserve">
          <source>remove any occurrence of lexemes in &lt;code&gt;lexemes&lt;/code&gt; from &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vector&lt;/code&gt; 에서 lexemes에있는 &lt;code&gt;lexemes&lt;/code&gt; 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f557bf48148ab0d42c59438c97083ebe97964b9a" translate="yes" xml:space="preserve">
          <source>remove elements of right array from left</source>
          <target state="translated">왼쪽에서 오른쪽 배열의 요소를 제거</target>
        </trans-unit>
        <trans-unit id="f4c2ce7c00e9f4f6ff237ed7d79bb592a368e241" translate="yes" xml:space="preserve">
          <source>remove entries matching right argument from array</source>
          <target state="translated">배열에서 올바른 인수와 일치하는 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3a85e7687c04dd79ad41273a333495c4a666af38" translate="yes" xml:space="preserve">
          <source>remove given &lt;code&gt;lexeme&lt;/code&gt; from &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;lexeme&lt;/code&gt; 을 &lt;code&gt;vector&lt;/code&gt; 에서 제거</target>
        </trans-unit>
        <trans-unit id="23acc1303deaae495d1853a3bfb7b51da8d3e16d" translate="yes" xml:space="preserve">
          <source>remove no-longer-needed files from the archive directory</source>
          <target state="translated">더 이상 필요하지 않은 파일을 아카이브 디렉토리에서 제거</target>
        </trans-unit>
        <trans-unit id="1fe926fa047bec6ba89c76c931f71121be744ab2" translate="yes" xml:space="preserve">
          <source>remove positions and weights from &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 에서 위치와 가중치 제거</target>
        </trans-unit>
        <trans-unit id="9dc6cb30e1258dd38c8070535185e19e9fafc89e" translate="yes" xml:space="preserve">
          <source>replace &lt;code&gt;target&lt;/code&gt; with &lt;code&gt;substitute&lt;/code&gt; within query</source>
          <target state="translated">교체 &lt;code&gt;target&lt;/code&gt; 로 &lt;code&gt;substitute&lt;/code&gt; 쿼리 내에서</target>
        </trans-unit>
        <trans-unit id="5188d18c0f7f37bcf7e981e94e98e14b02a1ad11" translate="yes" xml:space="preserve">
          <source>replace each array element equal to the given value with a new value</source>
          <target state="translated">주어진 값과 동일한 각 배열 요소를 새 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="082d585357b132d574d47eb232747743bbcaa89f" translate="yes" xml:space="preserve">
          <source>replace fields in &lt;code&gt;record&lt;/code&gt; with matching values from &lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;record&lt;/code&gt; 필드 를 &lt;code&gt;hstore&lt;/code&gt; 의 일치하는 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="f6497423feeb7cfbcbea6dfe9043ee8a2d8a82ce" translate="yes" xml:space="preserve">
          <source>replace using targets and substitutes from a &lt;code&gt;SELECT&lt;/code&gt; command</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 명령 에서 대상 및 대체를 사용하여 교체</target>
        </trans-unit>
        <trans-unit id="f641218d2d50f1a8843c5b665bee0c71b3cd8081" translate="yes" xml:space="preserve">
          <source>replication slot information</source>
          <target state="translated">복제 슬롯 정보</target>
        </trans-unit>
        <trans-unit id="dd9d9b14b554540f18ebbc89119208ebf00845a1" translate="yes" xml:space="preserve">
          <source>report the status of the given transaction: &lt;code&gt;committed&lt;/code&gt;, &lt;code&gt;aborted&lt;/code&gt;, &lt;code&gt;in progress&lt;/code&gt;, or null if the transaction ID is too old</source>
          <target state="translated">주어진 트랜잭션의 상태를보고합니다 : &lt;code&gt;committed&lt;/code&gt; , &lt;code&gt;aborted&lt;/code&gt; , &lt;code&gt;in progress&lt;/code&gt; , 또는 트랜잭션 ID가 너무 오래된 경우 null</target>
        </trans-unit>
        <trans-unit id="5135b0db9215727e0820279b872a0bf3a7a995ab" translate="yes" xml:space="preserve">
          <source>represents the given list and all of its possible subsets (i.e. the power set). Thus</source>
          <target state="translated">주어진 목록과 가능한 모든 하위 집합 (예 : 전원 집합)을 나타냅니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="356ffe4c0384f09906245d0f662d4f64ca925e90" translate="yes" xml:space="preserve">
          <source>represents the given list of expressions and all prefixes of the list including the empty list; thus it is equivalent to</source>
          <target state="translated">지정된 표현식 목록과 빈 목록을 포함하여 목록의 모든 접두사를 나타냅니다. 따라서 그것은</target>
        </trans-unit>
        <trans-unit id="c3fed1dae28105416889eb25d33d7d24c7a20450" translate="yes" xml:space="preserve">
          <source>reserved</source>
          <target state="translated">reserved</target>
        </trans-unit>
        <trans-unit id="7cf3815c9bd862676a352eeccf7ac7542600b6c5" translate="yes" xml:space="preserve">
          <source>reserved (can be function or type)</source>
          <target state="translated">예약 됨 (기능 또는 유형일 수 있음)</target>
        </trans-unit>
        <trans-unit id="ed21c3e5b93bf74f1eaef8bef11e84e4f4d063cc" translate="yes" xml:space="preserve">
          <source>rest of RE is a BRE</source>
          <target state="translated">RE의 나머지는 BRE입니다</target>
        </trans-unit>
        <trans-unit id="ecc3be46f9db605f5a4800017e62c87a14975389" translate="yes" xml:space="preserve">
          <source>rest of RE is a literal (&amp;ldquo;quoted&amp;rdquo;) string, all ordinary characters</source>
          <target state="translated">나머지 RE는 리터럴 ( &quot;인용 된&quot;) 문자열이며 모든 일반 문자</target>
        </trans-unit>
        <trans-unit id="91d89625c583905657cc3796e4a310389dbcc99b" translate="yes" xml:space="preserve">
          <source>rest of RE is an ERE</source>
          <target state="translated">RE의 나머지는 ERE입니다</target>
        </trans-unit>
        <trans-unit id="975c06d7cafa478c3fe79782ed24c7c6272e47b5" translate="yes" xml:space="preserve">
          <source>results in a boldfaced (&lt;code&gt;1;&lt;/code&gt;) yellow-on-black (&lt;code&gt;33;40&lt;/code&gt;) prompt on VT100-compatible, color-capable terminals.</source>
          <target state="translated">VT100 호환, 컬러 지원 터미널 에서 굵은 체 ( &lt;code&gt;1;&lt;/code&gt; ) 노랑-온-블랙 ( &lt;code&gt;33;40&lt;/code&gt; ) 프롬프트가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a330de73ae3e6dd801ff4acc1591c2a394148067" translate="yes" xml:space="preserve">
          <source>results in an error, because even though the &lt;code&gt;||&lt;/code&gt; operator doesn't need to know a collation, the &lt;code&gt;ORDER BY&lt;/code&gt; clause does. As before, the conflict can be resolved with an explicit collation specifier:</source>
          <target state="translated">비록 &lt;code&gt;||&lt;/code&gt; 연산자는 데이터 정렬을 알 필요가 없으며 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 알 수 있습니다. 이전과 마찬가지로 명시 적 데이터 정렬 지정자로 충돌을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="444b34c633eaec66d1c65cbe124cb5d92d2bd179" translate="yes" xml:space="preserve">
          <source>results in sending the three SQL commands to the server in a single request, when the non-backslashed semicolon is reached. The server executes such a request as a single transaction, unless there are explicit &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt; commands included in the string to divide it into multiple transactions. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;Section 52.2.2.1&lt;/a&gt; for more details about how the server handles multi-query strings.) psql prints only the last query result it receives for each request; in this example, although all three &lt;code&gt;SELECT&lt;/code&gt;s are indeed executed, psql only prints the &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">백 슬래시가없는 세미콜론에 도달하면 단일 요청으로 세 개의 SQL 명령을 서버로 보냅니다. 문자열에 명시 적 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 명령이 포함되어 있지 않은 한 서버는 단일 트랜잭션으로 이러한 요청을 실행 하여 여러 트랜잭션으로 나눕니다. ( 서버가 다중 쿼리 문자열을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;52.2.2.1 단원&lt;/a&gt; 을 참조하십시오.) psql은 각 요청에 대해 수신 한 마지막 쿼리 결과 만 인쇄합니다. 이 예에서는 세 개의 &lt;code&gt;SELECT&lt;/code&gt; 가 모두 실제로 실행되지만 psql은 &lt;code&gt;3&lt;/code&gt; 만 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="5fce577ae88abc86447ced8062ac57ef7a232995" translate="yes" xml:space="preserve">
          <source>retain SQL and log files even after successful completion</source>
          <target state="translated">성공적인 완료 후에도 SQL 및 로그 파일 유지</target>
        </trans-unit>
        <trans-unit id="16bf0aaa4359a81eaeb06e64f3c0357d5ae75c44" translate="yes" xml:space="preserve">
          <source>retrieves the most recent weather report for each location. But if we had not used &lt;code&gt;ORDER BY&lt;/code&gt; to force descending order of time values for each location, we'd have gotten a report from an unpredictable time for each location.</source>
          <target state="translated">각 위치에 대한 최신 날씨 보고서를 검색합니다. 그러나 &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용 하여 각 위치에 대해 내림차순 시간 값을 설정하지 않은 경우 각 위치에 대해 예측할 수없는 시간에 대한 보고서를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="ee22df0a1fecf5d6e65d0f717939490ca3a867a6" translate="yes" xml:space="preserve">
          <source>return the bucket number to which &lt;em&gt;&lt;code&gt;operand&lt;/code&gt;&lt;/em&gt; would be assigned given an array listing the lower bounds of the buckets; returns &lt;code&gt;0&lt;/code&gt; for an input less than the first lower bound; the &lt;em&gt;&lt;code&gt;thresholds&lt;/code&gt;&lt;/em&gt; array &lt;em&gt;must be sorted&lt;/em&gt;, smallest first, or unexpected results will be obtained</source>
          <target state="translated">버킷 의 하한을 나열하는 배열이 주어지면 &lt;em&gt; &lt;code&gt;operand&lt;/code&gt; &lt;/em&gt; 가 할당 될 버킷 번호를 반환합니다 . 첫 번째 하한보다 작은 입력에 대해 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 . &lt;em&gt; &lt;code&gt;thresholds&lt;/code&gt; &lt;/em&gt; 어레이 &lt;em&gt;정렬되어야&lt;/em&gt; 작은 제, 또는 예기치 않은 결과가 얻어진다</target>
        </trans-unit>
        <trans-unit id="3002498c207f977bb1a57f96069026decbcaab11" translate="yes" xml:space="preserve">
          <source>return the bucket number to which &lt;em&gt;&lt;code&gt;operand&lt;/code&gt;&lt;/em&gt; would be assigned in a histogram having &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; equal-width buckets spanning the range &lt;em&gt;&lt;code&gt;b1&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;b2&lt;/code&gt;&lt;/em&gt;; returns &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;em&gt;count&lt;/em&gt;+1&lt;/code&gt; for an input outside the range</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;b1&lt;/code&gt; &lt;/em&gt; ~ &lt;em&gt; &lt;code&gt;b2&lt;/code&gt; &lt;/em&gt; 범위에 걸쳐 동일한 너비의 버킷 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 를 가진 히스토그램에서 &lt;em&gt; &lt;code&gt;operand&lt;/code&gt; &lt;/em&gt; 가 할당 될 버킷 번호를 반환합니다 . 범위 밖의 입력에 대해 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&lt;em&gt;count&lt;/em&gt;+1&lt;/code&gt; +1 을 반환 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7267abd0eccd3050c932ca8f9a39b2db7805ebf" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;value&lt;/code&gt; evaluated at the row that is &lt;code&gt;offset&lt;/code&gt; rows after the current row within the partition; if there is no such row, instead return &lt;code&gt;default&lt;/code&gt; (which must be of the same type as &lt;code&gt;value&lt;/code&gt;). Both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; are evaluated with respect to the current row. If omitted, &lt;code&gt;offset&lt;/code&gt; defaults to 1 and &lt;code&gt;default&lt;/code&gt; to null</source>
          <target state="translated">파티션 내 현재 행 다음의 &lt;code&gt;offset&lt;/code&gt; 행인 평가 된 &lt;code&gt;value&lt;/code&gt; 반환 합니다. 그러한 행이 없으면 대신 &lt;code&gt;default&lt;/code&gt; ( &lt;code&gt;value&lt;/code&gt; 와 같은 유형이어야 함)를 반환 하십시오 . 두 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;default&lt;/code&gt; 현재 행에 대한 평가됩니다. 생략하면 &lt;code&gt;offset&lt;/code&gt; 기본값은 1이고 &lt;code&gt;default&lt;/code&gt; 은 null입니다.</target>
        </trans-unit>
        <trans-unit id="ebdeb428fdccc9cb040c31c14014be4f17047d0d" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;value&lt;/code&gt; evaluated at the row that is &lt;code&gt;offset&lt;/code&gt; rows before the current row within the partition; if there is no such row, instead return &lt;code&gt;default&lt;/code&gt; (which must be of the same type as &lt;code&gt;value&lt;/code&gt;). Both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; are evaluated with respect to the current row. If omitted, &lt;code&gt;offset&lt;/code&gt; defaults to 1 and &lt;code&gt;default&lt;/code&gt; to null</source>
          <target state="translated">파티션 내 현재 행 앞의 &lt;code&gt;offset&lt;/code&gt; 행인 평가 된 &lt;code&gt;value&lt;/code&gt; 반환 합니다. 그러한 행이 없으면 대신 &lt;code&gt;default&lt;/code&gt; ( &lt;code&gt;value&lt;/code&gt; 와 같은 유형이어야 함)를 반환 하십시오 . 두 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;default&lt;/code&gt; 현재 행에 대한 평가됩니다. 생략하면 &lt;code&gt;offset&lt;/code&gt; 기본값은 1이고 &lt;code&gt;default&lt;/code&gt; 은 null입니다.</target>
        </trans-unit>
        <trans-unit id="c3f6b1427093198f62e2acf28b696edf486be820" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;value&lt;/code&gt; evaluated at the row that is the &lt;code&gt;nth&lt;/code&gt; row of the window frame (counting from 1); null if no such row</source>
          <target state="translated">윈도우 프레임 의 &lt;code&gt;nth&lt;/code&gt; 행인 행에서 평가 된 &lt;code&gt;value&lt;/code&gt; 리턴 합니다 (1부터 계산). 그러한 행이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="fe444fc771c8feb6c57dc4688d6426860a1d491c" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;value&lt;/code&gt; evaluated at the row that is the first row of the window frame</source>
          <target state="translated">창 프레임의 첫 번째 행인 행에서 평가 된 &lt;code&gt;value&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1396dd2e096fb41f0e4f5a3f241ebed4c06e1d0c" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;value&lt;/code&gt; evaluated at the row that is the last row of the window frame</source>
          <target state="translated">윈도우 프레임의 마지막 행인 평가 된 &lt;code&gt;value&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="71a10c96eee8568f3508c9aa39cf3e3ea3ed15ca" translate="yes" xml:space="preserve">
          <source>returns a text representation of array's dimensions</source>
          <target state="translated">배열 치수의 텍스트 표현을 반환</target>
        </trans-unit>
        <trans-unit id="3b62532b94231f6238b17c538120a19aee2a06bf" translate="yes" xml:space="preserve">
          <source>returns an array initialized with supplied value and dimensions, optionally with lower bounds other than 1</source>
          <target state="translated">제공된 값과 차원으로 초기화 된 배열을 반환하며 선택적으로 1 이외의 하한으로</target>
        </trans-unit>
        <trans-unit id="1cd245f5e95769a191196af0e331ee0930cd1c26" translate="yes" xml:space="preserve">
          <source>returns an array of subscripts of all occurrences of the second argument in the array given as first argument (array must be one-dimensional)</source>
          <target state="translated">첫 번째 인수로 지정된 배열에서 두 번째 인수가 모두 나타나는 첨자 배열을 반환합니다 (배열은 1 차원이어야 함).</target>
        </trans-unit>
        <trans-unit id="7c82d508b01a6e8cbe051297d24034e9c62249ab" translate="yes" xml:space="preserve">
          <source>returns lower bound of the requested array dimension</source>
          <target state="translated">요청 된 배열 차원의 하한을 반환</target>
        </trans-unit>
        <trans-unit id="3b46912b18272e12992ac296592f4fa8c7a7364a" translate="yes" xml:space="preserve">
          <source>returns the length of the requested array dimension</source>
          <target state="translated">요청 된 배열 차원의 길이를 반환</target>
        </trans-unit>
        <trans-unit id="d6548b44faf585f67ff06870acc7d8b484dba54c" translate="yes" xml:space="preserve">
          <source>returns the most frequent input value (arbitrarily choosing the first one if there are multiple equally-frequent results)</source>
          <target state="translated">가장 빈번한 입력 값을 반환합니다 (동일한 결과가 여러 개있는 경우 첫 번째 값을 임의로 선택)</target>
        </trans-unit>
        <trans-unit id="1a6cbc667a3301906e72bbd9b93b36f18bc6aa8a" translate="yes" xml:space="preserve">
          <source>returns the number of dimensions of the array</source>
          <target state="translated">배열의 차원 수를 반환</target>
        </trans-unit>
        <trans-unit id="1521a81520f2ac81215752f9f1dd8450e26db7a8" translate="yes" xml:space="preserve">
          <source>returns the number of non-null arguments</source>
          <target state="translated">널이 아닌 인수의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41dc754b6fcfa81efc4d59f1d30e6f1bc08e52ea" translate="yes" xml:space="preserve">
          <source>returns the number of null arguments</source>
          <target state="translated">널 인수 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="950bb0d705afa2ecdf04dc69b670d776908717d5" translate="yes" xml:space="preserve">
          <source>returns the subscript of the first occurrence of the second argument in the array, starting at the element indicated by the third argument or at the first element (array must be one-dimensional)</source>
          <target state="translated">배열에서 두 번째 인수의 첫 번째 발생에 대한 첨자를 반환합니다. 세 번째 인수로 표시된 요소 또는 첫 번째 요소에서 시작합니다 (배열은 1 차원이어야 함).</target>
        </trans-unit>
        <trans-unit id="2796675e9a2fc94171df461336da329dd018137d" translate="yes" xml:space="preserve">
          <source>returns the total number of elements in the array, or 0 if the array is empty</source>
          <target state="translated">배열의 총 요소 수를 반환하거나 배열이 비어 있으면 0을 반환</target>
        </trans-unit>
        <trans-unit id="6457c7b2d74cd1057087944da3309b3e771916f7" translate="yes" xml:space="preserve">
          <source>returns upper bound of the requested array dimension</source>
          <target state="translated">요청 된 배열 차원의 상한을 반환</target>
        </trans-unit>
        <trans-unit id="d27a1f11771200949714b1af99f048a416f5d6f4" translate="yes" xml:space="preserve">
          <source>right</source>
          <target state="translated">right</target>
        </trans-unit>
        <trans-unit id="7a6adcc3945face87585fd8155c0a3bfe12c1aea" translate="yes" xml:space="preserve">
          <source>role creation</source>
          <target state="translated">역할 생성</target>
        </trans-unit>
        <trans-unit id="4f20913ec848d650926d4542f930064b4e800121" translate="yes" xml:space="preserve">
          <source>role name</source>
          <target state="translated">역할 이름</target>
        </trans-unit>
        <trans-unit id="30035c6118dd0b42e0d54eff22bda5ac1667a64a" translate="yes" xml:space="preserve">
          <source>round to &lt;em&gt;&lt;code&gt;s&lt;/code&gt;&lt;/em&gt; decimal places</source>
          <target state="translated">라운드 &lt;em&gt; &lt;code&gt;s&lt;/code&gt; &lt;/em&gt; 소수점</target>
        </trans-unit>
        <trans-unit id="d4e5b6836d776c479140516a0df34da04eb26f7e" translate="yes" xml:space="preserve">
          <source>round to nearest integer</source>
          <target state="translated">가장 가까운 정수로 반올림</target>
        </trans-unit>
        <trans-unit id="afca603cb13b0f0b0e9d13ff9e678c072fe1a068" translate="yes" xml:space="preserve">
          <source>row-security policies</source>
          <target state="translated">행 보안 정책</target>
        </trans-unit>
        <trans-unit id="bf443f73fbbb68c960a09139294cf81dd9c4311f" translate="yes" xml:space="preserve">
          <source>rows per table</source>
          <target state="translated">테이블 당 행</target>
        </trans-unit>
        <trans-unit id="caa155adf81fddd29ab4b21a147927fb0295eb53" translate="yes" xml:space="preserve">
          <source>rules</source>
          <target state="translated">rules</target>
        </trans-unit>
        <trans-unit id="7f97770a91e79897c140e6d67dd7c50d07a1eedb" translate="yes" xml:space="preserve">
          <source>same as 04:05; AM does not affect value</source>
          <target state="translated">04:05와 동일; AM은 가치에 영향을 미치지 않습니다</target>
        </trans-unit>
        <trans-unit id="f04a71dc97d5af82e0ee8edb9253d169ee48a0ce" translate="yes" xml:space="preserve">
          <source>same as 16:05; input hour must be &amp;lt;= 12</source>
          <target state="translated">16:05와 동일; 입력 시간은 &amp;lt;= 12 여야합니다.</target>
        </trans-unit>
        <trans-unit id="381ad91239df75c43baa01c572764914bd0529ce" translate="yes" xml:space="preserve">
          <source>same as &lt;code&gt;SHMMAX&lt;/code&gt; if bytes, or &lt;code&gt;ceil(SHMMAX/PAGE_SIZE)&lt;/code&gt; if pages, plus room for other applications</source>
          <target state="translated">바이트 인 경우 &lt;code&gt;SHMMAX&lt;/code&gt; 와 같 거나 페이지 인 경우 &lt;code&gt;ceil(SHMMAX/PAGE_SIZE)&lt;/code&gt; 및 다른 응용 프로그램을위한 공간</target>
        </trans-unit>
        <trans-unit id="444029a8e89cc9b36d7757a94617ef66b90b1ec0" translate="yes" xml:space="preserve">
          <source>same as &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">동일 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="725e9a292ccbf46a0011119b27055450e073ee89" translate="yes" xml:space="preserve">
          <source>same as &lt;code&gt;txid_current()&lt;/code&gt; but returns null instead of assigning a new transaction ID if none is already assigned</source>
          <target state="translated">&lt;code&gt;txid_current()&lt;/code&gt; 와 동일 하지만 아직 할당되지 않은 경우 새 트랜잭션 ID를 할당하는 대신 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2550c14b9889607f837e2bceed8ca16c04df8628" translate="yes" xml:space="preserve">
          <source>same as argument data type</source>
          <target state="translated">인수 데이터 유형과 동일</target>
        </trans-unit>
        <trans-unit id="6505c58080c76822039bb8092fd3dc7c084088d5" translate="yes" xml:space="preserve">
          <source>same as argument type</source>
          <target state="translated">인수 유형과 동일</target>
        </trans-unit>
        <trans-unit id="29d4500a9f8344a41e893c32af126918b437f345" translate="yes" xml:space="preserve">
          <source>same as argument types</source>
          <target state="translated">인수 유형과 동일</target>
        </trans-unit>
        <trans-unit id="75d1035aa98b33a93d51413789c402f68a1e958a" translate="yes" xml:space="preserve">
          <source>same as sort expression</source>
          <target state="translated">정렬 표현식과 동일</target>
        </trans-unit>
        <trans-unit id="b04ca48928a88a6f40948b741bd4a4aa9a940096" translate="yes" xml:space="preserve">
          <source>sample covariance</source>
          <target state="translated">표본 공분산</target>
        </trans-unit>
        <trans-unit id="3b475ac96d1fa258fe07f14c2bca707d6c31af09" translate="yes" xml:space="preserve">
          <source>sample standard deviation of the input values</source>
          <target state="translated">입력 값의 표본 표준 편차</target>
        </trans-unit>
        <trans-unit id="d6f6c117f9c0d8f537673cb495b75dc42dd3c9d7" translate="yes" xml:space="preserve">
          <source>sample variance of the input values (square of the sample standard deviation)</source>
          <target state="translated">입력 값의 표본 분산 (샘플 표준 편차의 제곱)</target>
        </trans-unit>
        <trans-unit id="b8420ac235635b82c2dba8c4c33bee009cfe6d73" translate="yes" xml:space="preserve">
          <source>scale of the argument (the number of decimal digits in the fractional part)</source>
          <target state="translated">인수의 스케일 (소수 부분의 소수 자릿수)</target>
        </trans-unit>
        <trans-unit id="c20018ff0e789e8b5fbb66e98bfc41abd855a441" translate="yes" xml:space="preserve">
          <source>schemas</source>
          <target state="translated">schemas</target>
        </trans-unit>
        <trans-unit id="158ec945e449489046fe7f0d6278576a3e5e99d6" translate="yes" xml:space="preserve">
          <source>second (00-59)</source>
          <target state="translated">초 (00-59)</target>
        </trans-unit>
        <trans-unit id="44def91fc11923bbab937d474f217ff8bc930277" translate="yes" xml:space="preserve">
          <source>seconds past midnight (0-86399)</source>
          <target state="translated">자정이 지난 초 (0-86399)</target>
        </trans-unit>
        <trans-unit id="b1c5e0f7813fff587cbcf086ee5a937547200510" translate="yes" xml:space="preserve">
          <source>security labels</source>
          <target state="translated">보안 레이블</target>
        </trans-unit>
        <trans-unit id="d7f7da16285a8232ead81524f850ad3798c96fbb" translate="yes" xml:space="preserve">
          <source>security labels on database objects</source>
          <target state="translated">데이터베이스 객체의 보안 레이블</target>
        </trans-unit>
        <trans-unit id="13f0095e6696d94a4573ac4c799bdda01d997028" translate="yes" xml:space="preserve">
          <source>security labels on shared database objects</source>
          <target state="translated">공유 데이터베이스 오브젝트의 보안 레이블</target>
        </trans-unit>
        <trans-unit id="4d57d13fe1b83c37010a258861fb2f7cad8afcec" translate="yes" xml:space="preserve">
          <source>see Examples section</source>
          <target state="translated">예 섹션 참조</target>
        </trans-unit>
        <trans-unit id="74acdbefb150f3934bfb4c52a48120f7bb3e2de3" translate="yes" xml:space="preserve">
          <source>see text</source>
          <target state="translated">텍스트 참조</target>
        </trans-unit>
        <trans-unit id="2679f8bbcd41e24d3e47024eb1e57f9c2de822a3" translate="yes" xml:space="preserve">
          <source>seed used in hash functions by default</source>
          <target state="translated">기본적으로 해시 함수에 사용되는 시드</target>
        </trans-unit>
        <trans-unit id="bea4a97042f47e1fdf46da61cad740998fb72742" translate="yes" xml:space="preserve">
          <source>seg</source>
          <target state="translated">seg</target>
        </trans-unit>
        <trans-unit id="4c56967d91bb3aca321c3df62c169fed6bdef73a" translate="yes" xml:space="preserve">
          <source>select only elements with given &lt;code&gt;weights&lt;/code&gt; from &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vector&lt;/code&gt; 에서 주어진 &lt;code&gt;weights&lt;/code&gt; 를 가진 요소 만 선택</target>
        </trans-unit>
        <trans-unit id="644e5c2acdd03305f6e3d3fd02e387f18ee262e8" translate="yes" xml:space="preserve">
          <source>selects a scale of 0. Specifying:</source>
          <target state="translated">스케일 0을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c87eafc5e4f7d06ceebb389c8131b970291e23e2" translate="yes" xml:space="preserve">
          <source>sent to client to indicate server's identity</source>
          <target state="translated">서버의 신원을 나타 내기 위해 클라이언트에게 전송</target>
        </trans-unit>
        <trans-unit id="07bfb4c7c3f91af6d4d516112db1cda98690f754" translate="yes" xml:space="preserve">
          <source>sepgsql</source>
          <target state="translated">sepgsql</target>
        </trans-unit>
        <trans-unit id="6e0abecd9209de3a67bf617f2a320a16833ff235" translate="yes" xml:space="preserve">
          <source>sequences</source>
          <target state="translated">sequences</target>
        </trans-unit>
        <trans-unit id="50de66b735d30738618568294742fcf1dfa52a47" translate="yes" xml:space="preserve">
          <source>serial</source>
          <target state="translated">serial</target>
        </trans-unit>
        <trans-unit id="e07cc34dbfcde8a6a6b9e26e394598959862e030" translate="yes" xml:space="preserve">
          <source>serialization anomaly</source>
          <target state="translated">직렬화 이상</target>
        </trans-unit>
        <trans-unit id="eb95185afa76ed511c8e284a022b3ab5a2053b04" translate="yes" xml:space="preserve">
          <source>server certificate</source>
          <target state="translated">서버 인증서</target>
        </trans-unit>
        <trans-unit id="3012cb613cb7a5b6af88819a82a682de4a6fbf66" translate="yes" xml:space="preserve">
          <source>server private key</source>
          <target state="translated">서버 개인 키</target>
        </trans-unit>
        <trans-unit id="30c38a4a7c10a113e25809757f44fe3b350d2a0d" translate="yes" xml:space="preserve">
          <source>server start time</source>
          <target state="translated">서버 시작 시간</target>
        </trans-unit>
        <trans-unit id="f149fd4651ad8c2853db89a728ed4063d863c34f" translate="yes" xml:space="preserve">
          <source>session user name</source>
          <target state="translated">세션 사용자 이름</target>
        </trans-unit>
        <trans-unit id="2176f740dcbe933b33347e08ad8f878db90a67a7" translate="yes" xml:space="preserve">
          <source>set 7th bit to one, also known as modified EUI-64, for inclusion in an IPv6 address</source>
          <target state="translated">IPv6 주소에 포함시키기 위해 수정 된 EUI-64라고도하는 7 비트를 1로 설정</target>
        </trans-unit>
        <trans-unit id="5bb89ca75be98937c9666fbaeb5284390c99901a" translate="yes" xml:space="preserve">
          <source>set last 3 bytes to zero</source>
          <target state="translated">마지막 3 바이트를 0으로 설정</target>
        </trans-unit>
        <trans-unit id="e9915c518a4be3e539a68b91c3693842f0a3e949" translate="yes" xml:space="preserve">
          <source>set last 5 bytes to zero</source>
          <target state="translated">마지막 5 바이트를 0으로 설정</target>
        </trans-unit>
        <trans-unit id="f6b50cd4aea4f89f6723d8dee6940c3db608439d" translate="yes" xml:space="preserve">
          <source>set netmask length for &lt;code&gt;cidr&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 값에 대한 넷 마스크 길이 설정</target>
        </trans-unit>
        <trans-unit id="38d64c3e82d8607f24ef4f2f2226730c77afcbb1" translate="yes" xml:space="preserve">
          <source>set netmask length for &lt;code&gt;inet&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 값에 대한 넷 마스크 길이 설정</target>
        </trans-unit>
        <trans-unit id="d25995862e194e5a3a5c2bd155fdb0e4324e3a5a" translate="yes" xml:space="preserve">
          <source>set parameter and return new value</source>
          <target state="translated">매개 변수 설정 및 새 값 반환</target>
        </trans-unit>
        <trans-unit id="b13d3693e75409e62fe740c49c5c3fb72bedffd5" translate="yes" xml:space="preserve">
          <source>set seed for subsequent &lt;code&gt;random()&lt;/code&gt; calls (value between -1.0 and 1.0, inclusive)</source>
          <target state="translated">후속 &lt;code&gt;random()&lt;/code&gt; 호출에 대한 시드 설정 (-1.0과 1.0 사이의 값 포함)</target>
        </trans-unit>
        <trans-unit id="fe21788b00e3b77dd3e5ec835ccc1f5b49e1dc5b" translate="yes" xml:space="preserve">
          <source>sets the default character set to &lt;code&gt;EUC_JP&lt;/code&gt; (Extended Unix Code for Japanese). You can use &lt;code&gt;--encoding&lt;/code&gt; instead of &lt;code&gt;-E&lt;/code&gt; if you prefer longer option strings. If no &lt;code&gt;-E&lt;/code&gt; or &lt;code&gt;--encoding&lt;/code&gt; option is given, &lt;code&gt;initdb&lt;/code&gt; attempts to determine the appropriate encoding to use based on the specified or default locale.</source>
          <target state="translated">기본 문자 세트를 &lt;code&gt;EUC_JP&lt;/code&gt; (Extended Unix Code for Japanese)로 설정합니다. 더 긴 옵션 문자열을 선호하는 경우 &lt;code&gt;-E&lt;/code&gt; 대신 &lt;code&gt;--encoding&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;-E&lt;/code&gt; 또는 &lt;code&gt;--encoding&lt;/code&gt; 옵션이 제공 되지 않으면 &lt;code&gt;initdb&lt;/code&gt; 는 지정된 또는 기본 로케일을 기반으로 사용할 적절한 인코딩을 결정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f1cdd98ece11ec8696e4549b7fd49fdfb53329a5" translate="yes" xml:space="preserve">
          <source>sets the variable &lt;code&gt;foo&lt;/code&gt; to the value &lt;code&gt;bar&lt;/code&gt;. To retrieve the content of the variable, precede the name with a colon, for example:</source>
          <target state="translated">변수 &lt;code&gt;foo&lt;/code&gt; 를 값 &lt;code&gt;bar&lt;/code&gt; 로 설정합니다 . 변수의 내용을 검색하려면 다음과 같이 이름 앞에 콜론을 붙입니다.</target>
        </trans-unit>
        <trans-unit id="f14194e1ad0db4fc5a6c41c25d97b88b0b0eb9d2" translate="yes" xml:space="preserve">
          <source>shared disk</source>
          <target state="translated">공유 디스크</target>
        </trans-unit>
        <trans-unit id="2bd12a73caaa637f0067a8ea8256c6ef51ec7eb4" translate="yes" xml:space="preserve">
          <source>shift specified number of digits (see notes)</source>
          <target state="translated">지정된 자릿수 이동 (주 참조)</target>
        </trans-unit>
        <trans-unit id="d0d3354171909fec092803a13e57504284839b56" translate="yes" xml:space="preserve">
          <source>show help, then exit</source>
          <target state="translated">도움말을 표시 한 다음 종료</target>
        </trans-unit>
        <trans-unit id="7a4c1ffcc21e466d4c03636dfe48d7208ff34a2a" translate="yes" xml:space="preserve">
          <source>sign anchored to number (uses locale)</source>
          <target state="translated">숫자에 고정 된 부호 (로케일 사용)</target>
        </trans-unit>
        <trans-unit id="2d8038b8fa79ee6f4e0333b7d9abbd6d27192e74" translate="yes" xml:space="preserve">
          <source>sign of the argument (-1, 0, +1)</source>
          <target state="translated">인수 부호 (-1, 0, +1)</target>
        </trans-unit>
        <trans-unit id="92e213bad97bab9b212d988dd8e7d25cdfca5dac" translate="yes" xml:space="preserve">
          <source>signed eight-byte integer</source>
          <target state="translated">부호있는 8 바이트 정수</target>
        </trans-unit>
        <trans-unit id="b262fe7ab8a722f5a80f938f46cf8f4584413294" translate="yes" xml:space="preserve">
          <source>signed four-byte integer</source>
          <target state="translated">부호있는 4 바이트 정수</target>
        </trans-unit>
        <trans-unit id="4da4ccae877e5d648124e213d97abcb322d4e5d7" translate="yes" xml:space="preserve">
          <source>signed two-byte integer</source>
          <target state="translated">부호있는 2 바이트 정수</target>
        </trans-unit>
        <trans-unit id="0f00b74f11b767c79cdfe4e57b77d6c9229acca2" translate="yes" xml:space="preserve">
          <source>since here no normalization of the word &lt;code&gt;rats&lt;/code&gt; will occur. The elements of a &lt;code&gt;tsvector&lt;/code&gt; are lexemes, which are assumed already normalized, so &lt;code&gt;rats&lt;/code&gt; does not match &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;rats&lt;/code&gt; 정규화 가 발생 하지 않기 때문 입니다. &lt;code&gt;tsvector&lt;/code&gt; 의 요소는 lexemes 이며, 이미 정규화되어 있다고 가정하므로 &lt;code&gt;rats&lt;/code&gt; &lt;code&gt;rat&lt;/code&gt; 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3ceffe1ce290eba808bf1b206f569dc259347da3" translate="yes" xml:space="preserve">
          <source>sine</source>
          <target state="translated">sine</target>
        </trans-unit>
        <trans-unit id="23df04a0cdcf2537524dd2bc11ff311556f2d0d7" translate="yes" xml:space="preserve">
          <source>single precision floating-point number (4 bytes)</source>
          <target state="translated">단 정밀도 부동 소수점 수 (4 바이트)</target>
        </trans-unit>
        <trans-unit id="44817ac90b4676f63ab6aa851d0d68fe7668eb1d" translate="yes" xml:space="preserve">
          <source>single quote</source>
          <target state="translated">작은 따옴표</target>
        </trans-unit>
        <trans-unit id="99a4cbeed5e697c938719c7074046afe2c5d7b40" translate="yes" xml:space="preserve">
          <source>single-byte internal type</source>
          <target state="translated">1 바이트 내부 유형</target>
        </trans-unit>
        <trans-unit id="b232aae2ea051a8b4eaddeaefe182cb7892647ee" translate="yes" xml:space="preserve">
          <source>slope of the least-squares-fit linear equation determined by the (&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;) pairs</source>
          <target state="translated">( &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; ) 쌍으로 결정된 최소 제곱 법 선형 방정식의 기울기</target>
        </trans-unit>
        <trans-unit id="46cbb81a5d630d179cb52059ee20297c400b1416" translate="yes" xml:space="preserve">
          <source>small autoincrementing integer</source>
          <target state="translated">작은 자동 증가 정수</target>
        </trans-unit>
        <trans-unit id="558af7381b144d3cc082f2123a4bc36981e7bc21" translate="yes" xml:space="preserve">
          <source>small-range integer</source>
          <target state="translated">작은 범위의 정수</target>
        </trans-unit>
        <trans-unit id="909c8f67764ae9c083dec81d2f306957c4d8be27" translate="yes" xml:space="preserve">
          <source>smallest value among arguments</source>
          <target state="translated">인수 중 가장 작은 값</target>
        </trans-unit>
        <trans-unit id="65054f9d9beebbd4a2951daf149f1905474abfaa" translate="yes" xml:space="preserve">
          <source>smallint</source>
          <target state="translated">smallint</target>
        </trans-unit>
        <trans-unit id="a1052ff798b7fb9365168ccf304ef07f3cc90e46" translate="yes" xml:space="preserve">
          <source>smallserial</source>
          <target state="translated">smallserial</target>
        </trans-unit>
        <trans-unit id="403cf57b0a03d649674382c49443d5cfce45091b" translate="yes" xml:space="preserve">
          <source>so that the &lt;code&gt;mytext&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; operator is found immediately according to the exact-match rule. If the best-match rules are reached, they actively discriminate against operators on domain types. If they did not, such an operator would create too many ambiguous-operator failures, because the casting rules always consider a domain as castable to or from its base type, and so the domain operator would be considered usable in all the same cases as a similarly-named operator on the base type.</source>
          <target state="translated">그래서 있음 &lt;code&gt;mytext&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 연산자는 바로 정확한 경기 규칙에 따라 발견된다. 가장 일치하는 규칙에 도달하면 도메인 유형의 운영자를 적극적으로 차별합니다. 그렇지 않은 경우, 캐스팅 규칙은 항상 도메인을 기본 유형으로 또는 기본 유형에서 캐스트 가능한 것으로 간주하므로 도메인 운영자는 다음과 같은 경우에 도메인 운영자를 사용할 수있는 것으로 간주되므로 이러한 운영자는 모호한 운영자 실패를 너무 많이 생성합니다. 기본 유형의 비슷한 이름의 연산자.</target>
        </trans-unit>
        <trans-unit id="e2d5b92a83b79fb705b5433a3595097766599749" translate="yes" xml:space="preserve">
          <source>so that the parent query's restrictions can be applied directly to scans of &lt;code&gt;big_table&lt;/code&gt;.</source>
          <target state="translated">부모 쿼리의 제한 사항을 &lt;code&gt;big_table&lt;/code&gt; 스캔에 직접 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33287210e7f37c0de60bcc486617260fed9646cd" translate="yes" xml:space="preserve">
          <source>so those parameters can be &lt;em&gt;anything&lt;/em&gt; valid in those particular locations. The result from this SELECT needs to return exactly two columns (which it will unless you try to list multiple fields for key or document). Beware that this simplistic approach requires that you validate any user-supplied values to avoid SQL injection attacks.</source>
          <target state="translated">그래서 이러한 매개 변수가 될 수 &lt;em&gt;아무것도&lt;/em&gt; 그 특정 위치에서 유효한. 이 SELECT의 결과는 정확히 두 개의 열을 리턴해야합니다 (키 또는 문서에 대해 여러 필드를 나열하려고 시도하지 않는 한). 이 간단한 접근 방식에서는 SQL 주입 공격을 피하기 위해 사용자 제공 값의 유효성을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bbe4f2c3d484261a28a0a9d79b86a28dda8aed6" translate="yes" xml:space="preserve">
          <source>sort array &amp;mdash; &lt;em&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/em&gt; must be &lt;code&gt;asc&lt;/code&gt; or &lt;code&gt;desc&lt;/code&gt;</source>
          <target state="translated">정렬 배열 &amp;mdash; &lt;em&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;asc&lt;/code&gt; 또는 &lt;code&gt;desc&lt;/code&gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9ab26c613ad783ec5c4279647c4568cb60270e77" translate="yes" xml:space="preserve">
          <source>sort in ascending order</source>
          <target state="translated">오름차순으로 정렬</target>
        </trans-unit>
        <trans-unit id="fb775ca116e6daf98d00622b5a2803573dc2febb" translate="yes" xml:space="preserve">
          <source>sort in descending order</source>
          <target state="translated">내림차순으로 정렬</target>
        </trans-unit>
        <trans-unit id="ca3c7b2fd53d38a6a7c264721dafcec998424fe9" translate="yes" xml:space="preserve">
          <source>spell mode (not implemented)</source>
          <target state="translated">철자 모드 (구현되지 않음)</target>
        </trans-unit>
        <trans-unit id="efee56d94903e1b7e28b79f8005d10a42494ad38" translate="yes" xml:space="preserve">
          <source>spi</source>
          <target state="translated">spi</target>
        </trans-unit>
        <trans-unit id="07ad7dd79d10d356d3f19ca7b4961bd475f4ce9c" translate="yes" xml:space="preserve">
          <source>splits string into array elements using supplied delimiter and optional null string</source>
          <target state="translated">제공된 구분 기호 및 선택적 null 문자열을 사용하여 문자열을 배열 요소로 분할</target>
        </trans-unit>
        <trans-unit id="d2e8f58c13899630f0106304b4acdc14ab8327ed" translate="yes" xml:space="preserve">
          <source>square of the correlation coefficient</source>
          <target state="translated">상관 계수의 제곱</target>
        </trans-unit>
        <trans-unit id="7ffba3c538fd4255e879f2b7a70c1b72afcd84f0" translate="yes" xml:space="preserve">
          <source>square root</source>
          <target state="translated">제곱근</target>
        </trans-unit>
        <trans-unit id="d29e8b0f25329304da24b8f5667deb49b699ff9c" translate="yes" xml:space="preserve">
          <source>ssl_ca_file</source>
          <target state="translated">ssl_ca_file</target>
        </trans-unit>
        <trans-unit id="2775392bb369de7d75269131ab9f0f5c70d8d785" translate="yes" xml:space="preserve">
          <source>ssl_crl_file</source>
          <target state="translated">ssl_crl_file</target>
        </trans-unit>
        <trans-unit id="d63313191bc16a4e5613009efa64dfed354c4d72" translate="yes" xml:space="preserve">
          <source>sslinfo</source>
          <target state="translated">sslinfo</target>
        </trans-unit>
        <trans-unit id="0e24c2b184b5e3e7b75dfc61701788e720c9898e" translate="yes" xml:space="preserve">
          <source>state of true or false</source>
          <target state="translated">참 또는 거짓 상태</target>
        </trans-unit>
        <trans-unit id="76d6ac0cd9f5ce2ee31b1316375ad2ee4ceb0a05" translate="yes" xml:space="preserve">
          <source>strict &amp;mdash; if a structural error occurs, an error is raised.</source>
          <target state="translated">엄격 &amp;mdash; 구조적 오류가 발생하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c725950adf558e08ebc2be1f8506cf33d890586" translate="yes" xml:space="preserve">
          <source>strictly left of</source>
          <target state="translated">엄격히 왼쪽</target>
        </trans-unit>
        <trans-unit id="16e3eac5295a5a86760ddf1668ab883d6f97e415" translate="yes" xml:space="preserve">
          <source>strictly right of</source>
          <target state="translated">의 권리</target>
        </trans-unit>
        <trans-unit id="ff0902db07bc383387414b9b62a35d91a903191b" translate="yes" xml:space="preserve">
          <source>stripping characters from beginning (at prefix) or end (at suffix) of the word</source>
          <target state="translated">단어의 시작 (접두사) 또는 끝 (접미사)에서 문자 제거</target>
        </trans-unit>
        <trans-unit id="a2ee44ca661afb794a87a879241a503270262fe3" translate="yes" xml:space="preserve">
          <source>subpath of &lt;code&gt;ltree&lt;/code&gt; from position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to position &lt;em&gt;&lt;code&gt;end&lt;/code&gt;&lt;/em&gt;-1 (counting from 0)</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 에서 위치 &lt;em&gt; &lt;code&gt;end&lt;/code&gt; &lt;/em&gt; -1 까지 의 &lt;code&gt;ltree&lt;/code&gt; 하위 경로 (0부터 계산)&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db7985ce034d4afe6de74558c8e7ec35b413a467" translate="yes" xml:space="preserve">
          <source>subpath of &lt;code&gt;ltree&lt;/code&gt; starting at position &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, extending to end of path. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, subpath starts that far from the end of the path.</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작하여 경로 끝으로 확장되는 &lt;code&gt;ltree&lt;/code&gt; 의 하위 경로. 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정, 서브 패스의 시작입니다까지 경로의 끝에서.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c84f52912bfefd68b6818002b2502e529886498e" translate="yes" xml:space="preserve">
          <source>subpath of &lt;code&gt;ltree&lt;/code&gt; starting at position &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, length &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, subpath starts that far from the end of the path. If &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; is negative, leaves that many labels off the end of the path.</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; , 길이 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 에서 시작 하는 &lt;code&gt;ltree&lt;/code&gt; 의 서브 패스 . 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정, 서브 패스의 시작입니다까지 경로의 끝에서. 경우 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 부정적, 잎이며 많은 레이블 경로의 끝에 끕니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="148d46fb75d907f1fd6bcb109cb532d2ed504a21" translate="yes" xml:space="preserve">
          <source>subtraction</source>
          <target state="translated">subtraction</target>
        </trans-unit>
        <trans-unit id="65d1e029a91246a971c572acd9ec3d08d257f763" translate="yes" xml:space="preserve">
          <source>sum of &lt;code&gt;expression&lt;/code&gt; across all non-null input values</source>
          <target state="translated">널이 아닌 모든 입력 값에 대한 &lt;code&gt;expression&lt;/code&gt; 합</target>
        </trans-unit>
        <trans-unit id="09f5c2fc49e7c07dd883faf65026ffe4105202a6" translate="yes" xml:space="preserve">
          <source>summarize page ranges not already summarized</source>
          <target state="translated">아직 요약되지 않은 페이지 범위 요약</target>
        </trans-unit>
        <trans-unit id="c24280a4a78ffdc75c705d5e8ce72de573b9991a" translate="yes" xml:space="preserve">
          <source>summarize the page range covering the given block, if not already summarized</source>
          <target state="translated">주어진 블록을 포함하는 페이지 범위를 요약하지 않은 경우 요약합니다.</target>
        </trans-unit>
        <trans-unit id="8c87e21d0d6de8652d2e01dca2c7ebde52c0aa50" translate="yes" xml:space="preserve">
          <source>summary of client authentication configuration file contents</source>
          <target state="translated">클라이언트 인증 구성 파일 내용 요약</target>
        </trans-unit>
        <trans-unit id="58142ece3d6a908aba0b58fc5cad299c6174210e" translate="yes" xml:space="preserve">
          <source>summary of configuration file contents</source>
          <target state="translated">구성 파일 내용 요약</target>
        </trans-unit>
        <trans-unit id="e04e42dee218dde251ef4ebdcb76ed806dcd11e5" translate="yes" xml:space="preserve">
          <source>superuser status</source>
          <target state="translated">수퍼 유저 상태</target>
        </trans-unit>
        <trans-unit id="5326eb908107f97478c23d9b99f7cb41cf4644c3" translate="yes" xml:space="preserve">
          <source>synonym for backslash (&lt;code&gt;\&lt;/code&gt;) to help reduce the need for backslash doubling</source>
          <target state="translated">백 슬래시 배가의 필요성을 줄이는 데 도움이 되는 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )의 동의어</target>
        </trans-unit>
        <trans-unit id="e0543ba22ccc80a5d2365241ee2adb754f80be19" translate="yes" xml:space="preserve">
          <source>syslog</source>
          <target state="translated">syslog</target>
        </trans-unit>
        <trans-unit id="b5f19ccea91f97d4b15d06255ee16e18d4f5df7e" translate="yes" xml:space="preserve">
          <source>t_cid</source>
          <target state="translated">t_cid</target>
        </trans-unit>
        <trans-unit id="3566c3333b7c1e7dc546f8fd79009bce96d3a9f1" translate="yes" xml:space="preserve">
          <source>t_ctid</source>
          <target state="translated">t_ctid</target>
        </trans-unit>
        <trans-unit id="906c2d9bf143985320f3172f192daac3e80b12eb" translate="yes" xml:space="preserve">
          <source>t_hoff</source>
          <target state="translated">t_hoff</target>
        </trans-unit>
        <trans-unit id="218215b970a0f483facba84ec4d966687ecce7a8" translate="yes" xml:space="preserve">
          <source>t_infomask</source>
          <target state="translated">t_infomask</target>
        </trans-unit>
        <trans-unit id="55cda73bf8273d254cca1cabe30439d075274f02" translate="yes" xml:space="preserve">
          <source>t_infomask2</source>
          <target state="translated">t_infomask2</target>
        </trans-unit>
        <trans-unit id="f688b8f7e24c0430b3539f7001dfaab559aef213" translate="yes" xml:space="preserve">
          <source>t_xmax</source>
          <target state="translated">t_xmax</target>
        </trans-unit>
        <trans-unit id="3e027aae59957e2fe3d0ceca25224da26dc08f92" translate="yes" xml:space="preserve">
          <source>t_xmin</source>
          <target state="translated">t_xmin</target>
        </trans-unit>
        <trans-unit id="ac0ede48d7d4858148c9f1d118fd54633957d4ec" translate="yes" xml:space="preserve">
          <source>t_xvac</source>
          <target state="translated">t_xvac</target>
        </trans-unit>
        <trans-unit id="e974602114f14fbf55401c109937e173b1b23220" translate="yes" xml:space="preserve">
          <source>tab</source>
          <target state="translated">tab</target>
        </trans-unit>
        <trans-unit id="539f190c6cfa469da7783a58b84a11ba6723b3ed" translate="yes" xml:space="preserve">
          <source>table columns (&amp;ldquo;attributes&amp;rdquo;)</source>
          <target state="translated">테이블 열 ( &quot;속성&quot;)</target>
        </trans-unit>
        <trans-unit id="6044dcccc38779772fabb83f940da1325990ecdf" translate="yes" xml:space="preserve">
          <source>table inheritance hierarchy</source>
          <target state="translated">테이블 상속 계층</target>
        </trans-unit>
        <trans-unit id="f21cabf566df4a25de1bab1e0837d3989e5dc66b" translate="yes" xml:space="preserve">
          <source>table rows</source>
          <target state="translated">테이블 행</target>
        </trans-unit>
        <trans-unit id="3fbbef6781f1813071bdc92cdf08e9b81d54c1f1" translate="yes" xml:space="preserve">
          <source>table rows and row locks</source>
          <target state="translated">테이블 행 및 행 잠금</target>
        </trans-unit>
        <trans-unit id="10cc15a4361cbd00043d8d62255c92110f6cc283" translate="yes" xml:space="preserve">
          <source>table/column name separator</source>
          <target state="translated">테이블 / 열 이름 구분 기호</target>
        </trans-unit>
        <trans-unit id="2a84340fb304f44925184800129598d97f49a2b4" translate="yes" xml:space="preserve">
          <source>tablefunc</source>
          <target state="translated">tablefunc</target>
        </trans-unit>
        <trans-unit id="3915396b5fe58dce8505b3e62c31b4f79b3ccc2c" translate="yes" xml:space="preserve">
          <source>tables</source>
          <target state="translated">tables</target>
        </trans-unit>
        <trans-unit id="3eb23c4bab7e32930a985de5e12e792e44e167aa" translate="yes" xml:space="preserve">
          <source>tables, indexes, sequences, views (&amp;ldquo;relations&amp;rdquo;)</source>
          <target state="translated">테이블, 인덱스, 시퀀스, 뷰 ( &quot;관계&quot;)</target>
        </trans-unit>
        <trans-unit id="e05d28c3042a9932c72923ff3735eb14986d9865" translate="yes" xml:space="preserve">
          <source>tablespaces within this database cluster</source>
          <target state="translated">이 데이터베이스 클러스터 내의 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="04a662df36aeb5b23cf012b1ff916de932b16f68" translate="yes" xml:space="preserve">
          <source>tangent</source>
          <target state="translated">tangent</target>
        </trans-unit>
        <trans-unit id="cd0fa5ece2c6e9528c815c5ea2f02656d4885419" translate="yes" xml:space="preserve">
          <source>tcn</source>
          <target state="translated">tcn</target>
        </trans-unit>
        <trans-unit id="c5db23c752c68e4d55538e93bfa3ce941678aa84" translate="yes" xml:space="preserve">
          <source>template data for procedural languages</source>
          <target state="translated">절차 적 언어의 템플릿 데이터</target>
        </trans-unit>
        <trans-unit id="8eea0dbe1b0e9a919b18d7021f82a37a6d7c7718" translate="yes" xml:space="preserve">
          <source>test a configuration</source>
          <target state="translated">구성 테스트</target>
        </trans-unit>
        <trans-unit id="fd37c37fecb0d96a58174a99ee410100079e48fc" translate="yes" xml:space="preserve">
          <source>test a dictionary</source>
          <target state="translated">사전을 시험하다</target>
        </trans-unit>
        <trans-unit id="fda4b2d759b71d3f97140244c5f3ec627c2b55f3" translate="yes" xml:space="preserve">
          <source>test a parser</source>
          <target state="translated">파서를 테스트</target>
        </trans-unit>
        <trans-unit id="01ee0ff2889bfeb9730ae8ee3f6a11e6a75c4329" translate="yes" xml:space="preserve">
          <source>test whether an index access method has a specified property</source>
          <target state="translated">인덱스 액세스 방법에 지정된 속성이 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="6369d5568ef487e68f0502b41cd4c863cb98d191" translate="yes" xml:space="preserve">
          <source>test whether an index column has a specified property</source>
          <target state="translated">인덱스 열에 지정된 속성이 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="0a78395943c148a0e65cc0b00b33b2dc5c67c724" translate="yes" xml:space="preserve">
          <source>test whether an index has a specified property</source>
          <target state="translated">인덱스에 지정된 속성이 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="136e386e2bd42653ff2f4bb324e89751746b5a98" translate="yes" xml:space="preserve">
          <source>test_decoding</source>
          <target state="translated">test_decoding</target>
        </trans-unit>
        <trans-unit id="3c7bb6a0fede2d554560499fd4fb3f4027e84dd9" translate="yes" xml:space="preserve">
          <source>text of the currently executing query, as submitted by the client (might contain more than one statement)</source>
          <target state="translated">클라이언트가 제출 한 현재 실행중인 쿼리의 텍스트 (두 개 이상의 명령문을 포함 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="262239a41b135d05790ef69def8268bf051ef132" translate="yes" xml:space="preserve">
          <source>text search configuration</source>
          <target state="translated">텍스트 검색 구성</target>
        </trans-unit>
        <trans-unit id="dc59c4b8921d0c5c108d497968cc5eca63c40a45" translate="yes" xml:space="preserve">
          <source>text search configurations</source>
          <target state="translated">텍스트 검색 구성</target>
        </trans-unit>
        <trans-unit id="6f423eeeef1ded8a7df8e347ea3b02639ee83a76" translate="yes" xml:space="preserve">
          <source>text search configurations' token mappings</source>
          <target state="translated">텍스트 검색 구성의 토큰 매핑</target>
        </trans-unit>
        <trans-unit id="4a90227c13fd84c9cc0f3eed6e793c54b874bc0c" translate="yes" xml:space="preserve">
          <source>text search dictionaries</source>
          <target state="translated">텍스트 검색 사전</target>
        </trans-unit>
        <trans-unit id="c173e71038b608a5c1c0b8b5fd855e11d8eb7b20" translate="yes" xml:space="preserve">
          <source>text search dictionary</source>
          <target state="translated">텍스트 검색 사전</target>
        </trans-unit>
        <trans-unit id="a475eff8ebd03c8c3c3373631c481d09aca484e9" translate="yes" xml:space="preserve">
          <source>text search document</source>
          <target state="translated">텍스트 검색 문서</target>
        </trans-unit>
        <trans-unit id="0d90e6d4122e65f9b7d5edeea7b27dfadab2bfb2" translate="yes" xml:space="preserve">
          <source>text search parsers</source>
          <target state="translated">텍스트 검색 파서</target>
        </trans-unit>
        <trans-unit id="1eaf6a8a449804f77d406cbabc050e21c053c5da" translate="yes" xml:space="preserve">
          <source>text search query</source>
          <target state="translated">텍스트 검색어</target>
        </trans-unit>
        <trans-unit id="1dfaa13ffd2afb6f6dd51c3343b0a8fd4173e0dd" translate="yes" xml:space="preserve">
          <source>text search templates</source>
          <target state="translated">텍스트 검색 템플릿</target>
        </trans-unit>
        <trans-unit id="3ccd4b9b1fc8d97f17bea17bb0147fb21fb6ee0f" translate="yes" xml:space="preserve">
          <source>textual JSON data</source>
          <target state="translated">텍스트 JSON 데이터</target>
        </trans-unit>
        <trans-unit id="327dd5dc64b82107d30da0f7b5b23a327a33f652" translate="yes" xml:space="preserve">
          <source>that is, one whole bucket plus a linear fraction of the second, divided by the number of buckets. The estimated number of rows can now be calculated as the product of the selectivity and the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">즉, 하나의 전체 버킷과 두 번째의 선형 비율을 버킷 수로 나눈 값입니다. 예상 행 수는 이제 선택도 및 카디널리티 &lt;code&gt;tenk1&lt;/code&gt; 의 곱으로 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13aaac9452dafc1adedc1cb992241d4d10016515" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;&amp;lt;&lt;/code&gt; comparison is performed according to &lt;code&gt;de_DE&lt;/code&gt; rules, because the expression combines an implicitly derived collation with the default collation. But in</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 비교에 따라 수행된다 &lt;code&gt;de_DE&lt;/code&gt; 발현 기본 콜레 암시 유도 정렬을 결합하기 때문에, 규칙. 그러나</target>
        </trans-unit>
        <trans-unit id="a3a0853b309b91e750aa6c995b1ed30221e3d7fb" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;OPERATOR&lt;/code&gt; construct is taken to have the default precedence shown in &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE-TABLE&quot;&gt;Table 4.2&lt;/a&gt; for &amp;ldquo;any other operator&amp;rdquo;. This is true no matter which specific operator appears inside &lt;code&gt;OPERATOR()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; 의 구조는 기본적으로 나타낸 우선 순위가 취해진 다 &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE-TABLE&quot;&gt;표 4.2&lt;/a&gt; &quot;다른 연산자&quot;로한다. 이것은 &lt;code&gt;OPERATOR()&lt;/code&gt; 안에 어떤 특정 연산자가 나타나는지에 관계없이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="692d3dbb22fcf56525bbfdad2ab865e41fbfb12a" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;WITH&lt;/code&gt; query will be materialized, producing a temporary copy of &lt;code&gt;big_table&lt;/code&gt; that is then joined with itself &amp;mdash; without benefit of any index. This query will be executed much more efficiently if written as</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 쿼리의 임시 복사본 생성 구체화 될 것이다 &lt;code&gt;big_table&lt;/code&gt; 어떤 인덱스의 혜택없이 - 다음 자체와 결합되는 것을. 이 쿼리는 다음과 같이 작성하면 훨씬 효율적으로 실행됩니다</target>
        </trans-unit>
        <trans-unit id="68a3e816bafbbd38d1315ac2b7739fca48d634f2" translate="yes" xml:space="preserve">
          <source>the SQL/JSON path language</source>
          <target state="translated">SQL / JSON 경로 언어</target>
        </trans-unit>
        <trans-unit id="cfd6f4954706a27f3fed453664626de5f684d01e" translate="yes" xml:space="preserve">
          <source>the average (arithmetic mean) of all non-null input values</source>
          <target state="translated">널이 아닌 모든 입력 값의 평균 (산술 평균)</target>
        </trans-unit>
        <trans-unit id="e121256ee6598dbd950a22c0a77e7b4b0350e572" translate="yes" xml:space="preserve">
          <source>the bitwise AND of all non-null input values, or null if none</source>
          <target state="translated">null 이외의 모든 입력 값의 비트 AND. 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="7cef86adb7c1a5ce3f1811981d8674ac103930aa" translate="yes" xml:space="preserve">
          <source>the bitwise OR of all non-null input values, or null if none</source>
          <target state="translated">null 이외의 모든 입력 치의 비트 단위 OR.없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="ccb4720bc22a556d25cbe1a747ae19fc5c271450" translate="yes" xml:space="preserve">
          <source>the character whose collating-sequence name is &lt;code&gt;ESC&lt;/code&gt;, or failing that, the character with octal value &lt;code&gt;033&lt;/code&gt;</source>
          <target state="translated">조합 순서 명이 &lt;code&gt;ESC&lt;/code&gt; 인 캐릭터, 또는 실패한 경우, 8 진 치가 &lt;code&gt;033&lt;/code&gt; 인 캐릭터</target>
        </trans-unit>
        <trans-unit id="e48210f07eb6dca117738a3754973042871ed42c" translate="yes" xml:space="preserve">
          <source>the character whose value is &lt;code&gt;0&lt;/code&gt; (the null byte)</source>
          <target state="translated">값이 &lt;code&gt;0&lt;/code&gt; 인 문자 (널 바이트)</target>
        </trans-unit>
        <trans-unit id="dc943613073c0cf4c6ae229720a8ca8e66b2c2ab" translate="yes" xml:space="preserve">
          <source>the comparison is performed using &lt;code&gt;fr_FR&lt;/code&gt; rules, because the explicit collation derivation overrides the implicit one. Furthermore, given</source>
          <target state="translated">명시 적 데이터 정렬 파생이 암시 적 규칙보다 우선하기 때문에 &lt;code&gt;fr_FR&lt;/code&gt; 규칙을 사용하여 비교가 수행됩니다 . 또한, 주어진</target>
        </trans-unit>
        <trans-unit id="67f903fa66c74bd798e19bdd9417f38e203398e4" translate="yes" xml:space="preserve">
          <source>the contents of the WHERE clause. This cannot be omitted, so use &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1=1&lt;/code&gt; if you want to process all the rows in the relation</source>
          <target state="translated">WHERE 절의 내용 생략 할 수 없으므로 관계의 모든 행을 처리 하려면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;1=1&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cf8bcd18127e475c226093573533808203171701" translate="yes" xml:space="preserve">
          <source>the estimated cost and row count for the Index Scan node are shown as though it were run to completion. But in reality the Limit node stopped requesting rows after it got two, so the actual row count is only 2 and the run time is less than the cost estimate would suggest. This is not an estimation error, only a discrepancy in the way the estimates and true values are displayed.</source>
          <target state="translated">인덱스 스캔 노드의 예상 비용 및 행 수는 완료까지 실행 된 것으로 표시됩니다. 그러나 실제로 한계 노드는 2 개를 얻은 후에 행 요청을 중지 했으므로 실제 행 수는 2이고 실행 시간은 예상 비용보다 적습니다. 이것은 추정 오차가 아니며 추정치와 실제 값이 표시되는 방식의 차이 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="307b7b912d469ebb074397ba0e4ce4d2b7c7d8fd" translate="yes" xml:space="preserve">
          <source>the name of the &amp;ldquo;key&amp;rdquo; field &amp;mdash; this is just a field to be used as the first column of the output table, i.e., it identifies the record from which each output row came (see note below about multiple values)</source>
          <target state="translated">&quot;키&quot;필드의 이름-이것은 출력 테이블의 첫 번째 열로 사용될 필드입니다. 즉, 각 출력 행이 나온 레코드를 식별합니다 (여러 값에 대해서는 아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="f232d9d562d9367d1dc1d3b757de968dbe7eba7a" translate="yes" xml:space="preserve">
          <source>the name of the field containing the XML document</source>
          <target state="translated">XML 문서를 포함하는 필드의 이름</target>
        </trans-unit>
        <trans-unit id="a4add5db060b3f4241ef36678355329244966dc1" translate="yes" xml:space="preserve">
          <source>the name of the table or view containing the documents</source>
          <target state="translated">문서를 포함하는 테이블 또는 뷰의 이름</target>
        </trans-unit>
        <trans-unit id="bfdc5bc44c2880cc5dae08ec8961eb2ab399a3f7" translate="yes" xml:space="preserve">
          <source>the new PostgreSQL executable directory; environment variable &lt;code&gt;PGBINNEW&lt;/code&gt;</source>
          <target state="translated">새로운 PostgreSQL 실행 디렉토리; 환경 변수 &lt;code&gt;PGBINNEW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eef95f709069bb1666ba77bdce6f9f945b42f62f" translate="yes" xml:space="preserve">
          <source>the new cluster port number; environment variable &lt;code&gt;PGPORTNEW&lt;/code&gt;</source>
          <target state="translated">새로운 클러스터 포트 번호; 환경 변수 &lt;code&gt;PGPORTNEW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="047de36a4c83d7de99f696d8e01f43a0bc061673" translate="yes" xml:space="preserve">
          <source>the new database cluster configuration directory; environment variable &lt;code&gt;PGDATANEW&lt;/code&gt;</source>
          <target state="translated">새로운 데이터베이스 클러스터 구성 디렉토리; 환경 변수 &lt;code&gt;PGDATANEW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16c62222ab02e25661dde573b5c8e6c3a3d1a3ad" translate="yes" xml:space="preserve">
          <source>the old PostgreSQL executable directory; environment variable &lt;code&gt;PGBINOLD&lt;/code&gt;</source>
          <target state="translated">이전 PostgreSQL 실행 파일 디렉토리; 환경 변수 &lt;code&gt;PGBINOLD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1064b361d7619de39dcff5be794668d124216960" translate="yes" xml:space="preserve">
          <source>the old cluster port number; environment variable &lt;code&gt;PGPORTOLD&lt;/code&gt;</source>
          <target state="translated">이전 클러스터 포트 번호; 환경 변수 &lt;code&gt;PGPORTOLD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58793dcee0d39f4a57ec2eae4c6562b49ae428bf" translate="yes" xml:space="preserve">
          <source>the old database cluster configuration directory; environment variable &lt;code&gt;PGDATAOLD&lt;/code&gt;</source>
          <target state="translated">이전 데이터베이스 클러스터 구성 디렉토리; 환경 변수 &lt;code&gt;PGDATAOLD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50a49416dffc3fc516dc2db500e43a1d23fb67a8" translate="yes" xml:space="preserve">
          <source>the ordering will be done according to &lt;code&gt;de_DE&lt;/code&gt; rules. But this query:</source>
          <target state="translated">순서는 &lt;code&gt;de_DE&lt;/code&gt; 규칙 에 따라 수행됩니다 . 그러나이 쿼리 :</target>
        </trans-unit>
        <trans-unit id="8d6b9af88d7b3358ed10a1ac78512d2e224067ae" translate="yes" xml:space="preserve">
          <source>the outer &lt;code&gt;SELECT&lt;/code&gt; would return the original prices before the action of the &lt;code&gt;UPDATE&lt;/code&gt;, while in</source>
          <target state="translated">외부 &lt;code&gt;SELECT&lt;/code&gt; 는 &lt;code&gt;UPDATE&lt;/code&gt; 작업 전에 원래 가격을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2e0353aea2c20b6763d8c7f7b14c65ae7297a6f1" translate="yes" xml:space="preserve">
          <source>the outer &lt;code&gt;SELECT&lt;/code&gt; would return the updated data.</source>
          <target state="translated">외부 &lt;code&gt;SELECT&lt;/code&gt; 는 업데이트 된 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a5ed5fd0a8e425db5af03a91264aaa32fda43c6" translate="yes" xml:space="preserve">
          <source>the parser cannot determine which collation to apply, since the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; columns have conflicting implicit collations. Since the &lt;code&gt;&amp;lt;&lt;/code&gt; operator does need to know which collation to use, this will result in an error. The error can be resolved by attaching an explicit collation specifier to either input expression, thus:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 열에 충돌하는 암시 적 데이터 정렬이 있으므로 구문 분석기가 적용 할 데이터 정렬을 결정할 수 없습니다 . &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자는 사용할 데이터 정렬을 알아야하기 때문에 오류가 발생합니다. 명시 적 데이터 정렬 지정자를 입력 표현식에 첨부하여 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449a2bf2bd22fbd6eb33a3054acb7a3d9eb99581" translate="yes" xml:space="preserve">
          <source>the planner is free to join the given tables in any order. For example, it could generate a query plan that joins A to B, using the &lt;code&gt;WHERE&lt;/code&gt; condition &lt;code&gt;a.id = b.id&lt;/code&gt;, and then joins C to this joined table, using the other &lt;code&gt;WHERE&lt;/code&gt; condition. Or it could join B to C and then join A to that result. Or it could join A to C and then join them with B &amp;mdash; but that would be inefficient, since the full Cartesian product of A and C would have to be formed, there being no applicable condition in the &lt;code&gt;WHERE&lt;/code&gt; clause to allow optimization of the join. (All joins in the PostgreSQL executor happen between two input tables, so it's necessary to build up the result in one or another of these fashions.) The important point is that these different join possibilities give semantically equivalent results but might have hugely different execution costs. Therefore, the planner will explore all of them to try to find the most efficient query plan.</source>
          <target state="translated">플래너는 주어진 테이블을 임의의 순서로 자유롭게 결합 할 수 있습니다. 예를 들어, &lt;code&gt;WHERE&lt;/code&gt; 조건 &lt;code&gt;a.id = b.id&lt;/code&gt; 사용하여 A를 B에 조인 한 다음 다른 &lt;code&gt;WHERE&lt;/code&gt; 조건을 사용하여 C를이 조인 된 테이블에 조인하는 쿼리 계획을 생성 할 수 있습니다. 또는 B를 C에 결합시킨 다음 A를 그 결과에 결합시킬 수 있습니다. 아니면 C에 가입 한 후 B로 가입 할 수 -하지만 A와 C의 전체 데카르트 제품부터 형성되어야 할 것이다, 비효율적의에서 적용 가능한 조건이 존재하지 &lt;code&gt;WHERE&lt;/code&gt; 에게조인의 최적화를 허용하는 절. (PostgreSQL 실행 프로그램의 모든 조인은 두 개의 입력 테이블 사이에서 발생하므로 이러한 방식 중 하나를 사용하여 결과를 작성해야합니다.) 중요한 점은 이러한 서로 다른 조인 가능성이 의미 적으로 동등한 결과를 제공하지만 실행 비용이 크게 다를 수 있다는 것입니다. . 따라서 플래너는 가장 효율적인 쿼리 계획을 찾기 위해 모든 것을 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="8fea5fc0258f7fff14a4bf4c6b5adb0eddd4ecc8" translate="yes" xml:space="preserve">
          <source>the planner will disregard the &lt;code&gt;city&lt;/code&gt; clause as not changing the selectivity, which is correct. However, it will make the same assumption about</source>
          <target state="translated">플래너는 &lt;code&gt;city&lt;/code&gt; 조항을 선택도를 변경하지 않는 것으로 무시합니다 . 그러나 동일한 가정을합니다.</target>
        </trans-unit>
        <trans-unit id="68d57bf578d30a6a56c4aeb65e05915bea7742be" translate="yes" xml:space="preserve">
          <source>the session would have use of only those privileges granted to &lt;code&gt;admin&lt;/code&gt;, and not those granted to &lt;code&gt;joe&lt;/code&gt;. After:</source>
          <target state="translated">세션은 &lt;code&gt;joe&lt;/code&gt; 에게 부여 된 권한이 아닌 &lt;code&gt;admin&lt;/code&gt; 에게 부여 된 권한 만 사용 합니다. 후:</target>
        </trans-unit>
        <trans-unit id="deff53370899ab0952270a9c1e224bf7c655df0c" translate="yes" xml:space="preserve">
          <source>the session would have use of only those privileges granted to &lt;code&gt;wheel&lt;/code&gt;, and not those granted to either &lt;code&gt;joe&lt;/code&gt; or &lt;code&gt;admin&lt;/code&gt;. The original privilege state can be restored with any of:</source>
          <target state="translated">세션은 &lt;code&gt;wheel&lt;/code&gt; 에게 부여 된 권한 만 사용 하고 &lt;code&gt;joe&lt;/code&gt; 또는 &lt;code&gt;admin&lt;/code&gt; 에게 부여 된 권한은 사용 하지 않습니다 . 원래 권한 상태는 다음 중 하나를 사용하여 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a629578dc1ac76e946c713046793a9150b785f" translate="yes" xml:space="preserve">
          <source>the smallest network which includes both of the given networks</source>
          <target state="translated">주어진 네트워크를 모두 포함하는 가장 작은 네트워크</target>
        </trans-unit>
        <trans-unit id="0e174768520268ac2fa949a909a94d5d4ee88b6c" translate="yes" xml:space="preserve">
          <source>the smallest range which includes both of the given ranges</source>
          <target state="translated">주어진 범위를 모두 포함하는 가장 작은 범위</target>
        </trans-unit>
        <trans-unit id="6fc28ad78efaa5e3b63b3b1348a9b0a8c5c3ce00" translate="yes" xml:space="preserve">
          <source>the string must begin with &lt;code&gt;P&lt;/code&gt;, and a &lt;code&gt;T&lt;/code&gt; separates the date and time parts of the interval. The values are given as numbers similar to ISO 8601 dates.</source>
          <target state="translated">문자열은 &lt;code&gt;P&lt;/code&gt; 로 시작해야 하며 &lt;code&gt;T&lt;/code&gt; 는 간격의 날짜 및 시간 부분을 구분합니다. 값은 ISO 8601 날짜와 유사한 숫자로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="674c279997ed5c86b11d56ba540cf11094276d75" translate="yes" xml:space="preserve">
          <source>the traditional approach to speeding up such queries would be to create an index on &lt;code&gt;x&lt;/code&gt; only. However, an index defined as</source>
          <target state="translated">이러한 쿼리 속도를 높이기위한 기존의 접근 방식은 &lt;code&gt;x&lt;/code&gt; 에 대해서만 인덱스를 작성하는 것 입니다. 그러나 인덱스는</target>
        </trans-unit>
        <trans-unit id="862685a78a839c855a395d7bb986bbab1ed890d8" translate="yes" xml:space="preserve">
          <source>the uniqueness condition applies to just column &lt;code&gt;x&lt;/code&gt;, not to the combination of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. (An &lt;code&gt;INCLUDE&lt;/code&gt; clause can also be written in &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints, providing alternative syntax for setting up an index like this.)</source>
          <target state="translated">고유성 조건 은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 조합이 아닌 &lt;code&gt;x&lt;/code&gt; 열에 만 적용됩니다 . (과는 &lt;code&gt;INCLUDE&lt;/code&gt; 절도 작성할 수 있습니다 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 의 이 같은 인덱스를 설정하기위한 대안 구문을 제공, 제약.)</target>
        </trans-unit>
        <trans-unit id="1fe91804ad697d3116d66bcc7e8fa7c5c0ed77c2" translate="yes" xml:space="preserve">
          <source>the whitespace will be ignored if the field type is integer, but not if it is text.</source>
          <target state="translated">필드 유형이 정수인 경우 공백이 무시되지만 텍스트 인 경우에는 공백이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad76f53ea805e426301ceff5c8ced8f35125123c" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;somefunc()&lt;/code&gt; would (probably) not be called at all. The same would be the case if one wrote:</source>
          <target state="translated">그러면 &lt;code&gt;somefunc()&lt;/code&gt; 가 전혀 호출되지 않을 것입니다. 다음과 같이 쓴 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="089585ade96141f6137202b19b0f873716bd658f" translate="yes" xml:space="preserve">
          <source>then PostgreSQL was not installed properly. Either it was not installed at all or your shell's search path was not set to include it. Try calling the command with an absolute path instead:</source>
          <target state="translated">PostgreSQL이 제대로 설치되지 않았습니다. 전혀 설치되지 않았거나 쉘의 검색 경로가 포함되지 않도록 설정되었습니다. 대신 절대 경로를 사용하여 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="e46e625b31bfd81aaa584e64018e61cbb218ea95" translate="yes" xml:space="preserve">
          <source>then a label not matching &lt;code&gt;football&lt;/code&gt; nor &lt;code&gt;tennis&lt;/code&gt;</source>
          <target state="translated">그런 다음 &lt;code&gt;football&lt;/code&gt; 나 &lt;code&gt;tennis&lt;/code&gt; 와 일치하지 않는 라벨</target>
        </trans-unit>
        <trans-unit id="0b6bcdb33f5018845232e3051cc52aaf65bb775a" translate="yes" xml:space="preserve">
          <source>then all rows in the table will be deleted! Caveat programmer.</source>
          <target state="translated">테이블의 모든 행이 삭제됩니다! 경고 프로그래머.</target>
        </trans-unit>
        <trans-unit id="40fb4ee6aa859598a9c37c1fbc825bacd5ddfef0" translate="yes" xml:space="preserve">
          <source>then it might be appropriate to define an index on the columns &lt;code&gt;major&lt;/code&gt; and &lt;code&gt;minor&lt;/code&gt; together, e.g.:</source>
          <target state="translated">다음은 컬럼에 인덱스 정의 적합 할 수 있습니다 &lt;code&gt;major&lt;/code&gt; 및 &lt;code&gt;minor&lt;/code&gt; 함께, 예를 :</target>
        </trans-unit>
        <trans-unit id="9d27e7c457c4a52c8a6bde4f641352725f47fd06" translate="yes" xml:space="preserve">
          <source>then it might be worth creating an index like this:</source>
          <target state="translated">다음과 같은 색인을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa9dbd83d7e426c2e83718b8ab3bc0f8a4c4a8a1" translate="yes" xml:space="preserve">
          <source>then the same &lt;code&gt;inventory_item&lt;/code&gt; composite type shown above would come into being as a byproduct, and could be used just as above. Note however an important restriction of the current implementation: since no constraints are associated with a composite type, the constraints shown in the table definition &lt;em&gt;do not apply&lt;/em&gt; to values of the composite type outside the table. (To work around this, create a domain over the composite type, and apply the desired constraints as &lt;code&gt;CHECK&lt;/code&gt; constraints of the domain.)</source>
          <target state="translated">위에 표시된 것과 동일한 &lt;code&gt;inventory_item&lt;/code&gt; 복합 유형이 부산물로되어 위와 같이 사용될 수 있습니다. 그러나 현재 구현의 중요한 제한 사항에 유의하십시오. 복합 유형과 연관된 제한 조건이 없으므로 테이블 정의에 표시된 제한 조건이 테이블 외부의 복합 유형 값에 &lt;em&gt;적용되지 않습니다&lt;/em&gt; . 이 문제를 해결하려면 복합 유형 위에 도메인을 작성하고 원하는 제한 조건을 도메인의 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건으로 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac39d4ad084d724fa0bcd581aae9b198ada8a10" translate="yes" xml:space="preserve">
          <source>then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i + 0.5) - f(i - 0.5)&lt;/code&gt;. Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to the middle of the interval are drawn, and the less frequently values close to the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; bounds. About 67% of values are drawn from the middle &lt;code&gt;1.0 / parameter&lt;/code&gt;, that is a relative &lt;code&gt;0.5 / parameter&lt;/code&gt; around the mean, and 95% in the middle &lt;code&gt;2.0 / parameter&lt;/code&gt;, that is a relative &lt;code&gt;1.0 / parameter&lt;/code&gt; around the mean; for instance, if &lt;code&gt;parameter&lt;/code&gt; is 4.0, 67% of values are drawn from the middle quarter (1.0 / 4.0) of the interval (i.e. from &lt;code&gt;3.0 / 8.0&lt;/code&gt; to &lt;code&gt;5.0 / 8.0&lt;/code&gt;) and 95% from the middle half (&lt;code&gt;2.0 / 4.0&lt;/code&gt;) of the interval (second and third quartiles). The minimum allowed &lt;code&gt;parameter&lt;/code&gt; value is 2.0.</source>
          <target state="translated">그런 다음 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 값 사이의 값 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;f(i + 0.5) - f(i - 0.5)&lt;/code&gt; 확률로 그려집니다 . 직관적으로 &lt;code&gt;parameter&lt;/code&gt; 가 클수록 간격의 중간에 가까운 값이 더 자주 그려지고 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 경계에 가까운 값이 덜 자주 나타 납니다. 값의 약 67 %가 중앙으로부터 그려진 &lt;code&gt;1.0 / parameter&lt;/code&gt; 상대적이며 &lt;code&gt;0.5 / parameter&lt;/code&gt; 중간 평균 주위에 95 % &lt;code&gt;2.0 / parameter&lt;/code&gt; 상대적이며 &lt;code&gt;1.0 / parameter&lt;/code&gt; 평균 약; 예를 들어, &lt;code&gt;parameter&lt;/code&gt; 값이 4.0 인 경우 간격의 중간 분기 (1.0 / 4.0)에서 67 % (예 : &lt;code&gt;3.0 / 8.0&lt;/code&gt; ~ &lt;code&gt;5.0 / 8.0&lt;/code&gt; ) 및 간격 의 중간 절반 ( &lt;code&gt;2.0 / 4.0&lt;/code&gt; ) 에서 95 % (초 및 3 분위). 허용되는 최소 &lt;code&gt;parameter&lt;/code&gt; 값은 2.0입니다.</target>
        </trans-unit>
        <trans-unit id="d38e3b26d1226acb500b8ee6071a2d7ca057630c" translate="yes" xml:space="preserve">
          <source>then we get the following results for the various joins:</source>
          <target state="translated">그런 다음 다양한 조인에 대해 다음 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="52e8a28cfc35c704e96d85d3c117771bbe4ebb21" translate="yes" xml:space="preserve">
          <source>then, according to the SQL standard, we should get the contents of the table expanded into separate columns:</source>
          <target state="translated">그런 다음 SQL 표준에 따라 테이블의 내용을 별도의 열로 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad9d61c37bc7476b78610e5e4bdf997896c037ca" translate="yes" xml:space="preserve">
          <source>there is nothing to identify what type the string literal should be taken as. In this situation PostgreSQL will fall back to resolving the literal's type as &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">문자열 리터럴의 유형을 식별 할 수있는 것은 없습니다. 이 상황에서 PostgreSQL은 리터럴 유형을 &lt;code&gt;text&lt;/code&gt; 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="675ae7350f8af3e66ccdba7a28d3aa802f8f059c" translate="yes" xml:space="preserve">
          <source>tight syntax (default; see below)</source>
          <target state="translated">엄격한 구문 (기본값; 아래 참조)</target>
        </trans-unit>
        <trans-unit id="ac0ebd8468baebb9491a07eddd92e75f6c726bac" translate="yes" xml:space="preserve">
          <source>time interval</source>
          <target state="translated">시간 간격</target>
        </trans-unit>
        <trans-unit id="3ee1ea35bb76355841bda6b830868fe71c0df836" translate="yes" xml:space="preserve">
          <source>time of day (no date)</source>
          <target state="translated">시간 (날짜 없음)</target>
        </trans-unit>
        <trans-unit id="910c8c87788d6880db6b5dd0f0b8468a7eed8f9d" translate="yes" xml:space="preserve">
          <source>time of day (no date), with time zone</source>
          <target state="translated">시간대가있는 시간 (날짜 없음)</target>
        </trans-unit>
        <trans-unit id="e19861055f3ca8cb07211edc3d29e31ce26e5694" translate="yes" xml:space="preserve">
          <source>time of day (no time zone)</source>
          <target state="translated">시간대 (시간대 없음)</target>
        </trans-unit>
        <trans-unit id="0a541446be0ba0374ced11a39b31e0e7e6e4d50f" translate="yes" xml:space="preserve">
          <source>time of day, including time zone</source>
          <target state="translated">시간대를 포함한 시간</target>
        </trans-unit>
        <trans-unit id="9d5cd61c60ddd9ec810d1fca1879a37f916186dd" translate="yes" xml:space="preserve">
          <source>time span</source>
          <target state="translated">시간 범위</target>
        </trans-unit>
        <trans-unit id="4d45347beab7f84762668f97f8b6d14328b6f586" translate="yes" xml:space="preserve">
          <source>time with time zone</source>
          <target state="translated">시간대와 시간</target>
        </trans-unit>
        <trans-unit id="70201cff3483f8665e789ead1e8e4ba5bf8e02b8" translate="yes" xml:space="preserve">
          <source>time zone abbreviations</source>
          <target state="translated">시간대 약어</target>
        </trans-unit>
        <trans-unit id="882133be8af8c2816ca9e7b0fe6e3556c221875f" translate="yes" xml:space="preserve">
          <source>time zone names</source>
          <target state="translated">시간대 이름</target>
        </trans-unit>
        <trans-unit id="76023cb1359236643e55b8eee9559becc6cc116e" translate="yes" xml:space="preserve">
          <source>time zone specified by abbreviation</source>
          <target state="translated">약어로 지정된 시간대</target>
        </trans-unit>
        <trans-unit id="a39b9dd941c047cf9f8e54b8e8208c0ffeefad77" translate="yes" xml:space="preserve">
          <source>time zone specified by full name</source>
          <target state="translated">이름으로 지정된 시간대</target>
        </trans-unit>
        <trans-unit id="849d0277d4e83cea63b503c63ca3a5f178f90513" translate="yes" xml:space="preserve">
          <source>time-zone hours</source>
          <target state="translated">시간대 시간</target>
        </trans-unit>
        <trans-unit id="476c5260af0bb6664ae31f8adf0c99c7d8aa6ae3" translate="yes" xml:space="preserve">
          <source>time-zone minutes</source>
          <target state="translated">시간대 분</target>
        </trans-unit>
        <trans-unit id="625acb81057beef248f7134ca433ae4c0eac60d9" translate="yes" xml:space="preserve">
          <source>time-zone offset from UTC (only supported in &lt;code&gt;to_char&lt;/code&gt;)</source>
          <target state="translated">UTC에서 시간대 오프셋 ( &lt;code&gt;to_char&lt;/code&gt; 에서만 지원됨 )</target>
        </trans-unit>
        <trans-unit id="a5a01b8fa531faad566300a7eedefd11c4d01fde" translate="yes" xml:space="preserve">
          <source>timestamp</source>
          <target state="translated">timestamp</target>
        </trans-unit>
        <trans-unit id="0aa7ed235161236970521752f6ca1a03278bc01b" translate="yes" xml:space="preserve">
          <source>timestamp with time zone</source>
          <target state="translated">시간대가있는 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="1ce1805e4b5f351a0fb46c7e0a05beff1a2be153" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt; or &lt;code&gt;/etc/rc.local&lt;/code&gt; or look at the file &lt;code&gt;contrib/start-scripts/linux&lt;/code&gt; in the PostgreSQL source distribution.</source>
          <target state="translated">에 &lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt; 파일 또는 &lt;code&gt;/etc/rc.local&lt;/code&gt; 에 파일이나 모양 &lt;code&gt;contrib/start-scripts/linux&lt;/code&gt; PostgreSQL의 소스 배포한다.</target>
        </trans-unit>
        <trans-unit id="0fcbadcafadd255fb5e353fa4b0362465f703b4e" translate="yes" xml:space="preserve">
          <source>to examine the parameters and current state of a sequence. In particular, the &lt;code&gt;last_value&lt;/code&gt; field of the sequence shows the last value allocated by any session. (Of course, this value might be obsolete by the time it's printed, if other sessions are actively doing &lt;code&gt;nextval&lt;/code&gt; calls.)</source>
          <target state="translated">시퀀스의 파라미터 및 현재 상태를 검사합니다. 특히 시퀀스 의 &lt;code&gt;last_value&lt;/code&gt; 필드는 모든 세션에 의해 할당 된 마지막 값을 보여줍니다. (물론,이 값은 다른 세션을 적극적으로하고있는 경우가 인쇄되어 시간이 무용지물이 될 수 &lt;code&gt;nextval&lt;/code&gt; 전화를.)</target>
        </trans-unit>
        <trans-unit id="14b5a6198c6c0d08f07e8c09b6ad956c7163ac63" translate="yes" xml:space="preserve">
          <source>to rename the directory.</source>
          <target state="translated">디렉토리 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e73046f279ae0b6763a76622a0704ea4fdbac3ea" translate="yes" xml:space="preserve">
          <source>to the syslog daemon's configuration file to make it work.</source>
          <target state="translated">syslog 데몬의 구성 파일에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="7538bfc3fa9519e0550e749442775baecca74119" translate="yes" xml:space="preserve">
          <source>to transfer your data.</source>
          <target state="translated">데이터를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="8abc79f7e7ece86c6a1a14ee58503cf82eeb5966" translate="yes" xml:space="preserve">
          <source>traditional style</source>
          <target state="translated">전통적인 스타일</target>
        </trans-unit>
        <trans-unit id="25be3224e355ab745c855819c72ea60b3f346faa" translate="yes" xml:space="preserve">
          <source>transforms (data type to procedural language conversions)</source>
          <target state="translated">변환 (데이터 유형을 절차 언어 변환으로)</target>
        </trans-unit>
        <trans-unit id="d474687adece4246be7a0f43e5cdf88a135d3672" translate="yes" xml:space="preserve">
          <source>translation mode (print localized day and month names based on &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt;)</source>
          <target state="translated">번역 모드 ( &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time에&lt;/a&gt; 따라 현지화 된 요일 및 월 이름 인쇄 )</target>
        </trans-unit>
        <trans-unit id="608430456776b767a45cfe44d2daf36d0aea1581" translate="yes" xml:space="preserve">
          <source>trigger function for automatic &lt;code&gt;tsvector&lt;/code&gt; column update</source>
          <target state="translated">자동 &lt;code&gt;tsvector&lt;/code&gt; 열 업데이트를 위한 트리거 기능</target>
        </trans-unit>
        <trans-unit id="0d850d1fb8c4564a96bca7874d3015c0176cbdd0" translate="yes" xml:space="preserve">
          <source>triggers</source>
          <target state="translated">triggers</target>
        </trans-unit>
        <trans-unit id="9546575366698be9dc3339385ecc226802ffce6e" translate="yes" xml:space="preserve">
          <source>true if all input values are true, otherwise false</source>
          <target state="translated">모든 입력 값이 true이면 true이고, 그렇지 않으면 false</target>
        </trans-unit>
        <trans-unit id="f0ed3d53c4e2a2ba679a3d31f68b49bcc000d1f2" translate="yes" xml:space="preserve">
          <source>true if at least one input value is true, otherwise false</source>
          <target state="translated">하나 이상의 입력 값이 true이면 true이고, 그렇지 않으면 false</target>
        </trans-unit>
        <trans-unit id="676f3dd71ebf9aaf4b17b5a32c43ba35b85b2858" translate="yes" xml:space="preserve">
          <source>truncate to &lt;em&gt;&lt;code&gt;s&lt;/code&gt;&lt;/em&gt; decimal places</source>
          <target state="translated">잘라 내기까지 &lt;em&gt; &lt;code&gt;s&lt;/code&gt; &lt;/em&gt; 소수점 이하 자릿수</target>
        </trans-unit>
        <trans-unit id="9f277633b773b878ad72f1b39c1e59ee5f87fe70" translate="yes" xml:space="preserve">
          <source>truncate toward zero</source>
          <target state="translated">0쪽으로 자르다</target>
        </trans-unit>
        <trans-unit id="fc8761dd806bfc6e9c7818b4d00e5c9c77f32b19" translate="yes" xml:space="preserve">
          <source>trusted certificate authorities</source>
          <target state="translated">신뢰할 수있는 인증 기관</target>
        </trans-unit>
        <trans-unit id="a7fc787c0791506254f82d1f6cdec70e8766fe7a" translate="yes" xml:space="preserve">
          <source>tsm_system_rows</source>
          <target state="translated">tsm_system_rows</target>
        </trans-unit>
        <trans-unit id="c921d28508e9dd5ecf35e231b94a62cbd32ce141" translate="yes" xml:space="preserve">
          <source>tsm_system_time</source>
          <target state="translated">tsm_system_time</target>
        </trans-unit>
        <trans-unit id="f973befd080b2f010e4ad1b799afb0b8c2fb8567" translate="yes" xml:space="preserve">
          <source>tsquery</source>
          <target state="translated">tsquery</target>
        </trans-unit>
        <trans-unit id="583abee19c6b93555cf1156e26e4af8002a6a95c" translate="yes" xml:space="preserve">
          <source>tsvector</source>
          <target state="translated">tsvector</target>
        </trans-unit>
        <trans-unit id="e8dd9c53392235b67f66d1f5dbcc7f67180bd94c" translate="yes" xml:space="preserve">
          <source>txid_snapshot</source>
          <target state="translated">txid_snapshot</target>
        </trans-unit>
        <trans-unit id="12fcab458227ac117050daf9e3d6590c92085efd" translate="yes" xml:space="preserve">
          <source>typical choice for integer</source>
          <target state="translated">정수에 대한 일반적인 선택</target>
        </trans-unit>
        <trans-unit id="6ffb20caf93251ba7e5c57f747ba85d7f5bc1c05" translate="yes" xml:space="preserve">
          <source>uint16</source>
          <target state="translated">uint16</target>
        </trans-unit>
        <trans-unit id="e0c0463b32fc07d8d003fd3d7c2aafeee72b97c5" translate="yes" xml:space="preserve">
          <source>uint8</source>
          <target state="translated">uint8</target>
        </trans-unit>
        <trans-unit id="47d947d7a7bc349d6556615c0b97b33f01b72bb8" translate="yes" xml:space="preserve">
          <source>unaccent</source>
          <target state="translated">unaccent</target>
        </trans-unit>
        <trans-unit id="4733d5969a0631154730f80662597dcf64f61a4f" translate="yes" xml:space="preserve">
          <source>unambiguous in any &lt;code&gt;datestyle&lt;/code&gt; input mode</source>
          <target state="translated">모든 &lt;code&gt;datestyle&lt;/code&gt; 입력 모드 에서 분명</target>
        </trans-unit>
        <trans-unit id="8f35d00dc17da97aae84ee915e465c1cc5e7e477" translate="yes" xml:space="preserve">
          <source>unary plus, unary minus</source>
          <target state="translated">단항 더하기, 단항 빼기</target>
        </trans-unit>
        <trans-unit id="deaaf5ecd475cc19cfe8dc6939345ab56aa84c13" translate="yes" xml:space="preserve">
          <source>uniformly-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 균일 분포 랜덤 정수</target>
        </trans-unit>
        <trans-unit id="67ad5a07a2b999e38f2228365318c33459ab727a" translate="yes" xml:space="preserve">
          <source>union</source>
          <target state="translated">union</target>
        </trans-unit>
        <trans-unit id="5db7298da48ddfb62e71af9cb857bcb096433248" translate="yes" xml:space="preserve">
          <source>union of arguments</source>
          <target state="translated">논쟁의 연합</target>
        </trans-unit>
        <trans-unit id="d9c7a5b4c45a634dab61330755c4014c3fd7e21c" translate="yes" xml:space="preserve">
          <source>union of arrays</source>
          <target state="translated">배열의 합집합</target>
        </trans-unit>
        <trans-unit id="23b91e19c57aced544a7f5e44fe3c7966c16869d" translate="yes" xml:space="preserve">
          <source>unique number identifying the client session (starts from zero)</source>
          <target state="translated">클라이언트 세션을 식별하는 고유 번호 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="3f75603856194fe1878bcadff1a5fededf8734ef" translate="yes" xml:space="preserve">
          <source>universally unique identifier</source>
          <target state="translated">보편적으로 유일한 식별자</target>
        </trans-unit>
        <trans-unit id="e1a6f0b6f73a57a8b3ee30419e28f6cb95143908" translate="yes" xml:space="preserve">
          <source>unlimited</source>
          <target state="translated">unlimited</target>
        </trans-unit>
        <trans-unit id="06647ef63369928e96eb9c3870dbd7bd9e93df8a" translate="yes" xml:space="preserve">
          <source>unspecified (see text)</source>
          <target state="translated">불특정 (텍스트 참조)</target>
        </trans-unit>
        <trans-unit id="c6a8e0866f7f03293a30849bc162a8c2f4818fc5" translate="yes" xml:space="preserve">
          <source>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</source>
          <target state="translated">소수점 앞 최대 131072 자리; 소수점 이후 최대 16383 자리</target>
        </trans-unit>
        <trans-unit id="b42a5d7fe096994a11b818473f2669928a5dba69" translate="yes" xml:space="preserve">
          <source>upper bound of range</source>
          <target state="translated">범위의 상한</target>
        </trans-unit>
        <trans-unit id="30cfd923f02de39cecf439b115b7cf828835d142" translate="yes" xml:space="preserve">
          <source>upper case ordinal number suffix</source>
          <target state="translated">대문자 서수 접미사</target>
        </trans-unit>
        <trans-unit id="ae12ab34a766a4939271ced9061de451e3fa0944" translate="yes" xml:space="preserve">
          <source>upper case time-zone abbreviation (only supported in &lt;code&gt;to_char&lt;/code&gt;)</source>
          <target state="translated">대문자 시간대 약어 ( &lt;code&gt;to_char&lt;/code&gt; 에서만 지원됨 )</target>
        </trans-unit>
        <trans-unit id="5d449e34fd3b092418b5a2a566608d763a55317b" translate="yes" xml:space="preserve">
          <source>use hard links instead of copying files to the new cluster</source>
          <target state="translated">새 클러스터에 파일을 복사하는 대신 하드 링크를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4973dcc07764d6816796626f62ae369e27f7526" translate="yes" xml:space="preserve">
          <source>user mappings</source>
          <target state="translated">사용자 매핑</target>
        </trans-unit>
        <trans-unit id="ca7b0e484889d9f7667e415fdb65ec333f91c3af" translate="yes" xml:space="preserve">
          <source>user name of current execution context</source>
          <target state="translated">현재 실행 컨텍스트의 사용자 이름</target>
        </trans-unit>
        <trans-unit id="3ecdf2ca9fee52b2cac0d8dd1d9845660e313a12" translate="yes" xml:space="preserve">
          <source>user-level transaction ID snapshot</source>
          <target state="translated">사용자 수준 트랜잭션 ID 스냅 샷</target>
        </trans-unit>
        <trans-unit id="2bcd853384b0d1306c229db53057e92c809d9e95" translate="yes" xml:space="preserve">
          <source>user-specified precision, exact</source>
          <target state="translated">정확한 사용자 지정 정밀도</target>
        </trans-unit>
        <trans-unit id="8782baefd5b9fb265c66ecc34780fd0b8a1dbc87" translate="yes" xml:space="preserve">
          <source>using the &lt;em&gt;new&lt;/em&gt; psql.</source>
          <target state="translated">&lt;em&gt;새로운&lt;/em&gt; psql을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a046c43e9c192caf6bd401480cc0f5fad7ceec8a" translate="yes" xml:space="preserve">
          <source>uuid-ossp</source>
          <target state="translated">uuid-ossp</target>
        </trans-unit>
        <trans-unit id="8f0faf3a7751e4af5b9c227d30bfcbaa444edd84" translate="yes" xml:space="preserve">
          <source>vacuumdb</source>
          <target state="translated">vacuumdb</target>
        </trans-unit>
        <trans-unit id="145988faa1e40e7ddecb2ea65b7c51807c3271cb" translate="yes" xml:space="preserve">
          <source>vacuumdb &amp;mdash; garbage-collect and analyze a PostgreSQL database</source>
          <target state="translated">vacuumdb &amp;mdash; PostgreSQL 데이터베이스를 가비지 수집 및 분석</target>
        </trans-unit>
        <trans-unit id="e5c778a21d37b9be0e61c44b2474a01bfe05b692" translate="yes" xml:space="preserve">
          <source>vacuumdb accepts the following command-line arguments:</source>
          <target state="translated">vacuumdb는 다음과 같은 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="93abf036b734fe132167e900b4c0fba2398d2224" translate="yes" xml:space="preserve">
          <source>vacuumdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">vacuumdb는 또한 연결 매개 변수에 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1528a6903cc3a4ec373552daced8a437d4c5cafd" translate="yes" xml:space="preserve">
          <source>vacuumdb is a utility for cleaning a PostgreSQL database. vacuumdb will also generate internal statistics used by the PostgreSQL query optimizer.</source>
          <target state="translated">vacuumdb는 PostgreSQL 데이터베이스를 정리하는 유틸리티입니다. vacuumdb는 PostgreSQL 쿼리 옵티마이 저가 사용하는 내부 통계도 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c3547b30c049ff8ffce05ab606ec48070300fed" translate="yes" xml:space="preserve">
          <source>vacuumdb is a wrapper around the SQL command &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;. There is no effective difference between vacuuming and analyzing databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">vacuumdb는 SQL 명령 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 주위의 래퍼 입니다. 이 유틸리티와 서버에 액세스하는 다른 방법을 통해 데이터베이스를 정리하고 분석하는 것에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c5fb8d56ab327b2f14d361fe631ab7a16e896a2" translate="yes" xml:space="preserve">
          <source>vacuumdb might need to connect several times to the PostgreSQL server, asking for a password each time. It is convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file in such cases. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">vacuumdb는 PostgreSQL 서버에 여러 번 연결해야 할 때마다 암호를 요구합니다. 이런 경우 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용 하는 것이 편리합니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;33.15 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f46818d78f22eaf25aea8864f72802c46059e9c3" translate="yes" xml:space="preserve">
          <source>vacuumdb will open &lt;code&gt;njobs&lt;/code&gt; connections to the database, so make sure your &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; setting is high enough to accommodate all connections.</source>
          <target state="translated">vacuumdb는 데이터베이스에 대한 &lt;code&gt;njobs&lt;/code&gt; 연결을 열 므로 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 설정이 모든 연결을 수용 할 수있을만큼 충분히 높아야합니다.</target>
        </trans-unit>
        <trans-unit id="df99bb033a353b66cc7ec2ee85cd87fb87542059" translate="yes" xml:space="preserve">
          <source>value of the constant PI</source>
          <target state="translated">상수 PI의 값</target>
        </trans-unit>
        <trans-unit id="8279b9e0fcc10e814e566b08c3a4a690bc1ceca1" translate="yes" xml:space="preserve">
          <source>value tests</source>
          <target state="translated">가치 테스트</target>
        </trans-unit>
        <trans-unit id="551c3faca5896d7034c0ce682bd144af83b995d8" translate="yes" xml:space="preserve">
          <source>values stored in the MCV item</source>
          <target state="translated">MCV 항목에 저장된 값</target>
        </trans-unit>
        <trans-unit id="b46d0172433dd6895dac7544b9dacbb87b361e9f" translate="yes" xml:space="preserve">
          <source>variable</source>
          <target state="translated">variable</target>
        </trans-unit>
        <trans-unit id="7298df2d9cff6d1a98ebb8f3292bdd052dda2f66" translate="yes" xml:space="preserve">
          <source>variable unlimited length</source>
          <target state="translated">가변 무제한 길이</target>
        </trans-unit>
        <trans-unit id="c33a839f17cccf416f33c1ff72d670667eaa6316" translate="yes" xml:space="preserve">
          <source>variable-length binary string</source>
          <target state="translated">가변 길이 이진 문자열</target>
        </trans-unit>
        <trans-unit id="82e998f6547837b4bb250aed85de1f06e90b526b" translate="yes" xml:space="preserve">
          <source>variable-length bit string</source>
          <target state="translated">가변 길이 비트 문자열</target>
        </trans-unit>
        <trans-unit id="b8c9e9056b1fc953c6624f2a90d33200eccefab2" translate="yes" xml:space="preserve">
          <source>variable-length character string</source>
          <target state="translated">가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="0383de504e58025d45eb9992e372542a0abf7899" translate="yes" xml:space="preserve">
          <source>variable-length with limit</source>
          <target state="translated">제한이있는 가변 길이</target>
        </trans-unit>
        <trans-unit id="b50074f44d7610d791284812510de93631d572ef" translate="yes" xml:space="preserve">
          <source>variable-precision, inexact</source>
          <target state="translated">정확하지 않은 가변 정밀도</target>
        </trans-unit>
        <trans-unit id="793813d775cb84067082961ebfb6d08120f27fae" translate="yes" xml:space="preserve">
          <source>various flag bits</source>
          <target state="translated">다양한 플래그 비트</target>
        </trans-unit>
        <trans-unit id="1e9847031591279c4882662842e6bb8b45759840" translate="yes" xml:space="preserve">
          <source>vertical size of box</source>
          <target state="translated">상자의 세로 크기</target>
        </trans-unit>
        <trans-unit id="935fc2d7ce72de659cb2219b67b2ae35cb7c8cc3" translate="yes" xml:space="preserve">
          <source>vertical tab, as in C</source>
          <target state="translated">C에서와 같이 수직 탭</target>
        </trans-unit>
        <trans-unit id="b1bad95fa507072f46712bded24f41b01216bc69" translate="yes" xml:space="preserve">
          <source>via the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement in SQL</source>
          <target state="translated">SQL 의 &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; 문을 통해</target>
        </trans-unit>
        <trans-unit id="7578d82766f9bd29c639036328b849ce29a39304" translate="yes" xml:space="preserve">
          <source>via the Bind message in the frontend/backend protocol, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;Section 52.2.3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;52.2.3 절에&lt;/a&gt; 설명 된 것처럼 프론트 엔드 / 백엔드 프로토콜의 바인드 메시지를 통해</target>
        </trans-unit>
        <trans-unit id="a28d981942e491b947c92a0e2f3f7947ce1c9893" translate="yes" xml:space="preserve">
          <source>via the Server Programming Interface (SPI), as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/spi-interface.html&quot;&gt;Section 46.1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/spi-interface.html&quot;&gt;46.1 장에&lt;/a&gt; 설명 된 SPI (Server Programming Interface)를 통해</target>
        </trans-unit>
        <trans-unit id="81f33187147211336a4984d8ab8fccdfeb11a42c" translate="yes" xml:space="preserve">
          <source>views</source>
          <target state="translated">views</target>
        </trans-unit>
        <trans-unit id="6e7a9821d49ea8d70b1ce202fbb6c4bbe7a8864d" translate="yes" xml:space="preserve">
          <source>week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)</source>
          <target state="translated">ISO 8601 주 번호 매기기 주 번호 (01-53, 첫 번째 목요일은 주 1)</target>
        </trans-unit>
        <trans-unit id="dcf0a4257eaf2654515093d684fc76c3f351114a" translate="yes" xml:space="preserve">
          <source>week number of year (1-53) (the first week starts on the first day of the year)</source>
          <target state="translated">연도의 주 번호 (1-53) (첫 번째주는 첫 번째 요일에 시작)</target>
        </trans-unit>
        <trans-unit id="e36af5a529b747070a5db3558591e88d36bb68b6" translate="yes" xml:space="preserve">
          <source>week of month (1-5) (the first week starts on the first day of the month)</source>
          <target state="translated">매주 주 (1-5) (첫주는 매월 첫째 날에 시작)</target>
        </trans-unit>
        <trans-unit id="428b9e698aec6af472173b26531814f7afdee96a" translate="yes" xml:space="preserve">
          <source>when followed by a character other than a digit, matches the left-brace character &lt;code&gt;{&lt;/code&gt;; when followed by a digit, it is the beginning of a &lt;code&gt;bound&lt;/code&gt; (see below)</source>
          <target state="translated">뒤에 숫자 이외의 문자가 오는 경우 왼쪽 괄호 문자 &lt;code&gt;{&lt;/code&gt; ; 뒤에 숫자가 오면 &lt;code&gt;bound&lt;/code&gt; 의 시작입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="364c8705353be0aad06a99befe16e732767f00ac" translate="yes" xml:space="preserve">
          <source>when written as a column constraint, and:</source>
          <target state="translated">열 제약 조건으로 작성 될 때</target>
        </trans-unit>
        <trans-unit id="6e1ec19a99583071720740b9242482fdde3817c6" translate="yes" xml:space="preserve">
          <source>when written as a table constraint.</source>
          <target state="translated">테이블 제약 조건으로 쓸 때.</target>
        </trans-unit>
        <trans-unit id="5f8a66e7adff2f3b4d4dcb113d02b2e17f726203" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;(x,y)&lt;/code&gt; is the center point and &lt;code&gt;r&lt;/code&gt; is the radius of the circle.</source>
          <target state="translated">여기서 &lt;code&gt;(x,y)&lt;/code&gt; 는 중심점이고 &lt;code&gt;r&lt;/code&gt; 은 원의 반지름입니다.</target>
        </trans-unit>
        <trans-unit id="bd37643d0dd6010b481c08b474014ac24270a823" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;(x1,y1)&lt;/code&gt; and &lt;code&gt;(x2,y2)&lt;/code&gt; are any two opposite corners of the box.</source>
          <target state="translated">여기서 &lt;code&gt;(x1,y1)&lt;/code&gt; 및 &lt;code&gt;(x2,y2)&lt;/code&gt; 는 상자의 두 반대쪽 모서리입니다.</target>
        </trans-unit>
        <trans-unit id="18182ac0abf5fa69da0135991df6a4b42daf0796" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;(x1,y1)&lt;/code&gt; and &lt;code&gt;(x2,y2)&lt;/code&gt; are the end points of the line segment.</source>
          <target state="translated">여기서 &lt;code&gt;(x1,y1)&lt;/code&gt; 및 &lt;code&gt;(x2,y2)&lt;/code&gt; 는 선분의 ​​끝점입니다.</target>
        </trans-unit>
        <trans-unit id="cd0a33de1e918a3a5dbe460c4835d4bab41aef8b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;(x1,y1)&lt;/code&gt; and &lt;code&gt;(x2,y2)&lt;/code&gt; are two different points on the line.</source>
          <target state="translated">여기서 &lt;code&gt;(x1,y1)&lt;/code&gt; 및 &lt;code&gt;(x2,y2)&lt;/code&gt; 는 선에서 서로 다른 두 점입니다.</target>
        </trans-unit>
        <trans-unit id="62cc883c4cff0d727c6bccd03373401e789a3bdc" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;aggregate_name&lt;/code&gt; is a previously defined aggregate (possibly qualified with a schema name) and &lt;code&gt;expression&lt;/code&gt; is any value expression that does not itself contain an aggregate expression or a window function call. The optional &lt;code&gt;order_by_clause&lt;/code&gt; and &lt;code&gt;filter_clause&lt;/code&gt; are described below.</source>
          <target state="translated">여기서 &lt;code&gt;aggregate_name&lt;/code&gt; 은 이전에 정의 된 집계 (스키마 이름으로 정규화 될 수 있음)이며 &lt;code&gt;expression&lt;/code&gt; 은 자체적으로 집계 식 또는 윈도우 함수 호출을 포함하지 않는 값 식입니다. 선택적 &lt;code&gt;order_by_clause&lt;/code&gt; 및 &lt;code&gt;filter_clause&lt;/code&gt; 가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb27ce432756b53a4aded2a65828cbdaa1282ba5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;algorithm&lt;/code&gt; is one of:</source>
          <target state="translated">여기서 &lt;code&gt;algorithm&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="a7cd4f12063c1975f0d255a05965b38eb93bc6c2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;archivelocation&lt;/code&gt; is the directory from which WAL segment files should be removed.</source>
          <target state="translated">여기서 &lt;code&gt;archivelocation&lt;/code&gt; 은 WAL 세그먼트 파일을 제거 할 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="39d50e4fc00ccd5c8ec9a75dd873782f3183c2ce" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;c&lt;/code&gt; is alphanumeric (possibly followed by other characters) is an &lt;em&gt;escape&lt;/em&gt;, see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt; (AREs only; in EREs and BREs, this matches &lt;code&gt;c&lt;/code&gt;)</source>
          <target state="translated">여기서 &lt;code&gt;c&lt;/code&gt; 는 영숫자 (다른 문자가 뒤따를 수 있음)는 &lt;em&gt;이스케이프입니다&lt;/em&gt; . 9.7.3.3 &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;절&lt;/a&gt; 참조 (ARE 만 해당, ERE 및 BRE의 경우 &lt;code&gt;c&lt;/code&gt; 와 일치 )</target>
        </trans-unit>
        <trans-unit id="95363da9cd107f5dcc6d6108200a75dee0fecc9d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;client_id&lt;/code&gt; indicates which client session ran the transaction, &lt;code&gt;transaction_no&lt;/code&gt; counts how many transactions have been run by that session, &lt;code&gt;time&lt;/code&gt; is the total elapsed transaction time in microseconds, &lt;code&gt;script_no&lt;/code&gt; identifies which script file was used (useful when multiple scripts were specified with &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;-b&lt;/code&gt;), and &lt;code&gt;time_epoch&lt;/code&gt;/&lt;code&gt;time_us&lt;/code&gt; are a Unix-epoch time stamp and an offset in microseconds (suitable for creating an ISO 8601 time stamp with fractional seconds) showing when the transaction completed. The &lt;code&gt;schedule_lag&lt;/code&gt; field is the difference between the transaction's scheduled start time, and the time it actually started, in microseconds. It is only present when the &lt;code&gt;--rate&lt;/code&gt; option is used. When both &lt;code&gt;--rate&lt;/code&gt; and &lt;code&gt;--latency-limit&lt;/code&gt; are used, the &lt;code&gt;time&lt;/code&gt; for a skipped transaction will be reported as &lt;code&gt;skipped&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;client_id&lt;/code&gt; 는 트랜잭션을 실행 한 클라이언트 세션을 나타내고 transaction_no는 해당 세션에서 실행 된 &lt;code&gt;transaction_no&lt;/code&gt; 수를 계산하고, &lt;code&gt;time&lt;/code&gt; 은 총 경과 된 트랜잭션 시간 (마이크로 초)이며 &lt;code&gt;script_no&lt;/code&gt; 는 사용 된 스크립트 파일을 식별합니다 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;-b&lt;/code&gt; ) 및 &lt;code&gt;time_epoch&lt;/code&gt; / &lt;code&gt;time_us&lt;/code&gt; 는 Unix-epoch 타임 스탬프이며 트랜잭션이 완료된 시점을 나타내는 마이크로 초 단위 오프셋 (분수 초로 ISO 8601 타임 스탬프를 만드는 데 적합)입니다. &lt;code&gt;schedule_lag&lt;/code&gt; 필드는 트랜잭션의 예약 된 시작 시간과 실제로 시작된 시간의 차이 (마이크로 초)입니다. &lt;code&gt;--rate&lt;/code&gt; 옵션을 사용 하는 경우에만 존재합니다 . 두 경우 &lt;code&gt;--rate&lt;/code&gt; 및 &lt;code&gt;--latency-limit&lt;/code&gt; 사용의 &lt;code&gt;time&lt;/code&gt; 스킵 거래는 다음과 같이보고됩니다 &lt;code&gt;skipped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15575bf8bc20a17322a91c6a004375b23fe3bede" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;collation&lt;/code&gt; is a possibly schema-qualified identifier. The &lt;code&gt;COLLATE&lt;/code&gt; clause binds tighter than operators; parentheses can be used when necessary.</source>
          <target state="translated">여기서 &lt;code&gt;collation&lt;/code&gt; 은 스키마로 한정된 식별자 일 수 있습니다. &lt;code&gt;COLLATE&lt;/code&gt; 절은 사업자보다 더 엄격한 결합; 필요한 경우 괄호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd38ffefd9af14e03f114a3c898a1682942460e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 결과로 평가되는 표현식입니다 . 이 조건을 만족하지 않는 행은 출력에서 ​​제거됩니다. 실제 행 값이 변수 참조로 대체 될 때 true를 리턴하면 행이 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="883e212f0298979617ff0fdf44518bd05a084205" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 결과로 평가되는 표현식입니다 . 이 조건을 만족하지 않는 행은 테이블에 삽입되지 않습니다. 실제 행 값이 변수 참조로 대체 될 때 true를 리턴하면 행이 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="50d757545c644d09173ed3fc8ac85d6de14f6f0b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is the same as specified for the &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;WHERE&lt;/code&gt; 절에 지정된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0e39ffa4c4736dc3798858fa334aa10d101b9ea1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;config_name&lt;/code&gt; is a column in the &lt;code&gt;pgweb&lt;/code&gt; table. This allows mixed configurations in the same index while recording which configuration was used for each index entry. This would be useful, for example, if the document collection contained documents in different languages. Again, queries that are meant to use the index must be phrased to match, e.g., &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;config_name&lt;/code&gt; 은 &lt;code&gt;pgweb&lt;/code&gt; 테이블 의 열입니다 . 따라서 각 인덱스 항목에 사용 된 구성을 기록하면서 동일한 인덱스에서 혼합 된 구성을 사용할 수 있습니다. 예를 들어 문서 모음에 다른 언어로 된 문서가 포함 된 경우에 유용합니다. 다시, 인덱스를 사용하기위한 쿼리는 일치해야합니다 &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt; 예 : WHERE to_tsvector (config_name, body) @@ 'a &amp;amp; b') .</target>
        </trans-unit>
        <trans-unit id="0e33c809b5aed59b29d15e3755cf042bcd7cf972" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dbname&lt;/code&gt; is the name of the already-created database to test in. (You may also need &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and/or &lt;code&gt;-U&lt;/code&gt; options to specify how to connect to the database server.)</source>
          <target state="translated">여기서 &lt;code&gt;dbname&lt;/code&gt; 은 테스트하기 위해 이미 작성된 데이터베이스의 이름입니다. 데이터베이스 서버에 연결하는 방법을 지정 하려면 &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 / 또는 &lt;code&gt;-U&lt;/code&gt; 옵션이 필요할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2efafe66fc0fb01790e7b075da02f4b34a5191f4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;delim&lt;/code&gt; is the delimiter character for the type, as recorded in its &lt;code&gt;pg_type&lt;/code&gt; entry. Among the standard data types provided in the PostgreSQL distribution, all use a comma (&lt;code&gt;,&lt;/code&gt;), except for type &lt;code&gt;box&lt;/code&gt; which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). Each &lt;code&gt;val&lt;/code&gt; is either a constant of the array element type, or a subarray. An example of an array constant is:</source>
          <target state="translated">여기서 &lt;code&gt;delim&lt;/code&gt; 은 &lt;code&gt;pg_type&lt;/code&gt; 항목에 기록 된 유형의 구분 문자입니다 . PostgreSQL 배포에서 제공되는 표준 데이터 유형 중에서 세미콜론 ( &lt;code&gt;;&lt;/code&gt; ) 을 사용하는 유형 &lt;code&gt;box&lt;/code&gt; 를 제외하고 모두 쉼표 ( &lt;code&gt;,&lt;/code&gt; ) 를 사용합니다 . 각 &lt;code&gt;val&lt;/code&gt; 은 배열 요소 유형의 상수이거나 하위 배열입니다. 배열 상수의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc0c370cc6c4db09350c38f91dbc0ead530523ea" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;digits&lt;/code&gt; is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (&lt;code&gt;e&lt;/code&gt;), if one is present. There cannot be any spaces or other characters embedded in the constant. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant.</source>
          <target state="translated">여기서 &lt;code&gt;digits&lt;/code&gt; 은 하나 이상의 10 진수 (0-9)입니다. 소수점을 사용하는 경우 하나 이상의 숫자가 소수점 앞뒤에 있어야합니다. 지수 마커 ( &lt;code&gt;e&lt;/code&gt; )가있는 경우 하나 이상의 숫자가 지수 마커 ( e )를 따라야합니다 . 상수에는 공백이나 다른 문자가 포함될 수 없습니다. 선행 더하기 또는 빼기 기호는 실제로 상수의 일부로 간주되지 않습니다. 상수에 적용되는 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7fccfedd66d19eee35d6037183fff7ab24667" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;documents&lt;/code&gt; is a table that has a text field &lt;code&gt;bodytext&lt;/code&gt; that we wish to search. The reason for using the &lt;code&gt;simple&lt;/code&gt; configuration with the &lt;code&gt;to_tsvector&lt;/code&gt; function, instead of using a language-specific configuration, is that we want a list of the original (unstemmed) words.</source>
          <target state="translated">여기서 &lt;code&gt;documents&lt;/code&gt; 텍스트 필드가있는 테이블입니다 &lt;code&gt;bodytext&lt;/code&gt; 우리가 검색하고자하는 것으로합니다. 언어 별 구성을 사용하는 대신 &lt;code&gt;to_tsvector&lt;/code&gt; 함수 와 함께 &lt;code&gt;simple&lt;/code&gt; 구성 을 사용하는 이유 는 원래 (비 스테 롬) 단어 목록을 원하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9a039bb227f52a1b9a93d81d62221c9b30047689" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dumpfile&lt;/code&gt; is the file output by the pg_dump command. The database &lt;code&gt;dbname&lt;/code&gt; will not be created by this command, so you must create it yourself from &lt;code&gt;template0&lt;/code&gt; before executing psql (e.g., with &lt;code&gt;createdb -T template0 dbname&lt;/code&gt;). psql supports options similar to pg_dump for specifying the database server to connect to and the user name to use. See the &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; reference page for more information. Non-text file dumps are restored using the &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; utility.</source>
          <target state="translated">여기서 &lt;code&gt;dumpfile&lt;/code&gt; 은 pg_dump 명령으로 출력 된 파일입니다. 데이터베이스 &lt;code&gt;dbname&lt;/code&gt; 은이 명령으로 작성되지 않으므로 psql을 실행하기 전에 &lt;code&gt;template0&lt;/code&gt; 에서 직접 작성해야합니다 (예 : &lt;code&gt;createdb -T template0 dbname&lt;/code&gt; 사용 ). psql은 연결할 데이터베이스 서버 및 사용할 사용자 이름을 지정하기 위해 pg_dump와 유사한 옵션을 지원합니다. 자세한 내용은 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 참조 페이지를 참조하십시오. 비 텍스트 파일 덤프는 &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; 유틸리티를 사용하여 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e33127f2af6130f52a3e81c11a87546a1d4d1276" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; can be one of</source>
          <target state="translated">여기서 &lt;code&gt;frame_start&lt;/code&gt; 및 &lt;code&gt;frame_end&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4a0bb9f112237b3006e826384b66b73f19342f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e. the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">여기서 &lt;code&gt;interval_start&lt;/code&gt; 는 간격 의 시작 (UNIX epoch 시간 소인), &lt;code&gt;num_transactions&lt;/code&gt; 는 간격 내의 트랜잭션 수, &lt;code&gt;sum_latency&lt;/code&gt; 는 간격 내의 트랜잭션 지연 시간 의 합 , &lt;code&gt;sum_latency_2&lt;/code&gt; 는 트랜잭션 지연 시간의 제곱의 합입니다. 간격, &lt;code&gt;min_latency&lt;/code&gt; 는 간격 내 최소 대기 시간이고 &lt;code&gt;max_latency&lt;/code&gt; 는 간격 내 최대 대기 시간입니다. 다음 필드 인 &lt;code&gt;sum_lag&lt;/code&gt; , &lt;code&gt;sum_lag_2&lt;/code&gt; , &lt;code&gt;min_lag&lt;/code&gt; 및 &lt;code&gt;max_lag&lt;/code&gt; 는 &lt;code&gt;--rate&lt;/code&gt; 옵션이 사용됩니다. 각 트랜잭션이 이전 트랜잭션이 완료되기를 기다려야하는 시간, 즉 각 트랜잭션의 예약 된 시작 시간과 실제로 시작된 시간의 차이에 대한 통계를 제공합니다. 마지막 필드 인 &lt;code&gt;skipped&lt;/code&gt; 는 &lt;code&gt;--latency-limit&lt;/code&gt; 옵션을 사용 하는 경우에만 나타납니다 . 너무 늦게 시작되어 건너 뛴 트랜잭션 수를 계산합니다. 각 트랜잭션은 커밋 된 간격으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="02521c4b560914d5a494676dd3a10eaddf5a2d27" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. &lt;code&gt;pg_start_backup&lt;/code&gt; creates a &lt;em&gt;backup label&lt;/em&gt; file, called &lt;code&gt;backup_label&lt;/code&gt;, in the cluster directory with information about your backup, including the start time and label string. The function also creates a &lt;em&gt;tablespace map&lt;/em&gt; file, called &lt;code&gt;tablespace_map&lt;/code&gt;, in the cluster directory with information about tablespace symbolic links in &lt;code&gt;pg_tblspc/&lt;/code&gt; if one or more such link is present. Both files are critical to the integrity of the backup, should you need to restore from it.</source>
          <target state="translated">여기서 &lt;code&gt;label&lt;/code&gt; 은이 백업 작업을 고유하게 식별하는 데 사용하려는 문자열입니다. &lt;code&gt;pg_start_backup&lt;/code&gt; 는 생성 &lt;em&gt;백업 레이블&lt;/em&gt; 라는 파일 &lt;code&gt;backup_label&lt;/code&gt; 시작 시간과 레이블 문자열을 포함하여 백업에 대한 정보와 클러스터 디렉토리를. 이 함수는 또한 하나 이상의 이러한 링크가 존재하는 경우 &lt;code&gt;pg_tblspc/&lt;/code&gt; 테이블 스페이스 기호 링크에 대한 정보와 함께 클러스터 디렉토리에 &lt;code&gt;tablespace_map&lt;/code&gt; 이라는 테이블 &lt;em&gt;스페이스 맵&lt;/em&gt; 파일을 작성합니다 . 두 파일 모두 백업 무결성을 위해 중요합니다. 백업에서 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="2632c6a394b4c5afed578e3db6104be70d7c969c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. The connection calling &lt;code&gt;pg_start_backup&lt;/code&gt; must be maintained until the end of the backup, or the backup will be automatically aborted.</source>
          <target state="translated">여기서 &lt;code&gt;label&lt;/code&gt; 은이 백업 작업을 고유하게 식별하는 데 사용하려는 문자열입니다. &lt;code&gt;pg_start_backup&lt;/code&gt; 을 호출하는 연결 은 백업이 끝날 때까지 유지되어야합니다. 그렇지 않으면 백업이 자동으로 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="14ec95115d9949716f5574166b53e4a99c82ef40" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;lock_strength&lt;/code&gt; can be one of</source>
          <target state="translated">여기서 &lt;code&gt;lock_strength&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc24930f3c49a2f1c610c96b58a313a1bb2f6567" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;name&lt;/code&gt; follows the usual rules for SQL identifiers. The current role automatically becomes the owner of the new database. It is the privilege of the owner of a database to remove it later (which also removes all the objects in it, even if they have a different owner).</source>
          <target state="translated">여기서 &lt;code&gt;name&lt;/code&gt; 은 일반적인 SQL 식별자 규칙을 따릅니다. 현재 역할은 자동으로 새 데이터베이스의 소유자가됩니다. 나중에 데이터베이스를 제거하는 것은 데이터베이스 소유자의 특권입니다 (이는 소유자가 다른 경우에도 데이터베이스의 모든 오브젝트를 제거합니다).</target>
        </trans-unit>
        <trans-unit id="2e04d3386ac5dbafbf688329834c2f0edf9b1b29" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;num_sync&lt;/code&gt; is the number of synchronous standbys that transactions need to wait for replies from, and &lt;code&gt;standby_name&lt;/code&gt; is the name of a standby server. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;ANY&lt;/code&gt; specify the method to choose synchronous standbys from the listed servers.</source>
          <target state="translated">여기서 &lt;code&gt;num_sync&lt;/code&gt; 는 트랜잭션이 응답을 대기해야하는 동기 대기의 수이고 &lt;code&gt;standby_name&lt;/code&gt; 은 대기 서버의 이름입니다. &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;ANY&lt;/code&gt; 는 나열된 서버에서 동기 대기를 선택하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="051ce8638a4cb0df58ccc78d0226c857003f3754" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.</source>
          <target state="translated">어디 &lt;code&gt;old_cluster&lt;/code&gt; 및 &lt;code&gt;new_cluster&lt;/code&gt; 는 차의 현재 디렉토리를 기준으로하며, &lt;code&gt;remote_dir&lt;/code&gt; 것입니다 &lt;em&gt;위의&lt;/em&gt; 대기에 이전 및 새 클러스터 디렉토리. 기본 및 대기에서 지정된 디렉토리 아래의 디렉토리 구조가 일치해야합니다. 원격 디렉토리 지정에 대한 자세한 내용은 rsync 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6995f4e58e8fe029424bd429b077f2eb8c3fe1f6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is an optional precision specification giving the number of fractional digits in the seconds field. Precision can be specified for &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt; types, and can range from 0 to 6. If no precision is specified in a constant specification, it defaults to the precision of the literal value (but not more than 6 digits).</source>
          <target state="translated">여기서 &lt;code&gt;p&lt;/code&gt; 는 초 필드의 소수 자릿수를 제공하는 선택적 정밀도 사양입니다. 정밀도는 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; 및 &lt;code&gt;interval&lt;/code&gt; 유형에 대해 지정할 수 있으며 범위는 0-6입니다. 상수 스펙에 정밀도가 지정되지 않은 경우 리터럴 값의 정밀도 (기본값은 6 자리 이하)입니다.</target>
        </trans-unit>
        <trans-unit id="3ae43e1773ab7435ea942bef4aab35ea977ed17e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;quantity&lt;/code&gt; is a number (possibly signed); &lt;code&gt;unit&lt;/code&gt; is &lt;code&gt;microsecond&lt;/code&gt;, &lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;week&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, &lt;code&gt;millennium&lt;/code&gt;, or abbreviations or plurals of these units; &lt;code&gt;direction&lt;/code&gt; can be &lt;code&gt;ago&lt;/code&gt; or empty. The at sign (&lt;code&gt;@&lt;/code&gt;) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. &lt;code&gt;ago&lt;/code&gt; negates all the fields. This syntax is also used for interval output, if &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; is set to &lt;code&gt;postgres_verbose&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;quantity&lt;/code&gt; 은 숫자입니다 (아마 서명). &lt;code&gt;unit&lt;/code&gt; 는 &lt;code&gt;microsecond&lt;/code&gt; , &lt;code&gt;millisecond&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;week&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; , &lt;code&gt;millennium&lt;/code&gt; 또는 이들 단위의 약어 또는 복수이고; &lt;code&gt;direction&lt;/code&gt; 은 &lt;code&gt;ago&lt;/code&gt; 또는 비어 있을 수 있습니다 . at 기호 ( &lt;code&gt;@&lt;/code&gt; )는 선택적인 노이즈입니다. 서로 다른 단위의 금액은 적절한 부호 계산으로 암시 적으로 추가됩니다. &lt;code&gt;ago&lt;/code&gt; 모든 필드를 무효화합니다. &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; 이 &lt;code&gt;postgres_verbose&lt;/code&gt; 로 설정된 경우이 구문은 간격 출력에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb85a9d1ba20986c4eabc4c0cc672867a0082382" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;salt&lt;/code&gt;, &lt;code&gt;StoredKey&lt;/code&gt; and &lt;code&gt;ServerKey&lt;/code&gt; are in Base64 encoded format. This format is the same as that specified by RFC 5803.</source>
          <target state="translated">여기서 &lt;code&gt;salt&lt;/code&gt; , &lt;code&gt;StoredKey&lt;/code&gt; 및 &lt;code&gt;ServerKey&lt;/code&gt; 는 Base64로 인코딩 된 형식입니다. 이 형식은 RFC 5803에서 지정한 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="902cd914b55268a7f42373967de3300fb2a6df74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;search_condition&lt;/code&gt; is any value expression (see &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;) that returns a value of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;search_condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 값을 반환하는 값 식 ( &lt;a href=&quot;sql-expressions&quot;&gt;4.2&lt;/a&gt; 참조 )입니다 .</target>
        </trans-unit>
        <trans-unit id="9cab206ed9f849b266fa8bbb5c105eda41d171c2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_definition&lt;/code&gt; has the syntax</source>
          <target state="translated">여기서 &lt;code&gt;window_definition&lt;/code&gt; 에는 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ffcb73100c9208f3d73e7359a7710f21793aea4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_name&lt;/code&gt; is a name that can be referenced from &lt;code&gt;OVER&lt;/code&gt; clauses or subsequent window definitions, and &lt;code&gt;window_definition&lt;/code&gt; is</source>
          <target state="translated">여기서 &lt;code&gt;window_name&lt;/code&gt; 은 &lt;code&gt;OVER&lt;/code&gt; 절 또는 후속 창 정의 에서 참조 할 수있는 이름 이며 &lt;code&gt;window_definition&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="05865f2594ddc7befb862529cd119701ff24e8ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the respective coordinates, as floating-point numbers.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 부동 소수점 숫자로 각 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="63a67aa07860e75ed55512e599efa11799c590cd" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; is a single character with no other significance, matches that character</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 다른 의미가없는 단일 문자이며 해당 문자와 ​​일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cfc72d3af1bb50704e8aee07809af6321faa971" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;xsi&lt;/code&gt; is the XML namespace prefix for XML Schema Instance. An appropriate namespace declaration will be added to the result value. If false, columns containing null values are simply omitted from the output.</source>
          <target state="translated">여기서 &lt;code&gt;xsi&lt;/code&gt; 는 XML 스키마 인스턴스의 XML 네임 스페이스 접두사입니다. 적절한 네임 스페이스 선언이 결과 값에 추가됩니다. false이면 널값을 포함하는 열이 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd4a92c9b71cd49ffa17bbdcc8f19ea4f09000a" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">여기서 &lt;code&gt;nextval()&lt;/code&gt; 함수는 &lt;em&gt;시퀀스 객체&lt;/em&gt; 에서 연속적인 값을 제공 &lt;em&gt;합니다&lt;/em&gt; ( &lt;a href=&quot;functions-sequence&quot;&gt;9.16 절&lt;/a&gt; 참조 ). 이 배열은 특별한 약어가 있다는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="9f13f6d0c9013e1b5a9453aad6e84166421dc49f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;operator&lt;/code&gt; token follows the syntax rules of &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;Section 4.1.3&lt;/a&gt;, or is one of the key words &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;, or is a qualified operator name in the form:</source>
          <target state="translated">여기서 &lt;code&gt;operator&lt;/code&gt; 토큰은 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;섹션 4.1.3&lt;/a&gt; 의 구문 규칙을 따르 거나 키워드 &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; 및 &lt;code&gt;NOT&lt;/code&gt; 중 하나 이거나 형식이 한정된 연산자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8a017c95f90d3833011c4cbc0c74fcbcfe44ef42" translate="yes" xml:space="preserve">
          <source>where the archive directory is physically located on the standby server, so that the &lt;code&gt;archive_command&lt;/code&gt; is accessing it across NFS, but the files are local to the standby. This will:</source>
          <target state="translated">여기서 &lt;code&gt;archive_command&lt;/code&gt; 는 NFS를 통해 디렉토리에 액세스하지만 파일은 대기에 로컬입니다. 이것은 :</target>
        </trans-unit>
        <trans-unit id="a6b4be2958f0bb91c3ed3c4e4583c088a4832f4d" translate="yes" xml:space="preserve">
          <source>where the colon (&lt;code&gt;:&lt;/code&gt;) symbol acts as a delimiter between a phrase and its replacement.</source>
          <target state="translated">여기서, 콜론 ( &lt;code&gt;:&lt;/code&gt; ) 심볼은 구문 및 여분 간의 분리로서 작용한다.</target>
        </trans-unit>
        <trans-unit id="e11e7f071949ee7312e3026921c20a83a618fe45" translate="yes" xml:space="preserve">
          <source>where the comment begins with &lt;code&gt;/*&lt;/code&gt; and extends to the matching occurrence of &lt;code&gt;*/&lt;/code&gt;. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments.</source>
          <target state="translated">여기서 주석은 &lt;code&gt;/*&lt;/code&gt; 로 시작 하고 일치하는 &lt;code&gt;*/&lt;/code&gt; 로 확장됩니다 . 이러한 블록 주석은 SQL 표준에 지정되어 있지만 C와 달리 중첩되므로 기존 블록 주석을 포함 할 수있는 더 큰 코드 블록을 주석 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8e7c67b39887933602dcee06120320113183300a" translate="yes" xml:space="preserve">
          <source>where the component fields are:</source>
          <target state="translated">구성 요소 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a5be562692973652e8751f219be291ae87f74a1" translate="yes" xml:space="preserve">
          <source>where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the &lt;code&gt;COPY&lt;/code&gt; command in &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;.</source>
          <target state="translated">백엔드 프로세스가 파일을 직접 읽으므로 소스 파일의 파일 이름은 클라이언트가 아닌 백엔드 프로세스를 실행하는 시스템에서 사용 가능해야합니다. 당신은에 대해 자세히 읽을 수있는 &lt;code&gt;COPY&lt;/code&gt; 의 명령 &lt;a href=&quot;sql-copy&quot;&gt;COPY를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aca0a6010ee58659cb962578b12187acb232c0bd" translate="yes" xml:space="preserve">
          <source>where the format of a table mapping depends on the &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; parameter as explained above.</source>
          <target state="translated">여기서 테이블 매핑 형식은 위에서 설명한 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt; 매개 변수 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="c322d4fb81e0c24a81de070751209570b9a21fe2" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the boundary of the polygon.</source>
          <target state="translated">여기서 점은 다각형의 경계를 포함하는 선분의 ​​끝점입니다.</target>
        </trans-unit>
        <trans-unit id="f3a39e39e3dc55cc38a327aeb589b6bbda39e7f5" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the path. Square brackets (&lt;code&gt;[]&lt;/code&gt;) indicate an open path, while parentheses (&lt;code&gt;()&lt;/code&gt;) indicate a closed path. When the outermost parentheses are omitted, as in the third through fifth syntaxes, a closed path is assumed.</source>
          <target state="translated">여기서 포인트는 경로를 포함하는 선분의 ​​끝 포인트입니다. 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )는 열린 경로를 나타내고 괄호 ( &lt;code&gt;()&lt;/code&gt; )는 닫힌 경로를 나타냅니다. 세 번째에서 다섯 번째 구문과 같이 가장 바깥 쪽 괄호를 생략하면 닫힌 경로가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="8b49a312334fd1bdab104f06f0ce7761910dd239" translate="yes" xml:space="preserve">
          <source>where the recursive self-reference must appear on the right-hand side of the &lt;code&gt;UNION&lt;/code&gt;. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive &lt;code&gt;SELECT&lt;/code&gt; query in a data-modifying statement. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for an example.</source>
          <target state="translated">여기서 재귀 자기 참조는 &lt;code&gt;UNION&lt;/code&gt; 의 오른쪽에 나타나야합니다 . 쿼리 당 하나의 재귀 자체 참조 만 허용됩니다. 재귀 데이터 수정 문은 지원되지 않지만 데이터 수정 문에서 재귀 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 결과를 사용할 수 있습니다 . 예제는 &lt;a href=&quot;queries-with&quot;&gt;섹션 7.8&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dab6fc9fba9dce67d798f2e3e758f073548c0c8" translate="yes" xml:space="preserve">
          <source>where the schema mapping is as above.</source>
          <target state="translated">여기서 스키마 매핑은 위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e9fff4ccdc17ba4f1e6aa42fae36f876c94b66d" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;. The number of obsolete tuples is obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">여기서 진공베이스 임계 값은 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; 이고, 진공 스케일 계수는 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; 이며 튜플 수는 &lt;code&gt;pg_class&lt;/code&gt; 입니다. &lt;code&gt;reltuples&lt;/code&gt; . 사용되지 않는 튜플의 수는 통계 수집기에서 가져옵니다. 각 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 조작으로 갱신 된 반 정확한 계수 입니다. (로드 가 많은 경우 일부 정보가 손실 될 수 있기 때문에 반 정확성입니다.) 테이블 의 &lt;code&gt;relfrozenxid&lt;/code&gt; 값이 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 트랜잭션 보다 오래되면 오래된 튜플을 동결하고 &lt;code&gt;relfrozenxid&lt;/code&gt; 를 진행시키기 위해 적극적인 진공이 수행됩니다.; 그렇지 않으면 마지막 진공 처리 이후 수정 된 페이지 만 스캔됩니다.</target>
        </trans-unit>
        <trans-unit id="4e9d5d3d104047e0064d4303bd59ec16810bf890" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">자신의 로그인 이름이 언급 된 곳. 관리자가 PostgreSQL 사용자 계정을 생성하지 않은 경우에 발생합니다. PostgreSQL 사용자 계정은 운영 체제 사용자 계정과 다릅니다. 관리자 인 경우 계정 생성에 대한 도움말은 &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;21 장을&lt;/a&gt; 참조하십시오 . 첫 번째 사용자 계정을 만들려면 PostgreSQL을 설치 한 운영 체제 사용자 (일반적으로 &lt;code&gt;postgres&lt;/code&gt; )가되어야합니다. 운영 체제 사용자 이름과 다른 PostgreSQL 사용자 이름이 할당되었을 수도 있습니다. 이 경우 &lt;code&gt;-U&lt;/code&gt; 스위치 를 사용 하거나 &lt;code&gt;PGUSER&lt;/code&gt; 환경 변수를 설정하여 PostgreSQL 사용자 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f1cf5f67d7b1357c152874d6df8382f05565c46" translate="yes" xml:space="preserve">
          <source>which displays per-product sales totals in only the top sales regions. The &lt;code&gt;WITH&lt;/code&gt; clause defines two auxiliary statements named &lt;code&gt;regional_sales&lt;/code&gt; and &lt;code&gt;top_regions&lt;/code&gt;, where the output of &lt;code&gt;regional_sales&lt;/code&gt; is used in &lt;code&gt;top_regions&lt;/code&gt; and the output of &lt;code&gt;top_regions&lt;/code&gt; is used in the primary &lt;code&gt;SELECT&lt;/code&gt; query. This example could have been written without &lt;code&gt;WITH&lt;/code&gt;, but we'd have needed two levels of nested sub-&lt;code&gt;SELECT&lt;/code&gt;s. It's a bit easier to follow this way.</source>
          <target state="translated">상위 판매 지역에서만 총 제품 판매량을 표시합니다. &lt;code&gt;WITH&lt;/code&gt; 의 절은 두 개의 보조 문이라는 정의 &lt;code&gt;regional_sales&lt;/code&gt; 및 &lt;code&gt;top_regions&lt;/code&gt; 의 출력, &lt;code&gt;regional_sales&lt;/code&gt; 이 사용된다 &lt;code&gt;top_regions&lt;/code&gt; 와의 출력 &lt;code&gt;top_regions&lt;/code&gt; 이 차에 사용되는 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를. 이 예제는 &lt;code&gt;WITH&lt;/code&gt; 없이 작성 될 수 있었지만 두 가지 수준의 중첩 된 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 필요했습니다 . 이 방법을 따르는 것이 조금 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bae8a1a20973cccefd7c610839e91bd3974b4005" translate="yes" xml:space="preserve">
          <source>which finds the ten places closest to a given target point. The ability to do this is again dependent on the particular operator class being used. In &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;, operators that can be used in this way are listed in the column &amp;ldquo;Ordering Operators&amp;rdquo;.</source>
          <target state="translated">주어진 목표 지점에 가장 가까운 열 곳을 찾습니다. 이를 수행하는 기능은 사용중인 특정 연산자 클래스에 따라 다시 달라집니다. 에서 &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 64.1&lt;/a&gt; , 이런 식으로 사용할 수있는 연산자는 열 &quot;주문 운영자&quot;에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfde0f1cc2ebaaf170e42acdfe9b417e65a8fd3" translate="yes" xml:space="preserve">
          <source>which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using &lt;code&gt;HAVING&lt;/code&gt;:</source>
          <target state="translated">도시 당 하나의 출력 행을 제공합니다. 각 집계 결과는 해당 도시와 일치하는 테이블 행에 대해 계산됩니다. &lt;code&gt;HAVING&lt;/code&gt; 을 사용하여 그룹화 된 행을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b9fcfc65791db8244d0ec78c95baca6172d630" translate="yes" xml:space="preserve">
          <source>which gives us the same results for only the cities that have all &lt;code&gt;temp_lo&lt;/code&gt; values below 40. Finally, if we only care about cities whose names begin with &amp;ldquo;&lt;code&gt;S&lt;/code&gt;&amp;rdquo;, we might do:</source>
          <target state="translated">이는 모든 &lt;code&gt;temp_lo&lt;/code&gt; 값이 40 미만인 도시에 대해서만 동일한 결과를 제공 합니다. 마지막으로 이름이 &quot; &lt;code&gt;S&lt;/code&gt; &quot;로 시작하는 도시 만 신경 쓰면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689a2e02b1a49db16b3b1be754391d4fc8da64e0" translate="yes" xml:space="preserve">
          <source>which is executed as:</source>
          <target state="translated">이것은 다음과 같이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f15875e884530dd30ab6d27db56535aa74c98f64" translate="yes" xml:space="preserve">
          <source>which obtains the 50th percentile, or median, value of the &lt;code&gt;income&lt;/code&gt; column from table &lt;code&gt;households&lt;/code&gt;. Here, &lt;code&gt;0.5&lt;/code&gt; is a direct argument; it would make no sense for the percentile fraction to be a value varying across rows.</source>
          <target state="translated">이는 테이블 &lt;code&gt;households&lt;/code&gt; 에서 &lt;code&gt;income&lt;/code&gt; 열의 50 번째 백분위 수 또는 중앙값을 얻습니다 . 여기서 &lt;code&gt;0.5&lt;/code&gt; 는 직접적인 논증입니다. 백분위 수 비율이 행마다 다른 값이되는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6ee8c6433c23fa17a7f1946c5c1b26470b55b09" translate="yes" xml:space="preserve">
          <source>which refers to a function with zero arguments, whereas the first variant can refer to a function with any number of arguments, including zero, as long as the name is unique.</source>
          <target state="translated">첫 번째 변형은 이름이 고유 한 한 0을 포함하여 여러 개의 인수가있는 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e899e70b75b90b65729658ed54cd0ca39432992" translate="yes" xml:space="preserve">
          <source>which returns:</source>
          <target state="translated">다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74cad75d5e4f20aa31f501f8fefdc21abad67352" translate="yes" xml:space="preserve">
          <source>which shows that the planner thinks that sorting &lt;code&gt;onek&lt;/code&gt; by index-scanning is about 12% more expensive than sequential-scan-and-sort. Of course, the next question is whether it's right about that. We can investigate that using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, as discussed below.</source>
          <target state="translated">이는 플래너가 인덱스 스캔으로 &lt;code&gt;onek&lt;/code&gt; 를 정렬 하는 것이 순차 스캔 및 정렬보다 약 12 ​​% 더 비싸다고 생각한다는 것을 보여줍니다 . 물론 다음 질문은 그것이 옳은지 여부입니다. 아래에서 설명하는 것처럼 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 사용을 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0656a99c8833cfc345dd27d0b6820caa432991" translate="yes" xml:space="preserve">
          <source>which we wish to display like</source>
          <target state="translated">우리가 보여주고 싶은</target>
        </trans-unit>
        <trans-unit id="c282db8639e1ae34ff018f3c72116a8c43100b68" translate="yes" xml:space="preserve">
          <source>which will copy archivable WAL segments to the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. (This is an example, not a recommendation, and might not work on all platforms.) After the &lt;code&gt;%p&lt;/code&gt; and &lt;code&gt;%f&lt;/code&gt; parameters have been replaced, the actual command executed might look like this:</source>
          <target state="translated">아카이브 가능한 WAL 세그먼트를 &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; 디렉토리에 복사 합니다 . (이것은 권장 사항이 아니며 예제이며 모든 플랫폼에서 작동하지 않을 수 있습니다.) &lt;code&gt;%p&lt;/code&gt; 및 &lt;code&gt;%f&lt;/code&gt; 매개 변수가 교체 된 후 실행 된 실제 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a169e40949af2620c4e85dda15d79975492e73f" translate="yes" xml:space="preserve">
          <source>which will copy previously archived WAL segments from the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. Of course, you can use something much more complicated, perhaps even a shell script that requests the operator to mount an appropriate tape.</source>
          <target state="translated">이전에 아카이브 된 WAL 세그먼트를 &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; 디렉토리에서 복사 합니다 . 물론 훨씬 더 복잡한 것을 사용할 수 있습니다. 아마도 운영자에게 적절한 테이프를 마운트하도록 요청하는 쉘 스크립트 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cd6a2051ea99afa4a27d84b6ed47beb5036a7c" translate="yes" xml:space="preserve">
          <source>which will leave the server running in the foreground. This must be done while logged into the PostgreSQL user account. Without &lt;code&gt;-D&lt;/code&gt;, the server will try to use the data directory named by the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. If that variable is not provided either, it will fail.</source>
          <target state="translated">그러면 서버가 포 그라운드에서 실행됩니다. PostgreSQL 사용자 계정에 로그인 한 상태에서 수행해야합니다. &lt;code&gt;-D&lt;/code&gt; 가 없으면 서버는 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 로 명명 된 데이터 디렉토리를 사용하려고합니다 . 해당 변수가 제공되지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4e8f14819326dd3aae3a2cf53d737470310c24e" translate="yes" xml:space="preserve">
          <source>which will match the stemmed form of &lt;code&gt;postgraduate&lt;/code&gt;.</source>
          <target state="translated">이것은 줄기 형태의 &lt;code&gt;postgraduate&lt;/code&gt; 과 일치 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5ff082187c1d02a1fdad2296ffb917870a45b03c" translate="yes" xml:space="preserve">
          <source>which would allow a box value's component numbers to be accessed by subscripting. Otherwise the type behaves the same as before.</source>
          <target state="translated">첨자에 의해 상자 값의 구성 요소 번호에 액세스 할 수 있습니다. 그렇지 않으면 유형이 이전과 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="df5d2347727e9e14fc56d97420272403e963b0b6" translate="yes" xml:space="preserve">
          <source>which would be a valid value of the &lt;code&gt;inventory_item&lt;/code&gt; type defined above. To make a field be NULL, write no characters at all in its position in the list. For example, this constant specifies a NULL third field:</source>
          <target state="translated">이는 위에서 정의한 &lt;code&gt;inventory_item&lt;/code&gt; 유형 의 유효한 값입니다 . 필드를 NULL로 만들려면 목록에서 해당 위치에 문자를 전혀 쓰지 마십시오. 예를 들어,이 상수는 NULL 세 번째 필드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9a3be0245636efccdc3c57134520df09a0e4a0a4" translate="yes" xml:space="preserve">
          <source>white space and comments cannot appear within multi-character symbols, such as &lt;code&gt;(?:&lt;/code&gt;</source>
          <target state="translated">공백과 주석은 &lt;code&gt;(?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b43caaeffd6a470ec3896dc284dda83445964f79" translate="yes" xml:space="preserve">
          <source>white space or &lt;code&gt;#&lt;/code&gt; within a bracket expression is retained</source>
          <target state="translated">공백 또는 &lt;code&gt;#&lt;/code&gt; 괄호 표현식 내의 # 는 유지됩니다</target>
        </trans-unit>
        <trans-unit id="52b07ed610fcda069d74b3a411d9e935637def49" translate="yes" xml:space="preserve">
          <source>will be allowed if the cast from type &lt;code&gt;integer&lt;/code&gt; to type &lt;code&gt;text&lt;/code&gt; is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt;, otherwise not. (We generally use the term &lt;em&gt;assignment cast&lt;/em&gt; to describe this kind of cast.)</source>
          <target state="translated">유형 &lt;code&gt;integer&lt;/code&gt; 에서 유형 &lt;code&gt;text&lt;/code&gt; 캐스트 가 &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; 로 표시 되면 허용됩니다 . 일반적으로 이러한 유형의 캐스트를 설명하기 위해 &lt;em&gt;할당 캐스트&lt;/em&gt; 라는 용어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e7b329bd0ae166b219c0dac7856440cebddc7bef" translate="yes" xml:space="preserve">
          <source>will be parsed as:</source>
          <target state="translated">다음과 같이 파싱됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc5b8ad0d43009e11ed531b9ba723b81a61922b" translate="yes" xml:space="preserve">
          <source>will draw an error even though the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations have identical behaviors. Mixing stripped and non-stripped collation names is therefore not recommended.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;POSIX&lt;/code&gt; 데이터 정렬의 동작이 동일 하더라도 오류가 발생 합니다. 따라서 잘린 조합 이름과 비 스트립 조합 이름은 혼합하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8ea301593a0a7ff485b37c9d6c155df86be3bfc8" translate="yes" xml:space="preserve">
          <source>will lock only rows having &lt;code&gt;col1 = 5&lt;/code&gt;, even though that condition is not textually within the sub-query.</source>
          <target state="translated">해당 조건이 텍스트로 하위 쿼리 내에 있지 않더라도 &lt;code&gt;col1 = 5&lt;/code&gt; 인 행만 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="b9075f9f3f87909783fee359888bd2c471dea042" translate="yes" xml:space="preserve">
          <source>will only process the master table.</source>
          <target state="translated">마스터 테이블 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="166a3172a29e9b1013bd7227d7fa350d195805cd" translate="yes" xml:space="preserve">
          <source>will remove the domain part for users with system user names that end with &lt;code&gt;@mydomain.com&lt;/code&gt;, and allow any user whose system name ends with &lt;code&gt;@otherdomain.com&lt;/code&gt; to log in as &lt;code&gt;guest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@mydomain.com&lt;/code&gt; 끝나는 시스템 사용자 이름을 가진 사용자의 도메인 부분을 제거하고 &lt;code&gt;@otherdomain.com&lt;/code&gt; 으로 끝나는 시스템 이름을 가진 모든 사용자가 &lt;code&gt;guest&lt;/code&gt; 로 로그인 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="733025f436e0af6dc9df77a7ba625859cbbf72ca" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index which includes all rows in the table.</source>
          <target state="translated">테이블 크기에 비례하는 노력이 필요합니다. PostgreSQL은 전체 테이블 또는 테이블의 모든 행을 포함하는 인덱스 전체를 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="91e07485ce9849ddc161bb7d803839b8f2cfb477" translate="yes" xml:space="preserve">
          <source>will result in the three SQL commands being individually sent to the server, with each one's results being displayed before continuing to the next command. However, a semicolon entered as &lt;code&gt;\;&lt;/code&gt; will not trigger command processing, so that the command before it and the one after are effectively combined and sent to the server in one request. So for example</source>
          <target state="translated">세 개의 SQL 명령이 개별적으로 서버로 전송되고 다음 명령을 계속하기 전에 각 명령의 결과가 표시됩니다. 그러나 세미콜론은 &lt;code&gt;\;&lt;/code&gt; 입력되었습니다 . 명령 처리를 트리거하지 않으므로 명령 전과 명령이 효과적으로 결합되어 한 번의 요청으로 서버로 전송됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="047ba62edd680e2d56a13904abdabc4188cb005b" translate="yes" xml:space="preserve">
          <source>will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">두 개의 열과 세 개의 행으로 구성된 테이블을 반환합니다. 효과적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cf8c1d7fdc60299e5a5cb3f3300a0c91cf43fb7" translate="yes" xml:space="preserve">
          <source>will start the server in the background and put the output into the named log file. The &lt;code&gt;-D&lt;/code&gt; option has the same meaning here as for &lt;code&gt;postgres&lt;/code&gt;. &lt;code&gt;pg_ctl&lt;/code&gt; is also capable of stopping the server.</source>
          <target state="translated">백그라운드에서 서버를 시작하고 출력을 명명 된 로그 파일에 넣습니다. &lt;code&gt;-D&lt;/code&gt; 옵션은 여기에서와 같은 의미를 &lt;code&gt;postgres&lt;/code&gt; . &lt;code&gt;pg_ctl&lt;/code&gt; 은 서버를 중지시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7130bc171fc84062054c81f8bc4460528312537b" translate="yes" xml:space="preserve">
          <source>with hot standby</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="af6d8270bf9a28cb0890365af8ad9fbaf343522d" translate="yes" xml:space="preserve">
          <source>with sync off</source>
          <target state="translated">동기화 해제</target>
        </trans-unit>
        <trans-unit id="3a3cc3c4fb4b36db89f9594987cae52aab437928" translate="yes" xml:space="preserve">
          <source>with sync on</source>
          <target state="translated">동기화를 켠 상태</target>
        </trans-unit>
        <trans-unit id="9370d4f218264e82510fdcf2db2c6328e076bb0c" translate="yes" xml:space="preserve">
          <source>with the default &lt;code&gt;BLCKSZ&lt;/code&gt; of 8192 bytes</source>
          <target state="translated">기본 &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8192 바이트 인</target>
        </trans-unit>
        <trans-unit id="1fcb8a613e6e45488de8c47b5f45118a3ee76969" translate="yes" xml:space="preserve">
          <source>without any precision or scale creates a column in which numeric values of any precision and scale can be stored, up to the implementation limit on precision. A column of this kind will not coerce input values to any particular scale, whereas &lt;code&gt;numeric&lt;/code&gt; columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about portability, always specify the precision and scale explicitly.)</source>
          <target state="translated">정밀도 또는 스케일이 없으면 정밀도에 대한 구현 한계까지 모든 정밀도 및 스케일의 숫자 값을 저장할 수있는 열을 작성합니다. 이러한 종류의 열은 입력 값을 특정 스케일로 강제 변환하지 않지만 선언 된 스케일을 가진 &lt;code&gt;numeric&lt;/code&gt; 열은 입력 값을 해당 스케일로 강제 변환합니다. (SQL 표준은 기본 스케일 0, 즉 정수 정밀도에 대한 강제를 요구합니다. 우리는 이것을 조금 쓸모가 없다는 것을 알게되었습니다. 이식성에 대해 염려 할 경우 항상 정밀도와 스케일을 명시 적으로 지정하십시오.)</target>
        </trans-unit>
        <trans-unit id="db48d21b6765af674c2d86f7d7085037c147d319" translate="yes" xml:space="preserve">
          <source>would fail to preserve the &lt;code&gt;FOR UPDATE&lt;/code&gt; lock after the &lt;code&gt;ROLLBACK TO&lt;/code&gt;. This has been fixed in release 9.3.</source>
          <target state="translated">&lt;code&gt;ROLLBACK TO&lt;/code&gt; 후 &lt;code&gt;FOR UPDATE&lt;/code&gt; 잠금 을 유지하지 못했습니다 . 이것은 릴리스 9.3에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d993c428e713634961b14ab1031f2202eb8ab483" translate="yes" xml:space="preserve">
          <source>would query the table &lt;code&gt;my_table&lt;/code&gt;. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it.</source>
          <target state="translated">&lt;code&gt;my_table&lt;/code&gt; 테이블을 쿼리합니다 . 이것은 안전하지 않을 수 있습니다. 변수의 값은 문자 그대로 복사되므로 불균형 따옴표 나 백 슬래시 명령을 포함 할 수 있습니다. 어디에 두 었는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fb1884d01fa0af9488b72c839058eb9b1cd3ec9" translate="yes" xml:space="preserve">
          <source>www.openwall.com</source>
          <target state="translated">www.openwall.com</target>
        </trans-unit>
        <trans-unit id="ee60015c8f586443db97ad8f39f2b79227b8fd01" translate="yes" xml:space="preserve">
          <source>xact</source>
          <target state="translated">xact</target>
        </trans-unit>
        <trans-unit id="30e2ca63aa35fbb6880b2c6d43d8e5e3aa97095e" translate="yes" xml:space="preserve">
          <source>xml2</source>
          <target state="translated">xml2</target>
        </trans-unit>
        <trans-unit id="f94d7d22277dd8bae275a25a490b99203cccb3b3" translate="yes" xml:space="preserve">
          <source>y-intercept of the least-squares-fit linear equation determined by the (&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;) pairs</source>
          <target state="translated">( &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; ) 쌍으로 결정된 최소 제곱 법 선형 방정식의 y 절편</target>
        </trans-unit>
        <trans-unit id="150f912c47bfa78eaad7a19807fcef6747d4b800" translate="yes" xml:space="preserve">
          <source>year (4 or more digits)</source>
          <target state="translated">연도 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="611de26b771af738f57fb9b6c8721bb546f69f99" translate="yes" xml:space="preserve">
          <source>year (4 or more digits) with comma</source>
          <target state="translated">쉼표가있는 연도 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="127cd8c2aa50e43e37fcd0ad357fa69ed4e6f270" translate="yes" xml:space="preserve">
          <source>year 99 BC</source>
          <target state="translated">99 년 BC</target>
        </trans-unit>
        <trans-unit id="d468eeeab09a5f89dd95cca8a1d68fbf5b52784a" translate="yes" xml:space="preserve">
          <source>year and day of year</source>
          <target state="translated">년과 일</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="b7caf4dc1da846acd815fdde550fbd1677a60c12" translate="yes" xml:space="preserve">
          <source>yes (Note 1)</source>
          <target state="translated">예 (주 1)</target>
        </trans-unit>
        <trans-unit id="a6e931eb3e1e969efa57eb9a58fd4f25fd4cb2e1" translate="yes" xml:space="preserve">
          <source>you will find that &lt;code&gt;tenk1&lt;/code&gt; has 358 disk pages and 10000 rows. The estimated cost is computed as (disk pages read * &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;) + (rows scanned * &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;). By default, &lt;code&gt;seq_page_cost&lt;/code&gt; is 1.0 and &lt;code&gt;cpu_tuple_cost&lt;/code&gt; is 0.01, so the estimated cost is (358 * 1.0) + (10000 * 0.01) = 458.</source>
          <target state="translated">당신은 발견 할 것이다 &lt;code&gt;tenk1&lt;/code&gt; 가 358 디스크 페이지와 10000 개 행이 있습니다. 예상 비용은 다음과 같이 계산 (디스크 페이지 * 읽어 &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost를&lt;/a&gt; ) + (행 * 스캔 &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost을&lt;/a&gt; ). 기본적으로 &lt;code&gt;seq_page_cost&lt;/code&gt; 는 1.0이고 &lt;code&gt;cpu_tuple_cost&lt;/code&gt; 는 0.01이므로 추정 비용은 (358 * 1.0) + (10000 * 0.01) = 458입니다.</target>
        </trans-unit>
        <trans-unit id="1982d2d3e9d46b67ceb2b6b1086e041a7f7ce8a9" translate="yes" xml:space="preserve">
          <source>zero octet</source>
          <target state="translated">제로 옥텟</target>
        </trans-unit>
        <trans-unit id="5aab974202bf0788f59e7ce97b96b6b4d59e6caf" translate="yes" xml:space="preserve">
          <source>{A,B,C}</source>
          <target state="translated">{A,B,C}</target>
        </trans-unit>
        <trans-unit id="f751f41a86686962c7eb6a6c72d7aead8c2eed66" translate="yes" xml:space="preserve">
          <source>~ ! @ # % ^ &amp;amp; | ` ?</source>
          <target state="translated">~! @ # % ^ &amp;amp; | `?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
