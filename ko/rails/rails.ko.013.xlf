<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rails">
    <body>
      <group id="rails">
        <trans-unit id="92a84248a85c0345a1f31c7e901bddf26352d033" translate="yes" xml:space="preserve">
          <source>If you did not configure the &lt;code&gt;:host&lt;/code&gt; option globally make sure to pass it to the URL helper.</source>
          <target state="translated">&lt;code&gt;:host&lt;/code&gt; 옵션을 전체적으로 구성하지 않은 경우 URL 도우미에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="19f896a8051227d916889ea44e72bfd1d0512d45" translate="yes" xml:space="preserve">
          <source>If you didn't want to use a generator, you could create your own file inside of &lt;code&gt;app/mailers&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ActionMailer::Base&lt;/code&gt;:</source>
          <target state="translated">생성기를 사용하지 않으려면 &lt;code&gt;app/mailers&lt;/code&gt; 내에 자체 파일을 만들 수 있습니다. &lt;code&gt;ActionMailer::Base&lt;/code&gt; 에서 상속 받도록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31e7db8dd815a268d841d89ad01529eaae9db9a7" translate="yes" xml:space="preserve">
          <source>If you do not pass a block to the &lt;code&gt;mail&lt;/code&gt; method, it will find all templates in the view paths using by default the mailer name and the method name that it is being called from, it will then create parts for each of these templates intelligently, making educated guesses on correct content type and sequence, and return a fully prepared &lt;code&gt;Mail::Message&lt;/code&gt; ready to call &lt;code&gt;:deliver&lt;/code&gt; on to send.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 메소드에 블록을 전달하지 않으면 기본적으로 메일러 이름과 호출되는 메소드 이름을 사용하여보기 경로에서 모든 템플리트를 찾은 다음 해당 템플리트 각각에 대한 부분을 지능적으로 작성합니다. 올바른 콘텐츠 형식과 순서에 대한 교육 추측을하고 만반의 준비를 반환 &lt;code&gt;Mail::Message&lt;/code&gt; 를 호출 할 준비가 &lt;code&gt;:deliver&lt;/code&gt; 전송에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49bb87fb9a1a55c72a69389c44e7008d38edb7d" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4140ab18bcd63be6a412aecefbbbd190489cd2d5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cb18e1cb1e3c7f393cc6642780d06d1eb6b80c5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f027cb4edcde27ee50ad5b5eddd3e7ae2b8487fc" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches&lt;/a&gt;, it will return a &lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt; which is enumerable.</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches에&lt;/a&gt; 블록을 제공하지 않으면 열거 가능한 &lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt; 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a014b6ac6ec93d8bd393971aaa82010a7c491b1f" translate="yes" xml:space="preserve">
          <source>If you do not set the &lt;code&gt;:inverse_of&lt;/code&gt; record, the association will do its best to match itself up with the correct inverse. Automatic inverse detection only works on &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;, and &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; associations.</source>
          <target state="translated">&lt;code&gt;:inverse_of&lt;/code&gt; 레코드를 설정하지 않으면 연결이 올바른 역수와 일치하도록 최선을 다합니다. 자동 역 검출은 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; , &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; 및 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 연관 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="02910cc77b0be1566c9800df7735a1d0ac74e701" translate="yes" xml:space="preserve">
          <source>If you do not specify a value for this option, a deprecation warning will be emitted. To avoid this, add the following line to your test environment:</source>
          <target state="translated">이 옵션에 값을 지정하지 않으면 사용 중단 경고가 표시됩니다. 이를 피하려면 테스트 환경에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eef8af99ea47332d6d11e1ad298d5910dde6559d" translate="yes" xml:space="preserve">
          <source>If you do not want the instance predicate, pass &lt;code&gt;instance_predicate: false&lt;/code&gt; and it will not be defined.</source>
          <target state="translated">인스턴스 술어를 원하지 않으면 &lt;code&gt;instance_predicate: false&lt;/code&gt; 전달 하면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48efd90fc348a0d9589d86743ee6c2acc3f50c3d" translate="yes" xml:space="preserve">
          <source>If you do not want your file to be handled via the raw handler, you should add an extension to your file that can be parsed by the appropriate template handler.</source>
          <target state="translated">원시 핸들러를 통해 파일을 처리하지 않으려면 파일에 적절한 템플리트 핸들러로 구문 분석 할 수있는 확장자를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="406900a443f2d25a6b532f732fd2e6e6351bbff5" translate="yes" xml:space="preserve">
          <source>If you do pass a block, you can render specific templates of your choice:</source>
          <target state="translated">블록을 전달하면 선택한 특정 템플릿을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74ecd23e26826cdd049e7329b893237f73b60f68" translate="yes" xml:space="preserve">
          <source>If you do so, you will have to define manually the class name that is hosting the fixtures (my_products.yml) using the &lt;code&gt;set_fixture_class&lt;/code&gt; method in your test definition:</source>
          <target state="translated">그렇게하면 테스트 정의에서 &lt;code&gt;set_fixture_class&lt;/code&gt; 메소드를 사용하여 조명기 (my_products.yml)를 호스팅하는 클래스 이름을 수동으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ca0e1fc71c14f9f8af7450a60a370b0f48d31113" translate="yes" xml:space="preserve">
          <source>If you do this, then Mail will take the file name and work out the mime type. It will also set the Content-Type, Content-Disposition, Content-Transfer-Encoding and encode the contents of the attachment in Base64.</source>
          <target state="translated">이 작업을 수행하면 Mail은 파일 이름을 사용하여 MIME 유형을 해결합니다. 또한 Content-Type, Content-Disposition, Content-Transfer-Encoding을 설정하고 Base64에서 첨부 파일의 내용을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8767744e965d45f97b638be1206c0cffe952975f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t provide a content type and Active Storage can&amp;rsquo;t determine the file&amp;rsquo;s content type automatically, it defaults to application/octet-stream.</source>
          <target state="translated">컨텐츠 유형을 제공하지 않고 Active Storage가 파일의 컨텐츠 유형을 자동으로 판별 할 수없는 경우, 기본값은 application / octet-stream입니다.</target>
        </trans-unit>
        <trans-unit id="fc9c20b9484d5edd8a9592cdbfabd993cce65aec" translate="yes" xml:space="preserve">
          <source>If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just like normal subclasses with no special magic for differentiating between them or reloading the right type with find.</source>
          <target state="translated">테이블에 유형 열이 정의되어 있지 않으면 단일 테이블 상속이 트리거되지 않습니다. 이 경우 다른 하위 클래스를 구분하거나 find를 사용하여 올바른 유형을 다시로드 할 수있는 특별한 마법이없는 일반 서브 클래스처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f2bc8d4f243e8832712c4be31cca4d7689b2c779" translate="yes" xml:space="preserve">
          <source>If you don't have any special response processing and are using the default rendering mechanism (i.e. you're not using &lt;code&gt;respond_to&lt;/code&gt; or calling render yourself) then you've got an easy helper in &lt;code&gt;fresh_when&lt;/code&gt;:</source>
          <target state="translated">특별한 응답 처리가없고 기본 렌더링 메커니즘을 사용하는 경우 (즉, &lt;code&gt;respond_to&lt;/code&gt; 를 사용하지 않거나 직접 렌더링을 호출하는 경우) &lt;code&gt;fresh_when&lt;/code&gt; 에서 쉬운 도우미가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="536d96169698859e04794d8ff518da4654447b74" translate="yes" xml:space="preserve">
          <source>If you don't have it, you can add the following to your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">없는 경우 &lt;code&gt;Gemfile&lt;/code&gt; 에 다음을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8fe1583558b53ca29247f000ea8f412b9bbd5ca" translate="yes" xml:space="preserve">
          <source>If you don't just want to parlay the broadcast unfiltered to the subscriber, you can also supply a callback that lets you alter what is sent out. The below example shows how you can use this to provide performance introspection in the process:</source>
          <target state="translated">구독자에게 필터링되지 않은 브로드 캐스트를 파레이 링하지 않으려는 경우 전송되는 내용을 변경할 수있는 콜백을 제공 할 수도 있습니다. 아래 예제는이를 사용하여 프로세스에서 성능 내부 검사를 제공하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ff55d0e491430e1f64a9c77d9de71b7cbc9a9a1" translate="yes" xml:space="preserve">
          <source>If you don't need to attach a form to a model instance, then check out &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView::Helpers::FormTagHelper#form_tag&lt;/a&gt;.</source>
          <target state="translated">모델 인스턴스에 폼을 첨부 할 필요가 없으면 &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView :: Helpers :: FormTagHelper # form_tag&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccd012a92fa2736ea2202478d5a8d02230235625" translate="yes" xml:space="preserve">
          <source>If you don't pass a subject to the &lt;code&gt;mail&lt;/code&gt; method, Action Mailer will try to find it in your translations. The performed lookup will use the pattern &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; to construct the key.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 방법에 제목을 전달하지 않으면 Action Mailer는 번역에서 해당 제목 을 찾으려고 시도합니다. 수행 된 조회는 &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; 패턴을 사용 하여 키를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="43990df1c551a2eb7490c735de41631ffb9f7a25" translate="yes" xml:space="preserve">
          <source>If you don't specify an endpoint, routes will be used as the default endpoint. You can use them just like you use an application's routes:</source>
          <target state="translated">끝점을 지정하지 않으면 경로가 기본 끝점으로 사용됩니다. 응용 프로그램의 경로를 사용하는 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892033cd916d52f004ab4ae9e14cfd8ddedf786b" translate="yes" xml:space="preserve">
          <source>If you don't want to an authenticity token field be rendered at all just pass &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">진위 토큰 필드를 원치 않으면 &lt;code&gt;false&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cb88ea8687e4075151208607606ccf25698f8be" translate="yes" xml:space="preserve">
          <source>If you don't want to force a layout on to users of the engine, then you can delete this file and reference a different layout in the controllers of your engine.</source>
          <target state="translated">엔진 사용자에게 강제로 레이아웃을 적용하지 않으려면이 파일을 삭제하고 엔진 컨트롤러에서 다른 레이아웃을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25721c75d7a2c3ad6bd3a5b975b48bea88d6ad0b" translate="yes" xml:space="preserve">
          <source>If you don't want to force the use of a locale in your routes you can use an optional path scope (denoted by the parentheses) like so:</source>
          <target state="translated">경로에서 로캘을 강제로 사용하지 않으려면 다음과 같이 선택적 경로 범위 (괄호로 표시)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4220d9a84edef742f81d3e912d4afd9142ab026" translate="yes" xml:space="preserve">
          <source>If you don't want to use a generator, you could create your own file inside of &lt;code&gt;app/jobs&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">생성기를 사용하지 않으려면 &lt;code&gt;app/jobs&lt;/code&gt; 내에 자체 파일을 만들 수 있습니다 . &lt;code&gt;ApplicationJob&lt;/code&gt; 에서 상속 받도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="3637b43bcc260555a9e865a3fb610bd1839c0baf" translate="yes" xml:space="preserve">
          <source>If you don't want to use a middleware that is included by default in the API-only middleware set, you can remove it with:</source>
          <target state="translated">API 전용 미들웨어 세트에 기본적으로 포함 된 미들웨어를 사용하지 않으려면 다음을 사용하여 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20674bbcbba7835744bdc242bcd09875ead799c3" translate="yes" xml:space="preserve">
          <source>If you eager load an association with a specified &lt;code&gt;:limit&lt;/code&gt; option, it will be ignored, returning all the associated objects:</source>
          <target state="translated">지정된 &lt;code&gt;:limit&lt;/code&gt; 옵션을 사용하여 연결을 열망하는 경우 연결된 모든 객체를 반환하여 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f46061761309fdc2cd2fc6d585a72e40532ccf5" translate="yes" xml:space="preserve">
          <source>If you enable &lt;code&gt;ParamsWrapper&lt;/code&gt; for &lt;code&gt;:json&lt;/code&gt; format, instead of having to send JSON parameters like this:</source>
          <target state="translated">&lt;code&gt;:json&lt;/code&gt; 형식에 대해 &lt;code&gt;ParamsWrapper&lt;/code&gt; 를 활성화하면 다음 과 같은 JSON 매개 변수를 보내지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="82e3c1aec71b777fae1e7b0b4a0fe046629f64f9" translate="yes" xml:space="preserve">
          <source>If you find your helpers are cluttering &lt;code&gt;test_helper.rb&lt;/code&gt;, you can extract them into separate files. One good place to store them is &lt;code&gt;lib/test&lt;/code&gt;.</source>
          <target state="translated">헬퍼가 &lt;code&gt;test_helper.rb&lt;/code&gt; 를 복잡 하게 만드는 것을 발견하면 별도의 파일로 추출 할 수 있습니다. 그것들을 저장하기에 좋은 곳은 &lt;code&gt;lib/test&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30e6213fe0918312e4279adb45e7deef5e07336a" translate="yes" xml:space="preserve">
          <source>If you find your own locale (language) missing from our &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;example translations data&lt;/a&gt; repository for Ruby on Rails, please &lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;fork&lt;/em&gt;&lt;/a&gt; the repository, add your data, and send a &lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">Ruby on Rails의 &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;번역 데이터&lt;/a&gt; 저장소 예제 에서 사용자 고유의 로케일 (언어)이 누락 된 경우 저장소 를 &lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;포크&lt;/em&gt;&lt;/a&gt; 하고 데이터를 추가 한 후 &lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;pull 요청을&lt;/a&gt; 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="aee4c416dc0883b87638d93d75d5ac3f38315db4" translate="yes" xml:space="preserve">
          <source>If you find yourself adding many extra actions to a resourceful route, it's time to stop and ask yourself whether you're disguising the presence of another resource.</source>
          <target state="translated">자원이 많은 경로에 많은 추가 조치를 추가하는 것을 발견 한 경우, 다른 자원의 존재를 위장하고 있는지를 중지하고 스스로에게 물어볼 시간입니다.</target>
        </trans-unit>
        <trans-unit id="67863595d8969ae1f5a6fe5426cd6b3cf82732bd" translate="yes" xml:space="preserve">
          <source>If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope.</source>
          <target state="translated">모든 경로에 대해이 옵션을 균일하게 변경하려는 경우 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c1ed0660af323c6b38280145d4b69ea2250ce1" translate="yes" xml:space="preserve">
          <source>If you followed the steps in the Basic Authentication section, you'll need to add authorization to every request header to get all the tests passing:</source>
          <target state="translated">기본 인증 섹션의 단계를 수행 한 경우 모든 테스트를 통과하려면 모든 요청 헤더에 권한을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="07b3354400b50989138ed2cd6a3c38797d5e394e" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve authors directly from chapters (&lt;code&gt;@chapter.book.author&lt;/code&gt;), then you can make your code somewhat more efficient by including authors in the association from chapters to books:</source>
          <target state="translated">챕터 ( &lt;code&gt;@chapter.book.author&lt;/code&gt; ) 에서 직접 저자를 자주 검색하는 경우 챕터에서 책에 이르는 관련 작성자를 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73716ae08dcaaac4220267ec92986f29436f62be" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve chapters directly from authors (&lt;code&gt;@author.books.chapters&lt;/code&gt;), then you can make your code somewhat more efficient by including chapters in the association from authors to books:</source>
          <target state="translated">작성자 ( &lt;code&gt;@author.books.chapters&lt;/code&gt; ) 에서 직접 장을 자주 검색하는 경우 저자에서 책에 이르는 연관 장을 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a0030b10beafb8e8d4a632de359b4cb60e78fe" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve representatives directly from suppliers (&lt;code&gt;@supplier.account.representative&lt;/code&gt;), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:</source>
          <target state="translated">공급 업체에서 직접 담당자를 자주 검색하는 경우 ( &lt;code&gt;@supplier.account.representative&lt;/code&gt; ) 공급 업체에서 계정으로 연결에 담당자를 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c0aef2c83bdce2045072d5251d85d631c54098" translate="yes" xml:space="preserve">
          <source>If you generate a form like this:</source>
          <target state="translated">다음과 같은 양식을 생성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5f9908bbf604191f82bab577a8c5260160dab56d" translate="yes" xml:space="preserve">
          <source>If you generate another resource, you can see that we get exactly the same result! This is useful if you want to customize your scaffold templates and/or layout by just creating &lt;code&gt;edit.html.erb&lt;/code&gt;, &lt;code&gt;index.html.erb&lt;/code&gt; and so on inside &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt;.</source>
          <target state="translated">다른 리소스를 생성하면 정확히 같은 결과를 얻을 수 있습니다! &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt; 안에 &lt;code&gt;edit.html.erb&lt;/code&gt; , &lt;code&gt;index.html.erb&lt;/code&gt; 등을 만들어 스캐 폴드 템플릿 및 / 또는 레이아웃을 사용자 정의하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d80a96cb267acb711147a9efacc8f899edfd01" translate="yes" xml:space="preserve">
          <source>If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above.</source>
          <target state="translated">메일러를 생성 한 경우 생성기는 메일러 조치에 대한 스텁 설비를 작성하지 않습니다. 위에서 설명한대로 해당 파일을 직접 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fd092a4ccbfde5c34feeb7f091644196fcd76ba" translate="yes" xml:space="preserve">
          <source>If you get the above error, you might want to increase the size of the connection pool by incrementing the &lt;code&gt;pool&lt;/code&gt; option in &lt;code&gt;database.yml&lt;/code&gt;</source>
          <target state="translated">위의 오류가 발생하면 &lt;code&gt;database.yml&lt;/code&gt; 에서 &lt;code&gt;pool&lt;/code&gt; 옵션을 증가시켜 연결 풀의 크기를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="5abe2a9c4438d6b9d28b46ea384acc62f1555bf4" translate="yes" xml:space="preserve">
          <source>If you got there by a browser request, the browser tab containing the request will be hung until the debugger has finished and the trace has finished processing the entire request.</source>
          <target state="translated">브라우저 요청으로 도착하면 디버거가 완료되고 추적이 전체 요청 처리를 완료 할 때까지 요청이 포함 된 브라우저 탭이 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="90a6bff827a4dfd6e1a87d9ded69a67eee69dad6" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;config/database.yml&lt;/code&gt; but no &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; then this file will be used to connect to your database:</source>
          <target state="translated">당신이 가지고있는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 하지만 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 파일은 데이터베이스에 연결하는 데 사용됩니다 없습니다</target>
        </trans-unit>
        <trans-unit id="1be4ccdf90899637a9e7f5bb397c6eba29f87752" translate="yes" xml:space="preserve">
          <source>If you have a Rails template that adds all the files in version control, it fails to add the generated binstubs because it gets executed before Bundler:</source>
          <target state="translated">버전 제어에 모든 파일을 추가하는 Rails 템플리트가있는 경우 Bundler 전에 실행되기 때문에 생성 된 binstub을 추가하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="651cf9b965cdd1ee650c11cdee3bd97dad86eb28" translate="yes" xml:space="preserve">
          <source>If you have a content security policy enabled then you can add an automatic nonce value by passing &lt;code&gt;nonce: true&lt;/code&gt; as part of &lt;code&gt;html_options&lt;/code&gt;. Example:</source>
          <target state="translated">컨텐츠 보안 정책을 사용하는 경우 &lt;code&gt;html_options&lt;/code&gt; 의 일부로 &lt;code&gt;nonce: true&lt;/code&gt; 를 전달하여 자동 nonce 값을 추가 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d0bcd96695c95db679a2cf79bacb1d734c477fd2" translate="yes" xml:space="preserve">
          <source>If you have a custom &lt;code&gt;QC::Queue&lt;/code&gt; subclass you'll need to subclass &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; and override the &lt;code&gt;build_queue&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 &lt;code&gt;QC::Queue&lt;/code&gt; 서브 클래스 가있는 경우 &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; 를 서브 클래스 하고 &lt;code&gt;build_queue&lt;/code&gt; 메소드를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9742db575a597c0715ebe3f5762a44ce4ffcebe" translate="yes" xml:space="preserve">
          <source>If you have a layout that by default is applied to all the actions of a controller, you still have the option of rendering a given action or set of actions without a layout, or restricting a layout to only a single action or a set of actions. The &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options can be passed to the layout call. For example:</source>
          <target state="translated">기본적으로 컨트롤러의 모든 작업에 적용되는 레이아웃이있는 경우 레이아웃없이 주어진 작업 또는 작업 집합을 렌더링하거나 단일 작업 또는 작업 집합으로 만 레이아웃을 제한 할 수 있습니다. . &lt;code&gt;:only&lt;/code&gt; 와 &lt;code&gt;:except&lt;/code&gt; 옵션 레이아웃 호출에 전달 될 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b93e10e3f4ae69640e52527ab8e71609f556eba" translate="yes" xml:space="preserve">
          <source>If you have a more advanced constraint, you can provide an object that responds to &lt;code&gt;matches?&lt;/code&gt; that Rails should use. Let's say you wanted to route all users on a restricted list to the &lt;code&gt;RestrictedListController&lt;/code&gt;. You could do:</source>
          <target state="translated">보다 고급 제약 조건이있는 경우 &lt;code&gt;matches?&lt;/code&gt; 하는 항목에 응답 할 수 있습니까? Rails가 사용해야합니다. 제한된 목록의 모든 사용자를 &lt;code&gt;RestrictedListController&lt;/code&gt; 로 라우팅한다고 가정 해 봅시다 . 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a560f192ee8ec9a1a15928b0663a0c5d7fd22fe7" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;</source>
          <target state="translated">모델과 관련된 스트림이있는 경우 모델 및 채널에서 사용 된 브로드 캐스트를 생성 할 수 있습니다. 다음 예제는 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 과 같은 브로드 캐스트를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="f173c059eba767e3af7bbb4a57f0feb244fb4cf2" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;.</source>
          <target state="translated">모델과 관련된 스트림이있는 경우 모델 및 채널에서 사용 된 브로드 캐스트를 생성 할 수 있습니다. 다음 예제는 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 와 같은 브로드 캐스트를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="ace6b01aac78a93246d7e4a98a5362a0be559c03" translate="yes" xml:space="preserve">
          <source>If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object, then specify the name of that attribute using this method and it will be handled automatically. The serialization is done through YAML. If &lt;code&gt;class_name&lt;/code&gt; is specified, the serialized object must be of that class on assignment and retrieval. Otherwise &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt; will be raised.</source>
          <target state="translated">데이터베이스에 오브젝트로 저장해야하고 동일한 오브젝트로 검색해야하는 속성이있는 경우이 메소드를 사용하여 해당 속성의 이름을 지정하면 자동으로 처리됩니다. 직렬화는 YAML을 통해 수행됩니다. &lt;code&gt;class_name&lt;/code&gt; 이 지정된 경우 직렬화 오브젝트는 지정 및 검색시 해당 클래스에 속해야합니다. 그렇지 않으면 &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fe32855d22ec254cf4b801e56944535a321053f" translate="yes" xml:space="preserve">
          <source>If you have an empty &lt;code&gt;config/database.yml&lt;/code&gt; file but your &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; is present, then Rails will connect to the database via your environment variable:</source>
          <target state="translated">빈 &lt;code&gt;config/database.yml&lt;/code&gt; 파일이 있지만 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 있으면 Rails는 환경 변수를 통해 데이터베이스에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b434262d0e0d30d972cd53659122043c19c68e57" translate="yes" xml:space="preserve">
          <source>If you have an extension that should be shared by many associations, you can use a named extension module. For example:</source>
          <target state="translated">여러 연결에서 공유해야하는 확장이 있으면 명명 된 확장 모듈을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71c2997c2132b3a3c4257c66422181641082fbce" translate="yes" xml:space="preserve">
          <source>If you have an instance of a model to render into a partial, you can use a shorthand syntax:</source>
          <target state="translated">부분적으로 렌더링 할 모델 인스턴스가있는 경우 간단한 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92ab7fbd387e8e24a134b89d84155d191fe3250" translate="yes" xml:space="preserve">
          <source>If you have an instance of the &lt;code&gt;Picture&lt;/code&gt; model, you can get to its parent via &lt;code&gt;@picture.imageable&lt;/code&gt;. To make this work, you need to declare both a foreign key column and a type column in the model that declares the polymorphic interface:</source>
          <target state="translated">&lt;code&gt;Picture&lt;/code&gt; 모델 의 인스턴스가있는 경우 &lt;code&gt;@picture.imageable&lt;/code&gt; 통해 부모에게 접근 할 수 있습니다 . 이 작업을 수행하려면 모델에서 다형성 인터페이스를 선언하는 외래 키 열과 유형 열을 모두 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="749159229f0a75d73cecb02d4a0dbd7000807ff0" translate="yes" xml:space="preserve">
          <source>If you have both &lt;code&gt;config/database.yml&lt;/code&gt; and &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; set then Rails will merge the configuration together. To better understand this we must see some examples.</source>
          <target state="translated">&lt;code&gt;config/database.yml&lt;/code&gt; 과 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 모두 설정되어 있으면 Rails는 구성을 병합합니다. 이것을 더 잘 이해하려면 몇 가지 예를보아야합니다.</target>
        </trans-unit>
        <trans-unit id="c50df36a34b654a6ac8d59986b79a1a7b827d8ab" translate="yes" xml:space="preserve">
          <source>If you have created namespaced routes, &lt;code&gt;form_with&lt;/code&gt; has a nifty shorthand for that too. If your application has an admin namespace then</source>
          <target state="translated">네임 스페이스가 &lt;code&gt;form_with&lt;/code&gt; 라우트를 생성 한 경우 form_with도 그에 대한 간단한 약어입니다. 응용 프로그램에 관리 네임 스페이스가있는 경우</target>
        </trans-unit>
        <trans-unit id="dfe47051a5d0d7d1fb7c807bed417ae1e0b1f5f4" translate="yes" xml:space="preserve">
          <source>If you have images as application resources this method may conflict with their named routes. The alias &lt;code&gt;path_to_image&lt;/code&gt; is provided to avoid that. Rails uses the alias internally, and plugin authors are encouraged to do so.</source>
          <target state="translated">응용 프로그램 리소스로 이미지가있는 경우이 방법은 명명 된 경로와 충돌 할 수 있습니다. 이를 피하기 위해 &lt;code&gt;path_to_image&lt;/code&gt; 라는 별칭 이 제공됩니다. Rails는 내부적으로 별명을 사용하므로 플러그인 작성자가 권장합니다.</target>
        </trans-unit>
        <trans-unit id="bab616c672f906a24a8da6f399b21cce858459b1" translate="yes" xml:space="preserve">
          <source>If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like &quot;&amp;Atilde;&amp;frac14;&quot; appearing instead of &quot;&amp;uuml;&quot;. Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.</source>
          <target state="translated">이 영역에서 실수를 한 경우 가장 일반적인 증상은 브라우저에 물음표가있는 검은 색 다이아몬드입니다. 또 다른 일반적인 증상은 &quot;&amp;uuml;&quot;대신 &quot;&amp;Atilde;&quot;와 같은 문자입니다. Rails는 자동으로 감지하고 수정할 수있는 이러한 문제의 일반적인 원인을 완화하기 위해 여러 가지 내부 단계를 수행합니다. 그러나 UTF-8로 저장되지 않은 외부 데이터가있는 경우 때때로 Rails에서 자동으로 감지하여 수정할 수없는 이러한 종류의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9747b5dd1ba72cbbc96b487b18b280e044481aa5" translate="yes" xml:space="preserve">
          <source>If you have multiple engines that need migrations copied over, use &lt;code&gt;railties:install:migrations&lt;/code&gt; instead:</source>
          <target state="translated">마이그레이션을 복사해야하는 엔진이 여러 개인 경우 대신 &lt;code&gt;railties:install:migrations&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c03fc752a11ff911bd0015f95701be96c600a53" translate="yes" xml:space="preserve">
          <source>If you have other manifests or individual stylesheets and JavaScript files to include, you can add them to the &lt;code&gt;precompile&lt;/code&gt; array in &lt;code&gt;config/initializers/assets.rb&lt;/code&gt;:</source>
          <target state="translated">포함 할 다른 매니페스트 또는 개별 스타일 시트 및 JavaScript 파일이 있는 경우 &lt;code&gt;config/initializers/assets.rb&lt;/code&gt; 의 &lt;code&gt;precompile&lt;/code&gt; 배열에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df82c551ce18fac9bf69f0fb3e927ca6f5be0c45" translate="yes" xml:space="preserve">
          <source>If you include &lt;code&gt;ActionController::Live&lt;/code&gt; in another module that is included in your controller, then you should also extend the module with &lt;code&gt;ActiveSupport::Concern&lt;/code&gt;. Alternatively, you can use the &lt;code&gt;self.included&lt;/code&gt; hook to include &lt;code&gt;ActionController::Live&lt;/code&gt; directly to the controller once the &lt;code&gt;StreamingSupport&lt;/code&gt; is included.</source>
          <target state="translated">컨트롤러에 포함 된 다른 모듈에 &lt;code&gt;ActionController::Live&lt;/code&gt; 를 포함하는 경우 &lt;code&gt;ActiveSupport::Concern&lt;/code&gt; 모듈을 확장해야합니다 . 또는 &lt;code&gt;StreamingSupport&lt;/code&gt; 가 포함 된 후 &lt;code&gt;self.included&lt;/code&gt; 후크를 사용하여 &lt;code&gt;ActionController::Live&lt;/code&gt; 를 컨트롤러에 직접 포함 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e83fc35c3e903402fcb6715e83f3dc96c7f48074" translate="yes" xml:space="preserve">
          <source>If you look in the &lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; file (remember, yours will have a slightly different name), here's what you'll find:</source>
          <target state="translated">&lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; 파일 을 살펴보면 (이름이 약간 다름을 기억하십시오) 다음과 같은 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="790cbfe3352192c73258d08a620394606704f786" translate="yes" xml:space="preserve">
          <source>If you modify this collection please update the &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; of &lt;code&gt;permit&lt;/code&gt; above.</source>
          <target state="translated">이 컬렉션을 수정하면 위 의 &lt;code&gt;permit&lt;/code&gt; &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; 를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="bae7f8fe46e797c75db60cffb6a878be3fd20cf1" translate="yes" xml:space="preserve">
          <source>If you need a deep copy of an object, you should use &lt;code&gt;deep_dup&lt;/code&gt;. Here is an example:</source>
          <target state="translated">객체의 딥 카피가 필요한 경우 &lt;code&gt;deep_dup&lt;/code&gt; 을 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20f29ef1028dace4ea49a793644fd7a8bcc48fc5" translate="yes" xml:space="preserve">
          <source>If you need a different session storage mechanism, you can change it in an initializer:</source>
          <target state="translated">다른 세션 저장 메커니즘이 필요한 경우 이니셜 라이저에서이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080a325cf371fc82e3e04c5bccb728e7cb6b2a39" translate="yes" xml:space="preserve">
          <source>If you need other headers not listed above, you can either pass them in as part of the headers hash or use the &lt;code&gt;headers['name'] = value&lt;/code&gt; method.</source>
          <target state="translated">위에 나열되지 않은 다른 헤더가 필요한 경우 헤더 해시의 일부로 전달하거나 &lt;code&gt;headers['name'] = value&lt;/code&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ae92042dbed69362c07d535dde7b6b2ed8c402a" translate="yes" xml:space="preserve">
          <source>If you need to access the subject, from or the recipients in the view, you can do that through message object:</source>
          <target state="translated">보기에서 제목 또는 수신자에게 액세스해야하는 경우 메시지 오브젝트를 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954f1c83a910f9054d1e6e5f93f9071747a3263d" translate="yes" xml:space="preserve">
          <source>If you need to add verification to the beginning of the callback chain, use &lt;code&gt;prepend: true&lt;/code&gt;.</source>
          <target state="translated">콜백 체인의 시작 부분에 검증을 추가해야하는 경우 &lt;code&gt;prepend: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd1bbfe07dcda3b0429f966b7d198efb7a51e68" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class&lt;/a&gt;:</source>
          <target state="translated">동일한 뷰에서 동일한 클래스의 여러 인스턴스를 처리해야하는 경우 &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class&lt;/a&gt; 접두어를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf8a89605e408f1e8580b14cac896f52f258bcf7" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id&lt;/a&gt;:</source>
          <target state="translated">동일한 뷰에서 동일한 클래스의 여러 인스턴스를 처리해야하는 경우 &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id&lt;/a&gt; 접두어를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9359a7d31d917d57f842db261747f4b0f5f8fe8a" translate="yes" xml:space="preserve">
          <source>If you need to create a link from outside of controller/view context (Background jobs, Cronjobs, etc.), you can access the rails_blob_path like this:</source>
          <target state="translated">컨트롤러 /보기 컨텍스트 외부 (배경 작업, Cronjobs 등)에서 링크를 작성해야하는 경우 다음과 같이 rails_blob_path에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa817aba72a4c37421ed41ccfb1a2fc86729bda1" translate="yes" xml:space="preserve">
          <source>If you need to create routes for more than one resource, you can save a bit of typing by defining them all with a single call to &lt;code&gt;resources&lt;/code&gt;:</source>
          <target state="translated">하나 개 이상의 자원에 대한 경로를 작성해야하는 경우, 단일 호출로 그들 모두를 정의하여 입력의 비트를 저장할 수 있습니다 &lt;code&gt;resources&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="34844eee6eff2caf99e5b8e6623c0bf544ac9a15" translate="yes" xml:space="preserve">
          <source>If you need to customize any of these inflections, for example to add an acronym, please have a look at &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt;.</source>
          <target state="translated">예를 들어 약어를 추가하기 위해 이러한 변곡을 사용자 정의해야하는 경우 &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt; 를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="53d21564526c14a06fa310834e5593a9e78a326e" translate="yes" xml:space="preserve">
          <source>If you need to disconnect a given connection, you can go through the &lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections&lt;/a&gt;. You can find the connections you're looking for by searching for the identifier declared on the connection. For example:</source>
          <target state="translated">지정된 연결을 끊어야하는 경우 &lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections를&lt;/a&gt; 통해 이동할 수 있습니다 . 연결에 선언 된 식별자를 검색하여 원하는 연결을 찾을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5c9243255bc5062fcc30a7801758920f6e9c91b" translate="yes" xml:space="preserve">
          <source>If you need to do more complex things with a default scope, you can alternatively define it as a class method:</source>
          <target state="translated">기본 범위로 더 복잡한 작업을 수행해야하는 경우 클래스 방법으로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d124bcef6d2f5cc39955a8634ad8736def8c80" translate="yes" xml:space="preserve">
          <source>If you need to interact with your application models, perform database queries, and so on, your task should depend on the &lt;code&gt;environment&lt;/code&gt; task, which will load your application code.</source>
          <target state="translated">응용 프로그램 모델과 상호 작용하고 데이터베이스 쿼리 등을 수행해야하는 경우 작업은 &lt;code&gt;environment&lt;/code&gt; 작업 에 따라 달라지며 이로 인해 응용 프로그램 코드가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="75176359408a8d163e91332794d54bd48802d326" translate="yes" xml:space="preserve">
          <source>If you need to output JSON elsewhere in your HTML, you can just do something like this, as any unsafe characters (including quotation marks) will be automatically escaped for you:</source>
          <target state="translated">HTML의 다른 곳에서 JSON을 출력 해야하는 경우 안전하지 않은 문자 (따옴표 포함)가 자동으로 이스케이프되므로 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="519dd973910d9eb8ae67c8edf32bba83a663bab5" translate="yes" xml:space="preserve">
          <source>If you need to redirect on the condition of something, then be sure to add &amp;ldquo;and return&amp;rdquo; to halt execution.</source>
          <target state="translated">어떤 상황에서 방향을 재지 정해야한다면 실행을 중단하기 위해&amp;ldquo;and return&amp;rdquo;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4b83190fc0648fde07fde56ea7fac76aabe04f49" translate="yes" xml:space="preserve">
          <source>If you need to run a specific migration up or down, the &lt;code&gt;db:migrate:up&lt;/code&gt; and &lt;code&gt;db:migrate:down&lt;/code&gt; commands will do that. Just specify the appropriate version and the corresponding migration will have its &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; method invoked, for example:</source>
          <target state="translated">특정 마이그레이션을 시작 또는 종료해야하는 경우 &lt;code&gt;db:migrate:up&lt;/code&gt; 및 &lt;code&gt;db:migrate:down&lt;/code&gt; 명령이이를 수행합니다. 적절한 버전을 지정하기 만하면 해당 마이그레이션에 &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 메소드가 호출됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="7b2c971f9e6d96aca70d28e7479cb38c3f266923" translate="yes" xml:space="preserve">
          <source>If you need to send attachments with no content, you need to create an empty view for it, or add an empty body parameter like this:</source>
          <target state="translated">컨텐츠가없는 첨부 파일을 보내려면 빈 뷰를 작성하거나 다음과 같이 빈 본문 매개 변수를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="04f1c647aef975987d77057d6d4fe9c8d4b41c82" translate="yes" xml:space="preserve">
          <source>If you need to share the same extensions between many associations, you can use a named extension module.</source>
          <target state="translated">여러 연결간에 동일한 확장을 공유해야하는 경우 명명 된 확장 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba1aa5152edc7d8ae4a1d94e91395ac318fcc31" translate="yes" xml:space="preserve">
          <source>If you need to support a cloud service other than these, you will need to implement the Service. Each service extends &lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt;&lt;code&gt;ActiveStorage::Service&lt;/code&gt;&lt;/a&gt; by implementing the methods necessary to upload and download files to the cloud.</source>
          <target state="translated">이 이외의 클라우드 서비스를 지원해야하는 경우 서비스를 구현해야합니다. 각 서비스는 파일을 클라우드에 업로드 및 다운로드하는 데 필요한 방법을 구현하여 &lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt; &lt;code&gt;ActiveStorage::Service&lt;/code&gt; &lt;/a&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="2f9831e439ebeb7b38108ed6ec41e90a0ee658bb" translate="yes" xml:space="preserve">
          <source>If you need to track the progress of the file upload, you can pass a third parameter to the &lt;code&gt;DirectUpload&lt;/code&gt; constructor. During the upload, DirectUpload will call the object's &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; method. You can then bind your own progress handler on the XHR.</source>
          <target state="translated">파일 업로드 진행 상황을 추적해야하는 경우 &lt;code&gt;DirectUpload&lt;/code&gt; 생성자에 세 번째 매개 변수를 전달할 수 있습니다 . 업로드하는 동안 DirectUpload는 개체의 &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; 메서드를 호출합니다 . 그런 다음 XHR에서 자체 진행 처리기를 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9860260780994b1b9fb79388dd273a28e808c5" translate="yes" xml:space="preserve">
          <source>If you need to use a MIME type which isn't supported by default, you can register your own handlers in &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; as follows.</source>
          <target state="translated">기본적으로 지원되지 않는 MIME 유형을 사용해야하는 경우 다음과 같이 &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 에 고유 한 핸들러를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c13930cc1194c1e09ba9d62347bc7e108608cf50" translate="yes" xml:space="preserve">
          <source>If you now go to http://localhost:3000/articles/new you'll &lt;em&gt;almost&lt;/em&gt; be able to create an article. Try it! You should get an error that looks like this:</source>
          <target state="translated">이제 http : // localhost : 3000 / articles / new로 이동하면 &lt;em&gt;거의&lt;/em&gt; 기사 를 작성할 수 있습니다. 시도 해봐! 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="798968b5441f3c2daa3ad458545f1e2ddca45cb0" translate="yes" xml:space="preserve">
          <source>If you only want to see the routes that map to a specific controller, there's the -c option.</source>
          <target state="translated">특정 컨트롤러에 매핑 된 경로 만 보려면 -c 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71785e7b949dee72159074c906445c53a98687be" translate="yes" xml:space="preserve">
          <source>If you open up the newly generated &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; you'll see a fairly empty controller:</source>
          <target state="translated">새로 생성 된 &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; 를 열면 상당히 빈 컨트롤러가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="caf437c6570b9645593ea709f18577d0e37d6c8e" translate="yes" xml:space="preserve">
          <source>If you pass a Symbol as the first argument, then a corresponding cache store class under the &lt;a href=&quot;cache&quot;&gt;ActiveSupport::Cache&lt;/a&gt; namespace will be created. For example:</source>
          <target state="translated">첫 번째 인수로 Symbol을 전달하면 &lt;a href=&quot;cache&quot;&gt;ActiveSupport :: Cache&lt;/a&gt; 네임 스페이스 아래에 해당 캐시 저장소 클래스 가 작성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddfa7769dcc84943f68c46033b730ce91d513aec" translate="yes" xml:space="preserve">
          <source>If you pass a single integer, returns a substring of one character at that position. The first character of the string is at position 0, the next at position 1, and so on. If a range is supplied, a substring containing characters at offsets given by the range is returned. In both cases, if an offset is negative, it is counted from the end of the string. Returns &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string. Returns an empty string if the beginning of the range is greater than the end of the string.</source>
          <target state="translated">단일 정수를 전달하면 해당 위치에서 한 문자의 하위 문자열을 반환합니다. 문자열의 첫 번째 문자는 위치 0에 있고 다음 문자는 위치 1에 있습니다. 범위가 제공되면 범위에 의해 지정된 오프셋에 문자가 포함 된 하위 문자열이 반환됩니다. 두 경우 모두 오프셋이 음수이면 문자열 끝부터 계산됩니다. 초기 오프셋이 문자열을 벗어나면 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다. 범위의 시작이 문자열의 끝보다 큰 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="632b8d8ffb1decfb5d4c8badbac89dd3e00fd7a9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;, please refer to the class version of this method for more information.</source>
          <target state="translated">추가 구성 옵션을 전달하면 클래스로 전달되어 &lt;code&gt;options&lt;/code&gt; 사용할 수 있습니다 . 자세한 정보는이 메소드의 클래스 버전을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="682ace517c959a77a771d42d6d9eac363da111c9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;:</source>
          <target state="translated">추가 구성 옵션을 전달하면 클래스에 전달되고 &lt;code&gt;options&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b6ba8e3114a56aad325e9b14a29ecad96dca5d8" translate="yes" xml:space="preserve">
          <source>If you pass arguments to &amp;ldquo;yield&amp;rdquo; then this will be passed to the block. One way to use this is to pass an array to layout and treat it as an enumerable.</source>
          <target state="translated">인수를 &quot;yield&quot;에 전달하면 블록으로 전달됩니다. 이것을 사용하는 한 가지 방법은 배열을 레이아웃에 전달하고 열거 가능한 것으로 취급하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f17ab7779351ab1a6884b258f583eb53ffb5b44d" translate="yes" xml:space="preserve">
          <source>If you pass the conditions via hash, you don't need to call &lt;a href=&quot;querymethods#method-i-references&quot;&gt;references&lt;/a&gt; explicitly, as &lt;a href=&quot;querymethods#method-i-where&quot;&gt;where&lt;/a&gt; references the tables for you. For example, this will work correctly:</source>
          <target state="translated">해시를 통해 조건을 전달하는 경우 테이블을 참조하는 &lt;a href=&quot;querymethods#method-i-where&quot;&gt;위치를&lt;/a&gt; 명시 적으로 &lt;a href=&quot;querymethods#method-i-references&quot;&gt;참조&lt;/a&gt; 할 필요가 없습니다 . 예를 들어, 이것은 올바르게 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="3b7db4311465b5c467ecad29ee1f4f9d15f4656a" translate="yes" xml:space="preserve">
          <source>If you prefer logging to a file, configure this instead:</source>
          <target state="translated">파일에 로깅하려는 경우 대신 다음을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="215c252f0c89788189f24e2d9043c91a50b33007" translate="yes" xml:space="preserve">
          <source>If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded parallelizer is backed by Minitest's &lt;code&gt;Parallel::Executor&lt;/code&gt;.</source>
          <target state="translated">스레드를 선호하거나 JRuby를 사용하는 경우 스레드 병렬화 옵션이 제공됩니다. 스레드 병렬 처리기는 Minitest의 &lt;code&gt;Parallel::Executor&lt;/code&gt; 의해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="eafe8299d3fe7769815c71c88d087079dcd317d2" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use a symbol instead of a string to specify the action to render:</source>
          <target state="translated">원하는 경우 문자열 대신 기호를 사용하여 렌더링 할 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d10e2bda23cd78a6360473103ead5548519dcba" translate="yes" xml:space="preserve">
          <source>If you preload your test database with all fixture data (probably by running `rails db:fixtures:load`) and use transactional tests, then you may omit all fixtures declarations in your test cases since all the data's already there and every case rolls back its changes.</source>
          <target state="translated">만약 모든 데이터베이스에 모든 조명기 데이터를 미리로드하고 (아마도 rails db : fixtures : load를 실행하여) 트랜잭션 테스트를 사용한다면, 모든 데이터가 이미 존재하고 모든 케이스가 롤백되기 때문에 테스트 케이스에서 모든 조명기 선언을 생략 할 수 있습니다 그 변화.</target>
        </trans-unit>
        <trans-unit id="032b750ddc0f2a68782ec3a07a6c02fa0912464e" translate="yes" xml:space="preserve">
          <source>If you re-submit the form now, you may not see any change on the page. Don't worry! This is because Rails by default returns &lt;code&gt;204 No Content&lt;/code&gt; response for an action if we don't specify what the response should be. We just added the &lt;code&gt;create&lt;/code&gt; action but didn't specify anything about how the response should be. In this case, the &lt;code&gt;create&lt;/code&gt; action should save our new article to the database.</source>
          <target state="translated">지금 양식을 다시 제출하면 페이지에 변경 사항이 표시되지 않을 수 있습니다. 걱정 마세요! 응답이 무엇인지 지정하지 않으면 Rails는 기본적으로 액션에 대해 &lt;code&gt;204 No Content&lt;/code&gt; 응답을 반환하기 때문 입니다. 방금 &lt;code&gt;create&lt;/code&gt; action을 추가 했지만 응답 방법에 대해서는 아무것도 지정하지 않았습니다. 이 경우, &lt;code&gt;create&lt;/code&gt; 조치는 새 기사를 데이터베이스에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a3ba760f2039016218b42a07ffd0719e51d2c95" translate="yes" xml:space="preserve">
          <source>If you re-submit the form one more time, you'll see something that looks like the following:</source>
          <target state="translated">양식을 한 번 더 다시 제출하면 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cb608c0020eca0be434d098953cdecfbe1c340" translate="yes" xml:space="preserve">
          <source>If you refresh http://localhost:3000/articles/new now, you'll get a new error:</source>
          <target state="translated">http : // localhost : 3000 / articles / new를 새로 고치면 새로운 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62810ba4faad6de0e07c448d86b162e6adf194c5" translate="yes" xml:space="preserve">
          <source>If you refresh the page now, you'll see the exact same form from our example above. Building forms in Rails is really just that easy!</source>
          <target state="translated">지금 페이지를 새로 고치면 위의 예와 정확히 동일한 양식이 표시됩니다. Rails에서 양식을 작성하는 것은 정말 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d168564efe905e950a12a0bbe8fa883b06949143" translate="yes" xml:space="preserve">
          <source>If you reload http://localhost:3000/articles/new and try to save an article without a title, Rails will send you back to the form, but that's not very useful. You need to tell the user that something went wrong. To do that, you'll modify &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; to check for error messages:</source>
          <target state="translated">http : // localhost : 3000 / articles / new를 다시로드하고 제목없이 기사를 저장하려고하면 Rails에서 양식으로 다시 보내지 만 유용하지는 않습니다. 사용자에게 무언가 잘못되었다고 알려 주어야합니다. 이를 위해 &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; 를 수정 하여 오류 메시지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc2177084e8c394a6a53d12cfdefd8100d07b30" translate="yes" xml:space="preserve">
          <source>If you remember from earlier, one of the Three Hashes of the Apocalypse was &lt;code&gt;flash&lt;/code&gt;.</source>
          <target state="translated">당신이 이전부터 기억한다면, 묵시록의 세 가지 해시 중 하나가 &lt;code&gt;flash&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="6dbac9c281a00497859f5bd21c6d9e0516606801" translate="yes" xml:space="preserve">
          <source>If you remember, we used the &lt;code&gt;rails generate model&lt;/code&gt; command in the &lt;a href=&quot;getting_started&quot;&gt;Getting Started with Rails&lt;/a&gt; guide. We created our first model, and among other things it created test stubs in the &lt;code&gt;test&lt;/code&gt; directory:</source>
          <target state="translated">기억 나는 경우, &lt;a href=&quot;getting_started&quot;&gt;Rails 시작하기&lt;/a&gt; 안내서 에서 &lt;code&gt;rails generate model&lt;/code&gt; 명령을 사용했습니다. 우리는 첫 번째 모델을 만들었고 무엇보다도 &lt;code&gt;test&lt;/code&gt; 디렉토리 에 테스트 스텁을 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="66a7e4fff5ec93b09b720d5b6a8599b8fb7d7ff2" translate="yes" xml:space="preserve">
          <source>If you repeatedly invoke application code from a long-running process, you may want to wrap using the Reloader instead.</source>
          <target state="translated">장기 실행 프로세스에서 애플리케이션 코드를 반복해서 호출하는 경우 대신 리 로더를 사용하여 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a1fd5aef7d3248f2da5139cc60b8c9d29b34d" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by 5.1 and older, or you are still validating your 5.2 deploy and want to allow you to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5.1 이상에서 쿠키를 읽거나 5.2 배포의 유효성을 검사하고 &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 롤백하도록 허용하려는 경우 쿠키를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1dfadda751bf13743cb353e426d145dc9b175a37" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by Rails 5.2 and older, or you are still validating your 6.0 deploy and want to be able to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Rails 5.2 이전 버전에서 쿠키를 읽거나 6.0 배포를 계속 검증하고 &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 롤백 할 수 있도록하려는 경우 .</target>
        </trans-unit>
        <trans-unit id="9fc71a9c4e127e7236f9ac5863d445bd51714d2b" translate="yes" xml:space="preserve">
          <source>If you reuse this frequently you could define a &lt;code&gt;labeled_form_with&lt;/code&gt; helper that automatically applies the &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; option:</source>
          <target state="translated">이것을 자주 재사용 하면 &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; 를 자동으로 적용 하는 &lt;code&gt;labeled_form_with&lt;/code&gt; 헬퍼를 정의 할 수 있습니다 . LabellingFormBuilder 옵션 :</target>
        </trans-unit>
        <trans-unit id="6cbb87cb4a5f9fbd29ad857e361eaf0f387942e5" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;rails routes&lt;/code&gt;, you'll see that it has defined routes for all the standard RESTful actions. The meaning of the prefix column (and other columns) will be seen later, but for now notice that Rails has inferred the singular form &lt;code&gt;article&lt;/code&gt; and makes meaningful use of the distinction.</source>
          <target state="translated">&lt;code&gt;rails routes&lt;/code&gt; 를 실행 하면 모든 표준 RESTful 작업에 대한 경로가 정의 된 것을 볼 수 있습니다. 접두사 열 (및 다른 열)의 의미는 나중에 볼 수 있지만 지금은 Rails가 단수 형태의 &lt;code&gt;article&lt;/code&gt; 유추 하여 구별을 의미있게 사용 한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5736fbb209b1e7176278dc85bda1088c0f60271" translate="yes" xml:space="preserve">
          <source>If you run the &lt;code&gt;rails db:migrate:status&lt;/code&gt; command, which displays the status (up or down) of each migration, you should see &lt;code&gt;********** NO FILE **********&lt;/code&gt; displayed next to any deleted migration file which was once executed on a specific environment but can no longer be found in the &lt;code&gt;db/migrate/&lt;/code&gt; directory.</source>
          <target state="translated">각 마이그레이션의 상태 (위 또는 아래)를 표시 하는 &lt;code&gt;rails db:migrate:status&lt;/code&gt; 명령 을 실행하면 &lt;code&gt;********** NO FILE **********&lt;/code&gt; 특정 환경에서 한 번 실행되었지만 더 이상 &lt;code&gt;db/migrate/&lt;/code&gt; 디렉토리 에서 찾을 수없는 삭제 된 마이그레이션 파일 옆에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ddac9227d2dba8d69bc55abee86ae1f7389613d" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;:only_integer&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, then it will use the</source>
          <target state="translated">&lt;code&gt;:only_integer&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면</target>
        </trans-unit>
        <trans-unit id="1a740b969cec9b8b5c9b7bf367c39be063ba9913" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;config.time_zone&lt;/code&gt; in the Rails Application, you can access this &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; object via &lt;code&gt;Time.zone&lt;/code&gt;:</source>
          <target state="translated">Rails 애플리케이션에서 &lt;code&gt;config.time_zone&lt;/code&gt; 을 설정 하면 &lt;code&gt;Time.zone&lt;/code&gt; 을 통해이 &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; 객체에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e982780a9d946f64c4d7b6f259ce4892a834ec57" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:autosave&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting &lt;code&gt;:autosave&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; is not the same as not setting the &lt;code&gt;:autosave&lt;/code&gt; option. If the &lt;code&gt;:autosave&lt;/code&gt; option is not present, then new associated objects will be saved, but updated associated objects will not be saved.</source>
          <target state="translated">&lt;code&gt;:autosave&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Rails는로드 된 연관 멤버를 저장하고 부모 오브젝트를 저장할 때마다 소멸로 표시된 멤버를 삭제합니다. 설정 &lt;code&gt;:autosave&lt;/code&gt; 에 &lt;code&gt;false&lt;/code&gt; 를 설정하지 않는 것과 동일하지 않습니다 &lt;code&gt;:autosave&lt;/code&gt; 옵션을 선택합니다. 는 IF &lt;code&gt;:autosave&lt;/code&gt; 옵션이 존재하지 않는 한 다음 새 연결 개체가 저장되지만 업데이트 관련 개체가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5ac83c1930890185af66324fd705be52e7e44d4" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:dependent&lt;/code&gt; option to:</source>
          <target state="translated">&lt;code&gt;:dependent&lt;/code&gt; 옵션을 다음 과 같이 설정 한 경우 :</target>
        </trans-unit>
        <trans-unit id="12dcf0f411660275e0f33063283ddd8270d49a00" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:optional&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the presence of the associated object won't be validated. By default, this option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:optional&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 연결된 객체의 존재가 확인되지 않습니다. 기본적으로이 옵션은 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54ae2ad12dfc24f090d30428ebf9feaf86d69cf" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:touch&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the &lt;code&gt;updated_at&lt;/code&gt; or &lt;code&gt;updated_on&lt;/code&gt; timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:</source>
          <target state="translated">당신이 설정 한 경우 &lt;code&gt;:touch&lt;/code&gt; 에 옵션이 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;updated_at&lt;/code&gt; 또는 &lt;code&gt;updated_on&lt;/code&gt; 관련 개체에 대한 타임 스탬프는이 객체가 저장되거나 파괴 될 때마다 현재 시간으로 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="38743afae7adfc5e0e587df5c7c10a6c0f8b74a9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;, then associated objects will not be validated whenever you save this object. By default, this is &lt;code&gt;true&lt;/code&gt;: associated objects will be validated when this object is saved.</source>
          <target state="translated">&lt;code&gt;:validate&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면이 객체를 저장할 때마다 연결된 객체의 유효성이 검사되지 않습니다. 기본적으로이 값은 &lt;code&gt;true&lt;/code&gt; 입니다 .이 개체를 저장하면 연결된 개체의 유효성이 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="bb46c33993d0c4a869b2ee45c2a47a55c32ff3a1" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then associated objects will be validated whenever you save this object. By default, this is &lt;code&gt;false&lt;/code&gt;: associated objects will not be validated when this object is saved.</source>
          <target state="translated">&lt;code&gt;:validate&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면이 객체를 저장할 때마다 연결된 객체의 유효성이 검사됩니다. 기본적으로이 값은 &lt;code&gt;false&lt;/code&gt; 입니다 .이 개체를 저장할 때 연결된 개체의 유효성이 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dacf4eb6331a59ac9520410f480184f687ec5233" translate="yes" xml:space="preserve">
          <source>If you simply want to check for the existence of the object there's a method called &lt;code&gt;exists?&lt;/code&gt;. This method will query the database using the same query as &lt;code&gt;find&lt;/code&gt;, but instead of returning an object or collection of objects it will return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">단순히 객체의 존재를 확인하고 싶다면 exist라는 메소드 &lt;code&gt;exists?&lt;/code&gt; . 이 메소드는 &lt;code&gt;find&lt;/code&gt; 와 동일한 쿼리를 사용하여 데이터베이스를 쿼리 하지만 개체 또는 개체 컬렉션을 반환하는 대신 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67bc3cb65d8184980d212dfd9e822bfdf8b287bc" translate="yes" xml:space="preserve">
          <source>If you specify a Rack application as the endpoint for a matcher, remember that the route will be unchanged in the receiving application. With the following route your Rack application should expect the route to be &lt;code&gt;/admin&lt;/code&gt;:</source>
          <target state="translated">랙 애플리케이션을 매처의 엔드 포인트로 지정하면 수신 애플리케이션에서 라우트가 변경되지 않습니다. 다음 경로를 사용하면 랙 응용 프로그램에서 경로가 &lt;code&gt;/admin&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1008a7039ea28960d769ea99f1ff1f8c59392671" translate="yes" xml:space="preserve">
          <source>If you specify a target version, Active Record will run the required migrations (change, up, down) until it has reached the specified version. The version is the numerical prefix on the migration's filename. For example, to migrate to version 20080906120000 run:</source>
          <target state="translated">대상 버전을 지정하면 Active Record는 지정된 버전에 도달 할 때까지 필요한 마이그레이션 (변경, 위, 아래)을 실행합니다. 버전은 마이그레이션 파일 이름의 숫자 접두사입니다. 예를 들어, 20080906120000 버전으로 마이그레이션하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f651ca4d5d892c8edafc644e3e3a8fd8f269046b" translate="yes" xml:space="preserve">
          <source>If you specify an encoding, Mail will assume that your content is already encoded and not try to Base64 encode it.</source>
          <target state="translated">인코딩을 지정하면 Mail은 내용이 이미 인코딩 된 것으로 가정하고 Base64 인코딩을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9126865264c6be1e7027d977582109ed0bb142af" translate="yes" xml:space="preserve">
          <source>If you specify your own &lt;code&gt;select&lt;/code&gt;, be sure to include the primary key and foreign key columns of the associated model. If you do not, Rails will throw an error.</source>
          <target state="translated">고유 한 &lt;code&gt;select&lt;/code&gt; 를 지정하는 경우 연관된 모델의 기본 키 및 외래 키 열을 포함해야합니다. 그렇지 않으면 Rails에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f16426fc6e7323d088a689b6ea243d576d56117e" translate="yes" xml:space="preserve">
          <source>If you stop the &lt;code&gt;ajax:aborted:file&lt;/code&gt; event, the default behavior of allowing the browser to submit the form via normal means (i.e. non-Ajax submission) will be canceled and the form will not be submitted at all. This is useful for implementing your own Ajax file upload workaround.</source>
          <target state="translated">당신이 중지하면 &lt;code&gt;ajax:aborted:file&lt;/code&gt; 이벤트를 정상적인 수단을 통해 양식을 제출 브라우저를 허용하는 기본 동작 (즉, 비 아약스 제출)이 취소되고 양식이 전혀 제출되지 않습니다. 이는 고유 한 Ajax 파일 업로드 해결 방법을 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="51f455c5e6976e35adebd807b27c3342f5873d91" translate="yes" xml:space="preserve">
          <source>If you submit the form again now, Rails will complain about not finding the &lt;code&gt;show&lt;/code&gt; action. That's not very useful though, so let's add the &lt;code&gt;show&lt;/code&gt; action before proceeding.</source>
          <target state="translated">지금 양식을 다시 제출하면 Rails는 &lt;code&gt;show&lt;/code&gt; 조치를 찾지 못하는 것에 대해 불평 합니다. 그다지 유용하지는 않으므로 진행하기 전에 &lt;code&gt;show&lt;/code&gt; 액션을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="68a6679b4edb22f06a2c4bad7125b30641e15742" translate="yes" xml:space="preserve">
          <source>If you then restart the application and re-trigger the deadlock condition, &lt;code&gt;/rails/locks&lt;/code&gt; will show a summary of all threads currently known to the interlock, which lock level they are holding or awaiting, and their current backtrace.</source>
          <target state="translated">그런 다음 응용 프로그램을 다시 시작하고 교착 상태를 다시 트리거하면 &lt;code&gt;/rails/locks&lt;/code&gt; 는 현재 인터록에 알려진 모든 스레드, 보유 또는 대기중인 잠금 레벨 및 현재 역 추적에 대한 요약을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="45dc06c18ada78f9291ac8e05d04201fde995ce7" translate="yes" xml:space="preserve">
          <source>If you try out this command in a Rails console, you would see that this loads &lt;code&gt;railties/exe/rails&lt;/code&gt;. A part of the file &lt;code&gt;railties/exe/rails&lt;/code&gt; has the following code:</source>
          <target state="translated">Rails 콘솔에서이 명령을 시도하면 &lt;code&gt;railties/exe/rails&lt;/code&gt; 가로드 되는 것을 볼 수 있습니다. 파일 &lt;code&gt;railties/exe/rails&lt;/code&gt; 의 일부 에는 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c7739665b35931a331b95459613cd91721f606b" translate="yes" xml:space="preserve">
          <source>If you try running &lt;code&gt;test_should_create_article&lt;/code&gt; test from &lt;code&gt;articles_controller_test.rb&lt;/code&gt; it will fail on account of the newly added model level validation and rightly so.</source>
          <target state="translated">&lt;code&gt;articles_controller_test.rb&lt;/code&gt; 에서 &lt;code&gt;test_should_create_article&lt;/code&gt; 테스트를 실행하려고 하면 새로 추가 된 모델 레벨 유효성 검사로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="69aa3078e7ba43546bbdbcbcd41e3c86b7e26fa6" translate="yes" xml:space="preserve">
          <source>If you try to define a set of Rake tasks on the instance, these will get passed up to the Rake tasks defined on the application's class.</source>
          <target state="translated">인스턴스에서 일련의 Rake 작업을 정의하려고하면 응용 프로그램 클래스에 정의 된 Rake 작업으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="43891496e6b3634d5b07b0b4f3b41b7a66741e77" translate="yes" xml:space="preserve">
          <source>If you try to render content along with a non-content status code (100-199, 204, 205, or 304), it will be dropped from the response.</source>
          <target state="translated">컨텐츠가 아닌 상태 코드 (100-199, 204, 205 또는 304)와 함께 컨텐츠를 렌더링하려고하면 응답에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd0daa65aa7e1a3f3cac1e33634eb83b028b95e" translate="yes" xml:space="preserve">
          <source>If you try to use more connections than are available, Active Record will block you and wait for a connection from the pool. If it cannot get a connection, a timeout error similar to that given below will be thrown.</source>
          <target state="translated">사용 가능한 것보다 많은 연결을 사용하려고하면 Active Record가 사용자를 차단하고 풀에서 연결을 기다립니다. 연결이되지 않으면 아래와 같은 시간 초과 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="860e16f3811842974bde3c3a9af5e24519a3b933" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;readonly&lt;/code&gt;, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 를 사용 하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="b2fff0660301739a755c59746d1897254d0051f8" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt; option, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; or &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; will create books where the confirmed column has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">해시 스타일 &lt;code&gt;where&lt;/code&gt; 옵션 을 사용하는 경우이 연관을 통한 레코드 작성은 해시를 사용하여 자동으로 범위가 지정됩니다. 이 경우 &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; 또는 &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; 를 사용하면 확인 된 열의 값이 &lt;code&gt;true&lt;/code&gt; 인 책을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5dd83d9db514a7dbdd4c85fbd0f778c62753c3a1" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt;, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@parts.assemblies.create&lt;/code&gt; or &lt;code&gt;@parts.assemblies.build&lt;/code&gt; will create orders where the &lt;code&gt;factory&lt;/code&gt; column has the value &quot;Seattle&quot;.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 해시 스타일을 사용하는 경우이 연결을 통한 레코드 작성은 해시를 사용하여 자동으로 범위가 지정됩니다. 이 경우 &lt;code&gt;@parts.assemblies.create&lt;/code&gt; 또는 &lt;code&gt;@parts.assemblies.build&lt;/code&gt; 를 사용하면 &lt;code&gt;factory&lt;/code&gt; 열의 값이 &quot;Seattle&quot;인 주문이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff0906b2865b4b40c9406d2045692447a90d6ec8" translate="yes" xml:space="preserve">
          <source>If you use a helper method, for example, inside a cached block and you then update that helper, you'll have to bump the cache as well. It doesn't really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:</source>
          <target state="translated">예를 들어 캐시 된 블록 내부에서 도우미 메서드를 사용하고 해당 도우미를 업데이트하는 경우 캐시도 충돌해야합니다. 실제로 어떻게 수행하든 중요하지 않지만 템플릿 파일의 MD5는 변경되어야합니다. 한 가지 권장 사항은 다음과 같이 주석에 명시 적으로 명시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7278a05bf1f7032406ce8df1e82fa5cb69d391c" translate="yes" xml:space="preserve">
          <source>If you use a module, for instance Weblog::PostsController, you will need a template named &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt;.</source>
          <target state="translated">Weblog :: PostsController와 같은 모듈을 사용하는 경우 &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt; 라는 템플릿이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce5a47f8e7e2a9b04c86ebb4fd66b97d7210e50" translate="yes" xml:space="preserve">
          <source>If you use a schema cache and multiple databases you'll need to write an initializer that loads the schema cache from your app. This wasn't an issue we could resolve in time for Rails 6.0 but hope to have it in a future version soon.</source>
          <target state="translated">스키마 캐시와 여러 데이터베이스를 사용하는 경우 앱에서 스키마 캐시를로드하는 이니셜 라이저를 작성해야합니다. 이것은 우리가 Rails 6.0을 위해 제 시간에 해결할 수있는 문제가 아니었지만 곧 차기 버전에서이를 희망하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe42d6b14f3e476da63fc938a5753e0e1a72642" translate="yes" xml:space="preserve">
          <source>If you use multiple &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt; declarations in your model then they will be merged together:</source>
          <target state="translated">모델에서 여러 &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt; 선언 을 사용하면 함께 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="80c97ff655888952411fdd288b4e6d761401568a" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor plugin&lt;/a&gt;, or actions that return a string, rather than rendering a view, &lt;em&gt;you have to escape the return value in the action&lt;/em&gt;. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.</source>
          <target state="translated">&lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor 플러그인&lt;/a&gt; 또는 뷰를 렌더링하지 않고 문자열을 리턴하는 조치 를 사용하는 경우 &lt;em&gt;action에서 리턴 값을 이스케이프해야합니다&lt;/em&gt; . 그렇지 않으면 반환 값에 XSS 문자열이 포함되어 있으면 악성 코드가 브라우저로 돌아올 때 실행됩니다. h () 메소드를 사용하여 입력 값을 이스케이프하십시오.</target>
        </trans-unit>
        <trans-unit id="42b21ecf5693ca022b4b65f0e8a6a7b79b4dcdcd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 메소드 를 사용하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="13fd547389407f2aa534f580945dfbb93b81209d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated objects will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 메소드 를 사용하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e4b4313b28e5174a5005ef4a1de6683090bde533" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;select&lt;/code&gt; method on a &lt;code&gt;belongs_to&lt;/code&gt; association, you should also set the &lt;code&gt;:foreign_key&lt;/code&gt; option to guarantee the correct results.</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 연관 에서 &lt;code&gt;select&lt;/code&gt; 메소드 를 사용하는 경우 , 올바른 결과를 보장하기 위해 &lt;code&gt;:foreign_key&lt;/code&gt; 옵션 도 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2957357fa844d5aa40521acffe133afd9ad46862" translate="yes" xml:space="preserve">
          <source>If you use the cookie session store, this would apply to the &lt;code&gt;session&lt;/code&gt; and &lt;code&gt;flash&lt;/code&gt; hash as well.</source>
          <target state="translated">쿠키 세션 저장소를 사용하는 경우 이는 &lt;code&gt;session&lt;/code&gt; 및 &lt;code&gt;flash&lt;/code&gt; 해시 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba2e5aabecb68374b1079b50a06d15a4d4a23aff" translate="yes" xml:space="preserve">
          <source>If you use the popular &lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem for user management, it will automatically expire sessions on sign in and sign out for you. If you roll your own, remember to expire the session after your sign in action (when the session is created). This will remove values from the session, therefore &lt;em&gt;you will have to transfer them to the new session&lt;/em&gt;.</source>
          <target state="translated">사용자 관리에 인기있는 &lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem을 사용하는 경우 로그인시 자동으로 세션이 만료되고 로그 아웃됩니다. 직접 롤백하는 경우 로그인 동작 후 (세션이 생성 될 때) 세션을 만료해야합니다. 세션에서 값이 제거되므로 &lt;em&gt;새 세션으로&lt;/em&gt; 값 &lt;em&gt;을 전송해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b260b5b45736153fb5e856c84240bdfdc7061b3c" translate="yes" xml:space="preserve">
          <source>If you used the scaffold generator, a system test skeleton was automatically created for you. If you didn't use the scaffold generator, start by creating a system test skeleton.</source>
          <target state="translated">스캐 폴드 생성기를 사용한 경우 시스템 테스트 스켈레톤이 자동으로 생성됩니다. 스캐 폴드 생성기를 사용하지 않은 경우 먼저 시스템 테스트 스켈레톤을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8186ba98e8144b29de8b3fe8b6e0a06a9a6ed8eb" translate="yes" xml:space="preserve">
          <source>If you validate the absence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;present?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 관계 를 통해 연결된 개체 가 없는지 확인하면 개체가 없는지 확인 &lt;code&gt;present?&lt;/code&gt; 도 &lt;code&gt;marked_for_destruction?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7fa8dd05040adec975ca62bfc25061e785c7df" translate="yes" xml:space="preserve">
          <source>If you validate the presence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;blank?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 관계 를 통해 연결된 개체의 존재를 확인하면 개체가 &lt;code&gt;blank?&lt;/code&gt; 있지 않은지 확인합니다 . 도 &lt;code&gt;marked_for_destruction?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8675fa9dbdfda79f0d9e088a9370acf6f7785f3" translate="yes" xml:space="preserve">
          <source>If you want Active Record to not output anything, then running &lt;code&gt;rails db:migrate
VERBOSE=false&lt;/code&gt; will suppress all output.</source>
          <target state="translated">Active Record가 아무 것도 출력하지 않게하려면 &lt;code&gt;rails db:migrate VERBOSE=false&lt;/code&gt; 를 실행 하면 모든 출력이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="5f8328e4e201b7e1606e4bfef13b41ffeba2bde1" translate="yes" xml:space="preserve">
          <source>If you want a flash value to be carried over to another request, use the &lt;code&gt;keep&lt;/code&gt; method:</source>
          <target state="translated">플래시 값을 다른 요청으로 전달하려면 &lt;code&gt;keep&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="630fe8293b9d46b8c896fddf7673500c6efe7a60" translate="yes" xml:space="preserve">
          <source>If you want a gem to behave as an engine, you have to specify an &lt;code&gt;Engine&lt;/code&gt; for it somewhere inside your plugin's &lt;code&gt;lib&lt;/code&gt; folder (similar to how we specify a &lt;code&gt;Railtie&lt;/code&gt;):</source>
          <target state="translated">gem이 엔진처럼 동작하게하려면 플러그인의 &lt;code&gt;lib&lt;/code&gt; 폴더 안에 &lt;code&gt;Engine&lt;/code&gt; 을 지정해야합니다 ( &lt;code&gt;Railtie&lt;/code&gt; 지정 방법과 유사 ).</target>
        </trans-unit>
        <trans-unit id="aee38d59683e989a0bb0adbb29c2bd0c92f4d9ee" translate="yes" xml:space="preserve">
          <source>If you want an exception to be raised when some key is blank, use the bang version:</source>
          <target state="translated">일부 키가 비어있을 때 예외를 발생 시키려면 bang 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="26e3876b177bb4a765333ca5c28aca58d164c1eb" translate="yes" xml:space="preserve">
          <source>If you want just MIME type, please use &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; instead.</source>
          <target state="translated">MIME 유형 만 원하면 &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="730767bfa8f160596399009706fb4cf9a0a1f899" translate="yes" xml:space="preserve">
          <source>If you want more control on what queue a job will be run you can pass a &lt;code&gt;:queue&lt;/code&gt; option to &lt;code&gt;#set&lt;/code&gt;:</source>
          <target state="translated">작업이 실행될 큐를 더 제어하려면 &lt;code&gt;:queue&lt;/code&gt; 옵션을 &lt;code&gt;#set&lt;/code&gt; 에 전달하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdfd062178bdf53433d9b2b0b20c92f631bd29ca" translate="yes" xml:space="preserve">
          <source>If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:</source>
          <target state="translated">유연성을 높이려면 블록을 전달하고 템플릿을 사용하지 않고 특정 템플릿을 렌더링하거나 인라인 또는 텍스트를 렌더링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb075b036e1a4a68f429c4ff5cc6a6fc5e17d254" translate="yes" xml:space="preserve">
          <source>If you want to add check constraints like in the examples above, you will have to use &lt;code&gt;structure.sql&lt;/code&gt; as dump method. See &lt;a href=&quot;#schema-dumping-and-you&quot;&gt;Schema Dumping and You&lt;/a&gt;.</source>
          <target state="translated">위의 예제와 같이 검사 제한 조건을 추가하려면 &lt;code&gt;structure.sql&lt;/code&gt; 을 덤프 메소드 로 사용해야 합니다. &lt;a href=&quot;#schema-dumping-and-you&quot;&gt;스키마 덤프 및 사용자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6819ae67fca06a336a7c220cddca705251c5bd7" translate="yes" xml:space="preserve">
          <source>If you want to add string conditions to your included models, you'll have to explicitly reference them. For example:</source>
          <target state="translated">포함 된 모델에 문자열 조건을 추가하려면 명시 적으로 참조해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcdf79631da776965ca916863b0814010876d14b" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">오브젝트를 저장하지 않고 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관에 오브젝트를 지정 하려면 &lt;code&gt;collection.build&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="049e99eb928b4643b8ed72ec399f9776d18df912" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">객체를 저장하지 않고 &lt;code&gt;has_many&lt;/code&gt; 연관에 객체를 지정 하려면 &lt;code&gt;collection.build&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="881b0e238763be506a07bc64b13764f8fc1d30bc" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_one&lt;/code&gt; association without saving the object, use the &lt;code&gt;build_association&lt;/code&gt; method.</source>
          <target state="translated">오브젝트를 저장하지 않고 &lt;code&gt;has_one&lt;/code&gt; 연관에 오브젝트를 지정 하려면 &lt;code&gt;build_association&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e4507250cc520d9ef9f615ef6bd7149e330d17" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is absent, you'll need to test whether the associated object itself is absent, and not the foreign key used to map the association.</source>
          <target state="translated">연결이 없는지 확인하려면 연결을 매핑하는 데 사용되는 외래 키가 아니라 관련 개체 자체가 없는지 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e06a09ea7f3496b2601d56d74f968ca41431796" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is present, you'll need to test whether the associated object itself is present, and not the foreign key used to map the association. This way, it is not only checked that the foreign key is not empty but also that the referenced object exists.</source>
          <target state="translated">연관이 있는지 확인하려면 연관을 맵핑하는 데 사용되는 외래 키가 아니라 연관된 오브젝트 자체가 존재하는지 테스트해야합니다. 이런 식으로 외래 키가 비어 있지 않은지뿐만 아니라 참조 된 개체가 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="81e027a9e050661dd1bbf2862087d403e8986023" translate="yes" xml:space="preserve">
          <source>If you want to cache a fragment under certain conditions, you can use &lt;code&gt;cache_if&lt;/code&gt; or &lt;code&gt;cache_unless&lt;/code&gt;:</source>
          <target state="translated">특정 조건에서 조각을 캐시하려면 &lt;code&gt;cache_if&lt;/code&gt; 또는 &lt;code&gt;cache_unless&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="882fdac760d8377266eb2e86f1a03a0b05fa12fe" translate="yes" xml:space="preserve">
          <source>If you want to call &lt;code&gt;order&lt;/code&gt; multiple times, subsequent orders will be appended to the first:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 여러 번 호출 하려면 후속 주문이 첫 번째 주문에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="01478e680e0a3de06aa15384b8c62b6f3e1b9a4d" translate="yes" xml:space="preserve">
          <source>If you want to change the default settings you can change what the system tests are &quot;driven by&quot;. Say you want to change the driver from Selenium to Poltergeist. First add the &lt;code&gt;poltergeist&lt;/code&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;. Then in your &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file do the following:</source>
          <target state="translated">기본 설정을 변경하려는 경우 시스템 테스트를 &quot;구동&quot;하는 내용을 변경할 수 있습니다. 드라이버를 Selenium에서 Poltergeist로 변경한다고 가정하십시오. 먼저 추가 &lt;code&gt;poltergeist&lt;/code&gt; 당신에 보석을 &lt;code&gt;Gemfile&lt;/code&gt; . 그런 다음 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f61e2bb61d59bbfaa9068fd515324935d10137ae" translate="yes" xml:space="preserve">
          <source>If you want to clear &lt;code&gt;public/assets&lt;/code&gt; completely, you can use &lt;code&gt;rails assets:clobber&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;public/assets&lt;/code&gt; 완전히 지우려면 &lt;code&gt;rails assets:clobber&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84dce1db9910af536d37104449772f92e11bc938" translate="yes" xml:space="preserve">
          <source>If you want to define the singular form of a resource, you should add additional rules to the &lt;code&gt;Inflector&lt;/code&gt;:</source>
          <target state="translated">단일 형식의 리소스를 정의하려면 &lt;code&gt;Inflector&lt;/code&gt; 에 규칙을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d60b834048a06a8aac5fcc39e4ca479462715455" translate="yes" xml:space="preserve">
          <source>If you want to destroy any of the associated models through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">양식을 통해 관련 모델 중 하나를 파괴하려는 경우 사용 먼저 활성화해야 &lt;code&gt;:allow_destroy&lt;/code&gt; 대한 옵션을 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8cf4512ea7b0117056f5d1547f834737b34adbc7" translate="yes" xml:space="preserve">
          <source>If you want to destroy the associated model through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">당신이 양식을 통해 관련 모델을 파괴하려는 경우 사용 먼저 활성화해야 &lt;code&gt;:allow_destroy&lt;/code&gt; 대한 옵션을 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ffb3f3dbf442bca04532c3a1fda2be7e3a29fd1b" translate="yes" xml:space="preserve">
          <source>If you want to disable Turbolinks for certain links, add a &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; attribute to the tag:</source>
          <target state="translated">특정 링크에 대해 터보 링크를 비활성화 하려면 태그에 &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1b888393b095eb8be9cc49c8e192d63811a4e144" translate="yes" xml:space="preserve">
          <source>If you want to disable color in console, do:</source>
          <target state="translated">콘솔에서 색상을 비활성화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e30d33a09c87d83b4cb462987de309752d63489a" translate="yes" xml:space="preserve">
          <source>If you want to do something a bit more elaborate when catching errors, you can use &lt;code&gt;rescue_from&lt;/code&gt;, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.</source>
          <target state="translated">오류를 잡을 때 좀 더 정교하게 작업 하려면 전체 컨트롤러와 하위 클래스에서 특정 유형 (또는 여러 유형)의 예외를 처리 하는 &lt;code&gt;rescue_from&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04738d106004ad91f50efe35fd9254c2801b9859" translate="yes" xml:space="preserve">
          <source>If you want to ensure your destination root is clean before running each test, you can set a setup callback:</source>
          <target state="translated">각 테스트를 실행하기 전에 대상 루트가 깨끗한 지 확인하려면 설정 콜백을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be69844258d0f1e61429e02bacd7a81a4960bfad" translate="yes" xml:space="preserve">
          <source>If you want to escape all content, you should invoke the &lt;code&gt;h&lt;/code&gt; method before calling the text helper.</source>
          <target state="translated">모든 내용을 이스케이프 하려면 텍스트 도우미를 호출하기 전에 &lt;code&gt;h&lt;/code&gt; 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9046fa26c6e62782a0a60039d77ec14dd6dd2b1e" translate="yes" xml:space="preserve">
          <source>If you want to explicitly render only certain templates, pass a block:</source>
          <target state="translated">특정 템플릿 만 명시 적으로 렌더링하려면 블록을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="9095618f3a017358eb1838ae59d25212c838a84b" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to GET, use &lt;code&gt;get&lt;/code&gt; in the router:</source>
          <target state="translated">조치를 GET에 노출 하려면 라우터에서 &lt;code&gt;get&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="7506b1f3128dfe856087aae91f14a7cef70e262d" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to both GET and POST, use:</source>
          <target state="translated">GET 및 POST 모두에 조치를 노출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f99a973d61a2033c930918ae7de48be26737ec4" translate="yes" xml:space="preserve">
          <source>If you want to find both by name and locked, you can chain these finders together by simply typing &quot;&lt;code&gt;and&lt;/code&gt;&quot; between the fields. For example, &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt;.</source>
          <target state="translated">이름과 잠금으로 모두 찾으려면 필드 사이에 &quot; &lt;code&gt;and&lt;/code&gt; &quot; 를 입력하여 이러한 파인더를 함께 연결할 수 있습니다. 예를 들어, &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79e1f98e54f296f2c7e4ea42e01c1fc27040270b" translate="yes" xml:space="preserve">
          <source>If you want to find records using the &lt;code&gt;IN&lt;/code&gt; expression you can pass an array to the conditions hash:</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 표현식을 사용하여 레코드를 찾으려면 조건 해시에 배열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fa85f08ba7bf321366b6270e9b87b779facc87" translate="yes" xml:space="preserve">
          <source>If you want to find the maximum value of a field in your table you can call the &lt;code&gt;maximum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블에서 필드의 최대 값을 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;maximum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28c3fda57f94de181be4b5408c0b0847936dab74" translate="yes" xml:space="preserve">
          <source>If you want to find the minimum value of a field in your table you can call the &lt;code&gt;minimum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블에서 필드의 최소값을 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;minimum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b488c2a178c88deaa3c422faf6e87ada4f5cdea2" translate="yes" xml:space="preserve">
          <source>If you want to find the sum of a field for all records in your table you can call the &lt;code&gt;sum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블의 모든 레코드에 대한 필드 합계를 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;sum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afcf2558505ba1fa6f04ecc0d3ef9a8e4515680d" translate="yes" xml:space="preserve">
          <source>If you want to follow along while browsing the Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;source code&lt;/a&gt;, we recommend that you use the &lt;code&gt;t&lt;/code&gt; key binding to open the file finder inside GitHub and find files quickly.</source>
          <target state="translated">Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;소스 코드&lt;/a&gt; 를 탐색하는 동안 따라 가려면 &lt;code&gt;t&lt;/code&gt; 키 바인딩을 사용하여 GitHub에서 파일 찾기를 열고 파일을 빨리 찾는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4b81c7f5d1059063f5ff1e607628d7b3a231038b" translate="yes" xml:space="preserve">
          <source>If you want to include all of the engine's helpers, you can use the helper method on an engine's instance:</source>
          <target state="translated">엔진의 모든 헬퍼를 포함 시키려면 엔진 인스턴스에서 헬퍼 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4367fc68e01e7cac642cd5f8e973aeffedafdc2c" translate="yes" xml:space="preserve">
          <source>If you want to keep that structure, you'll need to delete the subdirectory from the autoload paths in an initializer:</source>
          <target state="translated">해당 구조를 유지하려면 이니셜 라이저의 자동로드 경로에서 하위 디렉토리를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="833aa975863b9d65c76d04ff5db68bd93b0c3dd1" translate="yes" xml:space="preserve">
          <source>If you want to link to an action in the same controller, you don't need to specify the &lt;code&gt;:controller&lt;/code&gt; option, as Rails will use the current controller by default.</source>
          <target state="translated">Rails가 기본적으로 현재 컨트롤러를 사용하기 때문에 동일한 컨트롤러에서 액션에 연결하려면 &lt;code&gt;:controller&lt;/code&gt; 옵션 을 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9ae5a18bce4081d8e4bce6b79dad0a6271339c34" translate="yes" xml:space="preserve">
          <source>If you want to load all posts (including posts with no approved comments), then write your own &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; query using &lt;code&gt;ON&lt;/code&gt;:</source>
          <target state="translated">승인 된 주석이없는 게시물을 포함하여 모든 게시물을로드하려면 &lt;code&gt;ON&lt;/code&gt; 을 사용하여 자신의 &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; 쿼리를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7608a97b4cc8fee46c8ddb8e25f6f759d653e29" translate="yes" xml:space="preserve">
          <source>If you want to make sure that, upon insertion, all of the records in the persisted association are distinct (so that you can be sure that when you inspect the association that you will never find duplicate records), you should add a unique index on the table itself. For example, if you have a table named &lt;code&gt;readings&lt;/code&gt; and you want to make sure the articles can only be added to a person once, you could add the following in a migration:</source>
          <target state="translated">삽입시 지속되는 연관의 모든 레코드가 고유한지 확인하려면 (연결을 검사 할 때 중복 레코드를 찾을 수 없음을 확인할 수 있도록) 고유 색인을 추가해야합니다. 테이블 자체. 예를 들어 &lt;code&gt;readings&lt;/code&gt; 라는 이름의 테이블이 있고 기사를 한 사람에게 한 번만 추가 할 수있게하려면 마이그레이션에서 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d7a136709e327488aa669dc1033c97f1e78efb" translate="yes" xml:space="preserve">
          <source>If you want to make the format segment mandatory, so it cannot be omitted, you can supply &lt;code&gt;format: true&lt;/code&gt; like this:</source>
          <target state="translated">형식 세그먼트를 필수로 만들려면 생략 할 수 없으므로 &lt;code&gt;format: true&lt;/code&gt; 을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202741924d3793a6f39f70128849a1f76eb67a92" translate="yes" xml:space="preserve">
          <source>If you want to perform interpolation on a bulk hash of translations, you need to pass &lt;code&gt;deep_interpolation: true&lt;/code&gt; as a parameter. When you have the following dictionary:</source>
          <target state="translated">번역의 대량 해시에서 보간을 수행하려면 &lt;code&gt;deep_interpolation: true&lt;/code&gt; 를 매개 변수로 전달해야합니다 . 다음 사전이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b898a526db032ac4b4c17d10ed6b687f6f7a6dcf" translate="yes" xml:space="preserve">
          <source>If you want to provide text formatting other than HTML (due to security), use a mark-up language which is converted to HTML on the server-side. &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; is such a language for Ruby, but without precautions, it is also vulnerable to XSS.</source>
          <target state="translated">보안으로 인해 HTML 이외의 텍스트 서식을 제공하려면 서버 측에서 HTML로 변환되는 마크 업 언어를 사용하십시오. &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; 는 Ruby의 언어이지만 예방책이 없으면 XSS에도 취약합니다.</target>
        </trans-unit>
        <trans-unit id="0de6137e22655510821e761cfb4e32162cdf37b1" translate="yes" xml:space="preserve">
          <source>If you want to remove session related middleware, do the following:</source>
          <target state="translated">세션 관련 미들웨어를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="437988df35a90760193f1e50466ecd5f8d0cf358" translate="yes" xml:space="preserve">
          <source>If you want to render the view that corresponds to a different template within the same controller, you can use &lt;code&gt;render&lt;/code&gt; with the name of the view:</source>
          <target state="translated">동일한 컨트롤러 내에서 다른 템플릿에 해당하는 뷰를 렌더링하려면 뷰 이름과 함께 &lt;code&gt;render&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="678518a594c94e4ba524c6e692f3d1358ce5f917" translate="yes" xml:space="preserve">
          <source>If you want to replace any header which already exists, first set it to &lt;code&gt;nil&lt;/code&gt; in order to reset the value otherwise another field will be added for the same header.</source>
          <target state="translated">이미 존재하는 헤더를 바꾸려면 먼저 값을 재설정하기 위해 헤더를 &lt;code&gt;nil&lt;/code&gt; 로 설정하십시오. 그렇지 않으면 동일한 헤더에 다른 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5a89ab8db551e352e42182a2cfd9536e4a45123d" translate="yes" xml:space="preserve">
          <source>If you want to route /admin/posts to &lt;code&gt;PostsController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use</source>
          <target state="translated">/ admin / posts를 &lt;code&gt;PostsController&lt;/code&gt; 로 라우팅 하려면 ( &lt;code&gt;Admin::&lt;/code&gt; 모듈 접두어 없음)</target>
        </trans-unit>
        <trans-unit id="71e1116ab58411d02bb9b2741fbbff3dea0caf12" translate="yes" xml:space="preserve">
          <source>If you want to route /posts (without the prefix /admin) to &lt;code&gt;Admin::PostsController&lt;/code&gt;, you could use</source>
          <target state="translated">접두어 / admin없이 / posts를 &lt;code&gt;Admin::PostsController&lt;/code&gt; 하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c22991ae1709bb07298a0afe1f2a901f31ffa538" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/admin/articles&lt;/code&gt; to &lt;code&gt;ArticlesController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use:</source>
          <target state="translated">&lt;code&gt;/admin/articles&lt;/code&gt; 를 &lt;code&gt;ArticlesController&lt;/code&gt; 로 라우팅 하려면 ( &lt;code&gt;Admin::&lt;/code&gt; 모듈 접두어 없음) 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0d8526c069daa42c1a84666facdfaead9045910" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/articles&lt;/code&gt; (without the prefix &lt;code&gt;/admin&lt;/code&gt;) to &lt;code&gt;Admin::ArticlesController&lt;/code&gt;, you could use:</source>
          <target state="translated">접두어 &lt;code&gt;/admin&lt;/code&gt; 없이 &lt;code&gt;/articles&lt;/code&gt; 를 &lt;code&gt;Admin::ArticlesController&lt;/code&gt; 로 라우팅 하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a23182d8fff39aabae6eb6b0d95e07349aebd04" translate="yes" xml:space="preserve">
          <source>If you want to see how many records are in your model's table you could call &lt;code&gt;Client.count&lt;/code&gt; and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use &lt;code&gt;Client.count(:age)&lt;/code&gt;.</source>
          <target state="translated">모델 테이블에 몇 개의 레코드가 있는지 보려면 &lt;code&gt;Client.count&lt;/code&gt; 를 호출 하면 숫자가 반환됩니다. 더 구체적이고 데이터베이스에 연령이있는 모든 클라이언트를 찾으려면 &lt;code&gt;Client.count(:age)&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c82af370bdb1006cbe834871485c7f1ca878b194" translate="yes" xml:space="preserve">
          <source>If you want to see the average of a certain number in one of your tables you can call the &lt;code&gt;average&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블 중 하나에서 특정 숫자의 평균을 보려면 테이블 과 관련된 클래스 의 &lt;code&gt;average&lt;/code&gt; 메서드를 호출하면 됩니다. 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b0feb29eaac36cd5373da76d96fb33a59b720fd" translate="yes" xml:space="preserve">
          <source>If you want to see the exact results of a call to &lt;code&gt;render&lt;/code&gt; without needing to inspect it in a browser, you can call &lt;code&gt;render_to_string&lt;/code&gt;. This method takes exactly the same options as &lt;code&gt;render&lt;/code&gt;, but it returns a string instead of sending a response back to the browser.</source>
          <target state="translated">브라우저에서 검사 할 필요없이 &lt;code&gt;render&lt;/code&gt; 하기위한 정확한 호출 결과를 보려면 &lt;code&gt;render_to_string&lt;/code&gt; 을 호출 할 수 있습니다 . 이 메소드는 &lt;code&gt;render&lt;/code&gt; 와 정확히 동일한 옵션을 사용 하지만 응답을 브라우저로 다시 보내는 대신 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb3bcca1fe2eb16c2e4bafbe58abd6079508f7d4" translate="yes" xml:space="preserve">
          <source>If you want to select a set of records whether or not they have associated records you can use the &lt;code&gt;left_outer_joins&lt;/code&gt; method.</source>
          <target state="translated">연관된 레코드가 있는지 여부에 관계없이 레코드 세트를 선택하려는 경우 &lt;code&gt;left_outer_joins&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd867d338e486f51b7e048f7dbfe4bba0ff8db95" translate="yes" xml:space="preserve">
          <source>If you want to send a file that already exists on disk, use the &lt;code&gt;send_file&lt;/code&gt; method.</source>
          <target state="translated">디스크에 이미 존재하는 파일을 보내려면 &lt;code&gt;send_file&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa8614479ca836359c8d9b53a1ceb07120d48fe5" translate="yes" xml:space="preserve">
          <source>If you want to send emails right away (from a cronjob for example) just call &lt;code&gt;deliver_now&lt;/code&gt;:</source>
          <target state="translated">예를 들어 cronjob에서 이메일을 바로 보내려면 &lt;code&gt;deliver_now&lt;/code&gt; 로 전화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7e40e2a1ad7f940f357a14d957ba15d7fb75371" translate="yes" xml:space="preserve">
          <source>If you want to serve only some assets from your CDN, you can use custom &lt;code&gt;:host&lt;/code&gt; option your asset helper, which overwrites value set in &lt;code&gt;config.action_controller.asset_host&lt;/code&gt;.</source>
          <target state="translated">CDN에서 일부 자산 만 제공하려면 자산 도우미 인 custom &lt;code&gt;:host&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;config.action_controller.asset_host&lt;/code&gt; 에 설정된 값을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="86a051be540d60a884f81305aac005b33816a13e" translate="yes" xml:space="preserve">
          <source>If you want to set custom headers for a response then &lt;code&gt;response.headers&lt;/code&gt; is the place to do it. The headers attribute is a hash which maps header names to their values, and Rails will set some of them automatically. If you want to add or change a header, just assign it to &lt;code&gt;response.headers&lt;/code&gt; this way:</source>
          <target state="translated">당신이 응답을 설정 사용자 지정 헤더를 원하는 경우 &lt;code&gt;response.headers&lt;/code&gt; 은 그것을 할 수있는 곳입니다. headers 속성은 헤더 이름을 해당 값에 매핑하는 해시이며 Rails는 그 중 일부를 자동으로 설정합니다. 헤더를 추가하거나 변경하려면 다음과 같이 &lt;code&gt;response.headers&lt;/code&gt; 에 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="099225027f13bd8921cfcbe297f75a2b5bfbff8e" translate="yes" xml:space="preserve">
          <source>If you want to set far future &lt;code&gt;max-age&lt;/code&gt; in your &lt;code&gt;Cache-Control&lt;/code&gt; (and you do), then make sure when you change your assets that your cache is invalidated. For example when changing the smiley face in an image from yellow to blue, you want all visitors of your site to get the new blue face. When using a CDN with the Rails asset pipeline &lt;code&gt;config.assets.digest&lt;/code&gt; is set to true by default so that each asset will have a different file name when it is changed. This way you don't have to ever manually invalidate any items in your cache. By using a different unique asset name instead, your users get the latest asset.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 에서 미래의 &lt;code&gt;max-age&lt;/code&gt; 을 설정 하려면 자산을 변경할 때 캐시가 무효화되었는지 확인하십시오. 예를 들어 이미지에서 웃는 얼굴을 노란색에서 파란색으로 변경할 때 사이트의 모든 방문자가 새 파란 얼굴을 갖기를 원합니다. Rails 자산 파이프 라인과 함께 CDN을 사용하는 경우 각 자산이 변경 될 때 각 파일의 이름이 달라 지도록 기본적으로 &lt;code&gt;config.assets.digest&lt;/code&gt; 가 true로 설정됩니다. 이렇게하면 캐시에있는 항목을 수동으로 무효화 할 필요가 없습니다. 다른 고유 자산 이름을 대신 사용하면 사용자에게 최신 자산이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3aef9f711923eec46d9db89fdf9587f2d1fc51b2" translate="yes" xml:space="preserve">
          <source>If you want to set up a one-to-one relationship between two models, you'll need to add &lt;code&gt;belongs_to&lt;/code&gt; to one, and &lt;code&gt;has_one&lt;/code&gt; to the other. How do you know which is which?</source>
          <target state="translated">두 모델간에 일대일 관계를 설정하려면 한 모델에 &lt;code&gt;belongs_to&lt;/code&gt; 를 추가 하고 다른 모델에는 &lt;code&gt;has_one&lt;/code&gt; 을 추가해야합니다 . 어느 것이 무엇인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="41299ecc49f2b55d12fc783dd8a4bce25cda4533" translate="yes" xml:space="preserve">
          <source>If you want to specify multiple conditions:</source>
          <target state="translated">여러 조건을 지정하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="92432ba849376cfd328bd42af73915abeec976e3" translate="yes" xml:space="preserve">
          <source>If you want to take an existing application and make it an API one, read the following steps.</source>
          <target state="translated">기존 애플리케이션을 가져 와서 API 애플리케이션으로 만들려면 다음 단계를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="426e7b46d2daba4aa620587d8734cf3218fc3ddf" translate="yes" xml:space="preserve">
          <source>If you want to test for mobile sizes on top of testing for desktop, you can create another class that inherits from SystemTestCase and use in your test suite. In this example a file called &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; is created in the &lt;code&gt;/test&lt;/code&gt; directory with the following configuration.</source>
          <target state="translated">데스크탑 테스트 외에 모바일 크기를 테스트하려는 경우 SystemTestCase에서 상속하고 테스트 스위트에서 사용하는 다른 클래스를 작성할 수 있습니다. 이 예제에서 &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; 라는 파일 은 다음 구성으로 &lt;code&gt;/test&lt;/code&gt; 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb99e9b5714695e3c0d2a4ad4579d004020c4ebf" translate="yes" xml:space="preserve">
          <source>If you want to test the broadcasting made with &lt;code&gt;Channel.broadcast_to&lt;/code&gt;, you shoud use &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; to generate an underlying stream name:</source>
          <target state="translated">&lt;code&gt;Channel.broadcast_to&lt;/code&gt; 로 만든 방송을 테스트 하려면 &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; 를 사용하여 기본 스트림 이름을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ff54b553ef18f239f233ecc554746be0ea932b7" translate="yes" xml:space="preserve">
          <source>If you want to update the current avatar without providing the id, you must add &lt;code&gt;:update_only&lt;/code&gt; option.</source>
          <target state="translated">ID를 제공하지 않고 현재 아바타를 업데이트하려면 &lt;code&gt;:update_only&lt;/code&gt; 옵션을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f01918dd89fba4b8c4e6c1531a6a2074a2bdf6" translate="yes" xml:space="preserve">
          <source>If you want to use Spring as your application preloader you need to:</source>
          <target state="translated">Spring을 애플리케이션 프리 로더로 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b965db2407513b5b2b570f23c5d93b00e3101f2d" translate="yes" xml:space="preserve">
          <source>If you want to use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;data URI&lt;/a&gt; - a method of embedding the image data directly into the CSS file - you can use the &lt;code&gt;asset_data_uri&lt;/code&gt; helper.</source>
          <target state="translated">이미지 데이터를 CSS 파일에 직접 포함시키는 방법 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;데이터 URI&lt;/a&gt; 를 사용하려는 경우 &lt;code&gt;asset_data_uri&lt;/code&gt; 도우미를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a38b6f313ac095865cc041c45313249a8c891f54" translate="yes" xml:space="preserve">
          <source>If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding &lt;code&gt;headless_chrome&lt;/code&gt; or &lt;code&gt;headless_firefox&lt;/code&gt; in the &lt;code&gt;:using&lt;/code&gt; argument.</source>
          <target state="translated">헤드리스 브라우저를 사용 하려면 &lt;code&gt;:using&lt;/code&gt; 인수 에 &lt;code&gt;headless_chrome&lt;/code&gt; 또는 &lt;code&gt;headless_firefox&lt;/code&gt; 를 추가하여 Headless Chrome 또는 Headless Firefox를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8469a734b56d841b8d3b06494a60e3dbb5a95e48" translate="yes" xml:space="preserve">
          <source>If you want to use an inline method, such as a proc, do something like this:</source>
          <target state="translated">proc와 같은 인라인 메소드를 사용하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="e9476b0eea21be4c7ecb97a0e9ba1aba5803590f" translate="yes" xml:space="preserve">
          <source>If you want to use encoding other than Base64 then you will need to pass encoding type along with the pre-encoded content as Mail doesn't know how to decode the data:</source>
          <target state="translated">Base64 이외의 인코딩을 사용하려면 Mail이 데이터를 디코딩하는 방법을 모르기 때문에 미리 인코딩 된 내용과 함께 인코딩 유형을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="83bc651176612167b690b60503d3abc1dba33511" translate="yes" xml:space="preserve">
          <source>If you want to use environment variables, standard SDK configuration files, profiles, IAM instance profiles or task roles, you can omit the &lt;code&gt;access_key_id&lt;/code&gt;, &lt;code&gt;secret_access_key&lt;/code&gt;, and &lt;code&gt;region&lt;/code&gt; keys in the example above. The Amazon S3 Service supports all of the authentication options described in the &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK documentation&lt;/a&gt;.</source>
          <target state="translated">환경 변수, 표준 SDK 구성 파일, 프로파일, IAM 인스턴스 프로파일 또는 작업 역할을 사용하려는 경우 위 예에서 &lt;code&gt;access_key_id&lt;/code&gt; , &lt;code&gt;secret_access_key&lt;/code&gt; 및 &lt;code&gt;region&lt;/code&gt; 키를 생략 할 수 있습니다 . Amazon S3 서비스는 &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK 설명서에&lt;/a&gt; 설명 된 모든 인증 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="78550f6d08d1ff8a685dd59e30382d79dffa8bb2" translate="yes" xml:space="preserve">
          <source>If you want to use multiple Sass files, you should generally use the &lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; instead of these Sprockets directives. When using Sprockets directives, Sass files exist within their own scope, making variables or mixins only available within the document they were defined in.</source>
          <target state="translated">여러 Sass 파일을 사용하려면 일반적으로 이러한 Sprockets 지시문 대신 &lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; 규칙을&lt;/a&gt; 사용해야합니다 . Sprockets 지시문을 사용할 때 Sass 파일은 자체 범위 내에 존재하므로 정의 된 문서 내에서만 변수 또는 믹스 인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c94a4e174d42f497da3366d92bc9b0b8bc6401f" translate="yes" xml:space="preserve">
          <source>If you want to use the Direct Upload feature from a JavaScript framework, or you want to integrate custom drag and drop solutions, you can use the &lt;code&gt;DirectUpload&lt;/code&gt; class for this purpose. Upon receiving a file from your library of choice, instantiate a DirectUpload and call its create method. Create takes a callback to invoke when the upload completes.</source>
          <target state="translated">JavaScript 프레임 워크에서 직접 업로드 기능을 사용하거나 사용자 정의 끌어서 놓기 솔루션을 통합하려는 경우 &lt;code&gt;DirectUpload&lt;/code&gt; 클래스를이 목적으로 사용할 수 있습니다 . 선택한 라이브러리에서 파일을 받으면 DirectUpload를 인스턴스화하고 해당 create 메소드를 호출하십시오. 업로드가 완료되면 Create에서 콜백을 호출하여 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0daea374afa45a4f9161d43ce592eeaf4bfcbb83" translate="yes" xml:space="preserve">
          <source>If you want to use the new &lt;code&gt;secrets.yml&lt;/code&gt; convention to store your application's secrets, you need to:</source>
          <target state="translated">새로운 &lt;code&gt;secrets.yml&lt;/code&gt; 규칙을 사용하여 응용 프로그램의 비밀을 저장하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b2f0d4edf0b36ea43e41a3cceafe2919b1796b3" translate="yes" xml:space="preserve">
          <source>If you want to validate that a child record is associated with a parent record, you can use the &lt;code&gt;validates_presence_of&lt;/code&gt; method and the &lt;code&gt;:inverse_of&lt;/code&gt; key as this example illustrates:</source>
          <target state="translated">하위 레코드가 상위 레코드와 연관되어 있는지 유효성 검증하려는 경우, 이 예제에서 설명하는대로 &lt;code&gt;validates_presence_of&lt;/code&gt; 메소드 및 &lt;code&gt;:inverse_of&lt;/code&gt; 키를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="360919c22e7192293a509dac7b1cea6d815c9f8c" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">부울 필드가 있는지 확인하려면 (실제 값이 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 인 경우 ) &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ea56a09fad8a04faf2bff57737e8a807d3431719" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are true and false), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">부울 필드가 있는지 확인하려면 (실제 값이 true 및 false 인 경우) &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7fa417478846acd30b43d6fde743d8c6ea43060f" translate="yes" xml:space="preserve">
          <source>If you want your mailer to be able to process incoming messages, you'll need to implement a &lt;code&gt;receive&lt;/code&gt; method that accepts the raw email string as a parameter:</source>
          <target state="translated">메일러가 수신 메시지를 처리 ​​할 수있게 하려면 원시 이메일 문자열을 매개 변수로 승인 하는 &lt;code&gt;receive&lt;/code&gt; 메소드 를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6455c2de3d7a047581e9fcb01755edb3c86f2bbd" translate="yes" xml:space="preserve">
          <source>If you wanted to link to just a magazine:</source>
          <target state="translated">잡지에만 연결하려면 :</target>
        </trans-unit>
        <trans-unit id="7776932dfe5e1ba6fe53dedb97b0fcebe5afe5b5" translate="yes" xml:space="preserve">
          <source>If you were to publish your blog online, anyone would be able to add, edit and delete articles or delete comments.</source>
          <target state="translated">블로그를 온라인으로 게시 할 경우 누구나 기사를 추가, 편집 및 삭제할 수 있으며 의견을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575cb50250b1bf052c4de6c10262311c1b70fb97" translate="yes" xml:space="preserve">
          <source>If you were to use this inside an engine, it would &lt;strong&gt;always&lt;/strong&gt; go to the application's root. If you were to leave off the &lt;code&gt;main_app&lt;/code&gt; &quot;routing proxy&quot; method call, it could potentially go to the engine's or application's root, depending on where it was called from.</source>
          <target state="translated">엔진 내에서 이것을 사용한다면 &lt;strong&gt;항상&lt;/strong&gt; 응용 프로그램의 루트로 이동합니다. &lt;code&gt;main_app&lt;/code&gt; &quot;routing proxy&quot;메소드 호출을 중단해야하는 경우 호출 된 위치에 따라 엔진 또는 애플리케이션의 루트로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a427f99647eb5e543a3ae1b3a0d916eb1faa0edd" translate="yes" xml:space="preserve">
          <source>If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use &lt;code&gt;reversible&lt;/code&gt;:</source>
          <target state="translated">마이그레이션에서 Active Record가 되돌릴 방법을 모르는 작업을 수행하려는 경우 &lt;code&gt;reversible&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acd56c78b0133cc928ce018dc68640e14293ed83" translate="yes" xml:space="preserve">
          <source>If you wish to assign an object to a &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; association without saving it, use the &lt;code&gt;#build_association&lt;/code&gt; method (documented below). The object being replaced will still be saved to update its foreign key.</source>
          <target state="translated">저장하지 않고 &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; 연결에 객체를 할당 하려면 &lt;code&gt;#build_association&lt;/code&gt; 메서드를 사용하십시오 (아래에 설명되어 있음). 교체되는 객체는 외래 키를 업데이트하기 위해 여전히 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a737eea7353d9510092816cd514035cc221c5cdd" translate="yes" xml:space="preserve">
          <source>If you wish to direct your form request to a particular URL, you would use &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; instead. To see more in depth options on what &lt;code&gt;form_with&lt;/code&gt; accepts be sure to &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;check out the API documentation&lt;/a&gt;.</source>
          <target state="translated">양식 요청을 특정 URL로 &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; 대신 form_with url : my_nifty_url_path를 사용하십시오. &lt;code&gt;form_with&lt;/code&gt; 가 받아들이는 것에 대한 더 자세한 옵션을 보려면 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;API 문서&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6402f3e6ee3269544b94ed2afd9f856f4bfe840" translate="yes" xml:space="preserve">
          <source>If you wish to enforce referential integrity at the database level, add the &lt;code&gt;foreign_key: true&lt;/code&gt; option to the &amp;lsquo;reference&amp;rsquo; column declarations above.</source>
          <target state="translated">데이터베이스 레벨에서 참조 무결성을 강제 하려면 위의 'reference'열 선언에 &lt;code&gt;foreign_key: true&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba5ce0e2d38e3da0ce1fa3f46b615712df3745f" translate="yes" xml:space="preserve">
          <source>If you wish to override the default delivery options (e.g. SMTP credentials) while delivering emails, you can do this using &lt;code&gt;delivery_method_options&lt;/code&gt; in the mailer action.</source>
          <target state="translated">이메일을 전송하는 동안 기본 전송 옵션 (예 : SMTP 신임 정보)을 대체하려는 경우 , 메일러 조치에서 &lt;code&gt;delivery_method_options&lt;/code&gt; 를 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bc41a963ec89ff455cd121d6950f47a8727574b" translate="yes" xml:space="preserve">
          <source>If you wish to preload the dependent &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; model, you can use the named scope:</source>
          <target state="translated">종속 &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; 모델 을 사전로드하려는 경우 이름 지정된 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32d5aaa0eac49f14bbdb07d88277c02905e0a8f3" translate="yes" xml:space="preserve">
          <source>If you wish to reference the application inside the engine in a similar way, use the &lt;code&gt;main_app&lt;/code&gt; helper:</source>
          <target state="translated">비슷한 방식으로 엔진 내부의 응용 프로그램을 참조하려면 &lt;code&gt;main_app&lt;/code&gt; 도우미를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e733200282906818655a1aeb77c3effbcc540ff4" translate="yes" xml:space="preserve">
          <source>If you wish to specify disabled option tags, set &lt;code&gt;selected&lt;/code&gt; to be a hash, with &lt;code&gt;:disabled&lt;/code&gt; being either a value or array of values to be disabled. In this case, you can use &lt;code&gt;:selected&lt;/code&gt; to specify selected option tags.</source>
          <target state="translated">당신이 사용할 옵션 태그를 지정하고자하는 경우, 세트 &lt;code&gt;selected&lt;/code&gt; 과 해시로 &lt;code&gt;:disabled&lt;/code&gt; 복지 값이나 값의 배열 비활성화 된 것 중 하나. 이 경우 &lt;code&gt;:selected&lt;/code&gt; 를 사용하여 선택한 옵션 태그를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1c9e5119e4d165a495f0f324ad98ec144c7d4d2" translate="yes" xml:space="preserve">
          <source>If you wish to specify your own custom joins using &lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord::QueryMethods#joins&lt;/a&gt; method, those table names will take precedence over the eager associations:</source>
          <target state="translated">&lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord :: QueryMethods # joins&lt;/a&gt; 메서드 를 사용하여 고유 한 사용자 지정 조인을 지정하려는 경우 해당 테이블 이름이 열성적인 연결보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="81a502737a61e2e278b4a4cb999f6a9c1f6ca22d" translate="yes" xml:space="preserve">
          <source>If you wish to test out some code without changing any data, you can do that by invoking &lt;code&gt;rails console --sandbox&lt;/code&gt;.</source>
          <target state="translated">데이터를 변경하지 않고 일부 코드를 테스트하려면 &lt;code&gt;rails console --sandbox&lt;/code&gt; 를 호출하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55e25e1f3e40c431c5a37b5f3841936bbc4459cd" translate="yes" xml:space="preserve">
          <source>If you wish to use an initializer - code that should run before the engine is loaded - the place for it is the &lt;code&gt;config/initializers&lt;/code&gt; folder. This directory's functionality is explained in the &lt;a href=&quot;configuring#initializers&quot;&gt;Initializers section&lt;/a&gt; of the Configuring guide, and works precisely the same way as the &lt;code&gt;config/initializers&lt;/code&gt; directory inside an application. The same thing goes if you want to use a standard initializer.</source>
          <target state="translated">엔진을로드하기 전에 실행해야하는 이니셜 라이저를 사용하려는 경우 엔진의 위치는 &lt;code&gt;config/initializers&lt;/code&gt; 폴더입니다. 이 디렉토리의 기능은 구성 안내서 의 &lt;a href=&quot;configuring#initializers&quot;&gt;이니셜 라이저 섹션&lt;/a&gt; 에 설명 되어 있으며 응용 프로그램 내의 &lt;code&gt;config/initializers&lt;/code&gt; 디렉토리 와 정확히 동일한 방식으로 작동 합니다. 표준 이니셜 라이저를 사용하려는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c739de938813bf2056a36275c1000bffb09bd3db" translate="yes" xml:space="preserve">
          <source>If you wish, you can manually specify a URL inside of your &lt;code&gt;config/database.yml&lt;/code&gt;</source>
          <target state="translated">원하는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 내부에 URL을 수동으로 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f69437be8ce715e3ad0ef7043ae0bcb2d318c62e" translate="yes" xml:space="preserve">
          <source>If you would like to only grab a single record per unique value in a certain field, you can use &lt;code&gt;distinct&lt;/code&gt;:</source>
          <target state="translated">특정 필드에서 고유 한 값당 단일 레코드 만 가져 오려면 &lt;code&gt;distinct&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed75682776d228d6bff9a8ef48ef887e89b70898" translate="yes" xml:space="preserve">
          <source>If you would like to render a template located outside of the default &lt;code&gt;app/views/mailer_name/&lt;/code&gt; directory, you can apply the &lt;code&gt;prepend_view_path&lt;/code&gt;, like so:</source>
          <target state="translated">기본 &lt;code&gt;app/views/mailer_name/&lt;/code&gt; 디렉토리 외부에있는 템플리트를 렌더링 하려면 다음 과 같이 &lt;code&gt;prepend_view_path&lt;/code&gt; 를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7911382e4c2b67c50379b3d44270b5f5346e6d73" translate="yes" xml:space="preserve">
          <source>If you would like to run migrations only from one engine, you can do it by specifying &lt;code&gt;SCOPE&lt;/code&gt;:</source>
          <target state="translated">하나의 엔진에서만 마이그레이션을 실행하려면 &lt;code&gt;SCOPE&lt;/code&gt; 를 지정하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="790b328e640d82b5da7e75fab70c6282096d3a74" translate="yes" xml:space="preserve">
          <source>If you would prefer missing translations to raise an error, you can opt out of span-wrapping behavior globally by setting &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; or individually by passing &lt;code&gt;raise: true&lt;/code&gt; as an option to &lt;code&gt;translate&lt;/code&gt;.</source>
          <target state="translated">번역이 누락되어 오류가 발생하는 것을 선호하는 경우 &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; 를 설정 하거나 &lt;code&gt;translate&lt;/code&gt; 옵션으로 &lt;code&gt;raise: true&lt;/code&gt; 를 전달 하여 스팬 랩핑 동작을 전체적으로 선택 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b08445505f4021362fd6c2de4bd7b9f8fc7ae2" translate="yes" xml:space="preserve">
          <source>If you would prefer to have your Rack application receive requests at the root path instead, use &lt;code&gt;mount&lt;/code&gt;:</source>
          <target state="translated">Rack 응용 프로그램이 대신 루트 경로에서 요청을 받도록하려면 &lt;code&gt;mount&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f046f887041093bb4fa70b63dbbb0a559fdea0" translate="yes" xml:space="preserve">
          <source>If you'd like to add an index on the new column, you can do that as well:</source>
          <target state="translated">새 열에 색인을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7976c8ec3a7be940920ae427bbf8a122fa920741" translate="yes" xml:space="preserve">
          <source>If you'd like to add conditions to your find, you could just specify them in there, just like &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt;. This will find all clients where the &lt;code&gt;orders_count&lt;/code&gt; field's value is 2.</source>
          <target state="translated">찾기에 조건을 추가하려면 &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt; 와 같이 조건을 지정하면됩니다 . &lt;code&gt;orders_count&lt;/code&gt; 필드 값이 2 인 모든 클라이언트를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d19f1f4f9e797b4b1ec650b6359a17ffa7511296" translate="yes" xml:space="preserve">
          <source>If you'd like to delete several records in bulk, you may use &lt;code&gt;destroy_by&lt;/code&gt; or &lt;code&gt;destroy_all&lt;/code&gt; method:</source>
          <target state="translated">여러 레코드를 대량으로 삭제하려면 &lt;code&gt;destroy_by&lt;/code&gt; 또는 &lt;code&gt;destroy_all&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e981bfaa7de9368100fa34a45a9739141519f9a" translate="yes" xml:space="preserve">
          <source>If you'd like to ensure that communication to your controller is only possible via HTTPS, you should do so by enabling the &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; middleware via &lt;code&gt;config.force_ssl&lt;/code&gt; in your environment configuration.</source>
          <target state="translated">컨트롤러와의 통신이 HTTPS를 통해서만 가능하도록하려면 환경 구성에서 &lt;code&gt;config.force_ssl&lt;/code&gt; 을 통해 &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; 미들웨어를 활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6bfd2699bc66216d017e05cf9ebcf5a5fc2b1215" translate="yes" xml:space="preserve">
          <source>If you'd like to use your own SQL to find records in a table you can use &lt;code&gt;find_by_sql&lt;/code&gt;. The &lt;code&gt;find_by_sql&lt;/code&gt; method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</source>
          <target state="translated">고유 한 SQL을 사용하여 테이블에서 레코드를 찾으려면 &lt;code&gt;find_by_sql&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;find_by_sql&lt;/code&gt; 의 방법도 기본 쿼리가 반환하는 경우 단지 하나의 레코드 객체의 배열을 반환합니다. 예를 들어이 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d913a8c49bbd0caa0d0558b5ff8d81df0b5195d4" translate="yes" xml:space="preserve">
          <source>If you'd prefer to use numeric prefixes, you can turn timestamped migrations off by setting:</source>
          <target state="translated">숫자 접두사를 사용하려면 다음을 설정하여 타임 스탬프 마이그레이션을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e07e42c2f306a8f64c34aec429563c444e6909" translate="yes" xml:space="preserve">
          <source>If you'd rather play around in the console, &lt;code&gt;rails console&lt;/code&gt; will also work just like a Rails application. Remember: the &lt;code&gt;Article&lt;/code&gt; model is namespaced, so to reference it you must call it as &lt;code&gt;Blorgh::Article&lt;/code&gt;.</source>
          <target state="translated">콘솔에서 플레이하고 싶다면 Rails &lt;code&gt;rails console&lt;/code&gt; 도 Rails 응용 프로그램처럼 작동합니다. 기억하십시오 : &lt;code&gt;Article&lt;/code&gt; 모델은 네임 스페이스이므로 참조하려면 &lt;code&gt;Blorgh::Article&lt;/code&gt; 이라고해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6532d9f78f750c236c3b6d83a991d12488056704" translate="yes" xml:space="preserve">
          <source>If you're building a Rails application that will be an API server first and foremost, you can start with a more limited subset of Rails and add in features as needed.</source>
          <target state="translated">가장 먼저 API 서버가 될 Rails 애플리케이션을 구축하는 경우 더 제한된 Rails 하위 세트로 시작하여 필요에 따라 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e3e39f3273389814db32e9d227bc1663081d89" translate="yes" xml:space="preserve">
          <source>If you're defining additional resource routes with a symbol as the first positional argument, be mindful that it is not equivalent to using a string. Symbols infer controller actions while strings infer paths.</source>
          <target state="translated">기호를 첫 번째 위치 인수로 사용하여 추가 리소스 경로를 정의하는 경우 문자열을 사용하는 것과 같지 않습니다. 문자열은 경로를 유추하는 동안 기호는 컨트롤러 동작을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="c858a8636b2b3b43ef9fa37542ac6af20ab4623e" translate="yes" xml:space="preserve">
          <source>If you're familiar with the HTTP protocol, you'll know that &lt;code&gt;get&lt;/code&gt; is a type of request. There are 6 request types supported in Rails functional tests:</source>
          <target state="translated">HTTP 프로토콜에 익숙하다면 &lt;code&gt;get&lt;/code&gt; 이 요청 유형 이라는 것을 알게 될 것입니다 . Rails 기능 테스트에서는 6 가지 요청 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8fe2bd82f04d8f34c233a8938cd887f9fe4b73" translate="yes" xml:space="preserve">
          <source>If you're going to need to use any other methods, you should use &lt;code&gt;reversible&lt;/code&gt; or write the &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; methods instead of using the &lt;code&gt;change&lt;/code&gt; method.</source>
          <target state="translated">다른 방법을 사용해야하는 경우 &lt;code&gt;change&lt;/code&gt; 방법 을 사용하는 대신 &lt;code&gt;reversible&lt;/code&gt; 있거나 &lt;code&gt;up&lt;/code&gt; 및 &lt;code&gt;down&lt;/code&gt; 방법을 작성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2da9f66c4acf50bc0a779c72300d200c3b9cb2d7" translate="yes" xml:space="preserve">
          <source>If you're going to pass the parameters to an &lt;code&gt;ActiveModel&lt;/code&gt; object (such as &lt;code&gt;User.new(params[:user])&lt;/code&gt;), you might consider passing the model class to the method instead. The &lt;code&gt;ParamsWrapper&lt;/code&gt; will actually try to determine the list of attribute names from the model and only wrap those attributes:</source>
          <target state="translated">매개 변수를 &lt;code&gt;ActiveModel&lt;/code&gt; 객체 (예 : &lt;code&gt;User.new(params[:user])&lt;/code&gt; )에 전달하려는 경우 대신 모델 클래스를 메소드에 전달하는 것을 고려할 수 있습니다. &lt;code&gt;ParamsWrapper&lt;/code&gt; 은 실제로 모델에서 속성 이름의 목록을 확인하고 속성 만 포장하려고합니다 :</target>
        </trans-unit>
        <trans-unit id="096ce5069eb7339a39375acb03a52843c4f452e9" translate="yes" xml:space="preserve">
          <source>If you're not going to be using any of the options like collections or layouts, you can also use the short-hand defaults of render to render partials. Examples:</source>
          <target state="translated">컬렉션이나 레이아웃과 같은 옵션을 사용하지 않을 경우 짧은 기본 렌더링을 사용하여 부분을 렌더링 할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c1428a86731299c6d458cfab5f49fba8d9a54cee" translate="yes" xml:space="preserve">
          <source>If you're on MySQL, then do not use Data Definition Language (DDL) operations in nested transactions blocks that are emulated with savepoints. That is, do not execute statements like 'CREATE TABLE' inside such blocks. This is because MySQL automatically releases all savepoints upon executing a DDL operation. When &lt;code&gt;transaction&lt;/code&gt; is finished and tries to release the savepoint it created earlier, a database error will occur because the savepoint has already been automatically released. The following example demonstrates the problem:</source>
          <target state="translated">MySQL을 사용하는 경우 저장 점으로 에뮬레이트 된 중첩 트랜잭션 블록에서 DDL (Data Definition Language) 작업을 사용하지 마십시오. 즉, 이러한 블록 내에서 'CREATE TABLE'과 같은 문을 실행하지 마십시오. MySQL은 DDL 작업을 실행할 때 모든 저장 점을 자동으로 해제하기 때문입니다. 때 &lt;code&gt;transaction&lt;/code&gt; 완료이며 이전에 만든 세이브 포인트를 해제하려고 세이브 포인트가 이미 자동으로 해제되어 있기 때문에, 데이터베이스 오류가 발생합니다. 다음 예제는 문제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e401cde5d947378c5cb2630d5792af35e1cd426a" translate="yes" xml:space="preserve">
          <source>If you're precompiling your assets (see &lt;a href=&quot;#in-production&quot;&gt;In Production&lt;/a&gt; below), linking to an asset that does not exist will raise an exception in the calling page. This includes linking to a blank string. As such, be careful using &lt;code&gt;image_tag&lt;/code&gt; and the other helpers with user-supplied data.</source>
          <target state="translated">자산을 사전 컴파일하는 경우 ( 아래 &lt;a href=&quot;#in-production&quot;&gt;프로덕션에서&lt;/a&gt; 참조) 존재하지 않는 자산에 연결하면 호출 페이지에서 예외가 발생합니다. 여기에는 빈 문자열에 대한 링크가 포함됩니다. 따라서 &lt;code&gt;image_tag&lt;/code&gt; 및 사용자가 제공 한 데이터와 함께 다른 도우미를 사용하는 데주의하십시오.</target>
        </trans-unit>
        <trans-unit id="3df341ac8f262d7b86a6c04ae7e8cea08aa1a2e1" translate="yes" xml:space="preserve">
          <source>If you're running multiple Ruby on Rails server processes (which is the case if you're using Phusion Passenger or puma clustered mode), then your Rails server process instances won't be able to share cache data with each other. This cache store is not appropriate for large application deployments. However, it can work well for small, low traffic sites with only a couple of server processes, as well as development and test environments.</source>
          <target state="translated">Phusion Passenger 또는 puma clustered 모드를 사용하는 경우 여러 Ruby on Rails 서버 프로세스를 실행하는 경우 Rails 서버 프로세스 인스턴스는 서로 캐시 데이터를 공유 할 수 없습니다. 이 캐시 저장소는 대규모 응용 프로그램 배포에는 적합하지 않습니다. 그러나 개발 및 테스트 환경뿐만 아니라 몇 개의 서버 프로세스 만있는 트래픽이 적은 소규모 사이트에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9b7c79524790e17cbf7db1c67efd468a1423d66e" translate="yes" xml:space="preserve">
          <source>If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.</source>
          <target state="translated">원시 SQL을 사용하여 데이터베이스 레코드를 찾는 데 익숙하다면 일반적으로 Rails에서 동일한 작업을 수행하는 더 좋은 방법이 있다는 것을 알게 될 것입니다. Active Record는 대부분의 경우 SQL을 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="cf43b2e21b48384c946daf0f74a4a7b9ec9b126b" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;schema_search_path&lt;/code&gt; or other PostgreSQL extensions, you can control how the schema is dumped. Set to &lt;code&gt;:all&lt;/code&gt; to generate all dumps, or to &lt;code&gt;:schema_search_path&lt;/code&gt; to generate from schema search path.</source>
          <target state="translated">&lt;code&gt;schema_search_path&lt;/code&gt; 또는 기타 PostgreSQL 확장을 사용 하는 경우 스키마가 덤프되는 방법을 제어 할 수 있습니다. 모든 덤프를 생성 하려면 &lt;code&gt;:all&lt;/code&gt; 로, 스키마 검색 경로에서 생성 하려면 &lt;code&gt;:schema_search_path&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d229ea54e3d521db7d13293be710b7f3c3f89865" translate="yes" xml:space="preserve">
          <source>If you're using Windows Subsystem for Linux then there are currently some limitations on file system notifications that mean you should disable the &lt;code&gt;spring&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; gems which you can do by running &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt;.</source>
          <target state="translated">Linux 용 Windows 서브 시스템을 사용하는 경우 파일 시스템 알림에 현재 일부 제한 사항이 있습니다. 즉, &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt; 을 실행하여 수행 할 수 있는 &lt;code&gt;spring&lt;/code&gt; 및 &lt;code&gt;listen&lt;/code&gt; gem을 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="252ef08bae0df050b53b6a5779527ac92970980d" translate="yes" xml:space="preserve">
          <source>If you're using named routes, they can be easily tested using the original named routes' methods straight in the test case.</source>
          <target state="translated">명명 된 경로를 사용하는 경우 테스트 사례에서 직접 명명 된 경로의 방법을 사용하여 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf468826e965e22f66613dde40512c32eb5d1476" translate="yes" xml:space="preserve">
          <source>If you're using password input fields (for any purpose), you might want to configure your application to prevent those parameters from being logged. You can learn about this in the &lt;a href=&quot;security#logging&quot;&gt;Securing Rails Applications&lt;/a&gt; guide.</source>
          <target state="translated">암호 입력 필드를 사용하는 경우 (어떤 목적 으로든) 해당 매개 변수가 기록되지 않도록 응용 프로그램을 구성 할 수 있습니다. 이에 대한 내용은 &lt;a href=&quot;security#logging&quot;&gt;Securing Rails Applications&lt;/a&gt; 안내서 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6052169eaf1bc86bbca65ea47bc1eb643397b147" translate="yes" xml:space="preserve">
          <source>If you're writing a library or component that will invoke application code, you should wrap it with a call to the executor:</source>
          <target state="translated">애플리케이션 코드를 호출 할 라이브러리 또는 컴포넌트를 작성하는 경우 실행 프로그램을 호출하여 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="43117e0ed8eb687cc272466c40042620d7fe982e" translate="yes" xml:space="preserve">
          <source>If you're writing a web service application, you might find yourself more comfortable accepting parameters in JSON format. If the &quot;Content-Type&quot; header of your request is set to &quot;application/json&quot;, Rails will automatically load your parameters into the &lt;code&gt;params&lt;/code&gt; hash, which you can access as you would normally.</source>
          <target state="translated">웹 서비스 응용 프로그램을 작성하는 경우 JSON 형식의 매개 변수를보다 쉽게 ​​받아 들일 수 있습니다. 요청의 &quot;Content-Type&quot;헤더가 &quot;application / json&quot;으로 설정된 경우 Rails는 매개 &lt;code&gt;params&lt;/code&gt; 해시에 매개 변수를 자동으로로드하며 , 일반적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d4d5f61b556e519c6e1e2356999ce42a7ddf62c" translate="yes" xml:space="preserve">
          <source>If you've set specific values, they'll be left alone.</source>
          <target state="translated">특정 값을 설정하면 값이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="74869c5690f1f8df683db24bb30ead644f992f32" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;first&lt;/code&gt; will return the first record according to this ordering.</source>
          <target state="translated">귀하의 경우 &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;기본 범위는&lt;/a&gt; 주문 방법을 포함, &lt;code&gt;first&lt;/code&gt; 이 순서에 따라 첫 번째 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6835afd1c650ba01f41e5d358bf7f0e864950743" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;last&lt;/code&gt; will return the last record according to this ordering.</source>
          <target state="translated">&lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;기본 범위&lt;/a&gt; 에 주문 방법이 포함 된 경우 &lt;code&gt;last&lt;/code&gt; 는이 주문에 따라 마지막 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1caa7aca1cdb0d5b52aac0863cedc2558d775ff6" translate="yes" xml:space="preserve">
          <source>If your Capybara configuration requires more setup than provided by Rails, this additional configuration could be added into the &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file.</source>
          <target state="translated">Capybara 구성에 Rails에서 제공 한 것보다 더 많은 설정이 필요한 경우이 추가 구성을 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5682ba1adb63dcd899a9ab63cfa20e123e47b8a7" translate="yes" xml:space="preserve">
          <source>If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via +html()+. Most jQuery plugins do this. If that is the case, be sure to &lt;code&gt;html_escape&lt;/code&gt; or &lt;code&gt;sanitize&lt;/code&gt; any user-generated content returned by your JSON.</source>
          <target state="translated">JSON을 다운 스트림에 사용하여 DOM에 삽입하는 경우 + html () +를 통해 삽입되는지 여부를 알고 있어야합니다. 대부분의 jQuery 플러그인이이를 수행합니다. 이 경우 JSON에서 반환 한 사용자 생성 콘텐츠 를 &lt;code&gt;html_escape&lt;/code&gt; 하거나 &lt;code&gt;sanitize&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7fefdf5de1dd35d237a9b1901e9afd42363fae3" translate="yes" xml:space="preserve">
          <source>If your MySQL version is 5.5 or 5.6 and want to use the &lt;code&gt;utf8mb4&lt;/code&gt; character set by default, please configure your MySQL server to support the longer key prefix by enabling &lt;code&gt;innodb_large_prefix&lt;/code&gt; system variable.</source>
          <target state="translated">MySQL 버전이 5.5 또는 5.6이고 기본적으로 &lt;code&gt;utf8mb4&lt;/code&gt; 문자 세트 를 사용하려는 경우 &lt;code&gt;innodb_large_prefix&lt;/code&gt; 시스템 변수 를 활성화하여 더 긴 키 접 두부를 지원하도록 MySQL 서버를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ec6ed42547439a0457afd0ebebe94c88bd5fa87" translate="yes" xml:space="preserve">
          <source>If your application currently depends on MultiJSON directly, you have a few options:</source>
          <target state="translated">애플리케이션이 현재 MultiJSON에 직접 의존하는 경우 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0d95ee276b14edf1a42c9fa291547930f26681" translate="yes" xml:space="preserve">
          <source>If your application depends on one of these features, you can get them back by adding the &lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt;&lt;code&gt;activesupport-json_encoder&lt;/code&gt;&lt;/a&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램이 이러한 기능 중 하나에 의존하는 경우, 당신은 추가하여 그들을 다시 얻을 수 &lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt; &lt;code&gt;activesupport-json_encoder&lt;/code&gt; 의&lt;/a&gt; 당신에 보석을 &lt;code&gt;Gemfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="381e5230923304164bbcf6cb5cafb16c7ce7b7f7" translate="yes" xml:space="preserve">
          <source>If your application has STIs, please check their section in the guide &lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;Autoloading and Reloading Constants (Zeitwerk Mode)&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램에 STI가있는 경우 &lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;Autoloading and Reloading Constants (Zeitwerk Mode)&lt;/a&gt; 안내서에서 해당 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dbc5db49e45fcf4e2303c426327e0441f8dcc0b" translate="yes" xml:space="preserve">
          <source>If your application has complex routes, Rails provides a number of useful helpers to test them.</source>
          <target state="translated">애플리케이션에 복잡한 경로가있는 경우 Rails는 여러 가지 유용한 도우미를 제공하여 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e74a56a0c5eeea301a713680cbfd78e970264146" translate="yes" xml:space="preserve">
          <source>If your application has many RESTful routes, using &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; to generate only the routes that you actually need can cut down on memory use and speed up the routing process.</source>
          <target state="translated">응용 프로그램에 많은 RESTful 경로가있는 경우 &lt;code&gt;:only&lt;/code&gt; 및 &lt;code&gt;:except&lt;/code&gt; 를 사용하여 실제로 필요한 경로 만 생성하면 메모리 사용을 줄이고 라우팅 프로세스 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f0014e907848cfdeccd3b999808ddc2e11c394" translate="yes" xml:space="preserve">
          <source>If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and &lt;code&gt;command&lt;/code&gt;. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).</source>
          <target state="translated">응용 프로그램이 기본 운영 체제에서 명령을 실행해야하는 경우 Ruby에는 exec (command), syscall (command), system (command) 및 &lt;code&gt;command&lt;/code&gt; 와 같은 여러 가지 방법이 있습니다 . 사용자가 전체 명령 또는 그 일부를 입력 할 수있는 경우 이러한 기능에 특히주의해야합니다. 대부분의 쉘에서 첫 번째 명령의 끝에 다른 명령을 실행하여 세미콜론 (;) 또는 수직 막대 (|)로 연결할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="889c5891aad30eb8db5021e9ab63293d15ccf22f" translate="yes" xml:space="preserve">
          <source>If your application includes a locale switching menu, you would then have something like this in it:</source>
          <target state="translated">응용 프로그램에 로케일 전환 메뉴가 포함되어 있으면 다음과 같은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc86689b27dc32bd92136eda6001352ad0921b2" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.0.x, you should upgrade to Rails 3.0 before attempting an update to Rails 3.1.</source>
          <target state="translated">응용 프로그램이 현재 3.0.x 이전의 모든 Rails 버전에있는 경우 Rails 3.1로 업데이트하기 전에 Rails 3.0으로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="12223a67df42527d2cbff3ea72dd72f11fc7181b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.1.x, you should upgrade to Rails 3.1 before attempting an update to Rails 3.2.</source>
          <target state="translated">애플리케이션이 현재 3.1.x 이전의 모든 Rails 버전에있는 경우 Rails 3.2로 업데이트하기 전에 Rails 3.1로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf06afce41a26745cb148a584af6c8c383ba496b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.2.x, you should upgrade to Rails 3.2 before attempting one to Rails 4.0.</source>
          <target state="translated">애플리케이션이 현재 3.2.x 이전의 모든 Rails 버전에있는 경우 Rails 4.0으로 시도하기 전에 Rails 3.2로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="c90ef0b46bf42ed5bf642ff84f742f3bf3110011" translate="yes" xml:space="preserve">
          <source>If your application is deadlocking and you think the Load Interlock may be involved, you can temporarily add the ActionDispatch::DebugLocks middleware to &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 교착 상태이고로드 인터록이 관련되어 있다고 생각되면 ActionDispatch :: DebugLocks 미들웨어를 &lt;code&gt;config/application.rb&lt;/code&gt; 에 임시로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc2f17257706e28458d22e8b6cad9d03d6bad0a4" translate="yes" xml:space="preserve">
          <source>If your application is using an &quot;/assets&quot; route for a resource you may want to change the prefix used for assets to avoid conflicts:</source>
          <target state="translated">애플리케이션이 자원에 대해 &quot;/ 자산&quot;경로를 사용하는 경우 충돌을 피하기 위해 자산에 사용되는 접 두부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e05fa3e91e37b6cf6fa12bc4e688c1e6edaef466" translate="yes" xml:space="preserve">
          <source>If your application lived at &lt;code&gt;https://example.com&lt;/code&gt;, you would specify the fully-qualified URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;https://example.com&lt;/code&gt; 에있는 경우 완전한 URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7e4bd7dc0f0e490c584ba6f39585e2d67413ee59" translate="yes" xml:space="preserve">
          <source>If your application lives at &lt;code&gt;https://example.com&lt;/code&gt;, you would configure the Postfix SMTP server to pipe inbound emails to the following command:</source>
          <target state="translated">애플리케이션이 &lt;code&gt;https://example.com&lt;/code&gt; 에있는 경우 인바운드 이메일을 다음 명령으로 파이프하도록 Postfix SMTP 서버를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="daa1c9e216c9d8d165b0c33678ea2b6e0ff6a8b7" translate="yes" xml:space="preserve">
          <source>If your application needs to use the old sanitizer implementation, include &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 이전 소독제 구현을 사용해야하는 경우 &lt;code&gt;Gemfile&lt;/code&gt; 에 &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="1030747ba04510c35d637b99ad76753d7203e5a7" translate="yes" xml:space="preserve">
          <source>If your application stores nested configuration in &lt;code&gt;config/secrets.yml&lt;/code&gt;, all keys are now loaded as symbols, so access using strings should be changed.</source>
          <target state="translated">애플리케이션이 중첩 된 구성을 &lt;code&gt;config/secrets.yml&lt;/code&gt; 에 저장 하면 모든 키가 이제 심볼로로드되므로 문자열을 사용한 액세스를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8139193fb989ae2ed172e3931f636d721facb2c" translate="yes" xml:space="preserve">
          <source>If your application uses the top-level &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; class, you should slowly move your code to instead use &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에서 최상위 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 클래스를 사용하는 경우 &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; 대신 코드를 천천히 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="91af82fb39f605eb090b15525e992995690b6439" translate="yes" xml:space="preserve">
          <source>If your application was not updated to Rails 5.2 defaults, the secret_key_base will be found in the old &lt;code&gt;config/secrets.yml&lt;/code&gt; file.</source>
          <target state="translated">애플리케이션이 Rails 5.2 기본값으로 업데이트되지 않은 경우 secret_key_base는 이전 &lt;code&gt;config/secrets.yml&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9b2e447adcea9fbe7e2a9bd3bc168e61c635fb" translate="yes" xml:space="preserve">
          <source>If your application's secrets may have been exposed, strongly consider changing them. Changing &lt;code&gt;secret_key_base&lt;/code&gt; will expire currently active sessions.</source>
          <target state="translated">응용 프로그램의 비밀이 노출되었을 수 있으면 변경하는 것이 좋습니다. &lt;code&gt;secret_key_base&lt;/code&gt; 를 변경하면 현재 활성 세션이 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0a57381eea06e446a567dd408bdc093cbdd1ce" translate="yes" xml:space="preserve">
          <source>If your cache is on a shared infrastructure, you can define a namespace for your cache entries. If a namespace is defined, it will be prefixed on to every key. The namespace can be either a static value or a Proc. If it is a Proc, it will be invoked when each key is evaluated so that you can use application logic to invalidate keys.</source>
          <target state="translated">캐시가 공유 인프라에있는 경우 캐시 항목의 네임 스페이스를 정의 할 수 있습니다. 네임 스페이스가 정의되면 모든 키 앞에 접두사가 붙습니다. 네임 스페이스는 정적 값이거나 Proc 일 수 있습니다. Proc 인 경우, 각 키가 평가 될 때 호출되어 응용 프로그램 논리를 사용하여 키를 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ac4c43c45266924507181e8d1c66138e18a9e8" translate="yes" xml:space="preserve">
          <source>If your collection cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of a block that returns an array:</source>
          <target state="translated">컬렉션 캐시가 여러 소스에 의존하는 경우 (간단하게 유지하기 위해이를 피하려고 시도) 배열을 반환하는 블록의 일부로 이러한 모든 종속성의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b951b1cd4019d75cd33aff42a1e533f21ba16a6" translate="yes" xml:space="preserve">
          <source>If your controller has defined &lt;code&gt;@person&lt;/code&gt; and that person's city_id is 2:</source>
          <target state="translated">컨트롤러가 &lt;code&gt;@person&lt;/code&gt; 을 정의 하고 해당 사람의 city_id가 2 인 경우 :</target>
        </trans-unit>
        <trans-unit id="0aecaded96b353fb5bd5f694e20b8584a9b1d3a5" translate="yes" xml:space="preserve">
          <source>If your database supports setting the isolation level for a transaction, you can set it like so:</source>
          <target state="translated">데이터베이스가 트랜잭션의 격리 수준 설정을 지원하는 경우 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103ba4b31df0da57a8ec66f6aa656e1b132fd216" translate="yes" xml:space="preserve">
          <source>If your development database has a root user with an empty password, this configuration should work for you. Otherwise, change the username and password in the &lt;code&gt;development&lt;/code&gt; section as appropriate.</source>
          <target state="translated">개발 데이터베이스에 빈 암호를 가진 루트 사용자가있는 경우이 구성이 적합합니다. 그렇지 않으면 &lt;code&gt;development&lt;/code&gt; 섹션 에서 사용자 이름과 비밀번호 를 적절히 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c10c4f115be70f11c744ae41c96edb7a7107b4c" translate="yes" xml:space="preserve">
          <source>If your engine has migrations, you may also want to prepare data for the database in the &lt;code&gt;db/seeds.rb&lt;/code&gt; file. You can load that data using the &lt;code&gt;load_seed&lt;/code&gt; method, e.g.</source>
          <target state="translated">엔진에 마이그레이션이있는 경우 &lt;code&gt;db/seeds.rb&lt;/code&gt; 파일 에서 데이터베이스에 대한 데이터를 준비 할 수도 있습니다 . &lt;code&gt;load_seed&lt;/code&gt; 메소드를 사용하여 해당 데이터를로드 할 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="425cd983d81b837debf97e01070fc8dd942a349a" translate="yes" xml:space="preserve">
          <source>If your front-end server supports accelerated file sending, &lt;code&gt;Rack::Sendfile&lt;/code&gt; will offload the actual file sending work to the front-end server.</source>
          <target state="translated">프런트 엔드 서버가 파일 전송 가속화를 지원하는 경우 &lt;code&gt;Rack::Sendfile&lt;/code&gt; 은 실제 파일 전송 작업을 프런트 엔드 서버로 오프로드합니다.</target>
        </trans-unit>
        <trans-unit id="bd8111e3c285dfb7987c6fb762023306b9a5dc95" translate="yes" xml:space="preserve">
          <source>If your migration is irreversible, you should raise &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; from your &lt;code&gt;down&lt;/code&gt; method. If someone tries to revert your migration, an error message will be displayed saying that it can't be done.</source>
          <target state="translated">마이그레이션을 되돌릴 수없는 경우 &lt;code&gt;down&lt;/code&gt; 메소드 에서 &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; 을 높여야 합니다 . 누군가 마이그레이션을 되돌리려 고하면 수행 할 수 없다는 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c3382db198a7dd11c8954262ef38078bc5ca90" translate="yes" xml:space="preserve">
          <source>If your model does not act like an Active Model object, then you should define &lt;code&gt;:to_model&lt;/code&gt; yourself returning a proxy object that wraps your object with Active Model compliant methods.</source>
          <target state="translated">모델이 Active Model 객체처럼 작동하지 않으면 &lt;code&gt;:to_model&lt;/code&gt; 을 정의 하여 Active Model 호환 메소드로 객체를 래핑하는 프록시 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="76baa030465bac752869f817cdc6077b5aeb38ed" translate="yes" xml:space="preserve">
          <source>If your object is already designed to implement all of the Active Model you can use the default &lt;code&gt;:to_model&lt;/code&gt; implementation, which simply returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">객체가 이미 모든 활성 모델을 구현하도록 설계된 경우 기본 &lt;code&gt;:to_model&lt;/code&gt; 구현을 사용할 수 있으며 이는 단순히 &lt;code&gt;self&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="05b58e6bdf018a796fd3192e810a7a0d52af9a3b" translate="yes" xml:space="preserve">
          <source>If your railtie has Rake tasks, you can tell Rails to load them through the method &lt;code&gt;rake_tasks&lt;/code&gt;:</source>
          <target state="translated">railtie에 Rake 작업이있는 경우 rake_tasks 메소드를 통해 Rails &lt;code&gt;rake_tasks&lt;/code&gt; 를로드하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87a60c820f332d2130d62bec29e48f80d0781651" translate="yes" xml:space="preserve">
          <source>If your resource has associations defined, for example, you want to add comments to the document given that the routes are set correctly:</source>
          <target state="translated">예를 들어, 자원에 연관이 정의되어 있으면 경로가 올바르게 설정되어있는 경우 문서에 주석을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6fe760c48d59a5abc10b50357644a1cefa1de69d" translate="yes" xml:space="preserve">
          <source>If your route needs to respond to more than one HTTP method (or all methods) then using the &lt;code&gt;:via&lt;/code&gt; option on &lt;code&gt;match&lt;/code&gt; is preferable.</source>
          <target state="translated">경로가 둘 이상의 HTTP 메소드 (또는 모든 메소드)에 응답해야하는 경우 &lt;code&gt;match&lt;/code&gt; &lt;code&gt;:via&lt;/code&gt; 옵션 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14e98748b230ce1d3b61f7ea63fc8bfa9d1c5edb" translate="yes" xml:space="preserve">
          <source>If your system tests verify the deletion of a model with attachments and you're using Active Job, set your test environment to use the inline queue adapter so the purge job is executed immediately rather at an unknown time in the future.</source>
          <target state="translated">시스템 테스트에서 첨부 파일이있는 모델의 삭제를 확인하고 활성 작업을 사용중인 경우 나중에 알 수없는 시간에 제거 작업이 즉시 실행되도록 인라인 큐 어댑터를 사용하도록 테스트 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6bedd4e4c87ec197ef48f07fe917c09d9e5f5451" translate="yes" xml:space="preserve">
          <source>If your table/model specifies any of Active Record's standard timestamp columns (&lt;code&gt;created_at&lt;/code&gt;, &lt;code&gt;created_on&lt;/code&gt;, &lt;code&gt;updated_at&lt;/code&gt;, &lt;code&gt;updated_on&lt;/code&gt;), they will automatically be set to &lt;code&gt;Time.now&lt;/code&gt;.</source>
          <target state="translated">테이블 / 모델이 Active Record의 표준 타임 스탬프 열 ( &lt;code&gt;created_at&lt;/code&gt; , &lt;code&gt;created_on&lt;/code&gt; , &lt;code&gt;updated_at&lt;/code&gt; , &lt;code&gt;updated_on&lt;/code&gt; )을 지정하면 자동으로 &lt;code&gt;Time.now&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="582795cbf5201022212575a8a28b6d7709781eb4" translate="yes" xml:space="preserve">
          <source>If your template cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of an array:</source>
          <target state="translated">템플릿 캐시가 여러 소스에 의존하는 경우 (이를 피하기 위해 시도하지 마십시오) 이러한 모든 종속성의 이름을 배열의 일부로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40543e76d91d611a5ec9410b5887ffa0387c4560" translate="yes" xml:space="preserve">
          <source>If your test helper contains a call to &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; this can be removed. The check is now done automatically when you &lt;code&gt;require 'rails/test_help'&lt;/code&gt;, although leaving this line in your helper is not harmful in any way.</source>
          <target state="translated">테스트 도우미에 &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; 이것을 제거 할 수 있습니다. &lt;code&gt;require 'rails/test_help'&lt;/code&gt; 때 자동으로 검사가 수행 되지만, 도우미에이 줄을 남겨 두는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa870b38e91039a2c31c0ec518113cbf1f31ce8" translate="yes" xml:space="preserve">
          <source>If your translations are stored in YAML files, certain keys must be escaped. They are:</source>
          <target state="translated">번역이 YAML 파일에 저장된 경우 특정 키를 이스케이프해야합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="1185f54ced928c01b83f233ae5ac48bd71437bbc" translate="yes" xml:space="preserve">
          <source>If your user sessions don't store critical data or don't need to be around for long periods (for instance if you just use the flash for messaging), you can consider using &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt;. This will store sessions using the cache implementation you have configured for your application. The advantage of this is that you can use your existing cache infrastructure for storing sessions without requiring any additional setup or administration. The downside, of course, is that the sessions will be ephemeral and could disappear at any time.</source>
          <target state="translated">사용자 세션이 중요한 데이터를 저장하지 않거나 장시간 (예 : 메시징에 플래시를 사용하는 경우) 필요하지 않은 경우 &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt; 사용을 고려할 수 있습니다 . 응용 프로그램에 대해 구성한 캐시 구현을 사용하여 세션을 저장합니다. 이것의 장점은 추가 설정이나 관리없이 기존 캐시 인프라를 사용하여 세션을 저장할 수 있다는 것입니다. 물론 단점은 세션이 일시적이며 언제든지 사라질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c10b3295ac930c8b6d0186ae1b2fa25dca24d2a2" translate="yes" xml:space="preserve">
          <source>If your validator is complex enough that you want instance variables, you can easily use a plain old Ruby object instead:</source>
          <target state="translated">유효성 검사기가 인스턴스 변수를 원할 정도로 복잡하면 대신 일반 오래된 Ruby 객체를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afcb932a25203f1fddef75a94720d32694cde47f" translate="yes" xml:space="preserve">
          <source>If your web application is RESTful, you might be used to additional HTTP verbs, such as PATCH, PUT, or DELETE. Some legacy web browsers, however, do not support them - only GET and POST. Rails uses a hidden &lt;code&gt;_method&lt;/code&gt; field to handle these cases.</source>
          <target state="translated">웹 애플리케이션이 RESTful 인 경우 PATCH, PUT 또는 DELETE와 같은 추가 HTTP 동사에 사용될 수 있습니다. 그러나 일부 레거시 웹 브라우저는 지원하지 않으며 GET 및 POST 만 지원합니다. Rails는 숨겨진 &lt;code&gt;_method&lt;/code&gt; 필드를 사용하여 이러한 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="18ed34d58a9a3df6e8627865711db726b025acd9" translate="yes" xml:space="preserve">
          <source>If, in the case of this &lt;code&gt;includes&lt;/code&gt; query, there were no comments for any articles, all the articles would still be loaded. By using &lt;code&gt;joins&lt;/code&gt; (an INNER JOIN), the join conditions &lt;strong&gt;must&lt;/strong&gt; match, otherwise no records will be returned.</source>
          <target state="translated">&lt;code&gt;includes&lt;/code&gt; 쿼리가 포함 된 경우 기사에 대한 주석이 없으면 모든 기사가 계속로드됩니다. 사용하여 &lt;code&gt;joins&lt;/code&gt; (내부 조인)의 조건에 가입 &lt;strong&gt;해야한다&lt;/strong&gt; , 그렇지 않으면 레코드가 반환되지 않습니다, 일치합니다.</target>
        </trans-unit>
        <trans-unit id="00fef5983e69c04936b5e027592d449f0c9aa803" translate="yes" xml:space="preserve">
          <source>Image blobs can have variants that are the result of a set of transformations applied to the original. These variants are used to create thumbnails, fixed-size avatars, or any other derivative image from the original.</source>
          <target state="translated">이미지 블롭에는 원본에 적용된 일련의 변환의 결과 인 변형이있을 수 있습니다. 이러한 변형은 축소판 그림, 고정 크기 아바타 또는 원본의 다른 파생 이미지를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26464afe4467cfea083f888c397ad9db64fe0da" translate="yes" xml:space="preserve">
          <source>ImageMagick reference</source>
          <target state="translated">ImageMagick 참조</target>
        </trans-unit>
        <trans-unit id="6b547bf4fc75d103729ab2f9120fc708162824e6" translate="yes" xml:space="preserve">
          <source>ImageProcessing::MiniMagick</source>
          <target state="translated">ImageProcessing::MiniMagick</target>
        </trans-unit>
        <trans-unit id="bb1869013b3837865b83b826ba6cbc2f0478b949" translate="yes" xml:space="preserve">
          <source>ImageProcessing::Vips</source>
          <target state="translated">ImageProcessing::Vips</target>
        </trans-unit>
        <trans-unit id="e59410c44344783744ca127bd399b00f6c4b26d8" translate="yes" xml:space="preserve">
          <source>Images can also be organized into subdirectories if required, and then can be accessed by specifying the directory's name in the tag:</source>
          <target state="translated">필요한 경우 이미지를 하위 디렉토리로 구성한 다음 태그에 디렉토리 이름을 지정하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="042a141a97424ca18ce357d660b1f19cd18e6379" translate="yes" xml:space="preserve">
          <source>Imagine a restricted list deletes &quot;script&quot; from the user input. Now the attacker injects &quot;&amp;lt;scrscriptipt&amp;gt;&quot;, and after the filter, &quot;&amp;lt;script&amp;gt;&quot; remains. Earlier versions of Rails used a restricted list approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:</source>
          <target state="translated">제한된 목록이 사용자 입력에서 &quot;스크립트&quot;를 삭제한다고 상상해보십시오. 이제 공격자가 &quot;&amp;lt;scrscriptipt&amp;gt;&quot;을 삽입하고 필터 후에 &quot;&amp;lt;script&amp;gt;&quot;가 남아 있습니다. 이전 버전의 Rails는 strip_tags (), strip_links () 및 sanitize () 메소드에 대해 제한된 목록 접근 방식을 사용했습니다. 따라서 이런 종류의 주사가 가능했습니다.</target>
        </trans-unit>
        <trans-unit id="8b880b948b508d4c09c27dafc56f6c45e159ad52" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where you have parameters representing a product name and a hash of arbitrary data associated with that product, and you want to permit the product name attribute and also the whole data hash:</source>
          <target state="translated">제품 이름 및 해당 제품과 관련된 임의의 데이터 해시를 나타내는 매개 변수가 있고 제품 ​​이름 속성과 전체 데이터 해시를 허용하려는 시나리오를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="82efa8ca1d9a12ef2b518545653e0d364d47da15" translate="yes" xml:space="preserve">
          <source>Imagine that this template was in a file called &lt;code&gt;template.rb&lt;/code&gt;. We can use it to modify the outcome of the &lt;code&gt;rails new&lt;/code&gt; command by using the &lt;code&gt;-m&lt;/code&gt; option and passing in the filename:</source>
          <target state="translated">이 템플릿 파일이라는 있다는 상상 &lt;code&gt;template.rb&lt;/code&gt; . &lt;code&gt;-m&lt;/code&gt; 옵션 을 사용 하고 파일 이름을 전달 하여 &lt;code&gt;rails new&lt;/code&gt; 명령 의 결과를 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a23c9f6f0d6eb9b1c67997eb11e2e598caca6dc7" translate="yes" xml:space="preserve">
          <source>Imagine that you did have an asset located at &lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; To include this asset inside an application, just use &lt;code&gt;stylesheet_link_tag&lt;/code&gt; and reference the asset as if it were inside the engine:</source>
          <target state="translated">&lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; 에 자산이 있다고 상상해보십시오. 이 자산을 응용 프로그램에 포함 시키려면 &lt;code&gt;stylesheet_link_tag&lt;/code&gt; 를 사용 하고 엔진 내부에있는 것처럼 자산을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8d65f4b17f25607c90868e7031c68bab93f6d78" translate="yes" xml:space="preserve">
          <source>Imagine you have a series of users that you would like to display and provide a form on that same page to create a new user. The index action of your controller looks like this:</source>
          <target state="translated">같은 페이지에 새 사용자를 작성하기 위해 양식을 표시하고 제공하려는 일련의 사용자가 있다고 가정하십시오. 컨트롤러의 인덱스 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e96898b6501d3fbdcf2300804027e8c6693dd90" translate="yes" xml:space="preserve">
          <source>Imagine you have a server which mirrors the production environment but is only used for testing. Such a server is commonly called a &quot;staging server&quot;. To define an environment called &quot;staging&quot; for this server, just create a file called &lt;code&gt;config/environments/staging.rb&lt;/code&gt;. Please use the contents of any existing file in &lt;code&gt;config/environments&lt;/code&gt; as a starting point and make the necessary changes from there.</source>
          <target state="translated">프로덕션 환경을 미러링하지만 테스트에만 사용되는 서버가 있다고 가정하십시오. 이러한 서버를 일반적으로 &quot;스테이징 서버&quot;라고합니다. 이 서버에 &quot;staging&quot;이라는 환경을 정의하려면 &lt;code&gt;config/environments/staging.rb&lt;/code&gt; 파일을 작성하십시오 . &lt;code&gt;config/environments&lt;/code&gt; 에있는 기존 파일의 내용을 시작점으로 사용하고 필요한 부분을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0e1a932488fc0faaa2b295c30a9aa45876243c" translate="yes" xml:space="preserve">
          <source>Imagine you need to work with a legacy database containing the following table:</source>
          <target state="translated">다음 테이블이 포함 된 레거시 데이터베이스로 작업해야한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="6970d62a4e47823d1263b678a59e7b3be71b5a0c" translate="yes" xml:space="preserve">
          <source>Imagine you would like to delegate everything missing from the &lt;code&gt;User&lt;/code&gt; object, to the &lt;code&gt;Profile&lt;/code&gt; one. The &lt;code&gt;delegate_missing_to&lt;/code&gt; macro lets you implement this in a breeze:</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 객체 에서 누락 된 모든 것을 &lt;code&gt;Profile&lt;/code&gt; 객체 에 위임한다고 가정합니다 . &lt;code&gt;delegate_missing_to&lt;/code&gt; 의 매크로는 당신이 바람에이를 구현할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="592f461f8f650c9881d19434eb07cf55d51fcec5" translate="yes" xml:space="preserve">
          <source>Immediately forget this connection ever existed. Unlike disconnect!, this will not communicate with the server.</source>
          <target state="translated">이 연결이 존재한다는 것을 즉시 잊어 버리십시오. disconnect!와 달리 서버와 통신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ba4b37c409e259716fe6f3feb135d41b0df925d" translate="yes" xml:space="preserve">
          <source>Impact of Logs on Performance</source>
          <target state="translated">로그가 성능에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="3541319efbbc447409bc55f973fe6221e45917e9" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the analyzer can extract metadata.</source>
          <target state="translated">구체적인 서브 클래스에서이 메소드를 구현하십시오. 분석기가 메타 데이터를 추출 할 수있는 얼룩이 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6725be8193f353157ed48984e7bd46897dd0c798" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the previewer can generate an image.</source>
          <target state="translated">구체적인 서브 클래스에서이 메소드를 구현하십시오. 미리보기에서 이미지를 생성 할 수있는 얼룩이 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="900dd4ac67347484c1b41e0135def860124558d7" translate="yes" xml:space="preserve">
          <source>Implementing Support for Other Cloud Services</source>
          <target state="translated">다른 클라우드 서비스에 대한 지원 구현</target>
        </trans-unit>
        <trans-unit id="beca3b2271c9131a4132ecdb9e1400f3f98aaa03" translate="yes" xml:space="preserve">
          <source>Implementing a system test</source>
          <target state="translated">시스템 테스트 구현</target>
        </trans-unit>
        <trans-unit id="088e2ffa59238fae1077a6a98d6f816ed4781b79" translate="yes" xml:space="preserve">
          <source>Implementing an integration test</source>
          <target state="translated">통합 테스트 구현</target>
        </trans-unit>
        <trans-unit id="be2fc4a7e872958c1218af9bd0f7ec74151da4b2" translate="yes" xml:space="preserve">
          <source>Implements a hash where keys &lt;code&gt;:foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered to be the same.</source>
          <target state="translated">keys &lt;code&gt;:foo&lt;/code&gt; 와 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 가 같은 것으로 간주 되는 해시를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c613ef0456cfc282a210d9a952d24027a5dbe57d" translate="yes" xml:space="preserve">
          <source>Implements a mailer preview interceptor that converts image tag src attributes that use inline cid: style URLs to data: style URLs so that they are visible when previewing an HTML email in a web browser.</source>
          <target state="translated">인라인 cid : 스타일 URL을 데이터 : 스타일 URL로 사용하는 이미지 태그 src 속성을 웹 브라우저에서 HTML 이메일을 미리 볼 때 볼 수 있도록 변환하는 메일러 미리보기 인터셉터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="22d4e13f56409e0a39f90cdbbbdbcd9d6342ece8" translate="yes" xml:space="preserve">
          <source>Implements methods that allow rendering from a view context. In order to use this module, all you need is to implement view_renderer that returns an &lt;a href=&quot;../renderer&quot;&gt;ActionView::Renderer&lt;/a&gt; object.</source>
          <target state="translated">뷰 컨텍스트에서 렌더링 할 수있는 메소드를 구현합니다. 이 모듈을 사용하려면 &lt;a href=&quot;../renderer&quot;&gt;ActionView :: Renderer&lt;/a&gt; 객체 를 반환하는 view_renderer를 구현하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="24ec6605d9328a8008364cc4c4f420581b79a4a9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport::LogSubscriber&lt;/a&gt; for logging notifications when email is delivered or received.</source>
          <target state="translated">전자 메일이 배달되거나 수신 될 때 알림을 기록하기 위해 &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport :: LogSubscriber&lt;/a&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="52d6a97892d78e3ae869c7ed2c900dea4e6ebf61" translate="yes" xml:space="preserve">
          <source>Implements the logic behind &lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt;. See &lt;code&gt;rails notes --help&lt;/code&gt; for usage information.</source>
          <target state="translated">&lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt; 의 논리를 구현합니다 . 사용법 정보는 &lt;code&gt;rails notes --help&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d2e815ecf5eaeaf9463f97d49b56bdcf2cedef" translate="yes" xml:space="preserve">
          <source>Implicit Controller Namespacing</source>
          <target state="translated">암시 적 컨트롤러 이름 간격</target>
        </trans-unit>
        <trans-unit id="cc812dcbced753eec4dd16100a96e45f4f64caaa" translate="yes" xml:space="preserve">
          <source>Implicit dependencies</source>
          <target state="translated">암시 적 종속성</target>
        </trans-unit>
        <trans-unit id="4bc21b467c16e56b3af4d8560fc26cb749a105d4" translate="yes" xml:space="preserve">
          <source>Implicit template rendering is not performed if any attachments or parts have been added to the email. This means that you'll have to manually add each part to the email and set the content type of the email to &lt;code&gt;multipart/alternative&lt;/code&gt;.</source>
          <target state="translated">전자 메일에 첨부 파일이나 부품이 추가 된 경우 암시 적 템플릿 렌더링이 수행되지 않습니다. 즉, 전자 메일에 각 부분을 수동으로 추가하고 전자 메일의 콘텐츠 유형을 &lt;code&gt;multipart/alternative&lt;/code&gt; 로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4cf6d21cc8c3ec4dc1b9b1edae7488384d03d30c" translate="yes" xml:space="preserve">
          <source>ImplicitRender</source>
          <target state="translated">ImplicitRender</target>
        </trans-unit>
        <trans-unit id="d1638a243bdb748019bd32183a25a00764fdfe7e" translate="yes" xml:space="preserve">
          <source>Improper abstraction is shown in the following example, where assumptions are made about the ordering of the different parts of the translation. Note that Rails provides a &lt;code&gt;number_to_currency&lt;/code&gt; helper to handle the following case.</source>
          <target state="translated">번역의 다른 부분의 순서에 대한 가정이 만들어지는 다음 예에서 부적절한 추상화가 표시됩니다. Rails는 다음과 같은 경우를 처리하기 위해 &lt;code&gt;number_to_currency&lt;/code&gt; 도우미를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="25277a4e2d3aab7b020dc767c1fa2cdd12889e2b" translate="yes" xml:space="preserve">
          <source>Improving engine functionality</source>
          <target state="translated">엔진 기능 향상</target>
        </trans-unit>
        <trans-unit id="fae9a341e3cc54b88e5881c130771b3562076a34" translate="yes" xml:space="preserve">
          <source>In 2007 there was the first tailor-made trojan which stole information from an Intranet, namely the &quot;Monster for employers&quot; web site of Monster.com, an online recruitment web application. Tailor-made Trojans are very rare, so far, and the risk is quite low, but it is certainly a possibility and an example of how the security of the client host is important, too. However, the highest threat to Intranet and Admin applications are XSS and CSRF.</source>
          <target state="translated">2007 년에는 인트라넷, 즉 온라인 채용 웹 응용 프로그램 인 Monster.com의 &quot;Monster for 고용주&quot;웹 사이트에서 정보를 훔친 맞춤형 트로이 목마가있었습니다. 맞춤형 트로이 목마는 지금까지 매우 드물고 위험은 매우 낮지 만 클라이언트 호스트의 보안도 중요한 예일 것입니다. 그러나 인트라넷 및 관리 응용 프로그램에 가장 큰 위협은 XSS 및 CSRF입니다.</target>
        </trans-unit>
        <trans-unit id="459e6a935c80dde6e06ed67fe83a90bd9883c215" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode you could technically define several constants at the same top-level and have them all reloaded. For example, given</source>
          <target state="translated">&lt;code&gt;classic&lt;/code&gt; 모드 에서는 기술적으로 동일한 최상위에서 여러 상수를 정의하고 모두 다시로드 할 수 있습니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="542cf5e02cd8fb77390910ad4c46d85ca2ae6998" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode, if &lt;code&gt;app/models/foo.rb&lt;/code&gt; defines &lt;code&gt;Bar&lt;/code&gt;, you won't be able to autoload that file, but eager loading will work because it loads files recursively blindly. This can be a source of errors if you test things first eager loading, execution may fail later autoloading.</source>
          <target state="translated">에서 &lt;code&gt;classic&lt;/code&gt; 모드, 경우 &lt;code&gt;app/models/foo.rb&lt;/code&gt; 정의하는 &lt;code&gt;Bar&lt;/code&gt; , 해당 파일을 자동로드 할 수 없습니다, 그러나 반복적으로 맹목적으로 파일을로드하기 때문에 열망로드 작동합니다. 처음 열망하는 로딩을 테스트하면 나중에 오류가 발생할 수 있습니다. 나중에 자동 로딩이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c8108a5c9ee6932aeb4bd9a770d0dfa0e4b1c8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/application.rb&lt;/code&gt; add the following line at the top of the &lt;code&gt;Application&lt;/code&gt; class definition:</source>
          <target state="translated">에서 &lt;code&gt;config/application.rb&lt;/code&gt; 의 맨 위에 다음 줄을 추가 &lt;code&gt;Application&lt;/code&gt; 클래스 정의 :</target>
        </trans-unit>
        <trans-unit id="038e4733f3293952f2c69b8c06c72d61d56cd4cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, place the following line:</source>
          <target state="translated">에서 &lt;code&gt;config/environments/development.rb&lt;/code&gt; , 다음 줄을 배치합니다 :</target>
        </trans-unit>
        <trans-unit id="19a666179d9c9c5c55b760fb4bd295bdd2019cf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, set &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; to configure the format used in responses when errors occur in development mode.</source>
          <target state="translated">에서 &lt;code&gt;config/environments/development.rb&lt;/code&gt; , 세트 &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; 오류가 개발 모드에서 발생할 때 응답에 사용되는 형식을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1432a9900cff26dddc3080234094b35f280b42a8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/routes.rb&lt;/code&gt; you define URL-to-controller mappings, but the reverse is also possible: a URL can be generated from one of your routing definitions. URL generation functionality is centralized in this module.</source>
          <target state="translated">에서 &lt;code&gt;config/routes.rb&lt;/code&gt; 당신이 URL - 컨트롤러 매핑을 정의하지만, 그 반대도 가능하다 : URL이 라우팅 정의 중 하나를 생성 할 수 있습니다. URL 생성 기능은이 모듈에서 중앙 집중식입니다.</target>
        </trans-unit>
        <trans-unit id="1642945971bc58efcad1099a8a64f5268eb8322c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;lib/yaffle.rb&lt;/code&gt;, add &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;lib/yaffle.rb&lt;/code&gt; , 추가 &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e232716b6d62b50c947b184953eae7d056f56191" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode both loading modes are consistent, they fail and err in the same files.</source>
          <target state="translated">에서 &lt;code&gt;zeitwerk&lt;/code&gt; 모두 로딩 모드가 일치 모드, 그들은 같은 파일에 실패하고 ERR.</target>
        </trans-unit>
        <trans-unit id="e673fd939bb83dbf33354669755b6f6e9fd442c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode, Rails uses &lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt; internally to autoload, reload, and eager load. Rails instantiates and configures a dedicated Zeitwerk instance that manages the project.</source>
          <target state="translated">에서는 &lt;code&gt;zeitwerk&lt;/code&gt; 모드 사용 레일 &lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt; 자동로드, 장전하고 싶어 부하 내부적. Rails는 프로젝트를 관리하는 전용 Zeitwerk 인스턴스를 인스턴스화하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="71ea6f7b46d9cf92e4933e28e9d6bba26cdba1a8" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;development&lt;/strong&gt;, you want quicker startup with incremental loading of application code. So &lt;code&gt;eager_load&lt;/code&gt; should be set to &lt;code&gt;false&lt;/code&gt;, and Rails will autoload files as needed (see &lt;a href=&quot;#autoloading-algorithms&quot;&gt;Autoloading Algorithms&lt;/a&gt; below) -- and then reload them when they change (see &lt;a href=&quot;#constant-reloading&quot;&gt;Constant Reloading&lt;/a&gt; below).</source>
          <target state="translated">에서 &lt;strong&gt;개발&lt;/strong&gt; , 당신은 응용 프로그램 코드의 증가 로딩 빨리 시작합니다. 따라서 &lt;code&gt;eager_load&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 로 설정해야하며 Rails는 필요에 따라 파일을 &lt;a href=&quot;#autoloading-algorithms&quot;&gt;자동&lt;/a&gt; 로드하고 (아래의 자동로드 알고리즘 참조) 파일이 변경되면 다시로드합니다 (아래의 &lt;a href=&quot;#constant-reloading&quot;&gt;상수 다시로드&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="0f72170ee1c24d4c865ecf78482068999436ea7a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;production&lt;/strong&gt;, however, you want consistency and thread-safety and can live with a longer boot time. So &lt;code&gt;eager_load&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, and then during boot (before the app is ready to receive requests) Rails loads all files in the &lt;code&gt;eager_load_paths&lt;/code&gt; and then turns off auto loading (NB: autoloading may be needed during eager loading). Not autoloading after boot is a &lt;code&gt;good thing&lt;/code&gt;, as autoloading can cause the app to be have thread-safety problems.</source>
          <target state="translated">그러나 &lt;strong&gt;프로덕션 환경&lt;/strong&gt; 에서는 일관성과 스레드 안전성을 원하며 부팅 시간이 길어질 수 있습니다. 따라서 &lt;code&gt;eager_load&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 다음 부팅하는 동안 (앱이 요청을 수신 할 준비가되기 전에) Rails는 &lt;code&gt;eager_load_paths&lt;/code&gt; 에있는 모든 파일을로드 한 다음 자동로드를 끕니다 (NB : 자동로드가 열릴 때 필요할 수 있음). 자동로드 로 인해 앱에 스레드 안전성 문제가 발생할 수 있으므로 부팅 후 자동로드하지 않는 &lt;code&gt;good thing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f92b7014d8bd1687e9d67744b5d5dbfdfdc69342" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;test&lt;/strong&gt;, for speed of execution (of individual tests) &lt;code&gt;eager_load&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, so Rails follows development behaviour.</source>
          <target state="translated">&lt;strong&gt;test&lt;/strong&gt; 에서는 개별 테스트의 실행 속도에 대해 &lt;code&gt;eager_load&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이므로 Rails는 개발 동작을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="64bc7c7244baf7a888ec03c60f63bef901cae7ee" translate="yes" xml:space="preserve">
          <source>In App</source>
          <target state="translated">앱에서</target>
        </trans-unit>
        <trans-unit id="da5d6eae39d42acaf080e6551490223f993953d3" translate="yes" xml:space="preserve">
          <source>In December 2006, 34,000 actual user names and passwords were stolen in a &lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace phishing attack&lt;/a&gt;. The idea of the attack was to create a profile page named &quot;login_home_index_html&quot;, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.</source>
          <target state="translated">2006 년 12 월 &lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace 피싱 공격&lt;/a&gt; 에서 34,000 개의 실제 사용자 이름과 암호가 도난당했습니다 . 이 공격의 아이디어는 &quot;login_home_index_html&quot;이라는 프로필 페이지를 만드는 것이 었으므로 URL은 매우 설득력있게 보였습니다. 특수 제작 된 HTML 및 CSS를 사용하여 페이지에서 실제 MySpace 내용을 숨기고 대신 고유 한 로그인 양식을 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="95a2bb9868cd89f678d0493fad1f8fb986cade2e" translate="yes" xml:space="preserve">
          <source>In Development</source>
          <target state="translated">개발 중</target>
        </trans-unit>
        <trans-unit id="465280a3f4d120ddf717e03ed4ad4332c4473248" translate="yes" xml:space="preserve">
          <source>In JavaScript files, Sprockets directives begin with &lt;code&gt;//=&lt;/code&gt;. In the above case, the file is using the &lt;code&gt;require&lt;/code&gt; and the &lt;code&gt;require_tree&lt;/code&gt; directives. The &lt;code&gt;require&lt;/code&gt; directive is used to tell Sprockets the files you wish to require. Here, you are requiring the files &lt;code&gt;rails-ujs.js&lt;/code&gt; and &lt;code&gt;turbolinks.js&lt;/code&gt; that are available somewhere in the search path for Sprockets. You need not supply the extensions explicitly. Sprockets assumes you are requiring a &lt;code&gt;.js&lt;/code&gt; file when done from within a &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">JavaScript 파일에서 Sprockets 지시문은 &lt;code&gt;//=&lt;/code&gt; 로 시작합니다 . 위의 경우 파일은 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;require_tree&lt;/code&gt; 지시문을 사용합니다. 이 &lt;code&gt;require&lt;/code&gt; 지시어는 톱니에게 필요한하고자하는 파일을 얘기하는 데 사용됩니다. 여기, Sprockets 검색 경로 어딘가에있는 &lt;code&gt;rails-ujs.js&lt;/code&gt; 및 &lt;code&gt;turbolinks.js&lt;/code&gt; 파일이 필요합니다 . 확장명을 명시 적으로 제공 할 필요는 없습니다. 톱니는 당신이 필요로하는 가정 &lt;code&gt;.js&lt;/code&gt; 내에서 수행 할 때 파일 &lt;code&gt;.js&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="03f18111b3979ea4cddec4b3d6254c6c8812f51e" translate="yes" xml:space="preserve">
          <source>In Production</source>
          <target state="translated">생산 중</target>
        </trans-unit>
        <trans-unit id="881b52a0818476cf9a85f46aa68f0a3a1628f652" translate="yes" xml:space="preserve">
          <source>In Rails 3.0 and above, generators don't just look in the source root for templates, they also search for templates in other paths. And one of them is &lt;code&gt;lib/templates&lt;/code&gt;. Since we want to customize &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;, we can do that by simply making a template copy inside &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; with the name &lt;code&gt;helper.rb&lt;/code&gt;. So let's create that file with the following content:</source>
          <target state="translated">Rails 3.0 이상에서 제너레이터는 소스 루트에서 템플릿을 찾을뿐만 아니라 다른 경로에서 템플릿을 검색합니다. 그리고 그들 중 하나는 &lt;code&gt;lib/templates&lt;/code&gt; 입니다. 우리는 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; 를 커스터마이징하기를 원하기 때문에 &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; 안에 &lt;code&gt;helper.rb&lt;/code&gt; 라는 이름 으로 템플릿을 복사 하면 됩니다. 다음과 같은 내용으로 해당 파일을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="3d701b2dca3add4cb90f7c327e5b34c565ff6209" translate="yes" xml:space="preserve">
          <source>In Rails 4.0 when a column or a table is renamed the related indexes are also renamed. If you have migrations which rename the indexes, they are no longer needed.</source>
          <target state="translated">Rails 4.0에서 열 또는 테이블의 이름이 변경되면 관련 인덱스의 이름도 변경됩니다. 인덱스 이름을 바꾸는 마이그레이션이 있으면 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1adb17f63f770a578c9bd8dceb71a192376252bb" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; is raised when the action doesn't handle the request format. By default, the exception is handled by responding with 406 Not Acceptable, but you can override that now. In Rails 3, 406 Not Acceptable was always returned. No overrides.</source>
          <target state="translated">Rails 4.0에서는 액션이 요청 형식을 처리하지 않으면 &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; 이 발생합니다. 기본적으로 예외는 406 Not Acceptable로 응답하여 처리되지만 지금은이를 무시할 수 있습니다. Rails 3에서는 406 Not Acceptable이 항상 반환되었습니다. 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8c55c03013f5a72f0bf3f4390ebed968b1b748e" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; is properly nested when engines are mounted on an app that's served from a URL prefix. You no longer have to set &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; to work around overwritten URL prefixes.</source>
          <target state="translated">Rails 4.0에서 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 은 URL 접두사에서 제공되는 앱에 엔진이 마운트 될 때 올바르게 중첩됩니다. 덮어 쓴 URL 접두사를 해결하기 위해 더 이상 &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; 을 설정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fbd697524f2577109c25789402e832c69d562e7a" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, a generic &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; exception is raised when &lt;code&gt;ParamsParser&lt;/code&gt; fails to parse request params. You will want to rescue this exception instead of the low-level &lt;code&gt;MultiJson::DecodeError&lt;/code&gt;, for example.</source>
          <target state="translated">Rails 4.0에서는 &lt;code&gt;ParamsParser&lt;/code&gt; 가 요청 매개 변수를 구문 분석하지 못하면 일반 &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; 예외가 발생 합니다. 예를 들어, 하위 레벨 &lt;code&gt;MultiJson::DecodeError&lt;/code&gt; 대신이 예외를 해결하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2a1b06b5dc0aa44b96b3b0146a540533fa23c8d9" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, precompiling assets no longer automatically copies non-JS/CSS assets from &lt;code&gt;vendor/assets&lt;/code&gt; and &lt;code&gt;lib/assets&lt;/code&gt;. Rails application and engine developers should put these assets in &lt;code&gt;app/assets&lt;/code&gt; or configure &lt;code&gt;config.assets.precompile&lt;/code&gt;.</source>
          <target state="translated">Rails 4.0에서는 사전 컴파일 링 자산이 더 이상 &lt;code&gt;vendor/assets&lt;/code&gt; 및 &lt;code&gt;lib/assets&lt;/code&gt; 에서 비 JS / CSS 자산을 자동으로 복사하지 않습니다 . Rails 애플리케이션 및 엔진 개발자는 이러한 자산을 &lt;code&gt;app/assets&lt;/code&gt; 에 배치 하거나 &lt;code&gt;config.assets.precompile&lt;/code&gt; 을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e790cb94a07686a3cdc4c05781a0fcaefa57d168" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Job inherits from &lt;code&gt;ActiveJob::Base&lt;/code&gt;. In Rails 5.0, this behavior has changed to now inherit from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">Rails 4.2에서 활성 작업은 &lt;code&gt;ActiveJob::Base&lt;/code&gt; 에서 상속받습니다 . Rails 5.0에서는이 동작이 &lt;code&gt;ApplicationJob&lt;/code&gt; 에서 상속되도록 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3dd8df2469bc7ba82d934c36883ac1e21582a46d" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Record model inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. In Rails 5.0, all models inherit from &lt;code&gt;ApplicationRecord&lt;/code&gt;.</source>
          <target state="translated">Rails 4.2에서 Active Record 모델은 &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 에서 상속받습니다 . Rails 5.0에서는 모든 모델이 &lt;code&gt;ApplicationRecord&lt;/code&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="439d6d805d6bd1ed63fe14cf4cd328905a76b44e" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, when a 'before' callback returns &lt;code&gt;false&lt;/code&gt; in Active Record and Active Model, then the entire callback chain is halted. In other words, successive 'before' callbacks are not executed, and neither is the action wrapped in callbacks.</source>
          <target state="translated">Rails 4.2 에서 Active Record와 Active Model에서 'before'콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 전체 콜백 체인이 정지됩니다. 즉, 연속적인 '이전'콜백은 실행되지 않으며 콜백으로 래핑 된 작업도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7dce1a93bbd29712f2b1ec669334dfd3205ce7be" translate="yes" xml:space="preserve">
          <source>In Rails 5, the default log level for the production environment will be changed to &lt;code&gt;:debug&lt;/code&gt; (from &lt;code&gt;:info&lt;/code&gt;). To preserve the current default, add the following line to your &lt;code&gt;production.rb&lt;/code&gt;:</source>
          <target state="translated">Rails 5에서 프로덕션 환경의 기본 로그 레벨은 &lt;code&gt;:debug&lt;/code&gt; (from &lt;code&gt;:info&lt;/code&gt; ) 로 변경됩니다 . 현재 기본값을 유지하려면 &lt;code&gt;production.rb&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a17e8569da075383aacc8ee0799bf2cfe2223ce" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, how JSON/JSONB attributes are serialized and deserialized changed. Now, if you set a column equal to a &lt;code&gt;String&lt;/code&gt;, Active Record will no longer turn that string into a &lt;code&gt;Hash&lt;/code&gt;, and will instead only return the string. This is not limited to code interacting with models, but also affects &lt;code&gt;:default&lt;/code&gt; column settings in &lt;code&gt;db/schema.rb&lt;/code&gt;. It is recommended that you do not set columns equal to a &lt;code&gt;String&lt;/code&gt;, but pass a &lt;code&gt;Hash&lt;/code&gt; instead, which will be converted to and from a JSON string automatically.</source>
          <target state="translated">Rails 5.0에서는 JSON / JSONB 속성이 직렬화되고 역 직렬화되는 방식이 변경되었습니다. 이제 열을 &lt;code&gt;String&lt;/code&gt; 과 동일하게 설정하면 Active Record는 더 이상 해당 문자열을 &lt;code&gt;Hash&lt;/code&gt; 로 바꾸지 않고 대신 문자열 만 반환합니다. 이는 모델과 상호 작용하는 코드에만 국한되지 않고 &lt;code&gt;db/schema.rb&lt;/code&gt; 의 &lt;code&gt;:default&lt;/code&gt; 열 설정 에도 영향을줍니다 . 열을 &lt;code&gt;String&lt;/code&gt; 과 동일하게 설정하지 말고 대신 &lt;code&gt;Hash&lt;/code&gt; 를 전달 하면 JSON 문자열과 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8805a6baac81772ba5bc008724fb0e7b03fcbd7c" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, returning &lt;code&gt;false&lt;/code&gt; in an Active Record or Active Model callback will not have this side effect of halting the callback chain. Instead, callback chains must be explicitly halted by calling &lt;code&gt;throw(:abort)&lt;/code&gt;.</source>
          <target state="translated">Rails 5.0 에서, Active Record 또는 Active Model 콜백에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 콜백 체인을 정지시키는 부작용이 없습니다. 대신 &lt;code&gt;throw(:abort)&lt;/code&gt; 호출하여 콜백 체인을 명시 적으로 중지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ccfc486350477735c33b236b56a8f69a4fcc517" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, test cases will be executed in random order by default. In anticipation of this change, Rails 4.2 introduced a new configuration option &lt;code&gt;active_support.test_order&lt;/code&gt; for explicitly specifying the test ordering. This allows you to either lock down the current behavior by setting the option to &lt;code&gt;:sorted&lt;/code&gt;, or opt into the future behavior by setting the option to &lt;code&gt;:random&lt;/code&gt;.</source>
          <target state="translated">Rails 5.0에서는 테스트 케이스가 기본적으로 무작위 순서로 실행됩니다. 이러한 변경을 예상하여 Rails 4.2 는 테스트 순서를 명시 적으로 지정하기위한 새로운 구성 옵션 &lt;code&gt;active_support.test_order&lt;/code&gt; 를 도입했습니다 . 이를 통해 옵션을 &lt;code&gt;:sorted&lt;/code&gt; 로 설정하여 현재 동작을 잠 그거나 옵션을 &lt;code&gt;:random&lt;/code&gt; 으로 설정하여 향후 동작을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b0c195e1af271ce415b466ef143019d7676d6f1" translate="yes" xml:space="preserve">
          <source>In Rails 5.2, assigning to a collection of attachments declared with &lt;code&gt;has_many_attached&lt;/code&gt; appended new files:</source>
          <target state="translated">Rails 5.2에서 &lt;code&gt;has_many_attached&lt;/code&gt; 로 선언 된 첨부 파일 컬렉션에 할당 된 새 파일 :</target>
        </trans-unit>
        <trans-unit id="a6731ddb55b6a64f0e9f7cfc11759cdbf65ec568" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs and controller actions. By convention, each action also maps to particular CRUD operations in a database. A single entry in the routing file, such as</source>
          <target state="translated">Rails에서 유용한 경로는 HTTP 동사와 URL과 컨트롤러 작업 간의 매핑을 제공합니다. 일반적으로 각 작업은 데이터베이스의 특정 CRUD 작업에도 매핑됩니다. 라우팅 파일의 단일 항목 (예 :</target>
        </trans-unit>
        <trans-unit id="a77466629531af636135628e6426524916605e5c" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to a specific CRUD operation in a database. A single entry in the routing file, such as:</source>
          <target state="translated">Rails에서 유용한 경로는 HTTP 동사와 URL을 컨트롤러 작업에 매핑합니다. 일반적으로 각 작업은 데이터베이스의 특정 CRUD 작업에 매핑됩니다. 라우팅 파일에서 다음과 같은 단일 항목 :</target>
        </trans-unit>
        <trans-unit id="8c3a8caddd6cd9e897f742a979983edd518e3c9b" translate="yes" xml:space="preserve">
          <source>In Rails, an &lt;em&gt;association&lt;/em&gt; is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code. For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books. Without associations, the model declarations would look like this:</source>
          <target state="translated">레일에서, &lt;em&gt;협회는&lt;/em&gt; 두 개의 액티브 레코드 모델 사이의 연결입니다. 왜 모델 사이에 연관이 필요합니까? 코드에서 일반적인 작업을 더 간단하고 쉽게 할 수 있기 때문입니다. 예를 들어, 저자 모델과 책 모델을 포함하는 간단한 Rails 애플리케이션을 생각해보십시오. 각 저자는 많은 책을 가질 수 있습니다. 연관이 없으면 모델 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56e83cf4d25c00dd476d47cc56bf04c7705eec09" translate="yes" xml:space="preserve">
          <source>In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view.</source>
          <target state="translated">Rails에서 컨트롤러의 다양한 동작 테스트는 기능 테스트 작성의 한 형태입니다. 컨트롤러는 애플리케이션으로 들어오는 웹 요청을 처리하고 결국 렌더링 된 뷰로 응답합니다. 기능 테스트를 작성할 때 조치가 요청 및 예상 결과 또는 응답 (일부 경우 HTML보기)을 처리하는 방법을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0d6b371170194bc0f26caa23ed54b666ace3efba" translate="yes" xml:space="preserve">
          <source>In Rails, this is usually achieved by creating the form using &lt;code&gt;form_for&lt;/code&gt; and a number of related helper methods. &lt;code&gt;form_for&lt;/code&gt; generates an appropriate &lt;code&gt;form&lt;/code&gt; tag and yields a form builder object that knows the model the form is about. Input fields are created by calling methods defined on the form builder, which means they are able to generate the appropriate names and default values corresponding to the model attributes, as well as convenient IDs, etc. Conventions in the generated field names allow controllers to receive form data nicely structured in &lt;code&gt;params&lt;/code&gt; with no effort on your side.</source>
          <target state="translated">Rails에서는 일반적으로 &lt;code&gt;form_for&lt;/code&gt; 및 여러 관련 헬퍼 메소드를 사용하여 양식을 작성합니다 . &lt;code&gt;form_for&lt;/code&gt; 는 적절한 &lt;code&gt;form&lt;/code&gt; 태그를 생성하고 양식의 모델을 알고있는 양식 작성기 객체를 생성합니다. 입력 필드는 양식 빌더에 정의 된 메소드를 호출하여 작성됩니다. 즉, 모델 ID에 해당하는 적절한 이름과 기본값 및 편리한 ID 등을 생성 할 수 있습니다. 생성 된 필드 이름의 규칙은 컨트롤러가 수신 할 수 있도록합니다. 당신의 노력없이 &lt;code&gt;params&lt;/code&gt; 로 잘 구조화 된 양식 데이터 .</target>
        </trans-unit>
        <trans-unit id="ecb88f5d832e7f6682e1a0ae438d564ee40bc97a" translate="yes" xml:space="preserve">
          <source>In Rails, web requests are handled by &lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt; and Action View. Typically, Action Controller is concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response.</source>
          <target state="translated">Rails에서 웹 요청은 &lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt; 및 Action View에 의해 처리됩니다 . 일반적으로 Action Controller는 데이터베이스와 통신하고 필요한 경우 CRUD 조치를 수행합니다. 그런 다음 조치보기는 응답을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="0f84e8f7f3343be9781b8755e807fc7655f5753f" translate="yes" xml:space="preserve">
          <source>In Ruby &amp;lt; 2.5 &lt;code&gt;String::Hash&lt;/code&gt; evaluates to &lt;code&gt;Hash&lt;/code&gt; and the interpreter issues a warning: &quot;toplevel constant Hash referenced by String::Hash&quot;. Starting with 2.5, &lt;code&gt;String::Hash&lt;/code&gt; raises &lt;code&gt;NameError&lt;/code&gt; because &lt;code&gt;Object&lt;/code&gt; is skipped.</source>
          <target state="translated">루비에서 &amp;lt;2.5 &lt;code&gt;String::Hash&lt;/code&gt; 로 평가 &lt;code&gt;Hash&lt;/code&gt; 및 통역 문제 경고 : &quot;문자열 :: 해시에 의해 참조 최상위 상수 해시&quot;. 2.5부터 &lt;code&gt;String::Hash&lt;/code&gt; 제기 &lt;code&gt;NameError&lt;/code&gt; 하기 때문에 &lt;code&gt;Object&lt;/code&gt; 를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a7a30f953cf4d0929d1f4865a5b10c5e1cf44ed0" translate="yes" xml:space="preserve">
          <source>In a Rails application file names have to match the constants they define, with directories acting as namespaces.</source>
          <target state="translated">Rails 애플리케이션에서 파일 이름은 네임 스페이스 역할을하는 디렉토리와 함께 정의한 상수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7eee8371ad89288909147fa07191ccefaa0c267" translate="yes" xml:space="preserve">
          <source>In a Rails application, add or remove analyzers by manipulating &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; in an initializer:</source>
          <target state="translated">Rails 애플리케이션 에서 초기화 &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; 에서 Rails.application.config.active_storage.analyzer 를 조작하여 분석기를 추가하거나 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="a752f21ee54a6f792635342e300e65ca1f47dbd3" translate="yes" xml:space="preserve">
          <source>In a Rails console there is no file watcher active regardless of the value of &lt;code&gt;config.cache_classes&lt;/code&gt;. This is so because, normally, it would be confusing to have code reloaded in the middle of a console session, the same way you generally want an individual request to be served by a consistent, non-changing set of application classes and modules.</source>
          <target state="translated">Rails 콘솔에는 &lt;code&gt;config.cache_classes&lt;/code&gt; 값에 관계없이 활성화 된 파일 감시자가 없습니다 . 일반적으로 콘솔 세션 중간에 코드를 다시로드하는 것이 혼란 스럽기 때문에 일관되고 변경되지 않는 응용 프로그램 클래스 및 모듈 세트에서 개별 요청을 처리하는 것과 같은 방식입니다.</target>
        </trans-unit>
        <trans-unit id="271d126f8c9e0941ba1c5dcf24c8eee1adaeb3af" translate="yes" xml:space="preserve">
          <source>In a default Rails application, the Executor callbacks are used to:</source>
          <target state="translated">기본 Rails 애플리케이션에서 Executor 콜백은 다음을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1f399aa9a761173b4354a91df7a1e6d6783267" translate="yes" xml:space="preserve">
          <source>In a given request, the method is not actually called for every single generated URL; for performance reasons, the returned hash is cached, there is at most one invocation per request.</source>
          <target state="translated">주어진 요청에서, 메소드는 실제로 생성 된 모든 단일 URL에 대해 호출되지 않습니다. 성능상의 이유로, 리턴 된 해시가 캐시되며 요청 당 최대 하나의 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a3fb5ca85e3e7566828c53420b6eec7802c016" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program classes need to load their dependencies:</source>
          <target state="translated">일반적인 루비 프로그램에서 클래스는 의존성을로드해야합니다</target>
        </trans-unit>
        <trans-unit id="6bd2c46748362d10f7e077a4a3b403485446d896" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program, dependencies need to be loaded by hand. For example, the following controller uses classes &lt;code&gt;ApplicationController&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt;, and normally you'd need to put &lt;code&gt;require&lt;/code&gt; calls for them:</source>
          <target state="translated">일반적인 Ruby 프로그램에서는 종속성을 직접로드해야합니다. 예를 들어 다음 컨트롤러는 &lt;code&gt;ApplicationController&lt;/code&gt; 및 &lt;code&gt;Post&lt;/code&gt; 클래스를 사용 하며 일반적으로 &lt;code&gt;require&lt;/code&gt; 호출을해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac0a2911ec6534ec9248c4c1ae1f11192066c33e" translate="yes" xml:space="preserve">
          <source>In a sense, applications need to eager load STI hierarchies regardless of the loading mode.</source>
          <target state="translated">어떤 의미에서 애플리케이션은로드 모드에 관계없이로드 STI 계층을 열망해야합니다.</target>
        </trans-unit>
        <trans-unit id="492e74f0c484a235e0b7869c9c63fccdba258011" translate="yes" xml:space="preserve">
          <source>In a standard Rails application, there's a &lt;code&gt;Gemfile&lt;/code&gt; which declares all dependencies of the application. &lt;code&gt;config/boot.rb&lt;/code&gt; sets &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; to the location of this file. If the &lt;code&gt;Gemfile&lt;/code&gt; exists, then &lt;code&gt;bundler/setup&lt;/code&gt; is required. The require is used by Bundler to configure the load path for your Gemfile's dependencies.</source>
          <target state="translated">표준 Rails 애플리케이션에는 애플리케이션의 모든 종속성을 선언 하는 &lt;code&gt;Gemfile&lt;/code&gt; 이 있습니다. &lt;code&gt;config/boot.rb&lt;/code&gt; 는 &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; 을이 파일의 위치로 설정합니다. &lt;code&gt;Gemfile&lt;/code&gt; 이 존재 하면 번 들러 &lt;code&gt;bundler/setup&lt;/code&gt; 이 필요합니다. Bundler는 Gemfile의 종속성에 대한로드 경로를 구성하기 위해 require를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2efca34d821f10fdc65229cd31d319da2be59d15" translate="yes" xml:space="preserve">
          <source>In a template for Advertiser#account:</source>
          <target state="translated">Advertiser # account의 템플릿에서 :</target>
        </trans-unit>
        <trans-unit id="52490bd34ae0086f95f318727490682f974da3a4" translate="yes" xml:space="preserve">
          <source>In a view:</source>
          <target state="translated">보기에서 :</target>
        </trans-unit>
        <trans-unit id="e2736192c03ed00ff774577997cd5dbd2315c098" translate="yes" xml:space="preserve">
          <source>In above examples &quot;dear&quot; gets cut first, but then &lt;code&gt;:separator&lt;/code&gt; prevents it.</source>
          <target state="translated">위의 예에서 &quot;dear&quot;가 먼저 잘린 다음 &lt;code&gt;:separator&lt;/code&gt; 가이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="9ac475981d36c18878c748709fd215ea0991ca21" translate="yes" xml:space="preserve">
          <source>In addition to &quot;before&quot; filters, you can also run filters after an action has been executed, or both before and after.</source>
          <target state="translated">&quot;이전&quot;필터 외에도 작업이 실행 된 후 또는 전후에 필터를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9f9d35b8c646e0ba939b09862711d8f92f46954" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt; and &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast&lt;/a&gt;, it declares a method for all attributes with the &lt;code&gt;*_before_type_cast&lt;/code&gt; suffix.</source>
          <target state="translated">&lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt; 및 &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast&lt;/a&gt; 외에도 &lt;code&gt;*_before_type_cast&lt;/code&gt; 접미어 가있는 모든 속성에 대한 메소드를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="c19c7591f28c7db08cef693a8cc1a57e75f0daf1" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AbstractController::UrlFor&lt;/code&gt;, this module accesses the HTTP layer to define URL options like the &lt;code&gt;host&lt;/code&gt;. In order to do so, this module requires the host class to implement &lt;code&gt;env&lt;/code&gt; which needs to be Rack-compatible and &lt;code&gt;request&lt;/code&gt; which is either an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; or an object that responds to the &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;optional_port&lt;/code&gt;, &lt;code&gt;protocol&lt;/code&gt; and &lt;code&gt;symbolized_path_parameter&lt;/code&gt; methods.</source>
          <target state="translated">이 모듈 은 &lt;code&gt;AbstractController::UrlFor&lt;/code&gt; 외에도 HTTP 계층에 액세스하여 &lt;code&gt;host&lt;/code&gt; 와 같은 URL 옵션을 정의 합니다 . 이를 위해,이 모듈 구현하기 위해 호스트 클래스를 필요로 &lt;code&gt;env&lt;/code&gt; 랙 호환 할 필요가 &lt;code&gt;request&lt;/code&gt; 의 어느 쪽의 인스턴스 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 또는 개체를 그에게 응답 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;optional_port&lt;/code&gt; , &lt;code&gt;protocol&lt;/code&gt; 및 &lt;code&gt;symbolized_path_parameter&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="0c8406462341f19d778a61e152839741ecc45929" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;polymorphic_url&lt;/code&gt; and &lt;code&gt;polymorphic_path&lt;/code&gt; methods, a number of prefixed helpers are available as a shorthand to &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; in options. Those are:</source>
          <target state="translated">&lt;code&gt;polymorphic_url&lt;/code&gt; 및 &lt;code&gt;polymorphic_path&lt;/code&gt; 메소드 외에도 옵션에서 &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; 의 약어로 많은 접두사 헬퍼를 사용할 수 있습니다. 사람들은:</target>
        </trans-unit>
        <trans-unit id="4f7e1642dcfee5fa1064709f46ea588c41a50fed" translate="yes" xml:space="preserve">
          <source>In addition to being available in the database, the fixture's data may also be accessed by using a special dynamic method, which has the same name as the model.</source>
          <target state="translated">데이터베이스에서 사용할 수있을뿐만 아니라 모델과 이름이 같은 특수한 동적 방법을 사용하여 조명기의 데이터에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef8b9864032ee34f35123efed8c80f6525320f5" translate="yes" xml:space="preserve">
          <source>In addition to resource routing, Rails has powerful support for routing arbitrary URLs to actions. Here, you don't get groups of routes automatically generated by resourceful routing. Instead, you set up each route separately within your application.</source>
          <target state="translated">Rails는 리소스 라우팅 외에도 임의의 URL을 액션으로 라우팅하는 기능을 강력하게 지원합니다. 여기에서는 리소스가 많은 라우팅에 의해 자동으로 생성 된 경로 그룹을 얻지 못합니다. 대신 응용 프로그램 내에서 각 경로를 별도로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6fb5ad3102fed665dc6fd095dfd966ded3fa35b8" translate="yes" xml:space="preserve">
          <source>In addition to that, Bootsnap needs to disable the iseq cache due to a bug in the interpreter if running Ruby 2.5. Please make sure to depend on at least Bootsnap 1.4.4 in that case.</source>
          <target state="translated">또한 Ruby 2.5를 실행하는 경우 부트 스냅은 인터프리터의 버그로 인해 iseq 캐시를 비활성화해야합니다. 이 경우 최소한 Bootsnap 1.4.4에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f0707640817a2197a7219d2ab7981419f6d589b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;:include_blank&lt;/code&gt; option documented above, this method also supports a &lt;code&gt;:model&lt;/code&gt; option, which defaults to &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport::TimeZone&lt;/a&gt;. This may be used by users to specify a different time zone model object. (See &lt;code&gt;time_zone_options_for_select&lt;/code&gt; for more information.)</source>
          <target state="translated">받는 사람 또한 &lt;code&gt;:include_blank&lt;/code&gt; 위의 문서화 된 옵션이 방법은 또한 지원 &lt;code&gt;:model&lt;/code&gt; 에있는 기본 설정 옵션, &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport :: 시간대를&lt;/a&gt; . 사용자가 다른 시간대 모델 개체를 지정하는 데 사용할 수 있습니다. (자세한 내용은 &lt;code&gt;time_zone_options_for_select&lt;/code&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7f2aa54d391ee44ae00e7344e86d409d232deb52" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;valid?&lt;/code&gt; and &lt;code&gt;invalid?&lt;/code&gt; methods covered earlier, Rails provides a number of methods for working with the &lt;code&gt;errors&lt;/code&gt; collection and inquiring about the validity of objects.</source>
          <target state="translated">&lt;code&gt;valid?&lt;/code&gt; 것 외에도 ? 및 &lt;code&gt;invalid?&lt;/code&gt; 앞에서 설명한 방법을 통해 Rails는 &lt;code&gt;errors&lt;/code&gt; 수집 작업과 객체의 유효성에 대한 여러 가지 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="b25623f60c158c6ebcefbfc797a4eee78412b2c9" translate="yes" xml:space="preserve">
          <source>In addition to the above special tags, you can supply a final hash of standard HTML options, such as &lt;code&gt;:class&lt;/code&gt;, &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:name&lt;/code&gt;:</source>
          <target state="translated">위의 특수 태그 외에도 &lt;code&gt;:class&lt;/code&gt; , &lt;code&gt;:id&lt;/code&gt; 또는 &lt;code&gt;:name&lt;/code&gt; 과 같은 표준 HTML 옵션의 최종 해시를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed198b3314abe269e0167da41dc4271ec9cb08d" translate="yes" xml:space="preserve">
          <source>In addition to the basic accessors, query methods are also automatically available on the Active Record object. Query methods allow you to test whether an attribute value is present. Additionally, when dealing with numeric values, a query method will return false if the value is zero.</source>
          <target state="translated">기본 접근 자 외에도 쿼리 메서드는 Active Record 개체에서 자동으로 사용할 수 있습니다. 쿼리 방법을 사용하면 속성 값이 있는지 테스트 할 수 있습니다. 또한 숫자 값을 처리 할 때 값이 0이면 쿼리 메서드가 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0a66c08aa6f98ab67dbdc0e69a533f42cbcb5ab" translate="yes" xml:space="preserve">
          <source>In addition to the model, Rails has also made a migration to create the corresponding database table:</source>
          <target state="translated">모델 외에도 Rails는 해당 데이터베이스 테이블을 생성하기 위해 마이그레이션을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="659fec6072497b31e669b6f4a5b72d04e9dbb1f8" translate="yes" xml:space="preserve">
          <source>In addition to the routes for magazines, this declaration will also route ads to an &lt;code&gt;AdsController&lt;/code&gt;. The ad URLs require a magazine:</source>
          <target state="translated">잡지에 대한 경로 &lt;code&gt;AdsController&lt;/code&gt; 선언은 광고를 AdsController로 라우팅합니다 . 광고 URL에는 잡지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="273d8d34d0d9b7f29ca3c0db3edc85ecc0178162" translate="yes" xml:space="preserve">
          <source>In addition to the standard testing helpers, inheriting from &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.</source>
          <target state="translated">표준 테스트 도우미 외에도 &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; 에서 상속 하면 통합 테스트를 작성할 때 사용할 수있는 추가 도우미가 함께 제공됩니다. 우리가 선택할 수있는 세 가지 도우미 범주에 대해 간단히 소개하겠습니다.</target>
        </trans-unit>
        <trans-unit id="3b76cd292632a3d6bbb2d48a3be80cc0143dce1a" translate="yes" xml:space="preserve">
          <source>In addition to these specific assertions, you also have easy access to various collections that the regular test/unit assertions can be used against. These collections are:</source>
          <target state="translated">이러한 특정 어설 션 외에도 정기적 인 테스트 / 단위 어설 션을 사용할 수있는 다양한 컬렉션에 쉽게 액세스 할 수 있습니다. 이 컬렉션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f54b6c933dbdba4d46f41b497b370c4dc86bcb9" translate="yes" xml:space="preserve">
          <source>In addition to using the routing helpers, Rails can also create paths and URLs from an array of parameters. For example, suppose you have this set of routes:</source>
          <target state="translated">Rails는 라우팅 헬퍼를 사용하는 것 외에도 다양한 파라미터로부터 경로와 URL을 생성 할 수 있습니다. 예를 들어 다음과 같은 경로 집합이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9a489e96256e076ad81bed57e5b930cbe1f34754" translate="yes" xml:space="preserve">
          <source>In addition to using the standard template helpers provided, creating custom helpers to extract complicated logic or reusable functionality is strongly encouraged. By default, each controller will include all helpers. These helpers are only accessible on the controller through &lt;code&gt;#helpers&lt;/code&gt;</source>
          <target state="translated">제공된 표준 템플릿 헬퍼를 사용하는 것 외에도 복잡한 로직 또는 재사용 가능한 기능을 추출하는 사용자 정의 헬퍼를 작성하는 것이 좋습니다. 기본적으로 각 컨트롤러에는 모든 도우미가 포함됩니다. 이 도우미는 &lt;code&gt;#helpers&lt;/code&gt; 를 통해서만 컨트롤러에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a653052b951c629d3ca791ef6bf869c9d73b3cf7" translate="yes" xml:space="preserve">
          <source>In addition, default connection parameters of libpq can be set per environment variables. See &lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html&lt;/a&gt; .</source>
          <target state="translated">또한 환경 변수마다 libpq의 기본 연결 매개 변수를 설정할 수 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86eb91ad68dda50198619f27072e415d3a33306a" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and flow through a predefined raise/rescue flow to end up as a &lt;code&gt;400 Bad Request&lt;/code&gt; with no effort.</source>
          <target state="translated">또한 매개 변수를 필요에 따라 표시하고 사전 정의 된 상승 / 구조 흐름을 통해 흐르면 노력없이 &lt;code&gt;400 Bad Request&lt;/code&gt; 으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37cf4de850ab31fd45274bd24911679d02a7c120" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and will flow through a predefined raise/rescue flow that will result in a 400 Bad Request being returned if not all required parameters are passed in.</source>
          <target state="translated">또한 매개 변수는 필요에 따라 표시 될 수 있으며 사전 정의 된 상승 / 구조 흐름을 통해 흐르므로 필요한 모든 매개 변수가 전달되지 않을 경우 400 잘못된 요청이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e0d6f445342011a367c696c83fbd3cd58f1a98" translate="yes" xml:space="preserve">
          <source>In addition, the code takes advantage of some of the methods available for an association. We use the &lt;code&gt;create&lt;/code&gt; method on &lt;code&gt;@article.comments&lt;/code&gt; to create and save the comment. This will automatically link the comment so that it belongs to that particular article.</source>
          <target state="translated">또한이 코드는 연결에 사용할 수있는 일부 방법을 활용합니다. 의견을 작성하고 저장하기 위해 &lt;code&gt;@article.comments&lt;/code&gt; 의 &lt;code&gt;create&lt;/code&gt; 메소드를 사용합니다 . 주석이 해당 특정 기사에 속하도록 자동으로 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5e264b6df4bc7992f34cc32e3948724826c818" translate="yes" xml:space="preserve">
          <source>In all of these cases, if you don't provide the leading host (&lt;code&gt;http://www.example.com&lt;/code&gt;), Rails will take those details from the current request.</source>
          <target state="translated">이 모든 경우에 주요 호스트 ( &lt;code&gt;http://www.example.com&lt;/code&gt; )를 제공하지 않으면 Rails는 현재 요청에서 세부 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e3b2d56224656c1d716fe11607fdcc52c7fafa15" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;belongs_to&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;association&lt;/code&gt; 은 &lt;code&gt;belongs_to&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호로 대체됩니다 . 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="0267e786c3a2473c923ff186544a4fe59a3bc697" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_one&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;association&lt;/code&gt; 은 &lt;code&gt;has_one&lt;/code&gt; 의 첫 번째 인수로 전달 된 기호로 대체됩니다 . 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="4228a39194d9fa678da42b335b025a8551d95b8d" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_and_belongs_to_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;collection&lt;/code&gt; 은 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호 로 대체 되고 &lt;code&gt;collection_singular&lt;/code&gt; 는 해당 기호의 단일화 된 버전으로 대체됩니다. 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="3664f08539ac9bbd1f271c61e976c587e1e5dc16" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;collection&lt;/code&gt; 은 &lt;code&gt;has_many&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호 로 대체 되고 &lt;code&gt;collection_singular&lt;/code&gt; 는 해당 기호의 단일화 된 버전으로 대체됩니다. 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="76ba7bee8ae02e8825975013dd94ae4e48597265" translate="yes" xml:space="preserve">
          <source>In all other environments, we look for it first in &lt;a href=&quot;application&quot;&gt;ENV&lt;/a&gt;, then credentials.secret_key_base, and finally secrets.secret_key_base. For most applications, the correct place to store it is in the encrypted credentials file.</source>
          <target state="translated">다른 모든 환경에서는 &lt;a href=&quot;application&quot;&gt;ENV&lt;/a&gt; 에서 먼저 찾은 다음 credentials.secret_key_base, secrets.secret_key_base를 찾습니다 . 대부분의 응용 프로그램의 경우 올바른 위치는 암호화 된 자격 증명 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="000084df2bdb044e5363d197d064db2690bafce1" translate="yes" xml:space="preserve">
          <source>In another template for Advertiser#buy, we could have:</source>
          <target state="translated">Advertiser # buy의 다른 템플릿에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4870aa44e6a6abc63d2b0ec3e900a2aa278eff45" translate="yes" xml:space="preserve">
          <source>In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.</source>
          <target state="translated">어쨌든 Rails는 외래 키 열을 생성하지 않습니다. 마이그레이션의 일부로 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d11d79019970af8991b8284f111043aec00e832" translate="yes" xml:space="preserve">
          <source>In application.rb.</source>
          <target state="translated">application.rb에서.</target>
        </trans-unit>
        <trans-unit id="9c59320d50acb675849eb2769c537ff63243a3c9" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; of the wrapping DOM element are automatically generated, following naming conventions encapsulated by the &lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt; methods &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt; and &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt;:</source>
          <target state="translated">두 경우 모두에서, &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; 권취 DOM 요소 자동 캡슐화 명명 규칙에 따라 생성된다 &lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt; 방법 &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt; 및 &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="668c56622e7f9451f33d9f93e487e3ef6506b55c" translate="yes" xml:space="preserve">
          <source>In broad strokes, this involves deciding what should be sent as the response and calling an appropriate method to create that response. If the response is a full-blown view, Rails also does some extra work to wrap the view in a layout and possibly to pull in partial views. You'll see all of those paths later in this guide.</source>
          <target state="translated">광범위한 스트로크에서는 응답으로 보낼 대상을 결정하고 해당 메소드를 작성하기 위해 적절한 메소드를 호출해야합니다. 응답이 본격적인 뷰인 경우 Rails는 뷰를 레이아웃으로 감싸고 부분 뷰를 가져 오기 위해 추가 작업을 수행합니다. 이 가이드의 뒷부분에서 이러한 경로를 모두 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04c0e7fc642bc09b37b52db8f26f85e840c7be4" translate="yes" xml:space="preserve">
          <source>In case &lt;a href=&quot;core#method-c-configurations&quot;&gt;ActiveRecord::Base.configurations&lt;/a&gt; is set (Rails automatically loads the contents of config/database.yml into it), a symbol can also be given as argument, representing a key in the configuration hash:</source>
          <target state="translated">경우 &lt;a href=&quot;core#method-c-configurations&quot;&gt;액티브 :: Base.configurations이&lt;/a&gt; (레일은 자동으로 부하를 설정 / database.yml을 그것에의 내용을) 설정, 기호는 구성 해시의 키를 나타내는 인수로 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2914a351943b11d907ce8804814e83c9455d5f5b" translate="yes" xml:space="preserve">
          <source>In case if you don't want the helper to generate this hidden field you can specify &lt;code&gt;include_hidden: false&lt;/code&gt; option.</source>
          <target state="translated">도우미가이 숨겨진 필드를 생성하지 못하게하려면 &lt;code&gt;include_hidden: false&lt;/code&gt; 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53b57a67e8f0b195f0c2f8ec972106aabad30b2f" translate="yes" xml:space="preserve">
          <source>In case of collision the key in the hash of the argument wins in &lt;code&gt;merge&lt;/code&gt;. You can support option hashes with default values in a compact way with this idiom:</source>
          <target state="translated">충돌이 발생하면 인수 해시의 키가 &lt;code&gt;merge&lt;/code&gt; 에서 승리 합니다. 이 관용구를 사용하여 기본값으로 옵션 해시를 간결하게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5747e87b6b5262401689f735501c016f96edb770" translate="yes" xml:space="preserve">
          <source>In case of key collision, the value will be the one most recently inserted into the hash:</source>
          <target state="translated">키 충돌의 경우 값은 가장 최근에 해시에 삽입 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="ead9150d71466c198079df9606375a348f7545f7" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;reselect&lt;/code&gt; clause is not used,</source>
          <target state="translated">경우에 &lt;code&gt;reselect&lt;/code&gt; 절은 사용하지 않습니다,</target>
        </trans-unit>
        <trans-unit id="b99031f5395107cae850a34182a86c583a5e8bbc" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;rewhere&lt;/code&gt; clause is not used,</source>
          <target state="translated">경우에 &lt;code&gt;rewhere&lt;/code&gt; 의 절은 사용하지 않습니다,</target>
        </trans-unit>
        <trans-unit id="1b52403da0263fbc97fea21478c66a6efee34f30" translate="yes" xml:space="preserve">
          <source>In case there are multiple transactional callbacks as seen below, the order is reversed.</source>
          <target state="translated">아래와 같이 여러 트랜잭션 콜백이있는 경우 주문이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="635a341b8073e09a13f08f7515b6ef51d59d28df" translate="yes" xml:space="preserve">
          <source>In case you do need to use this directly, it's instantiated using a hash of transformations where the key is the command and the value is the arguments. Example:</source>
          <target state="translated">이것을 직접 사용해야하는 경우 키가 명령이고 값이 인수 인 변환 해시를 사용하여 인스턴스화됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="ab38fdbdc2be5e311392ae9dec66807dbc33331a" translate="yes" xml:space="preserve">
          <source>In classic mode, constant autoloading is not thread-safe, though Rails has locks in place for example to make web requests thread-safe when autoloading is enabled, as it is common in &lt;code&gt;development&lt;/code&gt; mode.</source>
          <target state="translated">클래식 모드에서는 지속적인 자동 로딩이 스레드로부터 안전하지는 않지만 &lt;code&gt;development&lt;/code&gt; 모드 에서 일반적으로 사용되는 자동 로딩이 활성화 된 경우 웹 요청을 스레드로부터 안전하도록 레일에 잠금이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="72a6c46a95f9b3a44f98f5f588dade7b6ceb8aa0" translate="yes" xml:space="preserve">
          <source>In designing a data model, you will sometimes find a model that should have a relation to itself. For example, you may want to store all employees in a single database model, but be able to trace relationships such as between manager and subordinates. This situation can be modeled with self-joining associations:</source>
          <target state="translated">데이터 모델을 설계 할 때 때때로 자신과 관련이있는 모델을 찾을 수 있습니다. 예를 들어 모든 직원을 단일 데이터베이스 모델로 저장하고 관리자와 부하 직원 간의 관계를 추적 할 수 있습니다. 이 상황은 자체 결합 연관을 사용하여 모델링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd40f53ba75e011c7a28f5ec65b729053cc27ab" translate="yes" xml:space="preserve">
          <source>In development and test, this is randomly generated and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;.</source>
          <target state="translated">개발 및 테스트에서 이는 무작위로 생성되어 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 의 임시 파일에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dc3433693fc4166beebd7acff85f8551ec0ef84" translate="yes" xml:space="preserve">
          <source>In development mode (which is what you're working in by default), Rails reloads your application with every browser request, so there's no need to stop and restart the web server when a change is made.</source>
          <target state="translated">개발 모드 (기본적으로 작업중인 모드)에서 Rails는 모든 브라우저 요청에 따라 애플리케이션을 다시로드하므로 변경시 웹 서버를 중지했다가 다시 시작할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cbbe35a8e7fc2586eee8dc5f2c42cbf40cb2cdf" translate="yes" xml:space="preserve">
          <source>In development mode, assets are served as separate files in the order they are specified in the manifest file.</source>
          <target state="translated">개발 모드에서 자산은 매니페스트 파일에 지정된 순서대로 별도의 파일로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d0117c9022aff8e1edf96d1640e0ef23c9aa8e0c" translate="yes" xml:space="preserve">
          <source>In development mode, or if the asset pipeline is disabled, when these files are requested they are processed by the processors provided by the &lt;code&gt;coffee-script&lt;/code&gt; and &lt;code&gt;sass&lt;/code&gt; gems and then sent back to the browser as JavaScript and CSS respectively. When asset pipelining is enabled, these files are preprocessed and placed in the &lt;code&gt;public/assets&lt;/code&gt; directory for serving by either the Rails app or web server.</source>
          <target state="translated">개발 모드에서 또는 자산 파이프 라인이 비활성화 된 경우 이러한 파일이 요청되면 &lt;code&gt;coffee-script&lt;/code&gt; 및 &lt;code&gt;sass&lt;/code&gt; gem 에서 제공하는 프로세서에서 처리 한 다음 각각 JavaScript 및 CSS로 브라우저로 다시 보냅니다. 자산 파이프 라이닝이 활성화되면 이러한 파일은 사전 처리 되어 Rails 앱 또는 웹 서버에서 제공 할 수 있도록 &lt;code&gt;public/assets&lt;/code&gt; 디렉토리에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="3786ad74fa4fe0940b68fbf7d2f8c00871af10e7" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use &lt;code&gt;scope&lt;/code&gt;. In the last case, the following paths map to &lt;code&gt;ArticlesController&lt;/code&gt;:</source>
          <target state="translated">이러한 각 경우에 명명 된 경로는 &lt;code&gt;scope&lt;/code&gt; 를 사용하지 않은 것과 동일하게 유지 됩니다 . 마지막 경우 다음 경로는 &lt;code&gt;ArticlesController&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc0da6ec76022c06eb655cd87ccef507cdb3d8d8" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use scope. In the last case, the following paths map to &lt;code&gt;PostsController&lt;/code&gt;:</source>
          <target state="translated">이러한 각 경우에 명명 된 경로는 범위를 사용하지 않은 것과 동일하게 유지됩니다. 마지막 경우 다음 경로는 &lt;code&gt;PostsController&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="d609cba35afc0d9cbede9275222dd86903f0402f" translate="yes" xml:space="preserve">
          <source>In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The &lt;code&gt;request&lt;/code&gt; method contains an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; and the &lt;code&gt;response&lt;/code&gt; method returns a response object representing what is going to be sent back to the client.</source>
          <target state="translated">모든 컨트롤러에는 현재 실행중인 요청주기와 관련된 요청 및 응답 객체를 가리키는 두 가지 접근 자 메서드가 있습니다. &lt;code&gt;request&lt;/code&gt; 방법은 인스턴스 포함 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 과 &lt;code&gt;response&lt;/code&gt; 응답 객체가 클라이언트로 전송 될 것입니다 무엇을 나타내는 방법을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10d1c3f7b24ff0cd15fba1526043f7d57ca81a41" translate="yes" xml:space="preserve">
          <source>In fact, in the BooksController class, inside of the update action where we want to render the edit template if the book does not update successfully, all of the following render calls would all render the &lt;code&gt;edit.html.erb&lt;/code&gt; template in the &lt;code&gt;views/books&lt;/code&gt; directory:</source>
          <target state="translated">실제로 BooksController 클래스에서 책이 성공적으로 업데이트되지 않은 경우 편집 템플릿을 렌더링하려는 업데이트 작업 내에서 다음 렌더링 호출은 모두 &lt;code&gt;views/books&lt;/code&gt; 에서 &lt;code&gt;edit.html.erb&lt;/code&gt; 템플릿을 렌더링합니다. 예배 규칙서:</target>
        </trans-unit>
        <trans-unit id="2a136ee58e677ffa9a8948ad3664e874d61587d7" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;options&lt;/code&gt; method here does quite a lot. This method is defined in &lt;code&gt;Rack::Server&lt;/code&gt; like this:</source>
          <target state="translated">사실, 여기 의 &lt;code&gt;options&lt;/code&gt; 방법은 상당히 많이합니다. 이 방법은 &lt;code&gt;Rack::Server&lt;/code&gt; 과 같이 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abd53ed7ec9bbce4777f7ebf39b859fff4f5d42f" translate="yes" xml:space="preserve">
          <source>In fact, the result string is wrapped in an instance of &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt;.</source>
          <target state="translated">실제로 결과 문자열은 &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt; 인스턴스에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e8382f13be7db86341dbb74cd26348b30c534d2" translate="yes" xml:space="preserve">
          <source>In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the &lt;code&gt;Comment&lt;/code&gt; model (app/models/comment.rb) that makes each comment belong to an Article:</source>
          <target state="translated">실제로 이것은 Rails가이 연관성을 선언하는 데 사용하는 구문과 매우 유사합니다. &lt;code&gt;Comment&lt;/code&gt; 모델 (app / models / comment.rb)에서 각 주석이 기사에 속하도록하는 코드 줄을 이미 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="cdd8ad375719e4ab6835063d47e1a972802da964" translate="yes" xml:space="preserve">
          <source>In general there is no such thing as plug-n-play security. Security depends on the people using the framework, and sometimes on the development method. And it depends on all layers of a web application environment: The back-end storage, the web server, and the web application itself (and possibly other layers or applications).</source>
          <target state="translated">일반적으로 플러그 앤 플레이 보안은 없습니다. 보안은 프레임 워크를 사용하는 사람과 개발 방법에 따라 다릅니다. 또한 백엔드 스토리지, 웹 서버 및 웹 애플리케이션 자체 (및 기타 계층 또는 애플리케이션)와 같은 웹 애플리케이션 환경의 모든 계층에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7859df51f6b2aa1d976967648705ec81c4e55e0c" translate="yes" xml:space="preserve">
          <source>In general, Rails encourages using resources objects instead of declaring routes manually. For more information about routing, see &lt;a href=&quot;routing&quot;&gt;Rails Routing from the Outside In&lt;/a&gt;.</source>
          <target state="translated">일반적으로 Rails는 경로를 수동으로 선언하는 대신 자원 객체를 사용하도록 권장합니다. 라우팅에 대한 자세한 내용은 &lt;a href=&quot;routing&quot;&gt;외부에서 레일 라우팅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50540acc55f3de829c0940388140fb1e249e65eb" translate="yes" xml:space="preserve">
          <source>In general, applications do not need to use the API of Zeitwerk directly. Rails sets things up according to the existing contract: &lt;code&gt;config.autoload_paths&lt;/code&gt;, &lt;code&gt;config.cache_classes&lt;/code&gt;, etc.</source>
          <target state="translated">일반적으로 응용 프로그램은 Zeitwerk의 API를 직접 사용할 필요가 없습니다. Rails는 기존 계약에 따라 설정합니다 : &lt;code&gt;config.autoload_paths&lt;/code&gt; , &lt;code&gt;config.cache_classes&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="009e5cde90877d092ff3fb64ff8f83cd2b9360b9" translate="yes" xml:space="preserve">
          <source>In general, editing existing migrations is not a good idea. You will be creating extra work for yourself and your co-workers and cause major headaches if the existing version of the migration has already been run on production machines. Instead, you should write a new migration that performs the changes you require. Editing a freshly generated migration that has not yet been committed to source control (or, more generally, which has not been propagated beyond your development machine) is relatively harmless.</source>
          <target state="translated">일반적으로 기존 마이그레이션을 편집하는 것은 좋지 않습니다. 기존 버전의 마이그레이션이 이미 프로덕션 시스템에서 실행 된 경우 자신과 동료를 위해 추가 작업을 작성하고 심각한 두통을 유발할 수 있습니다. 대신 필요한 변경을 수행하는 새 마이그레이션을 작성해야합니다. 아직 소스 제어를 수행하지 않은 (또는 일반적으로 개발 시스템을 넘어 전파되지 않은) 새로 생성 된 마이그레이션을 편집하는 것은 상대적으로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="cfa4f37960ac63db4c1e0581d458aa91965fd49b" translate="yes" xml:space="preserve">
          <source>In general, the work of configuring Rails means configuring the components of Rails, as well as configuring Rails itself. The configuration file &lt;code&gt;config/application.rb&lt;/code&gt; and environment-specific configuration files (such as &lt;code&gt;config/environments/production.rb&lt;/code&gt;) allow you to specify the various settings that you want to pass down to all of the components.</source>
          <target state="translated">일반적으로 Rails 구성 작업은 Rails 자체 구성뿐만 아니라 Rails 구성 요소 구성도 의미합니다. 구성 파일 &lt;code&gt;config/application.rb&lt;/code&gt; 및 환경 별 구성 파일 (예 : &lt;code&gt;config/environments/production.rb&lt;/code&gt; )을 사용하면 모든 구성 요소에 전달할 다양한 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba2b0f04d81bdf445c82110d1b2a735d4926f1c" translate="yes" xml:space="preserve">
          <source>In general, this approach is far less reliable than using the language header and is not recommended for most web applications.</source>
          <target state="translated">일반적으로이 방법은 언어 헤더를 사용하는 것보다 훨씬 덜 안정적이며 대부분의 웹 응용 프로그램에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05d3f7c12b05724d16ed0c24ed8019b8a5ebfbc8" translate="yes" xml:space="preserve">
          <source>In general, views will be rendered in the &lt;code&gt;main&lt;/code&gt; layout</source>
          <target state="translated">일반적으로 뷰는 &lt;code&gt;main&lt;/code&gt; 레이아웃 으로 렌더링됩니다</target>
        </trans-unit>
        <trans-unit id="561ed79dc42d8cf5921bed84b25cc1b1d859875b" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; methods to constrain a route to a particular verb. You can use the &lt;code&gt;match&lt;/code&gt; method with the &lt;code&gt;:via&lt;/code&gt; option to match multiple verbs at once:</source>
          <target state="translated">일반적으로 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 메소드를 사용하여 특정 동사에 대한 경로를 제한해야합니다. &lt;code&gt;match&lt;/code&gt; 메소드를 &lt;code&gt;:via&lt;/code&gt; 옵션 과 함께 사용하여 여러 동사를 한 번에 일치 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bd774faaf94fcd3bfa62b756b86b0055c4640b8" translate="yes" xml:space="preserve">
          <source>In many cases you will want to wrap the above in another helper, so you could do something like the following:</source>
          <target state="translated">대부분의 경우 위의 내용을 다른 도우미로 감싸서 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4038dff4cecd3f066b2d24d2f7447a5cd95089" translate="yes" xml:space="preserve">
          <source>In many languages &amp;mdash; including English &amp;mdash; there are only two forms, a singular and a plural, for a given string, e.g. &quot;1 message&quot; and &quot;2 messages&quot;. Other languages (&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;Arabic&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;Japanese&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;Russian&lt;/a&gt; and many more) have different grammars that have additional or fewer &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural forms&lt;/a&gt;. Thus, the I18n API provides a flexible pluralization feature.</source>
          <target state="translated">영어를 포함한 많은 언어에서는 주어진 문자열에 대해 단수형과 복수형, 즉 &quot;1 메시지&quot;와 &quot;2 메시지&quot;의 두 가지 형식 만 있습니다. 다른 언어 ( &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;아랍어&lt;/a&gt; , &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;일본어&lt;/a&gt; , &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;러시아어&lt;/a&gt; 등)는 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;복수형&lt;/a&gt; 이 추가되거나 적은 문법이 다릅니다 . 따라서 I18n API는 유연한 복수 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="80fd14ee0705f257e5f31eb4d9dd647ce74d257c" translate="yes" xml:space="preserve">
          <source>In many of the examples just shown, the &lt;code&gt;:model&lt;/code&gt; passed to &lt;code&gt;form_with&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;. It corresponds to a set of RESTful routes, most likely defined via &lt;code&gt;resources&lt;/code&gt; in &lt;code&gt;config/routes.rb&lt;/code&gt;.</source>
          <target state="translated">방금 표시된 많은 예제 에서 &lt;code&gt;form_with&lt;/code&gt; 로 전달 된 &lt;code&gt;:model&lt;/code&gt; 은 &lt;em&gt;resource&lt;/em&gt; 입니다. &lt;code&gt;config/routes.rb&lt;/code&gt; 의 &lt;code&gt;resources&lt;/code&gt; 을 통해 정의 된 RESTful 라우트 세트에 해당합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ef665603c985acc7fe36f2e58ee464bdd2d68" translate="yes" xml:space="preserve">
          <source>In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using &lt;code&gt;create_table&lt;/code&gt;, &lt;code&gt;add_index&lt;/code&gt;, and so on.</source>
          <target state="translated">여러면에서 이것은 정확히 무엇입니까. 이 파일은 데이터베이스를 검사하고 &lt;code&gt;create_table&lt;/code&gt; , &lt;code&gt;add_index&lt;/code&gt; 등을 사용하여 구조를 표현하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1503f11656b8d1ff7d917aa789c3193af3aea8f" translate="yes" xml:space="preserve">
          <source>In most cases form controls will be tied to a specific model and as you might expect Rails provides helpers tailored for that purpose. Consistent with other form helpers, when dealing with a model object drop the &lt;code&gt;_tag&lt;/code&gt; suffix from &lt;code&gt;select_tag&lt;/code&gt;:</source>
          <target state="translated">대부분의 경우 양식 컨트롤은 특정 모델에 연결되며 Rails는 해당 목적에 맞는 도우미를 제공합니다. 다른 폼 헬퍼와 일치하여 모델 객체를 다룰 때 &lt;code&gt;select_tag&lt;/code&gt; 에서 &lt;code&gt;_tag&lt;/code&gt; 접미사를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="283fed243a06178888cb8100163ceca9e14989cb" translate="yes" xml:space="preserve">
          <source>In most cases, fetching large number of records can be performed efficiently using the &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; methods. See &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; for more information.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt; 메서드를 사용하여 많은 수의 레코드를 효율적으로 가져올 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a148fbaa7aee69002a1ac5f21efa423a9e3c30e" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;ActionController::Base#render&lt;/code&gt; method does the heavy lifting of rendering your application's content for use by a browser. There are a variety of ways to customize the behavior of &lt;code&gt;render&lt;/code&gt;. You can render the default view for a Rails template, or a specific template, or a file, or inline code, or nothing at all. You can render text, JSON, or XML. You can specify the content type or HTTP status of the rendered response as well.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;ActionController::Base#render&lt;/code&gt; 메소드는 브라우저에서 사용할 수 있도록 애플리케이션 컨텐츠를 렌더링하는 작업을 많이 수행합니다. &lt;code&gt;render&lt;/code&gt; 의 동작을 사용자 정의하는 다양한 방법이 있습니다 . Rails 템플릿, 특정 템플릿, 파일 또는 인라인 코드에 대한 기본 뷰를 렌더링하거나 전혀 렌더링하지 않을 수 있습니다. 텍스트, JSON 또는 XML을 렌더링 할 수 있습니다. 렌더링 된 응답의 컨텐츠 유형 또는 HTTP 상태도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="845cacdf9af459c9ecab3fe3b4510b4778e6725a" translate="yes" xml:space="preserve">
          <source>In most database systems, on selecting fields with &lt;code&gt;distinct&lt;/code&gt; from a result set using methods like &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;pluck&lt;/code&gt; and &lt;code&gt;ids&lt;/code&gt;; the &lt;code&gt;order&lt;/code&gt; method will raise an &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; exception unless the field(s) used in &lt;code&gt;order&lt;/code&gt; clause are included in the select list. See the next section for selecting fields from the result set.</source>
          <target state="translated">대부분의 데이터베이스 시스템에서 &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;pluck&lt;/code&gt; 및 &lt;code&gt;ids&lt;/code&gt; 와 같은 메소드를 사용하여 결과 세트 와 &lt;code&gt;distinct&lt;/code&gt; 되는 필드를 선택합니다 . &lt;code&gt;order&lt;/code&gt; 방법은 올릴 것이다 &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; 에 사용되는 필드 (들)하지 않는 예외를 &lt;code&gt;order&lt;/code&gt; 절을 선택 목록에 포함되어 있습니다. 결과 집합에서 필드를 선택하려면 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cb5f676660b8c29fc4145374c10ee3d76b54507" translate="yes" xml:space="preserve">
          <source>In order for this example to work, you have to add the PDF MIME type to Rails. This can be done by adding the following line to the file &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt;:</source>
          <target state="translated">이 예제가 작동하려면 PDF MIME 유형을 Rails에 추가해야합니다. &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 파일에 다음 줄을 추가하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="1c259d151655b1917e97acadee79d5579af946a0" translate="yes" xml:space="preserve">
          <source>In order to change engine's priority you can use &lt;code&gt;config.railties_order&lt;/code&gt; in the main application. It will affect the priority of loading views, helpers, assets, and all the other files related to engine or application.</source>
          <target state="translated">엔진 우선 순위를 변경하기 위해 기본 애플리케이션에서 &lt;code&gt;config.railties_order&lt;/code&gt; 를 사용할 수 있습니다 . 뷰, 도우미, 자산 및 엔진 또는 응용 프로그램과 관련된 다른 모든 파일의 우선 순위에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f7199abd7ed7d1a2fbcfd4e2d260b9e8d6a648b3" translate="yes" xml:space="preserve">
          <source>In order to correctly invalidate the cache, you need to properly define the caching dependencies. Rails is clever enough to handle common cases so you don't have to specify anything. However, sometimes, when you're dealing with custom helpers for instance, you need to explicitly define them.</source>
          <target state="translated">캐시를 올바르게 무효화하려면 캐싱 종속성을 올바르게 정의해야합니다. Rails는 일반적인 경우를 처리하기에 충분히 영리하므로 아무 것도 지정할 필요가 없습니다. 그러나 때로는 예를 들어 사용자 지정 도우미를 처리 할 때 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0a530ba61d4811b2b142c8b4e65c31a5d957a7f" translate="yes" xml:space="preserve">
          <source>In order to develop secure web applications you have to keep up to date on all layers and know your enemies. To keep up to date subscribe to security mailing lists, read security blogs, and make updating and security checks a habit (check the &lt;a href=&quot;#additional-resources&quot;&gt;Additional Resources&lt;/a&gt; chapter). It is done manually because that's how you find the nasty logical security problems.</source>
          <target state="translated">안전한 웹 응용 프로그램을 개발하려면 모든 계층에 대한 최신 정보를 유지하고 적을 알아야합니다. 최신 보안 메일 링리스트를 구독하고 보안 블로그를 읽고 업데이트 및 보안 검사를 습관화하십시오 ( &lt;a href=&quot;#additional-resources&quot;&gt;추가 자료&lt;/a&gt; 장 참조). 그것은 당신이 불쾌한 논리적 보안 문제를 찾는 방법이기 때문에 수동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c80eb3d9bc865a25159d18d747353ab8f8e5787e" translate="yes" xml:space="preserve">
          <source>In order to find the first address that is (probably) accurate, we take the list of IPs, remove known and trusted proxies, and then take the last address left, which was presumably set by one of those proxies.</source>
          <target state="translated">(아마도) 정확한 첫 번째 주소를 찾기 위해 IP 목록을 가져오고 알려진 프록시와 신뢰할 수있는 프록시를 제거한 다음 마지막 프록시 주소 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6354c48f70c32d4750012cacd9da8ac279600087" translate="yes" xml:space="preserve">
          <source>In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passing &lt;code&gt;requires_new: true&lt;/code&gt;. If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. If we add it to the previous example:</source>
          <target state="translated">중첩 트랜잭션에 대한 ROLLBACK을 얻으려면 require_new &lt;code&gt;requires_new: true&lt;/code&gt; 를 전달하여 실제 하위 트랜잭션을 요청할 수 있습니다 . 문제가 발생하면 데이터베이스는 상위 트랜잭션을 롤백하지 않고 서브 트랜잭션의 시작 부분으로 롤백합니다. 이전 예제에 추가하면 :</target>
        </trans-unit>
        <trans-unit id="410e25b9e9888fb013e4964fa7a83949db21bdb0" translate="yes" xml:space="preserve">
          <source>In order to get around this problem, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; will emulate the effect of nested transactions, by using savepoints: &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt;Savepoints are supported by MySQL and PostgreSQL. SQLite3 version &amp;gt;= '3.6.8' supports savepoints.</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;트랜잭션&lt;/a&gt; 은 저장 점을 사용하여 중첩 된 트랜잭션의 효과를 에뮬레이션합니다. &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt; 저장 점 은 MySQL 및 PostgreSQL에서 지원됩니다. SQLite3 버전&amp;gt; = '3.6.8'은 저장 점을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dd11742e858f6334bdad83633d6fa6c8c53354ab" translate="yes" xml:space="preserve">
          <source>In order to have a near-zero default footprint, Active Support does not load anything by default. It is broken in small pieces so that you can load just what you need, and also has some convenience entry points to load related extensions in one shot, even everything.</source>
          <target state="translated">기본 설치 공간이 거의 제로에 가깝도록 Active Support는 기본적으로 아무것도로드하지 않습니다. 필요한 부분 만로드 할 수 있도록 작은 조각으로 나뉘어 있으며 관련 확장을 한 번에, 심지어 모든 항목에로드 할 수있는 편리한 진입 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82c837ad4838a769498f05c39e5cc7258777bc1" translate="yes" xml:space="preserve">
          <source>In order to load &lt;code&gt;ApplicationController&lt;/code&gt;, Rails iterates over &lt;code&gt;autoload_paths&lt;/code&gt;. First it checks if &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; exists. If it does not, which is normally the case, it continues and finds &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ApplicationController&lt;/code&gt; 를로드하기 위해 Rails는 &lt;code&gt;autoload_paths&lt;/code&gt; 를 반복 합니다. 먼저 &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; 가 있는지 확인 합니다. 그렇지 않은 경우 (일반적으로) &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4446192ce96a4398b61fcdab3b6475fcb7381eb8" translate="yes" xml:space="preserve">
          <source>In order to make your custom transliterations available, you must set them as the &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n key:</source>
          <target state="translated">사용자 정의 음역을 사용 가능하게하려면 &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n 키로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="73d914ea93f06da557242e0d8ce9a09c0b88f5d6" translate="yes" xml:space="preserve">
          <source>In order to mitigate SSL attacks, &lt;code&gt;form_authenticity_token&lt;/code&gt; is now masked so that it varies with each request. Thus, tokens are validated by unmasking and then decrypting. As a result, any strategies for verifying requests from non-rails forms that relied on a static session CSRF token have to take this into account.</source>
          <target state="translated">SSL 공격을 완화하기 위해 각 요청에 따라 &lt;code&gt;form_authenticity_token&lt;/code&gt; 이 마스크 처리됩니다. 따라서 토큰은 마스크를 해제 한 다음 해독하여 유효성을 검사합니다. 결과적으로 정적 세션 CSRF 토큰에 의존하는 비 레일 형식의 요청을 확인하기위한 모든 전략이이를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc82d22a9f284ef62e02e9541120ccbb65275b2b" translate="yes" xml:space="preserve">
          <source>In order to mitigate such attacks, &lt;em&gt;display a generic error message on forgot-password pages, too&lt;/em&gt;. Moreover, you can &lt;em&gt;require to enter a CAPTCHA after a number of failed logins from a certain IP address&lt;/em&gt;. Note, however, that this is not a bullet-proof solution against automatic programs, because these programs may change their IP address exactly as often. However, it raises the barrier of an attack.</source>
          <target state="translated">이러한 공격을 완화하려면 &lt;em&gt;잊어 버린 비밀번호 페이지에도 일반적인 오류 메시지를 표시하십시오&lt;/em&gt; . 또한 &lt;em&gt;특정 IP 주소에서 여러 번 로그인에 실패한 후 보안 문자를 입력해야&lt;/em&gt; 할 수도 있습니다 . 그러나 자동 프로그램에 대한 방탄 솔루션은 아닙니다. 이러한 프로그램은 IP 주소를 정확하게 변경할 수 있기 때문입니다. 그러나 공격의 장벽을 높입니다.</target>
        </trans-unit>
        <trans-unit id="b8932dfdb433984f20a34dffa003cc8435f6ddf0" translate="yes" xml:space="preserve">
          <source>In order to remove existing data from the database, Rails tries to disable referential integrity triggers (like foreign keys and check constraints). If you are getting annoying permission errors on running tests, make sure the database user has privilege to disable these triggers in testing environment. (In PostgreSQL, only superusers can disable all triggers. Read more about PostgreSQL permissions &lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">Rails는 데이터베이스에서 기존 데이터를 제거하기 위해 외래 키 및 검사 제약 조건과 같은 참조 무결성 트리거를 비활성화하려고합니다. 테스트를 실행할 때 성가신 권한 오류가 발생하는 경우 데이터베이스 사용자에게 테스트 환경에서 이러한 트리거를 비활성화 할 권한이 있는지 확인하십시오. (PostgreSQL에서는 수퍼 유저 만 모든 트리거를 비활성화 할 수 있습니다. PostgreSQL 권한에 대한 자세한 내용은 &lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="591a364b06e24638cd2bbe248317d0147d336890" translate="yes" xml:space="preserve">
          <source>In order to run your tests, your test database will need to have the current structure. The test helper checks whether your test database has any pending migrations. It will try to load your &lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/structure.sql&lt;/code&gt; into the test database. If migrations are still pending, an error will be raised. Usually this indicates that your schema is not fully migrated. Running the migrations against the development database (&lt;code&gt;rails db:migrate&lt;/code&gt;) will bring the schema up to date.</source>
          <target state="translated">테스트를 실행하려면 테스트 데이터베이스에 현재 구조가 있어야합니다. 테스트 도우미는 테스트 데이터베이스에 보류중인 마이그레이션이 있는지 확인합니다. &lt;code&gt;db/schema.rb&lt;/code&gt; 또는 &lt;code&gt;db/structure.sql&lt;/code&gt; 을 테스트 데이터베이스 에로드하려고 시도 합니다. 마이그레이션이 여전히 보류 중이면 오류가 발생합니다. 일반적으로 이는 스키마가 완전히 마이그레이션되지 않았 음을 나타냅니다. 개발 데이터베이스 ( &lt;code&gt;rails db:migrate&lt;/code&gt; ) 에 대해 마이그레이션을 실행하면 스키마가 최신 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="58f575461fcf64d202b669e6b7c232ec89e9af74" translate="yes" xml:space="preserve">
          <source>In order to test helpers, all you need to do is check that the output of the helper method matches what you'd expect. Tests related to the helpers are located under the &lt;code&gt;test/helpers&lt;/code&gt; directory.</source>
          <target state="translated">헬퍼를 테스트하려면 헬퍼 메소드의 출력이 예상 한 것과 일치하는지 확인하면됩니다. 헬퍼와 관련된 테스트는 &lt;code&gt;test/helpers&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb97c0e3b59e713cb40747cecd51d611b98bbe" translate="yes" xml:space="preserve">
          <source>In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.</source>
          <target state="translated">메일러가 예상대로 작동하는지 테스트하기 위해 단위 테스트를 사용하여 메일러의 실제 결과를 미리 작성된 예제의 미리 작성된 예제와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ed14a4839497197db3034ba8b5734ade36f0cf" translate="yes" xml:space="preserve">
          <source>In order to understand Ajax, you must first understand what a web browser does normally.</source>
          <target state="translated">Ajax를 이해하려면 먼저 웹 브라우저가 정상적으로 수행하는 작업을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="46312161d035588213184c9f80aa1fb2fc07cd0c" translate="yes" xml:space="preserve">
          <source>In order to understand what a generator template means, let's create the file &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; with the following content:</source>
          <target state="translated">생성기 템플릿의 의미를 이해하기 위해 다음 내용으로 &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="107547c56e4f88408e05c37dbf186d51ea22566e" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; with Strong Parameters, you will need to specify which nested attributes should be permitted. You might want to allow &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:_destroy&lt;/code&gt;, see ActiveRecord::NestedAttributes for more information.</source>
          <target state="translated">강한 매개 변수와 함께 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 를 사용하려면 허용 할 중첩 속성을 지정해야합니다. &lt;code&gt;:id&lt;/code&gt; 및 &lt;code&gt;:_destroy&lt;/code&gt; 를 허용 할 수 있습니다 . 자세한 정보는 ActiveRecord :: NestedAttributes를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40d37692f2f31f03a36c5e7dcd20c22020868c24" translate="yes" xml:space="preserve">
          <source>In order to use a different file, call &lt;code&gt;layout&lt;/code&gt; in your mailer:</source>
          <target state="translated">다른 파일을 사용하려면 메일러에서 &lt;code&gt;layout&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="6d85767016fa3a495331b4fb23a752c703fee817" translate="yes" xml:space="preserve">
          <source>In order to use instantiated fixtures with preloaded data, set &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; to true. This will provide access to fixture data for every table that has been loaded through fixtures (depending on the value of &lt;code&gt;use_instantiated_fixtures&lt;/code&gt;).</source>
          <target state="translated">사전로드 된 데이터와 함께 인스턴스화 된 조명기를 사용하려면 &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; 를 true로 설정 하십시오 . 이것은 조명기를 통해로드 된 모든 테이블에 대한 조명기 데이터에 대한 액세스를 제공합니다 ( &lt;code&gt;use_instantiated_fixtures&lt;/code&gt; 값에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="18bdaed8e369471a7df6f869f483701a9bf4a802" translate="yes" xml:space="preserve">
          <source>In order to use optimistic locking, the table needs to have a column called &lt;code&gt;lock_version&lt;/code&gt; of type integer. Each time the record is updated, Active Record increments the &lt;code&gt;lock_version&lt;/code&gt; column. If an update request is made with a lower value in the &lt;code&gt;lock_version&lt;/code&gt; field than is currently in the &lt;code&gt;lock_version&lt;/code&gt; column in the database, the update request will fail with an &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt;. Example:</source>
          <target state="translated">낙관적 잠금을 사용하려면 테이블에 정수 유형의 &lt;code&gt;lock_version&lt;/code&gt; 이라는 열이 있어야합니다 . 레코드가 업데이트 될 때마다 활성 레코드는 &lt;code&gt;lock_version&lt;/code&gt; 열을 증가시킵니다 . 데이터베이스 의 &lt;code&gt;lock_version&lt;/code&gt; 열에있는 것보다 &lt;code&gt;lock_version&lt;/code&gt; 필드 에서 더 낮은 값으로 업데이트 요청을하는 경우 &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt; 와 함께 업데이트 요청이 실패 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="97f8db0543047a0b8ca16dbd131cc3b42104554f" translate="yes" xml:space="preserve">
          <source>In order to use streaming, you will need to use a Ruby version that supports fibers (fibers are supported since version 1.9.2 of the main Ruby implementation).</source>
          <target state="translated">스트리밍을 사용하려면 파이버를 지원하는 Ruby 버전을 사용해야합니다 (기본 Ruby 구현 버전 1.9.2부터 파이버가 지원됨).</target>
        </trans-unit>
        <trans-unit id="dba418ad8c83fa1633e3b40c0d2bddfc1c0342ec" translate="yes" xml:space="preserve">
          <source>In order to use the PostgreSQL adapter you need to have at least version 9.3 installed. Older versions are not supported.</source>
          <target state="translated">PostgreSQL 어댑터를 사용하려면 버전 9.3 이상이 설치되어 있어야합니다. 이전 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8a387461da518b7b0ce941ea8ccc2c1adfc8d6" translate="yes" xml:space="preserve">
          <source>In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:</source>
          <target state="translated">사용 가능한 콜백을 사용하려면 콜백을 등록해야합니다. 콜백을 일반 메소드로 구현하고 매크로 스타일 클래스 메소드를 사용하여 콜백으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d0b40146c6f65e6dde8c5670a9643e8aee5e87" translate="yes" xml:space="preserve">
          <source>In order to use these methods to access fixtured data within your test cases, you must specify one of the following in your ActiveSupport::TestCase-derived class:</source>
          <target state="translated">이러한 방법을 사용하여 테스트 사례 내에서 고정 된 데이터에 액세스하려면 ActiveSupport :: TestCase 파생 클래스에서 다음 중 하나를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="651da9723da705d25ae3a7c22c950d1248914e1f" translate="yes" xml:space="preserve">
          <source>In order to use this helper, you need to install &lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem by adding this line to your &lt;code&gt;Gemfile&lt;/code&gt;: &lt;code&gt;gem 'dynamic_form'&lt;/code&gt;.</source>
          <target state="translated">이 도우미를 사용하려면 &lt;code&gt;Gemfile&lt;/code&gt; 에 다음 줄을 추가하여 &lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem 을 설치해야합니다 : &lt;code&gt;gem 'dynamic_form'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab4e37bd8136ae2e3df92d16165dff5ee0c42e5" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose absence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">부재가 필요한 관련 레코드의 유효성을 검사하려면 연결에 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f288ff2a7ae3e4f9c2eb79749ecb68121c66351" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose presence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">프레즌스가 필요한 관련 레코드의 유효성을 검사하려면 연결에 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="218a79265ec0fd7c85e83c35da82e6a7ffce9b16" translate="yes" xml:space="preserve">
          <source>In order to work with Action Controller, a &lt;a href=&quot;context&quot;&gt;Context&lt;/a&gt; must just include this module. The initialization of the variables used by the context (@output_buffer, @view_flow, and @virtual_path) is responsibility of the object that includes this module (although you can call &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;#_prepare_context&lt;/a&gt; defined below).</source>
          <target state="translated">Action Controller로 작업 하려면 &lt;a href=&quot;context&quot;&gt;컨텍스트&lt;/a&gt; 에이 모듈 만 포함해야합니다. 컨텍스트에 사용되는 변수 (@output_buffer, @view_flow 및 @virtual_path)의 초기화는이 모듈을 포함하는 객체의 책임입니다 ( 아래에 정의 된 &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;#_prepare_context&lt;/a&gt; 를 호출 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b483ca18407dce764b375bf3103a7eee8c3384af" translate="yes" xml:space="preserve">
          <source>In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with &lt;code&gt;#call&lt;/code&gt; method:</source>
          <target state="translated">다른 상황에서는이 동작을 변경하고 싶을 수도 있습니다. 예를 들어 기본 예외 처리는 자동화 된 테스트 중에 누락 된 번역을 쉽게 잡을 수 없습니다. 이를 위해 다른 예외 처리기를 지정할 수 있습니다. 지정된 예외 핸들러는 I18n 모듈의 메소드이거나 &lt;code&gt;#call&lt;/code&gt; 메소드가 있는 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="393cd9beea03d987167d30b004ade204e3cf72ad" translate="yes" xml:space="preserve">
          <source>In other words, this query can be generated by calling &lt;code&gt;where&lt;/code&gt; with no argument, then immediately chain with &lt;code&gt;not&lt;/code&gt; passing &lt;code&gt;where&lt;/code&gt; conditions. This will generate SQL like this:</source>
          <target state="translated">즉,이 쿼리는 인수없이 &lt;code&gt;where&lt;/code&gt; 를 호출 한 다음 &lt;code&gt;where&lt;/code&gt; 조건을 전달 &lt;code&gt;not&lt;/code&gt; 즉시 연결하여 생성 할 수 있습니다 . 다음과 같은 SQL이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f14055d795b486afde1a4cf285f261794af7f815" translate="yes" xml:space="preserve">
          <source>In other words, we make the request so that it operates on a single entity's person. Then, in the action, we extract the company data from the request, find or create the company, and then create the new person with the remaining data.</source>
          <target state="translated">다시 말해, 우리는 단일 실체의 개인에 대해 운영되도록 요청합니다. 그런 다음 작업에서 요청에서 회사 데이터를 추출하고 회사를 찾거나 생성 한 다음 나머지 데이터로 새 사람을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8c47a20f437054f4ca7a327a1a842acd08b76b69" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Colors::RED&lt;/code&gt; is totally unrelated to any other &lt;code&gt;RED&lt;/code&gt; constant that may live in any other class or module object. If there were any, they would have separate entries in their respective constant tables.</source>
          <target state="translated">특히, &lt;code&gt;Colors::RED&lt;/code&gt; 는 다른 클래스 또는 모듈 객체에있을 수 있는 다른 &lt;code&gt;RED&lt;/code&gt; 상수 와 전혀 관련이 없습니다 . 존재하는 경우 해당 상수 테이블에 별도의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bbc81dc05e3ca5c6f8c3d2409439a68ba3f44d" translate="yes" xml:space="preserve">
          <source>In particular, simple routing makes it very easy to map legacy URLs to new Rails actions.</source>
          <target state="translated">특히 간단한 라우팅을 통해 레거시 URL을 새로운 Rails 액션에 매우 쉽게 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b80c87979c07427dbbadbad87cc7038c0873204" translate="yes" xml:space="preserve">
          <source>In particular, thanks to the conventions followed in the generated field names, the controller gets a nested hash &lt;code&gt;params[:person]&lt;/code&gt; with the person attributes set in the form. That hash is ready to be passed to &lt;code&gt;Person.new&lt;/code&gt;:</source>
          <target state="translated">특히, 생성 된 필드 이름의 규칙에 따라 컨트롤러는 person 속성이 양식에 설정된 중첩 해시 &lt;code&gt;params[:person]&lt;/code&gt; 를 얻습니다 . 해시는 &lt;code&gt;Person.new&lt;/code&gt; 에 전달 될 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a9a2eb08117638628d90ba0302a5370951bb7703" translate="yes" xml:space="preserve">
          <source>In practice, more robust code is necessary to do this reliably. Iain Hecker's &lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt; library or Ryan Tomayko's &lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;locale&lt;/a&gt; Rack middleware provide solutions to this problem.</source>
          <target state="translated">실제로이 작업을 안정적으로 수행하려면보다 강력한 코드가 필요합니다. Iain Hecker의 &lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt; 라이브러리 또는 Ryan Tomayko의 &lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;로케일&lt;/a&gt; 랙 미들웨어가이 문제에 대한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0802cfe51fdef2c921e267ee151179358a255e95" translate="yes" xml:space="preserve">
          <source>In practice, this will allow you to precompile locally, have those files in your working tree, and commit those files to source control when needed. Development mode will work as expected.</source>
          <target state="translated">실제로이를 통해 로컬로 사전 컴파일하고 작업 트리에 해당 파일을 보유하고 필요할 때 해당 파일을 소스 제어에 커밋 할 수 있습니다. 개발 모드가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bfb8683e07369e8581df19e40a7fbd85c022d176" translate="yes" xml:space="preserve">
          <source>In practice, this works quite well as long as the nesting matches all parent namespaces respectively and the constants that make the rule apply are known at that time.</source>
          <target state="translated">실제로 이것은 중첩이 모든 부모 네임 스페이스와 각각 일치하고 규칙을 적용하는 상수가 그 시간에 알려진 한 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9f32eee395899344bec411ccbf6930fd17ef9d92" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails the controller will include a helper which matches the name of the controller, e.g., &lt;code&gt;MyController&lt;/code&gt; will automatically include &lt;code&gt;MyHelper&lt;/code&gt;. To return old behavior set &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 Rails에는 컨트롤러 이름과 일치하는 도우미가 컨트롤러에 포함 &lt;code&gt;MyHelper&lt;/code&gt; . 예를 들어 &lt;code&gt;MyController&lt;/code&gt; 는 자동으로 MyHelper를 포함 합니다 . 이전 동작을 반환하려면 &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="387fca91ce034b1ccf78d7b329410a4b592846a5" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails, all assets were located in subdirectories of &lt;code&gt;public&lt;/code&gt; such as &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;javascripts&lt;/code&gt; and &lt;code&gt;stylesheets&lt;/code&gt;. With the asset pipeline, the preferred location for these assets is now the &lt;code&gt;app/assets&lt;/code&gt; directory. Files in this directory are served by the Sprockets middleware.</source>
          <target state="translated">레일스의 이전 버전에서는 모든 자산이 &lt;code&gt;images&lt;/code&gt; , &lt;code&gt;javascripts&lt;/code&gt; 및 &lt;code&gt;stylesheets&lt;/code&gt; 와 같은 &lt;code&gt;public&lt;/code&gt; 하위 디렉토리에있었습니다 . 자산 파이프 라인에서 이러한 자산의 선호 위치는 이제 &lt;code&gt;app/assets&lt;/code&gt; 디렉토리입니다. 이 디렉토리의 파일은 Sprockets 미들웨어에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7dc5570153310ae5658bb85dc33107a7d11c2edb" translate="yes" xml:space="preserve">
          <source>In previous versions when you defined a &lt;code&gt;default_scope&lt;/code&gt; in a model it was overridden by chained conditions in the same field. Now it is merged like any other scope.</source>
          <target state="translated">이전 버전에서는 모델에서 &lt;code&gt;default_scope&lt;/code&gt; 를 정의 할 때 동일한 필드의 체인 조건으로 재정의되었습니다. 이제 다른 범위와 같이 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="acdc2b5830d037a308e1f80820fc64001fe34307" translate="yes" xml:space="preserve">
          <source>In production, Rails precompiles these files to &lt;code&gt;public/assets&lt;/code&gt; by default. The precompiled copies are then served as static assets by the web server. The files in &lt;code&gt;app/assets&lt;/code&gt; are never served directly in production.</source>
          <target state="translated">프로덕션 환경에서 Rails 는 기본적으로 이러한 파일을 &lt;code&gt;public/assets&lt;/code&gt; 으로 사전 컴파일합니다 . 그런 다음 사전 컴파일 된 사본은 웹 서버에서 정적 자산으로 제공됩니다. &lt;code&gt;app/assets&lt;/code&gt; 의 파일은 프로덕션에서 직접 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd1c2f4bacd2e42e0926f761088b2fa08f639486" translate="yes" xml:space="preserve">
          <source>In production-like environments it is generally better to load all the application code when the application boots. Eager loading puts everything in memory ready to serve requests right away, and it is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt;-friendly.</source>
          <target state="translated">프로덕션 환경에서는 일반적으로 응용 프로그램이 부팅 될 때 모든 응용 프로그램 코드를로드하는 것이 좋습니다. 빠른 로딩은 요청을 즉시 처리 할 수 ​​있도록 메모리의 모든 것을 준비하고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt; 친화적입니다.</target>
        </trans-unit>
        <trans-unit id="867aa3c331895802d160c399e93401a07e010863" translate="yes" xml:space="preserve">
          <source>In rare circumstances you might need to access the mapping directly. The mappings are exposed through a class method with the pluralized attribute name, which return the mapping in a &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt;:</source>
          <target state="translated">드문 경우이지만 매핑에 직접 액세스해야 할 수도 있습니다. 맵핑은 복수화 된 속성 이름을 가진 클래스 메소드를 통해 노출되며 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 의 맵핑을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f6955c0b68123d164c5a31f6ca257fa2c43af53a" translate="yes" xml:space="preserve">
          <source>In rare instances, web servers or front proxies strip authorization headers before they reach your application. You can debug this situation by logging all environment variables, and check for HTTP_AUTHORIZATION, amongst others.</source>
          <target state="translated">드문 경우지만 웹 서버 또는 프론트 프록시는 권한 헤더를 애플리케이션에 도달하기 전에 제거합니다. 모든 환경 변수를 로깅하여이 상황을 디버그하고 특히 HTTP_AUTHORIZATION을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="448cd91c5ca45a692c6ec9543871b6564930e128" translate="yes" xml:space="preserve">
          <source>In regular views you can access images in the &lt;code&gt;app/assets/images&lt;/code&gt; directory like this:</source>
          <target state="translated">일반보기에서 다음과 같이 &lt;code&gt;app/assets/images&lt;/code&gt; 디렉토리의 이미지에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06ae7ad8ee810f01851d88cc659fdf8a687fed96" translate="yes" xml:space="preserve">
          <source>In some cases you may want to prevent writes to the database even if you are on a database that can write. `while_preventing_writes` will prevent writes to the database for the duration of the block.</source>
          <target state="translated">어떤 경우에는 쓰기 가능한 데이터베이스에 있더라도 데이터베이스에 쓰지 못하게 할 수 있습니다. `while_preventing_writes`는 블록 동안 데이터베이스에 대한 쓰기를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1f80e06d03640ad157d5355c15d46fb341b319a3" translate="yes" xml:space="preserve">
          <source>In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:</source>
          <target state="translated">경우에 따라 단일 테이블 상속 설정과 같이 명시적인 종속성이 많이있을 수 있습니다. 모든 템플리트를 작성하는 대신 와일드 카드를 사용하여 디렉토리의 모든 템플리트를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3131b4ceda57af774c0368b496b38c23e7f116b4" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to provide a boolean hook. For example, webrat developers might want to have webrat available on controller generator. This can be achieved as:</source>
          <target state="translated">경우에 따라 부울 후크를 제공 할 수도 있습니다. 예를 들어, Webrat 개발자는 컨트롤러 생성기에서 Webrat를 사용할 수 있습니다. 이것은 다음과 같이 달성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b358a6bb6300b251cb348fc564a8833f7d939e" translate="yes" xml:space="preserve">
          <source>In some circumstances you may wish to use live compilation. In this mode all requests for assets in the pipeline are handled by Sprockets directly.</source>
          <target state="translated">경우에 따라 라이브 컴파일을 사용하고자 할 수도 있습니다. 이 모드에서는 파이프 라인의 자산에 대한 모든 요청이 Sprockets에서 직접 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5f915ed8669a78a1a735442736b9533062f4ecfc" translate="yes" xml:space="preserve">
          <source>In some scenarios you may want to add back some functionality provided by &lt;code&gt;ActionController::Base&lt;/code&gt; that is not present by default in &lt;code&gt;ActionController::API&lt;/code&gt;, for instance &lt;code&gt;MimeResponds&lt;/code&gt;. This module gives you the &lt;code&gt;respond_to&lt;/code&gt; method. Adding it is quite simple, you just need to include the module in a specific controller or in &lt;code&gt;ApplicationController&lt;/code&gt; in case you want it available in your entire application:</source>
          <target state="translated">일부 시나리오에서는 기본적으로 &lt;code&gt;ActionController::API&lt;/code&gt; 에없는 &lt;code&gt;ActionController::Base&lt;/code&gt; 가 제공하는 일부 기능 ( 예 : &lt;code&gt;MimeResponds&lt;/code&gt; )을 다시 추가 할 수 있습니다 . 이 모듈은 &lt;code&gt;respond_to&lt;/code&gt; 메소드를 제공합니다 . 추가하는 것은 매우 간단 합니다. 전체 응용 &lt;code&gt;ApplicationController&lt;/code&gt; 에서 모듈을 사용하려는 경우 특정 컨트롤러 또는 ApplicationController 에 모듈을 포함하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="17f0250b4e2377f22078b52d68151700c5137bc6" translate="yes" xml:space="preserve">
          <source>In special situations, where someone from the Core Team agrees to support more series, they are included in the list of supported series.</source>
          <target state="translated">핵심 팀의 누군가가 더 많은 시리즈를 지원하기로 동의 한 특별한 상황에서는 지원되는 시리즈 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f08fa535d4de28e332a84e5bf7432c5065e585" translate="yes" xml:space="preserve">
          <source>In such actions, you want to delay queries execution as much as you can. For example, imagine the following &lt;code&gt;dashboard&lt;/code&gt; action:</source>
          <target state="translated">이러한 작업에서 쿼리 실행을 최대한 지연 시키려고합니다. 예를 들어 다음 &lt;code&gt;dashboard&lt;/code&gt; 작업을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="e22a8c55bcb2ac30014d38e167eb68330f7cd298" translate="yes" xml:space="preserve">
          <source>In such case, it could even happen that the reassigned &lt;code&gt;A&lt;/code&gt; held a new class or module called also &quot;A&quot;!</source>
          <target state="translated">이 경우, 재 할당 된 &lt;code&gt;A&lt;/code&gt; 가 &quot;A&quot;라고하는 새로운 클래스 나 모듈을 보유 하게 될 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="7bc9b2fd355ec60ad8bae876600fcb6906d3ef26" translate="yes" xml:space="preserve">
          <source>In such cases, Ruby's core &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;Date&lt;/a&gt; and &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;Time&lt;/a&gt; should be used for precision date and time arithmetic.</source>
          <target state="translated">이러한 경우 Ruby의 핵심 &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;날짜&lt;/a&gt; 및 &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;시간&lt;/a&gt; 을 정확한 날짜 및 시간 산술에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3aac43b2be2d07c0a420f20d829b8934449b3c17" translate="yes" xml:space="preserve">
          <source>In test and development applications get a &lt;code&gt;secret_key_base&lt;/code&gt; derived from the app name. Other environments must use a random key present in &lt;code&gt;config/credentials.yml.enc&lt;/code&gt;, shown here in its decrypted state:</source>
          <target state="translated">테스트 및 개발 애플리케이션 에서 앱 이름에서 파생 된 &lt;code&gt;secret_key_base&lt;/code&gt; 를 얻습니다 . 다른 환경에서는 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 에있는 임의의 키를 사용해야합니다 ( 암호화 된 상태로 여기 표시됨).</target>
        </trans-unit>
        <trans-unit id="0b604c981536c6f7a57e350835fcc0cf00e3e7d1" translate="yes" xml:space="preserve">
          <source>In tests you can simply pass the URL or named route to &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">테스트에서 단순히 URL이나 이름 지정된 경로를 전달하여 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;post&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbfb856b113f8aa7f20649d6800d05bfc1f91454" translate="yes" xml:space="preserve">
          <source>In that case it is preferable to either use &lt;code&gt;check_box_tag&lt;/code&gt; or to use hashes instead of arrays.</source>
          <target state="translated">이 경우 &lt;code&gt;check_box_tag&lt;/code&gt; 를 사용하거나 배열 대신 해시를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8a94c0205e8998c88c2b83ec95edd58bd84adb0" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;app/models/concerns&lt;/code&gt; is assumed to be a root directory (because it belongs to the autoload paths), and it is ignored as namespace. So, &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; should define &lt;code&gt;Foo&lt;/code&gt;, not &lt;code&gt;Concerns::Foo&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;app/models/concerns&lt;/code&gt; 는 루트 디렉토리 (오토로드 경로에 속하기 때문에)로 간주되며 네임 스페이스로 무시됩니다. 따라서 &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; 는 &lt;code&gt;Concerns::Foo&lt;/code&gt; 아니라 &lt;code&gt;Foo&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b13a5797f6fc9e1292d0609d2b1de532169ec70b" translate="yes" xml:space="preserve">
          <source>In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption.</source>
          <target state="translated">이 경우 일괄 처리 방법을 사용하면 레코드를 일괄 처리하여 메모리 소비를 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c1c021f721c684135b59830f5b970354577a47" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#sessions&quot;&gt;session chapter&lt;/a&gt; you have learned that most Rails applications use cookie-based sessions. Either they store the session ID in the cookie and have a server-side session hash, or the entire session hash is on the client-side. In either case the browser will automatically send along the cookie on every request to a domain, if it can find a cookie for that domain. The controversial point is that if the request comes from a site of a different domain, it will also send the cookie. Let's start with an example:</source>
          <target state="translated">에서 &lt;a href=&quot;#sessions&quot;&gt;세션 장&lt;/a&gt; 당신은 대부분의 레일 응용 프로그램은 쿠키 기반 세션을 사용하는 것이 배웠습니다. 쿠키에 세션 ID를 저장하고 서버 측 세션 해시를 갖거나 전체 세션 해시가 클라이언트 측에 있습니다. 두 경우 모두 브라우저는 도메인에 대한 쿠키를 찾을 수있는 경우 모든 요청에 ​​따라 쿠키를 도메인으로 자동 전송합니다. 논란의 여지가있는 점은 요청이 다른 도메인의 사이트에서 온 경우 쿠키도 전송한다는 것입니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="cda842a28317aed91dd703e8e2c47e5c82db26d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ArticlesController&lt;/code&gt; we need to have a way to block access to the various actions if the person is not authenticated. Here we can use the Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; method, which allows access to the requested action if that method allows it.</source>
          <target state="translated">에서 &lt;code&gt;ArticlesController&lt;/code&gt; 우리는 사람이 인증되지 않은 경우 다양한 작업에 대한 액세스를 차단하는 방법이 필요합니다. 여기서 우리는 Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; 메소드를 사용할 수 있습니다.이 메소드는 요청 된 조치가 허용하는 경우 요청 된 조치에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="109d17caa7860bcdee4fd3c758460f7d4c9a3bc5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;show&lt;/code&gt; template, we'll render the &lt;code&gt;_article&lt;/code&gt; partial wrapped in the &lt;code&gt;box&lt;/code&gt; layout:</source>
          <target state="translated">에서 &lt;code&gt;show&lt;/code&gt; 템플릿, 우리는 렌더링 것이다 &lt;code&gt;_article&lt;/code&gt; 에 싸여 부분 &lt;code&gt;box&lt;/code&gt; 레이아웃 :</target>
        </trans-unit>
        <trans-unit id="932111316617cc42b0f847695447a92081a2e91f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;test_should_get_index&lt;/code&gt; test, Rails simulates a request on the action called &lt;code&gt;index&lt;/code&gt;, making sure the request was successful and also ensuring that the right response body has been generated.</source>
          <target state="translated">에서 &lt;code&gt;test_should_get_index&lt;/code&gt; 의 테스트, 레일라는 작업에 요청 시뮬레이션 &lt;code&gt;index&lt;/code&gt; 확인 요청이 성공하고도 적절한 응답 본문이 생성 된 것을 보장하고,.</target>
        </trans-unit>
        <trans-unit id="b0dd914d44cf11ff05a98e10708f475b57b6904b" translate="yes" xml:space="preserve">
          <source>In the Blog application, you will now create a new &lt;em&gt;resource&lt;/em&gt;. A resource is the term used for a collection of similar objects, such as articles, people, or animals. You can create, read, update, and destroy items for a resource and these operations are referred to as &lt;em&gt;CRUD&lt;/em&gt; operations.</source>
          <target state="translated">블로그 애플리케이션에서 이제 새 &lt;em&gt;자원을&lt;/em&gt; 작성 &lt;em&gt;합니다&lt;/em&gt; . 자원은 기사, 사람 또는 동물과 같은 유사한 개체의 모음에 사용되는 용어입니다. 자원에 대한 항목을 작성, 읽기, 업데이트 및 제거 할 수 있으며 이러한 작업을 &lt;em&gt;CRUD&lt;/em&gt; 작업 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="24db4d3c8293c09d3f0c65d469d2a51f794699b9" translate="yes" xml:space="preserve">
          <source>In the Rails framework these hooks are called when a specific library is loaded. For example, when &lt;code&gt;ActionController::Base&lt;/code&gt; is loaded, the &lt;code&gt;:action_controller_base&lt;/code&gt; hook is called. This means that all &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; calls with &lt;code&gt;:action_controller_base&lt;/code&gt; hooks will be called in the context of &lt;code&gt;ActionController::Base&lt;/code&gt; (that means &lt;code&gt;self&lt;/code&gt; will be an &lt;code&gt;ActionController::Base&lt;/code&gt;).</source>
          <target state="translated">Rails 프레임 워크에서 이러한 후크는 특정 라이브러리가로드 될 때 호출됩니다. 예를 들어 &lt;code&gt;ActionController::Base&lt;/code&gt; &lt;code&gt;:action_controller_base&lt;/code&gt; 드되면 : action_controller_base 후크가 호출됩니다. 이는 &lt;code&gt;:action_controller_base&lt;/code&gt; 후크를 사용 하는 모든 &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; 호출 이 &lt;code&gt;ActionController::Base&lt;/code&gt; 의 컨텍스트에서 호출 됨을 의미합니다 (즉, &lt;code&gt;self&lt;/code&gt; 는 &lt;code&gt;ActionController::Base&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="018cf8fd21b3afc27f24b270e9c9f004f622eeca" translate="yes" xml:space="preserve">
          <source>In the above block, a &lt;code&gt;FormBuilder&lt;/code&gt; object is yielded as the &lt;code&gt;person_form&lt;/code&gt; variable. This allows you to generate the &lt;code&gt;text_field&lt;/code&gt; and &lt;code&gt;check_box&lt;/code&gt; fields by specifying their eponymous methods, which modify the underlying template and associates the &lt;code&gt;@person&lt;/code&gt; model object with the form.</source>
          <target state="translated">위의 블록에서 &lt;code&gt;FormBuilder&lt;/code&gt; 객체는 &lt;code&gt;person_form&lt;/code&gt; 변수 로 생성됩니다 . 이를 통해 기본 템플릿을 수정하고 &lt;code&gt;@person&lt;/code&gt; 모델 객체를 양식 과 연결하는 시연 메서드를 지정 하여 &lt;code&gt;text_field&lt;/code&gt; 및 &lt;code&gt;check_box&lt;/code&gt; 필드 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e8f8ae805ddb6dd1112cbcc45e4fc5957590768" translate="yes" xml:space="preserve">
          <source>In the above case as long as Subclass does not assign a value to setting by performing &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;Subclass.setting&lt;/code&gt; would read value assigned to parent class. Once Subclass assigns a value then the value assigned by Subclass would be returned.</source>
          <target state="translated">긴 서브 클래스가 수행하여 설정 값을 할당하지 않는 한 위의 경우 &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;Subclass.setting&lt;/code&gt; 는 상위 클래스에 할당 된 값을 읽을 것입니다. 서브 클래스가 값을 할당하면 서브 클래스가 할당 한 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b1cb73fc73094a58e195dd6ca9b80ae9df2dfa1" translate="yes" xml:space="preserve">
          <source>In the above case it would make more sense to use the &lt;code&gt;content_type&lt;/code&gt; setter directly.</source>
          <target state="translated">위의 경우 &lt;code&gt;content_type&lt;/code&gt; setter를 직접 사용하는 것이 더 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="7e163be244fe8bdb5f530f0935c88b0adb00fc3e" translate="yes" xml:space="preserve">
          <source>In the above case there are still two readings. However &lt;code&gt;person.articles&lt;/code&gt; shows only one article because the collection loads only unique records.</source>
          <target state="translated">위의 경우에는 여전히 두 개의 판독 값이 있습니다. 그러나 컬렉션에는 고유 한 레코드 만로드되므로 &lt;code&gt;person.articles&lt;/code&gt; 에는 하나의 기사 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="176a9dc5fbcfae20c994660d52dd8f429b5d77c6" translate="yes" xml:space="preserve">
          <source>In the above case there are two readings and &lt;code&gt;person.articles&lt;/code&gt; brings out both of them even though these records are pointing to the same article.</source>
          <target state="translated">위의 경우이 수치가하고 &lt;code&gt;person.articles&lt;/code&gt; 는 이 기록이 같은 기사를 가리키는 경우에도 그들을 모두 밖으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="690cd0e61c2000224f7b44dbcc541e9443157e34" translate="yes" xml:space="preserve">
          <source>In the above case whenever you save an account the method &lt;code&gt;Audit#before&lt;/code&gt; will be called. On the other hand</source>
          <target state="translated">위의 경우 계정을 저장할 때마다 &lt;code&gt;Audit#before&lt;/code&gt; 메소드 가 호출됩니다. 반면에</target>
        </trans-unit>
        <trans-unit id="20fa2b618a41090d64744e8886e56741eb7768e0" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;render&lt;/code&gt; takes 2 options: &lt;code&gt;partial&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt;. But if these are the only options you want to pass, you can skip using these options. For example, instead of:</source>
          <target state="translated">위의 예에서 &lt;code&gt;render&lt;/code&gt; 는 &lt;code&gt;partial&lt;/code&gt; 및 &lt;code&gt;locals&lt;/code&gt; 의 두 가지 옵션을 사용 합니다. 그러나이 옵션 만 전달하려는 경우이 옵션을 사용하여 건너 뛸 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="157feea9492cf83c86be261458171459bd27095d" translate="yes" xml:space="preserve">
          <source>In the above example, the configuration from the first application was used to initialize the second application. You can also use the &lt;code&gt;initialize_copy&lt;/code&gt; on one of the applications to create a copy of the application which shares the configuration.</source>
          <target state="translated">위 예에서 첫 번째 응용 프로그램의 구성을 사용하여 두 번째 응용 프로그램을 초기화했습니다. 응용 프로그램 중 하나 에서 &lt;code&gt;initialize_copy&lt;/code&gt; 를 사용 하여 구성을 공유하는 응용 프로그램의 복사본을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb83d7ff54804b12fe50b173335aa3b0288d1172" translate="yes" xml:space="preserve">
          <source>In the above example, there will be a performance impact even if the allowed output level doesn't include debug. The reason is that Ruby has to evaluate these strings, which includes instantiating the somewhat heavy &lt;code&gt;String&lt;/code&gt; object and interpolating the variables. Therefore, it's recommended to pass blocks to the logger methods, as these are only evaluated if the output level is the same as &amp;mdash; or included in &amp;mdash; the allowed level (i.e. lazy loading). The same code rewritten would be:</source>
          <target state="translated">위의 예에서 허용 된 출력 레벨에 디버그가 포함되지 않은 경우에도 성능에 영향을 미칩니다. 그 이유는 Ruby가이 문자열을 평가해야하기 때문입니다. 여기에는 다소 무거운 &lt;code&gt;String&lt;/code&gt; 객체를 인스턴스화 하고 변수를 보간하는 것이 포함됩니다 . 따라서 출력 레벨이 허용 레벨과 같거나 포함 된 경우 (예 : 지연 로딩) 로거 메소드에 블록을 전달하는 것이 좋습니다. 다시 작성된 동일한 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="378a590ed7ea217bc157b04f767bbce3a298baf9" translate="yes" xml:space="preserve">
          <source>In the above template we specify that the application relies on the &lt;code&gt;rspec-rails&lt;/code&gt; and &lt;code&gt;cucumber-rails&lt;/code&gt; gem so these two will be added to the &lt;code&gt;test&lt;/code&gt; group in the &lt;code&gt;Gemfile&lt;/code&gt;. Then we pose a question to the user about whether or not they would like to install Devise. If the user replies &quot;y&quot; or &quot;yes&quot; to this question, then the template will add Devise to the &lt;code&gt;Gemfile&lt;/code&gt; outside of any group and then runs the &lt;code&gt;devise:install&lt;/code&gt; generator. This template then takes the users input and runs the &lt;code&gt;devise&lt;/code&gt; generator, with the user's answer from the last question being passed to this generator.</source>
          <target state="translated">위의 템플릿에서 애플리케이션이 &lt;code&gt;rspec-rails&lt;/code&gt; 및 &lt;code&gt;cucumber-rails&lt;/code&gt; gem을 사용하도록 지정 &lt;code&gt;Gemfile&lt;/code&gt; 두 개가 Gemfile 의 &lt;code&gt;test&lt;/code&gt; 그룹에 추가되도록 지정합니다 . 그런 다음 사용자에게 Devise 설치 여부에 대한 질문을합니다. 사용자가이 질문에 &quot;y&quot;또는 &quot;yes&quot;로 응답하면 템플릿은 그룹 외부의 &lt;code&gt;Gemfile&lt;/code&gt; 에 Devise를 추가 한 다음 &lt;code&gt;devise:install&lt;/code&gt; 생성기 를 실행합니다 . 그런 다음이 템플릿은 사용자 입력을 가져 와서 &lt;code&gt;devise&lt;/code&gt; 생성기를 실행 하며 마지막 질문에 대한 사용자의 답변이이 생성기로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d28329a81b72878163d25972277a4b07abf621a9" translate="yes" xml:space="preserve">
          <source>In the authentication filter:</source>
          <target state="translated">인증 필터에서 :</target>
        </trans-unit>
        <trans-unit id="b9a1952af56540f70e0738c20b1efb6e624ed304" translate="yes" xml:space="preserve">
          <source>In the case above we could implement a dynamic access point:</source>
          <target state="translated">위의 경우 동적 액세스 포인트를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca6413dd0b8621bd4954d0e4a4e829ed7492594" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an &lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; object is used as the value.</source>
          <target state="translated">belongs_to 관계의 경우, &lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; 객체가 값으로 사용되는 경우 연관 키를 사용하여 모델을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05db8fea52973334b7d1041a94daa538e6e41de9" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.</source>
          <target state="translated">belong_to 관계의 경우, 활성 레코드 오브젝트가 값으로 사용되는 경우 연관 키를 사용하여 모델을 지정할 수 있습니다. 이 방법은 다형성 관계에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d93756087be58618e833c25f67ba938827e554d3" translate="yes" xml:space="preserve">
          <source>In the case of in-place transformations like &lt;code&gt;gsub!&lt;/code&gt; the receiver itself becomes unsafe.</source>
          <target state="translated">&lt;code&gt;gsub!&lt;/code&gt; 와 같은 내부 변환의 경우 ! 수신기 자체가 안전하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="f90f4443b51bcdba4e9b77cbfad0537dffd722d4" translate="yes" xml:space="preserve">
          <source>In the case where the &lt;code&gt;reorder&lt;/code&gt; clause is not used, the SQL executed would be:</source>
          <target state="translated">&lt;code&gt;reorder&lt;/code&gt; 절이 사용되지 않는 경우 실행 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="043c45971093b99cfaa59be2aec6275bba7ade66" translate="yes" xml:space="preserve">
          <source>In the development and test environments your application's secret key base is generated by Rails and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;. In all other environments, it is stored encrypted in the &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; file.</source>
          <target state="translated">개발 및 테스트 환경에서 애플리케이션의 비밀 키베이스는 Rails에 의해 생성되며 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 의 임시 파일에 저장됩니다 . 다른 모든 환경에서는 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 파일 에 암호화되어 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c75681960dd180c7b1234a9df577a41edc756ce2" translate="yes" xml:space="preserve">
          <source>In the end, he got a 4 KB worm, which he injected into his profile page.</source>
          <target state="translated">결국 4 KB 웜이 생겼으며 프로필 페이지에 주입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a9a0668d9e8b01d60ee00fef66c5a4fe3b886bf5" translate="yes" xml:space="preserve">
          <source>In the event that the collection is empty, &lt;code&gt;render&lt;/code&gt; will return nil, so it should be fairly simple to provide alternative content.</source>
          <target state="translated">컬렉션이 비어있는 경우 &lt;code&gt;render&lt;/code&gt; 는 nil을 반환하므로 대체 콘텐츠를 제공하는 것은 매우 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="59270391c73875761b1bc79e7f69878ff7f7d24a" translate="yes" xml:space="preserve">
          <source>In the event you need to access nested attributes within a given model, you should nest these under &lt;code&gt;model/attribute&lt;/code&gt; at the model level of your translation file:</source>
          <target state="translated">주어진 모델 내에서 중첩 된 속성에 액세스해야하는 경우 변환 파일의 모델 수준에서 &lt;code&gt;model/attribute&lt;/code&gt; 아래에 중첩되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6bcd3a44538f064cef6c5ae28aa20a97b263d372" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;render&lt;/code&gt; is the name of the event, and the rest is called the &lt;em&gt;payload&lt;/em&gt;. The payload is a mechanism that allows instrumenters to pass extra information to subscribers. Payloads consist of a hash whose contents are arbitrary and generally depend on the event.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;render&lt;/code&gt; 는 이벤트 이름이며 나머지는 &lt;em&gt;payload&lt;/em&gt; 라고합니다 . 페이로드는 인스트루먼트가 추가 정보를 가입자에게 전달할 수있는 메커니즘입니다. 페이로드는 내용이 임의적이며 일반적으로 이벤트에 의존하는 해시로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3d1821b9f0f188e97d2cc4c5d27dd0bb5e0290" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@post&lt;/code&gt; 가 새 레코드 인 경우 &quot;Create Post&quot;를 단추 레이블로 사용합니다. 그렇지 않으면 &quot;Update Post&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="12de8b2a7a4948b5a6d00dcc981ef44ca582121c" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as submit button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@post&lt;/code&gt; 가 새 레코드 인 경우 &quot;Create Post&quot;를 제출 단추 레이블로 사용합니다. 그렇지 않으면 &quot;Update Post&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3f14b2fb242760f899c366a5e39f1bd828c37f48" translate="yes" xml:space="preserve">
          <source>In the example above, if the format is xml, it will render:</source>
          <target state="translated">위의 예에서 형식이 xml이면 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a12f2deb8f1230067d03dc82012f59d41652e60e" translate="yes" xml:space="preserve">
          <source>In the examples above, the object to be created or edited was represented by a symbol passed to &lt;code&gt;form_for&lt;/code&gt;, and we noted that a string can also be used equivalently. It is also possible, however, to pass a model object itself to &lt;code&gt;form_for&lt;/code&gt;. For example, if &lt;code&gt;@post&lt;/code&gt; is an existing record you wish to edit, you can create the form using</source>
          <target state="translated">위의 예제에서 작성 또는 편집 할 오브젝트는 &lt;code&gt;form_for&lt;/code&gt; 에 전달 된 기호로 표시되었으며 문자열도 동일하게 사용할 수 있습니다. 그러나 모델 객체 자체를 &lt;code&gt;form_for&lt;/code&gt; 로 전달할 수도 있습니다 . 예를 들어, &lt;code&gt;@post&lt;/code&gt; 가 편집하려는 기존 레코드 인 경우 다음을 사용하여 양식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eed6ef156bb24a3a66221694c274d09c46bead3c" translate="yes" xml:space="preserve">
          <source>In the examples just shown, although not indicated explicitly, we still need to use the &lt;code&gt;:url&lt;/code&gt; option in order to specify where the form is going to be sent. However, further simplification is possible if the record passed to &lt;code&gt;form_for&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;, i.e. it corresponds to a set of RESTful routes, e.g. defined using the &lt;code&gt;resources&lt;/code&gt; method in &lt;code&gt;config/routes.rb&lt;/code&gt;. In this case Rails will simply infer the appropriate URL from the record itself. For example,</source>
          <target state="translated">방금 표시된 예제에서 명시 적으로 표시되지는 않았지만 양식을 보낼 위치를 지정하려면 여전히 &lt;code&gt;:url&lt;/code&gt; 옵션 을 사용해야합니다 . 그러나 &lt;code&gt;form_for&lt;/code&gt; 에 전달 된 레코드 가 &lt;em&gt;자원 인 경우&lt;/em&gt; , 즉 &lt;code&gt;config/routes.rb&lt;/code&gt; 의 &lt;code&gt;resources&lt;/code&gt; 메소드를 사용하여 정의 된 RESTful 라우트 세트에 해당하는 경우 추가 단순화가 가능합니다 . 이 경우 Rails는 단순히 레코드 자체에서 적절한 URL을 유추합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aa0683ade2679737cbdc05a148fe8c06a05a2542" translate="yes" xml:space="preserve">
          <source>In the first case, you can simply avoid using the same name for multiple routes. In the second, you can use the &lt;code&gt;only&lt;/code&gt; or &lt;code&gt;except&lt;/code&gt; options provided by the &lt;code&gt;resources&lt;/code&gt; method to restrict the routes created as detailed in the &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="translated">첫 번째 경우에는 여러 경로에 동일한 이름을 사용하지 않아도됩니다. 두 번째로, &lt;code&gt;resources&lt;/code&gt; 방법에서 제공 하는 &lt;code&gt;only&lt;/code&gt; 옵션 또는 &lt;code&gt;except&lt;/code&gt; 옵션 을 사용하여 &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;라우팅 가이드에&lt;/a&gt; 설명 된대로 생성 된 경로를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaeba8b8091b87a8ab856794d2cb5912acdd5a6" translate="yes" xml:space="preserve">
          <source>In the following example the Post model has many Comments stored within it in a NoSQL database, thus there is no primary key for comments.</source>
          <target state="translated">다음 예제에서 Post 모델에는 NoSQL 데이터베이스에 많은 주석이 저장되어 있으므로 주석의 기본 키가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4a3d8485ceda8e58b6d1bfce4e3d31c308fca89" translate="yes" xml:space="preserve">
          <source>In the following example, the inner &lt;code&gt;assert_select&lt;/code&gt; for &lt;code&gt;li.menu_item&lt;/code&gt; runs within the collection of elements selected by the outer block:</source>
          <target state="translated">다음 예에서, 내부 &lt;code&gt;assert_select&lt;/code&gt; 위한 &lt;code&gt;li.menu_item&lt;/code&gt; 이 외측 블록에 의해 선택된 요소의 컬렉션 내에서 실행 :</target>
        </trans-unit>
        <trans-unit id="f7bef9cb53d38149013bd74d2990ec374d378858" translate="yes" xml:space="preserve">
          <source>In the following example, the looping on users will always be done when the three columns 'first_name', 'last_name' and 'full_name' exist, even when migrating down:</source>
          <target state="translated">다음 예에서는 마이그레이션시에도 'first_name', 'last_name'및 'full_name'이라는 세 개의 열이 존재하면 사용자에 대한 루핑이 항상 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a22f54b5a9f917ca16377381a398c8ffa97e40c4" translate="yes" xml:space="preserve">
          <source>In the following example, the new column &lt;code&gt;published&lt;/code&gt; will be given the value &lt;code&gt;true&lt;/code&gt; for all existing records.</source>
          <target state="translated">다음 예에서 &lt;code&gt;published&lt;/code&gt; 새 열에 는 모든 기존 레코드에 대해 &lt;code&gt;true&lt;/code&gt; 값이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cf32ccab8bfedf8d3bd009f8023805f13eb7150" translate="yes" xml:space="preserve">
          <source>In the next section, you will add the ability to create new articles in your application and be able to view them. This is the &quot;C&quot; and the &quot;R&quot; from CRUD: create and read. The form for doing this will look like this:</source>
          <target state="translated">다음 섹션에서는 애플리케이션에서 새 기사를 작성하고 볼 수있는 기능을 추가합니다. CRUD의 &quot;C&quot;와 &quot;R&quot;은 create and read입니다. 이 작업을 수행하는 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8117729c34fd38f858f62c942b31df3e2602c4" translate="yes" xml:space="preserve">
          <source>In the output, &lt;code&gt;F&lt;/code&gt; denotes a failure. You can see the corresponding trace shown under &lt;code&gt;Failure&lt;/code&gt; along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:</source>
          <target state="translated">출력에서 &lt;code&gt;F&lt;/code&gt; 는 실패를 나타냅니다. 실패한 테스트 이름과 함께 &lt;code&gt;Failure&lt;/code&gt; 아래에 해당 추적이 표시됩니다 . 다음 몇 줄에는 스택 추적과 실제 값 및 어설 션의 예상 값을 언급하는 메시지가옵니다. 기본 어설 션 메시지는 오류를 정확히 찾아 낼 수있는 충분한 정보를 제공합니다. 어설 션 실패 메시지를보다 읽기 쉽게하기 위해 모든 어설 션은 다음과 같이 선택적 메시지 매개 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4db67d28b943836cff0a68073645d31f62ee1a8f" translate="yes" xml:space="preserve">
          <source>In the previous example it could be the case that &lt;code&gt;:log_level&lt;/code&gt; does not belong to the public interface of the library and it is only used for development. The client code, unaware of the potential conflict, subclasses and defines its own &lt;code&gt;:log_level&lt;/code&gt;. Thanks to &lt;code&gt;attr_internal&lt;/code&gt; there's no collision.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;:log_level&lt;/code&gt; 이 라이브러리의 공용 인터페이스에 속하지 않고 개발에만 사용되는 경우가 있습니다. 잠재적 충돌을 인식하지 못하는 클라이언트 코드는 자신의 &lt;code&gt;:log_level&lt;/code&gt; 을 서브 클래스 화하고 정의합니다 . &lt;code&gt;attr_internal&lt;/code&gt; 덕분에 충돌이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3908f2e1774247ac628c78d28b4387e97fe76ec2" translate="yes" xml:space="preserve">
          <source>In the previous example the macro generates &lt;code&gt;avatar_size&lt;/code&gt; rather than &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">이전 예제에서 매크로는 &lt;code&gt;avatar_size&lt;/code&gt; 아닌 avatar_size를 생성 &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35dfd724e5592aa2978efe9cdd4cbb5436938ecd" translate="yes" xml:space="preserve">
          <source>In the previous scenarios M would no longer be reachable through &lt;code&gt;A::B&lt;/code&gt; but the module object itself could still be alive somewhere and its name would still be &quot;A::B&quot;.</source>
          <target state="translated">이전 시나리오에서 M은 더 이상 &lt;code&gt;A::B&lt;/code&gt; 통해 도달 할 수 없지만 모듈 객체 자체는 여전히 어딘가에있을 수 있으며 이름은 여전히 ​​&quot;A :: B&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="240be3d54a3302b13164d042110cd1f87453480c" translate="yes" xml:space="preserve">
          <source>In the process of &lt;em&gt;localizing&lt;/em&gt; your application you'll probably want to do the following three things:</source>
          <target state="translated">응용 프로그램을 &lt;em&gt;지역화&lt;/em&gt; 하는 과정 에서 다음 세 가지를 수행하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6966b7531fe1cf3228dbcc40ef51e48619f56ef9" translate="yes" xml:space="preserve">
          <source>In the production environment Sprockets uses the fingerprinting scheme outlined above. By default Rails assumes assets have been precompiled and will be served as static assets by your web server.</source>
          <target state="translated">프로덕션 환경에서 Sprockets는 위에서 설명한 지문 체계를 사용합니다. 기본적으로 Rails는 자산이 사전 컴파일되어 웹 서버에서 정적 자산으로 제공된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fd699f9c03765d18ac7eeda7b127958136df039" translate="yes" xml:space="preserve">
          <source>In the rare case you don't want this hidden field, you can pass the &lt;code&gt;include_hidden: false&lt;/code&gt; option to the helper method.</source>
          <target state="translated">드문 경우이지만이 숨겨진 필드를 원하지 않으면 &lt;code&gt;include_hidden: false&lt;/code&gt; 옵션을 도우미 메소드에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="907dc721c200adc34c9cd1a38a774d66172f7072" translate="yes" xml:space="preserve">
          <source>In the rare event that your application needs to run some code before Rails itself is loaded, put it above the call to &lt;code&gt;require 'rails/all'&lt;/code&gt; in &lt;code&gt;config/application.rb&lt;/code&gt;.</source>
          <target state="translated">드문 경우지만 Rails 자체가로드되기 전에 애플리케이션이 일부 코드를 실행 &lt;code&gt;require 'rails/all'&lt;/code&gt; &lt;code&gt;config/application.rb&lt;/code&gt; 에서 'rails / all' 을 요구 하는 호출 위에 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="e343b15a5c1979c12b2ce78c1a6e9b635664460e" translate="yes" xml:space="preserve">
          <source>In the remainder of this guide, you'll learn how to declare and use the various forms of associations. But first, a quick introduction to the situations where each association type is appropriate.</source>
          <target state="translated">이 가이드의 나머지 부분에서는 다양한 형식의 연결을 선언하고 사용하는 방법을 배웁니다. 그러나 먼저 각 연관 유형이 적합한 상황에 대한 빠른 소개입니다.</target>
        </trans-unit>
        <trans-unit id="f1ecfbad640a171b281df19ce17b6db703c115aa" translate="yes" xml:space="preserve">
          <source>In the step above we simply wanted to add a line to the generated helper, without adding any extra functionality. There is a simpler way to do that, and it's by replacing the templates of already existing generators, in that case &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;.</source>
          <target state="translated">위의 단계에서 추가 기능을 추가하지 않고 생성 된 도우미에 행을 추가하려고했습니다. 이를 수행하는 더 간단한 방법이 있으며 기존 생성기의 템플릿 (이 경우 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4aca72171cec217a6a6f8419ee4e2bc7dffd58d" translate="yes" xml:space="preserve">
          <source>In the test we create the email and store the returned object in the &lt;code&gt;email&lt;/code&gt; variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect. The helper &lt;code&gt;read_fixture&lt;/code&gt; is used to read in the content from this file.</source>
          <target state="translated">테스트에서 이메일을 작성하고 리턴 된 오브젝트를 &lt;code&gt;email&lt;/code&gt; 변수 에 저장합니다 . 그런 다음이 메시지가 전송되었는지 확인하고 (첫 번째 어설 션) 두 번째 어설 션에서 이메일에 실제로 예상 한 내용이 포함되도록합니다. 도우미 &lt;code&gt;read_fixture&lt;/code&gt; 는이 파일의 내용을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffe3c0b50c71cf9044af6117e77e0043e0f0f60" translate="yes" xml:space="preserve">
          <source>In these cases the interpreter issues a warning though:</source>
          <target state="translated">이 경우 통역사는 다음과 같은 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="93ce4a58cfac5b635c26f22549185d914a6bdf90" translate="yes" xml:space="preserve">
          <source>In these examples, we have three implicit lookup scenarios:</source>
          <target state="translated">이 예제에는 세 가지 암시 적 조회 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="502f55decb79b29eb1515742d9f6251647206e2e" translate="yes" xml:space="preserve">
          <source>In this application:</source>
          <target state="translated">이 응용 프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="f245011a3468e934666f54bb9f814c5d90ff5341" translate="yes" xml:space="preserve">
          <source>In this case it will look for templates at &lt;code&gt;app/views/notifications&lt;/code&gt; with name &lt;code&gt;another&lt;/code&gt;. You can also specify an array of paths for &lt;code&gt;template_path&lt;/code&gt;, and they will be searched in order.</source>
          <target state="translated">이 경우 &lt;code&gt;app/views/notifications&lt;/code&gt; 에서 이름이 &lt;code&gt;another&lt;/code&gt; 인 템플릿을 찾습니다 . &lt;code&gt;template_path&lt;/code&gt; 의 경로 배열을 지정할 수도 있으며 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0d9d06832166b95bcc20a680a541dfc7390292e7" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;do_something_else&lt;/code&gt; gets executed before &lt;code&gt;log_children&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;do_something_else&lt;/code&gt; 가 &lt;code&gt;log_children&lt;/code&gt; 보다 먼저 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8ae7818af6dd8e94846acb9a537d14c62858b73" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;log_children&lt;/code&gt; gets executed before &lt;code&gt;do_something_else&lt;/code&gt;. The same applies to all non-transactional callbacks.</source>
          <target state="translated">이 경우 &lt;code&gt;log_children&lt;/code&gt; 은 &lt;code&gt;do_something_else&lt;/code&gt; 보다 먼저 실행 됩니다. 모든 비 트랜잭션 콜백에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="95b5def6a1eafc74bdaaae9878cf5714bb14081e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;options&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt; so nothing happens in this method.</source>
          <target state="translated">이 경우, &lt;code&gt;options&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 아니므로이 방법에서는 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4dc79e30fed233fc8c2b2718746ea33166b3079" translate="yes" xml:space="preserve">
          <source>In this case, Rails will create all of the normal routes except the route for &lt;code&gt;destroy&lt;/code&gt; (a &lt;code&gt;DELETE&lt;/code&gt; request to &lt;code&gt;/photos/:id&lt;/code&gt;).</source>
          <target state="translated">이 경우 Rails는 &lt;code&gt;destroy&lt;/code&gt; ( &lt;code&gt;/photos/:id&lt;/code&gt; 에 대한 &lt;code&gt;DELETE&lt;/code&gt; 요청) 경로를 제외한 모든 일반 경로를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8af14d976d9ce80f23b3242ec266f5b8244e100c" translate="yes" xml:space="preserve">
          <source>In this case, Rails will see that &lt;code&gt;@magazine&lt;/code&gt; is a &lt;code&gt;Magazine&lt;/code&gt; and &lt;code&gt;@ad&lt;/code&gt; is an &lt;code&gt;Ad&lt;/code&gt; and will therefore use the &lt;code&gt;magazine_ad_path&lt;/code&gt; helper. In helpers like &lt;code&gt;link_to&lt;/code&gt;, you can specify just the object in place of the full &lt;code&gt;url_for&lt;/code&gt; call:</source>
          <target state="translated">이 경우 Rails는 &lt;code&gt;@magazine&lt;/code&gt; 은 &lt;code&gt;Magazine&lt;/code&gt; 이고 &lt;code&gt;@ad&lt;/code&gt; 는 &lt;code&gt;Ad&lt;/code&gt; 이므로 &lt;code&gt;magazine_ad_path&lt;/code&gt; 도우미를 사용합니다 . &lt;code&gt;link_to&lt;/code&gt; 와 같은 도우미에서는 전체 &lt;code&gt;url_for&lt;/code&gt; 호출 대신 객체 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec98966b432fd02dd889acb0e3ae363d24f7331a" translate="yes" xml:space="preserve">
          <source>In this case, Rails will use the customer or employee partials as appropriate for each member of the collection.</source>
          <target state="translated">이 경우 Rails는 컬렉션의 각 멤버에 따라 고객 또는 직원 부분을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="324afa7d33283fa836e991ed242a0c763e9a50ca" translate="yes" xml:space="preserve">
          <source>In this case, after saving our new entry to the database, the user is redirected to the &lt;code&gt;show&lt;/code&gt; method, which is then executed. Note that this is an external HTTP-level redirection which will cause the browser to make a second request (a GET to the show action), and not some internal re-routing which calls both &amp;ldquo;create&amp;rdquo; and then &amp;ldquo;show&amp;rdquo; within one request.</source>
          <target state="translated">이 경우, 새 항목을 데이터베이스에 저장 한 후 사용자는 &lt;code&gt;show&lt;/code&gt; 메소드로 경로 재 지정된 후 실행됩니다. 이는 외부 HTTP 레벨 리디렉션으로, 브라우저가 두 번째 요청 (show 조치에 대한 GET)을 작성하지만 한 요청 내에서 &quot;create&quot;와 &quot;show&quot;를 모두 호출하는 일부 내부 경로 재 지정이 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="90d76c0d057ec80df1313425905dbf5fc8817833" translate="yes" xml:space="preserve">
          <source>In this case, if you use this:</source>
          <target state="translated">이 경우에 이것을 사용하면 :</target>
        </trans-unit>
        <trans-unit id="1be8ecd1ff257edb9a048d380cba8d414155c70d" translate="yes" xml:space="preserve">
          <source>In this case, if you use:</source>
          <target state="translated">이 경우 다음을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="45910dcc6fa37937e878c391486df7457ff27ceb" translate="yes" xml:space="preserve">
          <source>In this case, instead of the default block, which would return &lt;code&gt;content_for(:layout)&lt;/code&gt;, this method returns the block that was passed in to &lt;code&gt;render :layout&lt;/code&gt;, and the response would be</source>
          <target state="translated">이 경우 &lt;code&gt;content_for(:layout)&lt;/code&gt; 반환하는 기본 블록 대신 이 메소드는 &lt;code&gt;render :layout&lt;/code&gt; 에 전달 된 블록을 반환 하며 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23294ab6faccc1c47ad44363cc9caeae8dba7046" translate="yes" xml:space="preserve">
          <source>In this case, it is usually more natural to include an association which has conditions defined on it:</source>
          <target state="translated">이 경우 일반적으로 조건이 정의 된 연관을 포함시키는 것이 더 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="3682a82419f80b6aaba8341e83ca11b591eb3f0f" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a book will update the timestamp on the associated author. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">이 경우 책을 저장하거나 삭제하면 관련 작성자의 타임 스탬프가 업데이트됩니다. 업데이트 할 특정 타임 스탬프 속성을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="46550e2dc92461d1a9bec5aa815cb8c7643c013c" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a supplier will update the timestamp on the associated account. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">이 경우 공급 업체를 저장하거나 폐기하면 관련 계정의 타임 스탬프가 업데이트됩니다. 업데이트 할 특정 타임 스탬프 속성을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a3fa81533cea880dc23c87f021c293fd2df3af" translate="yes" xml:space="preserve">
          <source>In this case, the checkbox field will be represented by an HTML &lt;code&gt;input&lt;/code&gt; tag with the &lt;code&gt;name&lt;/code&gt; attribute &lt;code&gt;permission[admin]&lt;/code&gt;, and the submitted value will appear in the controller as &lt;code&gt;params[:permission][:admin]&lt;/code&gt;. If &lt;code&gt;@person.permission&lt;/code&gt; is an existing record with an attribute &lt;code&gt;admin&lt;/code&gt;, the initial state of the checkbox when first displayed will reflect the value of &lt;code&gt;@person.permission.admin&lt;/code&gt;.</source>
          <target state="translated">이 경우, 확인란 필드는 &lt;code&gt;name&lt;/code&gt; 속성 &lt;code&gt;permission[admin]&lt;/code&gt; 과 함께 HTML &lt;code&gt;input&lt;/code&gt; 태그로 표시되며 제출 된 값은 컨트롤러에 &lt;code&gt;params[:permission][:admin]&lt;/code&gt; 으로 나타납니다 . 경우 &lt;code&gt;@person.permission&lt;/code&gt; 속성을 가진 기존의 기록이다 &lt;code&gt;admin&lt;/code&gt; , 최초의 값이 반영됩니다 표시 체크 박스의 초기 상태 &lt;code&gt;@person.permission.admin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31b43893b5d7d80c3642e5735940479c8a39085" translate="yes" xml:space="preserve">
          <source>In this case, the layout would receive the block passed into &lt;code&gt;render
:layout&lt;/code&gt;, and the struct specified would be passed into the block as an argument. The result would be</source>
          <target state="translated">이 경우 레이아웃은 &lt;code&gt;render :layout&lt;/code&gt; 전달 된 블록을 수신하고 지정된 struct가 인수로 블록에 전달됩니다. 결과는</target>
        </trans-unit>
        <trans-unit id="eb428f6fa982c5a012e150312c045633b5daa11c" translate="yes" xml:space="preserve">
          <source>In this case, the partial will have access to a local variable &lt;code&gt;title&lt;/code&gt; with the value &quot;Products Page&quot;.</source>
          <target state="translated">이 경우 부분은 값이 &quot;Products Page&quot;인 로컬 변수 &lt;code&gt;title&lt;/code&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0271f9329c9956c7be3a8dd886bdf6c333e85c14" translate="yes" xml:space="preserve">
          <source>In this case, the problem is that when the &lt;code&gt;before_destroy&lt;/code&gt; callback is executed, the children are not available because the &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord::Base#destroy&lt;/a&gt; callback gets executed first. You can use the &lt;code&gt;prepend&lt;/code&gt; option on the &lt;code&gt;before_destroy&lt;/code&gt; callback to avoid this.</source>
          <target state="translated">이 경우, &lt;code&gt;before_destroy&lt;/code&gt; 콜백이 실행될 때 &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord :: Base # destroy&lt;/a&gt; 콜백이 먼저 실행 되므로 자식을 사용할 수 없다는 문제가 있습니다 . 이를 방지하기 위해 &lt;code&gt;before_destroy&lt;/code&gt; 콜백 에서 &lt;code&gt;prepend&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9baf39f668787b7ea9b2708f867d659f69a15343" translate="yes" xml:space="preserve">
          <source>In this case, when a user opens the URL &lt;code&gt;/clients/active&lt;/code&gt;, &lt;code&gt;params[:status]&lt;/code&gt; will be set to &quot;active&quot;. When this route is used, &lt;code&gt;params[:foo]&lt;/code&gt; will also be set to &quot;bar&quot;, as if it were passed in the query string. Your controller will also receive &lt;code&gt;params[:action]&lt;/code&gt; as &quot;index&quot; and &lt;code&gt;params[:controller]&lt;/code&gt; as &quot;clients&quot;.</source>
          <target state="translated">사용자가 URL 열면이 경우 &lt;code&gt;/clients/active&lt;/code&gt; , &lt;code&gt;params[:status]&lt;/code&gt; &quot;활성&quot;으로 설정한다. 이 경로를 사용하면 &lt;code&gt;params[:foo]&lt;/code&gt; 도 마치 쿼리 문자열에 전달 된 것처럼 &quot;bar&quot;로 설정됩니다. 또한 컨트롤러는 &lt;code&gt;params[:action]&lt;/code&gt; 을 &quot;index&quot;로, &lt;code&gt;params[:controller]&lt;/code&gt; 를 &quot;clients&quot;로받습니다.</target>
        </trans-unit>
        <trans-unit id="0a36fec3659c2de19ce884ca0a800b73a334ea2d" translate="yes" xml:space="preserve">
          <source>In this case, you would need to configure the proxy server (NGINX, Apache, etc) to accept connections from your application server (Unicorn). By default Unicorn will listen for TCP connections on port 8080, but you can change the port or configure it to use sockets instead.</source>
          <target state="translated">이 경우 응용 프로그램 서버 (유니콘)의 연결을 허용하도록 프록시 서버 (NGINX, Apache 등)를 구성해야합니다. 기본적으로 Unicorn은 포트 8080에서 TCP 연결을 수신하지만 포트를 변경하거나 소켓을 대신 사용하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede2f597296609c3cbf7e0fc1896d94a0128407a" translate="yes" xml:space="preserve">
          <source>In this example a &lt;code&gt;balance&lt;/code&gt; record is transactionally saved even though &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;transaction&lt;/a&gt; is called on the &lt;code&gt;Account&lt;/code&gt; class:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;거래가 &lt;/a&gt; &lt;code&gt;Account&lt;/code&gt; 클래스 에서 호출 되더라도 &lt;code&gt;balance&lt;/code&gt; 레코드가 거래 방식으로 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="8315e856964911dcdef9965da60bf232cff0ef4f" translate="yes" xml:space="preserve">
          <source>In this example the filter is added to &lt;code&gt;ApplicationController&lt;/code&gt; and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with &lt;code&gt;skip_before_action&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 필터는 &lt;code&gt;ApplicationController&lt;/code&gt; 에 추가 되므로 애플리케이션의 모든 컨트롤러가이를 상속합니다. 응용 프로그램의 모든 것을 사용하려면 사용자가 로그인해야합니다. 명백한 이유로 (사용자가 처음에 로그인 할 수 없습니다!), 모든 컨트롤러 나 작업에서이를 요구하지는 않습니다. &lt;code&gt;skip_before_action&lt;/code&gt; 을 사용 하여 특정 조치 전에이 필터가 실행되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ed05101913eb841250d9350938e2a1cbfaa622" translate="yes" xml:space="preserve">
          <source>In this example you will add a method to String named &lt;code&gt;to_squawk&lt;/code&gt;. To begin, create a new test file with a few assertions:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;to_squawk&lt;/code&gt; 라는 문자열에 메소드를 추가합니다 . 시작하려면 몇 가지 주장으로 새 테스트 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="fedd050168d34065a17d9d68e74077e8c1d0a4f1" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;require_self&lt;/code&gt; is used. This puts the CSS contained within the file (if any) at the precise location of the &lt;code&gt;require_self&lt;/code&gt; call.</source>
          <target state="translated">이 예에서는 &lt;code&gt;require_self&lt;/code&gt; 가 사용됩니다. 이렇게하면 &lt;code&gt;require_self&lt;/code&gt; 호출 의 정확한 위치에 파일에 포함 된 CSS가 있습니다 (있는 경우) .</target>
        </trans-unit>
        <trans-unit id="5d763f0c08a6e36b13bfd4f55c2b0c56d55c2060" translate="yes" xml:space="preserve">
          <source>In this example, if any before validate callbacks returns &lt;code&gt;false&lt;/code&gt;, any successive before and around callback is not executed.</source>
          <target state="translated">이 예에서 before validate 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 연속적인 전후 콜백이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b577440c4b67419e3dd43e87c84951cf5901392" translate="yes" xml:space="preserve">
          <source>In this example, the :iphone format will be used if it's available, otherwise it'll fallback to the :html format.</source>
          <target state="translated">이 예에서 : iphone 형식은 사용 가능한 경우에 사용되며 그렇지 않으면 : html 형식으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7e25f6b231c3e7a583a15488e6962be811bbb8cb" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;articles_path&lt;/code&gt; helper is passed to the &lt;code&gt;:url&lt;/code&gt; option. To see what Rails will do with this, we look back at the output of &lt;code&gt;rails routes&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 &lt;code&gt;articles_path&lt;/code&gt; 헬퍼는 &lt;code&gt;:url&lt;/code&gt; 옵션으로 전달됩니다 . Rails가 이것으로 무엇을하는지보기 위해, 우리는 &lt;code&gt;rails routes&lt;/code&gt; 의 출력을 되돌아 봅니다 :</target>
        </trans-unit>
        <trans-unit id="cefad5f74cb38773452302635f93e20f8d80d081" translate="yes" xml:space="preserve">
          <source>In this example, the first question mark will be replaced with the value in &lt;code&gt;params[:orders]&lt;/code&gt; and the second will be replaced with the SQL representation of &lt;code&gt;false&lt;/code&gt;, which depends on the adapter.</source>
          <target state="translated">이 예에서 첫 번째 물음표는 &lt;code&gt;params[:orders]&lt;/code&gt; 의 값으로 대체되고 두 번째 물음표는 어댑터에 따라 &lt;code&gt;false&lt;/code&gt; 의 SQL 표시로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1c27b9227975c797fa6b2e2b282ef1471c2fa42" translate="yes" xml:space="preserve">
          <source>In this example, the subscribed and unsubscribed methods are not callable methods, as they were already declared in &lt;a href=&quot;base&quot;&gt;ActionCable::Channel::Base&lt;/a&gt;, but &lt;code&gt;#appear&lt;/code&gt; and &lt;code&gt;#away&lt;/code&gt; are. &lt;code&gt;#generate_connection_token&lt;/code&gt; is also not callable, since it's a private method. You'll see that appear accepts a data parameter, which it then uses as part of its model call. &lt;code&gt;#away&lt;/code&gt; does not, since it's simply a trigger action.</source>
          <target state="translated">이 예제에서 구독 및 구독 취소 된 메소드는 &lt;a href=&quot;base&quot;&gt;ActionCable :: Channel :: Base&lt;/a&gt; 에서 이미 선언되었으므로 호출 가능한 메소드는 아니지만 &lt;code&gt;#appear&lt;/code&gt; 및 &lt;code&gt;#away&lt;/code&gt; 는 호출 가능한 메소드 입니다. &lt;code&gt;#generate_connection_token&lt;/code&gt; 도 비공개 메소드이므로 호출 할 수 없습니다. appear는 데이터 매개 변수를 승인 한 후 모델 호출의 일부로 사용함을 알 수 있습니다. &lt;code&gt;#away&lt;/code&gt; 는 단순히 트리거 작업 이므로 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e06e6bc72e0675f6e83f410d12668e53aa905bf" translate="yes" xml:space="preserve">
          <source>In this example, the subscription will be rejected if the &lt;code&gt;current_user&lt;/code&gt; does not have access to the chat room. On the client-side, the &lt;code&gt;Channel#rejected&lt;/code&gt; callback will get invoked when the server rejects the subscription request.</source>
          <target state="translated">이 예에서 &lt;code&gt;current_user&lt;/code&gt; 가 대화방에 액세스 할 수없는 경우 구독이 거부됩니다 . 클라이언트 측 에서 서버가 구독 요청을 거부하면 &lt;code&gt;Channel#rejected&lt;/code&gt; 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e4189c06b24b1d007060ef87497a67e0f217bf84" translate="yes" xml:space="preserve">
          <source>In this guide you will learn about engines and how they can be used to provide additional functionality to their host applications through a clean and very easy-to-use interface.</source>
          <target state="translated">이 안내서에서는 엔진에 대해 배우고 엔진을 사용하여 깨끗하고 사용하기 쉬운 인터페이스를 통해 호스트 응용 프로그램에 추가 기능을 제공하는 방법에 대해 학습합니다.</target>
        </trans-unit>
        <trans-unit id="62fddb8ee2378135835c382d27251f82d4d91a62" translate="yes" xml:space="preserve">
          <source>In this guide you will learn how controllers work and how they fit into the request cycle in your application.</source>
          <target state="translated">이 안내서에서는 컨트롤러의 작동 방식과 컨트롤러가 애플리케이션의 요청주기에 어떻게 적용되는지 배웁니다.</target>
        </trans-unit>
        <trans-unit id="cf19788f5357ece34c60a8480d19af8f12bf7ec6" translate="yes" xml:space="preserve">
          <source>In this guide you will learn:</source>
          <target state="translated">이 안내서에서는 다음을 배우게됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6643c2d1d2064aadb116664a08bad47743e0a1" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how Action Cable works and how to use WebSockets to incorporate real-time features into your Rails application.</source>
          <target state="translated">이 가이드에서는 Action Cable의 작동 방식과 WebSockets를 사용하여 실시간 기능을 Rails 애플리케이션에 통합하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="bdf3816ba71ddd3fd76041fa284bf113f06c1558" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how to use the instrumentation API inside of Active Support to measure events inside of Rails and other Ruby code.</source>
          <target state="translated">이 안내서에서는 Active Support 내에서 인스 트루먼 테이션 API를 사용하여 Rails 및 기타 Ruby 코드 내의 이벤트를 측정하는 방법을 학습합니다.</target>
        </trans-unit>
        <trans-unit id="17d6f3660a8d0024f2df0642dcac76b33986119b" translate="yes" xml:space="preserve">
          <source>In this instance the &lt;code&gt;params&lt;/code&gt; object comes from the context in which the block is executed, e.g. generating a URL inside a controller action or a view. If the block is executed where there isn't a &lt;code&gt;params&lt;/code&gt; object such as this:</source>
          <target state="translated">이 경우 &lt;code&gt;params&lt;/code&gt; 객체는 블록이 실행되는 컨텍스트에서 가져옵니다 (예 : 컨트롤러 작업 또는보기 내부에 URL 생성). 다음 과 같은 &lt;code&gt;params&lt;/code&gt; 객체 가없는 곳에서 블록을 실행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e775a416c0401e99c05491f16f2e3ad2f0b37cf9" translate="yes" xml:space="preserve">
          <source>In this section, you will learn how to find and fix such leaks by using tool such as Valgrind.</source>
          <target state="translated">이 섹션에서는 Valgrind와 같은 도구를 사용하여 이러한 누수를 찾고 수정하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="7264044f5a1a998f82bc2a0fb68556ba4a58797d" translate="yes" xml:space="preserve">
          <source>In this usage, the argument passed to the block (&lt;code&gt;format&lt;/code&gt; above) is an instance of the &lt;a href=&quot;collector&quot;&gt;ActionController::MimeResponds::Collector&lt;/a&gt; class. This object serves as a container in which available responses can be stored by calling any of the dynamically generated, mime-type-specific methods such as &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; etc on the &lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt;. Each response is represented by a corresponding block if present.</source>
          <target state="translated">이 사용법에서 블록에 전달 된 인수 ( 위 &lt;code&gt;format&lt;/code&gt; )는 &lt;a href=&quot;collector&quot;&gt;ActionController :: MimeResponds :: Collector&lt;/a&gt; 클래스 의 인스턴스입니다 . 이 객체는 &lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt; 에서 &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;xml&lt;/code&gt; 등과 같이 동적으로 생성 된 MIME 유형별 메소드를 호출하여 사용 가능한 응답을 저장할 수있는 컨테이너 역할을합니다 . 각 응답은 해당 블록이 있으면 해당 블록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="33174322f55d37e3ac00f4a987ec114066590e1a" translate="yes" xml:space="preserve">
          <source>In those cases, you may give an options hash a distinguished treatment with &lt;code&gt;extract_options!&lt;/code&gt;. This method checks the type of the last item of an array. If it is a hash it pops it and returns it, otherwise it returns an empty hash.</source>
          <target state="translated">이 경우 &lt;code&gt;extract_options!&lt;/code&gt; 사용하여 옵션 해시에 고유 처리를 제공 할 수 있습니다 ! . 이 메소드는 배열의 마지막 항목 유형을 확인합니다. 해시 인 경우 팝업하여 반환하고, 그렇지 않으면 빈 해시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a550daa4f417c340f8beea7b13981602f9c09f42" translate="yes" xml:space="preserve">
          <source>In your &lt;code&gt;test_helper.rb&lt;/code&gt; add the following:</source>
          <target state="translated">당신에 &lt;code&gt;test_helper.rb&lt;/code&gt; 다음을 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="6d1f8e8d9a788b93b49454806edd8d6f19ea0326" translate="yes" xml:space="preserve">
          <source>In your controller you can access the session through the &lt;code&gt;session&lt;/code&gt; instance method.</source>
          <target state="translated">컨트롤러에서 &lt;code&gt;session&lt;/code&gt; 인스턴스 방법을 통해 세션에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20313399289d6ad32ea0f25486fb25f73b6a1650" translate="yes" xml:space="preserve">
          <source>In your integration tests, you can do something like this:</source>
          <target state="translated">통합 테스트에서 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77569b20d1403399dd78bff7dad56dca4c39d837" translate="yes" xml:space="preserve">
          <source>In your migrations/schema, you will add a references column to the model itself.</source>
          <target state="translated">마이그레이션 / 스키마에서 모델 자체에 참조 열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ed89d3298ab08bf564636e9e1eea9e37ffc2f147" translate="yes" xml:space="preserve">
          <source>In your view template you could use something like</source>
          <target state="translated">뷰 템플릿에서 다음과 같은 것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82340ae6007cc58d7c548a04779b98577444585b" translate="yes" xml:space="preserve">
          <source>InboundEmail</source>
          <target state="translated">InboundEmail</target>
        </trans-unit>
        <trans-unit id="a2ca380949bd2057d6cdc7b1a64745c4fb788fad" translate="yes" xml:space="preserve">
          <source>InboundEmail#mail</source>
          <target state="translated">InboundEmail#mail</target>
        </trans-unit>
        <trans-unit id="54414ba50dcb2d80fb74313ab3fda2b9f0df9706" translate="yes" xml:space="preserve">
          <source>InboundEmail#processed?</source>
          <target state="translated">InboundEmail#processed?</target>
        </trans-unit>
        <trans-unit id="824dd431201525fd3c331dec03aa796e0bdf2999" translate="yes" xml:space="preserve">
          <source>InboundEmail#source</source>
          <target state="translated">InboundEmail#source</target>
        </trans-unit>
        <trans-unit id="a4b17cd6aa1bb27eacde79de6be6eb12a19d8fb5" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable</source>
          <target state="translated">InboundEmail::Incineratable</target>
        </trans-unit>
        <trans-unit id="8f576111d92a7d2712339c8f9909670add70e0da" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate</source>
          <target state="translated">InboundEmail::Incineratable#incinerate</target>
        </trans-unit>
        <trans-unit id="ab3295021ae0509b9a0423771d3bb8027490f71f" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate_later</source>
          <target state="translated">InboundEmail::Incineratable#incinerate_later</target>
        </trans-unit>
        <trans-unit id="4a96b1371404b43e410f57979e0fc13280a27420" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration</source>
          <target state="translated">InboundEmail::Incineratable::Incineration</target>
        </trans-unit>
        <trans-unit id="4f0b1cec59ebbd3a8456fb217fa4aca34edbfa2c" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration#run</source>
          <target state="translated">InboundEmail::Incineratable::Incineration#run</target>
        </trans-unit>
        <trans-unit id="51cfcbf40a300479b6e6bcbd940a6d346920ecf1" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration::new</source>
          <target state="translated">InboundEmail::Incineratable::Incineration::new</target>
        </trans-unit>
        <trans-unit id="40bbbecf96c6d12682faff9578d52533226f3c97" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId</source>
          <target state="translated">InboundEmail::MessageId</target>
        </trans-unit>
        <trans-unit id="154e37c7872ea04e9018c3d4634f5f5f366b70d0" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#create_and_extract_message_id!</source>
          <target state="translated">InboundEmail::MessageId#create_and_extract_message_id!</target>
        </trans-unit>
        <trans-unit id="3e18904aabd7444b3358c765ab98ff3e7a93289b" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#extract_message_id</source>
          <target state="translated">InboundEmail::MessageId#extract_message_id</target>
        </trans-unit>
        <trans-unit id="f5912d0e9fb9f1a27f3fcc3d7157b541ab860c0f" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#generate_missing_message_id</source>
          <target state="translated">InboundEmail::MessageId#generate_missing_message_id</target>
        </trans-unit>
        <trans-unit id="2c0be3c66e86606aab01bf26322bb4ede14060b8" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable</source>
          <target state="translated">InboundEmail::Routable</target>
        </trans-unit>
        <trans-unit id="6c6b1b612c3911b90fce7e2e5e0d1ef6e415c371" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable#route</source>
          <target state="translated">InboundEmail::Routable#route</target>
        </trans-unit>
        <trans-unit id="ff0fbc44503d8cb2db7d66abca56d62be677cace" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable#route_later</source>
          <target state="translated">InboundEmail::Routable#route_later</target>
        </trans-unit>
        <trans-unit id="acbf3a393e68b6f6f34e91d2c28dcbb1f27f41ad" translate="yes" xml:space="preserve">
          <source>Incineration of InboundEmails</source>
          <target state="translated">인바운드 이메일 소각</target>
        </trans-unit>
        <trans-unit id="46f00fe566c2a85a7ae293976c1f5cc228d97a9f" translate="yes" xml:space="preserve">
          <source>IncinerationJob</source>
          <target state="translated">IncinerationJob</target>
        </trans-unit>
        <trans-unit id="9a3b927462c4fc3601133e7ebb25fa8381442e2e" translate="yes" xml:space="preserve">
          <source>IncinerationJob#perform</source>
          <target state="translated">IncinerationJob#perform</target>
        </trans-unit>
        <trans-unit id="cac65a7ffa3df433e8908fd590e410aeec250ed8" translate="yes" xml:space="preserve">
          <source>IncinerationJob::schedule</source>
          <target state="translated">IncinerationJob::schedule</target>
        </trans-unit>
        <trans-unit id="5c9882c571c76e2d7257004676310a0cdec5e265" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;activestorage.js&lt;/code&gt; in your application's JavaScript bundle.</source>
          <target state="translated">애플리케이션의 JavaScript 번들에 &lt;code&gt;activestorage.js&lt;/code&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bec07c62228d9d427b17ec331ffe481e3050aea" translate="yes" xml:space="preserve">
          <source>Include a field with the current UTC time-stamp in it and check it on the server. If it is too far in the past, or if it is in the future, the form is invalid.</source>
          <target state="translated">현재 UTC 시간 소인이있는 필드를 포함시키고 서버에서 확인하십시오. 과거에 너무 멀거나 미래에있을 경우 양식이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f121e28368bea6b8e2ce8d128829d6efaa5b3b4a" translate="yes" xml:space="preserve">
          <source>Include in a cookie jar to allow chaining, e.g. cookies.permanent.signed.</source>
          <target state="translated">쿠키를 포함하여 체인을 허용합니다 (예 : cookies.permanent.signed).</target>
        </trans-unit>
        <trans-unit id="c100b7d867e6c16b5bd5b980d88e6a2a50d8f041" translate="yes" xml:space="preserve">
          <source>Include more than one honeypot field of all types, including submission buttons</source>
          <target state="translated">제출 버튼을 포함하여 모든 유형의 허니팟 필드를 두 개 이상 포함</target>
        </trans-unit>
        <trans-unit id="4c5f87743501282fa63fbaffa15c1a3acc9cc8cd" translate="yes" xml:space="preserve">
          <source>Included modules:</source>
          <target state="translated">포함 된 모듈 :</target>
        </trans-unit>
        <trans-unit id="bdf9b5829b7161238ada537108b7fe4a6e34fa4e" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;url_for&lt;/code&gt; into the host class (e.g. an abstract controller or mailer). The class has to provide a &lt;code&gt;RouteSet&lt;/code&gt; by implementing the &lt;code&gt;_routes&lt;/code&gt; methods. Otherwise, an exception will be raised.</source>
          <target state="translated">호스트 클래스 (예 : 추상 컨트롤러 또는 메일러)에 &lt;code&gt;url_for&lt;/code&gt; 를 포함 합니다. 클래스는 제공해야 &lt;code&gt;RouteSet&lt;/code&gt; 을 이행함으로써 &lt;code&gt;_routes&lt;/code&gt; 의 방법을. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b4374eea981f26c15f5994eec0f3f1ab7ef8047" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;url_for&lt;/code&gt; into the host class. The class has to provide a &lt;code&gt;RouteSet&lt;/code&gt; by implementing the &lt;code&gt;_routes&lt;/code&gt; method. Otherwise, an exception will be raised.</source>
          <target state="translated">호스트 클래스에 &lt;code&gt;url_for&lt;/code&gt; 를 포함합니다 . 클래스는 제공해야 &lt;code&gt;RouteSet&lt;/code&gt; 을 이행함으로써 &lt;code&gt;_routes&lt;/code&gt; 의 방법을. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5579a2df75038fb652d0231bd1004d082f10429" translate="yes" xml:space="preserve">
          <source>Includes methods for executing and performing jobs instantly.</source>
          <target state="translated">작업을 즉시 실행하고 수행하는 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="631b012f0c3aa49dec56ba3a62ff5bff3b8b3f91" translate="yes" xml:space="preserve">
          <source>Includes the &lt;code&gt;perform_later&lt;/code&gt; method for job initialization.</source>
          <target state="translated">작업 초기화를위한 &lt;code&gt;perform_later&lt;/code&gt; 메소드를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="53c7595c01b9dbfe8612fe4bc1db96f60de2a369" translate="yes" xml:space="preserve">
          <source>Includes the ability to override the default queue name and prefix.</source>
          <target state="translated">기본 대기열 이름과 접두사를 재정의하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7990a0676a74bda5cc28e40baf19fd593e762c7" translate="yes" xml:space="preserve">
          <source>Includes the ability to override the default queue priority.</source>
          <target state="translated">기본 대기열 우선 순위를 무시하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e15c12fa809cf4ddf2cfdca94bdae62aa1fa326a" translate="yes" xml:space="preserve">
          <source>Includes the required interface for an object to interact with Action Pack and Action View, using different Active &lt;a href=&quot;model&quot;&gt;Model&lt;/a&gt; modules. It includes model name introspections, conversions, translations and validations. Besides that, it allows you to initialize the object with a hash of attributes, pretty much like Active Record does.</source>
          <target state="translated">다른 Active &lt;a href=&quot;model&quot;&gt;Model&lt;/a&gt; 모듈을 사용하여 객체가 Action Pack 및 Action View와 상호 작용하는 데 필요한 인터페이스를 포함합니다 . 여기에는 모델 이름 내부 검사, 변환, 변환 및 유효성 검사가 포함됩니다. 게다가 Active Record와 거의 비슷한 속성의 해시로 객체를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7fea2d3a0b9e01a0a5f139f1591c47d3c91bbc9" translate="yes" xml:space="preserve">
          <source>Includes the setter method for changing the active queue adapter.</source>
          <target state="translated">활성 큐 어댑터를 변경하기위한 setter 메소드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="aa5f93716a712ea4619d480ed3cde7ae07449569" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;ActionController::Live&lt;/code&gt; inside of your controller class will provide all actions inside of the controller the ability to stream data. You can mix in the module like so:</source>
          <target state="translated">컨트롤러 클래스 내부에 &lt;code&gt;ActionController::Live&lt;/code&gt; 포함 하면 컨트롤러 내부의 모든 작업에 데이터 스트리밍 기능이 제공됩니다. 다음과 같이 모듈을 혼합 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bab20420de5d9ccbf10b3dcff8cc1b95ab75628b" translate="yes" xml:space="preserve">
          <source>Including a nonce (a random value) in the session solves replay attacks. A nonce is valid only once, and the server has to keep track of all the valid nonces. It gets even more complicated if you have several application servers. Storing nonces in a database table would defeat the entire purpose of CookieStore (avoiding accessing the database).</source>
          <target state="translated">세션에 nonce (임의의 값)를 포함하면 재생 공격이 해결됩니다. nonce는 한 번만 유효하며 서버는 모든 유효한 nonces를 추적해야합니다. 여러 응용 프로그램 서버가 있으면 훨씬 더 복잡해집니다. 데이터베이스 테이블에 nonces를 저장하면 CookieStore의 전체 목적을 상실하게됩니다 (데이터베이스 액세스를 피함).</target>
        </trans-unit>
        <trans-unit id="3ba3a191a2f605b7f6e1de97049978194d3e3d3a" translate="yes" xml:space="preserve">
          <source>Increment a cached value. This method uses the Redis incr atomic operator and can only be used on values written with the :raw option. Calling it on a value not stored with :raw will initialize that value to zero.</source>
          <target state="translated">캐시 된 값을 증가시킵니다. 이 방법은 Redis incr 원자 연산자를 사용하며 : raw 옵션으로 작성된 값에만 사용할 수 있습니다. : raw와 함께 저장되지 않은 값에서 호출하면 해당 값이 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="84d6064c26c32bbd7bab16ef8fd8429566031c22" translate="yes" xml:space="preserve">
          <source>Increment a cached value. This method uses the memcached incr atomic operator and can only be used on values written with the :raw option. Calling it on a value not stored with :raw will initialize that value to zero.</source>
          <target state="translated">캐시 된 값을 증가시킵니다. 이 방법은 memcached incr 원자 연산자를 사용하며 : raw 옵션으로 작성된 값에만 사용할 수 있습니다. : raw와 함께 저장되지 않은 값에서 호출하면 해당 값이 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="dd0c837987bda03b85ceb94f7c3cfea331fe8115" translate="yes" xml:space="preserve">
          <source>Increment a numeric field by one, via a direct SQL update.</source>
          <target state="translated">직접 SQL 업데이트를 통해 숫자 필드를 하나씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="975a549b7ff243eb9938d718f3659245c93a9383" translate="yes" xml:space="preserve">
          <source>Increment an integer value in the cache.</source>
          <target state="translated">캐시에서 정수 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="78f8148e4691770bb4ee98b5331ee87d3d67f053" translate="yes" xml:space="preserve">
          <source>Increments an already existing integer value that is stored in the cache. If the key is not found nothing is done.</source>
          <target state="translated">캐시에 저장된 기존 정수 값을 증가시킵니다. 키를 찾을 수 없으면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c60a79bc55fbbd08f59d91ffb860f8c89bb4d61" translate="yes" xml:space="preserve">
          <source>Increments an integer value in the cache.</source>
          <target state="translated">캐시에서 정수 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="ac8f586235cd9c9a54e04e1582486b97984ef9e5" translate="yes" xml:space="preserve">
          <source>Indeed, those features are provided by Ruby on Rails, where we just write</source>
          <target state="translated">실제로 이러한 기능은 Ruby on Rails에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="15cfadc26717bad880a9fde19a51e2f1ba2fa5ba" translate="yes" xml:space="preserve">
          <source>Indent the &lt;code&gt;Gemfile&lt;/code&gt; to the depth of @indentation</source>
          <target state="translated">&lt;code&gt;Gemfile&lt;/code&gt; 의 깊이까지 Gemfile 을 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="55a69bd5ad72c95be80535a77a034016a752d59f" translate="yes" xml:space="preserve">
          <source>Indents the lines in the receiver:</source>
          <target state="translated">수신자의 행을 들여 쓰기합니다.</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="6af6ebf2652770fb07b7edc8a706df252af3c13a" translate="yes" xml:space="preserve">
          <source>Indicates if the model is persisted. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모델이 유지되는지 여부를 나타냅니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fd1b698c13f9950dbc0a396b271f3999ea4de3b" translate="yes" xml:space="preserve">
          <source>Indicates whether table names should be the pluralized versions of the corresponding class names. If true, the default table name for a Product class will be &amp;ldquo;products&amp;rdquo;. If false, it would just be &amp;ldquo;product&amp;rdquo;. See table_name for the full rules on table/class naming. This is true, by default.</source>
          <target state="translated">테이블 이름이 해당 클래스 이름의 복수 버전이어야하는지 여부를 나타냅니다. true 인 경우 Product 클래스의 기본 테이블 이름은 &quot;products&quot;입니다. False이면 &quot;제품&quot;일뿐입니다. 테이블 / 클래스 이름 지정에 대한 전체 규칙은 table_name을 참조하십시오. 이것은 기본적으로 사실입니다.</target>
        </trans-unit>
        <trans-unit id="dc64305a14542034550a32ad76b58e39ab963e2d" translate="yes" xml:space="preserve">
          <source>Indicates whether the table associated with this class exists</source>
          <target state="translated">이 클래스와 연관된 테이블이 존재하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b833fb286a71c34f5e91a0725ed89419e3cd6797" translate="yes" xml:space="preserve">
          <source>Indifferent Access</source>
          <target state="translated">무관심한 접근</target>
        </trans-unit>
        <trans-unit id="e377a7420d75303382002218677f891fbd8e5368" translate="yes" xml:space="preserve">
          <source>Individual Components</source>
          <target state="translated">개별 구성품</target>
        </trans-unit>
        <trans-unit id="af78b717bb9e05184fbb67ea0224879b5cf257ac" translate="yes" xml:space="preserve">
          <source>Inflection Rules For Other Locales</source>
          <target state="translated">다른 지역의 변곡 규칙</target>
        </trans-unit>
        <trans-unit id="7919b931473684f976aff4e0e966d02ccdc1b05a" translate="yes" xml:space="preserve">
          <source>Inflections</source>
          <target state="translated">Inflections</target>
        </trans-unit>
        <trans-unit id="5ade1199eca264ac0dfc557731d76a0f599ba79e" translate="yes" xml:space="preserve">
          <source>Info::inspect</source>
          <target state="translated">Info::inspect</target>
        </trans-unit>
        <trans-unit id="5e57975599660667fcec0e77696ab5bd3ccb669a" translate="yes" xml:space="preserve">
          <source>Info::property</source>
          <target state="translated">Info::property</target>
        </trans-unit>
        <trans-unit id="e8c940c56b021e4e98e5c24a447c9f7fb6f97ec7" translate="yes" xml:space="preserve">
          <source>Info::to_html</source>
          <target state="translated">Info::to_html</target>
        </trans-unit>
        <trans-unit id="6d3ae8926026fa77c4627cf590895d6f17c9ff4e" translate="yes" xml:space="preserve">
          <source>Info::to_s</source>
          <target state="translated">Info::to_s</target>
        </trans-unit>
        <trans-unit id="238da28b1ea22430b20905f64adaf447cc97c56b" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Mailgun. Requires the following parameters:</source>
          <target state="translated">Mailgun에서 인바운드 이메일을 수집합니다. 다음 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c243d42c40b1b079fac4e495d20a5f383add383e" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Mandrill.</source>
          <target state="translated">Mandrill에서 인바운드 이메일을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="2e89987697155a3aab4cf8005968c5692402a010" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Postmark. Requires a &lt;code&gt;RawEmail&lt;/code&gt; parameter containing a full RFC 822 message.</source>
          <target state="translated">Postmark에서 인바운드 이메일을 수집합니다. 전체 RFC 822 메시지를 포함 하는 &lt;code&gt;RawEmail&lt;/code&gt; 매개 변수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="04e8776b1781cf6ec53bef1b8cc34a7ff1a0e9d4" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from SendGrid. Requires an &lt;code&gt;email&lt;/code&gt; parameter containing a full RFC 822 message.</source>
          <target state="translated">SendGrid에서 인바운드 이메일을 수집합니다. 전체 RFC 822 메시지가 포함 된 &lt;code&gt;email&lt;/code&gt; 매개 변수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="844c9e9ffaf6b19ebb0cb6befdac150c47968826" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails relayed from an SMTP server.</source>
          <target state="translated">SMTP 서버에서 릴레이 된 인바운드 이메일을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="7da25d8a59155f55aeac4ed34d5ae1b9e20f37f3" translate="yes" xml:space="preserve">
          <source>Ingresses::Mailgun::InboundEmailsController</source>
          <target state="translated">Ingresses::Mailgun::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="b6d7efeec877849944e373cc37ee9788cbc2bde9" translate="yes" xml:space="preserve">
          <source>Ingresses::Mailgun::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Mailgun::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="d471c518a4e0625f34b076410d3be699c0bfa111" translate="yes" xml:space="preserve">
          <source>Ingresses::Mandrill::InboundEmailsController</source>
          <target state="translated">Ingresses::Mandrill::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="6497cdc2b1c087141d75471048d8be9f2619e409" translate="yes" xml:space="preserve">
          <source>Ingresses::Mandrill::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Mandrill::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="32482320e6f8c5325ea6fc34ae05791cb30bc211" translate="yes" xml:space="preserve">
          <source>Ingresses::Postmark::InboundEmailsController</source>
          <target state="translated">Ingresses::Postmark::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="def7ccd5bae34830a8dcd032d9c179d5f085af18" translate="yes" xml:space="preserve">
          <source>Ingresses::Postmark::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Postmark::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="7055870ae3e931a2224267afbbb92ab8f653c953" translate="yes" xml:space="preserve">
          <source>Ingresses::Relay::InboundEmailsController</source>
          <target state="translated">Ingresses::Relay::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="d68de4f5b7ef94464fcb633024f3afa8e9d82b81" translate="yes" xml:space="preserve">
          <source>Ingresses::Relay::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Relay::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="3315bf43c874cae6ee36c7d291e89ba04abb6915" translate="yes" xml:space="preserve">
          <source>Ingresses::Sendgrid::InboundEmailsController</source>
          <target state="translated">Ingresses::Sendgrid::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="79fc86436700d42b832b3c4ea9ae5af07d6ac826" translate="yes" xml:space="preserve">
          <source>Ingresses::Sendgrid::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Sendgrid::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="9addf5a08ee6560a6444bfa5da226f9dda5097e8" translate="yes" xml:space="preserve">
          <source>Inheritable callback queues</source>
          <target state="translated">상속 가능한 콜백 큐</target>
        </trans-unit>
        <trans-unit id="878ffd80536d567c1ec4814aab5eb7633c481c93" translate="yes" xml:space="preserve">
          <source>InheritableOptions</source>
          <target state="translated">InheritableOptions</target>
        </trans-unit>
        <trans-unit id="3d6a119a959e8cbe5490945458d11f87f26d87c5" translate="yes" xml:space="preserve">
          <source>InheritableOptions#inheritable_copy</source>
          <target state="translated">InheritableOptions#inheritable_copy</target>
        </trans-unit>
        <trans-unit id="108a36b1b8200fb5a72710521a7d03c26b191aca" translate="yes" xml:space="preserve">
          <source>InheritableOptions::new</source>
          <target state="translated">InheritableOptions::new</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="6990f737f07155678850da157ebfcf4ec6a6199e" translate="yes" xml:space="preserve">
          <source>Inheritance Examples</source>
          <target state="translated">상속 예제</target>
        </trans-unit>
        <trans-unit id="bde126929181e729972ad7d9ddf772e47cda5bd8" translate="yes" xml:space="preserve">
          <source>Inheritance#initialize_dup</source>
          <target state="translated">Inheritance#initialize_dup</target>
        </trans-unit>
        <trans-unit id="a326a867145d9f00f1712c47c8eb34e3439ab41c" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods</source>
          <target state="translated">Inheritance::ClassMethods</target>
        </trans-unit>
        <trans-unit id="a01613b2b9238ef321f4b05a78a4568055d71e6e" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#abstract_class</source>
          <target state="translated">Inheritance::ClassMethods#abstract_class</target>
        </trans-unit>
        <trans-unit id="4934c3b146a1d79f2577e3e67ff820d302381e18" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#abstract_class?</source>
          <target state="translated">Inheritance::ClassMethods#abstract_class?</target>
        </trans-unit>
        <trans-unit id="00e7918294e24f28c311b4076f415b7d8b83740e" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#base_class</source>
          <target state="translated">Inheritance::ClassMethods#base_class</target>
        </trans-unit>
        <trans-unit id="04a62c79aa4cb9e487fae1d12175cd1d777f6770" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#base_class?</source>
          <target state="translated">Inheritance::ClassMethods#base_class?</target>
        </trans-unit>
        <trans-unit id="0fb13c325e9fe3b08f15be74bd775aff377f5c5b" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#compute_type</source>
          <target state="translated">Inheritance::ClassMethods#compute_type</target>
        </trans-unit>
        <trans-unit id="15186ad27ca45e760e125a07d16fa8e79261d707" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#descends_from_active_record?</source>
          <target state="translated">Inheritance::ClassMethods#descends_from_active_record?</target>
        </trans-unit>
        <trans-unit id="0635fb33f336fafb4ba4e40502aff8a83777dcc6" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#inherited</source>
          <target state="translated">Inheritance::ClassMethods#inherited</target>
        </trans-unit>
        <trans-unit id="977d92bc899515934b4b966eb7654018c87db3bf" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#new</source>
          <target state="translated">Inheritance::ClassMethods#new</target>
        </trans-unit>
        <trans-unit id="372df04a248e04ff8449a2c54ffff50187ce7f28" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#polymorphic_name</source>
          <target state="translated">Inheritance::ClassMethods#polymorphic_name</target>
        </trans-unit>
        <trans-unit id="2a2dfa372be9c94c50976c8495df7eae0586c8a4" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#sti_name</source>
          <target state="translated">Inheritance::ClassMethods#sti_name</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="6514323c8fb77a04ce286a1549e2bf030a862781" translate="yes" xml:space="preserve">
          <source>Initialization events</source>
          <target state="translated">초기화 이벤트</target>
        </trans-unit>
        <trans-unit id="12ddca1d545d5a1128488691ed488f4cd1e459af" translate="yes" xml:space="preserve">
          <source>Initialize a new &lt;a href=&quot;messageencryptor&quot;&gt;MessageEncryptor&lt;/a&gt;. &lt;code&gt;secret&lt;/code&gt; must be at least as long as the cipher key size. For the default 'aes-256-gcm' cipher, this is 256 bits. If you are using a user-entered secret, you can generate a suitable key by using &lt;code&gt;ActiveSupport::KeyGenerator&lt;/code&gt; or a similar key derivation function.</source>
          <target state="translated">새로운 &lt;a href=&quot;messageencryptor&quot;&gt;MessageEncryptor를&lt;/a&gt; 초기화합니다 . &lt;code&gt;secret&lt;/code&gt; 은 암호 키 크기 이상이어야합니다. 기본 'aes-256-gcm'암호의 경우 256 비트입니다. 사용자가 입력 한 비밀을 사용하는 경우 &lt;code&gt;ActiveSupport::KeyGenerator&lt;/code&gt; 또는 유사한 키 파생 함수 를 사용하여 적합한 키를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96d7e26d527682af0767568cd6eff6730b2648d3" translate="yes" xml:space="preserve">
          <source>Initialize an empty model object from &lt;code&gt;coder&lt;/code&gt;. &lt;code&gt;coder&lt;/code&gt; should be the result of previously encoding an Active Record model, using &lt;a href=&quot;core#method-i-encode_with&quot;&gt;encode_with&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;coder&lt;/code&gt; 에서 빈 모델 객체를 초기화합니다 . &lt;code&gt;coder&lt;/code&gt; 는 &lt;a href=&quot;core#method-i-encode_with&quot;&gt;encode_with를&lt;/a&gt; 사용하여 이전에 활성 레코드 모델을 인코딩 한 결과 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="3cc643394e015280b5fb20c2d82a6a247d93fb7d" translate="yes" xml:space="preserve">
          <source>Initializers defined using the &lt;code&gt;initializer&lt;/code&gt; method will be run in the order they are defined in, with the exception of ones that use the &lt;code&gt;:before&lt;/code&gt; or &lt;code&gt;:after&lt;/code&gt; methods.</source>
          <target state="translated">이니셜 &lt;code&gt;initializer&lt;/code&gt; 메소드를 사용하여 정의 된 이니셜 라이저 는 &lt;code&gt;:before&lt;/code&gt; 또는 &lt;code&gt;:after&lt;/code&gt; 메소드 를 사용하는 것을 제외하고는 정의 된 순서대로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a86d77af0c3722c3e4da4c178fb648acf43fc367" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;attribute&lt;/code&gt; to zero if &lt;code&gt;nil&lt;/code&gt; and adds the value passed as &lt;code&gt;by&lt;/code&gt; (default is 1). The increment is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">이 초기화는 &lt;code&gt;attribute&lt;/code&gt; 으면 0 &lt;code&gt;nil&lt;/code&gt; 과 같이 전달 된 값에 추가 &lt;code&gt;by&lt;/code&gt; (디폴트는 1이다). 증분은 기본 속성에서 직접 수행되며 setter는 호출되지 않습니다. 숫자 기반 속성에만 적합합니다. &lt;code&gt;self&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fcd42385993fdf0221b329817d9382977b72308d" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;attribute&lt;/code&gt; to zero if &lt;code&gt;nil&lt;/code&gt; and subtracts the value passed as &lt;code&gt;by&lt;/code&gt; (default is 1). The decrement is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">이 초기화는 &lt;code&gt;attribute&lt;/code&gt; 으면 0 &lt;code&gt;nil&lt;/code&gt; 및 뺀 값으로 전달 &lt;code&gt;by&lt;/code&gt; (디폴트는 1이다). 감소는 기본 속성에서 직접 수행되며 setter는 호출되지 않습니다. 숫자 기반 속성에만 적합합니다. &lt;code&gt;self&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9d1efbf2932073f2aaa30fb69d34ca59d561f6dc" translate="yes" xml:space="preserve">
          <source>Initializes a new model with the given &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;params&lt;/code&gt; 로 새 모델을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="25919e950f14f28342516aa26edc8ef27fb8cfe7" translate="yes" xml:space="preserve">
          <source>Initializes and connects a PostgreSQL adapter.</source>
          <target state="translated">PostgreSQL 어댑터를 초기화하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5f44168de8e6de1f11fd906b709a9ac6d9152d00" translate="yes" xml:space="preserve">
          <source>Initializes new record from relation while maintaining the current scope.</source>
          <target state="translated">현재 범위를 유지하면서 관계에서 새 레코드를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="56915b94b06061a272ee042aac64cce078107917" translate="yes" xml:space="preserve">
          <source>Initiate a manual reload</source>
          <target state="translated">수동 재 장전 시작</target>
        </trans-unit>
        <trans-unit id="2d851649cb0b809ff3f794243faf8b50aac49273" translate="yes" xml:space="preserve">
          <source>Injection</source>
          <target state="translated">Injection</target>
        </trans-unit>
        <trans-unit id="829ffb5e8ba86505d0ede43d4f74c3b605d82ec6" translate="yes" xml:space="preserve">
          <source>Injection is very tricky, because the same code or parameter can be malicious in one context, but totally harmless in another. A context can be a scripting, query, or programming language, the shell, or a Ruby/Rails method. The following sections will cover all important contexts where injection attacks may happen. The first section, however, covers an architectural decision in connection with Injection.</source>
          <target state="translated">동일한 코드 나 매개 변수가 한 상황에서는 악의적 일 수 있지만 다른 상황에서는 전혀 무해하기 때문에 주입은 매우 까다 롭습니다. 컨텍스트는 스크립팅, 쿼리 또는 프로그래밍 언어, 쉘 또는 Ruby / Rails 메소드 일 수 있습니다. 다음 섹션에서는 주입 공격이 발생할 수있는 모든 중요한 컨텍스트를 다룹니다. 그러나 첫 번째 섹션에서는 인젝션과 관련된 아키텍처 결정에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6485cd5f8e0fb60a6b40665efa4be6e80ab8c693" translate="yes" xml:space="preserve">
          <source>Injects a block of code into a defined position in your file.</source>
          <target state="translated">코드 블록을 파일의 정의 된 위치에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="d2860d2edae8411abdfa46d50321f29af97f5353" translate="yes" xml:space="preserve">
          <source>Inline Attachments</source>
          <target state="translated">인라인 첨부</target>
        </trans-unit>
        <trans-unit id="b46ea27191430cc66d892811d5c5909433511f69" translate="yes" xml:space="preserve">
          <source>Inline callback blocks using &lt;code&gt;return&lt;/code&gt; can be refactored to evaluate to the returned value:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 을 사용하는 인라인 콜백 블록 은 리팩토링되어 반환 된 값으로 평가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a8dda03d8fa26cf788bd2ddffa18aa80d59c11" translate="yes" xml:space="preserve">
          <source>InlinePreviewInterceptor</source>
          <target state="translated">InlinePreviewInterceptor</target>
        </trans-unit>
        <trans-unit id="a845996754ffc7a0716a05091edc051fd302fc2e" translate="yes" xml:space="preserve">
          <source>Inserting data into HTML templates needs extra care. For example, you can't just interpolate &lt;code&gt;@review.title&lt;/code&gt; verbatim into an HTML page. For one thing, if the review title is &quot;Flanagan &amp;amp; Matz rules!&quot; the output won't be well-formed because an ampersand has to be escaped as &quot;&amp;amp;amp;&quot;. What's more, depending on the application, that may be a big security hole because users can inject malicious HTML setting a hand-crafted review title. Check out the section about cross-site scripting in the &lt;a href=&quot;security#cross-site-scripting-xss&quot;&gt;Security guide&lt;/a&gt; for further information about the risks.</source>
          <target state="translated">HTML 템플릿에 데이터를 삽입하려면 특별한주의가 필요합니다. 예를 들어 &lt;code&gt;@review.title&lt;/code&gt; 그대로 HTML 페이지에 삽입 할 수는 없습니다 . 우선, 리뷰 제목이 &quot;Flanagan &amp;amp; Matz rules!&quot;라면 앰퍼샌드를 &quot;&amp;amp; amp&quot;로 이스케이프해야하기 때문에 출력이 제대로 구성되지 않습니다. 또한 응용 프로그램에 따라 사용자가 수작업으로 작성한 리뷰 제목을 악의적 인 HTML 설정에 삽입 할 수 있기 때문에 보안 상 큰 허점이 될 수 있습니다. 위험에 대한 자세한 내용은 &lt;a href=&quot;security#cross-site-scripting-xss&quot;&gt;보안 가이드&lt;/a&gt; 에서 크로스 사이트 스크립팅 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="01be4a345faed307605daf983eeed9bc1912f61d" translate="yes" xml:space="preserve">
          <source>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.</source>
          <target state="translated">단일 SQL INSERT 문에서 데이터베이스에 단일 레코드를 삽입합니다. 모델을 인스턴스화하지 않으며 Active Record 콜백 또는 유효성 검사를 트리거하지 않습니다. 전달 된 값은 Active Record의 유형 캐스팅 및 직렬화를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="f2098ea62054241a3c2030b9e7b979d66024097c" translate="yes" xml:space="preserve">
          <source>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.</source>
          <target state="translated">단일 SQL INSERT 문으로 데이터베이스에 여러 레코드를 삽입합니다. 모델을 인스턴스화하지 않으며 Active Record 콜백 또는 유효성 검사를 트리거하지 않습니다. 전달 된 값은 Active Record의 유형 캐스팅 및 직렬화를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="3e75d211e60bc43f28ee2a4034ae9797a2cd4e71" translate="yes" xml:space="preserve">
          <source>Inserts the given fixture into the table. Overridden in adapters that require something beyond a simple insert (eg. Oracle). Most of adapters should implement `insert_fixtures_set` that leverages bulk SQL insert. We keep this method to provide fallback for databases like sqlite that do not support bulk inserts.</source>
          <target state="translated">주어진 조명기를 테이블에 삽입합니다. 단순한 삽입 이외의 것을 요구하는 어댑터 (예 : Oracle)에서 재정의되었습니다. 대부분의 어댑터는 대량 SQL 삽입을 활용하는`insert_fixtures_set`을 구현해야합니다. 대량 삽입을 지원하지 않는 sqlite와 같은 데이터베이스에 폴백을 제공하기 위해이 방법을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="dcdce6d287df6df156ef34c4bebe0e7598a298eb" translate="yes" xml:space="preserve">
          <source>Inside a Rails application, you can set-up your services through the generated &lt;code&gt;config/storage.yml&lt;/code&gt; file and reference one of the aforementioned constant under the &lt;code&gt;service&lt;/code&gt; key. For example:</source>
          <target state="translated">Rails 애플리케이션 내에서 생성 된 &lt;code&gt;config/storage.yml&lt;/code&gt; 파일을 통해 서비스를 설정 하고 &lt;code&gt;service&lt;/code&gt; 키 에서 위에서 언급 한 상수 중 하나를 참조 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81fc66f02c626e819fce091962b69cd908ed799a" translate="yes" xml:space="preserve">
          <source>Inside an Engine</source>
          <target state="translated">엔진 내부</target>
        </trans-unit>
        <trans-unit id="ca089a5502c726d8026d3a6ef582d1f9c7041b18" translate="yes" xml:space="preserve">
          <source>Inside any Rails application you can then invoke the debugger by calling the &lt;code&gt;byebug&lt;/code&gt; method.</source>
          <target state="translated">Rails 애플리케이션 내에서 &lt;code&gt;byebug&lt;/code&gt; 메소드 를 호출하여 디버거를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bafd3cd51f90726af9a9d1acaf7aa7cadd199a4" translate="yes" xml:space="preserve">
          <source>Inside any controller action or view, you can invoke the console by calling the &lt;code&gt;console&lt;/code&gt; method.</source>
          <target state="translated">컨트롤러 조치 또는보기에서 &lt;code&gt;console&lt;/code&gt; 메소드를 호출하여 콘솔을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21481b8c559c4c02b87406f78ebeb054fe506b43" translate="yes" xml:space="preserve">
          <source>Inside migration files, the &lt;code&gt;t&lt;/code&gt; object in &lt;a href=&quot;schemastatements#method-i-create_table&quot;&gt;create_table&lt;/a&gt; is actually of this type:</source>
          <target state="translated">마이그레이션 파일 내 에서 &lt;a href=&quot;schemastatements#method-i-create_table&quot;&gt;create_table&lt;/a&gt; 의 &lt;code&gt;t&lt;/code&gt; 객체 는 실제로 다음 유형입니다.</target>
        </trans-unit>
        <trans-unit id="acfb2b1ac48dee8a30cfcdf3f4dfe998556d2d5a" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;-&amp;gt; { ... }&lt;/code&gt; block you can use all of the usual &lt;a href=&quot;../relation&quot;&gt;Relation&lt;/a&gt; methods.</source>
          <target state="translated">&lt;code&gt;-&amp;gt; { ... }&lt;/code&gt; 블록 내에서 모든 일반적인 &lt;a href=&quot;../relation&quot;&gt;Relation&lt;/a&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edfc5dfee3505b9f9d6bda671872ebd4a4ee350e" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;app&lt;/code&gt; directory are the standard &lt;code&gt;assets&lt;/code&gt;, &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;helpers&lt;/code&gt;, &lt;code&gt;jobs&lt;/code&gt;, &lt;code&gt;mailers&lt;/code&gt;, &lt;code&gt;models&lt;/code&gt;, and &lt;code&gt;views&lt;/code&gt; directories that you should be familiar with from an application. We'll look more into models in a future section, when we're writing the engine.</source>
          <target state="translated">내부 &lt;code&gt;app&lt;/code&gt; 디렉토리 표준 &lt;code&gt;assets&lt;/code&gt; , &lt;code&gt;controllers&lt;/code&gt; , &lt;code&gt;helpers&lt;/code&gt; , &lt;code&gt;jobs&lt;/code&gt; , &lt;code&gt;mailers&lt;/code&gt; , &lt;code&gt;models&lt;/code&gt; 과 &lt;code&gt;views&lt;/code&gt; 디렉토리는 응용 프로그램에서 잘 알고 있어야합니다 것을. 우리는 엔진을 작성할 때 다음 섹션에서 더 많은 모델을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b5bb7d78f59ef0d2405b8e986fb4763ebd602dd" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;rails console&lt;/code&gt; you have access to the &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;helper&lt;/code&gt; instances.</source>
          <target state="translated">&lt;code&gt;rails console&lt;/code&gt; 내부에서 &lt;code&gt;app&lt;/code&gt; 및 &lt;code&gt;helper&lt;/code&gt; 인스턴스에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6469372268010b680566e892d837c1be10063e1d" translate="yes" xml:space="preserve">
          <source>Inside the test directory there is the &lt;code&gt;test/integration&lt;/code&gt; directory, where integration tests for the engine should be placed. Other directories can be created in the &lt;code&gt;test&lt;/code&gt; directory as well. For example, you may wish to create a &lt;code&gt;test/models&lt;/code&gt; directory for your model tests.</source>
          <target state="translated">테스트 디렉토리에는 엔진에 대한 통합 테스트를 수행해야하는 &lt;code&gt;test/integration&lt;/code&gt; 디렉토리가 있습니다. 다른 디렉토리도 &lt;code&gt;test&lt;/code&gt; 디렉토리 에서 작성할 수 있습니다 . 예를 들어 모델 테스트를위한 &lt;code&gt;test/models&lt;/code&gt; 디렉토리 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8408bbf7dfd69738c24b99c0074fd7a247613a94" translate="yes" xml:space="preserve">
          <source>Inspecting Middleware Stack</source>
          <target state="translated">미들웨어 스택 검사</target>
        </trans-unit>
        <trans-unit id="a6ae35f450b26d859c2118e63fa573b3bd8d5308" translate="yes" xml:space="preserve">
          <source>Inspecting Variables</source>
          <target state="translated">변수 검사</target>
        </trans-unit>
        <trans-unit id="c92130bec27348f9c16772e495150fc6bd805def" translate="yes" xml:space="preserve">
          <source>Inspecting and Testing Routes</source>
          <target state="translated">경로 검사 및 테스트</target>
        </trans-unit>
        <trans-unit id="cfb0a450eea8507a41095ebe947ca2ed8994961a" translate="yes" xml:space="preserve">
          <source>Inspired by the Quiet Backtrace gem by thoughtbot.</source>
          <target state="translated">Thinkbot의 Quiet Backtrace 보석에서 영감을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="8dacdfdb2b7181d7db1e289a5292e9965b1d7fd8" translate="yes" xml:space="preserve">
          <source>Install a callback for the given event.</source>
          <target state="translated">주어진 이벤트에 대한 콜백을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="17ec383645ad0dd91277a304080964bf80f4f253" translate="yes" xml:space="preserve">
          <source>Install migrations needed for &lt;code&gt;InboundEmail&lt;/code&gt; and ensure Active Storage is set up:</source>
          <target state="translated">&lt;code&gt;InboundEmail&lt;/code&gt; 에 필요한 마이그레이션을 설치 하고 Active Storage가 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d00f491d8c40c03d4b59f712550d0e446ff54fbd" translate="yes" xml:space="preserve">
          <source>Install spring using &lt;code&gt;bundle install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bundle install&lt;/code&gt; 사용하여 스프링을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="6e0f3906b5c7f6a4b6cb048055a7f93079d5264f" translate="yes" xml:space="preserve">
          <source>Installing Rails</source>
          <target state="translated">레일 설치</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">인스턴스 변수</target>
        </trans-unit>
        <trans-unit id="e6bc144a6aa17edc35608d98fc5380cd3df13339" translate="yes" xml:space="preserve">
          <source>Instance Variables Available</source>
          <target state="translated">사용 가능한 인스턴스 변수</target>
        </trans-unit>
        <trans-unit id="f4afcaf921a6de61c708f5f2c356b8ce5c3328e9" translate="yes" xml:space="preserve">
          <source>Instance methods are created as well for convenience, they are just proxies to the class attribute. So, instances can change the class attribute, but cannot override it as it happens with &lt;code&gt;class_attribute&lt;/code&gt; (see above). For example given</source>
          <target state="translated">인스턴스 메소드는 편의를 위해 작성되며 클래스 속성의 프록시 일뿐입니다. 따라서 인스턴스는 클래스 속성을 변경할 수 있지만 &lt;code&gt;class_attribute&lt;/code&gt; 에서 와 같이이를 무시할 수는 없습니다 (위 참조). 예를 들어 주어진</target>
        </trans-unit>
        <trans-unit id="0c9fd054155855fd08e13e216d559f7895b79636" translate="yes" xml:space="preserve">
          <source>Instance variables that are accessible in views.</source>
          <target state="translated">뷰에서 액세스 할 수있는 인스턴스 변수.</target>
        </trans-unit>
        <trans-unit id="a7436cd076605f4f6b404cf011f15d6a92df9c3d" translate="yes" xml:space="preserve">
          <source>Instance-level &lt;code&gt;respond_to&lt;/code&gt; is unaffected and does not require the additional gem:</source>
          <target state="translated">인스턴스 레벨 &lt;code&gt;respond_to&lt;/code&gt; 는 영향을받지 않으며 추가 gem이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7762633929a1e0b61a50135d708b869a90a1a564" translate="yes" xml:space="preserve">
          <source>Instances may overwrite the class value in the same way:</source>
          <target state="translated">인스턴스는 같은 방식으로 클래스 값을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2c6de42dd18302648ff7dd63c129bbd2f177e6" translate="yes" xml:space="preserve">
          <source>Instantiate the equivalent Ruby object of the appropriate model for every resulting row.</source>
          <target state="translated">모든 결과 행에 대해 적절한 모델의 동등한 Ruby 오브젝트를 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="d4cfe1684b9bdb4a97ddba033a2969091cea4d78" translate="yes" xml:space="preserve">
          <source>Instantiates a new column for the table. See &lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;connection.add_column&lt;/a&gt; for available options.</source>
          <target state="translated">테이블의 새 열을 인스턴스화합니다. 사용 가능한 옵션 은 &lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;connection.add_column&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec491111cabccfee0fc99b9e3416ee8ef93d5fab" translate="yes" xml:space="preserve">
          <source>Instantiating a new &lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt;</source>
          <target state="translated">새로운 &lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt; 인스턴스화</target>
        </trans-unit>
        <trans-unit id="de2daca2c5d3ff11781567a508a71041f4b7c73f" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;, like &lt;code&gt;posts#index&lt;/code&gt;, which corresponds to the index action in the PostsController, you can specify any Rack application as the endpoint for a matcher:</source>
          <target state="translated">PostsController의 인덱스 작업에 해당하는 &lt;code&gt;posts#index&lt;/code&gt; 와 같은 &lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt; 대신에 모든 랙 애플리케이션을 매처의 엔드 포인트로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b82c51d0b22ee7205e62cd6f126b3721bdf68de6" translate="yes" xml:space="preserve">
          <source>Instead of a String like &lt;code&gt;'articles#index'&lt;/code&gt;, which corresponds to the &lt;code&gt;index&lt;/code&gt; action in the &lt;code&gt;ArticlesController&lt;/code&gt;, you can specify any &lt;a href=&quot;rails_on_rack&quot;&gt;Rack application&lt;/a&gt; as the endpoint for a matcher:</source>
          <target state="translated">&lt;code&gt;ArticlesController&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 작업에 해당하는 &lt;code&gt;'articles#index'&lt;/code&gt; 와 같은 문자열 대신 모든 &lt;a href=&quot;rails_on_rack&quot;&gt;랙 애플리케이션&lt;/a&gt; 을 매처의 엔드 포인트로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cda95c68819053b9941c2e8712b8b82003b7c61b" translate="yes" xml:space="preserve">
          <source>Instead of an options hash, you can also simply pass in a model. Rails will use the &lt;code&gt;updated_at&lt;/code&gt; and &lt;code&gt;cache_key_with_version&lt;/code&gt; methods for setting &lt;code&gt;last_modified&lt;/code&gt; and &lt;code&gt;etag&lt;/code&gt;:</source>
          <target state="translated">옵션 해시 대신 단순히 모델을 전달할 수도 있습니다. Rails는 &lt;code&gt;last_modified&lt;/code&gt; 및 &lt;code&gt;etag&lt;/code&gt; 설정을 위해 &lt;code&gt;updated_at&lt;/code&gt; 및 &lt;code&gt;cache_key_with_version&lt;/code&gt; 메소드를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="b08b659f08cd25084c638c422a66099cf07388cf" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;a href=&quot;tabledefinition#method-i-column&quot;&gt;column&lt;/a&gt; directly, you can also work with the short-hand definitions for the default types. They use the type as the method name instead of as a parameter and allow for multiple columns to be defined in a single statement.</source>
          <target state="translated">&lt;a href=&quot;tabledefinition#method-i-column&quot;&gt;열을&lt;/a&gt; 직접 호출하는 대신 기본 유형에 대한 속기 정의를 사용할 수도 있습니다. 유형을 매개 변수 대신 메소드 이름으로 사용하고 단일 명령문에서 여러 열을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6fac76b830aa8fdf650571fd8e47e809b5f97b6" translate="yes" xml:space="preserve">
          <source>Instead of explicitly naming the location of a partial, you can also let &lt;a href=&quot;partialrenderer&quot;&gt;PartialRenderer&lt;/a&gt; do the work and pick the proper path by checking &lt;code&gt;to_partial_path&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;partialrenderer&quot;&gt;PartialRenderer&lt;/a&gt; 가 부분의 위치를 ​​명시 적으로 명명하는 대신 &lt;code&gt;to_partial_path&lt;/code&gt; 메소드 를 확인하여 PartialRenderer 가 작업을 수행하고 올바른 경로를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="282a280a0cab90c59c897d96018296189d742c1c" translate="yes" xml:space="preserve">
          <source>Instead of passing a string to the conditions option, you can pass an array to sanitize tainted strings like this:</source>
          <target state="translated">조건 옵션에 문자열을 전달하는 대신 배열을 전달하여 다음과 같이 오염 된 문자열을 살균 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec02bda762202680a9ca746c8177602658813c28" translate="yes" xml:space="preserve">
          <source>Instead of passing the content as an argument, you can also use a block in which case, you pass your &lt;code&gt;html_options&lt;/code&gt; as the first parameter.</source>
          <target state="translated">컨텐츠를 인수로 전달하는 대신 블록을 사용할 수도 있습니다.이 경우 &lt;code&gt;html_options&lt;/code&gt; 를 첫 번째 매개 변수로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd65bb52286b846fe1b028432f87a2da5ac601a" translate="yes" xml:space="preserve">
          <source>Instead of polluting the thread locals namespace:</source>
          <target state="translated">스레드 로컬 네임 스페이스를 오염시키는 대신 :</target>
        </trans-unit>
        <trans-unit id="38b0e5a9769fb9574f82e5157ef0cddca8289de5" translate="yes" xml:space="preserve">
          <source>Instead of returning a path such as &lt;code&gt;/assets/smile.png&lt;/code&gt; (digests are left out for readability). The URL generated will have the full path to your CDN.</source>
          <target state="translated">&lt;code&gt;/assets/smile.png&lt;/code&gt; 와 같은 경로를 반환하는 대신 (가독성을 위해 다이제스트는 제외됨 ) 생성 된 URL에는 CDN의 전체 경로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b24539f81dce8069573b818cfa967fe057251e4" translate="yes" xml:space="preserve">
          <source>Instead of setting the variant on the render call you may also set it on the request object in your controller action.</source>
          <target state="translated">렌더 호출에서 변형을 설정하는 대신 컨트롤러 작업의 요청 객체에서 변형을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d9c8fa98536e91c26d449b779521f157c1a6de" translate="yes" xml:space="preserve">
          <source>Instead of stealing a cookie unknown to the attacker, they fix a user's session identifier (in the cookie) known to them. Read more about this so-called session fixation later.</source>
          <target state="translated">공격자에게 알려지지 않은 쿠키를 훔치는 대신 쿠키로 알려진 사용자의 세션 식별자를 쿠키에 고정시킵니다. 이 소위 세션 고정에 대해 자세히 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="a9ae3405744e20c189c424dbe4a3d20461b01ff6" translate="yes" xml:space="preserve">
          <source>Instead of using Rails to generate HTML that communicates with the server through forms and links, many developers are treating their web application as just an API client delivered as HTML with JavaScript that consumes a JSON API.</source>
          <target state="translated">Rails를 사용하여 폼과 링크를 통해 서버와 통신하는 HTML을 생성하는 대신 많은 개발자들이 웹 애플리케이션을 JSON API를 사용하는 JavaScript를 통해 HTML로 제공되는 API 클라이언트로 취급하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="507770191eeb7ec98eb1ba54a5ba1a74a894e508" translate="yes" xml:space="preserve">
          <source>Instrumentation: Rails has an instrumentation API that triggers registered handlers for a variety of events, such as action processing, sending a file or data, redirection, and database queries. The payload of each event comes with relevant information (for the action processing event, the payload includes the controller, action, parameters, request format, request method, and the request's full path).</source>
          <target state="translated">계측 : Rails에는 작업 처리, 파일 또는 데이터 전송, 리디렉션 및 데이터베이스 쿼리와 같은 다양한 이벤트에 대해 등록 된 핸들러를 트리거하는 계측 API가 있습니다. 각 이벤트의 페이로드에는 관련 정보가 있습니다 (작업 처리 이벤트의 경우 페이로드에는 컨트롤러, 작업, 매개 변수, 요청 형식, 요청 방법 및 요청의 전체 경로가 포함됨).</target>
        </trans-unit>
        <trans-unit id="ce36819d4451c02e4b229841cfbf52796a818ec4" translate="yes" xml:space="preserve">
          <source>Instrumenters</source>
          <target state="translated">Instrumenters</target>
        </trans-unit>
        <trans-unit id="b300e5ce045a08b89313fafa5e73ed0492a458f3" translate="yes" xml:space="preserve">
          <source>Instrumenters are stored in a thread local.</source>
          <target state="translated">인스트루먼트는 스레드 로컬에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="3caba6d00ba203d77ce889c6e7b15dc02732832e" translate="yes" xml:space="preserve">
          <source>Integer#year</source>
          <target state="translated">Integer#year</target>
        </trans-unit>
        <trans-unit id="6c44dbddc3fd22ad67d4d705b958417bd4bc9d93" translate="yes" xml:space="preserve">
          <source>Integers in the example above are supposed to come from the respective calls to &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">위 예제의 정수는 각각의 &lt;code&gt;id&lt;/code&gt; 호출에서 온 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c87f52def7d613c90253e811aa67f30c00e37459" translate="yes" xml:space="preserve">
          <source>Integrating with Libraries or Frameworks</source>
          <target state="translated">라이브러리 또는 프레임 워크와 통합</target>
        </trans-unit>
        <trans-unit id="899e5920ef1372292f1f4f69d3125e5a5f5a1dfb" translate="yes" xml:space="preserve">
          <source>Integration</source>
          <target state="translated">Integration</target>
        </trans-unit>
        <trans-unit id="ed8e7536d5000854a478dee90bcbee2c9954ce4e" translate="yes" xml:space="preserve">
          <source>Integration Testing</source>
          <target state="translated">통합 테스팅</target>
        </trans-unit>
        <trans-unit id="67982c4f135ee413508775af875318e3445716ec" translate="yes" xml:space="preserve">
          <source>Integration test methods such as &lt;a href=&quot;integration/requesthelpers#method-i-get&quot;&gt;ActionDispatch::Integration::RequestHelpers#get&lt;/a&gt; and &lt;a href=&quot;integration/requesthelpers#method-i-post&quot;&gt;ActionDispatch::Integration::RequestHelpers#post&lt;/a&gt; return objects of class &lt;a href=&quot;testresponse&quot;&gt;TestResponse&lt;/a&gt;, which represent the HTTP response results of the requested controller actions.</source>
          <target state="translated">&lt;a href=&quot;integration/requesthelpers#method-i-get&quot;&gt;ActionDispatch :: Integration :: RequestHelpers # get&lt;/a&gt; 및 &lt;a href=&quot;integration/requesthelpers#method-i-post&quot;&gt;ActionDispatch :: Integration :: RequestHelpers # post&lt;/a&gt; 와 같은 통합 테스트 메소드 는 요청 된 컨트롤러 조치의 HTTP 응답 결과를 나타내는 &lt;a href=&quot;testresponse&quot;&gt;TestResponse&lt;/a&gt; 클래스의 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2e1cd626fe8c4b66dfdf6e0d004c6db44ed7558b" translate="yes" xml:space="preserve">
          <source>Integration tests are used to test how various parts of your application interact. They are generally used to test important workflows within our application.</source>
          <target state="translated">통합 테스트는 응용 프로그램의 다양한 부분이 어떻게 상호 작용하는지 테스트하는 데 사용됩니다. 일반적으로 응용 프로그램 내에서 중요한 워크 플로를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2819304f744a3d244c44613d57e819fac608045" translate="yes" xml:space="preserve">
          <source>Integration#cache_key</source>
          <target state="translated">Integration#cache_key</target>
        </trans-unit>
        <trans-unit id="6c53dea3f7d20bb55236f30495fad68cb70689bb" translate="yes" xml:space="preserve">
          <source>Integration#cache_key_with_version</source>
          <target state="translated">Integration#cache_key_with_version</target>
        </trans-unit>
        <trans-unit id="f02c91c56da5fefe68235806aa6ec3d1994ea656" translate="yes" xml:space="preserve">
          <source>Integration#cache_version</source>
          <target state="translated">Integration#cache_version</target>
        </trans-unit>
        <trans-unit id="21095e92f582034508d7653b41289d55753aeab1" translate="yes" xml:space="preserve">
          <source>Integration#to_param</source>
          <target state="translated">Integration#to_param</target>
        </trans-unit>
        <trans-unit id="ce1fd21e1204581f63416449f6c7edfb967c6d78" translate="yes" xml:space="preserve">
          <source>Integration::ClassMethods</source>
          <target state="translated">Integration::ClassMethods</target>
        </trans-unit>
        <trans-unit id="139e252d29f786121f30f0460e336269c02a8bac" translate="yes" xml:space="preserve">
          <source>Integration::ClassMethods#to_param</source>
          <target state="translated">Integration::ClassMethods#to_param</target>
        </trans-unit>
        <trans-unit id="98b57e9fddf70f7d3e9da54385232a98cebca479" translate="yes" xml:space="preserve">
          <source>IntegrationTest</source>
          <target state="translated">IntegrationTest</target>
        </trans-unit>
        <trans-unit id="ab94e6a337bd2b08d6d1d29161b02030b26df85e" translate="yes" xml:space="preserve">
          <source>Intercepting Emails</source>
          <target state="translated">이메일 차단</target>
        </trans-unit>
        <trans-unit id="173c52fe8d7e7d33649dde7c6d75cc38405db524" translate="yes" xml:space="preserve">
          <source>Intercepting and Observing Emails</source>
          <target state="translated">이메일 가로 채기 및 관찰</target>
        </trans-unit>
        <trans-unit id="342e3231db1c88366814ccab28f7d0434684057a" translate="yes" xml:space="preserve">
          <source>Interceptors allow you to make modifications to emails before they are handed off to the delivery agents. An interceptor class must implement the &lt;code&gt;:delivering_email(message)&lt;/code&gt; method which will be called before the email is sent.</source>
          <target state="translated">인터셉터를 사용하면 이메일을 배달 에이전트에게 전달하기 전에 이메일을 수정할 수 있습니다. 인터셉터 클래스는 이메일이 전송되기 전에 호출 될 &lt;code&gt;:delivering_email(message)&lt;/code&gt; 메소드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dfcc4c89dfb267aa18e62e74d6d54f6561f0fc2" translate="yes" xml:space="preserve">
          <source>Interestingly, the exact same view code in the previous example can be used to edit a person. If &lt;code&gt;@person&lt;/code&gt; is an existing record with name &amp;ldquo;John Smith&amp;rdquo; and ID 256, the code above as is would yield instead:</source>
          <target state="translated">흥미롭게도, 앞의 예에서와 동일한 뷰 코드를 사용하여 사람을 편집 할 수 있습니다. &lt;code&gt;@person&lt;/code&gt; 이 이름이&amp;ldquo;John Smith&amp;rdquo;이고 ID 256 인 기존 레코드 인 경우 위 코드는 대신 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="dcc5733b7561d603a93c21562214e0c1d33fb1c8" translate="yes" xml:space="preserve">
          <source>Internal Middleware Stack</source>
          <target state="translated">내부 미들웨어 스택</target>
        </trans-unit>
        <trans-unit id="505d9d0c421453bd1f4ff40309dee285d37725cf" translate="yes" xml:space="preserve">
          <source>Internally symbols are mapped to strings when used as keys in the entire writing interface (calling &lt;code&gt;[]=&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, etc). This mapping belongs to the public interface. For example, given:</source>
          <target state="translated">전체 쓰기 인터페이스에서 키로 사용되는 경우 내부적으로 기호가 문자열에 매핑됩니다 ( &lt;code&gt;[]=&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; 등 호출 ). 이 매핑은 공용 인터페이스에 속합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="ec41529ec988c31d48e2791253f7675f0f07663a" translate="yes" xml:space="preserve">
          <source>Internationalization and Localization</source>
          <target state="translated">국제화 및 현지화</target>
        </trans-unit>
        <trans-unit id="c09a9a12334a713ae333766d80dbc7726ba5ddbd" translate="yes" xml:space="preserve">
          <source>Internationalization is a complex problem. Natural languages differ in so many ways (e.g. in pluralization rules) that it is hard to provide tools for solving all problems at once. For that reason the Rails I18n API focuses on:</source>
          <target state="translated">국제화는 복잡한 문제입니다. 자연어는 여러 방식 (예 : 복수화 규칙)이 다르므로 모든 문제를 한 번에 해결하기위한 도구를 제공하기가 어렵습니다. 이러한 이유로 Rails I18n API는 다음에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="5ec77c95171316f9af44f1afebf62f3ac2ca5ee5" translate="yes" xml:space="preserve">
          <source>Interoperability and configuration</source>
          <target state="translated">상호 운용성 및 구성</target>
        </trans-unit>
        <trans-unit id="80feef0d1957adca54e3f9d24dc512572009e68c" translate="yes" xml:space="preserve">
          <source>Interpolation escapes as needed though. For example, given:</source>
          <target state="translated">필요에 따라 보간이 이스케이프됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b70d894eda2fa1027b4f2cc23a1615a878a3cb5f" translate="yes" xml:space="preserve">
          <source>Interpretation of the output of EXPLAIN is beyond the scope of this guide. The following pointers may be helpful:</source>
          <target state="translated">EXPLAIN의 출력에 대한 해석은이 안내서의 범위를 벗어납니다. 다음 포인터가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1331fd357cb4c48e65a61cb90dbec7b0da4d430b" translate="yes" xml:space="preserve">
          <source>Interpreting EXPLAIN</source>
          <target state="translated">EXPLAIN 해석</target>
        </trans-unit>
        <trans-unit id="438faf6320554999d6e3436c3267791fd96090b3" translate="yes" xml:space="preserve">
          <source>Interprets a file using &lt;code&gt;mechanism&lt;/code&gt; and marks its defined constants as autoloaded. &lt;code&gt;file_name&lt;/code&gt; can be either a string or respond to &lt;code&gt;to_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mechanism&lt;/code&gt; 사용하여 파일을 해석 하고 정의 된 상수를 자동로드 된 것으로 표시합니다. &lt;code&gt;file_name&lt;/code&gt; 은 문자열이거나 &lt;code&gt;to_path&lt;/code&gt; 에 응답 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bab1ab6e63418fb60a28315088fc32113592c35b" translate="yes" xml:space="preserve">
          <source>Intranet and Admin Security</source>
          <target state="translated">인트라넷 및 관리자 보안</target>
        </trans-unit>
        <trans-unit id="0a6767b03885ddc439ef17983c2f692c5a07e41e" translate="yes" xml:space="preserve">
          <source>Intranet and administration interfaces are popular attack targets, because they allow privileged access. Although this would require several extra-security measures, the opposite is the case in the real world.</source>
          <target state="translated">인트라넷 및 관리 인터페이스는 권한있는 액세스를 허용하므로 널리 사용되는 공격 대상입니다. 여기에는 몇 가지 추가 보안 조치가 필요하지만 실제로는 그 반대입니다.</target>
        </trans-unit>
        <trans-unit id="1e02c113caf7083037190e94f7f4d29321ba00e9" translate="yes" xml:space="preserve">
          <source>Introducing &lt;a href=&quot;concerning#method-i-concerning&quot;&gt;#concerning&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;concerning#method-i-concerning&quot;&gt;#concerning&lt;/a&gt; 소개</target>
        </trans-unit>
        <trans-unit id="f8ab457bd47803331ebc080bd833f3ee0b9e2d8f" translate="yes" xml:space="preserve">
          <source>Introducing Rack</source>
          <target state="translated">랙 소개</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b10b45ec08f0b166df0731e9de830720dfa05269" translate="yes" xml:space="preserve">
          <source>Introduction to Rack</source>
          <target state="translated">랙 소개</target>
        </trans-unit>
        <trans-unit id="2dc38a9b87ba3ab2b84c75bf7b0f1b314cde1a6d" translate="yes" xml:space="preserve">
          <source>Introduction to Testing</source>
          <target state="translated">테스트 소개</target>
        </trans-unit>
        <trans-unit id="87d217e986a7a6fcb0d9d6294bb7ea099ed34b8e" translate="yes" xml:space="preserve">
          <source>Introduction to instrumentation</source>
          <target state="translated">계측 소개</target>
        </trans-unit>
        <trans-unit id="f6d7303488dffe7e3ac8ead1d3fcbd32a701138b" translate="yes" xml:space="preserve">
          <source>Invocation of the tasks will look like:</source>
          <target state="translated">작업 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58dd409d6a03b715d8a4a7142eeb16c3ce59eda9" translate="yes" xml:space="preserve">
          <source>Invoke a generator based on the value supplied by the user to the given option named &amp;ldquo;name&amp;rdquo;. A class option is created when this method is invoked and you can set a hash to customize it.</source>
          <target state="translated">주어진 이름 &quot;name&quot;에 사용자가 제공 한 값에 따라 생성기를 호출하십시오. 이 메소드가 호출되면 클래스 옵션이 작성되며 해시를 설정하여 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3a05f5c432f715f0fac2ee75b57be97620fa7a" translate="yes" xml:space="preserve">
          <source>Invoke a method on the connection asynchronously through the pool of thread workers.</source>
          <target state="translated">스레드 워커 풀을 통해 비동기 적으로 연결에서 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="0256c5a56ef3a0bc7ccc3f9ed6d01aea84ad06a9" translate="yes" xml:space="preserve">
          <source>Invokes Journey::Router::Utils.normalize_path and ensure that (:locale) becomes (/:locale) instead of /(:locale). Except for root cases, where the latter is the correct one.</source>
          <target state="translated">Journey :: Router :: Utils.normalize_path를 호출하고 (: locale)이 / (: locale) 대신 (/ : locale)이되도록하십시오. 루트 케이스를 제외하고 후자가 올바른 경우입니다.</target>
        </trans-unit>
        <trans-unit id="385202a85d41f1ba93fb6a0880e136ee611817eb" translate="yes" xml:space="preserve">
          <source>Invokes the public method whose name goes as first argument just like &lt;code&gt;public_send&lt;/code&gt; does, except that if the receiver does not respond to it the call returns &lt;code&gt;nil&lt;/code&gt; rather than raising an exception.</source>
          <target state="translated">수신자가 응답하지 않으면 호출 이 예외를 발생시키지 않고 &lt;code&gt;nil&lt;/code&gt; 을 리턴한다는 점을 제외하고는 &lt;code&gt;public_send&lt;/code&gt; 처럼 이름이 첫 번째 인수로 사용되는 public 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="59e5020714711541b39a9551f5b84853e831134e" translate="yes" xml:space="preserve">
          <source>Irreversible transformations</source>
          <target state="translated">돌이킬 수없는 변환</target>
        </trans-unit>
        <trans-unit id="2f766b312d7e667b7f0d8b9c17bb303b08b1acae" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;new_name&lt;/code&gt; an alias?</source>
          <target state="translated">가 &lt;code&gt;new_name&lt;/code&gt; 별명?</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46fb94424bf8f10921609b59625d794e12d26b07" translate="yes" xml:space="preserve">
          <source>Is it a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; or &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; association?</source>
          <target state="translated">그것은이다 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 또는 &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; 관계?</target>
        </trans-unit>
        <trans-unit id="7aee814e5e7b7c81d49f7ba52ab62790c23d34e6" translate="yes" xml:space="preserve">
          <source>Is it a GET or HEAD request? GETs should be safe and idempotent</source>
          <target state="translated">GET 또는 HEAD 요청입니까? GET은 안전하고 dem 등이어야합니다</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="0e468c5ec10bbeae8ac268222bf3b1cefef440a5" translate="yes" xml:space="preserve">
          <source>Is this connection alive and ready for queries?</source>
          <target state="translated">이 연결이 활성화되어 있고 쿼리 준비가 되셨습니까?</target>
        </trans-unit>
        <trans-unit id="76655109a5cf36c486e596d85b9959d33081cbb3" translate="yes" xml:space="preserve">
          <source>Isolated &lt;a href=&quot;engine&quot;&gt;Engine&lt;/a&gt;</source>
          <target state="translated">고립 된 &lt;a href=&quot;engine&quot;&gt;엔진&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f451fdf2858ac5e97eb02d93dd74df99d36099e" translate="yes" xml:space="preserve">
          <source>Isolated engine's helpers</source>
          <target state="translated">고립 된 엔진의 도우미</target>
        </trans-unit>
        <trans-unit id="7ac5f519b4cd0a9c673a2b984a399a3a92c58140" translate="yes" xml:space="preserve">
          <source>It accepts a hash where the key is the symbol of the MIME type and the value is a proc.</source>
          <target state="translated">키가 MIME 유형의 기호이고 값이 proc 인 해시를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4a6fae6667f1ec35b8e1214e1089d2257fc09809" translate="yes" xml:space="preserve">
          <source>It accepts a headers hash. This hash allows you to specify the most used headers in an email message, these are:</source>
          <target state="translated">헤더 해시를 허용합니다. 이 해시를 사용하면 전자 메일 메시지에서 가장 많이 사용되는 헤더를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f0f4cf85fc4819613826afbcfe7f04f25a0738" translate="yes" xml:space="preserve">
          <source>It accepts two parameters on initialization. The first is a version of library and the second is a library name.</source>
          <target state="translated">초기화시 두 개의 매개 변수를 승인합니다. 첫 번째는 라이브러리의 버전이고 두 번째는 라이브러리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9435a5a3fea1387cba916e7fc9c284d2e6dfd894" translate="yes" xml:space="preserve">
          <source>It accepts two parameters on initialization. The first is an array of files and the second is an optional hash of directories. The hash must have directories as keys and the value is an array of extensions to be watched under that directory.</source>
          <target state="translated">초기화시 두 개의 매개 변수를 승인합니다. 첫 번째는 파일 배열이고 두 번째는 선택적 디렉토리 해시입니다. 해시는 디렉토리를 키로 가져야하며 값은 해당 디렉토리에서 감시 할 확장 배열입니다.</target>
        </trans-unit>
        <trans-unit id="38ca25bcf2c0905e02178cd352066c0836a6a9a0" translate="yes" xml:space="preserve">
          <source>It allows you to call method &lt;a href=&quot;renderer#method-i-render&quot;&gt;render&lt;/a&gt; directly.</source>
          <target state="translated">메소드 &lt;a href=&quot;renderer#method-i-render&quot;&gt;렌더를&lt;/a&gt; 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49d2a57a5a1ca8b7ea86511d458060ee225f77d" translate="yes" xml:space="preserve">
          <source>It also allows you to update the avatar through the member:</source>
          <target state="translated">또한 멤버를 통해 아바타를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc0f9ba57056697e4de8afcfef4be20a0ad3303" translate="yes" xml:space="preserve">
          <source>It also generated some lines in our &lt;code&gt;database.yml&lt;/code&gt; configuration corresponding to our choice of PostgreSQL for database.</source>
          <target state="translated">또한 &lt;code&gt;database.yml&lt;/code&gt; 대한 PostgreSQL의 선택에 해당하는 database.yml 구성 에서 일부 행을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="39146458b45b3abeec98952f595c4cf5f503332e" translate="yes" xml:space="preserve">
          <source>It also gives you the ability to initialize an object with a hash of attributes, much like any Active Record object.</source>
          <target state="translated">또한 Active Record 객체와 마찬가지로 속성 해시로 객체를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0ee1da8322e4399bcac48a328b9839193f1124" translate="yes" xml:space="preserve">
          <source>It also searches for a key specific to the given object:</source>
          <target state="translated">또한 주어진 객체에 특정한 키를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="cfedffa8e710bb3bffa6f731ec1bf9d845f19fbc" translate="yes" xml:space="preserve">
          <source>It also strips href/src attributes with unsafe protocols like &lt;code&gt;javascript:&lt;/code&gt;, while also protecting against attempts to use Unicode, ASCII, and hex character references to work around these protocol filters. All special characters will be escaped.</source>
          <target state="translated">또한 &lt;code&gt;javascript:&lt;/code&gt; 와 같은 안전하지 않은 프로토콜로 href / src 속성을 제거 하고 이러한 프로토콜 필터를 해결하기 위해 유니 코드, ASCII 및 16 진 문자 참조를 사용하려는 시도를 방지합니다. 모든 특수 문자가 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="426c108419ecab367f3cf08cecf90bf1479d10f5" translate="yes" xml:space="preserve">
          <source>It can also be used to return exceptional conditions:</source>
          <target state="translated">예외적 인 조건을 반환하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9316df6dbeb2297de41526f9b627ebdbe698b986" translate="yes" xml:space="preserve">
          <source>It can also be used with an explicit receiver:</source>
          <target state="translated">명시 적 리시버와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dba1fa6506ff89cb1689631b83474c09424753e" translate="yes" xml:space="preserve">
          <source>It can also be useful to save information to log files at runtime. Rails maintains a separate log file for each runtime environment.</source>
          <target state="translated">런타임시 정보를 로그 파일에 저장하는 것도 유용 할 수 있습니다. Rails는 각 런타임 환경에 대해 별도의 로그 파일을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="2831d4f1ce96a57796267468ca626023eda9252e" translate="yes" xml:space="preserve">
          <source>It can also calculate the sum without the use of a block.</source>
          <target state="translated">블록을 사용하지 않고 합계를 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7687f2339942576b33eabc229b67923feb868d9f" translate="yes" xml:space="preserve">
          <source>It can also receive an &lt;code&gt;:accept&lt;/code&gt; option, which determines the allowed values that will be considered as accepted. It defaults to &lt;code&gt;['1', true]&lt;/code&gt; and can be easily changed.</source>
          <target state="translated">허용되는 것으로 간주되는 허용되는 값을 결정 하는 &lt;code&gt;:accept&lt;/code&gt; 옵션 도받을 수 있습니다 . 기본값은 &lt;code&gt;['1', true]&lt;/code&gt; 이며 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a234c9c580ec73225fe07a2b2cb15c5278679324" translate="yes" xml:space="preserve">
          <source>It can also validate whether the value of the specified attributes are unique based on a &lt;code&gt;:scope&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;:scope&lt;/code&gt; 매개 변수를 기반으로 지정된 속성 값이 고유한지 여부를 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40a7b1d9d8a7cd76b12428401930bc5065694c8d" translate="yes" xml:space="preserve">
          <source>It can be used along with &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 와 함께 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1ac0a20ef283df4adc7e264352fcf154710271f2" translate="yes" xml:space="preserve">
          <source>It can be useful to access the class that is using that validator when there are prerequisites such as an &lt;code&gt;attr_accessor&lt;/code&gt; being present. This class is accessible via &lt;code&gt;options[:class]&lt;/code&gt; in the constructor. To setup your validator override the constructor.</source>
          <target state="translated">&lt;code&gt;attr_accessor&lt;/code&gt; 와 같은 전제 조건이있는 경우 해당 유효성 검증기를 사용하는 클래스에 액세스하는 것이 유용 할 수 있습니다 . 이 클래스는 생성자의 &lt;code&gt;options[:class]&lt;/code&gt; 를 통해 액세스 할 수 있습니다 . 유효성 검사기를 설정하려면 생성자를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="49b4aa175d14125482748aa613908101aa82e8b5" translate="yes" xml:space="preserve">
          <source>It creates and returns an instance of the &lt;a href=&quot;activesupport/multibyte/chars&quot;&gt;ActiveSupport::Multibyte::Chars&lt;/a&gt; class which encapsulates the original string. A Unicode safe version of all the &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; methods are defined on this proxy class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.</source>
          <target state="translated">원래 문자열을 캡슐화하는 &lt;a href=&quot;activesupport/multibyte/chars&quot;&gt;ActiveSupport :: Multibyte :: Chars&lt;/a&gt; 클래스 의 인스턴스를 만들고 반환 합니다. 모든 &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; 메소드 의 유니 코드 안전 버전 이이 프록시 클래스에 정의되어 있습니다. 프록시 클래스가 특정 메소드에 응답하지 않으면 캡슐화 된 문자열로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="499cc07feea969499a3dc48ed2492713c8c86211" translate="yes" xml:space="preserve">
          <source>It does not call &lt;code&gt;to_a&lt;/code&gt; on the argument, if the argument does not respond to &lt;code&gt;to_ary&lt;/code&gt; it returns an array with the argument as its single element.</source>
          <target state="translated">인수에서 &lt;code&gt;to_a&lt;/code&gt; 를 호출하지 않습니다 . 인수가 &lt;code&gt;to_ary&lt;/code&gt; 에 응답하지 않으면 인수가 단일 요소 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="56b4d8dc1bf62dfda767cc7b994335d9456a43bf" translate="yes" xml:space="preserve">
          <source>It intends to prevent odd bugs and confusion in code that call mutator methods directly on the &lt;code&gt;Relation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Relation&lt;/code&gt; 직접 뮤 테이터 메소드를 호출하는 코드에서 이상한 버그와 혼동을 막으려 고합니다 .</target>
        </trans-unit>
        <trans-unit id="5d5c5b84f1606def2d58f9fb00f6b5f36fadaeab" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;highly&lt;/strong&gt; recommended that the &lt;code&gt;isolate_namespace&lt;/code&gt; line be left within the &lt;code&gt;Engine&lt;/code&gt; class definition. Without it, classes generated in an engine &lt;strong&gt;may&lt;/strong&gt; conflict with an application.</source>
          <target state="translated">되어 &lt;strong&gt;매우&lt;/strong&gt; 하는 것이 좋습니다 &lt;code&gt;isolate_namespace&lt;/code&gt; 의 라인이 내에 남아있을 &lt;code&gt;Engine&lt;/code&gt; 클래스 정의. &lt;strong&gt;그렇지&lt;/strong&gt; 않으면 엔진에서 생성 된 클래스 가 응용 프로그램과 충돌 &lt;strong&gt;할 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="10cfb379bf3244a1c48de6cb1cda23ec4480ebb5" translate="yes" xml:space="preserve">
          <source>It is accessed in much the same way as the session, as a hash (it's a &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Flash/FlashHash.html&quot;&gt;FlashHash&lt;/a&gt; instance).</source>
          <target state="translated">세션과 거의 같은 방식으로 해시 ( &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Flash/FlashHash.html&quot;&gt;FlashHash&lt;/a&gt; 인스턴스)로 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="83efac2576f2e3cca18100e7aee4b5a47479b098" translate="yes" xml:space="preserve">
          <source>It is also important to use different salt values for encrypted and signed cookies. Using the same value for different salt configuration values may lead to the same derived key being used for different security features which in turn may weaken the strength of the key.</source>
          <target state="translated">암호화 및 서명 된 쿠키에 다른 솔트 값을 사용하는 것도 중요합니다. 다른 솔트 구성 값에 동일한 값을 사용하면 다른 보안 기능에 동일한 파생 키가 사용되어 키의 강도가 약해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd5336404614ecb4acce82c4ff85169b0e93d510" translate="yes" xml:space="preserve">
          <source>It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names &lt;code&gt;alert&lt;/code&gt; and &lt;code&gt;notice&lt;/code&gt; as well as a general purpose &lt;code&gt;flash&lt;/code&gt; bucket.</source>
          <target state="translated">리디렉션의 일부로 플래시 메시지를 할당 할 수도 있습니다. 일반적으로 사용되는 플래시 이름에 대한 두 가지 특별한 접근이 있습니다 &lt;code&gt;alert&lt;/code&gt; 및 &lt;code&gt;notice&lt;/code&gt; 뿐만 아니라 범용 &lt;code&gt;flash&lt;/code&gt; 버킷.</target>
        </trans-unit>
        <trans-unit id="179fe87c22bf5b6c89ee355df0482f9dc84a0da7" translate="yes" xml:space="preserve">
          <source>It is also possible to automatically disable an input while the form is submitting by using the &lt;code&gt;data-disable-with&lt;/code&gt; attribute. This is to prevent accidental double-clicks from the user, which could result in duplicate HTTP requests that the backend may not detect as such. The value of the attribute is the text that will become the new value of the button in its disabled state.</source>
          <target state="translated">&lt;code&gt;data-disable-with&lt;/code&gt; 속성 을 사용하여 양식을 제출하는 동안 입력을 자동으로 비활성화 할 수도 있습니다 . 이는 사용자가 실수로 두 번 클릭하는 것을 방지하기 위해 백엔드가 감지하지 못하는 HTTP 요청이 중복 될 수 있습니다. 속성 값은 비활성화 된 상태에서 버튼의 새로운 값이 될 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="348a45df3c04b6d5fe9c86d061104b62e5b62d75" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the way the elements will be shown by giving a block to the method:</source>
          <target state="translated">메소드에 블록을 제공하여 요소가 표시되는 방식을 사용자 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e55d2ed2495603dfd9e5fa2fc9d52ef7987d08b" translate="yes" xml:space="preserve">
          <source>It is also possible to define the Ajax &lt;code&gt;dataType&lt;/code&gt; explicitly while performing requests for &lt;code&gt;data-remote&lt;/code&gt; elements, by way of the &lt;code&gt;data-type&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;data-type&lt;/code&gt; 속성 을 통해 data- &lt;code&gt;data-remote&lt;/code&gt; 요소에 대한 요청을 수행하는 동안 Ajax &lt;code&gt;dataType&lt;/code&gt; 을 명시 적으로 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="819fc44ec9ef18718e13d598795b20fdc7e69280" translate="yes" xml:space="preserve">
          <source>It is also possible to limit the uniqueness constraint to a set of records matching certain conditions. In this example archived articles are not being taken into consideration when validating uniqueness of the title attribute:</source>
          <target state="translated">고유성 제약 조건을 특정 조건과 일치하는 레코드 세트로 제한 할 수도 있습니다. 이 예제에서 제목 속성의 고유성을 검증 할 때 아카이브 된 기사를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a985124ab3a30ac2f740ba2e729b65433dd15f7c" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a custom serializer that responds to &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;dump&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;dump&lt;/code&gt; 응답하는 사용자 정의 직렬 변환기를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7a775c2c33dca7d2800bfafa6f196f92f27191d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass an object which responds to &lt;code&gt;call&lt;/code&gt; method as the second parameter to the &lt;code&gt;subscribe&lt;/code&gt; method instead of a block:</source>
          <target state="translated">블록 대신 두 번째 매개 변수로 &lt;code&gt;call&lt;/code&gt; 메소드에 응답하는 오브젝트를 &lt;code&gt;subscribe&lt;/code&gt; 메소드 에 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18abb3beeb3bf6cdf55d0d1bc4bfefab51a336a9" translate="yes" xml:space="preserve">
          <source>It is also possible to set a default host that will be used in all mailers by setting the &lt;code&gt;:host&lt;/code&gt; option as a configuration option in &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 에서 &lt;code&gt;:host&lt;/code&gt; 옵션을 구성 옵션으로 설정하여 모든 메일러에서 사용될 기본 호스트를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab7cb2d57cb049b703f4721d525abf15854caa6a" translate="yes" xml:space="preserve">
          <source>It is also possible to set these default options that will be used in all mailers through the &lt;code&gt;default_options=&lt;/code&gt; configuration in &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 의 &lt;code&gt;default_options=&lt;/code&gt; 구성을 통해 모든 메일러에서 사용될 기본 옵션을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b781e4a3aafdb190e8c24f4f3c6f103c1f5c3b3" translate="yes" xml:space="preserve">
          <source>It is also possible to supply a custom prefix.</source>
          <target state="translated">사용자 정의 접두사를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="217db1c91aa9f1200c2f9bc48daada017d477db5" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this guide to document Ruby constants, but we are nevertheless going to highlight a few key topics. Truly grasping the following sections is instrumental to understanding constant autoloading and reloading.</source>
          <target state="translated">루비 상수를 문서화하는 것은이 안내서의 범위를 벗어나지 만 그럼에도 불구하고 우리는 몇 가지 주요 주제를 강조 할 것입니다. 다음 섹션을 정확히 파악하면 지속적인 자동 로딩 및 다시 로딩을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3258883b4eb20fb13831be19bf566b5526debab3" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this guide to inform you on how to secure your application code and environments. However, please secure your database configuration, e.g. &lt;code&gt;config/database.yml&lt;/code&gt;, master key for &lt;code&gt;credentials.yml&lt;/code&gt;, and other unencrypted secrets. You may want to further restrict access, using environment-specific versions of these files and any others that may contain sensitive information.</source>
          <target state="translated">응용 프로그램 코드 및 환경을 보호하는 방법에 대한 정보는이 안내서의 범위를 벗어납니다. 그러나 데이터베이스 구성 (예 : &lt;code&gt;config/database.yml&lt;/code&gt; , &lt;code&gt;credentials.yml&lt;/code&gt; 의 마스터 키 및 기타 암호화되지 않은 비밀)을 보호하십시오. 이러한 파일의 환경 별 버전 및 중요한 정보가 포함 된 다른 파일을 사용하여 액세스를 추가로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe4130ab4ee095a6deeb9892cd4088476f03a76" translate="yes" xml:space="preserve">
          <source>It is common to use persistent cookies to store user information, with &lt;code&gt;cookies.permanent&lt;/code&gt; for example. In this case, the cookies will not be cleared and the out of the box CSRF protection will not be effective. If you are using a different cookie store than the session for this information, you must handle what to do with it yourself:</source>
          <target state="translated">예를 들어 &lt;code&gt;cookies.permanent&lt;/code&gt; 와 같이 영구 쿠키를 사용하여 사용자 정보를 저장하는 것이 일반적 입니다. 이 경우 쿠키가 지워지지 않으며 즉시 사용 가능한 CSRF 보호 기능이 적용되지 않습니다. 이 정보에 대해 세션과 다른 쿠키 저장소를 사용하는 경우 직접 쿠키로 수행 할 작업을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9341cff4e30114860c81d61ae45c3c73d6ae1c7" translate="yes" xml:space="preserve">
          <source>It is considered good practice to declare callback methods as private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.</source>
          <target state="translated">콜백 메소드를 개인으로 선언하는 것이 좋습니다. 공개 된 경우 모델 외부에서 호출하여 객체 캡슐화 원칙을 위반할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a011e67c6ead698c933aa355ff5673de5432b5" translate="yes" xml:space="preserve">
          <source>It is equivalent to writing:</source>
          <target state="translated">다음과 같이 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01ba04d8b437042468e0c2c09742be51208f176a" translate="yes" xml:space="preserve">
          <source>It is generally safe to exclude XHR requests from CSRF protection (like the code snippet above does), because XHR requests can only be made from the same origin. Note however that any cross-origin third party domain allowed via &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt; will also be able to create XHR requests. Be sure to check your CORS configuration before disabling forgery protection for XHR.</source>
          <target state="translated">XHR 요청은 동일한 출처에서만 이루어질 수 있기 때문에 CSRF 보호에서 XHR 요청을 제외하는 것이 일반적으로 안전합니다 (위의 코드 조각과 동일). 그러나 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt; 를 통해 허용되는 출처 간 타사 도메인 도 XHR 요청을 생성 할 수 있습니다. XHR에 대한 위조 방지 기능을 비활성화하기 전에 CORS 구성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a207a505579df11ef014f66a20f5d9cf4698ae30" translate="yes" xml:space="preserve">
          <source>It is important that this folder is shared between deployments so that remotely cached pages referencing the old compiled assets still work for the life of the cached page.</source>
          <target state="translated">이전에 컴파일 된 자산을 참조하는 원격 캐시 된 페이지가 여전히 캐시 된 페이지의 수명 동안 작동하도록 배치간에이 폴더를 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="dda9f7c4cb278191f2fd04c7db508eb24b9287cd" translate="yes" xml:space="preserve">
          <source>It is important to note that files you want to reference outside a manifest must be added to the precompile array or they will not be available in the production environment.</source>
          <target state="translated">매니페스트 외부에서 참조하려는 파일은 사전 컴파일 배열에 추가해야합니다. 그렇지 않으면 프로덕션 환경에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="525c4700d9b0c161a634194efc57c56e14f975ce" translate="yes" xml:space="preserve">
          <source>It is important to notice that the actual crafted image or link doesn't necessarily have to be situated in the web application's domain, it can be anywhere - in a forum, blog post, or email.</source>
          <target state="translated">실제 제작 된 이미지 나 링크가 반드시 웹 응용 프로그램의 도메인에있을 필요는 없으며 포럼, 블로그 게시물 또는 전자 메일의 어느 곳에 나있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a753c2dcf80c811ac30d16c0dda03089e7018f95" translate="yes" xml:space="preserve">
          <source>It is important to understand that &lt;code&gt;html_safe&lt;/code&gt; performs no escaping whatsoever, it is just an assertion:</source>
          <target state="translated">&lt;code&gt;html_safe&lt;/code&gt; 가 이스케이프를 수행하지 않는다는 것을 이해하는 것이 중요합니다. 단 어설 션일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="d55e0a0d2aac8db229502f8ef70a2140d1f09635" translate="yes" xml:space="preserve">
          <source>It is important to understand that the nesting is composed of class and module &lt;em&gt;objects&lt;/em&gt;, it has nothing to do with the constants used to access them, and is also unrelated to their names.</source>
          <target state="translated">중첩은 클래스 및 모듈 &lt;em&gt;객체&lt;/em&gt; 로 구성 되며 액세스하는 데 사용되는 상수와 관련이 없으며 이름과 관련이 없다는 것을 이해하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="41efcacaf212ba9a4488f51d99b234f2f8337edd" translate="yes" xml:space="preserve">
          <source>It is interesting to observe that blocks do not modify the stack. In particular the blocks that may be passed to &lt;code&gt;Class.new&lt;/code&gt; and &lt;code&gt;Module.new&lt;/code&gt; do not get the class or module being defined pushed to their nesting. That's one of the differences between defining classes and modules in one way or another.</source>
          <target state="translated">블록이 스택을 수정하지 않는 것을 관찰하는 것이 흥미 롭습니다. 특히 &lt;code&gt;Class.new&lt;/code&gt; 및 &lt;code&gt;Module.new&lt;/code&gt; 에 전달 될 수있는 블록 은 정의중인 클래스 또는 모듈을 중첩으로 푸시하지 않습니다. 그것은 클래스와 모듈을 어떤 식 으로든 정의하는 것의 차이점 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="941e591857cdf0d45804c6c106a3821ade8d5bf6" translate="yes" xml:space="preserve">
          <source>It is necessary to &lt;code&gt;raw&lt;/code&gt; the result of &lt;code&gt;json_escape&lt;/code&gt;, so that quotation marks don't get converted to &lt;code&gt;&amp;amp;quot;&lt;/code&gt; entities. &lt;code&gt;json_escape&lt;/code&gt; doesn't automatically flag the result as HTML safe, since the raw value is unsafe to use inside HTML attributes.</source>
          <target state="translated">따옴표가 &lt;code&gt;&amp;amp;quot;&lt;/code&gt; 로 변환되지 않도록 &lt;code&gt;json_escape&lt;/code&gt; 의 결과 를 &lt;code&gt;raw&lt;/code&gt; 로 변환해야합니다 . 엔티티. 원시 값이 HTML 속성 내에서 사용하기에 안전하지 않기 때문에 &lt;code&gt;json_escape&lt;/code&gt; 는 결과를 HTML 안전으로 자동 플래그 지정 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59035bb25168789f781c7f9fcd3e7e21efa80ace" translate="yes" xml:space="preserve">
          <source>It is not necessary to pass all the attributes to &lt;code&gt;update&lt;/code&gt;. For example, if &lt;code&gt;@article.update(title: 'A new title')&lt;/code&gt; was called, Rails would only update the &lt;code&gt;title&lt;/code&gt; attribute, leaving all other attributes untouched.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 할 모든 속성을 전달할 필요는 없습니다 . 예를 들어, &lt;code&gt;@article.update(title: 'A new title')&lt;/code&gt; 을 호출하면 Rails는 &lt;code&gt;title&lt;/code&gt; 속성 만 업데이트하고 다른 모든 속성은 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="93598eff3d787ca530523d68e5e3b68468b4d0d0" translate="yes" xml:space="preserve">
          <source>It is not recommended that you stream static files through Rails if you can instead keep them in a public folder on your web server. It is much more efficient to let the user download the file directly using Apache or another web server, keeping the request from unnecessarily going through the whole Rails stack.</source>
          <target state="translated">정적 파일을 웹 서버의 공용 폴더에 보관할 수 있으면 Rails를 통해 정적 파일을 스트리밍하지 않는 것이 좋습니다. 사용자가 Apache 또는 다른 웹 서버를 사용하여 직접 파일을 직접 다운로드하여 요청이 불필요하게 전체 Rails 스택을 거치지 않도록하는 것이 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="e88432ee04e64b5f3195b709467ab625a7694aa3" translate="yes" xml:space="preserve">
          <source>It is often useful to ignore sets of fields that the user has not filled in. You can control this by passing a &lt;code&gt;:reject_if&lt;/code&gt; proc to &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;. This proc will be called with each hash of attributes submitted by the form. If the proc returns &lt;code&gt;false&lt;/code&gt; then Active Record will not build an associated object for that hash. The example below only tries to build an address if the &lt;code&gt;kind&lt;/code&gt; attribute is set.</source>
          <target state="translated">사용자가 입력하지 않은 필드 세트를 무시하는 것이 유용한 경우가 많습니다. &lt;code&gt;:reject_if&lt;/code&gt; proc를 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 에 전달하여이를 제어 할 수 있습니다 . 이 proc은 폼이 제출 한 속성의 각 해시와 함께 호출됩니다. proc가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 Active Record는 해당 해시에 대한 관련 개체를 작성하지 않습니다. 아래 예제는 &lt;code&gt;kind&lt;/code&gt; 속성이 설정된 경우에만 주소를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="359dd26ed4325027fc03a54808e8ea6356971976" translate="yes" xml:space="preserve">
          <source>It is only soft-deprecated, which means that your code will not break at the moment and no deprecation warning will be displayed, but this constant will be removed in the future.</source>
          <target state="translated">더 이상 사용되지 않으므로 코드가 현재 중단되지 않으며 사용 중단 경고가 표시되지 않지만 앞으로는이 상수가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4562ca89794a86c1f1a7abdb14c2b0bf7874f843" translate="yes" xml:space="preserve">
          <source>It is possible to associate &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; with a &lt;code&gt;Proc&lt;/code&gt; object which will be called. Using a &lt;code&gt;Proc&lt;/code&gt; object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.</source>
          <target state="translated">호출 될 &lt;code&gt;Proc&lt;/code&gt; 객체 와 함께 &lt;code&gt;:if&lt;/code&gt; 및 &lt;code&gt;:unless&lt;/code&gt; 를 연결할 수 있습니다. 사용 &lt;code&gt;Proc&lt;/code&gt; 객체 당신에게 별도의 방법 대신 인라인 상태를 기록 할 수있는 기능을 제공합니다. 이 옵션은 단일 라이너에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="cf776ffebf1af8bc2d942f750e9a51092414860e" translate="yes" xml:space="preserve">
          <source>It is possible to associate &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; with a &lt;code&gt;Proc&lt;/code&gt; object. This option is best suited when writing short validation methods, usually one-liners:</source>
          <target state="translated">&lt;code&gt;:if&lt;/code&gt; 및 &lt;code&gt;:unless&lt;/code&gt; &lt;code&gt;Proc&lt;/code&gt; 오브젝트 와 연관시킬 수 없습니다 . 이 옵션은 짧은 유효성 검사 방법 (일반적으로 한 줄짜리)을 작성할 때 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="94c0520a8d6f229af5d1702cf7d9bb86be3a506e" translate="yes" xml:space="preserve">
          <source>It is possible to customize the behavior of elements with a &lt;code&gt;data-remote&lt;/code&gt; attribute without writing a line of JavaScript. You can specify extra &lt;code&gt;data-&lt;/code&gt; attributes to accomplish this.</source>
          <target state="translated">JavaScript 라인을 작성하지 않고도 &lt;code&gt;data-remote&lt;/code&gt; 속성을 사용하여 요소의 동작을 사용자 정의 할 수 있습니다 . 이를 위해 추가 &lt;code&gt;data-&lt;/code&gt; 속성을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fdb819e34d79e2af13d3f5739becece3367eef9" translate="yes" xml:space="preserve">
          <source>It is possible to return to old behavior and disable &lt;code&gt;deep_munge&lt;/code&gt; configuring your application if you are aware of the risk and know how to handle it:</source>
          <target state="translated">위험을 알고 처리 방법을 알고있는 경우 이전 동작으로 돌아가서 애플리케이션을 구성하는 &lt;code&gt;deep_munge&lt;/code&gt; 를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c699de2f3bdf654ecdd4536b61685dc7cafc0885" translate="yes" xml:space="preserve">
          <source>It is possible to send email to one or more recipients in one email (e.g., informing all admins of a new signup) by setting the list of emails to the &lt;code&gt;:to&lt;/code&gt; key. The list of emails can be an array of email addresses or a single string with the addresses separated by commas.</source>
          <target state="translated">이메일 목록을 &lt;code&gt;:to&lt;/code&gt; 키로 설정하여 하나의 이메일로 하나 이상의 수신자에게 이메일을 보낼 수 있습니다 (예 : 모든 관리자에게 새 가입을 알리기) . 이메일 목록은 이메일 주소 배열이거나 주소가 쉼표로 구분 된 단일 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2fba07d1449421861070682cf3bc42607770a5" translate="yes" xml:space="preserve">
          <source>It is possible to share partials and associated caching between files with different mime types. For example shared partial caching allows template writers to share a partial between HTML and JavaScript files. When templates are collected in the template resolver file paths they only include the template language extension and not the mime type. Because of this templates can be used for multiple mime types. Both HTML and JavaScript requests will respond to the following code:</source>
          <target state="translated">다른 MIME 유형을 가진 파일간에 부분 및 관련 캐싱을 공유 할 수 있습니다. 예를 들어 공유 부분 캐싱을 사용하면 템플릿 작성자가 HTML과 JavaScript 파일간에 부분을 공유 할 수 있습니다. 템플리트 해석기 파일 경로에서 템플리트를 수집하면 MIME 유형이 아닌 템플리트 언어 확장자 만 포함됩니다. 이 템플릿으로 인해 여러 MIME 유형에 사용할 수 있습니다. HTML 및 JavaScript 요청 모두 다음 코드에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="b8fd1eae44ed2d596522e191f73299d597768b59" translate="yes" xml:space="preserve">
          <source>It is possible to swap the shipped Simple backend with a more powerful one, which would store translation data in a relational database, GetText dictionary, or similar. See section &lt;a href=&quot;#using-different-backends&quot;&gt;Using different backends&lt;/a&gt; below.</source>
          <target state="translated">제공된 단순 백엔드를 관계형 데이터베이스, GetText 사전 또는 이와 유사한 데이터베이스에 번역 데이터를 저장하는 더 강력한 백엔드로 교체 할 수 있습니다. 아래의 &lt;a href=&quot;#using-different-backends&quot;&gt;다른 백엔드 사용&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="648e7ff34b53bee2903e398ed4116f0d74bf63d7" translate="yes" xml:space="preserve">
          <source>It is recommended not to use the same verifier for different things, so you can get different verifiers passing the &lt;code&gt;verifier_name&lt;/code&gt; argument.</source>
          <target state="translated">다른 것에 대해 동일한 검증기를 사용하지 않는 것이 좋습니다 . 따라서 &lt;code&gt;verifier_name&lt;/code&gt; 인수를 전달하는 다른 검증기를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab44ad0eac99bfa97d75c89f0ad0ef7a845ed57e" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;em&gt;use RedCloth in combination with a permitted input filter&lt;/em&gt;, as described in the countermeasures against XSS section.</source>
          <target state="translated">XSS에 대한 대책 섹션에 설명 된대로 &lt;em&gt;허용 된 입력 필터와 함께 RedCloth&lt;/em&gt; 를 &lt;em&gt;사용하는&lt;/em&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="298255e081934b106aba3a7bad6a52c856a4bc8f" translate="yes" xml:space="preserve">
          <source>It is safe to call this method if a database transaction is already open, i.e. if &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; is called within another &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; block. In case of a nested call, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; will behave as follows:</source>
          <target state="translated">데이터베이스 트랜잭션이 이미 열려있는 경우, 즉 다른 &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;트랜잭션&lt;/a&gt; 블록 내에서 &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;트랜잭션&lt;/a&gt; 이 호출 된 경우이 메소드를 호출하는 것이 안전합니다 . 중첩 된 호출의 경우 &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;트랜잭션&lt;/a&gt; 은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7a45593b8b2126e4764abc506e87f644124f7d10" translate="yes" xml:space="preserve">
          <source>It is shorter, and the intention more obvious.</source>
          <target state="translated">더 짧고 의도는 더 분명합니다.</target>
        </trans-unit>
        <trans-unit id="89bdff5bc31e9e0bf49c6a3a0b41b9c39713a357" translate="yes" xml:space="preserve">
          <source>It is similar to render, except that it does not set the &lt;code&gt;response_body&lt;/code&gt; and it should be guaranteed to always return a string.</source>
          <target state="translated">&lt;code&gt;response_body&lt;/code&gt; 를 설정하지 않고 항상 문자열을 반환해야한다는 점을 제외하면 render와 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="feba03ed2eb137a18e226422934ced8f11f7d231" translate="yes" xml:space="preserve">
          <source>It is the server's (i.e. our) responsibility to look for a last modified timestamp and the if-none-match header and determine whether or not to send back the full response. With conditional-get support in Rails this is a pretty easy task:</source>
          <target state="translated">마지막으로 수정 된 타임 스탬프와 if-none-match 헤더를 찾아 전체 응답을 다시 보낼지 여부를 결정하는 것은 서버의 책임입니다. Rails에서 조건부 지원을 통해 이것은 매우 쉬운 작업입니다.</target>
        </trans-unit>
        <trans-unit id="1f24fb666ec8101a20d8e74aef753ea515b4ed85" translate="yes" xml:space="preserve">
          <source>It is useful when rendering from an &lt;code&gt;ActionController::Metal&lt;/code&gt; controller or otherwise to add an available renderer proc to a specific controller.</source>
          <target state="translated">&lt;code&gt;ActionController::Metal&lt;/code&gt; 컨트롤러 에서 렌더링 하거나 사용 가능한 렌더러 프로세스를 특정 컨트롤러에 추가 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="8381b5798039f8bdc6ba9892429183aa3882944c" translate="yes" xml:space="preserve">
          <source>It is very common that a template will need to iterate over a collection and render a sub-template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial for each one of the elements in the array.</source>
          <target state="translated">템플릿이 컬렉션을 반복하고 각 요소에 대한 하위 템플릿을 렌더링해야하는 경우가 매우 일반적입니다. 이 패턴은 배열을 허용하고 배열의 각 요소에 대한 부분을 렌더링하는 단일 메소드로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="112ab076fea03f9d75fe593aa250d73126e6c082" translate="yes" xml:space="preserve">
          <source>It is very easy to create Active Record models. All you have to do is to subclass the &lt;code&gt;ApplicationRecord&lt;/code&gt; class and you're good to go:</source>
          <target state="translated">Active Record 모델을 작성하는 것은 매우 쉽습니다. &lt;code&gt;ApplicationRecord&lt;/code&gt; 클래스 를 서브 클래 싱 하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2567301b91ff3e1a8e3b6ab299f1ab0e52af5b" translate="yes" xml:space="preserve">
          <source>It is very important to &lt;em&gt;think about the worst case&lt;/em&gt;: What if someone really got hold of your cookies or user credentials. You could &lt;em&gt;introduce roles&lt;/em&gt; for the admin interface to limit the possibilities of the attacker. Or how about &lt;em&gt;special login credentials&lt;/em&gt; for the admin interface, other than the ones used for the public part of the application. Or a &lt;em&gt;special password for very serious actions&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;최악의 경우에 대해 생각하는&lt;/em&gt; 것이 매우 중요합니다 . 누군가 쿠키 나 사용자 자격 증명을 실제로 가지고 있다면 어떻게해야합니까? 공격자의 가능성을 제한하기 위해 관리 인터페이스에 대한 &lt;em&gt;역할&lt;/em&gt; 을 &lt;em&gt;도입&lt;/em&gt; 할 수 있습니다. 또는 응용 프로그램의 공용 부분에 사용되는 것과 다른 관리 인터페이스의 &lt;em&gt;특수 로그인 자격 증명&lt;/em&gt; 은 어떻 습니까? 아니면 &lt;em&gt;매우 심각한 행동을위한 특별한 비밀번호&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="b0493caf1193ee906843c7daabc5ed6988e9f46b" translate="yes" xml:space="preserve">
          <source>It is very important to understand that Ruby does not have a way to truly reload classes and modules in memory, and have that reflected everywhere they are already used. Technically, &quot;unloading&quot; the &lt;code&gt;User&lt;/code&gt; class means removing the &lt;code&gt;User&lt;/code&gt; constant via &lt;code&gt;Object.send(:remove_const, &quot;User&quot;)&lt;/code&gt;.</source>
          <target state="translated">Ruby에는 클래스와 모듈을 메모리에 실제로 다시로드 할 수있는 방법이 없으며, 이미 사용중인 모든 곳에 반영되어 있다는 것을 이해하는 것이 중요합니다. 기술적으로 &lt;code&gt;User&lt;/code&gt; 클래스를 &quot;언로드&quot; 한다는 것은 &lt;code&gt;Object.send(:remove_const, &quot;User&quot;)&lt;/code&gt; 를 통해 &lt;code&gt;User&lt;/code&gt; 상수를 제거하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2ae463c41c994975a8c9d1ed7d20b19f6f82fa4e" translate="yes" xml:space="preserve">
          <source>It is very trivial to implement in Rails.</source>
          <target state="translated">Rails에서 구현하는 것은 매우 사소한 일입니다.</target>
        </trans-unit>
        <trans-unit id="35ee732864066c0d0eadb6125761394ebaf22e35" translate="yes" xml:space="preserve">
          <source>It is your responsibility to ensure calling &lt;code&gt;html_safe&lt;/code&gt; on a particular string is fine.</source>
          <target state="translated">특정 문자열에서 &lt;code&gt;html_safe&lt;/code&gt; 를 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="31c0edfcaa4fc403ac3adceae75236d17c99abf7" translate="yes" xml:space="preserve">
          <source>It iterates through the collection and passes each element to a block. The element will be keyed by the value returned by the block:</source>
          <target state="translated">컬렉션을 반복하고 각 요소를 블록으로 전달합니다. 요소는 블록이 반환 한 값으로 키가됩니다.</target>
        </trans-unit>
        <trans-unit id="721fe765d7d4e10b75516d49bfbcce75be736438" translate="yes" xml:space="preserve">
          <source>It may not function correctly. This is because the application doesn't know how to route these requests to the engine unless you explicitly tell it &lt;strong&gt;how&lt;/strong&gt;. To do this, you must set the &lt;code&gt;@routes&lt;/code&gt; instance variable to the engine's route set in your setup code:</source>
          <target state="translated">제대로 작동하지 않을 수 있습니다. 이는 명시 적으로 &lt;strong&gt;how&lt;/strong&gt; 에게 알려주지 않는 한 애플리케이션이 이러한 요청을 엔진으로 라우팅하는 방법을 모르기 때문 입니다. 이렇게하려면 &lt;code&gt;@routes&lt;/code&gt; 인스턴스 변수를 설정 코드에 설정된 엔진의 경로로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ce713b879eb723ee2b86cf67e06dfef733959e9" translate="yes" xml:space="preserve">
          <source>It offers a richer bottom-line at the language level, targeted both at the development of Rails applications, and at the development of Ruby on Rails itself.</source>
          <target state="translated">Rails 애플리케이션 개발과 Ruby on Rails 자체 개발을 목표로 언어 수준에서보다 풍부한 수익을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8096c3aca7a392a3a34226c703cd085adca651c9" translate="yes" xml:space="preserve">
          <source>It preserves dashes and underscores unless they are used as separators:</source>
          <target state="translated">구분 기호로 사용되지 않는 한 대시와 밑줄을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="124daf2dae3dc1290bb02e4af593b4afcd962cb7" translate="yes" xml:space="preserve">
          <source>It provides a method to capture blocks into variables through capture and a way to capture a block of markup for use in a layout through &lt;a href=&quot;capturehelper#method-i-content_for&quot;&gt;content_for&lt;/a&gt;.</source>
          <target state="translated">이는 캡처를 통해 변수로 블록을 캡처하는 방법과 &lt;a href=&quot;capturehelper#method-i-content_for&quot;&gt;content_for를&lt;/a&gt; 통해 레이아웃에 사용할 마크 업 블록을 캡처하는 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="d559b2073af90812c6c78ec7af2c339cdd913618" translate="yes" xml:space="preserve">
          <source>It provides an interface for protecting attributes from end-user assignment. This makes Action Controller parameters forbidden to be used in Active Model mass assignment until they have been explicitly enumerated.</source>
          <target state="translated">최종 사용자 할당으로부터 속성을 보호하기위한 인터페이스를 제공합니다. 이를 통해 Action Controller 매개 변수가 명시 적으로 열거 될 때까지 Active Model 질량 지정에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d53d2b0f66ddb0510df5988207a06488b1a81009" translate="yes" xml:space="preserve">
          <source>It provides two options that controls the top-level behavior of new instances:</source>
          <target state="translated">새 인스턴스의 최상위 동작을 제어하는 ​​두 가지 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b59d7e861125ed6d581d3a0cc77e6a38802989db" translate="yes" xml:space="preserve">
          <source>It relies on exception handling to handle control flow, which may be marginally slower.</source>
          <target state="translated">제어 흐름을 처리하기 위해 예외 처리에 의존하므로 약간 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e985f63cf9499f5816c3c8d3acd3c680200932a" translate="yes" xml:space="preserve">
          <source>It returns an empty HTML tag of type &lt;code&gt;name&lt;/code&gt; which by default is XHTML compliant. Set &lt;code&gt;open&lt;/code&gt; to true to create an open tag compatible with HTML 4.0 and below. Add HTML attributes by passing an attributes hash to &lt;code&gt;options&lt;/code&gt;. Set &lt;code&gt;escape&lt;/code&gt; to false to disable attribute value escaping.</source>
          <target state="translated">기본적으로 XHTML과 호환되는 &lt;code&gt;name&lt;/code&gt; 유형의 빈 HTML 태그를 반환합니다 . HTML 4.0 이하와 호환되는 열린 태그를 만들려면 &lt;code&gt;open&lt;/code&gt; 을 true로 설정하십시오 . &lt;code&gt;options&lt;/code&gt; 속성 해시를 전달하여 HTML 속성을 추가하십시오 . 속성 값 이스케이프를 사용하지 않으려면 &lt;code&gt;escape&lt;/code&gt; 를 false로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="103c6ce50b681a6ef444b5d698f26fbec76c9171" translate="yes" xml:space="preserve">
          <source>It should have created a test file placeholder for us. With the output of the previous command we should see:</source>
          <target state="translated">우리를 위해 테스트 파일 자리 표시자를 만들었을 것입니다. 이전 명령의 출력으로 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4966f7811cb27a198a6cba34da214ff55b23cc1f" translate="yes" xml:space="preserve">
          <source>It should have created a test file placeholder for us. With the output of the previous command you should see:</source>
          <target state="translated">우리를 위해 테스트 파일 자리 표시자를 만들었을 것입니다. 이전 명령의 출력으로 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="157ac47cfa200341598ff079a15434917fd957db" translate="yes" xml:space="preserve">
          <source>It takes the names of an old (deprecated) constant and of a new constant (both in string form) and optionally a deprecator. The deprecator defaults to &lt;code&gt;ActiveSupport::Deprecator&lt;/code&gt; if none is specified.</source>
          <target state="translated">오래된 (더 이상 사용되지 않는) 상수와 새 상수 (둘 다 문자열 형식) 및 선택적으로 사용되지 않는 감 가상 각기의 이름을 사용합니다. 사용되지 &lt;code&gt;ActiveSupport::Deprecator&lt;/code&gt; 경우, 지원자는 기본값으로 ActiveSupport :: Deprecator로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="83087d1a900bea48f8391e7474e1e5c67d0ff05a" translate="yes" xml:space="preserve">
          <source>It tends to be faster and less error prone to create a new instance of your application's database by loading the schema file via &lt;code&gt;rails db:schema:load&lt;/code&gt; than it is to replay the entire migration history. &lt;a href=&quot;#old-migrations&quot;&gt;Old migrations&lt;/a&gt; may fail to apply correctly if those migrations use changing external dependencies or rely on application code which evolves separately from your migrations.</source>
          <target state="translated">전체 마이그레이션 히스토리를 재생하는 것보다 &lt;code&gt;rails db:schema:load&lt;/code&gt; 를 통해 스키마 파일을로드하여 애플리케이션 데이터베이스의 새 인스턴스를 작성하는 것이 더 빠르고 오류가 적은 경향이 있습니다 . &lt;a href=&quot;#old-migrations&quot;&gt;마이그레이션에서&lt;/a&gt; 외부 종속성 변경을 사용하거나 마이그레이션과 별도로 진화하는 응용 프로그램 코드에 의존하는 경우 이전 마이그레이션 이 올바르게 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc2a2f98b56eb3a54fae986fc622f497465a043" translate="yes" xml:space="preserve">
          <source>It will include all of the helpers from engine's directory. Take into account that this does not include helpers defined in controllers with helper_method or other similar solutions, only helpers defined in the helpers directory will be included.</source>
          <target state="translated">엔진 디렉토리의 모든 도우미가 포함됩니다. helper_method 또는 다른 유사한 솔루션으로 컨트롤러에 정의 된 헬퍼는 포함되지 않으며 helpers 디렉토리에 정의 된 헬퍼 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="98c13cf8d00ca42ad01461edeb1c7ca6801faefd" translate="yes" xml:space="preserve">
          <source>It will look a little basic for now, but that's ok. We'll look at improving the styling for it afterwards.</source>
          <target state="translated">지금은 조금 기본으로 보이지만 괜찮습니다. 나중에 스타일을 개선하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8637603c373814dd050a1532100af0da4f2090a9" translate="yes" xml:space="preserve">
          <source>It will use the given &lt;code&gt;user_content_type&lt;/code&gt;, or multipart if the mail message has any attachments. If the attachments are inline, the content type will be &amp;ldquo;multipart/related&amp;rdquo;, otherwise &amp;ldquo;multipart/mixed&amp;rdquo;.</source>
          <target state="translated">주어진 &lt;code&gt;user_content_type&lt;/code&gt; 을 사용 하거나 메일 메시지에 첨부 파일이 있으면 multipart 를 사용합니다 . 첨부 파일이 인라인 인 경우 컨텐츠 유형은 &quot;멀티 파트 / 관련&quot;이고, 그렇지 않으면 &quot;멀티 파트 / 혼합&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="42cbfd3191bc8d384376a66a5cca989147dbf649" translate="yes" xml:space="preserve">
          <source>It works for both inline:</source>
          <target state="translated">인라인 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="618aee3ec871071cafa5f2c415e6c3ad428f6c63" translate="yes" xml:space="preserve">
          <source>It works like this:</source>
          <target state="translated">다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4e9581765ec600cf23cfdcdef0a724ea6ec31300" translate="yes" xml:space="preserve">
          <source>It's a good practice to ensure that the correct message has been broadcasted inside other components (e.g. inside your controllers). This is precisely where the custom assertions provided by Action Cable are pretty useful. For instance, within a model:</source>
          <target state="translated">다른 구성 요소 (예 : 컨트롤러 내부) 내에서 올바른 메시지가 브로드 캐스트되도록하는 것이 좋습니다. 바로 Action Cable이 제공하는 커스텀 어설 션이 매우 유용합니다. 예를 들어, 모델 내에서 :</target>
        </trans-unit>
        <trans-unit id="f422ae9e8159f660700963246d16c8816e8e4e5b" translate="yes" xml:space="preserve">
          <source>It's a good practice to ensure that your jobs correctly get enqueued or performed wherever you invoke them (e.g. inside your controllers). This is precisely where the custom assertions provided by Active Job are pretty useful. For instance, within a model:</source>
          <target state="translated">작업을 호출 할 때마다 (예 : 컨트롤러 내부) 작업이 올바르게 대기열에 포함되거나 수행되도록하는 것이 좋습니다. Active Job에서 제공하는 사용자 지정 어설 ​​션이 매우 유용한 곳입니다. 예를 들어, 모델 내에서 :</target>
        </trans-unit>
        <trans-unit id="a80a15c6dc9f952abf9d054b00b9bc97a4a2ae13" translate="yes" xml:space="preserve">
          <source>It's advisable that you only store simple data (strings and numbers) in cookies. If you have to store complex objects, you would need to handle the conversion manually when reading the values on subsequent requests.</source>
          <target state="translated">쿠키에는 간단한 데이터 (문자열 및 숫자) 만 저장하는 것이 좋습니다. 복잡한 개체를 저장해야하는 경우 후속 요청에서 값을 읽을 때 변환을 수동으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5341eced867c0f8d3ab2b44d8744a44e0359bb" translate="yes" xml:space="preserve">
          <source>It's also a good idea to add indexes to each of those columns to speed up the joins process. However, in MySQL it is advised to add a compound index for both of the columns as MySQL only uses one index per table during the lookup.</source>
          <target state="translated">또한 조인 프로세스 속도를 높이기 위해 각 열에 인덱스를 추가하는 것이 좋습니다. 그러나 MySQL에서는 조회 중에 테이블 당 하나의 인덱스 만 사용하므로 MySQL에서는 두 열 모두에 복합 인덱스를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="23d63436f77065acc450057bff4d18024da3b766" translate="yes" xml:space="preserve">
          <source>It's also important to treat the value objects as immutable. Don't allow the Money object to have its amount changed after creation. Create a new Money object with the new value instead. The &lt;code&gt;Money#exchange_to&lt;/code&gt; method is an example of this. It returns a new value object instead of changing its own values. Active Record won't persist value objects that have been changed through means other than the writer method.</source>
          <target state="translated">값 객체를 불변으로 취급하는 것도 중요합니다. Money 객체가 생성 후에 금액이 변경되는 것을 허용하지 마십시오. 대신 새 값으로 새 Money 개체를 만듭니다. &lt;code&gt;Money#exchange_to&lt;/code&gt; 방법이의 예입니다. 자체 값을 변경하는 대신 새 값 개체를 반환합니다. 활성 레코드는 기록기 방법 이외의 방법을 통해 변경된 값 개체를 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce772d533b0ed334ad2b7969d9190d3bfed1e182" translate="yes" xml:space="preserve">
          <source>It's also possible to construct multi-dimensional parameter hashes by specifying keys using brackets, such as:</source>
          <target state="translated">다음과 같이 대괄호를 사용하여 키를 지정하여 다차원 매개 변수 해시를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5080c9d97459219fcb315f929272aaf0d44726" translate="yes" xml:space="preserve">
          <source>It's also possible to delegate a method to the class by using &lt;code&gt;:class&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;:class&lt;/code&gt; 를 사용하여 메소드를 클래스에 위임 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9bba4c576ef4381989429f386a4c0d76c77e88" translate="yes" xml:space="preserve">
          <source>It's also possible to instantiate related objects, so a &lt;code&gt;Client&lt;/code&gt; class belonging to the &lt;code&gt;clients&lt;/code&gt; table with a &lt;code&gt;master_id&lt;/code&gt; foreign key can instantiate master through &lt;code&gt;Client#master&lt;/code&gt;.</source>
          <target state="translated">관련 객체를 인스턴스화 할 수도 있으므로 &lt;code&gt;master_id&lt;/code&gt; 외래 키 를 사용하여 &lt;code&gt;clients&lt;/code&gt; 테이블에 속하는 &lt;code&gt;Client&lt;/code&gt; 클래스 는 &lt;code&gt;Client#master&lt;/code&gt; 를 통해 마스터를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d018ba7160b482abab2b6e00cfd3ecbbb4865e28" translate="yes" xml:space="preserve">
          <source>It's also possible to interpret encrypted YAML files with &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">암호화 된 YAML 파일을 &lt;code&gt;config&lt;/code&gt; 로 해석 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c8736847d7c7ad6de203a9a1a70d34f62f81a4d" translate="yes" xml:space="preserve">
          <source>It's also possible to override the column that should be used as the table's primary key using the &lt;code&gt;ActiveRecord::Base.primary_key=&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;ActiveRecord::Base.primary_key=&lt;/code&gt; 메소드를 사용하여 테이블의 기본 키로 사용해야하는 열을 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20c583d4833cfc55c98348bf9834c35bbaee87ec" translate="yes" xml:space="preserve">
          <source>It's also possible to retry or discard a job if an exception is raised during execution. For example:</source>
          <target state="translated">실행 중에 예외가 발생하면 작업을 재 시도하거나 폐기 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d0f83e7bb64d92b6a7b5c41f4d4d0caa14b8cea" translate="yes" xml:space="preserve">
          <source>It's also possible to specify the instance to be used:</source>
          <target state="translated">사용할 인스턴스를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bf6d5af71eff30bf65d8d44e4b90be5583daab" translate="yes" xml:space="preserve">
          <source>It's also possible to use multiple attributes in the same &lt;code&gt;find_by_&lt;/code&gt; by separating them with &amp;ldquo;&lt;em&gt;and&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">동일한 &lt;code&gt;find_by_&lt;/code&gt; 에서 여러 속성 을&amp;ldquo; &lt;em&gt;와&lt;/em&gt; &amp;rdquo; 로 구분하여 여러 속성을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3598f3734b84a9d144e42f8399310dc626f865a" translate="yes" xml:space="preserve">
          <source>It's common that you need to find a record or create it if it doesn't exist. You can do that with the &lt;code&gt;find_or_create_by&lt;/code&gt; and &lt;code&gt;find_or_create_by!&lt;/code&gt; methods.</source>
          <target state="translated">레코드를 찾거나 존재하지 않는 경우 작성해야하는 것이 일반적입니다. &lt;code&gt;find_or_create_by&lt;/code&gt; 와 &lt;code&gt;find_or_create_by!&lt;/code&gt; 그렇게 할 수 있습니다 ! 행동 양식.</target>
        </trans-unit>
        <trans-unit id="0f49250b8cffccdc364b03b3385e42a6d9aa7de5" translate="yes" xml:space="preserve">
          <source>It's common to have resources that are logically children of other resources. For example, suppose your application includes these models:</source>
          <target state="translated">논리적으로 다른 리소스의 자식 인 리소스를 갖는 것이 일반적입니다. 예를 들어, 응용 프로그램에 다음 모델이 포함되어 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b210ae2be028d7173f42ca71c61c6b0b4412e0aa" translate="yes" xml:space="preserve">
          <source>It's common to have resources that are logically children of other resources:</source>
          <target state="translated">논리적으로 다른 자원의 하위 자원 인 자원을 갖는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="70811258be9b0fd9bd6ee0a2ce8b0baa003841be" translate="yes" xml:space="preserve">
          <source>It's common to want to test the caching strategy of your application in development mode. Rails provides the rails command &lt;code&gt;dev:cache&lt;/code&gt; to easily toggle caching on/off.</source>
          <target state="translated">개발 모드에서 응용 프로그램의 캐싱 전략을 테스트하는 것이 일반적입니다. Rails는 Rails 명령 &lt;code&gt;dev:cache&lt;/code&gt; 를 제공하여 캐싱을 쉽게 켜고 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="496d6b6240d7125cf093cec706a29512a5683f4c" translate="yes" xml:space="preserve">
          <source>It's even possible to call these dynamic finder methods on relations and named scopes.</source>
          <target state="translated">관계 및 명명 된 범위에서 이러한 동적 파인더 메소드를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40bb18153b626c0253f7b7d4189338603c47ddb" translate="yes" xml:space="preserve">
          <source>It's even possible to use &lt;code&gt;exists?&lt;/code&gt; without any arguments on a model or a relation.</source>
          <target state="translated">&lt;code&gt;exists?&lt;/code&gt; 것도 가능 합니까? 모델이나 관계에 대한 논쟁없이.</target>
        </trans-unit>
        <trans-unit id="d966070d0b05c39fbcc1da00391f8af210d6e75b" translate="yes" xml:space="preserve">
          <source>It's helpful to be able to test incoming emails in development without actually sending and receiving real emails. To accomplish this, there's a conductor controller mounted at &lt;code&gt;/rails/conductor/action_mailbox/inbound_emails&lt;/code&gt;, which gives you an index of all the InboundEmails in the system, their state of processing, and a form to create a new InboundEmail as well.</source>
          <target state="translated">실제 이메일을주고받지 않고 개발중인 수신 이메일을 테스트 할 수 있으면 도움이됩니다. 이를 위해 &lt;code&gt;/rails/conductor/action_mailbox/inbound_emails&lt;/code&gt; 에 도체 컨트롤러가 설치되어 시스템의 모든 InboundEmail 색인, 처리 상태 및 새로운 InboundEmail 작성 양식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74318357210d0ce970a5c87b95a2c46f5bec161f" translate="yes" xml:space="preserve">
          <source>It's important to connect to your database in a single model and then inherit from that model for the tables rather than connect multiple individual models to the same database. Database clients have a limit to the number of open connections there can be and if you do this it will multiply the number of connections you have since Rails uses the model class name for the connection specification name.</source>
          <target state="translated">단일 모델로 데이터베이스에 연결 한 다음 여러 개별 모델을 동일한 데이터베이스에 연결하지 않고 테이블에 대해 해당 모델에서 상속하는 것이 중요합니다. 데이터베이스 클라이언트는 열린 연결 수에 제한이 있으며,이를 수행하면 Rails가 연결 스펙 이름으로 모델 클래스 이름을 사용하므로 연결 수를 곱하게됩니다.</target>
        </trans-unit>
        <trans-unit id="c731ba937d8d715e7c40709120f481beab47aa00" translate="yes" xml:space="preserve">
          <source>It's important to keep in mind at all times that the application should &lt;strong&gt;always&lt;/strong&gt; take precedence over its engines. An application is the object that has final say in what goes on in its environment. The engine should only be enhancing it, rather than changing it drastically.</source>
          <target state="translated">응용 프로그램이 &lt;strong&gt;항상&lt;/strong&gt; 엔진보다 우선 해야한다는 점을 &lt;strong&gt;항상&lt;/strong&gt; 명심해야합니다 . 응용 프로그램은 환경에서 일어나는 일에 대해 최종적으로 언급 한 객체입니다. 엔진은 엔진을 급격히 바꾸지 않고 향상시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="a0c359079f380a8190da5470e95085b4e0266c5b" translate="yes" xml:space="preserve">
          <source>It's important to remember that XML or JSON requests are also checked by default. If you're building an &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; or an SPA you could change forgery protection method in &lt;code&gt;ApplicationController&lt;/code&gt; (by default: &lt;code&gt;:exception&lt;/code&gt;):</source>
          <target state="translated">XML 또는 JSON 요청도 기본적으로 확인됩니다. &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; 또는 SPA를 구축하는 경우 &lt;code&gt;ApplicationController&lt;/code&gt; 에서 위조 방지 방법을 변경할 수 있습니다 (기본적으로 &lt;code&gt;:exception&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d4ea5fd1f11864cb83fb9ed3228955626a4be617" translate="yes" xml:space="preserve">
          <source>It's necessary not to set or leave &lt;code&gt;:nullify&lt;/code&gt; option for those associations that have &lt;code&gt;NOT NULL&lt;/code&gt; database constraints. If you don't set &lt;code&gt;dependent&lt;/code&gt; to destroy such associations you won't be able to change the associated object because the initial associated object's foreign key will be set to the unallowed &lt;code&gt;NULL&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 데이터베이스 제한 조건 이있는 연관에 대해서는 &lt;code&gt;:nullify&lt;/code&gt; 옵션 을 설정하거나 그대로 두지 않아도 됩니다 . 이러한 연관을 제거하도록 &lt;code&gt;dependent&lt;/code&gt; 을 설정하지 않으면 초기 연관된 오브젝트의 외부 키가 허용되지 않는 &lt;code&gt;NULL&lt;/code&gt; 값 으로 설정되므로 연관된 오브젝트를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2de386d061ae8779fc61c2f09a77ad60535807ab" translate="yes" xml:space="preserve">
          <source>It's normal for associations to work in two directions, requiring declaration on two different models:</source>
          <target state="translated">연결이 두 방향으로 작동하는 것은 정상이며 두 가지 다른 모델에 대한 선언이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="27f390c981876d7b7b77c2786f714460a8271639" translate="yes" xml:space="preserve">
          <source>It's not possible to derive all render calls like that, though. Here are a few examples of things that can't be derived:</source>
          <target state="translated">그래도 모든 렌더 호출을 파생시킬 수는 없습니다. 도출 할 수없는 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25f14b97d2c364a8b7b21e0c4a093d07e8cb1fd6" translate="yes" xml:space="preserve">
          <source>It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an &lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord::RecordNotFound&lt;/a&gt; error if they do not return any records, like &lt;code&gt;Person.find_by_last_name!&lt;/code&gt;.</source>
          <target state="translated">동적 파인더 끝에 느낌표 (!)를 추가하여 &lt;code&gt;Person.find_by_last_name!&lt;/code&gt; 과 같은 레코드를 리턴하지 않으면 &lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord :: RecordNotFound&lt;/a&gt; 오류를 발생시킬 수 있습니다 ! .</target>
        </trans-unit>
        <trans-unit id="07d745fa3c1940442a48d11e1c81707259e4e2fc" translate="yes" xml:space="preserve">
          <source>It's possible to rotate the ciphers and digests used for encrypted and signed cookies.</source>
          <target state="translated">암호화 및 서명 된 쿠키에 사용 된 암호 및 요약을 회전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32e8dd88e75c55390e501c7bd381f8aca605240" translate="yes" xml:space="preserve">
          <source>It's possible to set the fixture's model class directly in the YAML file. This is helpful when fixtures are loaded outside tests and &lt;code&gt;set_fixture_class&lt;/code&gt; is not available (e.g. when running &lt;code&gt;rails db:fixtures:load&lt;/code&gt;).</source>
          <target state="translated">조명기의 모델 클래스를 YAML 파일에서 직접 설정할 수 있습니다. 이것은 조명기가 테스트 외부에로드되고 &lt;code&gt;set_fixture_class&lt;/code&gt; 를 사용할 수없는 경우에 유용합니다 (예 &lt;code&gt;rails db:fixtures:load&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="98cb3aa74f36c4b8f6c7c65b58c0012c527c5d89" translate="yes" xml:space="preserve">
          <source>It's possible to stack callbacks by passing them as an array. Example:</source>
          <target state="translated">콜백을 배열로 전달하여 콜백을 쌓을 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="411969aa31079ad6714c1419f7c08edef6d92a15" translate="yes" xml:space="preserve">
          <source>It's possible to use any of the above middlewares in your custom Rack stack.</source>
          <target state="translated">위의 미들웨어를 사용자 정의 랙 스택에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d4cccbe811b7396f09d0f801e04618ab0dac79" translate="yes" xml:space="preserve">
          <source>It's time to add a second model to the application. The second model will handle comments on articles.</source>
          <target state="translated">이제 응용 프로그램에 두 번째 모델을 추가해야합니다. 두 번째 모델은 기사에 대한 주석을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0ad56c35d6c96eef75a6ee75178cc603e11a32f0" translate="yes" xml:space="preserve">
          <source>It's very important here to use the &lt;code&gt;String&lt;/code&gt; version of the class, rather than the class itself. If you were to use the class, Rails would attempt to load that class and then reference the related table. This could lead to problems if the table didn't already exist. Therefore, a &lt;code&gt;String&lt;/code&gt; should be used and then converted to a class using &lt;code&gt;constantize&lt;/code&gt; in the engine later on.</source>
          <target state="translated">여기서는 클래스 자체가 아닌 &lt;code&gt;String&lt;/code&gt; 버전의 클래스 를 사용하는 것이 매우 중요 합니다. 클래스를 사용하려는 경우 Rails는 해당 클래스를로드 한 다음 관련 테이블을 참조하려고 시도합니다. 테이블이 존재하지 않으면 문제가 발생할 수 있습니다. 따라서 &lt;code&gt;String&lt;/code&gt; 을 사용하고 나중에 엔진에서 &lt;code&gt;constantize&lt;/code&gt; 를 사용하여 클래스로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82c4355aa174ea1134e7c02d2a116f276e1eee7a" translate="yes" xml:space="preserve">
          <source>Iterates through each error key, value pair in the error messages hash. Yields the attribute and the error for that attribute. If the attribute has more than one error message, yields once for each error message.</source>
          <target state="translated">각 오류 키, 오류 메시지 해시의 값 쌍을 반복합니다. 속성과 해당 속성의 오류를 나타냅니다. 속성에 둘 이상의 오류 메시지가있는 경우 각 오류 메시지마다 한 번씩 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="fe0b7e20b2738d8025a2377f855de38e73f547f9" translate="yes" xml:space="preserve">
          <source>JSON and JSONB</source>
          <target state="translated">JSON과 JSONB</target>
        </trans-unit>
        <trans-unit id="cf43040f699629e838a8715912bcf428aa5440fb" translate="yes" xml:space="preserve">
          <source>JSON is a JavaScript data format used by many Ajax libraries. Rails has built-in support for converting objects to JSON and rendering that JSON back to the browser:</source>
          <target state="translated">JSON은 많은 Ajax 라이브러리에서 사용되는 JavaScript 데이터 형식입니다. Rails는 객체를 JSON으로 변환하고 JSON을 브라우저로 다시 렌더링하는 기능을 내장하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c1bce502137da7db199329615126120773d1f0" translate="yes" xml:space="preserve">
          <source>JSON parameters</source>
          <target state="translated">JSON 매개 변수</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON 지원</target>
        </trans-unit>
        <trans-unit id="91b8bae1d5741163238caeb859f60f9aad22ca54" translate="yes" xml:space="preserve">
          <source>JSON::decode</source>
          <target state="translated">JSON::decode</target>
        </trans-unit>
        <trans-unit id="cd65102564a8ba6c57d96671fc65196b16e48b3c" translate="yes" xml:space="preserve">
          <source>JSON::encode</source>
          <target state="translated">JSON::encode</target>
        </trans-unit>
        <trans-unit id="92b18c9405f766007bd6109914f3813baf41ad56" translate="yes" xml:space="preserve">
          <source>JSON::parse_error</source>
          <target state="translated">JSON::parse_error</target>
        </trans-unit>
        <trans-unit id="19acdb4160eb288df993337f159e349c600848ff" translate="yes" xml:space="preserve">
          <source>JSON_ESCAPE</source>
          <target state="translated">JSON_ESCAPE</target>
        </trans-unit>
        <trans-unit id="c4f4583027599ec31d99dce1fd474812e595bec5" translate="yes" xml:space="preserve">
          <source>JSON_ESCAPE_REGEXP</source>
          <target state="translated">JSON_ESCAPE_REGEXP</target>
        </trans-unit>
        <trans-unit id="6b078a8fb6a84f103228ea09a5d693750075dfee" translate="yes" xml:space="preserve">
          <source>JS_ESCAPE_MAP</source>
          <target state="translated">JS_ESCAPE_MAP</target>
        </trans-unit>
        <trans-unit id="3a2bc94aa5df89cb534947cbbba66bbfa8f5d420" translate="yes" xml:space="preserve">
          <source>JavaScript Compression</source>
          <target state="translated">자바 스크립트 압축</target>
        </trans-unit>
        <trans-unit id="329f655713f7ed95d8ad672ec206ea61c89847f8" translate="yes" xml:space="preserve">
          <source>JavaScript asset compression requires you have a JavaScript runtime available on your system, in the absence of a runtime you will see an &lt;code&gt;execjs&lt;/code&gt; error during asset compilation. Usually macOS and Windows come with a JavaScript runtime installed. &lt;code&gt;therubyrhino&lt;/code&gt; is the recommended runtime for JRuby users and is added by default to the &lt;code&gt;Gemfile&lt;/code&gt; in apps generated under JRuby. You can investigate all the supported runtimes at &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt;.</source>
          <target state="translated">JavaScript 자산 압축을 사용하려면 시스템에서 JavaScript 런타임을 사용할 수 있어야합니다. 런타임이 없으면 자산 컴파일 중에 &lt;code&gt;execjs&lt;/code&gt; 오류 가 표시됩니다 . 일반적으로 macOS 및 Windows에는 JavaScript 런타임이 설치되어 있습니다. &lt;code&gt;therubyrhino&lt;/code&gt; 는 JRuby 사용자에게 권장되는 런타임이며 기본적으로 JRuby에서 생성 된 앱 의 &lt;code&gt;Gemfile&lt;/code&gt; 에 추가됩니다 . &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt; 에서 지원되는 모든 런타임을 조사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c469bfe9f94b3c15c0a2967572561504964de859" translate="yes" xml:space="preserve">
          <source>JavaScript can also make requests to the server, and parse the response. It also has the ability to update information on the page. Combining these two powers, a JavaScript writer can make a web page that can update just parts of itself, without needing to get the full page data from the server. This is a powerful technique that we call Ajax.</source>
          <target state="translated">JavaScript는 서버에 요청을하고 응답을 구문 분석 할 수도 있습니다. 또한 페이지의 정보를 업데이트 할 수 있습니다. 이 두 가지 기능을 결합하여 JavaScript 작성기는 서버에서 전체 페이지 데이터를 가져올 필요없이 자체 일부만 업데이트 할 수있는 웹 페이지를 만들 수 있습니다. 이것은 우리가 Ajax라고 부르는 강력한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="e79342aa85fd4f1c22498783cd42d8faf5c0f966" translate="yes" xml:space="preserve">
          <source>JavaScriptHelper</source>
          <target state="translated">JavaScriptHelper</target>
        </trans-unit>
        <trans-unit id="4d1ff2f58b0a4a6adf2107fa93ff7226f28327a3" translate="yes" xml:space="preserve">
          <source>Job Execution</source>
          <target state="translated">작업 실행</target>
        </trans-unit>
        <trans-unit id="ba8d06fda34fb43af828c544923775e18fb1a0b2" translate="yes" xml:space="preserve">
          <source>Job Identifier</source>
          <target state="translated">작업 식별자</target>
        </trans-unit>
        <trans-unit id="3f331e97598d78f4160b82438f27bf259a5df56f" translate="yes" xml:space="preserve">
          <source>Job Testing</source>
          <target state="translated">직업 테스트</target>
        </trans-unit>
        <trans-unit id="e5baad04a61a328c9f20c8c710417477b5871973" translate="yes" xml:space="preserve">
          <source>Job arguments</source>
          <target state="translated">직업 인수</target>
        </trans-unit>
        <trans-unit id="243efbade47e05637dd57919b72473a334187b42" translate="yes" xml:space="preserve">
          <source>Job object</source>
          <target state="translated">작업 객체</target>
        </trans-unit>
        <trans-unit id="e91b70d63ed47030600cb3d8ce6bdfdabe2a990d" translate="yes" xml:space="preserve">
          <source>Job: Any class inheriting from the adapter may set the priority on the job object relative to other jobs.</source>
          <target state="translated">작업 : 어댑터에서 상속되는 모든 클래스는 다른 작업에 비해 작업 오브젝트의 우선 순위를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a6116842526736873ed5f69baef76f0d3c2c51b" translate="yes" xml:space="preserve">
          <source>Job: The number of retries can be set per instance of the job class.</source>
          <target state="translated">작업 : 재시도 횟수는 작업 클래스의 인스턴스마다 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfef8c94380b329ced3bcf083ac61b7f2a6ce2ec" translate="yes" xml:space="preserve">
          <source>Job: The timeout can be set for each instance of the job class.</source>
          <target state="translated">작업 : 작업 클래스의 각 인스턴스에 대해 시간 종료를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a539a40723c2241a7fba7916651de221c51cc8" translate="yes" xml:space="preserve">
          <source>Joining Across Databases</source>
          <target state="translated">데이터베이스 간 가입</target>
        </trans-unit>
        <trans-unit id="5e207af13c7f10c990fa0278c9a6d430dd7d1927" translate="yes" xml:space="preserve">
          <source>Joining Tables</source>
          <target state="translated">테이블 조인</target>
        </trans-unit>
        <trans-unit id="9cd1a12e9f4770062aa1cf8bf14ef4b159146a9b" translate="yes" xml:space="preserve">
          <source>Joining across clusters</source>
          <target state="translated">여러 클러스터에 참여</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="b8202b1a0f9ac4ece76b1b53a1b999e3fec322b8" translate="yes" xml:space="preserve">
          <source>Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren't matched by this. Also, we could have nested hashes which partially match, e.g. { a: :b } &amp;amp; { a: [:b, :c] }</source>
          <target state="translated">사전로드로 표시된 조인. 어떤 경우에는로드하기를 열망해야합니다. 이것은 동일한 연결을 나타내는 문자열과 기호를 가질 수 있지만 이것과 일치하지 않기 때문에 순진한 구현입니다. 또한 {a : : b} &amp;amp; {a : [: b, : c]}와 부분적으로 일치하는 중첩 해시를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e55f603d9ec6b7739d6e41f2a606f221971eb79" translate="yes" xml:space="preserve">
          <source>Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.</source>
          <target state="translated">거의 모든 Rails 애플리케이션이 데이터베이스와 많이 상호 작용하므로 결과적으로 테스트를 수행 할 데이터베이스도 필요합니다. 효율적인 테스트를 작성하려면이 데이터베이스를 설정하고 샘플 데이터로 채우는 방법을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a2e31fe0f7501188d972dc8b3009118ae147cce" translate="yes" xml:space="preserve">
          <source>Just about every Rails application will interact with a database. You can connect to the database by setting an environment variable &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; or by using a configuration file called &lt;code&gt;config/database.yml&lt;/code&gt;.</source>
          <target state="translated">거의 모든 Rails 애플리케이션이 데이터베이스와 상호 작용합니다. 환경 변수 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 을 설정 하거나 &lt;code&gt;config/database.yml&lt;/code&gt; 이라는 구성 파일을 사용하여 데이터베이스에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9bc826bb062c09dd75404c4f004cf69a6b37f" translate="yes" xml:space="preserve">
          <source>Just as with member routes, you can pass &lt;code&gt;:on&lt;/code&gt; to a route:</source>
          <target state="translated">회원 경로와 마찬가지로 &lt;code&gt;:on&lt;/code&gt; 을 경로로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f3d430d08030c44ea5008d7059f7767a85248fa" translate="yes" xml:space="preserve">
          <source>Just as with validations, it is also possible to skip callbacks by using the following methods:</source>
          <target state="translated">유효성 검사와 마찬가지로 다음 방법을 사용하여 콜백을 건너 뛸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7176b43f8be7e97b7f6abc748a4d1ba73e1f076" translate="yes" xml:space="preserve">
          <source>Just as you have to filter file names for uploads, you have to do so for downloads. The send_file() method sends files from the server to the client. If you use a file name, that the user entered, without filtering, any file can be downloaded:</source>
          <target state="translated">업로드 할 파일 이름을 필터링해야하는 것처럼 다운로드 할 때도 그렇게해야합니다. send_file () 메소드는 서버에서 클라이언트로 파일을 보냅니다. 파일 이름을 사용하면 필터링없이 사용자가 입력 한 파일을 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eba7e48f48826c026364d3ef9033ea0a2ba0cec" translate="yes" xml:space="preserve">
          <source>Just follow the flow and use constant autoloading always, never mix autoloading and &lt;code&gt;require&lt;/code&gt;. As a last resort, if some file absolutely needs to load a certain file use &lt;code&gt;require_dependency&lt;/code&gt; to play nice with constant autoloading. This option is rarely needed in practice, though.</source>
          <target state="translated">흐름을 따르고 항상 일정한 자동 로딩을 사용하고 자동 로딩을 혼합하지 말고 &lt;code&gt;require&lt;/code&gt; . 최후의 수단으로, 일부 파일이 특정 파일을로드해야하는 경우 &lt;code&gt;require_dependency&lt;/code&gt; 를 사용 하여 지속적인 자동 로딩을 즐기십시오. 그러나 실제로는이 옵션이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7399cb44559f41a1a38147646227e775691d7d9" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;calculations#method-i-pluck&quot;&gt;pluck&lt;/a&gt;, &lt;a href=&quot;calculations#method-i-pick&quot;&gt;pick&lt;/a&gt; will only load the actual value, not the entire record object, so it's also more efficient. The value is, again like with pluck, typecast by the column type.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;calculations#method-i-pluck&quot;&gt;뽑은&lt;/a&gt; , &lt;a href=&quot;calculations#method-i-pick&quot;&gt;선택은&lt;/a&gt; 또한보다 효율적으로, 그래서 만, 실제 값이 아닌 레코드 전체 개체를로드합니다. pluck과 마찬가지로 값은 열 유형별로 유형 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="671b2bc997bf58b09f7c839fa2e9de6a259349c8" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;where&lt;/code&gt; clauses scopes are merged using &lt;code&gt;AND&lt;/code&gt; conditions.</source>
          <target state="translated">그냥 같은 &lt;code&gt;where&lt;/code&gt; 조항의 범위를 사용하여 병합 &lt;code&gt;AND&lt;/code&gt; 조건.</target>
        </trans-unit>
        <trans-unit id="f64914076cb847b94287ce323657522270559d5e" translate="yes" xml:space="preserve">
          <source>Just like controller views, you can also have mailer layouts. The layout name needs to be the same as your mailer, such as &lt;code&gt;user_mailer.html.erb&lt;/code&gt; and &lt;code&gt;user_mailer.text.erb&lt;/code&gt; to be automatically recognized by your mailer as a layout.</source>
          <target state="translated">컨트롤러보기와 마찬가지로 메일러 레이아웃도 가질 수 있습니다. 메일러가 레이아웃으로 자동 인식 하려면 레이아웃 이름은 메일러와 동일해야합니다 (예 : &lt;code&gt;user_mailer.html.erb&lt;/code&gt; 및 &lt;code&gt;user_mailer.text.erb&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="753554100abd5092cfad1bab450b186806b19dcb" translate="yes" xml:space="preserve">
          <source>Just like the &lt;code&gt;:status&lt;/code&gt; option for &lt;code&gt;render&lt;/code&gt;, &lt;code&gt;:status&lt;/code&gt; for &lt;code&gt;redirect_to&lt;/code&gt; accepts both numeric and symbolic header designations.</source>
          <target state="translated">그냥 같은 &lt;code&gt;:status&lt;/code&gt; 에 대한 옵션을 &lt;code&gt;render&lt;/code&gt; , &lt;code&gt;:status&lt;/code&gt; 에 대한 &lt;code&gt;redirect_to&lt;/code&gt; 는 숫자와 기호 헤더 지정을 모두 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="48a1e320e2900c92a403a1b54619041dc6c7dbb0" translate="yes" xml:space="preserve">
          <source>Just like with controller views, use &lt;code&gt;yield&lt;/code&gt; to render the view inside the layout.</source>
          <target state="translated">컨트롤러보기와 마찬가지로 &lt;code&gt;yield&lt;/code&gt; 를 사용 하여 레이아웃 내부에서보기를 렌더링하십시오.</target>
        </trans-unit>
        <trans-unit id="cfe563ecbc5c2d0727d8e68cb28dba126901d7cb" translate="yes" xml:space="preserve">
          <source>Just provide the polymorphic target type and Active Record will take care of the rest.</source>
          <target state="translated">다형성 대상 유형 만 제공하면 Active Record가 나머지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="860d8665c7153f5ed86a5af21fcfc9bdf178a9c7" translate="yes" xml:space="preserve">
          <source>Just remember: They'll be gone by the time the next action has been performed.</source>
          <target state="translated">다음 작업이 수행 될 때까지 사라질 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d4539f21502f9a79f091307f97c17b2f1499a26d" translate="yes" xml:space="preserve">
          <source>KILOBYTE</source>
          <target state="translated">KILOBYTE</target>
        </trans-unit>
        <trans-unit id="74f46f9fed362d70b79016c97d7a171bb9094666" translate="yes" xml:space="preserve">
          <source>KV_RE</source>
          <target state="translated">KV_RE</target>
        </trans-unit>
        <trans-unit id="6dc3af60e01355817ee8300ffeb6bf0b63b5301c" translate="yes" xml:space="preserve">
          <source>Karel Minař&amp;iacute;k</source>
          <target state="translated">카렐 미나 릭</target>
        </trans-unit>
        <trans-unit id="ca6310cd242689398be52a0e491b3ffc0905a27a" translate="yes" xml:space="preserve">
          <source>Keep in mind that database adapters handle certain serialization tasks for you. For instance: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types in PostgreSQL will be converted between JSON object/array syntax and Ruby &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; objects transparently. There is no need to use &lt;a href=&quot;classmethods#method-i-serialize&quot;&gt;serialize&lt;/a&gt; in this case.</source>
          <target state="translated">데이터베이스 어댑터는 특정 직렬화 태스크를 처리합니다. 예를 들어 PostgreSQL의 &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;jsonb&lt;/code&gt; 유형은 JSON 객체 / 배열 구문과 Ruby &lt;code&gt;Hash&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 객체 간에 투명하게 변환됩니다. 이 경우 &lt;a href=&quot;classmethods#method-i-serialize&quot;&gt;직렬화&lt;/a&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
