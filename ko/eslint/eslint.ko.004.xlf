<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="eslint">
    <body>
      <group id="eslint">
        <trans-unit id="242eeccd5d52147ec1754c157acf9d8bc93f2a94" translate="yes" xml:space="preserve">
          <source>FunctionExpression</source>
          <target state="translated">FunctionExpression</target>
        </trans-unit>
        <trans-unit id="7b9979eefc37fbcb68120aa159c368948bb1d7b5" translate="yes" xml:space="preserve">
          <source>Functions Explained</source>
          <target state="translated">설명 된 기능</target>
        </trans-unit>
        <trans-unit id="9d73f5d6d7a1f0213edd697639ee44d40a45e487" translate="yes" xml:space="preserve">
          <source>Functions declared inside of other functions should be declared immediately after the &lt;code&gt;var&lt;/code&gt; statement.</source>
          <target state="translated">다른 함수 안에서 선언 된 함수는 &lt;code&gt;var&lt;/code&gt; 문 바로 다음에 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4bcc58afe5ae87087e01c52a23f4ed7d3ef4f59" translate="yes" xml:space="preserve">
          <source>Functions should be declared before they are used. When a function is not a method (not attached to an object) it should be defined using function declaration format (not function expression format nor using the &lt;code&gt;Function&lt;/code&gt; constructor). There should be no space between the function name and the opening parentheses. There should be one space between the closing parentheses and the right brace. The right brace should be on the same line as the &lt;code&gt;function&lt;/code&gt; keyword. There should be no space after the opening parentheses or before the closing parentheses. Named arguments should have a space after the comma but not before it. The function body should be indented one level.</source>
          <target state="translated">함수는 사용하기 전에 선언해야합니다. 함수가 메소드가 아닌 경우 (객체에 첨부되지 않은 경우) 함수 선언 형식 (함수 표현식 형식이나 &lt;code&gt;Function&lt;/code&gt; 생성자가 아닌)을 사용하여 정의해야합니다 . 함수 이름과 여는 괄호 사이에는 공백이 없어야합니다. 닫는 괄호와 오른쪽 중괄호 사이에 공백이 하나 있어야합니다. 오른쪽 괄호는 &lt;code&gt;function&lt;/code&gt; 키워드 와 같은 줄에 있어야합니다 . 여는 괄호 뒤에 또는 닫는 괄호 앞에 공백이 없어야합니다. 명명 된 인수는 쉼표 뒤에 공백이 있어야하지만 앞에 쉼표가 없어야합니다. 함수 본문은 한 수준으로 들여 쓰기해야합니다.</target>
        </trans-unit>
        <trans-unit id="bde886e46a60602d71e6fb5101b6d6dffe1e77d5" translate="yes" xml:space="preserve">
          <source>Functions that take numerous parameters can be difficult to read and write because it requires the memorization of what each parameter is, its type, and the order they should appear in. As a result, many coders adhere to a convention that caps the number of parameters a function can take.</source>
          <target state="translated">많은 매개 변수를 사용하는 함수는 각 매개 변수의 유형, 유형 및 표시 순서를 암기해야하기 때문에 읽고 쓰기가 어려울 수 있습니다. 결과적으로 많은 코더는 매개 변수의 수를 제한하는 규칙을 따릅니다. 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="e25c1e95ea5591c995c9c1f25b2d912e486761e8" translate="yes" xml:space="preserve">
          <source>Further Reading: https://estools.github.io/escope/</source>
          <target state="translated">추가 자료 : https://estools.github.io/escope/</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="ba2bb5be981e93482d382868040766613c7b17db" translate="yes" xml:space="preserve">
          <source>Further, ES6 modules mandate that &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements can only occur in the top level of the module's body.</source>
          <target state="translated">또한 ES6 모듈은 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 명령문이 모듈 본문의 최상위 레벨에서만 발생할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7815e5645af9df96e892739a3b0f31714ebc82b7" translate="yes" xml:space="preserve">
          <source>Further, in &lt;code&gt;&quot;always&quot;&lt;/code&gt; mode, a second object option is available that contains a single boolean &lt;code&gt;allowNewlines&lt;/code&gt; property.</source>
          <target state="translated">또한 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 모드에서는 단일 부울 &lt;code&gt;allowNewlines&lt;/code&gt; 특성 을 포함하는 두 번째 오브젝트 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81de065a8861790d26820fc5d06589b48f235e3e" translate="yes" xml:space="preserve">
          <source>Generally, semicolons are at the end of lines. However, in semicolon-less style, semicolons are at the beginning of lines. This rule enforces that semicolons are at the configured location.</source>
          <target state="translated">일반적으로 세미콜론은 줄의 끝에 있습니다. 그러나 세미콜론이없는 스타일에서는 세미콜론이 시작 부분에 있습니다. 이 규칙은 세미콜론이 구성된 위치에있게합니다.</target>
        </trans-unit>
        <trans-unit id="3e79ba65138b641bbe407622f3e91f8a8f78035c" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;build/eslint.js&lt;/code&gt; for use in a browser</source>
          <target state="translated">브라우저에서 사용하기 위해 &lt;code&gt;build/eslint.js&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="fcc5b2914a7a2ea251adb77c39978894c31abd89" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;build/eslint.js&lt;/code&gt;, a version of ESLint for use in the browser</source>
          <target state="translated">브라우저에서 사용하기위한 ESLint 버전 인 &lt;code&gt;build/eslint.js&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="5945bd3c8bc550a8cf2401193804d1c9e6d113b1" translate="yes" xml:space="preserve">
          <source>Generates JSDoc documentation and places it into &lt;code&gt;/jsdoc&lt;/code&gt;.</source>
          <target state="translated">JSDoc 문서를 생성하여 &lt;code&gt;/jsdoc&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="310727bd5d081f34063cbab1b776498ff1099367" translate="yes" xml:space="preserve">
          <source>Generators are a new type of function in ECMAScript 6 that can return multiple values over time. These special functions are indicated by placing an &lt;code&gt;*&lt;/code&gt; after the &lt;code&gt;function&lt;/code&gt; keyword.</source>
          <target state="translated">생성기는 ECMAScript 6에서 시간이 지남에 따라 여러 값을 반환 할 수있는 새로운 유형의 함수입니다. 이 특수 함수는 &lt;code&gt;function&lt;/code&gt; 키워드 뒤에 &lt;code&gt;*&lt;/code&gt; 를 붙여 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="93c139a6ce34105689c947640356617403f86eb6" translate="yes" xml:space="preserve">
          <source>Get familiar with the &lt;a href=&quot;user-guide/command-line-interface&quot;&gt;command line options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;user-guide/command-line-interface&quot;&gt;명령 행 옵션에&lt;/a&gt; 익숙해 지십시오 .</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="58b550930ff9fffb167adfd8ee39a843e9586962" translate="yes" xml:space="preserve">
          <source>Getting Started with ESLint</source>
          <target state="translated">ESLint 시작하기</target>
        </trans-unit>
        <trans-unit id="7ca8756b353c0b76dc6de040bd89171962896459" translate="yes" xml:space="preserve">
          <source>Getting the Source</source>
          <target state="translated">소스 얻기</target>
        </trans-unit>
        <trans-unit id="128c6bb7b6bf78e6850bf53726f5a89cab72531b" translate="yes" xml:space="preserve">
          <source>Git Precommit Hook</source>
          <target state="translated">힘내 사전 커밋 후크</target>
        </trans-unit>
        <trans-unit id="21ff9395b1860dfd1b610dd7f96c9e872d886945" translate="yes" xml:space="preserve">
          <source>Git pre-commit hook that only lints staged changes</source>
          <target state="translated">보푸라기 만 단계적으로 변경되는 Git 사전 커밋 후크</target>
        </trans-unit>
        <trans-unit id="e617e36bd8412176fc0cb1c38dd248de4b431c36" translate="yes" xml:space="preserve">
          <source>Glob pattern overrides have higher precedence than the regular configuration in the same config file. Multiple overrides within the same config are applied in order. That is, the last override block in a config file always has the highest precedence.</source>
          <target state="translated">글로브 패턴 대체는 동일한 구성 파일의 일반 구성보다 우선 순위가 높습니다. 동일한 구성 내의 여러 재정의가 순서대로 적용됩니다. 즉, 구성 파일의 마지막 재정의 블록이 항상 가장 높은 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0823f01a9e70f704b93047e4e7ec9b65dc5acd57" translate="yes" xml:space="preserve">
          <source>Global variable leaks</source>
          <target state="translated">전역 변수 누출</target>
        </trans-unit>
        <trans-unit id="1e8bf2817d0e3606a6573ec6b33c08545db542a1" translate="yes" xml:space="preserve">
          <source>Global variable leaks.</source>
          <target state="translated">전역 변수 누출.</target>
        </trans-unit>
        <trans-unit id="bdf50a7101b173e7ff27359f55926a9df8d5a3fd" translate="yes" xml:space="preserve">
          <source>Global variables created from a script can produce name collisions with global variables created from another script, which will usually lead to runtime errors or unexpected behavior.</source>
          <target state="translated">스크립트에서 생성 된 전역 변수는 다른 스크립트에서 생성 된 전역 변수와 이름 충돌을 일으킬 수 있으며 일반적으로 런타임 오류 또는 예기치 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1d22fa6d5fe08a0428bd868deefa69f7b4dad4c" translate="yes" xml:space="preserve">
          <source>Globals can be disabled with the string &lt;code&gt;&quot;off&quot;&lt;/code&gt;. For example, in an environment where most ES2015 globals are available but &lt;code&gt;Promise&lt;/code&gt; is unavailable, you might use this config:</source>
          <target state="translated">문자열 &lt;code&gt;&quot;off&quot;&lt;/code&gt; 로 전역을 비활성화 할 수 있습니다 . 예를 들어 대부분의 ES2015 전역을 사용할 수 있지만 &lt;code&gt;Promise&lt;/code&gt; 를 사용할 수없는 환경 에서이 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6694355730f716bd8bc02fad0f77e6032920b3" translate="yes" xml:space="preserve">
          <source>Globs are matched using &lt;a href=&quot;https://github.com/kaelzhang/node-ignore&quot;&gt;node-ignore&lt;/a&gt;, so a number of features are available:</source>
          <target state="translated">Glob은 &lt;a href=&quot;https://github.com/kaelzhang/node-ignore&quot;&gt;node-ignore를&lt;/a&gt; 사용하여 일치 하므로 여러 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="411dfa3491e742f169a9eabf19310458112cfe76" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/eslint/eslint&quot;&gt;https://github.com/eslint/eslint&lt;/a&gt; and click the &quot;Fork&quot; button. Follow the &lt;a href=&quot;https://help.github.com/articles/fork-a-repo&quot;&gt;GitHub documentation&lt;/a&gt; for forking and cloning.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/eslint/eslint&quot;&gt;https://github.com/eslint/eslint로&lt;/a&gt; 이동 하여 &quot;포크&quot;버튼을 클릭하십시오. 분기 및 복제에 대해서는 &lt;a href=&quot;https://help.github.com/articles/fork-a-repo&quot;&gt;GitHub 설명서&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="a6617e667de9f88741fd1a7ebaf6f0e23cfbaa38" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://nodejs.org/&quot;&gt;https://nodejs.org/&lt;/a&gt; to download and install the latest stable version for your operating system.</source>
          <target state="translated">운영 체제에 맞는 최신 안정 버전을 다운로드하여 설치하려면 &lt;a href=&quot;https://nodejs.org/&quot;&gt;https://nodejs.org/&lt;/a&gt; 로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ea7f828f26d9fceea4f4d6bd87992131e20906f" translate="yes" xml:space="preserve">
          <source>Grunt: &lt;a href=&quot;https://www.npmjs.com/package/grunt-eslint&quot;&gt;grunt-eslint&lt;/a&gt;</source>
          <target state="translated">그런트 : 그런트 &lt;a href=&quot;https://www.npmjs.com/package/grunt-eslint&quot;&gt;-에슬 린트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="54000f7505185b081957bfac1390caa5502c47df" translate="yes" xml:space="preserve">
          <source>Gulp: &lt;a href=&quot;https://www.npmjs.com/package/gulp-eslint&quot;&gt;gulp-eslint&lt;/a&gt;</source>
          <target state="translated">꿀꺽 &lt;a href=&quot;https://www.npmjs.com/package/gulp-eslint&quot;&gt;꿀꺽 꿀꺽 꿀꺽 꿀꺽 마시다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a3cb3ca162fa44c4df1b6111753f586c63126fb" translate="yes" xml:space="preserve">
          <source>Handling warnings</source>
          <target state="translated">경고 처리</target>
        </trans-unit>
        <trans-unit id="400e3ff42bde508534f29f8b35fbfc07bca3a323" translate="yes" xml:space="preserve">
          <source>Have an ESLint team member champion inclusion of the rule</source>
          <target state="translated">ESLint 팀원 챔피언에게 규칙 포함</target>
        </trans-unit>
        <trans-unit id="a198a8011dce88c0fa8a772a88db629e2b707836" translate="yes" xml:space="preserve">
          <source>Have an ESLint team member champion the change</source>
          <target state="translated">ESLint 팀원이 변화를 이겨내도록하십시오</target>
        </trans-unit>
        <trans-unit id="2331ba67e2d2702911301630fcf52e4c0d23abea" translate="yes" xml:space="preserve">
          <source>Have some extra time and want to contribute? This section talks about the process of working on issues.</source>
          <target state="translated">여분의 시간이 있고 기여하고 싶습니까? 이 섹션에서는 문제를 해결하는 프로세스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0a4d55a8d778e5022fab701977c5d840bbc486d0" translate="yes" xml:space="preserve">
          <source>Hello World</source>
          <target state="translated">안녕하세요 월드</target>
        </trans-unit>
        <trans-unit id="4698476cc278899c186f08ba38fc540c030e5af5" translate="yes" xml:space="preserve">
          <source>Here are a few common examples using the ES5 syntax:</source>
          <target state="translated">다음은 ES5 구문을 사용하는 몇 가지 일반적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="50fcab2478cdd473bf8ef09108774e65b13bfec6" translate="yes" xml:space="preserve">
          <source>Here are methods for the &lt;a href=&quot;../rules/array-callback-return&quot;&gt;array-callback-return&lt;/a&gt; rule:</source>
          <target state="translated">&lt;a href=&quot;../rules/array-callback-return&quot;&gt;배열 콜백 리턴&lt;/a&gt; 규칙에 대한 메소드는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="8107635e978f92c38dfc42f4127b75fb737c33b8" translate="yes" xml:space="preserve">
          <source>Here are some good commit message summary examples:</source>
          <target state="translated">좋은 커밋 메시지 요약 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93db38995286d4c911c64ebca2e9ba323edd87ae" translate="yes" xml:space="preserve">
          <source>Here are the supported object options:</source>
          <target state="translated">지원되는 객체 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bd072abb5800aca18a1177a3f0b3a9572a87781" translate="yes" xml:space="preserve">
          <source>Here is an example configuration:</source>
          <target state="translated">구성 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e674c22be7c4bf1ffea002950ce480358ab828e8" translate="yes" xml:space="preserve">
          <source>Here is an example of a generator function:</source>
          <target state="translated">다음은 생성기 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e49700a85e99598dc36d99df820a3fccd24ff705" translate="yes" xml:space="preserve">
          <source>Here is the basic format of the source file for a rule:</source>
          <target state="translated">다음은 규칙 소스 파일의 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="dd8677592fa5ec27c36b1f8455fb17aa39ea36fe" translate="yes" xml:space="preserve">
          <source>Here's a configuration file with the closest equivalent of the old defaults:</source>
          <target state="translated">이전 기본값과 가장 비슷한 구성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f2b2a6785fe7221113d612b4694f75cc5b860c2" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;.eslintrc.json&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;.eslintrc.json&lt;/code&gt; 파일 의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3caaee4438077ccfc367e54ba130583f7f5793e1" translate="yes" xml:space="preserve">
          <source>Here's an example where the usage of &lt;code&gt;=&amp;gt;&lt;/code&gt; could be confusing:</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 사용법 이 혼란 스러울 수 있는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="69579a1902b896558c6c5e0da078f9c102327c17" translate="yes" xml:space="preserve">
          <source>Here's an example where the usage of &lt;code&gt;=&amp;gt;&lt;/code&gt; is most likely a typo:</source>
          <target state="translated">다음은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 사용법이 오타 일 가능성이 높은 예입니다 .</target>
        </trans-unit>
        <trans-unit id="91cf4ec4989adf874c24a01d0a7887526b72a403" translate="yes" xml:space="preserve">
          <source>Here's what the &lt;code&gt;data&lt;/code&gt; object would look like if one rule, &lt;code&gt;no-extra-semi&lt;/code&gt;, had been run:</source>
          <target state="translated">여기에 무슨 &lt;code&gt;data&lt;/code&gt; 객체가 하나의 규칙, 경우처럼 보일 것 &lt;code&gt;no-extra-semi&lt;/code&gt; , 있었다 실행 :</target>
        </trans-unit>
        <trans-unit id="c8381d2b32745ce22d2b437f812f233f5b2f2c31" translate="yes" xml:space="preserve">
          <source>Here's what the schema from above looks like when properly converted:</source>
          <target state="translated">올바르게 변환했을 때의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75ae80968a1517575f98728b476cb5292150f02e" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;fix()&lt;/code&gt; function is used to insert a semicolon after the node. Note that a fix is not immediately applied, and may not be applied at all if there are conflicts with other fixes. After applying fixes, ESLint will run all of the enabled rules again on the fixed code, potentially applying more fixes. This process will repeat up to 10 times, or until no more fixable problems are found. Afterwards, any remaining problems will be reported as usual.</source>
          <target state="translated">여기서 &lt;code&gt;fix()&lt;/code&gt; 함수는 노드 뒤에 세미콜론을 삽입하는 데 사용됩니다. 수정 사항은 즉시 적용되지 않으며 다른 수정 사항과 충돌이있는 경우 전혀 적용되지 않을 수 있습니다. 수정 사항을 적용한 후 ESLint는 모든 활성화 된 규칙을 수정 된 코드에서 다시 실행하여 더 많은 수정 사항을 적용합니다. 이 프로세스는 최대 10 회까지 또는 더 이상 수정 가능한 문제가 발견되지 않을 때까지 반복됩니다. 그 후 남은 문제는 평소대로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8fbec61ce977dd79baacea5273b4c4549f2f0f9a" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;fix()&lt;/code&gt; function is used to insert a semicolon after the node. Note that the fix is not immediately applied and may not be applied at all if there are conflicts with other fixes. If the fix cannot be applied, then the problem message is reported as usual; if the fix can be applied, then the problem message is not reported.</source>
          <target state="translated">여기서 &lt;code&gt;fix()&lt;/code&gt; 함수는 노드 뒤에 세미콜론을 삽입하는 데 사용됩니다. 수정 사항은 즉시 적용되지 않으며 다른 수정 사항과 충돌이있는 경우 전혀 적용되지 않을 수 있습니다. 수정 사항을 적용 할 수없는 경우 문제점 메시지가 정상적으로보고됩니다. 수정 사항을 적용 할 수 있으면 문제점 메시지가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff8b740232342a63ba2626bdfd5772e2040ddc24" translate="yes" xml:space="preserve">
          <source>How ESLint Finds Personal Configuration File</source>
          <target state="translated">ESLint가 개인 구성 파일을 찾는 방법</target>
        </trans-unit>
        <trans-unit id="5f9f0fbf29f7b501c030758c0c08e3456ab16379" translate="yes" xml:space="preserve">
          <source>How Personal Configuration File Behaves</source>
          <target state="translated">개인 구성 파일의 작동 방식</target>
        </trans-unit>
        <trans-unit id="baf60d8659418f3ae6c463f7ba4d66b67aa7ea0a" translate="yes" xml:space="preserve">
          <source>How evil is eval</source>
          <target state="translated">평가는 얼마나 악한가</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="1327d170552189b8d51b2d02b266287ad708c180" translate="yes" xml:space="preserve">
          <source>How to store Node.js deployment settings/configuration files? - Stack Overflow</source>
          <target state="translated">Node.js 배포 설정 / 구성 파일을 저장하는 방법? - 스택 오버플로</target>
        </trans-unit>
        <trans-unit id="61690269fd440a22ff0ab6115f326e176ab7f24d" translate="yes" xml:space="preserve">
          <source>However, if you want to enforce the style of spacing between the &lt;code&gt;function&lt;/code&gt; keyword and the following opening parenthesis, please refer to &lt;a href=&quot;space-before-function-paren&quot;&gt;space-before-function-paren&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;function&lt;/code&gt; 키워드와 다음 여는 괄호 사이에 간격 스타일을 적용하려면 function &lt;a href=&quot;space-before-function-paren&quot;&gt;-before-function-paren을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d1d23a4e252168ddaf82392ba6af06eb923611d" translate="yes" xml:space="preserve">
          <source>However, if you're using Node.js, you may want to turn strict mode on globally. Files are typically not concatenated together in Node.js projects and therefore the risk of applying strict mode accidentally is minimal. Further, since every file in Node.js has its own scope, global strict mode only effects the single file in which it is placed.</source>
          <target state="translated">그러나 Node.js를 사용하는 경우 전역에서 엄격 모드를 켜고 싶을 수 있습니다. 파일은 일반적으로 Node.js 프로젝트에서 함께 연결되지 않으므로 실수로 엄격 모드를 적용 할 위험은 최소화됩니다. 또한 Node.js의 모든 파일에는 고유 한 범위가 있으므로 전역 엄격 모드는 파일이 위치한 단일 파일에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="128ecc4491bd188d93624c174fbe6b646868393b" translate="yes" xml:space="preserve">
          <source>However, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:</source>
          <target state="translated">그러나 세미콜론을 사용하는 사람들에게는 ASI 메커니즘이 까다로울 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c379491a9b3c4a1a9218e57f12d3d5a77f41c184" translate="yes" xml:space="preserve">
          <source>However, there are a few problems with this. First, you can't be sure what type of system the script is running on. Node.js can be run on any computer, including Windows, which uses a different path separator. It's very easy, therefore, to create an invalid path using string concatenation and assuming Unix-style separators. There's also the possibility of having double separators, or otherwise ending up with an invalid path.</source>
          <target state="translated">그러나 이것에는 몇 가지 문제가 있습니다. 첫째, 스크립트가 어떤 유형의 시스템에서 실행 중인지 확신 할 수 없습니다. Node.js는 다른 경로 구분 기호를 사용하는 Windows를 포함한 모든 컴퓨터에서 실행될 수 있습니다. 따라서 문자열 연결을 사용하고 유닉스 스타일 구분 기호를 가정하면 유효하지 않은 경로를 만드는 것이 매우 쉽습니다. 이중 구분 기호가 있거나 유효하지 않은 경로로 끝날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb456769869329e0928feb28b4a92121639f6d0" translate="yes" xml:space="preserve">
          <source>However, this is no different from using the more concise object literal syntax:</source>
          <target state="translated">그러나 이것은 더 간결한 객체 리터럴 구문을 사용하는 것과 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0691cb4a13c783b84fc4fabc7b11778ad1cb0a36" translate="yes" xml:space="preserve">
          <source>However, to simplify schema creation, rules may also export an array of schemas for each optional positional argument, and ESLint will automatically validate the required error level first. For example, the &lt;code&gt;yoda&lt;/code&gt; rule accepts a primary mode argument, as well as an extra options object with named properties.</source>
          <target state="translated">그러나 스키마 생성을 단순화하기 위해 규칙은 각 선택적 위치 인수에 대한 스키마 배열을 내보낼 수도 있으며 ESLint는 먼저 필요한 오류 수준을 자동으로 확인합니다. 예를 들어, &lt;code&gt;yoda&lt;/code&gt; 규칙은 기본 모드 인수와 이름이 지정된 추가 옵션 개체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c30ae13ab8f250b713026f3fce02de7c62dc87d4" translate="yes" xml:space="preserve">
          <source>However, when declared in the top-level of a browser script these variables are not 'script-scoped'. They are actually created in the global scope and could produce name collisions with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables and &lt;code&gt;function&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; declarations from other scripts. This does not apply to ES and CommonJS modules.</source>
          <target state="translated">그러나 브라우저 스크립트의 최상위 레벨에서 선언 될 때 이러한 변수는 '스크립트 범위'가 아닙니다. 그들은 실제로 전역에 만들어지고와 이름이 충돌 생산할 수있는 &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 하고 &lt;code&gt;let&lt;/code&gt; 변수와 &lt;code&gt;function&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; 다른 스크립트에서 선언합니다. ES 및 CommonJS 모듈에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c427752105bd33ab8292fe22f39c248a208b872f" translate="yes" xml:space="preserve">
          <source>However, with appropriate new lines, it becomes easy to read and understand. Look at the same code written below with line breaks after each call.</source>
          <target state="translated">그러나 적절한 새 줄을 사용하면 쉽게 읽고 이해할 수 있습니다. 각 호출 후에 줄 바꿈으로 아래에 작성된 동일한 코드를보십시오.</target>
        </trans-unit>
        <trans-unit id="ddc6b64c7c2b6bc0e7723c5590c9bcaba38b512d" translate="yes" xml:space="preserve">
          <source>However, you might not want to manually add &lt;code&gt;eslint-disable-next-line&lt;/code&gt; or &lt;code&gt;eslint-disable-line&lt;/code&gt;. You can achieve the effect of only receiving errors for console calls with the &lt;code&gt;no-restricted-syntax&lt;/code&gt; rule:</source>
          <target state="translated">그러나 &lt;code&gt;eslint-disable-next-line&lt;/code&gt; 또는 &lt;code&gt;eslint-disable-line&lt;/code&gt; 을 수동으로 추가하지 않을 수 있습니다 . &lt;code&gt;no-restricted-syntax&lt;/code&gt; 이 필요없는 구문 규칙을 사용하여 콘솔 호출에 대해서만 오류를 수신하는 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84bf4d2e563fecd62c000173949d1bd469a0d041" translate="yes" xml:space="preserve">
          <source>I hope to deprecate &lt;code&gt;functionExpressionScope&lt;/code&gt; field as replacing by &lt;code&gt;scope.type === &quot;function-expression-name&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scope.type === &quot;function-expression-name&quot;&lt;/code&gt; 으로 대체하여 &lt;code&gt;functionExpressionScope&lt;/code&gt; 필드 를 더 이상 사용하지 않기를 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="3a588183ac256de41f63b2fdfbfde1275ea31a40" translate="yes" xml:space="preserve">
          <source>I hope to deprecate &lt;code&gt;identifiers&lt;/code&gt; field as replacing by &lt;code&gt;defs[].name&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;defs[].name&lt;/code&gt; 필드 로 대체하여 &lt;code&gt;identifiers&lt;/code&gt; 필드 를 더 이상 사용하지 않기를 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="1c0d841662dae605665760989b60b4cb4244744f" translate="yes" xml:space="preserve">
          <source>I hope to rename &lt;code&gt;set&lt;/code&gt; field or replace by a method.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; field의 이름을 바꾸 거나 메소드 로 바꾸고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="7b889fd29b2848edc4e5927706ca2407a685ae99" translate="yes" xml:space="preserve">
          <source>IIFEs</source>
          <target state="translated">IIFEs</target>
        </trans-unit>
        <trans-unit id="1425a804470d990c0638321f27625d9932279335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;always&quot;&lt;/code&gt; then the &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/*&lt;/code&gt; must be followed by at least one whitespace.</source>
          <target state="translated">경우 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 다음 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;/*&lt;/code&gt; 하나 이상의 공백이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="94911ace78ebe05995938d04eaeb09f0e2b08447" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;balanced&quot;: false&lt;/code&gt; then balanced whitespace is not enforced.</source>
          <target state="translated">경우 &lt;code&gt;&quot;balanced&quot;: false&lt;/code&gt; 후 균형 공백이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df6236bfac26b8bc9b50004728602cf54088348b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;balanced&quot;: true&lt;/code&gt; and &lt;code&gt;&quot;always&quot;&lt;/code&gt; then the &lt;code&gt;/*&lt;/code&gt; must be followed by at least one whitespace, and the &lt;code&gt;*/&lt;/code&gt; must be preceded by at least one whitespace.</source>
          <target state="translated">경우 &lt;code&gt;&quot;balanced&quot;: true&lt;/code&gt; 과 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 다음 &lt;code&gt;/*&lt;/code&gt; 하는 적어도 하나의 공백 다음에해야하며, &lt;code&gt;*/&lt;/code&gt; 하는 적어도 하나의 공백이 선행되어야한다.</target>
        </trans-unit>
        <trans-unit id="65b29e4c4508e7a3b1dcca425ea25f5d0a6019fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;balanced&quot;: true&lt;/code&gt; and &lt;code&gt;&quot;never&quot;&lt;/code&gt; then there should be no whitespace following &lt;code&gt;/*&lt;/code&gt; or preceding &lt;code&gt;*/&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&quot;balanced&quot;: true&lt;/code&gt; 과 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 다음이 없어야없는 공백의 다음 &lt;code&gt;/*&lt;/code&gt; 또는 이전 &lt;code&gt;*/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bd5cf86f2f0cd115eb5d6412df3814063f3fe2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;never&quot;&lt;/code&gt; then there should be no whitespace following.</source>
          <target state="translated">경우 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 다음에 공백의 다음이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="af559ebac1d09db39ca603a5249c7f829d0aab9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.eslintrc.*&lt;/code&gt; and/or &lt;code&gt;package.json&lt;/code&gt; files are also used for configuration (i.e., &lt;code&gt;--no-eslintrc&lt;/code&gt; was not specified), the configurations will be merged. Options from this configuration file have precedence over the options from &lt;code&gt;.eslintrc.*&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt; files.</source>
          <target state="translated">경우 &lt;code&gt;.eslintrc.*&lt;/code&gt; 및 / 또는 &lt;code&gt;package.json&lt;/code&gt; 의 파일도 (즉,이 구성에 사용되는 &lt;code&gt;--no-eslintrc&lt;/code&gt; 가 지정되지 않았습니다), 구성은 병합됩니다. 이 구성 파일의 옵션은 &lt;code&gt;.eslintrc.*&lt;/code&gt; 및 &lt;code&gt;package.json&lt;/code&gt; 파일 의 옵션보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="7a9f1ee9e49e65873a251fff85f77d43eab66dac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RuleTester.describe&lt;/code&gt; and &lt;code&gt;RuleTester.it&lt;/code&gt; have been set to function values, &lt;code&gt;RuleTester&lt;/code&gt; will use &lt;code&gt;RuleTester.describe&lt;/code&gt; and &lt;code&gt;RuleTester.it&lt;/code&gt; to run tests. You can use this to customize the behavior of &lt;code&gt;RuleTester&lt;/code&gt; to match a test framework that you're using.</source>
          <target state="translated">경우 &lt;code&gt;RuleTester.describe&lt;/code&gt; 및 &lt;code&gt;RuleTester.it&lt;/code&gt; 은 함수 값에 설정 한 &lt;code&gt;RuleTester&lt;/code&gt; 는 사용 &lt;code&gt;RuleTester.describe&lt;/code&gt; 및 &lt;code&gt;RuleTester.it&lt;/code&gt; 를 테스트를 실행합니다. 이를 사용하여 &lt;code&gt;RuleTester&lt;/code&gt; 의 동작을 사용중인 테스트 프레임 워크와 일치 하도록 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec01bb29e273ee321f9993370bc52ce9eab5a01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align&lt;/code&gt; is defined as an object, but not all of the parameters are provided, undefined parameters will default to the following:</source>
          <target state="translated">경우 &lt;code&gt;align&lt;/code&gt; 매개 변수가 제공되는 모든 객체로 정의되는 것이 아니라, 정의되지 않은 매개 변수는 다음 기본값으로 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="7468df61e4cc7cbe78e75b5258128550f1d95105" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eslint&lt;/code&gt; could find configuration files in the project, &lt;code&gt;eslint&lt;/code&gt; ignores &lt;code&gt;~/.eslintrc.*&lt;/code&gt; file even if it's in an ancestor directory of the project directory.</source>
          <target state="translated">&lt;code&gt;eslint&lt;/code&gt; 가 프로젝트에서 구성 파일을 찾을 수 있으면 eslint 는 &lt;code&gt;~/.eslintrc.*&lt;/code&gt; 파일이 프로젝트 디렉토리의 상위 디렉토리에 &lt;code&gt;eslint&lt;/code&gt; 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="c910d7177c7be80d23035d833053528e65fae9b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eslint&lt;/code&gt; could not find any configuration file in the project, &lt;code&gt;eslint&lt;/code&gt; loads &lt;code&gt;~/.eslintrc.*&lt;/code&gt; file.</source>
          <target state="translated">경우 &lt;code&gt;eslint&lt;/code&gt; 이 프로젝트의 모든 구성 파일을 찾을 수 없습니다, &lt;code&gt;eslint&lt;/code&gt; 의 부하 &lt;code&gt;~/.eslintrc.*&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="f571fae99406f632111fb82aa898e2ca4b333877" translate="yes" xml:space="preserve">
          <source>If ESLint can't find a configuration, then it will throw an error and ask you to provide one.</source>
          <target state="translated">ESLint가 구성을 찾을 수 없으면 오류가 발생하여 구성을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="6f1aa46516ae8fbeb1465af094f22ef03395bdcb" translate="yes" xml:space="preserve">
          <source>If ESLint parses code in strict mode, the parser (instead of this rule) reports the error.</source>
          <target state="translated">ESLint가 엄격 모드에서 코드를 구문 분석하면이 규칙 대신 구문 분석기가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="36700c2c10655c29379465dfe1fd6e89caba46f9" translate="yes" xml:space="preserve">
          <source>If Statements</source>
          <target state="translated">if 문</target>
        </trans-unit>
        <trans-unit id="28c62b22bf0008ec1a25ee68e5e4cab444e0ca67" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;catch&lt;/code&gt; clause in a &lt;code&gt;try&lt;/code&gt; statement accidentally (or purposely) assigns another value to the exception parameter, it impossible to refer to the error from that point on. Since there is no &lt;code&gt;arguments&lt;/code&gt; object to offer alternative access to this data, assignment of the parameter is absolutely destructive.</source>
          <target state="translated">경우 &lt;code&gt;catch&lt;/code&gt; A의 절 &lt;code&gt;try&lt;/code&gt; 문이 실수로 (또는 의도적으로) 예외 매개 변수에 다른 값을 할당하는 것은 불가능에 그 시점에서 오류를 참조하십시오. 이 데이터에 대한 대체 액세스를 제공 할 &lt;code&gt;arguments&lt;/code&gt; 객체 가 없으므로 매개 변수의 할당은 절대적으로 파괴적입니다.</target>
        </trans-unit>
        <trans-unit id="ec2084855440431416b29d5a35071c33fe850853" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;switch&lt;/code&gt; doesn't have a &lt;code&gt;default&lt;/code&gt; case, then it should be indicated with a comment.</source>
          <target state="translated">경우 &lt;code&gt;switch&lt;/code&gt; 이없는 &lt;code&gt;default&lt;/code&gt; 케이스를, 다음은 주석으로 표시해야한다.</target>
        </trans-unit>
        <trans-unit id="68b79dad32e10651fe6aed17316501637283b2e3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;switch&lt;/code&gt; statement has duplicate test expressions in &lt;code&gt;case&lt;/code&gt; clauses, it is likely that a programmer copied a &lt;code&gt;case&lt;/code&gt; clause but forgot to change the test expression.</source>
          <target state="translated">경우 &lt;code&gt;switch&lt;/code&gt; 문에서 중복 테스트 표현이 &lt;code&gt;case&lt;/code&gt; 조항, 프로그래머가 복사 가능성이 &lt;code&gt;case&lt;/code&gt; 절을하지만, 테스트 표현식을 변경하는 것을 잊었다.</target>
        </trans-unit>
        <trans-unit id="da3285cd66acdef654458171d8d844b63892f8e4" translate="yes" xml:space="preserve">
          <source>If a Promise executor function is using &lt;code&gt;await&lt;/code&gt;, this is usually a sign that it is not actually necessary to use the &lt;code&gt;new Promise&lt;/code&gt; constructor, or the scope of the &lt;code&gt;new Promise&lt;/code&gt; constructor can be reduced.</source>
          <target state="translated">약속의 실행 프로그램 기능을 사용하는 경우 &lt;code&gt;await&lt;/code&gt; 를 ,이는 사용할 실제로 필요하지 않습니다 있다는 신호 보통 &lt;code&gt;new Promise&lt;/code&gt; 생성자를, 또는의 범위 &lt;code&gt;new Promise&lt;/code&gt; 감소시킬 수 생성자.</target>
        </trans-unit>
        <trans-unit id="2a8d6853f7a44d1ae90dbb34ebf7a13d629e57a6" translate="yes" xml:space="preserve">
          <source>If a class method does not use &lt;code&gt;this&lt;/code&gt;, it can &lt;em&gt;sometimes&lt;/em&gt; be made into a static function. If you do convert the method into a static function, instances of the class that call that particular method have to be converted to a static call as well (&lt;code&gt;MyClass.callStaticMethod()&lt;/code&gt;)</source>
          <target state="translated">클래스 메서드는 사용하지 않는 경우 &lt;code&gt;this&lt;/code&gt; , 그것은 수 &lt;em&gt;때로는&lt;/em&gt; 정적 함수로 만들 수. 메소드를 정적 함수로 변환하는 경우 해당 특정 메소드를 호출하는 클래스의 인스턴스도 정적 호출로 변환해야합니다 ( &lt;code&gt;MyClass.callStaticMethod()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f9adcd77d4fef720476018d5517c24d272a09b5e" translate="yes" xml:space="preserve">
          <source>If a custom message is specified with the &lt;code&gt;message&lt;/code&gt; property, ESLint will use that message when reporting occurrences of the syntax specified in the &lt;code&gt;selector&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 속성 으로 사용자 정의 메시지를 지정 하면 ESLint는 &lt;code&gt;selector&lt;/code&gt; 속성에 지정된 구문의 발생을보고 할 때 해당 메시지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d79ab9e420559d08edcc7d09e6db99ddf957f261" translate="yes" xml:space="preserve">
          <source>If a directory is specified, a cache file will be created inside the specified folder. The name of the file will be based on the hash of the current working directory (CWD). e.g.: &lt;code&gt;.cache_hashOfCWD&lt;/code&gt;</source>
          <target state="translated">디렉토리가 지정되면 지정된 폴더 내에 캐시 파일이 작성됩니다. 파일 이름은 현재 작업 디렉토리 (CWD)의 해시를 기반으로합니다. 예 : &lt;code&gt;.cache_hashOfCWD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="013f35aac0d5daf915b473bc276e6dac035af41c" translate="yes" xml:space="preserve">
          <source>If a filename in the optional second parameter matches a file that is configured to be ignored, then this function returns no errors or warnings. The method includes an additional optional boolean third parameter. When &lt;code&gt;true&lt;/code&gt;, a resolved file name that is ignored will return a warning.</source>
          <target state="translated">선택적인 두 번째 매개 변수의 파일 이름이 무시되도록 구성된 파일과 일치하면이 함수는 오류나 경고를 반환하지 않습니다. 이 방법에는 추가 선택적 부울 세 번째 매개 변수가 포함됩니다. 때 &lt;code&gt;true&lt;/code&gt; 무시하는 해결 파일 이름은 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d76f9a27f5a237607b9a23b2fbc50e0d167e5729" translate="yes" xml:space="preserve">
          <source>If a loop contains no nested loops or switches, labeling the loop is unnecessary.</source>
          <target state="translated">루프에 중첩 루프 나 스위치가 없으면 루프 레이블을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ffa52261da0cd7a502d7bf4801fc10335e0f7e30" translate="yes" xml:space="preserve">
          <source>If a processor name starts with &lt;code&gt;.&lt;/code&gt;, ESLint handles the processor as a &lt;strong&gt;file extension-named processor&lt;/strong&gt; especially and applies the processor to the kind of files automatically. People don't need to specify the file extension-named processors in their config files.</source>
          <target state="translated">경우 프로세서 이름으로 시작 &lt;code&gt;.&lt;/code&gt; ESLint는 프로세서를 &lt;strong&gt;파일 확장명&lt;/strong&gt; 프로세서로 처리하고 프로세서를 &lt;strong&gt;파일&lt;/strong&gt; 종류에 자동으로 적용합니다. 구성 파일에 파일 확장명 프로세서를 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5fad7687981070af33a1b73460dae7788d4aabc" translate="yes" xml:space="preserve">
          <source>If a reference is inside of a binary expression or a ternary expression, this rule checks the result of the expression instead. If a reference is inside of a dynamic expression (e.g. &lt;code&gt;CallExpression&lt;/code&gt;, &lt;code&gt;YieldExpression&lt;/code&gt;, ...), this rule ignores it.</source>
          <target state="translated">참조가 이진 표현식 또는 삼항 표현식 내에 있으면이 규칙은 대신 표현식의 결과를 확인합니다. 참조가 동적 표현식 안에 있으면 (예 : &lt;code&gt;CallExpression&lt;/code&gt; , &lt;code&gt;YieldExpression&lt;/code&gt; 등)이 규칙은이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1e1270048dc46eb08c8bcfe13b7604338d3a96bc" translate="yes" xml:space="preserve">
          <source>If a rule has additional options, you can specify them using array literal syntax, such as:</source>
          <target state="translated">규칙에 추가 옵션이있는 경우 다음과 같은 배열 리터럴 구문을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed092715e7af9dc686e6a209cce5db829a9d7eae" translate="yes" xml:space="preserve">
          <source>If a string is provided as an error instead of an object, the string is used to assert the &lt;code&gt;message&lt;/code&gt; of the error.</source>
          <target state="translated">문자열이 객체 대신 오류로 제공되는 경우 문자열은 오류 &lt;code&gt;message&lt;/code&gt; 를 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9d78cfc776b15554fbf39fc84e184e687deb527" translate="yes" xml:space="preserve">
          <source>If a valid test case only uses the &lt;code&gt;code&lt;/code&gt; property, it can optionally be provided as a string containing the code, rather than an object with a &lt;code&gt;code&lt;/code&gt; key.</source>
          <target state="translated">유효한 테스트 사례가 &lt;code&gt;code&lt;/code&gt; 속성 만 사용하는 경우 &lt;code&gt;code&lt;/code&gt; 키 가있는 객체가 아니라 코드를 포함하는 문자열로 선택적으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce06671cc1c5422162e0dbee1e02e62dbe4151bb" translate="yes" xml:space="preserve">
          <source>If a variable is initialized or assigned the value &lt;code&gt;this&lt;/code&gt;, the name of the variable &lt;em&gt;must&lt;/em&gt; be a designated alias.</source>
          <target state="translated">변수가 초기화되거나 값 &lt;code&gt;this&lt;/code&gt; 가 지정 되면 변수 이름은 지정된 별명 &lt;em&gt;이어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="83ba7ea230d056612009b4845562832e2c193c78" translate="yes" xml:space="preserve">
          <source>If a variable is never reassigned, using the &lt;code&gt;const&lt;/code&gt; declaration is better.</source>
          <target state="translated">변수를 다시 할당하지 않으면 &lt;code&gt;const&lt;/code&gt; 선언을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05279982445e35103bd42dc84f0c8fa4bc99dcf3" translate="yes" xml:space="preserve">
          <source>If a variable with a designated name is declared, it &lt;em&gt;must&lt;/em&gt; be either initialized (in the declaration) or assigned (in the same scope as the declaration) the value &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">지정된 이름의 변수가 선언 된 경우, 그것은 &lt;em&gt;해야&lt;/em&gt; 값 중 하나 (선언에서) 초기화되거나 (선언과 같은 범위에서) 할당 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c391588a627bffc4f9b2fa0a7ad1a3f187fc0a5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.eslintignore&lt;/code&gt; file is not found and an alternate file is not specified, ESLint will look in package.json for an &lt;code&gt;eslintIgnore&lt;/code&gt; key to check for files to ignore.</source>
          <target state="translated">는 IF &lt;code&gt;.eslintignore&lt;/code&gt; 의 파일을 찾을 수없는 및 대체 파일이 지정되지 않은, ESLint는 대한 package.json에서 찾게됩니다 &lt;code&gt;eslintIgnore&lt;/code&gt; 의 무시하는 파일을 확인 키.</target>
        </trans-unit>
        <trans-unit id="31e630605fbaa69cd7c9106660d700ae7cc8e034" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;if&lt;/code&gt; block contains a &lt;code&gt;return&lt;/code&gt; statement, the &lt;code&gt;else&lt;/code&gt; block becomes unnecessary. Its contents can be placed outside of the block.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록에 &lt;code&gt;return&lt;/code&gt; 문 이 있으면 &lt;code&gt;else&lt;/code&gt; 블록이 불필요 해집니다. 내용은 블록 외부에 놓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060bb33758f5003d2495b8e6017c8aabee9fd6f6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;if&lt;/code&gt; statement is the only statement in the &lt;code&gt;else&lt;/code&gt; block, it is often clearer to use an &lt;code&gt;else if&lt;/code&gt; form.</source>
          <target state="translated">는 IF &lt;code&gt;if&lt;/code&gt; 문이있는 유일한 문이다 &lt;code&gt;else&lt;/code&gt; 블록, 사용하는 것이 명확 &lt;code&gt;else if&lt;/code&gt; 형태.</target>
        </trans-unit>
        <trans-unit id="108772879dc734697fb9e3f2633d5a6195dc2277" translate="yes" xml:space="preserve">
          <source>If an async executor function throws an error, the error will be lost and won't cause the newly-constructed &lt;code&gt;Promise&lt;/code&gt; to reject. This could make it difficult to debug and handle some errors.</source>
          <target state="translated">비동기 실행기 함수에서 오류가 발생하면 오류가 손실되고 새로 구성된 &lt;code&gt;Promise&lt;/code&gt; 가 거부 되지 않습니다 . 이로 인해 일부 오류를 디버깅하고 처리하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731f187649e609b76cb19e1a10d708cfa4f42b24" translate="yes" xml:space="preserve">
          <source>If an integration has dependencies on ESLint and a set of plugins, and the tool invokes ESLint on behalf of the user with a preset configuration, the tool should set &lt;code&gt;--resolve-plugins-relative-to&lt;/code&gt; to the top-level directory of the tool.</source>
          <target state="translated">통합에 ESLint 및 플러그인 세트에 대한 종속성이 있고 사전 설정된 구성으로 사용자를 대신하여 도구가 ESLint를 호출하는 경우 도구는 &lt;code&gt;--resolve-plugins-relative-to&lt;/code&gt; 도구의 최상위 디렉토리로 설정해야합니다. .</target>
        </trans-unit>
        <trans-unit id="430cfbaad19dd61f95f6a025f052c0903d62611a" translate="yes" xml:space="preserve">
          <source>If an issue has already been claimed by someone, please be respectful of that person's desire to complete the work and don't work on it unless you verify that they are no longer interested.</source>
          <target state="translated">누군가가 문제를 이미 주장했다면 더 이상 관심이없는 것으로 확인되지 않는 한 해당 작업을 완료하려는 사람의 욕구를 존중하고 작업하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff0ee57a0b710f6259eb08de6ae0349bb2ee8fc7" translate="yes" xml:space="preserve">
          <source>If another developer attempts to add &lt;code&gt;baz();&lt;/code&gt; to the &lt;code&gt;if&lt;/code&gt; statement, they might mistakenly change the code to</source>
          <target state="translated">다른 개발자가 &lt;code&gt;baz();&lt;/code&gt; 를 추가하려고하면 ; 받는 &lt;code&gt;if&lt;/code&gt; 문, 그들은 실수로 코드를 변경 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d490c46886da3eef22da5146c1cd9f085497227a" translate="yes" xml:space="preserve">
          <source>If any code paths in a function return a value explicitly but some code path do not return a value explicitly, it might be a typing mistake, especially in a large function. In the following example:</source>
          <target state="translated">함수의 코드 경로가 명시 적으로 값을 반환하지만 일부 코드 경로가 명시 적으로 값을 반환하지 않는 경우, 특히 큰 함수에서 입력 오류 일 수 있습니다. 다음 예에서</target>
        </trans-unit>
        <trans-unit id="c724ecc343a6b714b13c8432f177e2988958c487" translate="yes" xml:space="preserve">
          <source>If comments are inconsistent because they are not updated when function definitions are modified, then readers might become confused.</source>
          <target state="translated">함수 정의가 수정 될 때 주석이 업데이트되지 않아 주석이 일치하지 않으면 독자가 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98fcb5379ef45039a8d0d4e959eef97582a2d85a" translate="yes" xml:space="preserve">
          <source>If comments are invalid because of typing mistakes, then documentation will be incomplete.</source>
          <target state="translated">입력 실수로 주석이 유효하지 않으면 문서가 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="cbb41ffface398ef2232aa13a97c60ff349b62b2" translate="yes" xml:space="preserve">
          <source>If don't want to enforce consistent linebreaks inside function parentheses, do not turn on this rule.</source>
          <target state="translated">함수 괄호 안에 일관된 줄 바꿈을 적용하지 않으려면이 규칙을 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e46b2ee896050d579bb14e7a488a09fdee949b37" translate="yes" xml:space="preserve">
          <source>If explicit declaration of global variables is not to your taste.</source>
          <target state="translated">전역 변수의 명시 적 선언이 취향에 맞지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="8f73860fe183fb4ea93cd5ae590599a3b93a4551" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;&quot;always&quot;&lt;/code&gt;, then the literal value must always come first.</source>
          <target state="translated">이 경우 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 다음 리터럴 값은 항상 먼저 와야.</target>
        </trans-unit>
        <trans-unit id="9a5cddf7639a3dd0ad1b5edfefda8e16074b2b70" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;&quot;object&quot;&lt;/code&gt; (default), the dot in a member expression should be on the same line as the object portion.</source>
          <target state="translated">이 경우 &lt;code&gt;&quot;object&quot;&lt;/code&gt; (디폴트), 일원 식의 도트 개체 부와 동일 선상에 있어야한다.</target>
        </trans-unit>
        <trans-unit id="03af9596ea8057aa7372bb310711b2afc56fd99c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;&quot;property&quot;&lt;/code&gt;, the dot in a member expression should be on the same line as the property portion.</source>
          <target state="translated">이 경우 &lt;code&gt;&quot;property&quot;&lt;/code&gt; , 일원 식에 도트 속성 부와 동일 선상에 있어야한다.</target>
        </trans-unit>
        <trans-unit id="bbd5ac5250ad5ecc9dc78acbb61a5f71c2252cd3" translate="yes" xml:space="preserve">
          <source>If it is the default &lt;code&gt;&quot;never&quot;&lt;/code&gt;, then comparisons must never be Yoda conditions.</source>
          <target state="translated">이것이 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 기본값 인 경우 비교는 절대 요다 조건이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc9f5a48306289fb13de2cacc02542cd88ed1536" translate="yes" xml:space="preserve">
          <source>If more than one parameter has the same name in a function definition, the last occurrence &quot;shadows&quot; the preceding occurrences. A duplicated name might be a typing error.</source>
          <target state="translated">함수 정의에서 둘 이상의 매개 변수가 동일한 이름을 갖는 경우 마지막 발생은 이전 발생을 &quot;그림자&quot;로 표시합니다. 중복 된 이름은 입력 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b2099ade2be35a89641a96b838792d35446840" translate="yes" xml:space="preserve">
          <source>If multiple selectors have equal specificity, their listeners will be called in alphabetical order for that node.</source>
          <target state="translated">여러 선택기가 동일한 특이성을 갖는 경우 해당 리스너는 해당 노드에 대해 알파벳 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cb4224d9d3359902074aad85bbe517c47fc6fe85" translate="yes" xml:space="preserve">
          <source>If one of those occurs in an innocent-looking statement such as &lt;code&gt;a == b&lt;/code&gt; the actual problem is very difficult to spot.</source>
          <target state="translated">그 중 하나가 &lt;code&gt;a == b&lt;/code&gt; 와 같은 순진한 문장에서 나오는 경우 실제 문제를 찾기가 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="71c77efc2dce3b6c849c7d1edf87a9fd15fcf2ac" translate="yes" xml:space="preserve">
          <source>If re-exporting from an imported module, you should add the imports to the &lt;code&gt;import&lt;/code&gt;-statement, and export that directly, not use &lt;code&gt;export ... from&lt;/code&gt;.</source>
          <target state="translated">가져온 모듈에서 다시 내보내는 경우 &lt;code&gt;import&lt;/code&gt; - statement에 가져 오기를 추가하고 &lt;code&gt;export ... from&lt;/code&gt; 사용하지 않고 직접 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="0eb3e53516bf8f022c5a2446e35a316afcbffebd" translate="yes" xml:space="preserve">
          <source>If that sounds like you, then continue reading to get started.</source>
          <target state="translated">그 소리가 당신처럼 들리면 계속해서 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="2d461afe2572662db02026a93f2f9778445ac9b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;always&quot;&lt;/code&gt; option is used, this rule requires that files always begin with the Unicode BOM character U+FEFF. If &lt;code&gt;&quot;never&quot;&lt;/code&gt; is used, files must never begin with U+FEFF.</source>
          <target state="translated">경우 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 옵션을 사용,이 규칙 파일은 항상 유니 코드 BOM 문자 U + FEFF로 시작해야합니다. 경우 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 사용하지 않는 파일은 U + FEFF로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a004223cf87eacec3bf8edcbe4617e861ea2175b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;exceptRange&quot;&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;, the rule &lt;em&gt;allows&lt;/em&gt; yoda conditions in range comparisons which are wrapped directly in parentheses, including the parentheses of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; condition. The default value is &lt;code&gt;false&lt;/code&gt;. A &lt;em&gt;range&lt;/em&gt; comparison tests whether a variable is inside or outside the range between two literal values.</source>
          <target state="translated">는 IF &lt;code&gt;&quot;exceptRange&quot;&lt;/code&gt; 속성입니다 &lt;code&gt;true&lt;/code&gt; , 규칙이 &lt;em&gt;허용&lt;/em&gt; 의 괄호를 포함하여 괄호 안에 직접 포장하는 범위 비교에서 요다 조건 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 상태. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;em&gt;범위&lt;/em&gt; 비교 테스트 변수 안에 두 리터럴 값의 범위 밖인지의 여부.</target>
        </trans-unit>
        <trans-unit id="80ccea46ead798cf9822ef53909d165d6457d6b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;onlyEquality&quot;&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;, the rule reports yoda conditions &lt;em&gt;only&lt;/em&gt; for the equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&quot;onlyEquality&quot;&lt;/code&gt; 속성입니다 &lt;code&gt;true&lt;/code&gt; , 규칙 보고서 요다 조건 &lt;em&gt;에만&lt;/em&gt; 평등 운영자 &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;===&lt;/code&gt; . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="861981c1e841a3a76ef0b71345e0aaaf9b6bfd8b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ignoreConsecutiveComments&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, then comments which otherwise violate the rule will not be reported as long as they immediately follow another comment. This can be applied more than once.</source>
          <target state="translated">는 IF &lt;code&gt;ignoreConsecutiveComments&lt;/code&gt; 의 옵션이 설정되어 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 규칙을 위반하고 의견 그들이 즉시 다른 의견을 따를로보고되지 않습니다. 이것은 두 번 이상 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bffdbe44f305944bc7109716f9cf52ec0cf80daa" translate="yes" xml:space="preserve">
          <source>If the arrow function is intentional, it should be wrapped in parens to remove ambiguity.</source>
          <target state="translated">화살표 기능이 의도적 인 경우 모호성을 제거하기 위해 괄호로 싸야합니다.</target>
        </trans-unit>
        <trans-unit id="55317abcd7e2aa335fbbbc7490e278d824a2e6b4" translate="yes" xml:space="preserve">
          <source>If the class/attribute/pseudo-class count is tied, the selector that contains more node type selectors has higher specificity.</source>
          <target state="translated">클래스 / 속성 / 의사-클래스 카운트가 묶인 경우 더 많은 노드 유형 선택기가 포함 된 선택기가 더 높은 특이성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="286888e55b37d67f478b26da19d04cf8b3fa7cba" translate="yes" xml:space="preserve">
          <source>If the configured name of the error variable begins with a &lt;code&gt;^&lt;/code&gt; it is considered to be a regexp pattern.</source>
          <target state="translated">오류 변수의 구성된 이름이 &lt;code&gt;^&lt;/code&gt; 로 시작 하면 정규 표현식 패턴으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c8424c3fa05ae2557114fbb7afae75511fc54e4f" translate="yes" xml:space="preserve">
          <source>If the example plugin above were called &lt;code&gt;eslint-plugin-myPlugin&lt;/code&gt;, the &lt;code&gt;myConfig&lt;/code&gt; and &lt;code&gt;myOtherConfig&lt;/code&gt; configurations would then be usable by extending off of &lt;code&gt;&quot;plugin:myPlugin/myConfig&quot;&lt;/code&gt; and &lt;code&gt;&quot;plugin:myPlugin/myOtherConfig&quot;&lt;/code&gt;, respectively.</source>
          <target state="translated">위의 예제 플러그인이 &lt;code&gt;eslint-plugin-myPlugin&lt;/code&gt; 이면 , 각각 &lt;code&gt;&quot;plugin:myPlugin/myConfig&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;plugin:myPlugin/myOtherConfig&quot;&lt;/code&gt; 를 확장 하여 &lt;code&gt;myConfig&lt;/code&gt; 및 &lt;code&gt;myOtherConfig&lt;/code&gt; 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6755e05b62b74cc3c5aaf2f93b2be523dafe3b38" translate="yes" xml:space="preserve">
          <source>If the expression sequence is explicitly wrapped in parentheses.</source>
          <target state="translated">식 시퀀스가 ​​명시 적으로 괄호로 묶인 경우.</target>
        </trans-unit>
        <trans-unit id="4979b6e8f108fec6d6947fcf358fcb9a4ebe8f29" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;code&gt;CatchClause&lt;/code&gt;, the variable for the exception is returned.</source>
          <target state="translated">노드가 &lt;code&gt;CatchClause&lt;/code&gt; 인 경우 예외에 대한 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0bedf0818cdf99f778f0aba476971b9012249054" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;code&gt;ClassDeclaration&lt;/code&gt; or a &lt;code&gt;ClassExpression&lt;/code&gt;, the variable for the class name is returned.</source>
          <target state="translated">노드가 &lt;code&gt;ClassDeclaration&lt;/code&gt; 또는 &lt;code&gt;ClassExpression&lt;/code&gt; 인 경우 클래스 이름의 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5dcd249f6b5101ffc512ce04d850df7301f340" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;code&gt;FunctionDeclaration&lt;/code&gt; or &lt;code&gt;FunctionExpression&lt;/code&gt;, the variable for the function name is returned, in addition to variables for the function parameters.</source>
          <target state="translated">노드가 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 또는 &lt;code&gt;FunctionExpression&lt;/code&gt; 인 경우 함수 매개 변수에 대한 변수 외에 함수 이름에 대한 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0239c6eab481baf7e5cd73e1d8be32515edd4e81" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;code&gt;VariableDeclaration&lt;/code&gt;, all variables declared in the declaration are returned.</source>
          <target state="translated">노드가 &lt;code&gt;VariableDeclaration&lt;/code&gt; 인 경우 선언에 선언 된 모든 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="61a88a7314032c642bfc5f80310b4c5fc44211ab" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;code&gt;VariableDeclarator&lt;/code&gt;, all variables declared in the declarator are returned.</source>
          <target state="translated">노드가 &lt;code&gt;VariableDeclarator&lt;/code&gt; 인 경우 선언자에 선언 된 모든 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a53e1a5bf877ea2bcfd787625d054a10533b30c2" translate="yes" xml:space="preserve">
          <source>If the node is an &lt;code&gt;ArrowFunctionExpression&lt;/code&gt;, variables for the parameters are returned.</source>
          <target state="translated">노드가 &lt;code&gt;ArrowFunctionExpression&lt;/code&gt; 인 경우 매개 변수의 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9f838ab4ac526271081c23b394b697a09e426e0d" translate="yes" xml:space="preserve">
          <source>If the node is an &lt;code&gt;ImportDeclaration&lt;/code&gt;, variables for all of its specifiers are returned.</source>
          <target state="translated">노드가 &lt;code&gt;ImportDeclaration&lt;/code&gt; 인 경우 모든 지정자에 대한 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e6c21b10c9edae6498937fd2f3d4185500c8f7f7" translate="yes" xml:space="preserve">
          <source>If the node is an &lt;code&gt;ImportSpecifier&lt;/code&gt;, &lt;code&gt;ImportDefaultSpecifier&lt;/code&gt;, or &lt;code&gt;ImportNamespaceSpecifier&lt;/code&gt;, the declared variable is returned.</source>
          <target state="translated">노드가 &lt;code&gt;ImportSpecifier&lt;/code&gt; , &lt;code&gt;ImportDefaultSpecifier&lt;/code&gt; 또는 &lt;code&gt;ImportNamespaceSpecifier&lt;/code&gt; 인 경우 선언 된 변수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="77e6d0663a5dc9ddfb5ba721ad2cac984752b5a7" translate="yes" xml:space="preserve">
          <source>If the object name is omitted, the property is disallowed for all objects:</source>
          <target state="translated">객체 이름을 생략하면 모든 객체에 대해 속성이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d87c6b6c0dd2f2805118449f8bde287740cd978" translate="yes" xml:space="preserve">
          <source>If the operation ends with a parsing error, you will get a single message for this file, with &lt;code&gt;fatal: true&lt;/code&gt; added as an extra property.</source>
          <target state="translated">작업이 구문 분석 오류로 끝나는 경우이 파일에 대한 추가 메시지로 &lt;code&gt;fatal: true&lt;/code&gt; 추가 된 단일 메시지가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe396c3c6bb93306ee96c0f7cebd18cb04f122d" translate="yes" xml:space="preserve">
          <source>If the option is &lt;code&gt;&quot;^(err|error|anySpecificError)$&quot;&lt;/code&gt;, the rule reports unhandled errors where the parameter name can be &lt;code&gt;err&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;anySpecificError&lt;/code&gt;.</source>
          <target state="translated">옵션이 &lt;code&gt;&quot;^(err|error|anySpecificError)$&quot;&lt;/code&gt; 인 경우 규칙은 매개 변수 이름이 &lt;code&gt;err&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;anySpecificError&lt;/code&gt; 일 수있는 처리되지 않은 오류를보고합니다 .</target>
        </trans-unit>
        <trans-unit id="eb07ab30e4a55a6eddf8ef9a05a2f85cf2a6aee9" translate="yes" xml:space="preserve">
          <source>If the option is &lt;code&gt;&quot;^.*(e|E)rr&quot;&lt;/code&gt;, the rule reports unhandled errors where the parameter name matches any string that contains &lt;code&gt;err&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt; (for example, &lt;code&gt;err&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;anyError&lt;/code&gt;, &lt;code&gt;some_err&lt;/code&gt; will match).</source>
          <target state="translated">옵션이 &lt;code&gt;&quot;^.*(e|E)rr&quot;&lt;/code&gt; 인 경우 규칙은 매개 변수 이름이 &lt;code&gt;err&lt;/code&gt; 또는 &lt;code&gt;Err&lt;/code&gt; 가 포함 된 문자열과 일치하는 처리되지 않은 오류를보고합니다 (예 : &lt;code&gt;err&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;anyError&lt;/code&gt; , &lt;code&gt;some_err&lt;/code&gt; 가 일치 함).</target>
        </trans-unit>
        <trans-unit id="93cc7488fa78f99eb5cf4d9c302285ca9b4f9441" translate="yes" xml:space="preserve">
          <source>If the option is &lt;code&gt;&quot;^.+Error$&quot;&lt;/code&gt;, the rule reports unhandled errors where the parameter name ends with &lt;code&gt;Error&lt;/code&gt; (for example, &lt;code&gt;connectionError&lt;/code&gt; or &lt;code&gt;validationError&lt;/code&gt; will match).</source>
          <target state="translated">옵션이 &lt;code&gt;&quot;^.+Error$&quot;&lt;/code&gt; 인 경우 규칙은 매개 변수 이름이 &lt;code&gt;Error&lt;/code&gt; 로 끝나는 처리되지 않은 오류를보고합니다 (예 : &lt;code&gt;connectionError&lt;/code&gt; 또는 &lt;code&gt;validationError&lt;/code&gt; 가 일치 함).</target>
        </trans-unit>
        <trans-unit id="0e771886c3456f585fd28d2511e4e816e918a626" translate="yes" xml:space="preserve">
          <source>If the property name is omitted, accessing any property of the given object is disallowed:</source>
          <target state="translated">속성 이름을 생략하면 지정된 객체의 속성에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="936496d696830abf713f57ff4dffcd113c791136" translate="yes" xml:space="preserve">
          <source>If the rule is defined within a plugin, you have to prefix the rule ID with the plugin name and a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">규칙이 플러그인 내에 정의되어 있으면 규칙 ID 앞에 플러그인 이름과 &lt;code&gt;/&lt;/code&gt; 가 붙어야 합니다.</target>
        </trans-unit>
        <trans-unit id="0d16d54aa0743d9f97198f4deb3a1dda76f546b0" translate="yes" xml:space="preserve">
          <source>If the third argument is a string, it is interpreted as the &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">세 번째 인수가 문자열이면 &lt;code&gt;filename&lt;/code&gt; 으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a70cbab282fd2c607dbd174889be8db4131e9e9" translate="yes" xml:space="preserve">
          <source>If the value is a function, it should wrap under the property name and should have a blank line both before and after the function.</source>
          <target state="translated">값이 함수 인 경우 속성 이름으로 줄 바꿈해야하며 함수 앞뒤에 빈 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9e58d27ec1d6a8f2b83ea052b21d0675aebbb38" translate="yes" xml:space="preserve">
          <source>If the variable is intended to be local to the script, wrap the code with a block or with an immediately-invoked function expression (IIFE).</source>
          <target state="translated">변수가 스크립트에 로컬 인 경우 코드를 블록 또는 즉시 호출 된 함수 표현식 (IIFE)으로 랩하십시오.</target>
        </trans-unit>
        <trans-unit id="73767ddbd81d9dbe02ce6fed5e6251914cb03d71" translate="yes" xml:space="preserve">
          <source>If there are any failing tests, update your code until all tests pass.</source>
          <target state="translated">실패한 테스트가 있으면 모든 테스트가 통과 될 때까지 코드를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="4e39a9fb9ba324c2286fd879d0e7ba5569d5dacc" translate="yes" xml:space="preserve">
          <source>If there are declarations of the same name in class members, the last declaration overwrites other declarations silently. It can cause unexpected behaviors.</source>
          <target state="translated">클래스 멤버에 동일한 이름의 선언이있는 경우 마지막 선언은 다른 선언을 자동으로 덮어 씁니다. 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c7f9187cd1de032df79c7af025cf136787d74ca" translate="yes" xml:space="preserve">
          <source>If there are multiple configuration files in the same directory, ESLint will only use one. The priority order is:</source>
          <target state="translated">동일한 디렉토리에 여러 구성 파일이있는 경우 ESLint는 하나만 사용합니다. 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8647b942abc0b85c8f1bf2d86a64b8b3d027f285" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;.eslintrc&lt;/code&gt; and a &lt;code&gt;package.json&lt;/code&gt; file found in the same directory, &lt;code&gt;.eslintrc&lt;/code&gt; will take a priority and &lt;code&gt;package.json&lt;/code&gt; file will not be used.</source>
          <target state="translated">이 생길 경우 &lt;code&gt;.eslintrc&lt;/code&gt; 하고 &lt;code&gt;package.json&lt;/code&gt; 의 같은 디렉토리에 파일이 &lt;code&gt;.eslintrc&lt;/code&gt; 는 우선 순위를 취할 것이며, &lt;code&gt;package.json&lt;/code&gt; 의 파일이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df824358feaeb45f56e93593d0d239d836cdfe4c" translate="yes" xml:space="preserve">
          <source>If there is not &lt;code&gt;catch&lt;/code&gt; block, &lt;code&gt;finally&lt;/code&gt; block has two current segments. At this time, &lt;code&gt;CodePath.currentSegments.length&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;. One is the normal path, and another is the leaving path (&lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 블록 이 없으면 &lt;code&gt;finally&lt;/code&gt; 블록에는 현재 두 개의 세그먼트가 있습니다. 현재 &lt;code&gt;CodePath.currentSegments.length&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 입니다. 하나는 정상적인 경로이고 다른 하나는 떠나는 경로입니다 ( &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1757e08f8b71310c2a4c59f6dc50ed8f567f5460" translate="yes" xml:space="preserve">
          <source>If this rule is invoked with the command-line &lt;code&gt;--fix&lt;/code&gt; option, object literals that violate the rule are generally modified to comply with it. The modification in each case is to move a property specification to the next line whenever there is part or all of a previous property specification on the same line. For example,</source>
          <target state="translated">이 규칙을 command-line &lt;code&gt;--fix&lt;/code&gt; 옵션으로 호출 하면 규칙을 위반하는 객체 리터럴이 일반적으로 규칙을 준수하도록 수정됩니다. 각 경우에 수정은 동일한 행에 이전 특성 스펙의 일부 또는 전부가있을 때마다 특성 스펙을 다음 행으로 이동하는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="850d3ffd2fa1ce88bcaebffd3ad35b0697ab6bcb" translate="yes" xml:space="preserve">
          <source>If two or more selectors match the same node, their listeners will be called in order of increasing specificity. The specificity of an AST selector is similar to the specificity of a CSS selector:</source>
          <target state="translated">둘 이상의 선택자가 동일한 노드와 일치하면 특이성이 증가하는 순서로 리스너가 호출됩니다. AST 선택기의 특이성은 CSS 선택기의 특이성과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="99630c41d6f205e5e12d2bda184454445047c226" translate="yes" xml:space="preserve">
          <source>If we ask you to make code changes, there's no need to close the pull request and create a new one. Just go back to the branch on your fork and make your changes. Then, when you're ready, you can add your changes into the branch:</source>
          <target state="translated">코드를 변경하도록 요청하면 풀 요청을 닫고 새 요청을 만들 필요가 없습니다. 포크의 지점으로 돌아가서 변경하십시오. 그런 다음 준비가되면 변경 사항을 지점에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0e0d7c63f3124bf206c35deec0d0869a1131e5" translate="yes" xml:space="preserve">
          <source>If you already have some text to lint, then you can use the &lt;code&gt;executeOnText()&lt;/code&gt; method to lint that text. The linter will assume that the text is a file in the current working directory, and so will still obey any &lt;code&gt;.eslintrc&lt;/code&gt; and &lt;code&gt;.eslintignore&lt;/code&gt; files that may be present. Here's an example:</source>
          <target state="translated">린트 할 텍스트가 이미있는 경우 &lt;code&gt;executeOnText()&lt;/code&gt; 메소드를 사용하여 해당 텍스트를 린트 할 수 있습니다 . linter는 텍스트가 현재 작업중인 디렉토리에있는 파일이라고 가정하므로 여전히 존재하는 &lt;code&gt;.eslintrc&lt;/code&gt; 및 &lt;code&gt;.eslintignore&lt;/code&gt; 파일을 준수합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fbb74a49f2eaba94e280fd44611bcca515833b5" translate="yes" xml:space="preserve">
          <source>If you are not concerned about unnecessary calls to &lt;code&gt;bind()&lt;/code&gt;, you can safely disable this rule.</source>
          <target state="translated">&lt;code&gt;bind()&lt;/code&gt; 에 대한 불필요한 호출이 걱정되지 않으면 이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ddab54be7073b7379d9641b3883acaaac2a010" translate="yes" xml:space="preserve">
          <source>If you are targeting ECMAScript 2017 and/or older environments, you can disable this rule, because this ECMAScript feature is only supported in ECMAScript 2018 and/or newer environments.</source>
          <target state="translated">ECMAScript 2017 및 / 또는 이전 환경을 대상으로하는 경우이 ECMAScript 기능은 ECMAScript 2018 및 / 또는 최신 환경에서만 지원되므로이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e889a6e2c510adf6f330ae77fbde14de46dd853" translate="yes" xml:space="preserve">
          <source>If you are throwing an error inside of an asynchronous function for this purpose, then you may want to disable this rule.</source>
          <target state="translated">이 목적으로 비동기 함수 내부에 오류가 발생하면이 규칙을 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0727bfa2099c5dff84bb32defc46aff16b4cd440" translate="yes" xml:space="preserve">
          <source>If you are trying to override one of the native objects.</source>
          <target state="translated">기본 오브젝트 중 하나를 대체하려는 경우.</target>
        </trans-unit>
        <trans-unit id="b2612b9f29d0ec472086dc1da9d121df79cb8ca9" translate="yes" xml:space="preserve">
          <source>If you are unable to push because some references are old, do a forced push instead:</source>
          <target state="translated">일부 참조가 오래되어 푸시 할 수없는 경우 대신 강제 푸시를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0b370077857ae1599795ffaa3d65cdbadb983377" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;process.exit()&lt;/code&gt; only for specifying the exit code, you can set &lt;a href=&quot;https://nodejs.org/api/process.html#process_process_exitcode&quot;&gt;&lt;code&gt;process.exitCode&lt;/code&gt;&lt;/a&gt; (introduced in Node.js 0.11.8) instead.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;process.exit()&lt;/code&gt; 에만 종료 코드를 지정하기위한, 당신은 설정할 수 있습니다 &lt;a href=&quot;https://nodejs.org/api/process.html#process_process_exitcode&quot;&gt; &lt;code&gt;process.exitCode&lt;/code&gt; &lt;/a&gt; 대신 (Node.js를 0.11.8에 도입을).</target>
        </trans-unit>
        <trans-unit id="794c9e1eab3bee427778ec5f6492eee54355c471" translate="yes" xml:space="preserve">
          <source>If you are using a custom implementation of &lt;code&gt;require&lt;/code&gt; and your code will never be used in projects where a standard &lt;code&gt;require&lt;/code&gt; (CommonJS, Node.js, AMD) is expected, you can safely turn this rule off.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 의 사용자 정의 구현을 사용하고 표준 &lt;code&gt;require&lt;/code&gt; (CommonJS, Node.js, AMD)이 예상되는 프로젝트에서 코드를 사용하지 않는 경우이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a095c50390bcd7a4a098485b2044aec9520f886d" translate="yes" xml:space="preserve">
          <source>If you are using an ECMAScript 3 JavaScript engine (such as IE8) and you want to use a keyword (such as &lt;code&gt;if&lt;/code&gt;) as a property name. This restriction was removed in ECMAScript 5.</source>
          <target state="translated">ECMAScript 3 JavaScript 엔진 (예 : IE8)을 사용하고 있고 키워드 (예 : &lt;code&gt;if&lt;/code&gt; )를 특성 이름 으로 사용하려는 경우 . 이 제한은 ECMAScript 5에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="e79b6d39ed61231d71b33b4d264895e5f11a3a24" translate="yes" xml:space="preserve">
          <source>If you are using one configuration file and want ESLint to ignore any &lt;code&gt;.eslintrc.*&lt;/code&gt; files, make sure to use &lt;code&gt;--no-eslintrc&lt;/code&gt; along with the &lt;code&gt;-c&lt;/code&gt; flag.</source>
          <target state="translated">하나의 구성 파일을 사용하고 있고 ESLint가 &lt;code&gt;.eslintrc.*&lt;/code&gt; 파일 을 무시 하도록하려면 &lt;code&gt;-c&lt;/code&gt; 플래그 와 함께 &lt;code&gt;--no-eslintrc&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dc0228170d5897f66f6c2892c04523f20899b905" translate="yes" xml:space="preserve">
          <source>If you are working with ES6 modules:</source>
          <target state="translated">ES6 모듈로 작업하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7fd01c75198649e058b17377a36d78a054ffe274" translate="yes" xml:space="preserve">
          <source>If you aren't concerned about having different line comment styles, then you can turn off this rule.</source>
          <target state="translated">다른 행 주석 스타일이 걱정되지 않으면이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93d0dcfda167424e32f450a26f03cf14dedb911" translate="yes" xml:space="preserve">
          <source>If you aren't concerned about having different line endings within your code, then you can safely turn this rule off.</source>
          <target state="translated">코드 내에서 줄 끝이 다른 것에 대해 걱정하지 않으면이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca485d61ff911bfd152fcdab49dac4ba14922646" translate="yes" xml:space="preserve">
          <source>If you aren't concerned about misinterpreting floating decimal point values, then you can safely turn this rule off.</source>
          <target state="translated">부동 소수점 값을 잘못 해석 할 염려가 없다면이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90285ec365861710d4fa6c81c812503ce64d8cd4" translate="yes" xml:space="preserve">
          <source>If you aren't going to use the default parser of ESLint, this section explains about using custom parsers.</source>
          <target state="translated">ESLint의 기본 구문 분석기를 사용하지 않을 경우이 섹션에서는 사용자 정의 구문 분석기 사용에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f36c167b80c0da8a28ee63a69b56b94547879c0c" translate="yes" xml:space="preserve">
          <source>If you aren't using JSDoc, then you can safely turn this rule off.</source>
          <target state="translated">JSDoc을 사용하지 않는 경우이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3b62d423b673891d6d79bb7f1574b983499ef7" translate="yes" xml:space="preserve">
          <source>If you can't determine an appropriate complexity limit for your code, then it's best to disable this rule.</source>
          <target state="translated">코드에 대한 적절한 복잡성 한계를 결정할 수 없으면이 규칙을 비활성화하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="48d343ff8f2275b0ea325fc0a64c31bd1fb7cd98" translate="yes" xml:space="preserve">
          <source>If you configure ESLint to automatically enable new rules when you upgrade, ESLint can report new problems when there are no changes to source code, therefore any newer minor version of ESLint can behave as if it has breaking changes.</source>
          <target state="translated">업그레이드 할 때 새 규칙을 자동으로 활성화하도록 ESLint를 구성하면 소스 코드에 변경 사항이 없을 때 ESLint가 새로운 문제를보고 할 수 있으므로 ESLint의 최신 마이너 버전은 변경 사항이 적용되는 것처럼 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="404fcfa2ef5c1f362f2be3f12cef0103e708a9b8" translate="yes" xml:space="preserve">
          <source>If you decide that you wish to use whitespace other than tabs and spaces outside of strings in your application.</source>
          <target state="translated">응용 프로그램에서 탭 이외의 공백과 문자열 외부의 공백을 사용하기로 결정한 경우.</target>
        </trans-unit>
        <trans-unit id="e2f36f9a48b18ab417c90448e3760f46ecb246c5" translate="yes" xml:space="preserve">
          <source>If you depend on fall through behavior and want access to bindings introduced in the case block.</source>
          <target state="translated">추락 동작에 의존하고 사례 블록에 도입 된 바인딩에 액세스하려는 경우.</target>
        </trans-unit>
        <trans-unit id="7a38e6f565ac0f063fab2adb4a1dcf52e65781dc" translate="yes" xml:space="preserve">
          <source>If you do not care about extra blank lines, turn this off.</source>
          <target state="translated">빈 줄이 더 이상 신경 쓰지 않으면 끄십시오.</target>
        </trans-unit>
        <trans-unit id="7bfcf2e27f8485a989b5dfd1cc941c1c7279f4bf" translate="yes" xml:space="preserve">
          <source>If you do not need consistency in your string styles, you can safely disable this rule.</source>
          <target state="translated">문자열 스타일에서 일관성이 필요하지 않은 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="392f8a1f4fba093842c4607835e8cfd25a31c650" translate="yes" xml:space="preserve">
          <source>If you do not need to support IE 8 and earlier, you should turn this rule off.</source>
          <target state="translated">IE 8 및 이전 버전을 지원할 필요가 없으면이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d547b86ad688b98a0c6659d848158e9b5dabb04" translate="yes" xml:space="preserve">
          <source>If you do not require JSDoc for your functions, then you can leave this rule off.</source>
          <target state="translated">함수에 JSDoc이 필요하지 않은 경우이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9d550da8d530ae5bf38a38f34d4a343d1cbae42" translate="yes" xml:space="preserve">
          <source>If you do not want ignored file warnings output to the console, you can omit the third argument or pass &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">무시 된 파일 경고를 콘솔에 출력하지 않으려면 세 번째 인수를 생략하거나 &lt;code&gt;false&lt;/code&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2628614f8cc596f13fac5b621f18df2aeb5bc2ff" translate="yes" xml:space="preserve">
          <source>If you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.</source>
          <target state="translated">특정 방식으로 세미콜론 사용 (또는 생략)을 시행하지 않으려는 경우이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0473345a5bb57f1c01e60cdf29fe464c00a72c" translate="yes" xml:space="preserve">
          <source>If you do not wish to enforce consistency on keyword spacing.</source>
          <target state="translated">키워드 간격에 일관성을 유지하지 않으려는 경우</target>
        </trans-unit>
        <trans-unit id="ec438abebebab23efa3997bca0496ca41fc86dd6" translate="yes" xml:space="preserve">
          <source>If you don't care about disallowing redundant return statements, you can turn off this rule.</source>
          <target state="translated">중복 리턴 문을 허용하지 않는 경우이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377445f5eeba500665b9afe31fabf0a6ca7e60ea" translate="yes" xml:space="preserve">
          <source>If you don't care if property names are consistently wrapped in quotes or not, and you don't target legacy ES3 environments, turn this rule off.</source>
          <target state="translated">속성 이름이 일관되게 따옴표로 묶여 있는지 여부를 신경 쓰지 않고 레거시 ES3 환경을 대상으로하지 않으면이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="fbb1b5f010231afcab8c832ef9f8d843a9047947" translate="yes" xml:space="preserve">
          <source>If you don't have any object/property combinations to restrict, you should not use this rule.</source>
          <target state="translated">제한 할 객체 / 속성 조합이없는 경우이 규칙을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c5f3d9d25eecc50921d17e2d250b565540102e1d" translate="yes" xml:space="preserve">
          <source>If you don't use Node.js, or you still need to support versions of Node.js that lack methods like &lt;code&gt;Buffer.from&lt;/code&gt;, then you should not enable this rule.</source>
          <target state="translated">Node.js를 사용하지 않거나 &lt;code&gt;Buffer.from&lt;/code&gt; 과 같은 메소드가없는 Node.js 버전을 계속 지원해야하는 경우이 규칙을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="28fe184ed022eb7ed86a6fdb953113737c1230b4" translate="yes" xml:space="preserve">
          <source>If you don't use async or generator functions, you don't need to enable this rule.</source>
          <target state="translated">비동기 또는 생성기 기능을 사용하지 않으면이 규칙을 활성화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="8e8976ae986f3df4acec0327270b71cfedc18f22" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about empty functions, then it's safe to disable this rule.</source>
          <target state="translated">빈 기능에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="035b02b7f62b6cf56e490c776d78cfc18884a2f6" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about invalid/missing &lt;code&gt;super()&lt;/code&gt; callings in constructors, you can safely disable this rule.</source>
          <target state="translated">생성자에서 유효하지 않거나 누락 된 &lt;code&gt;super()&lt;/code&gt; 호출에 대한 알림을받지 않으려면 이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cdcf809d4b2ba636118edcb3c72c778c76b8ef9" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about mixed operators, then it's safe to disable this rule.</source>
          <target state="translated">혼합 연산자에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b34060b6575a25206fbe68c5a7727598b25882e3" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about modifying imported bindings, you can disable this rule.</source>
          <target state="translated">가져온 바인딩 수정에 대한 알림을받지 않으려면이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05cd0829efd0f529155675a47415f71b807b23e6" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about modifying variables of class declarations, you can safely disable this rule.</source>
          <target state="translated">클래스 선언 변수 수정에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b676a87bc4231e95cfd51afd88cbeab37557db5d" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about modifying variables that are declared using &lt;code&gt;const&lt;/code&gt; keyword, you can safely disable this rule.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드를 사용하여 선언 된 변수 수정에 대한 알림을받지 않으려면 이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57556711aa41b9d323be8427c2ecdd4bff4b57ef" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about shorter notations for the type conversion, you can safely disable this rule.</source>
          <target state="translated">유형 변환에 대한 더 짧은 표기법에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0dc600bd88206c2efee7216202f42acce935e8" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about spacing style inside of blocks, you can safely disable this rule.</source>
          <target state="translated">블록 내부의 간격 스타일에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b5bb845c2f283fd9522751ebbc0160e430a28d" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary &lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.apply()&lt;/code&gt;, you can safely disable this rule.</source>
          <target state="translated">불필요한 대한 알림을받지 않으려면 &lt;code&gt;.call()&lt;/code&gt; 와 &lt;code&gt;.apply()&lt;/code&gt; 안전하게이 규칙을 사용하지 않도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f79445e9a598b886c416fdf23687b7ac40682" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary catch clauses, you can safely disable this rule.</source>
          <target state="translated">불필요한 catch 절에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1af85e373e8151e1abe933aa39f83e1d3e16b9c" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary computed property keys, you can safely disable this rule.</source>
          <target state="translated">불필요한 계산 된 속성 키에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e855a5d5cb2ae2ff25109bb9e22035ab28a628e6" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary constructors, you can safely disable this rule.</source>
          <target state="translated">불필요한 생성자에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938ce66a3470c3b9f0b562fcf30a08bd7f6898be" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary escapes, you can safely disable this rule.</source>
          <target state="translated">불필요한 이스케이프에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b06ab9aed5b29d9c1a958df26fdcb70958c47f8" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unnecessary string concatenation, you can safely disable this rule.</source>
          <target state="translated">불필요한 문자열 연결에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d677c6d2346e3a005d4cdd590600c4532148540" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unused labels, then it's safe to disable this rule.</source>
          <target state="translated">사용하지 않는 레이블에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="05e4276980e348df485708112eedf0b691b13051" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about unused variables or function arguments, you can safely turn this rule off.</source>
          <target state="translated">사용하지 않는 변수 또는 함수 인수에 대한 알림을받지 않으려면이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58889c4cfc98cc39318dd6b4c202708b2134c213" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about usage of &lt;code&gt;this&lt;/code&gt; keyword outside of classes or class-like objects, you can safely disable this rule.</source>
          <target state="translated">클래스 또는 클래스 유사 객체 외부 &lt;code&gt;this&lt;/code&gt; 키워드의 사용에 대한 알림을받지 않으려면 이 규칙을 안전하게 사용 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f8ec01867de0ac8cf9a52dab4bc974350b262a" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about usage of labels, then it's safe to disable this rule.</source>
          <target state="translated">라벨 사용에 대한 알림을받지 않으려면이 규칙을 사용 중지하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="c3c8da72d7ad33b084fed89dc9957cbb66fc2e56" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about usage of spacing between tag functions and their template literals, then it's safe to disable this rule.</source>
          <target state="translated">태그 함수와 템플릿 리터럴 사이의 간격 사용에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="69856ad30b7df75041b8701dce21332166566dbf" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about usage of spacing inside of template strings, then it's safe to disable this rule.</source>
          <target state="translated">템플릿 문자열 내부의 간격 사용에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="3a49a93c91c935fd9301abeba634853b470cfac9" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about using &lt;code&gt;this&lt;/code&gt;/&lt;code&gt;super&lt;/code&gt; before &lt;code&gt;super()&lt;/code&gt; in constructors, you can safely disable this rule.</source>
          <target state="translated">생성자에서 &lt;code&gt;super()&lt;/code&gt; 전에 &lt;code&gt;this&lt;/code&gt; / &lt;code&gt;super&lt;/code&gt; 사용에 대한 알림을받지 않으려면 이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90eb0f399adda799268d0bf35448574d276ef357" translate="yes" xml:space="preserve">
          <source>If you don't want to be notified about variables that are never reassigned after initial assignment, you can safely disable this rule.</source>
          <target state="translated">초기 할당 후 다시 할당되지 않은 변수에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ee117c17516d2c719e0db6ab55eccac5d6aa9c" translate="yes" xml:space="preserve">
          <source>If you don't want to check and disallow multiple spaces, then you should turn this rule off.</source>
          <target state="translated">여러 공백을 확인하거나 허용하지 않으려면이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d0224d3ec9408d92b6667d3c8ffeab802c5eee2" translate="yes" xml:space="preserve">
          <source>If you don't want to convert your JSCS configuration directly into an ESLint configuration, then you can use ESLint's built-in wizard to get you started. Just run:</source>
          <target state="translated">JSCS 구성을 ESLint 구성으로 직접 변환하지 않으려면 ESLint의 내장 마법사를 사용하여 시작할 수 있습니다. 그냥 실행 :</target>
        </trans-unit>
        <trans-unit id="dd03ca6e3947a66ea53baf8ac86171507a2394fc" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce a &lt;code&gt;default&lt;/code&gt; case for &lt;code&gt;switch&lt;/code&gt; statements, you can safely disable this rule.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 &lt;code&gt;default&lt;/code&gt; 사례 를 적용하지 않으려면 이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aababb9275bb8cf111ca9e21208a1cb5e64bd8e0" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce a particular brace style, don't enable this rule.</source>
          <target state="translated">특정 괄호 스타일을 적용하지 않으려면이 규칙을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4f9124dfb72433852245c700fe867a59eddb7e22" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce a particular style for multiline comments, you can disable the rule.</source>
          <target state="translated">여러 줄 주석에 특정 스타일을 적용하지 않으려면 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3d2c7d722dea39207f449727021bfd08dd6671" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce a style for using equality operators, then it's safe to disable this rule.</source>
          <target state="translated">항등 연산자를 사용하기 위해 스타일을 적용하지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="881783518287437ee5c4be83087dc074c16404b7" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce any particular naming convention for all identifiers, or your naming convention is too complex to be enforced by configuring this rule, then you should not enable this rule.</source>
          <target state="translated">모든 식별자에 대해 특정 명명 규칙을 적용하지 않거나이 규칙을 구성하여 명명 규칙을 적용하기에 너무 복잡하면이 규칙을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="03c547bbe71dd30e4b389d995a733cefd95fe62d" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce consistency on keyword spacing, then it's safe to disable this rule.</source>
          <target state="translated">키워드 간격에 일관성을 유지하지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="ba05107ad0aa4784160535c5a83cf1838bb66020" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce consistent line breaks inside braces, then it's safe to disable this rule.</source>
          <target state="translated">중괄호 안에 일관된 줄 바꿈을 적용하지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="fab6d15b9e92cdd55e80d0de68464eedc16c6a43" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce either presence or omission of the &lt;code&gt;10&lt;/code&gt; radix value you can turn this rule off.</source>
          <target state="translated">&lt;code&gt;10&lt;/code&gt; 기수 값 의 존재 또는 누락을 강요하지 않으려면 이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e804e65f30ad2295d3ca3750dd67b83793cbfc1a" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce empty lines between class members, you can disable this rule.</source>
          <target state="translated">반원들 사이에 빈 줄을 적용하지 않으려면이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d6cebc65b3f88d81c83eeb9c12b94536bc421c" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce line breaks after opening and before closing array brackets, don't enable this rule.</source>
          <target state="translated">배열 괄호를 열거 나 닫기 전에 줄 바꿈을 적용하지 않으려면이 규칙을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="28fb13c709b5f77912ad0d548d670040e0b12839" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce line breaks between arguments, don't enable this rule.</source>
          <target state="translated">인수 사이에 줄 바꿈을 적용하지 않으려면이 규칙을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4533fe95406ecc1ea725791c70efca418fe966b8" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce linebreaks between array elements, don't enable this rule.</source>
          <target state="translated">배열 요소 사이에 줄 바꿈을 적용하지 않으려면이 규칙을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bd6ed68cf488b02540f00ff06a41e1354a2bf35b" translate="yes" xml:space="preserve">
          <source>If you don't want to enforce that each &lt;code&gt;case&lt;/code&gt; statement should end with a &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, or comment, then you can safely turn this rule off.</source>
          <target state="translated">각 &lt;code&gt;case&lt;/code&gt; 문이 &lt;code&gt;throw&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; 또는 comment 로 끝나 도록 강요하지 않으려면 이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c4ada68371f02ae755b6c46bc3ff8872f96d881" translate="yes" xml:space="preserve">
          <source>If you don't want to notified about references inside of loop conditions, then it's safe to disable this rule.</source>
          <target state="translated">루프 조건 내부의 참조에 대한 알림을받지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="55804cfbbeb711790995c168e8efbacb6de0c91a" translate="yes" xml:space="preserve">
          <source>If you don't want to notify about properties' order, then it's safe to disable this rule.</source>
          <target state="translated">속성 순서에 대해 알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0c9a9ac4de306fc8ecda601da045432c3691af97" translate="yes" xml:space="preserve">
          <source>If you don't want to notify about self assignments, then it's safe to disable this rule.</source>
          <target state="translated">자체 할당에 대해 알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="44d06f76b9a9450bdb8b56c5dfe1046944fc23a9" translate="yes" xml:space="preserve">
          <source>If you don't want to notify generator functions that have no &lt;code&gt;yield&lt;/code&gt; expression, then it's safe to disable this rule.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 표현식 이없는 생성기 함수에 알리지 않으려면 이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="7cbf12fa597c277297c8058f6568bf93b2611aa3" translate="yes" xml:space="preserve">
          <source>If you don't want to notify regular expressions with no &lt;code&gt;u&lt;/code&gt; flag, then it's safe to disable this rule.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 플래그 없이 정규식에 알리지 않으려면 이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="debec24cd2ab68499573ae20752142917a1aaa28" translate="yes" xml:space="preserve">
          <source>If you don't want to notify spacing around colons of switch statements, then it's safe to disable this rule.</source>
          <target state="translated">스위치 명령문의 콜론 주위에 간격을 알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="48c5ed2023dc8f69088270df9de52f3c95dffc50" translate="yes" xml:space="preserve">
          <source>If you don't want to notify the location of semicolons, then it's safe to disable this rule.</source>
          <target state="translated">세미콜론의 위치를 ​​알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b1086b581d410ccfff2d69ce1d4a0f1ce3883ef4" translate="yes" xml:space="preserve">
          <source>If you don't want to notify unsafe logical negations, then it's safe to disable this rule.</source>
          <target state="translated">안전하지 않은 논리적 부정을 알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="092de94e02976f91598695c0b62fe884df6462d5" translate="yes" xml:space="preserve">
          <source>If you don't want to notify warnings about linebreaks, then it's safe to disable this rule.</source>
          <target state="translated">줄 바꿈에 대한 경고를 알리지 않으려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f7d7ceec15dd410c793e8ea6857bb2384373256d" translate="yes" xml:space="preserve">
          <source>If you don't want to restrict your code from using any JavaScript features or syntax, you should not use this rule.</source>
          <target state="translated">코드가 JavaScript 기능이나 구문을 사용하지 못하게하려면이 규칙을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="727de670c07aa6ddaad290b7f9c4933857178381" translate="yes" xml:space="preserve">
          <source>If you don't want to warn about usage of &lt;code&gt;return&lt;/code&gt; statement in callbacks of array's methods, then it's safe to disable this rule.</source>
          <target state="translated">배열 메소드의 콜백에서 &lt;code&gt;return&lt;/code&gt; 문 사용에 대해 경고하지 않으려면 이 규칙을 비활성화하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cd5b557f539ab445a2f764b39d2f629358eb8508" translate="yes" xml:space="preserve">
          <source>If you find the custom formatter pattern doesn't provide enough options for the way you'd like to format ESLint results, the best option is to use ESLint's built-in &lt;a href=&quot;../user-guide/formatters/index&quot;&gt;JSON formatter&lt;/a&gt; and pipe the output to a second program. For example:</source>
          <target state="translated">사용자 정의 포맷터 패턴이 ESLint 결과의 형식을 지정하는 방식에 충분한 옵션을 제공하지 않는 경우 가장 좋은 옵션은 ESLint의 내장 &lt;a href=&quot;../user-guide/formatters/index&quot;&gt;JSON 포맷터&lt;/a&gt; 를 사용 하여 출력을 두 번째 프로그램으로 파이프하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="118095cb4d7d2586daf3a9c4aeedb6269df5ca60" translate="yes" xml:space="preserve">
          <source>If you find you can't finish the work, then simply add a comment letting people know, for example:</source>
          <target state="translated">작업을 완료 할 수없는 경우 사람들에게 알리는 설명을 추가하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="e102d884d27cd6a22fd9e584af0049437ee110e4" translate="yes" xml:space="preserve">
          <source>If you have a custom rule, you should make sure it handles empty files appropriately. (In most cases, no changes should be necessary.)</source>
          <target state="translated">사용자 지정 규칙이 있으면 빈 파일을 적절하게 처리해야합니다. (대부분의 경우 변경이 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="b921db934ffd761c043389137ead53e58a1b0bf5" translate="yes" xml:space="preserve">
          <source>If you have a large code base that was not developed with a policy to not use such warning terms, you might get hundreds of warnings / errors which might be counter-productive if you can't fix all of them (e.g. if you don't get the time to do it) as you might overlook other warnings / errors or get used to many of them and don't pay attention on it anymore.</source>
          <target state="translated">이러한 경고 용어를 사용하지 않는 정책으로 개발되지 않은 큰 코드 기반이있는 경우 수백 가지 경고 / 오류가 발생할 수 있습니다.이 오류는 모두 수정할 수없는 경우에 비생산적 일 수 있습니다 (예 : 다른 경고 / 오류를 간과하거나 그 중 많은 것에 익숙해 져 더 이상주의를 기울이지 않기 때문에 시간을 내십시오.</target>
        </trans-unit>
        <trans-unit id="73368d2dd1104f63622c3ee28dbef44e3e0176d9" translate="yes" xml:space="preserve">
          <source>If you have a module that must be initialized with information that comes from the file-system or if a module is only used in very rare situations and will cause significant overhead to load it may make sense to disable the rule. If you need to &lt;code&gt;require()&lt;/code&gt; an optional dependency inside of a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, you can disable this rule for just that dependency using the &lt;code&gt;// eslint-disable-line global-require&lt;/code&gt; comment.</source>
          <target state="translated">파일 시스템에서 제공되는 정보로 초기화해야하는 모듈이 있거나 모듈이 매우 드문 상황에서만 사용되며로드가 많이 발생하는 경우 규칙을 사용하지 않는 것이 좋습니다. &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 내에서 선택적 종속성 을 &lt;code&gt;require()&lt;/code&gt; 해야하는 경우 &lt;code&gt;// eslint-disable-line global-require&lt;/code&gt; 주석을 사용하여 해당 종속성에 대해이 규칙을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78b63fe9c75180f7eae12563749a18484f524c7f" translate="yes" xml:space="preserve">
          <source>If you have a plugin with rules and you are using RuleTester, then you also need to update the options you pass for rules that use &lt;code&gt;ecmaFeatures&lt;/code&gt;. For example:</source>
          <target state="translated">규칙이있는 플러그인이 있고 RuleTester를 사용 &lt;code&gt;ecmaFeatures&lt;/code&gt; 경우 ecmaFeatures 를 사용하는 규칙에 대해 전달하는 옵션도 업데이트해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1adc550e08a101ef27b397d37ebb50513d8babdd" translate="yes" xml:space="preserve">
          <source>If you have another convention for property spacing that might not be consistent with the available options, or if you want to permit multiple styles concurrently you can safely disable this rule.</source>
          <target state="translated">사용 가능한 옵션과 일치하지 않을 수도있는 속성 간격에 대한 다른 규칙이 있거나 여러 스타일을 동시에 허용하려는 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a15b4bf698befd94c9c28f3b561bee7f0f9d2d1a" translate="yes" xml:space="preserve">
          <source>If you have conflicting rules or when you are fine with chained calls on one line, you can safely turn this rule off.</source>
          <target state="translated">충돌하는 규칙이 있거나 한 회선의 연결 통화에 문제가없는 경우이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf354fdcd95932555803b6fe121c6b5650ca543" translate="yes" xml:space="preserve">
          <source>If you have conventions that don't require an uppercase letter for constructors, or don't require capitalized functions be only used as constructors, turn this rule off.</source>
          <target state="translated">생성자에 대문자를 요구하지 않는 규칙이 있거나 대문자로 된 함수를 생성자로만 사용할 필요가없는 경우이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="439a3304ad5df05ab1c795bee9cad7c9396aac67" translate="yes" xml:space="preserve">
          <source>If you have established a standard where having tabs is fine, then you can disable this rule.</source>
          <target state="translated">탭이있는 표준을 설정 한 경우이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="188988ea697a9b957d25b534719239d8a1857409" translate="yes" xml:space="preserve">
          <source>If you have established coding standards using a different naming convention (separating words with underscores), turn this rule off.</source>
          <target state="translated">다른 이름 지정 규칙 (밑줄로 단어를 구분)을 사용하여 코딩 표준을 설정 한 경우이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="526f59648be01853bcfaff830a60f08fcb2ba9a0" translate="yes" xml:space="preserve">
          <source>If you have multiple &lt;code&gt;.jscsrc.json&lt;/code&gt; files, you can pass them all and Polyjuice will combine them into one &lt;code&gt;.eslintrc.json&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;.jscsrc.json&lt;/code&gt; 파일 이 여러 개인 경우 모든 파일을 전달할 수 있으며 Polyjuice는이 파일 을 하나의 &lt;code&gt;.eslintrc.json&lt;/code&gt; 파일 로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="ac994ca847831c1c302f8b42ca3c3efee45e3720" translate="yes" xml:space="preserve">
          <source>If you have no strict conventions about when to use block statements and when not to, you can safely disable this rule.</source>
          <target state="translated">block 문을 사용하는시기와 사용하지 않는시기에 대한 엄격한 규칙이없는 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f93035ea1b2e22270015dfd6ae4ecd60d85f61" translate="yes" xml:space="preserve">
          <source>If you intend to create a global &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; variable or a global &lt;code&gt;class&lt;/code&gt; declaration, to be used from other scripts, be aware that there are certain differences when compared to the traditional methods, which are &lt;code&gt;var&lt;/code&gt; declarations and assigning to a property of the global &lt;code&gt;window&lt;/code&gt; object:</source>
          <target state="translated">당신이 글로벌 만들려는 경우 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 변수 또는 전역 &lt;code&gt;class&lt;/code&gt; 선언을, 다른 스크립트에서 사용할 수,있는 기존의 방법과 비교했을 때 어떤 차이가 있다는 것을 알고 &lt;code&gt;var&lt;/code&gt; 에 선언 및 세계의 속성에 할당 &lt;code&gt;window&lt;/code&gt; 개체 :</target>
        </trans-unit>
        <trans-unit id="cc1252817e8c5df5df09e177c1f59eb843a08370" translate="yes" xml:space="preserve">
          <source>If you intentionally use &lt;code&gt;with&lt;/code&gt; statements then you can disable this rule.</source>
          <target state="translated">의도적으로 &lt;code&gt;with&lt;/code&gt; 문을 사용하는 경우이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a54e590a75faa65b0ed8e0ad0659925f1afaec" translate="yes" xml:space="preserve">
          <source>If you intentionally use empty block statements then you can disable this rule.</source>
          <target state="translated">의도적으로 빈 블록 명령문을 사용하는 경우이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b9a44ddb5f057d0633a491bcff3b454a13ca25" translate="yes" xml:space="preserve">
          <source>If you intentionally use extra semicolons then you can disable this rule.</source>
          <target state="translated">의도적으로 추가 세미콜론을 사용하는 경우이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed58b7a43c9e311ce8e3580896560e95ee0a6c3d" translate="yes" xml:space="preserve">
          <source>If you intentionally use the &lt;code&gt;void&lt;/code&gt; operator then you can disable this rule.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 연산자를 의도적으로 사용하는 경우이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29ecbabab88c404ca5af384d017cf9ea2b3f4919" translate="yes" xml:space="preserve">
          <source>If you maintain a plugin and provide installation instructions, you should ensure that the installation instructions are up to date with the &lt;a href=&quot;#package-loading-simplification&quot;&gt;user-facing changes to how plugins are loaded&lt;/a&gt;. In particular, if your plugin was generated with the &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt;&lt;code&gt;generator-eslint&lt;/code&gt;&lt;/a&gt; package, it likely contains outdated instructions for how to use the plugin with global ESLint installations.</source>
          <target state="translated">플러그인을 유지 보수하고 설치 지시 &lt;a href=&quot;#package-loading-simplification&quot;&gt;사항을 제공하는 경우, 플러그인이로드되는 방식을 사용자가 변경&lt;/a&gt; 하여 설치 지시 사항이 최신인지 확인해야합니다 . 특히 플러그인이 &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt; &lt;code&gt;generator-eslint&lt;/code&gt; &lt;/a&gt; 패키지 로 생성 된 경우 글로벌 ESLint 설치에서 플러그인을 사용하는 방법에 대한 오래된 지침이 포함되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="382050530e90f989fc4392b588fcc385aace40bb" translate="yes" xml:space="preserve">
          <source>If you make a &lt;code&gt;fix()&lt;/code&gt; function which returns multiple &lt;code&gt;fixing&lt;/code&gt; objects, those &lt;code&gt;fixing&lt;/code&gt; objects must not be overlapped.</source>
          <target state="translated">여러 &lt;code&gt;fixing&lt;/code&gt; 객체 를 반환 하는 &lt;code&gt;fix()&lt;/code&gt; 함수 를 만드는 경우 해당 &lt;code&gt;fixing&lt;/code&gt; 객체가 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="30d314fb125cae0253768be98db5440a6591c835" translate="yes" xml:space="preserve">
          <source>If you need to access comments for a specific node you can use &lt;code&gt;sourceCode.getComments(node)&lt;/code&gt;:</source>
          <target state="translated">특정 노드에 대한 주석에 액세스해야하는 경우 &lt;code&gt;sourceCode.getComments(node)&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bded78921bf41e6e0100847f8e36439af0a827a" translate="yes" xml:space="preserve">
          <source>If you need to capture nested context, &lt;code&gt;consistent-this&lt;/code&gt; is going to be problematic. Code of that nature is usually difficult to read and maintain and you should consider refactoring it.</source>
          <target state="translated">중첩 된 컨텍스트를 캡처 해야하는 경우 &lt;code&gt;consistent-this&lt;/code&gt; 문제가됩니다. 그러한 성격의 코드는 일반적으로 읽고 유지하기가 어렵 기 때문에 리팩토링을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="382e78ca57fb3d4eb43f4468524bc11d77683bdd" translate="yes" xml:space="preserve">
          <source>If you need to make multiple configs that can extend from each other and live in different directories, you can create a single shareable config that handles this scenario.</source>
          <target state="translated">서로 확장되어 다른 디렉토리에있을 수있는 여러 구성을 만들어야하는 경우이 시나리오를 처리하는 공유 가능한 단일 구성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5812603008a46c3486b5e671b8f0edc57df6edd6" translate="yes" xml:space="preserve">
          <source>If you need to use control character pattern matching, then you should turn this rule off.</source>
          <target state="translated">제어 문자 패턴 일치를 사용해야하는 경우이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="02d1a6666bd32062a9544a0211172b4e0690165a" translate="yes" xml:space="preserve">
          <source>If you need to use labeled statements everywhere, then you can safely disable this rule.</source>
          <target state="translated">어디에서나 레이블 된 명령문을 사용해야하는 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660081d33ba72f5ae35d8f8429fbf0433e7b68be" translate="yes" xml:space="preserve">
          <source>If you prefer to use &lt;code&gt;process.env&lt;/code&gt; throughout your project to retrieve values from environment variables, then you can safely disable this rule.</source>
          <target state="translated">프로젝트 전체에서 &lt;code&gt;process.env&lt;/code&gt; 를 사용 하여 환경 변수에서 값을 검색하려는 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0340890e7d3e636e8f793bfb600313cb993e9d" translate="yes" xml:space="preserve">
          <source>If you simply want to create a local copy of the source to play with, you can clone the main repository using this command:</source>
          <target state="translated">재생할 소스의 로컬 사본을 작성하려는 경우 다음 명령을 사용하여 기본 저장소를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b54b0379c44ec2d18f671613df2ac7b3fa322827" translate="yes" xml:space="preserve">
          <source>If you think you've found a bug in ESLint, please &lt;a href=&quot;https://github.com/eslint/eslint/issues/new&quot;&gt;create a new issue&lt;/a&gt; or a &lt;a href=&quot;pull-requests&quot;&gt;pull request&lt;/a&gt; on GitHub.</source>
          <target state="translated">ESLint에서 버그를 발견했다고 생각되면 GitHub &lt;a href=&quot;https://github.com/eslint/eslint/issues/new&quot;&gt;에서 새 문제&lt;/a&gt; 또는 &lt;a href=&quot;pull-requests&quot;&gt;풀 요청&lt;/a&gt; 을 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="38f228e5fd212b5545994a73a849c889d4d81493" translate="yes" xml:space="preserve">
          <source>If you use a boilerplate generator that relies on this behavior (e.g. to generate a script that runs &lt;code&gt;eslint tests/&lt;/code&gt; in a new project before any test files are actually present), you can work around this issue by adding a dummy file that matches the given pattern (e.g. an empty &lt;code&gt;tests/index.js&lt;/code&gt; file).</source>
          <target state="translated">이 동작에 의존하는 상용구 생성기를 사용하는 경우 (예 : 테스트 파일이 실제로 존재하기 전에 새 프로젝트에서 &lt;code&gt;eslint tests/&lt;/code&gt; 를 실행하는 스크립트 생성 ) 지정된 파일과 일치하는 더미 파일을 추가하여이 문제를 해결할 수 있습니다. 패턴 (예 : 빈 &lt;code&gt;tests/index.js&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="7d3465c7ac30a9cf24afa4cba7d6d7a58b08270c" translate="yes" xml:space="preserve">
          <source>If you use a config file located outside of a local project (with the &lt;code&gt;--config&lt;/code&gt; flag), consider installing the plugins as dependencies of that config file, and setting the &lt;a href=&quot;command-line-interface#--resolve-plugins-relative-to&quot;&gt;&lt;code&gt;--resolve-plugins-relative-to&lt;/code&gt;&lt;/a&gt; flag to the location of the config file.</source>
          <target state="translated">&lt;code&gt;--config&lt;/code&gt; 플래그 와 함께 로컬 프로젝트 외부에있는 구성 파일을 사용하는 경우 해당 구성 파일의 종속성으로 플러그인을 설치하고 &lt;a href=&quot;command-line-interface#--resolve-plugins-relative-to&quot;&gt; &lt;code&gt;--resolve-plugins-relative-to&lt;/code&gt; &lt;/a&gt; 플래그를 구성 파일.</target>
        </trans-unit>
        <trans-unit id="ef38f0f26aedebc08c900f2170004ffdde1f5fb9" translate="yes" xml:space="preserve">
          <source>If you use a pattern such as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; where the &lt;code&gt;require&lt;/code&gt;d modules are not loaded in variable declarations, this rule will obviously do nothing for you.</source>
          <target state="translated">이 같은 패턴을 사용하는 경우 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; (가) 어디에 &lt;code&gt;require&lt;/code&gt; D 모듈은 변수 선언에로드되지 않습니다,이 규칙은 분명히 당신을 위해 아무것도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e5b9656ad64e63d8b3fd891ddf70408bf2754ad" translate="yes" xml:space="preserve">
          <source>If you use some UTF-16 or UTF-32 files and you want to allow a file to optionally begin with a Unicode BOM, you should turn this rule off.</source>
          <target state="translated">일부 UTF-16 또는 UTF-32 파일을 사용하고 파일이 선택적으로 유니 코드 BOM으로 시작하도록하려면이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="0326d8c204460011dd4d50e18688b63f04393c0a" translate="yes" xml:space="preserve">
          <source>If you want to allow &lt;code&gt;setTimeout()&lt;/code&gt; and &lt;code&gt;setInterval()&lt;/code&gt; with string arguments, then you can safely disable this rule.</source>
          <target state="translated">문자열 인수와 함께 &lt;code&gt;setTimeout()&lt;/code&gt; 및 &lt;code&gt;setInterval()&lt;/code&gt; 을 허용하려는 경우이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc7c63ca6c90a4fc825f096a878d02d0077a0af" translate="yes" xml:space="preserve">
          <source>If you want to allow additional constructor flags for any reason, you can specify them using an &lt;code&gt;allowConstructorFlags&lt;/code&gt; option in &lt;code&gt;.eslintrc&lt;/code&gt;. These flags will then be ignored by the rule regardless of the &lt;code&gt;ecmaVersion&lt;/code&gt; setting.</source>
          <target state="translated">당신이 어떤 이유로 추가 생성자 플래그를 허용 할 경우, 당신은 사용하여 지정할 수 있습니다 &lt;code&gt;allowConstructorFlags&lt;/code&gt; 의 에서 옵션 &lt;code&gt;.eslintrc&lt;/code&gt; 을 . 이 플래그는 &lt;code&gt;ecmaVersion&lt;/code&gt; 설정에 관계없이 규칙에 의해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="025c660770aa315e6d8b4dbc5d92f3800b8c5d91" translate="yes" xml:space="preserve">
          <source>If you want to allow assignment to function parameters, then you can safely disable this rule.</source>
          <target state="translated">기능 매개 변수에 할당을 허용하려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c2aaebaf24fdde52a8a21733c045787756506c" translate="yes" xml:space="preserve">
          <source>If you want to allow control flow operations in &lt;code&gt;finally&lt;/code&gt; blocks, you can turn this rule off.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 블록 에서 제어 흐름 작업을 허용 하려면이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce4198863586a404bf23ac360d7a26607f63a6c" translate="yes" xml:space="preserve">
          <source>If you want to allow dangling underscores in identifiers, then you can safely turn this rule off.</source>
          <target state="translated">식별자에 매달려 밑줄을 허용하려면이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ec3c669980b1ce6e74d2cc3cca9be9749234bd" translate="yes" xml:space="preserve">
          <source>If you want to allow developers to each decide how they want to write functions on their own, then you can disable this rule.</source>
          <target state="translated">개발자가 독자적으로 함수를 작성하는 방법을 결정하도록하려면이 규칙을 사용하지 않도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a99420336119594b2985f957e70afd067dc5c412" translate="yes" xml:space="preserve">
          <source>If you want to allow functions to have different &lt;code&gt;return&lt;/code&gt; behavior depending on code branching, then it is safe to disable this rule.</source>
          <target state="translated">코드 분기에 따라 함수가 다른 &lt;code&gt;return&lt;/code&gt; 동작 을 갖도록 하려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="06d8a61f2b762c90cf475f1c301e8c19a2803657" translate="yes" xml:space="preserve">
          <source>If you want to allow multiple spaces in a regular expression, then you can safely turn this rule off.</source>
          <target state="translated">정규식에 여러 공백을 허용하려면이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="168b692048b6b1f7a247321b869174d92d311217" translate="yes" xml:space="preserve">
          <source>If you want to allow string concatenation of path names.</source>
          <target state="translated">경로 이름의 문자열 연결을 허용하려는 경우</target>
        </trans-unit>
        <trans-unit id="c2b47982ee8ecdbe90dcd79199ede4d5a1a2501a" translate="yes" xml:space="preserve">
          <source>If you want to allow synchronous operations in your script, do not enable this rule.</source>
          <target state="translated">스크립트에서 동기 작업을 허용하려면이 규칙을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="157d97e1222d6e6c5c3036eddedf2544c220e1e7" translate="yes" xml:space="preserve">
          <source>If you want to allow the use of &lt;code&gt;undefined&lt;/code&gt; in your code, then you can safely turn this rule off.</source>
          <target state="translated">코드에서 &lt;code&gt;undefined&lt;/code&gt; 를 사용하려면 이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5593620bae839c590950598c5628a7cf2b50ce4f" translate="yes" xml:space="preserve">
          <source>If you want to allow the use of assignment operators in a &lt;code&gt;return&lt;/code&gt; statement, then you can safely disable this rule.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 문 에 대입 연산자를 사용하려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b91748df59dc1d210ee220fffd1795446709f9c9" translate="yes" xml:space="preserve">
          <source>If you want to allow the use of primitive wrapper objects, then you can safely disable this rule.</source>
          <target state="translated">기본 랩퍼 오브젝트 사용을 허용하려는 경우이 규칙을 안전하게 사용 안함으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="117c72dd490ac86d6418992cd2bdcb271c9762cc" translate="yes" xml:space="preserve">
          <source>If you want to allow use of &lt;code&gt;parseInt()&lt;/code&gt; or &lt;code&gt;Number.parseInt()&lt;/code&gt; for binary, octal, or hexadecimal integers, or if you are not using ES6 (because binary and octal literals are not supported in ES5 and below), you may wish to disable this rule.</source>
          <target state="translated">2 진, 8 진 또는 16 진 정수 에 &lt;code&gt;parseInt()&lt;/code&gt; 또는 &lt;code&gt;Number.parseInt()&lt;/code&gt; 를 사용하거나 ES6을 사용하지 않는 경우 (2 진 및 8 진 리터럴이 ES5 이하에서 지원되지 않기 때문에) 원하는 경우 이 규칙을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a7a2d8bc617fb6a973e4a757758c6ff305221634" translate="yes" xml:space="preserve">
          <source>If you want to be able to access array indices or object properties directly, you can either configure the rule to your tastes or disable the rule entirely.</source>
          <target state="translated">배열 인덱스 또는 객체 속성에 직접 액세스하려면 규칙을 취향에 맞게 구성하거나 규칙을 완전히 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e945829b731e7b76322bd039aebed22d8e0288ab" translate="yes" xml:space="preserve">
          <source>If you want to contribute to an ESLint repo, please use a GitHub pull request. This is the fastest way for us to evaluate your code and to merge it into the code base. Please don't file an issue with snippets of code. Doing so means that we need to manually merge the changes in and update any appropriate tests. That decreases the likelihood that your code is going to get included in a timely manner. Please use pull requests.</source>
          <target state="translated">ESLint 저장소에 기여하려면 GitHub 풀 요청을 사용하십시오. 이것이 코드를 평가하고 코드베이스에 병합하는 가장 빠른 방법입니다. 코드 스 니펫에 문제를 제기하지 마십시오. 그렇게하면 변경 사항을 수동으로 병합하고 적절한 테스트를 업데이트해야합니다. 그러면 코드가 적시에 포함될 가능성이 줄어 듭니다. 풀 요청을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1bc3e203f722d1ec9693455df83c11f36ba7aae" translate="yes" xml:space="preserve">
          <source>If you want to fix code from &lt;code&gt;stdin&lt;/code&gt; or otherwise want to get the fixes without actually writing them to the file, use the &lt;a href=&quot;#--fix-dry-run&quot;&gt;&lt;code&gt;--fix-dry-run&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에서 코드를 수정 하거나 실제로 파일에 코드를 작성하지 않고 수정을 얻으려면 &lt;a href=&quot;#--fix-dry-run&quot;&gt; &lt;code&gt;--fix-dry-run&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d433926704a4ac51dbe6e1a80f5afe0f9cbc20ed" translate="yes" xml:space="preserve">
          <source>If you want to implement a breaking change or a change to the core, ensure there's an issue that describes what you're doing and the issue has been accepted. You can create a new issue or just indicate you're &lt;a href=&quot;working-on-issues&quot;&gt;working on an existing issue&lt;/a&gt;. Bug fixes, documentation changes, and other pull requests do not require an issue.</source>
          <target state="translated">주요 변경 사항 또는 핵심 변경 사항을 구현하려면 현재 수행중인 작업을 설명하고 문제가 승인되었는지 확인하십시오. 새 문제를 만들거나 &lt;a href=&quot;working-on-issues&quot;&gt;기존 문제를 해결하고&lt;/a&gt; 있음을 나타낼 수 있습니다 . 버그 수정, 문서 변경 및 기타 풀 요청에는 문제가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf3fa15fdca101b1059dd87a531855c8a22f9b" translate="yes" xml:space="preserve">
          <source>If you want to learn more about destructuring, check out the links below:</source>
          <target state="translated">구조 해제에 대한 자세한 내용을 보려면 아래 링크를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="01bdb16b7d4784e8c75c4b849aaf2b1888300119" translate="yes" xml:space="preserve">
          <source>If you want to learn more about tagged template literals, check out the links below:</source>
          <target state="translated">태그가 지정된 템플릿 리터럴에 대한 자세한 내용을 보려면 아래 링크를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1bfb10754401295a1a5e4ea43c2fe0a3b67db675" translate="yes" xml:space="preserve">
          <source>If you want to lint one or more files, use the &lt;code&gt;executeOnFiles()&lt;/code&gt; method. This method accepts a single argument, which is an array of files and/or directories to traverse for files. You can pass the same values as you would using the ESLint command line interface, such as &lt;code&gt;&quot;.&quot;&lt;/code&gt; to search all JavaScript files in the current directory. Here's an example:</source>
          <target state="translated">하나 이상의 파일을 보풀이되게하려면 &lt;code&gt;executeOnFiles()&lt;/code&gt; 메소드를 사용하십시오 . 이 메소드는 파일을 탐색 할 파일 및 / 또는 디렉토리의 배열 인 단일 인수를 허용합니다. &lt;code&gt;&quot;.&quot;&lt;/code&gt; 와 같은 ESLint 명령 행 인터페이스를 사용할 때와 동일한 값을 전달할 수 있습니다 . 현재 디렉토리에서 모든 JavaScript 파일을 검색합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ae0efa7cc8d38a3e330a4407faa82ae491a0ad3" translate="yes" xml:space="preserve">
          <source>If you want to propose a new rule, please see how to &lt;a href=&quot;pull-requests&quot;&gt;create a pull request&lt;/a&gt; or submit an issue by filling out a &lt;a href=&quot;https://github.com/eslint/eslint/issues/new?template=NEW_RULE.md&quot;&gt;new rule template&lt;/a&gt;.</source>
          <target state="translated">새 규칙을 제안하려면 &lt;a href=&quot;https://github.com/eslint/eslint/issues/new?template=NEW_RULE.md&quot;&gt;새 규칙 템플릿&lt;/a&gt; 을 &lt;a href=&quot;pull-requests&quot;&gt;작성하여 풀 요청&lt;/a&gt; 을 작성 하거나 문제를 제출하는 방법을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc20c08d174f1ad50d824f0e45cd254992c6ae16" translate="yes" xml:space="preserve">
          <source>If you want to quickly run just one test, you can do so by running Mocha directly and passing in the filename. For example:</source>
          <target state="translated">하나의 테스트 만 빠르게 실행하려면 Mocha를 직접 실행하고 파일 이름을 전달하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16da35b5af438aa046c923e0c90a12cc343ac898" translate="yes" xml:space="preserve">
          <source>If you want to retrieve a configuration object for a given file, use the &lt;code&gt;getConfigForFile()&lt;/code&gt; method. This method accepts one argument, a file path, and returns an object represented the calculated configuration of the file. Here's an example:</source>
          <target state="translated">주어진 파일에 대한 구성 객체를 검색하려면 &lt;code&gt;getConfigForFile()&lt;/code&gt; 메소드를 사용하십시오 . 이 메소드는 파일 경로 인 하나의 인수를 허용하고 파일의 계산 된 구성을 나타내는 오브젝트를 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bbedf7b05174e3221ac6559667171bdc4900f74" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;await&lt;/code&gt; to denote a value that is a thenable, even when it is not necessary; or if you do not want the performance benefit of avoiding &lt;code&gt;return await&lt;/code&gt;, you can turn off this rule.</source>
          <target state="translated">필요하지 않은 경우에도 &lt;code&gt;await&lt;/code&gt; 를 사용하여 다음 값을 표시 할 수 있습니다 . 또는 &lt;code&gt;return await&lt;/code&gt; 피하기위한 성능 이점을 원하지 않는 경우이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ebf4e944a61bef47f4a2f25c9dfb29556f044f3" translate="yes" xml:space="preserve">
          <source>If you want to use Reflect methods, but keep using the &lt;code&gt;delete&lt;/code&gt; keyword, then your config would look like &lt;code&gt;prefer-reflect: [2, { &quot;exceptions&quot;: [&quot;delete&quot;] }]&lt;/code&gt;.</source>
          <target state="translated">Reflect 메소드를 사용하고 싶지만 &lt;code&gt;delete&lt;/code&gt; 키워드를 계속 사용 하려면 구성이 &lt;code&gt;prefer-reflect: [2, { &quot;exceptions&quot;: [&quot;delete&quot;] }]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dcbce8e16ab14d37edc537499d4673be2756e1d" translate="yes" xml:space="preserve">
          <source>If you want to use an environment from a plugin, be sure to specify the plugin name in the &lt;code&gt;plugins&lt;/code&gt; array and then use the unprefixed plugin name, followed by a slash, followed by the environment name. For example:</source>
          <target state="translated">플러그인에서 환경을 사용하려면 &lt;code&gt;plugins&lt;/code&gt; 배열 에서 플러그인 이름을 지정한 다음 접두사 뒤에 붙지 않은 플러그인 이름, 슬래시, 환경 이름을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb8a205efd9c67c4073b9416e356ad4478147a46" translate="yes" xml:space="preserve">
          <source>If you want to use sparse arrays, then it is safe to disable this rule.</source>
          <target state="translated">희소 배열을 사용하려면이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="32718e9e480985cfed80435e0fad5f99885ad95f" translate="yes" xml:space="preserve">
          <source>If you want to use your own parser and provide additional capabilities for your rules, you can specify your own custom parser. If a &lt;code&gt;parseForESLint&lt;/code&gt; method is exposed on the parser, this method will be used to parse the code. Otherwise, the &lt;code&gt;parse&lt;/code&gt; method will be used. Both methods should take in the source code as the first argument, and an optional configuration object as the second argument (provided as &lt;code&gt;parserOptions&lt;/code&gt; in a config file). The &lt;code&gt;parse&lt;/code&gt; method should simply return the AST. The &lt;code&gt;parseForESLint&lt;/code&gt; method should return an object that contains the required property &lt;code&gt;ast&lt;/code&gt; and optional properties &lt;code&gt;services&lt;/code&gt;, &lt;code&gt;scopeManager&lt;/code&gt;, and &lt;code&gt;visitorKeys&lt;/code&gt;.</source>
          <target state="translated">자체 파서를 사용하고 규칙에 추가 기능을 제공하려는 경우 고유 한 사용자 정의 파서를 지정할 수 있습니다. 경우 &lt;code&gt;parseForESLint&lt;/code&gt; 의 방법을 파서에 노출되어,이 방법은 코드를 구문 분석하는 데 사용됩니다. 그렇지 않으면 &lt;code&gt;parse&lt;/code&gt; 방법이 사용됩니다. 두 메소드 모두 소스 코드를 첫 번째 인수로, 선택적 구성 오브젝트를 두 번째 인수 ( 구성 파일에서 &lt;code&gt;parserOptions&lt;/code&gt; 로 제공)로 가져와야 합니다. &lt;code&gt;parse&lt;/code&gt; 방법은 단순히 AST를 반환해야합니다. &lt;code&gt;parseForESLint&lt;/code&gt; 의 방법은 필요한 속성이 포함 된 개체를 반환해야합니다 &lt;code&gt;ast&lt;/code&gt; 및 선택 속성 &lt;code&gt;services&lt;/code&gt; , &lt;code&gt;scopeManager&lt;/code&gt; 을 하고, &lt;code&gt;visitorKeys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3230232a97c3d21775cfc1d1507fc08955ed3b0e" translate="yes" xml:space="preserve">
          <source>If you were to remove the initialization, then the behavior of the loop changes:</source>
          <target state="translated">초기화를 제거하면 루프 동작이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="d93b953074e456b439293bef97d4d869490dadb5" translate="yes" xml:space="preserve">
          <source>If you were using &lt;code&gt;ecmaFeatures.modules&lt;/code&gt; to enable ES6 module support like this:</source>
          <target state="translated">&lt;code&gt;ecmaFeatures.modules&lt;/code&gt; 를 사용 하여 다음 과 같이 ES6 모듈 지원을 활성화 한 경우 :</target>
        </trans-unit>
        <trans-unit id="36c05b83cad0c60a876dbe4551ddc2004b01bce0" translate="yes" xml:space="preserve">
          <source>If you were using a prior version of ESLint, you can get help with the transition by reading:</source>
          <target state="translated">이전 버전의 ESLint를 사용중인 경우 다음을 읽고 전환에 대한 도움을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62e887c8ffaf679225cbfb62fab07d5987855b22" translate="yes" xml:space="preserve">
          <source>If you wish to allow the use of the &lt;code&gt;Object&lt;/code&gt; constructor, you can safely turn this rule off.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 생성자를 사용하려면 이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4845e6a9b32a2c3cb12af3f332e0e771dafb2f16" translate="yes" xml:space="preserve">
          <source>If you wish to have a different configuration for line comments and block comments, you can do so by using two different object configurations (note that the capitalization option will be enforced consistently for line and block comments):</source>
          <target state="translated">라인 주석 및 블록 주석에 대해 다른 구성을 원하면 두 가지 다른 객체 구성을 사용하여 구성 할 수 있습니다 (대화 옵션은 라인 및 블록 주석에 대해 일관되게 시행됨).</target>
        </trans-unit>
        <trans-unit id="3b305d34beab965b8e6902b4057eb1ea1186cc8f" translate="yes" xml:space="preserve">
          <source>If you'd like ESLint to attempt to fix the problem you're reporting, you can do so by specifying the &lt;code&gt;fix&lt;/code&gt; function when using &lt;code&gt;context.report()&lt;/code&gt;. The &lt;code&gt;fix&lt;/code&gt; function receives a single argument, a &lt;code&gt;fixer&lt;/code&gt; object, that you can use to apply a fix. For example:</source>
          <target state="translated">보고중인 문제를 ESLint가 수정하려고 할 경우 &lt;code&gt;context.report()&lt;/code&gt; 사용할 때 &lt;code&gt;fix&lt;/code&gt; 함수 를 지정하면 됩니다 . &lt;code&gt;fix&lt;/code&gt; 기능은 단일 인수하는 수신 &lt;code&gt;fixer&lt;/code&gt; 당신이 수정 프로그램을 적용하는 데 사용할 수있는 개체를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2de9e1d21deb952d591059d9bfac04bff3045b4" translate="yes" xml:space="preserve">
          <source>If you'd like to request a change other than a bug fix or new rule, this section explains that process.</source>
          <target state="translated">버그 수정 또는 새 규칙 이외의 변경을 요청하려면이 섹션에서 해당 프로세스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9dbf97a89558daba71eceae42ebb78166efcb253" translate="yes" xml:space="preserve">
          <source>If you'd like to request a change to ESLint, please &lt;a href=&quot;https://github.com/eslint/eslint/issues/new?template=CHANGE.md&quot;&gt;create a new issue&lt;/a&gt; on GitHub. Be sure to include the following information:</source>
          <target state="translated">ESLint 변경을 요청하려면 GitHub &lt;a href=&quot;https://github.com/eslint/eslint/issues/new?template=CHANGE.md&quot;&gt;에서 새로운 이슈&lt;/a&gt; 를 만드십시오 . 다음 정보를 반드시 포함하십시오 :</target>
        </trans-unit>
        <trans-unit id="a2ff681ef1e1294a4a8430977faeb8b6585b95bd" translate="yes" xml:space="preserve">
          <source>If you'd like to work on a pull request and you've never submitted code before, follow these steps:</source>
          <target state="translated">풀 요청을 수행하고 전에 코드를 제출 한 적이 없다면 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="1fc6d5511f027154cd7d3325f533abfe108333a7" translate="yes" xml:space="preserve">
          <source>If you'd prefer to use a different file than the &lt;code&gt;.eslintignore&lt;/code&gt; in the current working directory, you can specify it on the command line using the &lt;code&gt;--ignore-path&lt;/code&gt; option. For example, you can use &lt;code&gt;.jshintignore&lt;/code&gt; file because it has the same format:</source>
          <target state="translated">현재 작업 디렉토리에서 &lt;code&gt;.eslintignore&lt;/code&gt; 와 다른 파일을 사용하려면 &lt;code&gt;--ignore-path&lt;/code&gt; 옵션을 사용하여 명령 줄에서 해당 파일 을 지정할 수 있습니다. 예를 들어, &lt;code&gt;.jshintignore&lt;/code&gt; 파일은 형식이 같으므로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8bb46085e72a67007bd541cac129fad559af636" translate="yes" xml:space="preserve">
          <source>If you're going to work on an issue, please add a comment to that issue saying so and indicating when you think you will complete it. It will help us to avoid duplication of effort. Some examples of good comments are:</source>
          <target state="translated">문제를 해결하려는 경우 해당 문제에 대한 의견을 추가하고 완료 할 시점을 알려주십시오. 노력의 중복을 피하는 데 도움이 될 것입니다. 좋은 의견의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="529fb9f8074c731a55ea46317378ab6ce2fa6379" translate="yes" xml:space="preserve">
          <source>If you're interested in writing a tool that uses ESLint, then you can use the Node.js API to get programmatic access to functionality.</source>
          <target state="translated">ESLint를 사용하는 도구를 작성하려면 Node.js API를 사용하여 기능에 프로그래밍 방식으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="492482d9566e53632c85e7788842a3f9c1aceabf" translate="yes" xml:space="preserve">
          <source>If you're not concerned about consistent locations of implicitly returned arrow function expressions, you should not turn on this rule.</source>
          <target state="translated">내재적으로 리턴 된 화살표 함수 표현식의 일관된 위치에 대해 걱정하지 않으면이 규칙을 설정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="403e57af13573e69ccf33af74594bbecf97b2c8e" translate="yes" xml:space="preserve">
          <source>If you're not concerned about consistent locations of single-line statements, you should not turn on this rule. You can also disable this rule if you're using the &lt;code&gt;&quot;all&quot;&lt;/code&gt; option for the &lt;a href=&quot;curly&quot;&gt;&lt;code&gt;curly&lt;/code&gt;&lt;/a&gt; rule, because this will disallow single-line statements entirely.</source>
          <target state="translated">한 줄짜리 진술의 일관된 위치에 대해 걱정하지 않으면이 규칙을 설정하지 않아야합니다. &lt;a href=&quot;curly&quot;&gt; &lt;code&gt;curly&lt;/code&gt; &lt;/a&gt; 대해 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 옵션을 사용하는 경우이 규칙을 사용하지 않을 수도 있습니다 . 이는 단일 행 명령문을 완전히 허용하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1d9f59855a50da748bf20de2e170697ffbe4d25d" translate="yes" xml:space="preserve">
          <source>If you're not sure which config file needs to be updated, it may be useful to run ESLint v5 and look at what config file is mentioned in the deprecation warning.</source>
          <target state="translated">어떤 구성 파일을 업데이트해야할지 확실하지 않은 경우 ESLint v5를 실행하고 사용 중단 경고에 어떤 구성 파일이 언급되어 있는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e7c33db323d7ae05a4a777eaa7e0692355dceeee" translate="yes" xml:space="preserve">
          <source>If you're not using &lt;code&gt;ecmaFeatures&lt;/code&gt; in your configuration or your custom/plugin rules and tests, then no change is needed.</source>
          <target state="translated">구성 또는 사용자 정의 / 플러그인 규칙 및 테스트에서 &lt;code&gt;ecmaFeatures&lt;/code&gt; 를 사용하지 않는 경우 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e5d630cd8e1ad7d04f0f3ebb887b02dbcbde5a8" translate="yes" xml:space="preserve">
          <source>If you're planning on contributing to ESLint, then it's a good idea to fork the repository. You can find instructions for forking a repository at &lt;a href=&quot;https://help.github.com/articles/fork-a-repo/&quot;&gt;https://help.github.com/articles/fork-a-repo/&lt;/a&gt;. After forking the ESLint repository, you'll want to create a local copy of your fork.</source>
          <target state="translated">ESLint에 기여할 계획이라면 저장소를 포크하는 것이 좋습니다. &lt;a href=&quot;https://help.github.com/articles/fork-a-repo/&quot;&gt;https://help.github.com/articles/fork-a-repo/&lt;/a&gt; 에서 저장소 포크에 대한 지침을 찾을 수 있습니다 . ESLint 리포지토리를 분기 한 후 분기의 로컬 복사본을 만들려고합니다.</target>
        </trans-unit>
        <trans-unit id="04c7fb910e2d3f13bf107bc9b013fc5fc7904efc" translate="yes" xml:space="preserve">
          <source>If you're requesting a change to a rule, it's helpful to include this information as well:</source>
          <target state="translated">규칙 변경을 요청하는 경우 다음 정보도 포함하면 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="44e50b47a18d3a7403129f958f989d1c21f74408" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;context.ecmaFeatures.modules&lt;/code&gt;, rewrite to check that the &lt;code&gt;sourceType&lt;/code&gt; property of the Program node is &lt;code&gt;&quot;module&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;context.ecmaFeatures.modules&lt;/code&gt; 를 사용 하는 경우 Program 노드 의 &lt;code&gt;sourceType&lt;/code&gt; 속성이 &lt;code&gt;&quot;module&quot;&lt;/code&gt; 인지 확인하기 위해 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fc559da69650e0770bde8a012bac60b284aed63" translate="yes" xml:space="preserve">
          <source>If you're using Node.js, however, &lt;code&gt;console&lt;/code&gt; is used to output information to the user and so is not strictly used for debugging purposes. If you are developing for Node.js then you most likely do not want this rule enabled.</source>
          <target state="translated">그러나 Node.js를 사용하는 경우 &lt;code&gt;console&lt;/code&gt; 은 사용자에게 정보를 출력하는 데 사용되므로 디버깅 목적으로 엄격하게 사용되지는 않습니다. Node.js를 개발하는 경우이 규칙을 사용하지 않을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="6679e6e261401ed39ebd01362b8293e4ddca112e" translate="yes" xml:space="preserve">
          <source>If you're using a non-ES6 feature flag such as &lt;code&gt;context.ecmaFeatures.jsx&lt;/code&gt;, rewrite to check for &lt;code&gt;context.parserOptions.ecmaFeatures.jsx&lt;/code&gt;.</source>
          <target state="translated">이 같은 비 ES6 기능 플래그를 사용하는 경우 &lt;code&gt;context.ecmaFeatures.jsx&lt;/code&gt; , 확인하기 위해 다시 &lt;code&gt;context.parserOptions.ecmaFeatures.jsx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a85d177b329bc6c730f23ff598ce3a4fb75b095d" translate="yes" xml:space="preserve">
          <source>If you're using an ES6 feature flag such as &lt;code&gt;context.ecmaFeatures.blockBindings&lt;/code&gt;, rewrite to check for &lt;code&gt;context.parserOptions.ecmaVersion &amp;gt; 5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;context.ecmaFeatures.blockBindings&lt;/code&gt; 와 같은 ES6 기능 플래그를 사용하는 경우 &lt;code&gt;context.parserOptions.ecmaVersion &amp;gt; 5&lt;/code&gt; 를 확인하도록 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ff71978601ec2bbe9e3d1868a2d18412ce28bed" translate="yes" xml:space="preserve">
          <source>If you're using any non-ES6 flags in &lt;code&gt;ecmaFeatures&lt;/code&gt;, you need to move those inside of &lt;code&gt;parserOptions&lt;/code&gt;. For instance:</source>
          <target state="translated">당신이 아닌 ES6 플래그를 사용하는 경우 &lt;code&gt;ecmaFeatures&lt;/code&gt; , 당신의 그 내부 이동해야 &lt;code&gt;parserOptions&lt;/code&gt; 을 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5d5c9fc44eb094ac8f2b18978cbf3f0acccc994b" translate="yes" xml:space="preserve">
          <source>If you're using any of these flags, such as:</source>
          <target state="translated">다음과 같은 플래그를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="6495d2f4fd019907eeb203fca9c3e68a5e7680ab" translate="yes" xml:space="preserve">
          <source>If you're using custom non-error values as Promise rejection reasons, you can turn off this rule.</source>
          <target state="translated">약속 거부 이유로 사용자 지정 오류가 아닌 값을 사용하는 경우이 규칙을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3dda6a82a85489dc460700036c64d7e04f74905" translate="yes" xml:space="preserve">
          <source>If you're using such an initialization inside of a loop, then you should disable this rule.</source>
          <target state="translated">루프 내부에서 이러한 초기화를 사용하는 경우이 규칙을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="de18cfd7f994a6a4746d6a5b6b988915f27f6978" translate="yes" xml:space="preserve">
          <source>If you're writing custom ESLint rules, you might be interested in using selectors to examine specific parts of the AST. If you're configuring ESLint for your codebase, you might be interested in restricting particular syntax patterns with selectors.</source>
          <target state="translated">사용자 정의 ESLint 규칙을 작성하는 경우 선택기를 사용하여 AST의 특정 부분을 검사하는 것이 좋습니다. 코드베이스에 대해 ESLint를 구성하는 경우 선택기로 특정 구문 패턴을 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c96442ea1831fcb8ddebf6e89b51db125d24c596" translate="yes" xml:space="preserve">
          <source>If your code is only going to be executed in an ECMAScript 5 or higher environment, then you can safely leave this rule off.</source>
          <target state="translated">코드가 ECMAScript 5 이상 환경에서만 실행되는 경우이 규칙을 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c1a1996cd5371119325ca66866f4edcd3530231" translate="yes" xml:space="preserve">
          <source>If your code is out-of-date, we might ask you to rebase. That means we want you to apply your changes on top of the latest upstream code. Make sure you have set up a &lt;a href=&quot;../development-environment&quot;&gt;development environment&lt;/a&gt; and then you can rebase using these commands:</source>
          <target state="translated">코드가 최신이 아닌 경우 리베이스를 요청할 수 있습니다. 즉, 최신 업스트림 코드 위에 변경 사항을 적용하기를 원합니다. &lt;a href=&quot;../development-environment&quot;&gt;개발 환경&lt;/a&gt; 을 설정했는지 확인한 후 다음 명령을 사용하여 리베이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a50954cfa8c4532d799e153f3402761f00daa2" translate="yes" xml:space="preserve">
          <source>If your code is still very much in development and don't want to worry about stripping &lt;code&gt;debugger&lt;/code&gt; statements, then turn this rule off. You'll generally want to turn it back on when testing code prior to deployment.</source>
          <target state="translated">코드가 아직 개발 중이며 &lt;code&gt;debugger&lt;/code&gt; 문을 제거하는 것에 대해 걱정하지 않으려면 이 규칙을 해제하십시오. 배포 전에 코드를 테스트 할 때 일반적으로 다시 켜고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="83a5396f7b29a4f6527d5a1931cc0bcb3428da62" translate="yes" xml:space="preserve">
          <source>If your code will not be run in IE8 or below (a Node.js application, for example) and you'd prefer to allow trailing commas, turn this rule off.</source>
          <target state="translated">코드가 IE8 이하 (예 : Node.js 애플리케이션)에서 실행되지 않고 후행 쉼표를 허용하려면이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="f8f29c811490e5458b9805b99b4ea539001d53d1" translate="yes" xml:space="preserve">
          <source>If your codebase doesn't support async function syntax, there's no need to enable this rule.</source>
          <target state="translated">코드베이스가 비동기 함수 구문을 지원하지 않으면이 규칙을 활성화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a162368aefa62116f17df2fd8bc935578feec8ea" translate="yes" xml:space="preserve">
          <source>If your commit message is in the incorrect format, you'll be asked to update it. You can do so via:</source>
          <target state="translated">커밋 메시지의 형식이 잘못된 경우 업데이트하라는 메시지가 표시됩니다. 다음을 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab5ccc8af6f48197d32df8b7d3e12fe2a0141524" translate="yes" xml:space="preserve">
          <source>If your configuration extends all core rules: after you upgrade to a newer major or minor version of ESLint, review the reported problems before you use the &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;command-line-interface#fix&quot;&gt;command line&lt;/a&gt;, so you know if a new fixable rule will make changes to the code.</source>
          <target state="translated">구성이 모든 핵심 규칙을 확장하는 경우 : 최신 주 버전 또는 부 버전의 ESLint로 업그레이드 한 후 &lt;a href=&quot;command-line-interface#fix&quot;&gt;명령 행&lt;/a&gt; 에서 &lt;code&gt;--fix&lt;/code&gt; 옵션을 사용하기 전에보고 된 문제점을 검토하여 새 수정 가능한 규칙이 다음과 같이 변경되는지 확인하십시오. 코드.</target>
        </trans-unit>
        <trans-unit id="2559a41e901cadba989bfeffd57f3935b353bcb1" translate="yes" xml:space="preserve">
          <source>If your configuration extends the recommended rules: after you upgrade to a newer major version of ESLint, review the reported problems before you use the &lt;code&gt;--fix&lt;/code&gt; option on the &lt;a href=&quot;command-line-interface#fix&quot;&gt;command line&lt;/a&gt;, so you know if a new fixable recommended rule will make changes to the code.</source>
          <target state="translated">구성이 권장 규칙을 확장하는 경우 : 최신 주요 ESLint 버전으로 업그레이드 한 후 &lt;a href=&quot;command-line-interface#fix&quot;&gt;명령 행&lt;/a&gt; 에서 &lt;code&gt;--fix&lt;/code&gt; 옵션을 사용하기 전에보고 된 문제점을 검토하십시오 . 따라서 수정 가능한 새로운 권장 규칙이 암호.</target>
        </trans-unit>
        <trans-unit id="39f85b8e11f0a7287198c3637add2aa74d65ec3a" translate="yes" xml:space="preserve">
          <source>If your project will not be following a consistent comma-spacing pattern, turn this rule off.</source>
          <target state="translated">프로젝트가 일관된 쉼표 간격 패턴을 따르지 않으면이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b2741db66d6831acaf061c23673437b93b79e590" translate="yes" xml:space="preserve">
          <source>If your project will not be using ES5 property getters you do not need this rule.</source>
          <target state="translated">프로젝트에서 ES5 속성 게터를 사용하지 않는 경우이 규칙이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bab195dfe6cfd05f543eca0ef2bf531274ab3593" translate="yes" xml:space="preserve">
          <source>If your project will not be using a common operator line break style, turn this rule off.</source>
          <target state="translated">프로젝트에서 공통 연산자 줄 바꿈 스타일을 사용하지 않는 경우이 규칙을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2945d370984bd3d31485c9bde06fc75b8ba6634f" translate="yes" xml:space="preserve">
          <source>If your project will not be using generators or you are not concerned with spacing consistency, you do not need this rule.</source>
          <target state="translated">프로젝트에서 생성기를 사용하지 않거나 간격 일관성에 관심이없는 경우이 규칙이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5ba84c31d79b821b596dda291e464837704ee5d" translate="yes" xml:space="preserve">
          <source>If your project will not be using generators you do not need this rule.</source>
          <target state="translated">프로젝트에서 생성기를 사용하지 않는 경우이 규칙이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b403b66e02ddb4237f2f89a2eff187617c1cbaf" translate="yes" xml:space="preserve">
          <source>If your rule is disallowing something, prefix it with &lt;code&gt;no-&lt;/code&gt; such as &lt;code&gt;no-eval&lt;/code&gt; for disallowing &lt;code&gt;eval()&lt;/code&gt; and &lt;code&gt;no-debugger&lt;/code&gt; for disallowing &lt;code&gt;debugger&lt;/code&gt;.</source>
          <target state="translated">규칙에서 무언가 를 허용하지 않는 경우 &lt;code&gt;eval()&lt;/code&gt; 을 허용하지 않는 경우 eval () 을 허용하지 않는 &lt;code&gt;debugger&lt;/code&gt; 및 &lt;code&gt;no-debugger&lt;/code&gt; 를 허용하지 않는 경우 디버거 &lt;code&gt;no-eval&lt;/code&gt; 과 같이 &lt;code&gt;no-&lt;/code&gt; 접두사를 붙 입니다.</target>
        </trans-unit>
        <trans-unit id="2824b845991c6bbe7e78b00c6a0fb1a3e916869b" translate="yes" xml:space="preserve">
          <source>If your rule is enforcing the inclusion of something, use a short name without a special prefix.</source>
          <target state="translated">규칙에 무언가 포함을 강제하는 경우 특별한 접두사없이 짧은 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2011f28355e4125316a3bdd688cb7db66dd75549" translate="yes" xml:space="preserve">
          <source>If your rule needs to get the actual JavaScript source to work with, then use the &lt;code&gt;sourceCode.getText()&lt;/code&gt; method. This method works as follows:</source>
          <target state="translated">규칙에서 작업 할 실제 JavaScript 소스를 &lt;code&gt;sourceCode.getText()&lt;/code&gt; 하는 경우 sourceCode.getText () 메소드 를 사용하십시오 . 이 방법은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e1ebf009df56e29e74f07a68f239e17913f4a1d3" translate="yes" xml:space="preserve">
          <source>If your shareable config depends on a plugin, you should also specify it as a &lt;code&gt;peerDependency&lt;/code&gt; (plugins will be loaded relative to the end user's project, so the end user is required to install the plugins they need). However, if your shareable config depends on a third-party parser or another shareable config, you can specify these packages as &lt;code&gt;dependencies&lt;/code&gt;.</source>
          <target state="translated">공유 가능한 구성이 플러그인에 의존하는 경우이를 &lt;code&gt;peerDependency&lt;/code&gt; 로 지정해야합니다 (최종 사용자의 프로젝트를 기준으로 플러그인이로드되므로 최종 사용자는 필요한 플러그인을 설치해야 함). 그러나 공유 가능한 구성이 타사 파서 또는 다른 공유 가능한 구성에 &lt;code&gt;dependencies&lt;/code&gt; 하는 경우 이러한 패키지를 종속성으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1856f3abeff9591a2a7d76238103bbed25f63cd8" translate="yes" xml:space="preserve">
          <source>If/else statements</source>
          <target state="translated">if / else 문</target>
        </trans-unit>
        <trans-unit id="88efdf7b0a638bc58f75e1b4e8e0f081ca07ff33" translate="yes" xml:space="preserve">
          <source>Ignore patterns behave according to the &lt;code&gt;.gitignore&lt;/code&gt;&lt;a href=&quot;https://git-scm.com/docs/gitignore&quot;&gt;specification&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; &lt;a href=&quot;https://git-scm.com/docs/gitignore&quot;&gt;사양&lt;/a&gt; 에 따라 패턴을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="e0c0968ebdf38ddfdbaec683b916b61dcb603c54" translate="yes" xml:space="preserve">
          <source>Ignored File Warnings</source>
          <target state="translated">무시 된 파일 경고</target>
        </trans-unit>
        <trans-unit id="d261e62109255eb2c88ce241ececcda865af665d" translate="yes" xml:space="preserve">
          <source>Ignores the member sorting within a &lt;code&gt;multiple&lt;/code&gt; member import declaration.</source>
          <target state="translated">&lt;code&gt;multiple&lt;/code&gt; 멤버 가져 오기 선언 내에서 멤버 정렬을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="97f2ea65d88865525c32c1dc0fdaabf6454b7ce5" translate="yes" xml:space="preserve">
          <source>Ignores the sorting of import declaration statements.</source>
          <target state="translated">가져 오기 선언문의 정렬을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fc6c2032aae29f2bf4cdf1ecb565f44e6c98df5a" translate="yes" xml:space="preserve">
          <source>Ignoring Files and Directories</source>
          <target state="translated">파일 및 디렉토리 무시</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">파일 무시</target>
        </trans-unit>
        <trans-unit id="c58183c9a7f3073a5d043430bb488897214cfb72" translate="yes" xml:space="preserve">
          <source>Ignoring files from linting</source>
          <target state="translated">보푸라기에서 파일 무시</target>
        </trans-unit>
        <trans-unit id="1c756c5607fbc3a3e749301ea2e32381c2238f06" translate="yes" xml:space="preserve">
          <source>Immediately-Invoked Function Expression (IIFE)</source>
          <target state="translated">즉시 호출 된 함수 식 (IIFE)</target>
        </trans-unit>
        <trans-unit id="8670c08fed9affa1bdffc5de7ab5b3464ea35b75" translate="yes" xml:space="preserve">
          <source>Immediately-invoked functions should surround the entire function call with parentheses.</source>
          <target state="translated">즉시 호출 된 함수는 전체 함수 호출을 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="04ab9b79c8691d1b53dc55cdbba436a62027f12a" translate="yes" xml:space="preserve">
          <source>Implementation is Your Responsibility</source>
          <target state="translated">구현은 당신의 책임입니다</target>
        </trans-unit>
        <trans-unit id="1de41e87576d1cd7f3d74b3b5efff943cda9a84d" translate="yes" xml:space="preserve">
          <source>Import Sorting (sort-imports)</source>
          <target state="translated">가져 오기 정렬 (정렬 가져 오기)</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="e23adeb5c008391316e0c7840edb5f056d234e51" translate="yes" xml:space="preserve">
          <source>ImportDeclaration and ExportDeclaration</source>
          <target state="translated">수입 신고 및 수출 신고</target>
        </trans-unit>
        <trans-unit id="512f7b91ec0d8627411f038f8a785a9f4f839ad5" translate="yes" xml:space="preserve">
          <source>Imports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through the &lt;code&gt;require()&lt;/code&gt; call which makes this ESLint rule roughly equivalent to its CommonJS counterpart &lt;code&gt;no-restricted-modules&lt;/code&gt;.</source>
          <target state="translated">가져 오기는 현재 모듈에서 다른 모듈의 기능을 사용할 수 있도록하는 ES6 / ES2015 표준입니다. CommonJS 에서는이 ESLint 규칙을 CommonJS 대응 &lt;code&gt;no-restricted-modules&lt;/code&gt; 와 거의 동일하게 하는 &lt;code&gt;require()&lt;/code&gt; 호출을 통해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="18df2daa90a7f6f769b0f156d9d53dd73803f193" translate="yes" xml:space="preserve">
          <source>In 0.x, the &lt;code&gt;cli&lt;/code&gt; object was exported for use by external tools. It was later deprecated in favor of &lt;code&gt;CLIEngine&lt;/code&gt;. In v1.0.0, we are no longer exporting &lt;code&gt;cli&lt;/code&gt; as it should not be used by external tools. This will break existing tools that make use of it.</source>
          <target state="translated">0.x에서 &lt;code&gt;cli&lt;/code&gt; 객체는 외부 도구에서 사용하기 위해 내보냈습니다. 나중에 &lt;code&gt;CLIEngine&lt;/code&gt; 을 위해 더 이상 사용되지 않습니다 . v1.0.0에서는 외부 도구에서 사용하지 않아야하므로 &lt;code&gt;cli&lt;/code&gt; 를 더 이상 내 보내지 않습니다. 이를 사용하는 기존 도구가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="5898b7f28a0e71c9b161ddb4ca225bd973b5e97c" translate="yes" xml:space="preserve">
          <source>In 2.0.0, &lt;code&gt;window&lt;/code&gt; is no longer located in &lt;code&gt;Scope#through&lt;/code&gt; because we have added back the correct declaration. That means you can reference the &lt;code&gt;window&lt;/code&gt; object (or any other global object) directly. So the previous example would change to this:</source>
          <target state="translated">2.0.0에서는 올바른 선언을 다시 추가했기 때문에 &lt;code&gt;Scope#through&lt;/code&gt; 에 더 이상 &lt;code&gt;window&lt;/code&gt; 없습니다 . 즉, &lt;code&gt;window&lt;/code&gt; 개체 (또는 다른 전역 개체)를 직접 참조 할 수 있습니다. 따라서 이전 예제는 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="05d96a1c4cc6fce528d734e47e75612567aa64df" translate="yes" xml:space="preserve">
          <source>In 2.0.0, the following 11 rules were added to &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt;.</source>
          <target state="translated">2.0.0에서는 다음 11 개의 규칙이 &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; 에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c17a66e49943e18d906b5c12b9a5610dc4ab2300" translate="yes" xml:space="preserve">
          <source>In 3.0.0, the following rules were added to &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt;:</source>
          <target state="translated">3.0.0에서는 다음 규칙이 &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; 에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d9538a421f15d2f2ded0595be1de71484d2215ae" translate="yes" xml:space="preserve">
          <source>In 3.x, there was a bug where references to scoped NPM packages as plugins in config files could omit the scope. For example, in 3.x the following config was legal:</source>
          <target state="translated">3.x에는 구성 파일의 플러그인으로 범위가 지정된 NPM 패키지에 대한 참조가 범위를 생략 할 수있는 버그가있었습니다. 예를 들어, 3.x에서는 다음 구성이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="4a1986599cc9b6d638b666c0d5c5c84604abcd28" translate="yes" xml:space="preserve">
          <source>In 4.0, shebang comments are treated as comment tokens of type &lt;code&gt;Shebang&lt;/code&gt; and will be returned by any &lt;code&gt;SourceCode&lt;/code&gt; method that returns comments. The goal of this change is to make working with shebang comments more consistent with how other tokens are handled.</source>
          <target state="translated">4.0에서 shebang 주석은 &lt;code&gt;Shebang&lt;/code&gt; 유형의 주석 토큰으로 취급되며 주석을 리턴하는 모든 &lt;code&gt;SourceCode&lt;/code&gt; 메소드에 의해 리턴됩니다 . 이 변경의 목표는 shebang 주석에 대한 작업이 다른 토큰을 처리하는 방법과보다 일관성있게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16bc04c506c5ab833d227d4d6e4907ae0bdb1f50" translate="yes" xml:space="preserve">
          <source>In 4.0, we have moved away from the concept of comment attachment and have moved all comment handling logic into ESLint itself. This should make it easier to develop custom parsers, but it also means that AST nodes will no longer have &lt;code&gt;leadingComments&lt;/code&gt; and &lt;code&gt;trailingComments&lt;/code&gt; properties. Conceptually, rule authors can now think of comments in the context of tokens rather than AST nodes.</source>
          <target state="translated">4.0에서는 주석 첨부 개념에서 벗어나 모든 주석 처리 논리를 ESLint 자체로 옮겼습니다. 이를 통해 사용자 정의 구문 분석기를보다 쉽게 ​​개발할 수 있지만 AST 노드에는 더 이상 &lt;code&gt;leadingComments&lt;/code&gt; 및 &lt;code&gt;trailingComments&lt;/code&gt; 특성 이 없습니다 . 개념적으로, 규칙 작성자는 이제 AST 노드가 아닌 토큰 컨텍스트에서 주석을 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f714d17f0050b761984997f366964ef0c19b70" translate="yes" xml:space="preserve">
          <source>In 4.0.0, the &lt;code&gt;indent&lt;/code&gt; rule has been rewritten. The new version of the rule will report some indentation errors that the old version of the rule did not catch. Additionally, the indentation of &lt;code&gt;MemberExpression&lt;/code&gt; nodes, function parameters, and function arguments will now be checked by default (it was previously ignored by default for backwards compatibility).</source>
          <target state="translated">4.0.0에서는 &lt;code&gt;indent&lt;/code&gt; 규칙이 다시 작성되었습니다. 새 버전의 규칙은 이전 버전의 규칙에서 포착하지 못한 일부 들여 쓰기 오류를보고합니다. 또한 &lt;code&gt;MemberExpression&lt;/code&gt; 노드, 함수 매개 변수 및 함수 인수 의 들여 쓰기 가 기본적으로 확인됩니다 (이전 버전과의 호환성을 위해 기본적으로 무시되었습니다).</target>
        </trans-unit>
        <trans-unit id="520e73186dae0d7b16f745db5f763187ed794910" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;ECMAScript&lt;/strong&gt; modules, which always have strict mode semantics, the directives are unnecessary.</source>
          <target state="translated">항상 엄격한 모드 의미가있는 &lt;strong&gt;ECMAScript&lt;/strong&gt; 모듈 에서는 지시문이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65d11792aba2f3af0b5566f3cb910f10a5d5d222" translate="yes" xml:space="preserve">
          <source>In April 2016, we &lt;a href=&quot;https://eslint.org/blog/2016/04/welcoming-jscs-to-eslint&quot;&gt;announced&lt;/a&gt; that the JSCS project was shutting down and the JSCS team would be joining the ESLint team. This guide is intended to help those who are using JSCS to migrate their settings and projects to use ESLint. We've tried to automate as much of the conversion as possible, but there are some manual changes that are needed.</source>
          <target state="translated">년 4 월 2016 년, 우리는 &lt;a href=&quot;https://eslint.org/blog/2016/04/welcoming-jscs-to-eslint&quot;&gt;발표&lt;/a&gt; JSCS 프로젝트가 종료되었으며 JSCS 팀이 ESLint 팀에 합류 할 것이다. 이 안내서는 JSCS를 사용하여 설정 및 프로젝트를 마이그레이션하여 ESLint를 사용하는 사람들을 돕기 위해 작성되었습니다. Google은 최대한 많은 전환을 자동화하려고했지만 몇 가지 수동 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b23708a1c68d550b884d817586351e04c0ec1e6b" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5.1, &lt;code&gt;Object.create&lt;/code&gt; was added, which enables the creation of objects with a specified &lt;code&gt;[[Prototype]]&lt;/code&gt;. &lt;code&gt;Object.create(null)&lt;/code&gt; is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from &lt;code&gt;Object.prototype&lt;/code&gt;. This rule prevents calling some &lt;code&gt;Object.prototype&lt;/code&gt; methods directly from an object.</source>
          <target state="translated">ECMAScript 5.1에는 &lt;code&gt;Object.create&lt;/code&gt; 가 추가되어 지정된 &lt;code&gt;[[Prototype]]&lt;/code&gt; 으로 객체를 만들 수 있습니다 . &lt;code&gt;Object.create(null)&lt;/code&gt; 는 맵으로 사용될 객체를 만드는 데 사용되는 일반적인 패턴입니다. 객체에 &lt;code&gt;Object.prototype&lt;/code&gt; 의 속성이 있다고 가정하면 오류가 발생할 수 있습니다 . 이 규칙 은 개체에서 일부 &lt;code&gt;Object.prototype&lt;/code&gt; 메서드를 직접 호출하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="425012cd9483a50d08725272bb44280b01fa5c2b" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6) or later, if you don't want to be notified about &lt;code&gt;Function.prototype.apply()&lt;/code&gt; callings, you can safely disable this rule.</source>
          <target state="translated">나중에 ES2015 (ES6) 또는, 당신에 대해 알림을 받고 싶지 않으면 &lt;code&gt;Function.prototype.apply()&lt;/code&gt; 부름 안전하게이 규칙을 사용하지 않도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7288feb7f3cbe9e2c5aa84dc1b8995f09043f354" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6) or later, if you don't want to be notified about &lt;code&gt;arguments&lt;/code&gt; variables, then it's safe to disable this rule.</source>
          <target state="translated">ES2015 (ES6) 이상에서 &lt;code&gt;arguments&lt;/code&gt; 변수 에 대한 알림을받지 않으려면 이 규칙을 사용하지 않는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="c6e27cc5398617c234e14f6fdd9c136c292789aa" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6) or later, if you don't want to be notified about duplicate names in class members, you can safely disable this rule.</source>
          <target state="translated">ES2015 (ES6) 이상에서 클래스 구성원의 중복 이름에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0ab634b81ee05b23f8702255df744fed8eb12f" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6) or later, if you don't want to be notified about places where Reflect could be used, you can safely disable this rule.</source>
          <target state="translated">ES2015 (ES6) 이상에서 Reflect를 사용할 수있는 장소에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2eb7a2147b19e9a68b53dd99798118a281e8775" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6) or later, if you don't want to be notified about string concatenation, you can safely disable this rule.</source>
          <target state="translated">ES2015 (ES6) 이상에서 문자열 연결에 대한 알림을받지 않으려면이 규칙을 안전하게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79284304dcf5a3c4453db8bcc5a3d21330ba7616" translate="yes" xml:space="preserve">
          <source>In ES2015 (ES6), we can use template literals instead of string concatenation.</source>
          <target state="translated">ES2015 (ES6)에서는 문자열 연결 대신 템플릿 리터럴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c45a211d3e50a5f07def68689fe81ce6f3396159" translate="yes" xml:space="preserve">
          <source>In ES2015, one can use spread syntax to call variadic functions.</source>
          <target state="translated">ES2015에서는 분산 구문을 사용하여 가변 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76009c166d3d239347600943770e4ce17bd2a6bd" translate="yes" xml:space="preserve">
          <source>In ES6+ environments that allow the use of function expressions when describing callbacks or function arguments.</source>
          <target state="translated">콜백 또는 함수 인수를 설명 할 때 함수 표현식을 사용할 수있는 ES6 + 환경에서.</target>
        </trans-unit>
        <trans-unit id="d6e9567bb6bc4821161b78d2c46b2c8ee02a2b83" translate="yes" xml:space="preserve">
          <source>In ES6, block-level bindings (&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) introduce a &quot;temporal dead zone&quot; where a &lt;code&gt;ReferenceError&lt;/code&gt; will be thrown with any attempt to access the variable before its declaration.</source>
          <target state="translated">ES6에서 블록 레벨 바인딩 ( &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; ) 은 선언하기 전에 변수에 액세스하려고 하면 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생 하는 &quot;임시 데드 존&quot;을 도입합니다 .</target>
        </trans-unit>
        <trans-unit id="3c283b77541c32dd8ff6097bc78fb8ab4c5daff4" translate="yes" xml:space="preserve">
          <source>In ES6, code blocks may create a new scope if a block-level binding (&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;), a class declaration or a function declaration (in strict mode) are present. A block is not considered redundant in these cases.</source>
          <target state="translated">ES6에서, 블록 레벨 바인딩 ( &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; ), 클래스 선언 또는 함수 선언 (엄격 모드)이 존재 하면 코드 블록은 새로운 범위를 생성 할 수 있습니다 . 이 경우 블록은 중복으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5f75e3e4423421f164920649e64e4ef38d574fa" translate="yes" xml:space="preserve">
          <source>In ESLint v5, an unsuccessful linting run due to a fatal error will result in an exit code of 2, rather than 1.</source>
          <target state="translated">ESLint v5에서 치명적인 오류로 인해 실패한 Linting 실행이 실패하면 종료 코드가 1이 아닌 2가됩니다.</target>
        </trans-unit>
        <trans-unit id="eea08ca030095038bf25a737549a277fbe3aba08" translate="yes" xml:space="preserve">
          <source>In ESLint v5, reporting a problem without providing a message always results in an error.</source>
          <target state="translated">ESLint v5에서 메시지를 제공하지 않고 문제를보고하면 항상 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14faa4b6b34ee8eda4c12e45811ba40e9496a537" translate="yes" xml:space="preserve">
          <source>In ESLint v5, the &lt;code&gt;context.getScope()&lt;/code&gt; method has the same behavior regardless of &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; and returns the proper scope. See &lt;a href=&quot;../developer-guide/working-with-rules#contextgetscope&quot;&gt;the documentation&lt;/a&gt; for more details on which scopes are returned.</source>
          <target state="translated">ESLint v5에서 &lt;code&gt;context.getScope()&lt;/code&gt; 메서드는 &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; 에 관계없이 동일한 동작을 가지며 적절한 범위를 반환합니다. 참조 &lt;a href=&quot;../developer-guide/working-with-rules#contextgetscope&quot;&gt;문서&lt;/a&gt; 범위가 반환되는 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="bb1ef5c27afbdde2e7a8e173d72c21f7e3ae1a66" translate="yes" xml:space="preserve">
          <source>In ESLint v5, the &lt;code&gt;parent&lt;/code&gt; property is set on all AST nodes before any rules have access to the AST. This makes it easier to write some rules, because the &lt;code&gt;parent&lt;/code&gt; property is always available rather than being mutated behind the scenes. However, as a side-effect of having &lt;code&gt;parent&lt;/code&gt; properties, the AST object has a circular structure the first time a rule sees it (previously, it only had a circular structure after the first rule listeners were called). As a result, a custom rule that enumerates all properties of a node in order to traverse the AST might now loop forever or run out of memory if it does not check for cycles properly.</source>
          <target state="translated">ESLint v5에서 &lt;code&gt;parent&lt;/code&gt; 속성은 규칙이 AST에 액세스하기 전에 모든 AST 노드에 설정됩니다. 따라서 &lt;code&gt;parent&lt;/code&gt; 속성을 씬 뒤에서 변경하지 않고 항상 사용할 수 있기 때문에 일부 규칙을보다 쉽게 ​​작성할 수 있습니다. 그러나 &lt;code&gt;parent&lt;/code&gt; 속성 을 갖는 부작용으로 AST 객체는 규칙을 처음 볼 때 원형 구조를 갖습니다 (이전에는 첫 번째 규칙 리스너가 호출 된 후 원형 구조 만 있음). 결과적으로, AST를 순회하기 위해 노드의 모든 속성을 열거하는 사용자 지정 규칙은 사이클을 올바르게 확인하지 않으면 영원히 반복되거나 메모리가 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02e6562154408a0cd95ff399370b02dae59011b9" translate="yes" xml:space="preserve">
          <source>In ESLint v5, the default parser will now always give the &lt;code&gt;...data&lt;/code&gt; AST node the &lt;code&gt;RestElement&lt;/code&gt; type, even if the (now deprecated) &lt;a href=&quot;#experimental-object-rest-spread&quot;&gt;&lt;code&gt;experimentalObjectRestSpread&lt;/code&gt;&lt;/a&gt; option is enabled. This makes the AST compliant with the current ESTree spec.</source>
          <target state="translated">ESLint v5에서 기본 파서는 이제 (현재 사용되지 않는) &lt;a href=&quot;#experimental-object-rest-spread&quot;&gt; &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; &lt;/a&gt; 옵션이 활성화 된 경우에도 &lt;code&gt;...data&lt;/code&gt; AST 노드에 &lt;code&gt;RestElement&lt;/code&gt; 유형을 제공합니다 . 이로 인해 AST는 현재 ESTree 사양을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="31a881cb748835a072bf8830b1288b7196f3ecf5" translate="yes" xml:space="preserve">
          <source>In ESLint v5, the default parser will now always give the &lt;code&gt;...data&lt;/code&gt; AST node the &lt;code&gt;SpreadElement&lt;/code&gt; type, even if the (now deprecated) &lt;a href=&quot;#experimental-object-rest-spread&quot;&gt;&lt;code&gt;experimentalObjectRestSpread&lt;/code&gt;&lt;/a&gt; option is enabled. This makes the AST compliant with the current ESTree spec.</source>
          <target state="translated">ESLint v5에서 기본 파서는 이제 (현재 사용되지 않는) &lt;a href=&quot;#experimental-object-rest-spread&quot;&gt; &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; &lt;/a&gt; 옵션이 활성화 된 경우에도 &lt;code&gt;...data&lt;/code&gt; AST 노드에 &lt;code&gt;SpreadElement&lt;/code&gt; 유형을 제공합니다 . 이로 인해 AST는 현재 ESTree 사양을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="d4431524bfd5c4f07af8235581cb94fca4ff8732" translate="yes" xml:space="preserve">
          <source>In ESLint v6, &lt;code&gt;Linter&lt;/code&gt; will no longer perform any filesystem operations, including loading parsers.</source>
          <target state="translated">ESLint v6에서 &lt;code&gt;Linter&lt;/code&gt; 는 파서 로딩을 포함하여 더 이상 파일 시스템 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf67a660608cd3e1668cf8ebedf7ff745592d095" translate="yes" xml:space="preserve">
          <source>In ESLint v6.0.0, a parent config always has precedence over extended configs, even with &lt;code&gt;overrides&lt;/code&gt; blocks.</source>
          <target state="translated">ESLint v6.0.0에서 상위 구성은 &lt;code&gt;overrides&lt;/code&gt; 블록을 사용 하더라도 확장 구성보다 항상 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="c8abbd9afcc5de245675ea3f2aa4947437c8ef25" translate="yes" xml:space="preserve">
          <source>In ESLint, there's a similar option when you use &lt;code&gt;--init&lt;/code&gt;. Just select &quot;Inspect your JavaScript file(s)&quot;:</source>
          <target state="translated">ESLint에는 &lt;code&gt;--init&lt;/code&gt; 를 사용할 때 비슷한 옵션이 있습니다 . &quot;자바 스크립트 파일 검사&quot;를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5b59c31296d60785bf4dae3841ef03bc4bd1dfda" translate="yes" xml:space="preserve">
          <source>In ESLint, you can also pipe in code, but you need to use the &lt;code&gt;--stdin&lt;/code&gt; flag:</source>
          <target state="translated">ESLint에서는 코드를 파이프 할 수도 있지만 &lt;code&gt;--stdin&lt;/code&gt; 플래그 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acd5139582c073618b8ef6f0a7ca63779857d618" translate="yes" xml:space="preserve">
          <source>In IE 8 and earlier, the catch clause parameter can overwrite the value of a variable in the outer scope, if that variable has the same name as the catch clause parameter.</source>
          <target state="translated">IE 8 및 이전 버전에서는 catch 절 매개 변수와 이름이 같은 변수 인 경우 catch 절 매개 변수가 외부 범위의 변수 값을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2adf1aee416a521238a7c811bd9bd2ecf5e14167" translate="yes" xml:space="preserve">
          <source>In JSCS, you can pipe code in like this:</source>
          <target state="translated">JSCS에서는 다음과 같이 코드를 파이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3703d4c15bc56ac828c52126bdc5c7540593b23a" translate="yes" xml:space="preserve">
          <source>In JSON:</source>
          <target state="translated">JSON에서 :</target>
        </trans-unit>
        <trans-unit id="a82e67122ca4aaac99057c3557502dcfc9509e84" translate="yes" xml:space="preserve">
          <source>In JavaScript that is designed to be executed in the browser, it's considered a best practice to avoid using methods on &lt;code&gt;console&lt;/code&gt;. Such messages are considered to be for debugging purposes and therefore not suitable to ship to the client. In general, calls using &lt;code&gt;console&lt;/code&gt; should be stripped before being pushed to production.</source>
          <target state="translated">브라우저에서 실행되도록 설계된 JavaScript에서는 &lt;code&gt;console&lt;/code&gt; 에서 메소드를 사용하지 않는 것이 가장 좋습니다 . 이러한 메시지는 디버깅 목적으로 간주되므로 클라이언트에 전달하기에 적합하지 않습니다. 일반적으로 &lt;code&gt;console&lt;/code&gt; 을 사용하는 통화 는 프로덕션으로 푸시하기 전에 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="e26a4ff80b5f3f66c04e4918b45e8756a1c26153" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;NaN&lt;/code&gt; is a special value of the &lt;code&gt;Number&lt;/code&gt; type. It's used to represent any of the &quot;not-a-number&quot; values represented by the double-precision 64-bit format as specified by the IEEE Standard for Binary Floating-Point Arithmetic.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;Number&lt;/code&gt; 유형 의 특수 값입니다 . 이진 부동 소수점 산술에 대한 IEEE 표준에 지정된 배정도 64 비트 형식으로 표시되는 &quot;숫자가 아닌&quot;값을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd2fc151901451626280161ac11b4b93b4b50fd" translate="yes" xml:space="preserve">
          <source>In JavaScript, a variable that is declared and not initialized to any value automatically gets the value of &lt;code&gt;undefined&lt;/code&gt;. For example:</source>
          <target state="translated">JavaScript에서 선언되고 값으로 초기화되지 않은 변수는 자동으로 &lt;code&gt;undefined&lt;/code&gt; 값을 가져옵니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b60aba9b6eda269c9c92c576d2d7b17436dc1a04" translate="yes" xml:space="preserve">
          <source>In JavaScript, it's possible to redeclare the same variable name using &lt;code&gt;var&lt;/code&gt;. This can lead to confusion as to where the variable is actually declared and initialized.</source>
          <target state="translated">JavaScript에서는 &lt;code&gt;var&lt;/code&gt; 를 사용하여 동일한 변수 이름을 다시 선언 할 수 있습니다 . 변수가 실제로 선언되고 초기화되는 위치가 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3ae9da35b031e6fe272d750d08d43b247a9241" translate="yes" xml:space="preserve">
          <source>In JavaScript, one can access properties using the dot notation (&lt;code&gt;foo.bar&lt;/code&gt;) or square-bracket notation (&lt;code&gt;foo[&quot;bar&quot;]&lt;/code&gt;). However, the dot notation is often preferred because it is easier to read, less verbose, and works better with aggressive JavaScript minimizers.</source>
          <target state="translated">JavaScript에서는 도트 표기법 ( &lt;code&gt;foo.bar&lt;/code&gt; ) 또는 대괄호 표기법 ( &lt;code&gt;foo[&quot;bar&quot;]&lt;/code&gt; )을 사용하여 속성에 액세스 할 수 있습니다 . 그러나, 점 표기법은 읽기 쉽고, 덜 장황하며, 공격적인 JavaScript 최소화 프로그램으로 더 잘 작동하기 때문에 종종 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="79c19c72e76be7de1e81564fdd907fa54ae18eb9" translate="yes" xml:space="preserve">
          <source>In JavaScript, prior to ES6, a function declaration is only allowed in the first level of a program or the body of another function, though parsers sometimes &lt;a href=&quot;https://code.google.com/p/esprima/issues/detail?id=422&quot;&gt;erroneously accept them elsewhere&lt;/a&gt;. This only applies to function declarations; named or anonymous function expressions can occur anywhere an expression is permitted.</source>
          <target state="translated">JavaScript에서 ES6 이전에는 함수 선언이 프로그램의 첫 번째 레벨 또는 다른 함수의 본문에서만 허용되지만 파서는 때때로 &lt;a href=&quot;https://code.google.com/p/esprima/issues/detail?id=422&quot;&gt;다른 곳에서 잘못 허용합니다&lt;/a&gt; . 이것은 함수 선언에만 적용됩니다. 명명 된 함수 또는 익명 함수 식은식이 허용되는 모든 곳에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="803af5f5d14791d201ae8d61d435f1c64184268e" translate="yes" xml:space="preserve">
          <source>In JavaScript, prior to ES6, standalone code blocks delimited by curly braces do not create a new scope and have no use. For example, these curly braces do nothing to &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">JavaScript에서 ES6 이전에는 중괄호로 구분 된 독립형 코드 블록은 새 범위를 작성하지 않으며 사용하지 않습니다. 예를 들어,이 중괄호는 &lt;code&gt;foo&lt;/code&gt; 에 아무 작업도 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c8e0cb0f20079a63c0ebee7c35d2763450e0da3b" translate="yes" xml:space="preserve">
          <source>In JavaScript, prior to ES6, variable and function declarations are hoisted to the top of a scope, so it's possible to use identifiers before their formal declarations in code. This can be confusing and some believe it is best to always declare variables and functions before using them.</source>
          <target state="translated">JavaScript에서 ES6 이전에는 변수 및 함수 선언이 범위의 맨 위에 오기 때문에 코드에서 공식 선언 전에 식별자를 사용할 수 있습니다. 이것은 혼란스럽고 일부는 사용하기 전에 항상 변수와 함수를 선언하는 것이 가장 좋다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="1823798885782ba7322754df0cb99b7b3ed765ea" translate="yes" xml:space="preserve">
          <source>In JavaScript, returning a value in the constructor of a class may be a mistake. Forbidding this pattern prevents mistakes resulting from unfamiliarity with the language or a copy-paste error.</source>
          <target state="translated">JavaScript에서 클래스 생성자에 값을 반환하는 것은 실수 일 수 있습니다. 이 패턴을 사용하지 않으면 언어에 익숙하지 않거나 복사-붙여 넣기 오류로 인한 실수를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5dbdb528c78d6964e655c920b5562c6ac7357b6" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are a lot of different ways to convert value types. Some of them might be hard to read and understand.</source>
          <target state="translated">JavaScript에는 값 유형을 변환하는 다양한 방법이 있습니다. 그들 중 일부는 읽고 이해하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f85fcb870ec98a4b8e042f1f4f7d1ee7d391150" translate="yes" xml:space="preserve">
          <source>In JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement. For example, in the following code, &lt;code&gt;foo&lt;/code&gt; is initialized during declaration, while &lt;code&gt;bar&lt;/code&gt; is initialized later.</source>
          <target state="translated">JavaScript에서 변수는 선언하는 동안 또는 이후에 지정 문을 사용하여 언제든지 지정할 수 있습니다. 예를 들어 다음 코드 에서 선언 중에 &lt;code&gt;foo&lt;/code&gt; 가 초기화되고 나중에 &lt;code&gt;bar&lt;/code&gt; 가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f2431e0c54f3ccddb9b8b55c40ef110d03001a01" translate="yes" xml:space="preserve">
          <source>In JavaScript, you can extend any object, including builtin or &quot;native&quot; objects. Sometimes people change the behavior of these native objects in ways that break the assumptions made about them in other parts of the code.</source>
          <target state="translated">JavaScript에서는 내장 또는 &quot;기본&quot;객체를 포함하여 모든 객체를 확장 할 수 있습니다. 때로는 사람들이 코드의 다른 부분에서 가정에 대한 가정을 어기는 방식으로 이러한 기본 객체의 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5e343893daa54be7d2e9b003885e6efda1094561" translate="yes" xml:space="preserve">
          <source>In Node.js, a common pattern for dealing with asynchronous behavior is called the callback pattern. This pattern expects an &lt;code&gt;Error&lt;/code&gt; object or &lt;code&gt;null&lt;/code&gt; as the first argument of the callback. Forgetting to handle these errors can lead to some really strange behavior in your application.</source>
          <target state="translated">Node.js에서는 비동기 동작을 처리하기위한 공통 패턴을 콜백 패턴이라고합니다. 이 패턴은 &lt;code&gt;Error&lt;/code&gt; 객체 또는 콜백의 첫 번째 인수로 &lt;code&gt;null&lt;/code&gt; 을 예상합니다 . 이러한 오류를 처리하지 않으면 응용 프로그램에서 실제로 이상한 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e83e14b97a21dfc3164689e39c9953204a0216" translate="yes" xml:space="preserve">
          <source>In Node.js, module dependencies are included using the &lt;code&gt;require()&lt;/code&gt; function, such as:</source>
          <target state="translated">Node.js에서 &lt;code&gt;require()&lt;/code&gt; 함수를 사용하여 모듈 종속성이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eec858697f015c807640f5be285c6675cc7d8cf3" translate="yes" xml:space="preserve">
          <source>In Node.js, most I/O is done through asynchronous methods. However, there are often synchronous versions of the asynchronous methods. For example, &lt;code&gt;fs.exists()&lt;/code&gt; and &lt;code&gt;fs.existsSync()&lt;/code&gt;. In some contexts, using synchronous operations is okay (if, as with ESLint, you are writing a command line utility). However, in other contexts the use of synchronous operations is considered a bad practice that should be avoided. For example, if you are running a high-travel web server on Node.js, you should consider carefully if you want to allow any synchronous operations that could lock up the server.</source>
          <target state="translated">Node.js에서 대부분의 I / O는 비동기 메소드를 통해 수행됩니다. 그러나 종종 비동기 메소드의 동기 버전이 있습니다. 예를 들어, &lt;code&gt;fs.exists()&lt;/code&gt; 및 &lt;code&gt;fs.existsSync()&lt;/code&gt; 입니다. 일부 상황에서는 동기 작업을 사용하는 것이 좋습니다 (ESLint와 마찬가지로 명령 줄 유틸리티를 작성하는 경우). 그러나 다른 상황에서는 동기 작업 사용을 피해야하는 나쁜 습관으로 간주합니다. 예를 들어, Node.js에서 고급 웹 서버를 실행중인 경우 서버를 잠글 수있는 동기 조작을 허용하려면 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fb05857d9c01ca30417b8554d82f2317ca35e6b" translate="yes" xml:space="preserve">
          <source>In Node.js, the &lt;code&gt;__dirname&lt;/code&gt; and &lt;code&gt;__filename&lt;/code&gt; global variables contain the directory path and the file path of the currently executing script file, respectively. Sometimes, developers try to use these variables to create paths to other files, such as:</source>
          <target state="translated">Node.js에서 &lt;code&gt;__dirname&lt;/code&gt; 및 &lt;code&gt;__filename&lt;/code&gt; 전역 변수에는 각각 현재 실행중인 스크립트 파일의 디렉토리 경로 및 파일 경로가 포함됩니다. 때때로 개발자는 이러한 변수를 사용하여 다음과 같은 다른 파일의 경로를 만들려고합니다.</target>
        </trans-unit>
        <trans-unit id="986462bdb57daa520d17d6d171bfef6c12a9e4c1" translate="yes" xml:space="preserve">
          <source>In Node.js, the behavior of the &lt;code&gt;Buffer&lt;/code&gt; constructor is different depending on the type of its argument. Passing an argument from user input to &lt;code&gt;Buffer()&lt;/code&gt; without validating its type can lead to security vulnerabilities such as remote memory disclosure and denial of service. As a result, the &lt;code&gt;Buffer&lt;/code&gt; constructor has been deprecated and should not be used. Use the producer methods &lt;code&gt;Buffer.from&lt;/code&gt;, &lt;code&gt;Buffer.alloc&lt;/code&gt;, and &lt;code&gt;Buffer.allocUnsafe&lt;/code&gt; instead.</source>
          <target state="translated">Node.js에서 &lt;code&gt;Buffer&lt;/code&gt; 생성자 의 동작은 인수 유형에 따라 다릅니다. 형식을 확인하지 않고 사용자 입력에서 &lt;code&gt;Buffer()&lt;/code&gt; 로 인수를 전달하면 원격 메모리 공개 및 서비스 거부와 같은 보안 취약점이 발생할 수 있습니다. 결과적으로 &lt;code&gt;Buffer&lt;/code&gt; 생성자는 더 이상 사용되지 않으므로 사용해서는 안됩니다. 대신 생산자 메소드 &lt;code&gt;Buffer.from&lt;/code&gt; , &lt;code&gt;Buffer.alloc&lt;/code&gt; 및 &lt;code&gt;Buffer.allocUnsafe&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01b5e11bafdf37ab445e4c84a4053b58bfebcbed" translate="yes" xml:space="preserve">
          <source>In a codebase that has both strict and non-strict code, either turn this rule off, or &lt;a href=&quot;../user-guide/configuring&quot;&gt;selectively disable it&lt;/a&gt; where necessary. For example, functions referencing &lt;code&gt;arguments.callee&lt;/code&gt; are invalid in strict mode. A &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode#Differences_from_non-strict_to_strict&quot;&gt;full list of strict mode differences&lt;/a&gt; is available on MDN.</source>
          <target state="translated">엄격한 코드와 엄격하지 않은 코드가 모두있는 코드베이스에서이 규칙을 끄거나 필요한 경우 &lt;a href=&quot;../user-guide/configuring&quot;&gt;선택적으로 비활성화하십시오&lt;/a&gt; . 예를 들어 &lt;code&gt;arguments.callee&lt;/code&gt; 를 참조하는 함수 는 엄격 모드에서는 유효하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode#Differences_from_non-strict_to_strict&quot;&gt;엄격한 모드 차이&lt;/a&gt; 의 전체 목록은 MDN에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ce8149f3ae92cb0fb6941142cf5493644f910b" translate="yes" xml:space="preserve">
          <source>In a custom rule or plugin, you can omit &lt;code&gt;docs&lt;/code&gt; or include any properties that you need in it.</source>
          <target state="translated">사용자 정의 규칙 또는 플러그인에서 &lt;code&gt;docs&lt;/code&gt; 를 생략 하거나 필요한 속성을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72c9201ea52e4b148492fb5b692b369da55a6f80" translate="yes" xml:space="preserve">
          <source>In addition to any patterns in a &lt;code&gt;.eslintignore&lt;/code&gt; file, ESLint always ignores files in &lt;code&gt;/node_modules/*&lt;/code&gt; and &lt;code&gt;/bower_components/*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.eslintignore&lt;/code&gt; 는 .eslintignore 파일의 패턴 외에도 &lt;code&gt;/node_modules/*&lt;/code&gt; 및 &lt;code&gt;/bower_components/*&lt;/code&gt; 의 파일을 항상 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="fc12ca84af3f6382d0762d431b9d50690920ac41" translate="yes" xml:space="preserve">
          <source>In addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their codebase may not want to apply this rule if the cost of migrating from &lt;code&gt;var&lt;/code&gt; to &lt;code&gt;let&lt;/code&gt; is too costly.</source>
          <target state="translated">ES6 이외의 환경 외에도 ES6를 코드베이스에 도입하기 시작한 기존 JavaScript 프로젝트는 &lt;code&gt;var&lt;/code&gt; 에서 &lt;code&gt;let&lt;/code&gt; 으로 마이그레이션하는 비용 이 너무 비싸면이 규칙을 적용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1150e19bd11cdc7072eeae11448462abf32644f" translate="yes" xml:space="preserve">
          <source>In addition to the above, there is currently a proposal to add object rest and spread properties to the spec. They can be used as follows:</source>
          <target state="translated">위의 사항 외에도 현재 오브젝트 레스트를 추가하고 스펙에 특성을 분산시키는 제안이 있습니다. 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252f70da347da561455e66862058935add889d81" translate="yes" xml:space="preserve">
          <source>In addition to the properties above, invalid test cases can also have the following properties:</source>
          <target state="translated">위의 속성 외에도 잘못된 테스트 사례에는 다음과 같은 속성이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1712f8c3199dccd12aeedb6949eed21b105861f8" translate="yes" xml:space="preserve">
          <source>In case of &lt;code&gt;&quot;always&quot;&lt;/code&gt; option, set an exception to &lt;code&gt;false&lt;/code&gt; to enable it:</source>
          <target state="translated">의 경우 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 에 예외를 설정 옵션, &lt;code&gt;false&lt;/code&gt; 을 활성화하기 :</target>
        </trans-unit>
        <trans-unit id="7e2e3e9f152c06b2ea5727f6f3c6e80f43018dd6" translate="yes" xml:space="preserve">
          <source>In case of &lt;code&gt;&quot;never&quot;&lt;/code&gt; option, set an exception to &lt;code&gt;true&lt;/code&gt; to enable it:</source>
          <target state="translated">의 경우 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 옵션에 예외를 설정 &lt;code&gt;true&lt;/code&gt; 을 활성화하기 :</target>
        </trans-unit>
        <trans-unit id="92c16a623230638ab21900e3843f89d1124021ce" translate="yes" xml:space="preserve">
          <source>In conditional statements, it is very easy to mistype a comparison operator (such as &lt;code&gt;==&lt;/code&gt;) as an assignment operator (such as &lt;code&gt;=&lt;/code&gt;). For example:</source>
          <target state="translated">조건문에서 비교 연산자 (예 : &lt;code&gt;==&lt;/code&gt; )를 대입 연산자 (예 : &lt;code&gt;=&lt;/code&gt; ) 로 잘못 입력하는 것은 매우 쉽습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb410a3ea7892596a7988ae7c901cf7e2882ac6" translate="yes" xml:space="preserve">
          <source>In contexts such as an &lt;code&gt;if&lt;/code&gt; statement's test where the result of the expression will already be coerced to a Boolean, casting to a Boolean via double negation (&lt;code&gt;!!&lt;/code&gt;) or a &lt;code&gt;Boolean&lt;/code&gt; call is unnecessary. For example, these &lt;code&gt;if&lt;/code&gt; statements are equivalent:</source>
          <target state="translated">식의 결과가 이미 부울로 강제 변환 되는 &lt;code&gt;if&lt;/code&gt; 문의 테스트 와 같은 상황에서는 이중 부정 ( &lt;code&gt;!!&lt;/code&gt; ) 또는 &lt;code&gt;Boolean&lt;/code&gt; 호출을 통해 부울로 캐스팅 할 필요가 없습니다. 예를 들어 다음 &lt;code&gt;if&lt;/code&gt; 문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c8599f68059b0b2f8fbd7472705607eace6b16b0" translate="yes" xml:space="preserve">
          <source>In each case, the settings in the configuration file override default settings.</source>
          <target state="translated">각각의 경우 구성 파일의 설정이 기본 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="649357e05b50e25c812fc667d0a51838efee7ebc" translate="yes" xml:space="preserve">
          <source>In each of the following examples, the &lt;code&gt;&quot;always&quot;&lt;/code&gt; option is assumed.</source>
          <target state="translated">다음 각 예에서 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 옵션이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ab58973a1b0451e64158fd130c4275226ff167" translate="yes" xml:space="preserve">
          <source>In environments outside of CommonJS or ECMAScript modules, you may use &lt;code&gt;var&lt;/code&gt; to create a global variable that may be used by other scripts. You can use the &lt;code&gt;/* exported variableName */&lt;/code&gt; comment block to indicate that this variable is being exported and therefore should not be considered unused.</source>
          <target state="translated">CommonJS 또는 ECMAScript 모듈 외부의 환경에서 &lt;code&gt;var&lt;/code&gt; 를 사용하여 다른 스크립트에서 사용할 수있는 전역 변수를 작성할 수 있습니다. 당신은 사용할 수 있습니다 &lt;code&gt;/* exported variableName */&lt;/code&gt; 이 변수가 수출되고 있으며, 따라서 사용되지 않는 것으로 간주되어서는 안된다는 표시하는 주석 블록을.</target>
        </trans-unit>
        <trans-unit id="f39532fe56426ff07a71783a151b540911e49b3c" translate="yes" xml:space="preserve">
          <source>In environments that have not yet adopted ES6 language features (ES3/5).</source>
          <target state="translated">아직 ES6 언어 기능을 채택하지 않은 환경 (ES3 / 5).</target>
        </trans-unit>
        <trans-unit id="1a2489feba41fd4a92ae4a53d0b6dbcbf4bb794f" translate="yes" xml:space="preserve">
          <source>In general, ESLint core rules must be:</source>
          <target state="translated">일반적으로 ESLint 핵심 규칙은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="730c374622cf98488a7fb84f8403c25862d877fe" translate="yes" xml:space="preserve">
          <source>In general, no comment style is any more or less valid than any others, but many developers would agree that a consistent style can improve a project's maintainability.</source>
          <target state="translated">일반적으로 어떤 주석 스타일도 다른 스타일보다 유효하지 않지만 많은 개발자는 일관성있는 스타일이 프로젝트의 유지 관리 성을 향상시킬 수 있다는 데 동의합니다.</target>
        </trans-unit>
        <trans-unit id="f2dd07b1a4b0ae05f069e2c86041c05b70c13a77" translate="yes" xml:space="preserve">
          <source>In many cases the iterations of a loop are not actually independent of each-other. For example, the output of one iteration might be used as the input to another. Or, loops may be used to retry asynchronous operations that were unsuccessful. Or, loops may be used to prevent your code from sending an excessive amount of requests in parallel. In such cases it makes sense to use &lt;code&gt;await&lt;/code&gt; within a loop and it is recommended to disable the rule via a standard ESLint disable comment.</source>
          <target state="translated">많은 경우 루프의 반복은 실제로 서로 독립적이지 않습니다. 예를 들어, 한 반복의 출력이 다른 반복의 입력으로 사용될 수 있습니다. 또는 성공하지 못한 비동기 작업을 재 시도하는 데 루프를 사용할 수 있습니다. 또는 루프를 사용하여 코드가 과도한 양의 요청을 병렬로 보내지 못하게 할 수 있습니다. 이러한 경우 루프 내에서 &lt;code&gt;await&lt;/code&gt; 를 사용하는 것이 합리적 이며 표준 ESLint disable comment를 통해 규칙을 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e48107c6c8896cdcfc7e1315abb4322178c42a2" translate="yes" xml:space="preserve">
          <source>In many cases, it doesn't matter if you choose to use an identifier instead of a string or vice-versa. Even so, you might decide to enforce a consistent style in your code.</source>
          <target state="translated">대부분의 경우 문자열 대신 식별자를 사용하도록 선택하거나 그 반대의 경우에는 중요하지 않습니다. 그럼에도 불구하고 코드에서 일관된 스타일을 적용하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a474ea154ff40cc0c6e94f8cbfb8cf71fd96857f" translate="yes" xml:space="preserve">
          <source>In many cases, the empty object pattern is a mistake where the author intended to use a default value instead, such as:</source>
          <target state="translated">대부분의 경우 빈 객체 패턴은 작성자가 다음과 같이 기본값을 대신 사용하려는 실수입니다.</target>
        </trans-unit>
        <trans-unit id="f25b07254468f73077ad50b101b6ec3bb43ecd81" translate="yes" xml:space="preserve">
          <source>In more advanced cases where you really need to use the &lt;code&gt;Function&lt;/code&gt; constructor.</source>
          <target state="translated">보다 고급 인 경우에는 &lt;code&gt;Function&lt;/code&gt; 생성자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f1a46503feb2a904ba1391691b0681df116ea85" translate="yes" xml:space="preserve">
          <source>In object literal shorthand methods, spacing before the &lt;code&gt;*&lt;/code&gt; is not checked, as they lack a &lt;code&gt;function&lt;/code&gt; keyword.</source>
          <target state="translated">객체 리터럴 속기 방법에서 &lt;code&gt;function&lt;/code&gt; 키워드 가 없기 때문에 &lt;code&gt;*&lt;/code&gt; 앞에 간격 이 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8a619c7a6f45b45f93088c9ff495f0ed8669f1a" translate="yes" xml:space="preserve">
          <source>In order for a rule change to be accepted into ESLint, it must:</source>
          <target state="translated">규칙 변경 사항을 ESLint에 적용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="528b4219cc85dfb751a7dfd6e0385ac32c86b7cb" translate="yes" xml:space="preserve">
          <source>In order for a rule to be accepted in the ESLint core, it must:</source>
          <target state="translated">ESLint 코어에서 규칙을 승인하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1076911d7bc31ae6a22b80533fa7746bb73a1110" translate="yes" xml:space="preserve">
          <source>In order to avoid any confusion as to how to create the correct path, Node.js provides the &lt;code&gt;path&lt;/code&gt; module. This module uses system-specific information to always return the correct value. So you can rewrite the previous example as:</source>
          <target state="translated">올바른 경로를 만드는 방법에 대한 혼란을 피하기 위해 Node.js는 &lt;code&gt;path&lt;/code&gt; 모듈을 제공합니다 . 이 모듈은 시스템 특정 정보를 사용하여 항상 올바른 값을 반환합니다. 따라서 이전 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30dfaba2b526c5b26fe5ba2b4d9ad078d60be29f" translate="yes" xml:space="preserve">
          <source>In order to get the same functionality in ESLint, you would first need to install the &lt;code&gt;eslint-config-airbnb&lt;/code&gt; shareable config package:</source>
          <target state="translated">ESLint에서 동일한 기능을 사용하려면 먼저 &lt;code&gt;eslint-config-airbnb&lt;/code&gt; 공유 가능 구성 패키지 를 설치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="da327dc7b8895d9c2a799fa276a2c344a1fa9ef6" translate="yes" xml:space="preserve">
          <source>In order to make your plugin available to the community you have to publish it on npm.</source>
          <target state="translated">커뮤니티에서 플러그인을 사용하려면 npm에 플러그인을 게시해야합니다.</target>
        </trans-unit>
        <trans-unit id="f53a0ee7361f805bc70b82dd2bf7fd681d44bfa2" translate="yes" xml:space="preserve">
          <source>In order to provide suggestions, use the &lt;code&gt;suggest&lt;/code&gt; key in the report argument with an array of suggestion objects. The suggestion objects represent individual suggestions that could be applied and require either a &lt;code&gt;desc&lt;/code&gt; key string that describes what applying the suggestion would do or a &lt;code&gt;messageId&lt;/code&gt; key (see &lt;a href=&quot;#suggestion-messageids&quot;&gt;below&lt;/a&gt;), and a &lt;code&gt;fix&lt;/code&gt; key that is a function defining the suggestion result. This &lt;code&gt;fix&lt;/code&gt; function follows the same API as regular fixes (described above in &lt;a href=&quot;#applying-fixes&quot;&gt;applying fixes&lt;/a&gt;).</source>
          <target state="translated">제안 사항을 제공 하려면 보고서 인수 의 &lt;code&gt;suggest&lt;/code&gt; 키를 제안 사항 오브젝트 배열과 함께 사용하십시오 . 제안 개체는 적용될 수있는 개별 제안을 나타내며 제안을 적용하는 내용을 설명 하는 &lt;code&gt;desc&lt;/code&gt; 키 문자열 또는 &lt;code&gt;messageId&lt;/code&gt; 키 ( &lt;a href=&quot;#suggestion-messageids&quot;&gt;아래 참조&lt;/a&gt; )와 제안 결과를 정의하는 함수 인 &lt;code&gt;fix&lt;/code&gt; 키가 필요합니다. 이 &lt;code&gt;fix&lt;/code&gt; 함수는 일반 수정 사항과 동일한 API를 따릅니다 (위에서 &lt;a href=&quot;#applying-fixes&quot;&gt;수정 사항 적용에&lt;/a&gt; 설명 됨 ).</target>
        </trans-unit>
        <trans-unit id="c914896e68d128ecab267923570754040656a4ad" translate="yes" xml:space="preserve">
          <source>In order to submit code or documentation to an ESLint project, you will need to electronically sign our &lt;a href=&quot;https://cla.js.foundation/eslint/eslint&quot;&gt;Contributor License Agreement&lt;/a&gt;. The CLA is you giving us permission to use your contribution.</source>
          <target state="translated">ESLint 프로젝트에 코드 또는 문서를 제출하려면 &lt;a href=&quot;https://cla.js.foundation/eslint/eslint&quot;&gt;기고자 라이센스 계약서&lt;/a&gt; 에 전자 ​​서명해야합니다 . CLA는 귀하가 기부금을 사용할 수있는 권한을 귀하에게 부여합니다.</target>
        </trans-unit>
        <trans-unit id="ab1eb2b457b3afd52e3fa40c61b2b91f8e61a0a6" translate="yes" xml:space="preserve">
          <source>In order to use a local file as a custom formatter, you must begin the filename with a dot (such as &lt;code&gt;./my-awesome-formatter.js&lt;/code&gt; or &lt;code&gt;../formatters/my-awesome-formatter.js&lt;/code&gt;).</source>
          <target state="translated">로컬 파일을 사용자 정의 포맷터로 사용하려면 파일 이름을 점으로 시작해야합니다 (예 : &lt;code&gt;./my-awesome-formatter.js&lt;/code&gt; 또는 &lt;code&gt;../formatters/my-awesome-formatter.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe1c5d3210fe6c242e0968d6574611b5ef639ec0" translate="yes" xml:space="preserve">
          <source>In order to work with ESLint as a developer, it's recommended that:</source>
          <target state="translated">ESLint를 개발자로 사용하려면 다음을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="da54d53c92208bf53d5c67c558cd27c2431dde1d" translate="yes" xml:space="preserve">
          <source>In other words, if a property has a getter and a setter, the setter should be defined right after the getter, or vice versa.</source>
          <target state="translated">즉, 속성에 게터와 세터가있는 경우 게터 바로 다음에 세터를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bfb1d001512e3bd279cdd5b491a8cafde9ef9eb" translate="yes" xml:space="preserve">
          <source>In other words, it was possible to reference a rule from a scoped plugin (such as &lt;code&gt;foo/some-rule&lt;/code&gt;) without explicitly stating the &lt;code&gt;@my-organization&lt;/code&gt; scope. This was a bug because it could lead to ambiguous rule references if there was also an unscoped plugin called &lt;code&gt;eslint-plugin-foo&lt;/code&gt; loaded at the same time.</source>
          <target state="translated">즉, &lt;code&gt;@my-organization&lt;/code&gt; 범위 를 명시 적으로 지정하지 않고 범위 지정된 플러그인 (예 : &lt;code&gt;foo/some-rule&lt;/code&gt; ) 에서 규칙을 참조 할 수있었습니다 . &lt;code&gt;eslint-plugin-foo&lt;/code&gt; 라는 범위가 지정되지 않은 플러그인 이 동시에로드 된 경우 모호한 규칙 참조로 이어질 수 있기 때문에 버그였습니다 .</target>
        </trans-unit>
        <trans-unit id="2469f7b6a21432ad41d271440c98cea16a70b72b" translate="yes" xml:space="preserve">
          <source>In rare cases (if you were relying on the previous behavior where &lt;code&gt;eslint:recommended&lt;/code&gt; disables core rules), you might need to disable additional rules to restore the previous behavior.</source>
          <target state="translated">드문 경우이지만 &lt;code&gt;eslint:recommended&lt;/code&gt; 가 핵심 규칙을 비활성화 하는 이전 동작에 의존하는 경우 이전 동작 을 복원하기 위해 추가 규칙을 비활성화해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62940093175d70030e07910796a72fc9b37a5914" translate="yes" xml:space="preserve">
          <source>In rare cases where you really need identical test conditions in the same chain, which necessarily means that the expressions in the chain are causing and relying on side effects, you will have to turn this rule off.</source>
          <target state="translated">동일한 체인에서 동일한 테스트 조건이 실제로 필요한 경우는 드물지만 체인의 표현식이 부작용을 일으키고 의존한다는 것을 의미하므로이 규칙을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="79ead7da48164fbb99604c5811336f071bb53e52" translate="yes" xml:space="preserve">
          <source>In some cases fixes aren't appropriate to be automatically applied, for example, if a fix potentially changes functionality or if there are multiple valid ways to fix a rule depending on the implementation intent (see the best practices for &lt;a href=&quot;#applying-fixes&quot;&gt;applying fixes&lt;/a&gt; listed above). In these cases, there is an alternative &lt;code&gt;suggest&lt;/code&gt; option on &lt;code&gt;context.report()&lt;/code&gt; that allows other tools, such as editors, to expose helpers for users to manually apply a suggestion.</source>
          <target state="translated">예를 들어, 수정 사항이 잠재적으로 기능을 변경하거나 구현 의도에 따라 규칙을 수정하는 여러 가지 유효한 방법이있는 경우와 같이 수정 사항이 자동으로 적용하기에 적합하지 않은 경우가 있습니다 ( 위에 나열된 &lt;a href=&quot;#applying-fixes&quot;&gt;수정 사항 적용&lt;/a&gt; 우수 사례 참조 ). 이러한 경우 &lt;code&gt;context.report()&lt;/code&gt; 에는 다른 &lt;code&gt;suggest&lt;/code&gt; 도구 (예 : 편집기)가 사용자가 제안을 수동으로 적용 할 수 있도록 도우미를 노출시킬 수 있는 대체 제안 옵션 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="22ed0b0513e44ddddd0487035021c4a4d3ab12ff" translate="yes" xml:space="preserve">
          <source>In some cases, rule schemas can use the &lt;code&gt;default&lt;/code&gt; keyword to automatically specify default values for rule options. However, the &lt;code&gt;default&lt;/code&gt; keyword is only effective in certain schema locations, and is ignored elsewhere, which creates a risk of bugs if a rule incorrectly expects a default value to be provided as a rule option. In ESLint v6.0.0, &lt;code&gt;RuleTester&lt;/code&gt; will raise an error if a rule has an invalid &lt;code&gt;default&lt;/code&gt; keyword in its schema.</source>
          <target state="translated">경우에 따라 규칙 스키마는 &lt;code&gt;default&lt;/code&gt; 키워드를 사용하여 규칙 옵션의 기본값을 자동으로 지정할 수 있습니다. 그러나 &lt;code&gt;default&lt;/code&gt; 키워드는 특정 스키마 위치에서만 유효하며 다른 곳에서는 무시되므로 규칙에서 기본값이 규칙 옵션으로 제공 될 것으로 잘못 예상하면 버그가 발생할 수 있습니다. ESLint v6.0.0에서 규칙 에 스키마에 잘못된 &lt;code&gt;default&lt;/code&gt; 키워드 가 있으면 &lt;code&gt;RuleTester&lt;/code&gt; 에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="586438146f6109615a34b9a900fa8fbf8761e69b" translate="yes" xml:space="preserve">
          <source>In that case the expected syntax would have been:</source>
          <target state="translated">이 경우 예상되는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34e220746b67d0d1a6860ca7f5580ed5292abe0f" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;CommonJS&lt;/strong&gt; module system, a hidden function wraps each module and limits the scope of a &quot;global&quot; strict mode directive.</source>
          <target state="translated">에서 &lt;strong&gt;CommonJS의&lt;/strong&gt; 모듈 시스템, 숨겨진 기능은 각 모듈을 래핑하고 &quot;글로벌&quot;엄격 모드 지시어의 범위를 제한한다.</target>
        </trans-unit>
        <trans-unit id="2af7474f5034d2a87e6bb76f217e0214d6566d39" translate="yes" xml:space="preserve">
          <source>In the Node.js community it is often customary to separate initializations with calls to &lt;code&gt;require&lt;/code&gt; modules from other variable declarations, sometimes also grouping them by the type of module. This rule helps you enforce this convention.</source>
          <target state="translated">Node.js 커뮤니티에서는 다른 변수 선언의 모듈 을 &lt;code&gt;require&lt;/code&gt; 하기 위해 호출과 초기화를 분리 하고 때로는 모듈 유형별로 그룹화하는 것이 일반적입니다. 이 규칙은이 규칙을 적용하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f25f337dc8aa34dae55d66f05c1bb5c8ed5144c6" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;baz()&lt;/code&gt; can never execute. Obviously, &lt;code&gt;baz()&lt;/code&gt; could be executed only when &lt;code&gt;b&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, but in that case &lt;code&gt;bar()&lt;/code&gt; would be executed instead, since it's earlier in the chain.</source>
          <target state="translated">위의 예에서 &lt;code&gt;baz()&lt;/code&gt; 는 실행할 수 없습니다. 분명히, &lt;code&gt;baz()&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 될 때만 실행될 수 있지만,이 경우 &lt;code&gt;bar()&lt;/code&gt; 는 체인의 초기 단계이므로 대신 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc0e08c3b19b46bd79d160c044fb63b2212f50f" translate="yes" xml:space="preserve">
          <source>In the above example, the regular expression literal is easier to read and reason about. Also, it's a common mistake to omit the extra &lt;code&gt;\&lt;/code&gt; in the string literal, which would produce a completely different regular expression:</source>
          <target state="translated">위의 예에서 정규 표현식 리터럴은 읽기 쉽고 추론하기 쉽습니다. 또한 문자열 리터럴에서 여분의 &lt;code&gt;\&lt;/code&gt; 를 생략하는 것은 일반적으로 실수 이며, 완전히 다른 정규식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="805fa113fe73a36f3075118dbb4cbf1f7f0e4911" translate="yes" xml:space="preserve">
          <source>In the case of a CommonJS module, if your code is in strict mode or you don't want this rule to warn you about undeclared variables, and you also don't want this rule to warn you about the read-only globals, you can disable this rule.</source>
          <target state="translated">CommonJS 모듈의 경우 코드가 엄격 모드이거나이 규칙이 선언되지 않은 변수에 대해 경고하지 않게하고이 규칙이 읽기 전용 전역에 대해 경고하지 않게하려면 이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2333879fe578127fd545ac29675c84de972fc829" translate="yes" xml:space="preserve">
          <source>In the case of a browser script, if you want to be able to explicitly declare variables and functions in the global scope, and your code is in strict mode or you don't want this rule to warn you about undeclared variables, and you also don't want this rule to warn you about read-only globals, you can disable this rule.</source>
          <target state="translated">브라우저 스크립트의 경우 전역 범위에서 변수와 함수를 명시 적으로 선언 할 수 있고 코드가 엄격 모드이거나이 규칙이 선언되지 않은 변수에 대해 경고하지 않도록하려면 이 규칙이 읽기 전용 전역에 대해 경고하지 않게하려면이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73ff69869ee358fb751b07d6f10bc627b10fdf31" translate="yes" xml:space="preserve">
          <source>In the case of an ES module, if you don't want this rule to warn you about the read-only globals you can disable this rule.</source>
          <target state="translated">ES 모듈의 경우이 규칙이 읽기 전용 전역에 대해 경고하지 않게하려면이 규칙을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0cf62f8e2a7187fa75b64fd67d8b2165c79bd0" translate="yes" xml:space="preserve">
          <source>In the constructor of derived classes, if &lt;code&gt;this&lt;/code&gt;/&lt;code&gt;super&lt;/code&gt; are used before &lt;code&gt;super()&lt;/code&gt; calls, it raises a reference error.</source>
          <target state="translated">파생 클래스의 생성자에서 &lt;code&gt;super()&lt;/code&gt; 호출 전에 &lt;code&gt;this&lt;/code&gt; / &lt;code&gt;super&lt;/code&gt; 를 사용 하면 참조 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ff70ad8a5f97d1019f5ec2166872e8af868b385" translate="yes" xml:space="preserve">
          <source>In the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.</source>
          <target state="translated">ASI에 대한 토론에는 일반적으로 두 개의 사고 학교가 있습니다. 첫 번째는 ASI가 존재하지 않는 것처럼 취급하고 항상 세미콜론을 수동으로 포함해야한다는 것입니다. 이론적 근거는 세미콜론을 포함하는 것이 필요할 때 또는 필요하지 않은 것을 기억하는 것보다 항상 더 쉬우므로 오류가 발생할 가능성이 줄어든다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="484a62f26f2c619574ceb1e6c457d31625392327" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;sayHi&lt;/code&gt; method doesn't use &lt;code&gt;this&lt;/code&gt;, so we can make it a static method:</source>
          <target state="translated">위의 예제에서 &lt;code&gt;sayHi&lt;/code&gt; 메소드는 &lt;code&gt;this&lt;/code&gt; 를 사용하지 않으므로 정적 메소드로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2cd47d59330aa36977aa9998d327bbf8acb99ff" translate="yes" xml:space="preserve">
          <source>In the example configuration above, the top level &quot;before&quot; and &quot;after&quot; options define the default behavior of the rule, while the &quot;anonymous&quot; and &quot;method&quot; options override the default behavior. Overrides can be either an object with &quot;before&quot; and &quot;after&quot;, or a shorthand string as above.</source>
          <target state="translated">위의 구성 예에서 최상위 &quot;전&quot;및 &quot;후&quot;옵션은 규칙의 기본 동작을 정의하지만 &quot;익명&quot;및 &quot;방법&quot;옵션은 기본 동작을 재정의합니다. 재정의는 &quot;이전&quot;과 &quot;이후&quot;가있는 객체이거나 위와 같이 짧은 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97328f04f5b1cf5749587791362446a7fb8f3c20" translate="yes" xml:space="preserve">
          <source>In the exceptions where a newline does &lt;strong&gt;not&lt;/strong&gt; end a statement, a typing mistake to omit a semicolon causes two unrelated consecutive lines to be interpreted as one expression. Especially for a coding style without semicolons, readers might overlook the mistake. Although syntactically correct, the code might throw exceptions when it is executed.</source>
          <target state="translated">줄 바꿈이 명령문을 끝내지 않는 &lt;strong&gt;경우&lt;/strong&gt; 를 제외하고 세미콜론을 생략하는 입력 실수로 인해 두 개의 관련되지 않은 연속 행이 하나의 표현식으로 해석됩니다. 특히 세미콜론이없는 코딩 스타일의 경우 독자는 실수를 간과 할 수 있습니다. 구문 상으로는 정확하지만 코드가 실행될 때 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aff87de13f5ffd8d68a4105042048c5b3c19ed4" translate="yes" xml:space="preserve">
          <source>In the following example the &lt;code&gt;module&lt;/code&gt; import on line 1 is repeated on line 3. These can be combined to make the list of imports more succinct.</source>
          <target state="translated">다음 예제에서 1 행 의 &lt;code&gt;module&lt;/code&gt; 가져 오기는 3 행에서 반복됩니다.이 목록을 결합하여 가져 오기 목록을보다 간결하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e223ddd8853ea414a7d8a8c3771424ff2c613622" translate="yes" xml:space="preserve">
          <source>In the initial list of problems, the &lt;code&gt;fix&lt;/code&gt; property will refer to a fix in the processed JavaScript. The &lt;code&gt;postprocess&lt;/code&gt; method should transform the object to refer to a fix in the original, unprocessed file.</source>
          <target state="translated">초기 문제점 목록에서 &lt;code&gt;fix&lt;/code&gt; 특성은 처리 된 JavaScript의 수정 사항을 나타냅니다. &lt;code&gt;postprocess&lt;/code&gt; 있어서 원본 파일에 미처리 수정 참조 대상물을 변형한다.</target>
        </trans-unit>
        <trans-unit id="cdeeb4e7b1833bacebcb592d32546b7b7787fbed" translate="yes" xml:space="preserve">
          <source>In the initialization or update portions of a &lt;code&gt;for&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 문의 초기화 또는 업데이트 부분에서 .</target>
        </trans-unit>
        <trans-unit id="3a3d2790bd2dc958072534cbc721ebee4aafd235" translate="yes" xml:space="preserve">
          <source>In the last example the &lt;code&gt;await&lt;/code&gt; is necessary to be able to catch errors thrown from &lt;code&gt;bar()&lt;/code&gt;.</source>
          <target state="translated">마지막 예제에서 &lt;code&gt;await&lt;/code&gt; 는 &lt;code&gt;bar()&lt;/code&gt; 에서 발생한 오류를 포착 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8992ad5fc6c79ca648b7546f8d54a92a932529c" translate="yes" xml:space="preserve">
          <source>In the last file, you'll once again see that to properly resolve your config, you'll need include the full package path.</source>
          <target state="translated">마지막 파일에서 구성을 올바르게 해결하려면 전체 패키지 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="06a65141438f1465b9453edef91ccf38f50b2a41" translate="yes" xml:space="preserve">
          <source>In the preceding example, the error level is assumed to be the first argument. It is followed by the first optional argument, a string which may be either &lt;code&gt;&quot;always&quot;&lt;/code&gt; or &lt;code&gt;&quot;never&quot;&lt;/code&gt;. The final optional argument is an object, which may have a Boolean property named &lt;code&gt;exceptRange&lt;/code&gt;.</source>
          <target state="translated">앞의 예에서 오류 수준은 첫 번째 인수 인 것으로 가정합니다. 그 뒤에는 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;never&quot;&lt;/code&gt; 일 수있는 문자열 인 첫 번째 선택적 인수가옵니다 . 마지막 선택적 인수는 객체이며 &lt;code&gt;exceptRange&lt;/code&gt; 라는 부울 속성이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ae7da0834ca34159e742b20fb358094baed4a0e" translate="yes" xml:space="preserve">
          <source>In the same way, if there is a &lt;code&gt;package.json&lt;/code&gt; file in the root directory with an &lt;code&gt;eslintConfig&lt;/code&gt; field, the configuration it describes will apply to all subdirectories beneath it, but the configuration described by the &lt;code&gt;.eslintrc&lt;/code&gt; file in the tests directory will override it where there are conflicting specifications.</source>
          <target state="translated">같은 방법으로 &lt;code&gt;eslintConfig&lt;/code&gt; 필드 가있는 루트 디렉토리에 &lt;code&gt;package.json&lt;/code&gt; 파일 이있는 경우 , 설명하는 구성은 그 아래의 모든 서브 디렉토리에 적용되지만 tests 디렉토리 의 &lt;code&gt;.eslintrc&lt;/code&gt; 파일에 의해 설명 된 구성은 이를 대체합니다. 사양이 상충하는 곳.</target>
        </trans-unit>
        <trans-unit id="d895f26e01a339a58df0b6097b997dc2676f5f9b" translate="yes" xml:space="preserve">
          <source>In these configuration files, the rule &lt;code&gt;plugin1/rule1&lt;/code&gt; comes from the plugin named &lt;code&gt;plugin1&lt;/code&gt;. You can also use this format with configuration comments, such as:</source>
          <target state="translated">이 구성 파일에서 &lt;code&gt;plugin1/rule1&lt;/code&gt; 규칙은 plugin1 이라는 플러그인에서 가져 &lt;code&gt;plugin1&lt;/code&gt; . 다음과 같은 구성 설명과 함께이 형식을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d6699bd7eef806ecf2d6c599b776a76340f808" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;doSomething()&lt;/code&gt; is undefined at the time of invocation and so causes a runtime error.</source>
          <target state="translated">이 경우 호출시 &lt;code&gt;doSomething()&lt;/code&gt; 이 정의되지 않아 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a85d7db6d4b6df41b744c0747f7ca33c597e8b6" translate="yes" xml:space="preserve">
          <source>In this case, each function created within the loop returns a different number as expected.</source>
          <target state="translated">이 경우 루프 내에서 생성 된 각 함수는 예상대로 다른 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="356abc620d37a1abfd58a799df08e6a2a04736c0" translate="yes" xml:space="preserve">
          <source>In this case, probably removing &lt;code&gt;OUTER_LOOP:&lt;/code&gt; had been forgotten. Such labels take up space in the code and can lead to confusion by readers.</source>
          <target state="translated">이 경우 아마도 &lt;code&gt;OUTER_LOOP:&lt;/code&gt; 제거를 잊었을 것입니다. 이러한 레이블은 코드에서 공간을 차지하므로 독자가 혼동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c39bb2ffd2c62e6c7064f4d5e0435501709e632d" translate="yes" xml:space="preserve">
          <source>In this case, spacing will be disallowed after a &lt;code&gt;new&lt;/code&gt; operator and required before/after a &lt;code&gt;++&lt;/code&gt; operator.</source>
          <target state="translated">이 경우 &lt;code&gt;new&lt;/code&gt; 연산자 다음에는 공백이 허용되지 않으며 &lt;code&gt;++&lt;/code&gt; 연산자 전후에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7d4495221d480b471dcc1896dd624d6c593b570c" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;fail()&lt;/code&gt; function throws an error that is intended to be caught by the &lt;code&gt;catch()&lt;/code&gt; handler assigned later. Converting the &lt;code&gt;fail()&lt;/code&gt; function into a synchronous function would require the call to &lt;code&gt;fail()&lt;/code&gt; to be refactored to use a &lt;code&gt;try-catch&lt;/code&gt; statement instead of a promise.</source>
          <target state="translated">이 경우 &lt;code&gt;fail()&lt;/code&gt; 함수는 나중에 할당 된 &lt;code&gt;catch()&lt;/code&gt; 핸들러에 의해 잡힐 오류를 발생시킵니다 . &lt;code&gt;fail()&lt;/code&gt; 함수를 동기 함수로 변환하려면 promise 대신 &lt;code&gt;try-catch&lt;/code&gt; 문 을 사용 하도록 &lt;code&gt;fail()&lt;/code&gt; 호출을 리팩터링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0334129e557cb71f1101529b6b21d138390105a" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;var x&lt;/code&gt; is hoisted out of the loop, effectively creating:</source>
          <target state="translated">이 경우 &lt;code&gt;var x&lt;/code&gt; 는 루프 밖으로 들어올 려져 효과적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="81b4bbb5892a95679c7e65b779450b662ceded28" translate="yes" xml:space="preserve">
          <source>In this case, the created object is thrown away because its reference isn't stored anywhere, and in many cases, this means that the constructor should be replaced with a function that doesn't require &lt;code&gt;new&lt;/code&gt; to be used.</source>
          <target state="translated">이 경우 생성 된 객체는 참조가 어디에도 저장되지 않기 때문에 버려지며, 많은 경우 생성자를 &lt;code&gt;new&lt;/code&gt; 를 사용할 필요가없는 함수로 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0131376096f23dfc4bd77b3459401e2d691c79dd" translate="yes" xml:space="preserve">
          <source>In this case, the message is specific to the variable being used and the AST node type is &lt;code&gt;Identifier&lt;/code&gt;.</source>
          <target state="translated">이 경우 메시지는 사용중인 변수에 따라 다르며 AST 노드 유형은 &lt;code&gt;Identifier&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aad77b7ee8cfa194f8d3ef8768c4c03df4c2b476" translate="yes" xml:space="preserve">
          <source>In this case, the variable &lt;code&gt;a&lt;/code&gt; inside of &lt;code&gt;b()&lt;/code&gt; is shadowing the variable &lt;code&gt;a&lt;/code&gt; in the global scope. This can cause confusion while reading the code and it's impossible to access the global variable.</source>
          <target state="translated">이 경우, 가변 내부 &lt;code&gt;b()&lt;/code&gt; 가변 섀도 잉 전역에있다. 코드를 읽는 동안 혼동을 일으킬 수 있으며 전역 변수에 액세스 할 수 없습니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="399b857b733880f93edced40099e5c214d78fa49" translate="yes" xml:space="preserve">
          <source>In this case, you would expect each function created within the loop to return a different number. In reality, each function returns 10, because that was the last value of &lt;code&gt;i&lt;/code&gt; in the scope.</source>
          <target state="translated">이 경우 루프 내에서 작성된 각 함수가 다른 숫자를 리턴 할 것으로 예상합니다. 실제로 각 함수는 범위에서 &lt;code&gt;i&lt;/code&gt; 의 마지막 값이므로 10을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89db72e5b125a2136f5700b9df46d59dfd325de2" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;enum&lt;/code&gt; is used as an object key and will throw an error in an ECMAScript 3 environment (such as Internet Explorer 8).</source>
          <target state="translated">이 코드에서 &lt;code&gt;enum&lt;/code&gt; 은 객체 키로 사용되며 ECMAScript 3 환경 (예 : Internet Explorer 8)에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b3f3ffb93c91f659a612089534865f9263e81d0" translate="yes" xml:space="preserve">
          <source>In this code, no new variables are created because &lt;code&gt;a&lt;/code&gt; is just a location helper while the &lt;code&gt;{}&lt;/code&gt; is expected to contain the variables to create, such as:</source>
          <target state="translated">이 코드에서 &lt;code&gt;a&lt;/code&gt; 는 위치 도우미 일 뿐이 므로 &lt;code&gt;{}&lt;/code&gt; 에는 만들 변수가 포함될 것으로 예상 되므로 새 변수는 만들어지지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="99609a5bff02d4c73d9df2f874ef482759db0b7c" translate="yes" xml:space="preserve">
          <source>In this code, the reference to &lt;code&gt;this&lt;/code&gt; has been removed but &lt;code&gt;bind()&lt;/code&gt; is still used. In this case, the &lt;code&gt;bind()&lt;/code&gt; is unnecessary overhead (and a performance hit) and can be safely removed.</source>
          <target state="translated">이 코드에 대한 기준 &lt;code&gt;this&lt;/code&gt; 제거되었지만 &lt;code&gt;bind()&lt;/code&gt; 여전히 사용된다. 이 경우 &lt;code&gt;bind()&lt;/code&gt; 는 불필요한 오버 헤드 (및 성능 저하)이며 안전하게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df86629a847fb7ed6459c203d8878e66d97590a4" translate="yes" xml:space="preserve">
          <source>In this document, the first four types are summed up under the term &lt;em&gt;require declaration&lt;/em&gt;.</source>
          <target state="translated">이 문서에서 처음 네 가지 유형은 &lt;em&gt;선언 필요&lt;/em&gt; 라는 용어 &lt;em&gt;로&lt;/em&gt; 요약됩니다 .</target>
        </trans-unit>
        <trans-unit id="c640e601c90d57c39ee9be82c0f12dec43d6aa1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;../rules/eqeqeq&quot;&gt;&lt;code&gt;eqeqeq&lt;/code&gt;&lt;/a&gt; is turned off and &lt;a href=&quot;../rules/curly&quot;&gt;&lt;code&gt;curly&lt;/code&gt;&lt;/a&gt; is turned on as an error. You can also use the numeric equivalent for the rule severity:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;../rules/eqeqeq&quot;&gt; &lt;code&gt;eqeqeq&lt;/code&gt; &lt;/a&gt; 가 해제되고 오류로 &lt;a href=&quot;../rules/curly&quot;&gt; &lt;code&gt;curly&lt;/code&gt; &lt;/a&gt; 이 설정됩니다. 규칙 심각도에 해당하는 숫자를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c58957ba7e167fed9c432e37bda0f2aa517e44f7" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;CLIEngine&lt;/code&gt; instance is created that extends a configuration called &lt;code&gt;&quot;eslint-config-shared&quot;&lt;/code&gt;, a setting named &lt;code&gt;&quot;sharedData&quot;&lt;/code&gt; and two environments (&lt;code&gt;&quot;browser&quot;&lt;/code&gt; and &lt;code&gt;&quot;mocha&quot;&lt;/code&gt;) are defined, loading of &lt;code&gt;.eslintrc&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt; files are disabled, and the &lt;code&gt;semi&lt;/code&gt; rule enabled as an error. You can then call methods on &lt;code&gt;cli&lt;/code&gt; and these options will be used to perform the correct action.</source>
          <target state="translated">이 예에서는 &lt;code&gt;&quot;eslint-config-shared&quot;&lt;/code&gt; 구성을 확장 하는 새 &lt;code&gt;CLIEngine&lt;/code&gt; 인스턴스가 작성됩니다. 이 설정은 &lt;code&gt;&quot;sharedData&quot;&lt;/code&gt; 라는 설정 과 두 개의 환경 ( &lt;code&gt;&quot;browser&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;mocha&quot;&lt;/code&gt; )이 정의되어 &lt;code&gt;.eslintrc&lt;/code&gt; 및 &lt;code&gt;package.json&lt;/code&gt; 로드 .json 파일이 비활성화되고 &lt;code&gt;semi&lt;/code&gt; 규칙이 오류로 활성화되었습니다. 그런 다음 &lt;code&gt;cli&lt;/code&gt; 에서 메소드를 호출 하면 이러한 옵션이 올바른 조치를 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e04d10297a79bb36c8285674c21e09aa283053e2" translate="yes" xml:space="preserve">
          <source>In this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The &lt;a href=&quot;no-unexpected-multiline&quot;&gt;no-unexpected-multiline&lt;/a&gt; rule can protect your code from such cases.</source>
          <target state="translated">이 예제에서는 첫 번째 줄 뒤에 세미콜론을 삽입하지 않아 빈 오류가 마치 함수처럼 호출되므로 런타임 오류가 발생합니다. &lt;a href=&quot;no-unexpected-multiline&quot;&gt;없는 예상치 못한-여러&lt;/a&gt; 규칙은 이러한 경우에서 코드를 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd38ba50d65586ae33ba8981419872a1566d701" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, then execution will flow through both cases, as the first falls through to the second. You can prevent this by using &lt;code&gt;break&lt;/code&gt;, as in this example:</source>
          <target state="translated">이 예제에서 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 이면 첫 번째가 두 번째로 넘어 가면서 두 경우를 통해 실행이 진행됩니다. 다음 예제와 같이 &lt;code&gt;break&lt;/code&gt; 를 사용하여이를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d644af3174c7141490f9748832a9b77f491be79" translate="yes" xml:space="preserve">
          <source>In this example, rules run on &lt;code&gt;linter1&lt;/code&gt; will get &lt;code&gt;path/to/project&lt;/code&gt; when calling &lt;code&gt;context.getCwd()&lt;/code&gt;. Those run on &lt;code&gt;linter2&lt;/code&gt; will get &lt;code&gt;process.cwd()&lt;/code&gt; if the global &lt;code&gt;process&lt;/code&gt; object is defined or &lt;code&gt;undefined&lt;/code&gt; otherwise (e.g. on the browser https://eslint.org/demo).</source>
          <target state="translated">이 예제에서 &lt;code&gt;linter1&lt;/code&gt; 에서 실행되는 규칙 은 &lt;code&gt;context.getCwd()&lt;/code&gt; 호출 할 때 &lt;code&gt;path/to/project&lt;/code&gt; 를 가져옵니다 . &lt;code&gt;linter2&lt;/code&gt; 에서 실행되는 것은 전역 &lt;code&gt;process&lt;/code&gt; 객체가 다르게 정의되거나 &lt;code&gt;undefined&lt;/code&gt; 않은 경우 &lt;code&gt;process.cwd()&lt;/code&gt; 를 얻습니다 (예 : 브라우저 https://eslint.org/demo).</target>
        </trans-unit>
        <trans-unit id="779b188cd469ad108c26dd64160ac911811d7073" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;colors&lt;/code&gt; array has a &lt;code&gt;length&lt;/code&gt; of 3. But did the developer intend for there to be an empty spot in the middle of the array? Or is it a typo?</source>
          <target state="translated">이 예제에서 &lt;code&gt;colors&lt;/code&gt; 배열의 &lt;code&gt;length&lt;/code&gt; 는 3입니다. 그러나 개발자가 배열 중간에 빈 지점을 만들려고 했습니까? 아니면 오타입니까?</target>
        </trans-unit>
        <trans-unit id="5386dba46b991972060bd7c9e14da379324e4d9b" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;your-program-that-reads-json&lt;/code&gt; program can accept the raw JSON of ESLint results and process it before outputting its own format of the results. You can pass as many command line arguments to that program as are necessary to customize the output.</source>
          <target state="translated">이 예제에서 &lt;code&gt;your-program-that-reads-json&lt;/code&gt; 프로그램은 자체 JSON 형식의 결과를 출력하기 전에 원시 JSON ESLint 결과를 승인하고 처리 할 수 ​​있습니다. 출력을 사용자 정의하는 데 필요한만큼 많은 명령 행 인수를 해당 프로그램에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fe1ba8b07ed67f5a9ede5eb35c07a25b1b5f527" translate="yes" xml:space="preserve">
          <source>In this example, there is no confusion as to the expected behavior. It is clear that the first case is meant to fall through to the second case.</source>
          <target state="translated">이 예에서는 예상되는 동작에 대해 혼동이 없습니다. 첫 번째 경우는 두 번째 경우에 해당한다는 것이 명백합니다.</target>
        </trans-unit>
        <trans-unit id="7e7ef8fabcff41fe8f6f4df0b1edfce0bf6562b5" translate="yes" xml:space="preserve">
          <source>In this regular expression, it's very hard to tell how many spaces are intended to be matched. It's better to use only one space and then specify how many spaces are expected, such as:</source>
          <target state="translated">이 정규 표현식에서는 얼마나 많은 공간을 일치시킬 것인지 말하기가 매우 어렵습니다. 하나의 공백 만 사용하고 다음과 같이 예상되는 공백 수를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4a189fd8ceca6899851eb5f5658a2bf4f6b54ef4" translate="yes" xml:space="preserve">
          <source>In this way, you can look for patterns in the JavaScript text itself when the AST isn't providing the appropriate data (such as location of commas, semicolons, parentheses, etc.).</source>
          <target state="translated">이런 방식으로 AST가 적절한 데이터를 제공하지 않을 때 JavaScript 텍스트 자체에서 패턴을 찾을 수 있습니다 (예 : 쉼표, 세미콜론, 괄호 등).</target>
        </trans-unit>
        <trans-unit id="d5c0141841620af4d1a195b336ad8e436213bec6" translate="yes" xml:space="preserve">
          <source>In this way, you can retrieve the text and AST used for the last run of &lt;code&gt;linter.verify()&lt;/code&gt;.</source>
          <target state="translated">이런 식으로 &lt;code&gt;linter.verify()&lt;/code&gt; 의 마지막 실행에 사용 된 텍스트와 AST를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f93ca71277a0502e3ed4131457bb0945a787ed0" translate="yes" xml:space="preserve">
          <source>In your &lt;code&gt;.eslintrc.json&lt;/code&gt;:</source>
          <target state="translated">당신에 &lt;code&gt;.eslintrc.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="009b0850360ef7549f9650d1923055c3693ba1c5" translate="yes" xml:space="preserve">
          <source>In your &lt;code&gt;index.js&lt;/code&gt; you can do something like this:</source>
          <target state="translated">당신에 &lt;code&gt;index.js&lt;/code&gt; 이 같은 작업을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="032a16fac15a2c35de7010f198a6616b53ea5447" translate="yes" xml:space="preserve">
          <source>Include a Plugin</source>
          <target state="translated">플러그인 포함</target>
        </trans-unit>
        <trans-unit id="11727c01a1f0f864099d5b7d0794777c1a808dbc" translate="yes" xml:space="preserve">
          <source>Inconsistent array literals</source>
          <target state="translated">일치하지 않는 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="ca0226a65c54af3be6e8d1317608eb74c1af4347" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; will indent the multi-line property chains with 0 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 으로 설정된 상태에서 2 개의 공백을 들여 쓰기하면 공백이 0 인 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="7291c3e61a93ea88556a7189c20daea3b648aec5" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; will indent the multi-line property chains with 2 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 로 설정된 상태에서 2 개의 공백을 들여 쓰기하면 2 개의 공백이 있는 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc91230783ec5f7e7d075a1b0c3b0e709d44eaa" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent the multi-line property chains with 4 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;2&lt;/code&gt; 로 설정된 상태에서 2 개의 공백을 들여 쓰기하면 4 개의 공백이있는 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa45cb0a17e641de36c01adbba849efeb37b109" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;SwitchCase&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; will not indent &lt;code&gt;case&lt;/code&gt; clauses with respect to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;SwitchCase&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정된 상태에서 2 개의 공백을 들여 쓰기 하면 &lt;code&gt;switch&lt;/code&gt; 문과 관련하여 &lt;code&gt;case&lt;/code&gt; 절이 들여 쓰기되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4f2a16a4131df3f89017d70bbb1ece160f90c7c" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;SwitchCase&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; will indent &lt;code&gt;case&lt;/code&gt; clauses with 2 spaces with respect to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;SwitchCase&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 설정된 상태에서 2 개의 공백을 들여 쓰기 하면 &lt;code&gt;switch&lt;/code&gt; 문과 관련하여 2 개의 공백이있는 &lt;code&gt;case&lt;/code&gt; 절이 들여 쓰기됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa3ef7698444ec15ef47c06f1146395abe21723b" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;SwitchCase&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent &lt;code&gt;case&lt;/code&gt; clauses with 4 spaces with respect to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">2 개 공간 들여 &lt;code&gt;SwitchCase&lt;/code&gt; 의 행 세트 &lt;code&gt;2&lt;/code&gt; 것 들여 &lt;code&gt;case&lt;/code&gt; 에 대하여 4 공백 절 &lt;code&gt;switch&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="04b9c9c421c16f0b5f05a25e69465b0bc0f1be79" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;VariableDeclarator&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent the multi-line variable declarations with 4 spaces.</source>
          <target state="translated">&lt;code&gt;VariableDeclarator&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 로 설정된 상태에서 2 개의 공백을 들여 쓰기하면 공백이 4 개인 다중 행 변수 선언이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8ebca7ea1eadf77aa1539aee5992376aa42b9a" translate="yes" xml:space="preserve">
          <source>Indent of 2 spaces with &lt;code&gt;VariableDeclarator&lt;/code&gt; set to &lt;code&gt;{&quot;var&quot;: 2, &quot;let&quot;: 2, &quot;const&quot;: 3}&lt;/code&gt; will indent the multi-line variable declarations with 4 spaces for &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;, 6 spaces for &lt;code&gt;const&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;VariableDeclarator&lt;/code&gt; 가 &lt;code&gt;{&quot;var&quot;: 2, &quot;let&quot;: 2, &quot;const&quot;: 3}&lt;/code&gt; 설정된 2 개의 공백 들여 쓰기는 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 에 대해 4 개의 공백, &lt;code&gt;const&lt;/code&gt; 문에 대해 6 개의 공백이 있는 여러 줄 변수 선언을 들여 씁니다 .</target>
        </trans-unit>
        <trans-unit id="37da0f8ed8adb3a9ae9717323caef07582ce3615" translate="yes" xml:space="preserve">
          <source>Indent of 4 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; will indent the multi-line property chains with 0 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 으로 설정된 상태에서 4 개의 공백을 들여 쓰기하면 공백이 0 인 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="81800a33fcf8d34618c84a566cae8af76effa434" translate="yes" xml:space="preserve">
          <source>Indent of 4 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; will indent the multi-line property chains with 4 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 로 설정된 상태에서 4 개의 공백을 들여 쓰기하면 4 개의 공백이 있는 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="0adfe437bd53df09a8a1d1b8b57ebaa2b74de516" translate="yes" xml:space="preserve">
          <source>Indent of 4 spaces with &lt;code&gt;MemberExpression&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent the multi-line property chains with 8 spaces.</source>
          <target state="translated">&lt;code&gt;MemberExpression&lt;/code&gt; 이 &lt;code&gt;2&lt;/code&gt; 로 설정된 상태에서 4 개의 공백을 들여 쓰기하면 8 개의 공백이있는 여러 줄 속성 체인이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="c377f9f2c9baba9b61174102349a3cff039f772b" translate="yes" xml:space="preserve">
          <source>Indent of 4 spaces with &lt;code&gt;VariableDeclarator&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent the multi-line variable declarations with 8 spaces.</source>
          <target state="translated">&lt;code&gt;VariableDeclarator&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 로 설정된 상태에서 4 개의 공백을 들여 쓰기하면 8 개의 공백이있는 여러 줄 변수 선언이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="249477091acfdfe0764a4626099be04431debedd" translate="yes" xml:space="preserve">
          <source>Indent of tab with &lt;code&gt;SwitchCase&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent &lt;code&gt;case&lt;/code&gt; clauses with 2 tabs with respect to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;SwitchCase&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 로 설정된 탭 들여 쓰기는 &lt;code&gt;switch&lt;/code&gt; 문과 관련하여 2 개의 탭이있는 &lt;code&gt;case&lt;/code&gt; 절을 들여 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f517b0d431fab414c01fa41d1cb1ba6e2c691bfe" translate="yes" xml:space="preserve">
          <source>Indent of tab with &lt;code&gt;VariableDeclarator&lt;/code&gt; set to &lt;code&gt;2&lt;/code&gt; will indent the multi-line variable declarations with 2 tabs.</source>
          <target state="translated">&lt;code&gt;VariableDeclarator&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 로 설정된 탭 들여 쓰기는 2 개의 탭으로 여러 줄 변수 선언을 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="be85770cb5a76a0818b1bf2921835273683eab9e" translate="yes" xml:space="preserve">
          <source>Indent style</source>
          <target state="translated">들여 쓰기 스타일</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="e6261109da4902b33b9cd6b6a6e13950c7b2f265" translate="yes" xml:space="preserve">
          <source>Individual rules are the most specialized part of the ESLint architecture. Rules can do very little, they are simply a set of instructions executed against an AST that is provided. They do get some context information passed in, but the primary responsibility of a rule is to inspect the AST and report warnings.</source>
          <target state="translated">개별 규칙은 ESLint 아키텍처에서 가장 전문화 된 부분입니다. 규칙은 거의 할 수 없으며 제공된 AST에 대해 실행되는 일련의 명령입니다. 컨텍스트 정보가 전달되지만 규칙의 주요 책임은 AST를 검사하고 경고를보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a85c159fc06136af3a0e6f3ef7f7b357155918ae" translate="yes" xml:space="preserve">
          <source>Infix notation is considered to be more readable and thus more preferable than the function notation.</source>
          <target state="translated">접두어 표기법은 기능 표기법보다 읽기 쉽고 더 읽기 쉬운 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="171e49fd6eadd04f3820993c4be21fe5a1b35166" translate="yes" xml:space="preserve">
          <source>Inline configuration</source>
          <target state="translated">인라인 구성</target>
        </trans-unit>
        <trans-unit id="d2fd04fd84101709fd89ec790e1371ff8b9ef63c" translate="yes" xml:space="preserve">
          <source>Inline configuration comments</source>
          <target state="translated">인라인 구성 설명</target>
        </trans-unit>
        <trans-unit id="9585f00332de4d4f8c32369ef56719ceb72cd815" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;async function&lt;/code&gt;, &lt;code&gt;return await&lt;/code&gt; is seldom useful. Since the return value of an &lt;code&gt;async function&lt;/code&gt; is always wrapped in &lt;code&gt;Promise.resolve&lt;/code&gt;, &lt;code&gt;return await&lt;/code&gt; doesn&amp;rsquo;t actually do anything except add extra time before the overarching Promise resolves or rejects. The only valid exception is if &lt;code&gt;return await&lt;/code&gt; is used in a try/catch statement to catch errors from another Promise-based function.</source>
          <target state="translated">내부 &lt;code&gt;async function&lt;/code&gt; , &lt;code&gt;return await&lt;/code&gt; 드물게 유용합니다. 의 반환 값 때문에 &lt;code&gt;async function&lt;/code&gt; 항상에 싸여 &lt;code&gt;Promise.resolve&lt;/code&gt; , &lt;code&gt;return await&lt;/code&gt; 실제로 무엇보다 중요한 약속 결의 또는 거부하기 전에 추가 여분의 시간을 제외하고 아무것도하지 않습니다. 유일하게 유효한 예외는 try / catch 문에서 &lt;code&gt;return await&lt;/code&gt; 를 사용하여 다른 Promise 기반 함수의 오류를 포착하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb0de3cbdd2ccc580ba1ed8ca26a4b30319c1d03" translate="yes" xml:space="preserve">
          <source>Inside your &lt;code&gt;/lib/ci.js&lt;/code&gt; you have</source>
          <target state="translated">당신의 내부 &lt;code&gt;/lib/ci.js&lt;/code&gt; , 당신은</target>
        </trans-unit>
        <trans-unit id="97641fdd5c503b70c8becbd4ce8f7e9e8d44e3c6" translate="yes" xml:space="preserve">
          <source>Inside your &lt;code&gt;/lib/ci/common.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/lib/ci/common.js&lt;/code&gt; 내부</target>
        </trans-unit>
        <trans-unit id="79793a6b410e0433146645ca2357b284caa999c3" translate="yes" xml:space="preserve">
          <source>Inspect the AST for specific patterns</source>
          <target state="translated">특정 패턴에 대한 AST 검사</target>
        </trans-unit>
        <trans-unit id="aa191a92122db1dd534e01a6f8db776a244a258a" translate="yes" xml:space="preserve">
          <source>Inspecting JavaScript code strings</source>
          <target state="translated">JavaScript 코드 문자열 검사</target>
        </trans-unit>
        <trans-unit id="c606fdbf6de357bfc1116bac2ce0d38a13ee0476" translate="yes" xml:space="preserve">
          <source>Installation and Usage</source>
          <target state="translated">설치 및 사용법</target>
        </trans-unit>
        <trans-unit id="e15807031e6ce06bd523ee795f410f6739658f43" translate="yes" xml:space="preserve">
          <source>Instances where an arrow function would not produce identical results will be ignored.</source>
          <target state="translated">화살표 함수가 동일한 결과를 생성하지 않는 인스턴스는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd015dcfc5986643aac68a740707e55386dfe2e8" translate="yes" xml:space="preserve">
          <source>Instead of those, you can comply with the rule by writing</source>
          <target state="translated">그 대신에, 당신은 서면으로 규칙을 준수 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6029437e076bc4c6afdd7d074c7461678e957ef0" translate="yes" xml:space="preserve">
          <source>Instead of typing out messages in both the &lt;code&gt;context.report()&lt;/code&gt; call and your tests, you can use &lt;code&gt;messageId&lt;/code&gt;s instead.</source>
          <target state="translated">&lt;code&gt;context.report()&lt;/code&gt; 호출과 테스트 모두에서 메시지를 입력하는 대신 &lt;code&gt;messageId&lt;/code&gt; 를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad4af54fe31ce812575acd3bb59ea228cff9bbd9" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;code&gt;desc&lt;/code&gt; key for suggestions a &lt;code&gt;messageId&lt;/code&gt; can be used instead. This works the same way as &lt;code&gt;messageId&lt;/code&gt;s for the overall error (see &lt;a href=&quot;#messageIds&quot;&gt;messageIds&lt;/a&gt;). Here is an example of how to use it in a rule:</source>
          <target state="translated">대신 사용하는 &lt;code&gt;desc&lt;/code&gt; 추천 검색어에 대한 키 &lt;code&gt;messageId&lt;/code&gt; 가가 대신 사용할 수있다. 이것은 전체 오류에 대한 &lt;code&gt;messageId&lt;/code&gt; 와 동일한 방식으로 작동합니다 ( &lt;a href=&quot;#messageIds&quot;&gt;messageIds&lt;/a&gt; 참조 ). 다음은 규칙에서 사용하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a7881cac6e64abca5eafd172df6eb31fe0b84c88" translate="yes" xml:space="preserve">
          <source>Integrations</source>
          <target state="translated">Integrations</target>
        </trans-unit>
        <trans-unit id="7ce82ae5f06c2403a942ea5944563684a05c2677" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA, RubyMine, WebStorm, PhpStorm, PyCharm, AppCode, Android Studio, 0xDBE: &lt;a href=&quot;https://plugins.jetbrains.com/plugin/7494-eslint&quot;&gt;ESLint Plugin&lt;/a&gt;</source>
          <target state="translated">IntelliJ IDEA, RubyMine, WebStorm, PhpStorm, PyCharm, AppCode, Android Studio, 0xDBE : &lt;a href=&quot;https://plugins.jetbrains.com/plugin/7494-eslint&quot;&gt;ESLint 플러그인&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dcaca927eb571b52afe4df5a018ef73e1f47fd6" translate="yes" xml:space="preserve">
          <source>Inter-property Delimiters</source>
          <target state="translated">속성 간 구분자</target>
        </trans-unit>
        <trans-unit id="d2e6be9cff98375cf9b71efc8412555587e67bf3" translate="yes" xml:space="preserve">
          <source>Internally, the list of core modules is retrieved via &lt;code&gt;require(&quot;repl&quot;)._builtinLibs&lt;/code&gt;. If you use different versions of Node.js for ESLint and your application, the list of core modules for each version may be different. The above mentioned &lt;code&gt;_builtinLibs&lt;/code&gt; property became available in 0.8, for earlier versions a hardcoded list of module names is used as a fallback. If your version of Node.js is older than 0.6 that list may be inaccurate.</source>
          <target state="translated">내부적으로 핵심 모듈 목록은 &lt;code&gt;require(&quot;repl&quot;)._builtinLibs&lt;/code&gt; 를 통해 검색됩니다 . ESLint 및 애플리케이션에 다른 버전의 Node.js를 사용하는 경우 각 버전의 핵심 모듈 목록이 다를 수 있습니다. 위에서 언급 한 &lt;code&gt;_builtinLibs&lt;/code&gt; 속성은 0.8에서 사용할 수있게되었습니다. 이전 버전에서는 하드 코딩 된 모듈 이름 목록이 폴백으로 사용됩니다. Node.js 버전이 0.6보다 오래된 경우 해당 목록이 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a353823bf4679ac9a97ecdcdda169f480ccc4e6b" translate="yes" xml:space="preserve">
          <source>Interpreting command line arguments</source>
          <target state="translated">명령 줄 인수 해석</target>
        </trans-unit>
        <trans-unit id="44cd6f5293258a62e092650968ebc166ee72f7e8" translate="yes" xml:space="preserve">
          <source>Introduced in ES2016, the infix exponentiation operator &lt;code&gt;**&lt;/code&gt; is an alternative for the standard &lt;code&gt;Math.pow&lt;/code&gt; function.</source>
          <target state="translated">ES2016에 도입 된 infix exponentiation operator &lt;code&gt;**&lt;/code&gt; 는 표준 &lt;code&gt;Math.pow&lt;/code&gt; 함수 의 대안입니다 .</target>
        </trans-unit>
        <trans-unit id="306481a508a9005a041e40b4b6b65eb7b3a5810a" translate="yes" xml:space="preserve">
          <source>Introduced in ES2018, object spread is a declarative alternative which may perform better than the more dynamic, imperative &lt;code&gt;Object.assign&lt;/code&gt;.</source>
          <target state="translated">ES2018에 도입 된 객체 확산은보다 역동적이고 명령적인 &lt;code&gt;Object.assign&lt;/code&gt; 보다 성능이 우수한 선언적 대안입니다 .</target>
        </trans-unit>
        <trans-unit id="98ba7cd71bb7b6ecec8a3a9d63e39097f51862b5" translate="yes" xml:space="preserve">
          <source>Invalid Code</source>
          <target state="translated">유효하지 않은 코드</target>
        </trans-unit>
        <trans-unit id="815945ae0fe3963181a2bfa1fb673d90efae01ff" translate="yes" xml:space="preserve">
          <source>Invalid or irregular whitespace causes issues with ECMAScript 5 parsers and also makes code harder to debug in a similar nature to mixed tabs and spaces.</source>
          <target state="translated">유효하지 않거나 불규칙한 공백은 ECMAScript 5 파서에서 문제를 야기하며 혼합 탭 및 공백과 유사한 특성으로 코드를 디버그하기 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d5b11134917a485155a6f88cb85472d4bfbf86f8" translate="yes" xml:space="preserve">
          <source>Is NOT a valid character within JSON which would cause parse errors</source>
          <target state="translated">구문 분석 오류가 발생하는 JSON 내의 유효한 문자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="60cf4231de6804a719f7211d9a553afb7accfba5" translate="yes" xml:space="preserve">
          <source>Is NOT considered a separator for tokens and is often parsed as an &lt;code&gt;Unexpected token ILLEGAL&lt;/code&gt;</source>
          <target state="translated">토큰의 구분 기호로 간주되지 않으며 종종 &lt;code&gt;Unexpected token ILLEGAL&lt;/code&gt; 해석됩니다. 불법</target>
        </trans-unit>
        <trans-unit id="957302f33f2dc5759ecc018bc572081e80d88860" translate="yes" xml:space="preserve">
          <source>Is NOT shown in modern browsers making code repository software expected to resolve the visualization</source>
          <target state="translated">코드 리포지토리 소프트웨어가 시각화를 해결할 것으로 예상하는 최신 브라우저에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc9cf4d64ebc62cf137d309a08c91bfd3d80092e" translate="yes" xml:space="preserve">
          <source>Is this issue available for me to work on? If you have little or no experience contributing to ESLint, the &lt;a href=&quot;https://github.com/eslint/eslint/labels/good%20first%20issue&quot;&gt;&lt;code&gt;good first issue&lt;/code&gt;&lt;/a&gt; label marks appropriate issues. Otherwise, the &lt;a href=&quot;https://github.com/eslint/eslint/labels/help%20wanted&quot;&gt;&lt;code&gt;help wanted&lt;/code&gt;&lt;/a&gt; label is an invitation to work on the issue. If you have more experience, you can try working on other issues labeled &lt;a href=&quot;https://github.com/eslint/eslint/labels/accepted&quot;&gt;&lt;code&gt;accepted&lt;/code&gt;&lt;/a&gt;. Conversely, issues not yet ready to work on are labeled &lt;code&gt;triage&lt;/code&gt;, &lt;code&gt;evaluating&lt;/code&gt;, and/or &lt;code&gt;needs bikeshedding&lt;/code&gt;, and issues that cannot currently be worked on because of something else, such as a bug in a dependency, are labeled &lt;code&gt;blocked&lt;/code&gt;.</source>
          <target state="translated">이 문제를 해결할 수 있습니까? ESLint에 기여한 경험이 거의 없거나없는 경우, &lt;a href=&quot;https://github.com/eslint/eslint/labels/good%20first%20issue&quot;&gt; &lt;code&gt;good first issue&lt;/code&gt; &lt;/a&gt; 레이블은 적절한 문제를 나타냅니다. 그렇지 않으면, &lt;a href=&quot;https://github.com/eslint/eslint/labels/help%20wanted&quot;&gt; &lt;code&gt;help wanted&lt;/code&gt; &lt;/a&gt; 레이블은 문제를 해결하기위한 초대입니다. 더 많은 경험이 있다면, &lt;a href=&quot;https://github.com/eslint/eslint/labels/accepted&quot;&gt; &lt;code&gt;accepted&lt;/code&gt; &lt;/a&gt; 된 다른 문제에 대해 작업 해 볼 수 있습니다 . 반대로,에 일을 아직 준비가되지 않은 문제가 표시되어 &lt;code&gt;triage&lt;/code&gt; , &lt;code&gt;evaluating&lt;/code&gt; , 및 / 또는 &lt;code&gt;needs bikeshedding&lt;/code&gt; , 현재 이러한 의존성의 버그로 인해 다른 뭔가에 종사 할 수없는 문제가,라는 레이블이 붙었다 &lt;code&gt;blocked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7a2b9ab5c52c5baa98c0142e1ecf88e976d9a7" translate="yes" xml:space="preserve">
          <source>Issue 5848: Exponentiation operator ** has different results for numbers and variables from 50 upwards</source>
          <target state="translated">문제 5848 : 지수 연산자 **는 50 이상의 숫자와 변수에 대한 결과가 다릅니다</target>
        </trans-unit>
        <trans-unit id="37728d8bc7a4f09a840422afa258e772e00bb890" translate="yes" xml:space="preserve">
          <source>Issue Labels</source>
          <target state="translated">문제 라벨</target>
        </trans-unit>
        <trans-unit id="be652d16de194c250a891ad0f6808f168955fcd0" translate="yes" xml:space="preserve">
          <source>It can also take an object with lists of &lt;code&gt;paths&lt;/code&gt; and gitignore-style &lt;code&gt;patterns&lt;/code&gt; strings.</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt; 및 gitignore 스타일 &lt;code&gt;patterns&lt;/code&gt; 문자열 목록이있는 객체를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2924f65b6a87a4bd47f6db0bc1044df77741aec9" translate="yes" xml:space="preserve">
          <source>It creates the paths from &lt;code&gt;try&lt;/code&gt; block to &lt;code&gt;catch&lt;/code&gt; block at:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 블록에서 &lt;code&gt;catch&lt;/code&gt; 블록 까지의 경로를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fdb515fbd413583a1777a93401fe6bf040d961f9" translate="yes" xml:space="preserve">
          <source>It creates two code paths.</source>
          <target state="translated">두 개의 코드 경로를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e0d45deb43503113017a4d4ddd12a12a01bba178" translate="yes" xml:space="preserve">
          <source>It either requires or disallows spaces between the brackets and the values inside of them. This rule does not apply to brackets that are separated from the adjacent value by a newline.</source>
          <target state="translated">대괄호와 그 안의 값 사이에 공백이 필요하거나 허용되지 않습니다. 이 규칙은 줄 바꿈으로 인접한 값과 구분되는 괄호에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1437185c6ef9d0863b444bd8bb4f3398c15e78df" translate="yes" xml:space="preserve">
          <source>It has two settings:</source>
          <target state="translated">두 가지 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eac4161f004a7becbe3061ce8c3b4bd97a4b319" translate="yes" xml:space="preserve">
          <source>It is a &lt;code&gt;for()&lt;/code&gt;, &lt;code&gt;while()&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;if()&lt;/code&gt;, or &lt;code&gt;else&lt;/code&gt;, and there is no &lt;code&gt;{&lt;/code&gt;</source>
          <target state="translated">그것은 없다 &lt;code&gt;for()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; , &lt;code&gt;if()&lt;/code&gt; , 또는 &lt;code&gt;else&lt;/code&gt; , 더있다 &lt;code&gt;{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f04b31fe116a81aee3104f1518870b3f9f257e4d" translate="yes" xml:space="preserve">
          <source>It is also possible to install ESLint globally rather than locally (using &lt;code&gt;npm install eslint --global&lt;/code&gt;). However, this is not recommended, and any plugins or shareable configs that you use must be installed locally in either case.</source>
          <target state="translated">로컬이 아닌 ESLint를 로컬로 설치할 수도 있습니다 ( &lt;code&gt;npm install eslint --global&lt;/code&gt; 사용 ). 그러나 이것은 권장되지 않으며 사용하는 플러그인 또는 공유 가능한 구성은 두 경우 모두 로컬로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="60d8bb2666fcd22fb48ff106ea15d22786cda53c" translate="yes" xml:space="preserve">
          <source>It is called (&lt;code&gt;foo()&lt;/code&gt;) or constructed (&lt;code&gt;new foo()&lt;/code&gt;)</source>
          <target state="translated">( &lt;code&gt;foo()&lt;/code&gt; ) 또는 생성 된 ( &lt;code&gt;new foo()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d50a64c3ddd7bf38274c6a5f24e1b180a437f3ae" translate="yes" xml:space="preserve">
          <source>It is considered good practice to only &lt;code&gt;throw&lt;/code&gt; the &lt;code&gt;Error&lt;/code&gt; object itself or an object using the &lt;code&gt;Error&lt;/code&gt; object as base objects for user-defined exceptions. The fundamental benefit of &lt;code&gt;Error&lt;/code&gt; objects is that they automatically keep track of where they were built and originated.</source>
          <target state="translated">그것은 단지에 좋은 연습 간주됩니다 &lt;code&gt;throw&lt;/code&gt; &lt;code&gt;Error&lt;/code&gt; 객체 자체 또는 사용하여 객체 &lt;code&gt;Error&lt;/code&gt; 기본 사용자 정의 예외 객체로 객체를. &lt;code&gt;Error&lt;/code&gt; 객체 의 기본 이점은 객체가 생성 및 시작된 위치를 자동으로 추적한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be5f31a9c2ec8133c8f35672e41c04c2511eb6b8" translate="yes" xml:space="preserve">
          <source>It is considered good practice to only pass instances of the built-in &lt;code&gt;Error&lt;/code&gt; object to the &lt;code&gt;reject()&lt;/code&gt; function for user-defined errors in Promises. &lt;code&gt;Error&lt;/code&gt; objects automatically store a stack trace, which can be used to debug an error by determining where it came from. If a Promise is rejected with a non-&lt;code&gt;Error&lt;/code&gt; value, it can be difficult to determine where the rejection occurred.</source>
          <target state="translated">기본 제공 &lt;code&gt;Error&lt;/code&gt; 개체 의 인스턴스 만 Promises의 사용자 정의 오류에 대한 &lt;code&gt;reject()&lt;/code&gt; 함수로 전달하는 것이 좋습니다 . &lt;code&gt;Error&lt;/code&gt; 개체는 스택 추적을 자동으로 저장하며, 오류는 출처를 확인하여 오류를 디버깅하는 데 사용할 수 있습니다. 약속이 &lt;code&gt;Error&lt;/code&gt; 가 아닌 값으로 거부되면 거부가 발생한 위치를 결정하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4efad34ec75493b8be888ef3c0c9c3a3be295e6" translate="yes" xml:space="preserve">
          <source>It is considered good practice to use the type-safe equality operators &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; instead of their regular counterparts &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">정규 대응 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 대신 형식 안전 동등 연산자 &lt;code&gt;===&lt;/code&gt; 및 &lt;code&gt;!==&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2db77118d25a6696528bec7e8025641d13ef6524" translate="yes" xml:space="preserve">
          <source>It is difficult to tell the intent of the &lt;code&gt;return&lt;/code&gt; statement here. It's possible that the function is meant to return the result of &lt;code&gt;bar + 2&lt;/code&gt;, but then why is it assigning to &lt;code&gt;foo&lt;/code&gt;? It's also possible that the intent was to use a comparison operator such as &lt;code&gt;==&lt;/code&gt; and that this code is an error.</source>
          <target state="translated">여기에 &lt;code&gt;return&lt;/code&gt; 진술 의 의도를 말하기가 어렵습니다 . 함수가 &lt;code&gt;bar + 2&lt;/code&gt; 의 결과를 반환하는 것이 가능할 수 있지만 왜 &lt;code&gt;foo&lt;/code&gt; 에 할당 됩니까? 의도는 &lt;code&gt;==&lt;/code&gt; 와 같은 비교 연산자를 사용 하고이 코드가 오류 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bfab86bd0d58f0b204ea60ad86d6c48fe5638be" translate="yes" xml:space="preserve">
          <source>It is never permissible to omit the braces in any part of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문의 어떤 부분에서도 중괄호를 생략 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0d610283fcff3de92ca8a3e960496ebdd493acd5" translate="yes" xml:space="preserve">
          <source>It is often necessary to capture the current execution context in order to make it available subsequently. A prominent example of this are jQuery callbacks:</source>
          <target state="translated">이후에 사용 가능하게하려면 현재 실행 컨텍스트를 캡처해야하는 경우가 종종 있습니다. 이에 대한 대표적인 예는 jQuery 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="dfc9afbf00569a0e87286216aa95f76c773a479c" translate="yes" xml:space="preserve">
          <source>It is passed into a function as an argument (&lt;code&gt;doSomething(foo)&lt;/code&gt;)</source>
          <target state="translated">인수로 함수에 전달됩니다 ( &lt;code&gt;doSomething(foo)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dfa2013456253628c34682b02d1086b4f4ef7bcc" translate="yes" xml:space="preserve">
          <source>It is read (&lt;code&gt;var bar = foo&lt;/code&gt;)</source>
          <target state="translated">읽습니다 ( &lt;code&gt;var bar = foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0a1cbdcc89556b2945c916ade57ddabf664e1243" translate="yes" xml:space="preserve">
          <source>It is read inside of a function that is passed to another function (&lt;code&gt;doSomething(function() { foo(); })&lt;/code&gt;)</source>
          <target state="translated">다른 함수에 전달 된 함수 내부에서 읽습니다 ( &lt;code&gt;doSomething(function() { foo(); })&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cbbe54b3892924943f5cfe9bf7ffc5f5c0209850" translate="yes" xml:space="preserve">
          <source>It is the best practice to avoid 'polluting' the global scope with variables that are intended to be local to the script.</source>
          <target state="translated">스크립트에 국한되는 변수로 전역 범위를 '오염'시키는 것을 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d55327c58055d26684cdaa59dbf53b5743e7d61a" translate="yes" xml:space="preserve">
          <source>It may facilitate identifying symbols when one is observed during debugging.</source>
          <target state="translated">디버깅 중에 심볼이 관찰 될 때 심볼을 식별하는 것이 용이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="114d866dd6678baad5a769edfd94f8aa8e3b81d5" translate="yes" xml:space="preserve">
          <source>It must be a Node module loadable from the config file where it appears. Usually, this means you should install the parser package separately using npm.</source>
          <target state="translated">구성 파일에서로드 할 수있는 노드 모듈이어야합니다. 일반적으로 이것은 npm을 사용하여 구문 분석기 패키지를 별도로 설치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="41cebf36bc0a3258b56f36013f221f214f448509" translate="yes" xml:space="preserve">
          <source>It must conform to the &lt;a href=&quot;../developer-guide/working-with-plugins#working-with-custom-parsers&quot;&gt;parser interface&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../developer-guide/working-with-plugins#working-with-custom-parsers&quot;&gt;파서 인터페이스를&lt;/a&gt; 준수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf3f5af0d35e26dd178828257b423e55cf86a169" translate="yes" xml:space="preserve">
          <source>It will not catch blacklisted identifiers that are:</source>
          <target state="translated">다음과 같은 블랙리스트 식별자를 포착하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5d0d8c3a73df7cb32016f4fcb17e2f5afe0755f" translate="yes" xml:space="preserve">
          <source>It's a common mistake in JavaScript to create an object with just a setter for a property but never have a corresponding getter defined for it. Without a getter, you cannot read the property, so it ends up not being used.</source>
          <target state="translated">JavaScript에서는 속성에 대한 setter만으로 객체를 만들지 만 해당 getter가 정의되어 있지 않은 것은 일반적인 실수입니다. 게터가 없으면 속성을 읽을 수 없으므로 결국 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2aa041aeca24b1e83bce8e14db39165127131" translate="yes" xml:space="preserve">
          <source>It's a common mistake in JavaScript to use a conditional expression to select between two Boolean values instead of using ! to convert the test to a Boolean. Here are some examples:</source>
          <target state="translated">JavaScript에서는!를 사용하는 대신 조건식을 사용하여 두 부울 값 중에서 선택하는 것이 일반적입니다. 테스트를 부울로 변환합니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="1540ef4737be0d6ff417a0782976005f83977b1f" translate="yes" xml:space="preserve">
          <source>It's also possible to manually create a new wrapper instance:</source>
          <target state="translated">새 래퍼 인스턴스를 수동으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db4f5e50534780f1446698505a2d5bbe87d770d4" translate="yes" xml:space="preserve">
          <source>It's considered a best practice to avoid initializing variables to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">변수를 &lt;code&gt;undefined&lt;/code&gt; 로 초기화하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3b947e8368ebaac8be7eb45d05db7c278b4d8d20" translate="yes" xml:space="preserve">
          <source>It's considered a good practice to avoid using &lt;code&gt;eval()&lt;/code&gt; in JavaScript. There are security and performance implications involved with doing so, which is why many linters (including ESLint) recommend disallowing &lt;code&gt;eval()&lt;/code&gt;. However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;eval()&lt;/code&gt; 을 사용하지 않는 것이 좋습니다 . ESLint를 포함한 많은 linter가 &lt;code&gt;eval()&lt;/code&gt; 허용하지 않는 것이 좋습니다 . 그러나 문자열을 전달하고 비슷한 문제가있는 JavaScript 코드로 해석하는 다른 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="918a92ed2fd168a3c3cdb4b8edf6fc35db93de45" translate="yes" xml:space="preserve">
          <source>It's hard to tell, but there are two spaces between &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;. Multiple spaces such as this are generally frowned upon in favor of single spaces:</source>
          <target state="translated">말하기는 어렵지만 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;===&lt;/code&gt; 사이에는 두 개의 공백이 있습니다 . 이와 같은 여러 공간은 일반적으로 단일 공간을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="b430d90d24691524aa348af6d5cc4d1cefef18fc" translate="yes" xml:space="preserve">
          <source>It's less common to use &lt;code&gt;new&lt;/code&gt; and not store the result, such as:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;new&lt;/code&gt; 를 사용 하고 결과를 저장하지 않는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="d714e9087d5b54ecca2b51569eb95d74ddf8334f" translate="yes" xml:space="preserve">
          <source>It's possible to create functions in JavaScript using the &lt;code&gt;Function&lt;/code&gt; constructor, such as:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;Function&lt;/code&gt; 생성자를 사용하여 JavaScript에서 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee85d43b1ef036dbda6ac1ecca68ca0ebe5218b1" translate="yes" xml:space="preserve">
          <source>It's possible to create multiline strings in JavaScript by using a slash before a newline, such as:</source>
          <target state="translated">다음과 같이 줄 바꿈 앞에 슬래시를 사용하여 JavaScript에서 여러 줄 문자열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef00365692deaf723e678d24f89a72996bca75d" translate="yes" xml:space="preserve">
          <source>It's possible to have a class method which doesn't use &lt;code&gt;this&lt;/code&gt;, such as:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 사용하지 않는 클래스 메소드를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="338c73acf937231c9f586f241d1a166618a1a2de" translate="yes" xml:space="preserve">
          <source>It's possible to share multiple configs in the same npm package. You can specify a default config for the package by following the directions in the first section. You can specify additional configs by simply adding a new file to your npm package and then referencing it from your ESLint config.</source>
          <target state="translated">동일한 npm 패키지에서 여러 구성을 공유 할 수 있습니다. 첫 번째 섹션의 지침에 따라 패키지의 기본 구성을 지정할 수 있습니다. npm 패키지에 새 파일을 추가 한 다음 ESLint 구성에서 참조하여 추가 구성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="232ff89a49d744909e74bfbe6f3a0152ca2f07e5" translate="yes" xml:space="preserve">
          <source>It's therefore unnecessary to initialize a variable to &lt;code&gt;undefined&lt;/code&gt;, such as:</source>
          <target state="translated">따라서 다음과 같이 변수를 &lt;code&gt;undefined&lt;/code&gt; 로 초기화 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6700e2ff03beeb48145f7ff39dce207f42ed620a" translate="yes" xml:space="preserve">
          <source>It's unnecessary to concatenate two strings together, such as:</source>
          <target state="translated">다음과 같이 두 개의 문자열을 함께 연결할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcf1e0519c1e3f74f5179a17cad7d7e59f2d0a7d" translate="yes" xml:space="preserve">
          <source>It's unnecessary to use computed properties with literals such as:</source>
          <target state="translated">다음과 같은 리터럴과 함께 계산 된 속성을 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="56d6447c476a3f8a52dcf546edf453aff97884dd" translate="yes" xml:space="preserve">
          <source>It's up to the plugin to decide if it needs to return just one part, or multiple pieces. For example in the case of processing &lt;code&gt;.html&lt;/code&gt; files, you might want to return just one item in the array by combining all scripts, but for &lt;code&gt;.md&lt;/code&gt; file where each JavaScript block might be independent, you can return multiple items.</source>
          <target state="translated">한 부분 또는 여러 부분을 반환 해야하는지 여부는 플러그인에 달려 있습니다. 예를 들어 &lt;code&gt;.html&lt;/code&gt; 파일 을 처리하는 경우 모든 스크립트를 결합하여 배열에서 하나의 항목 만 반환하려고 할 수 있지만 각 JavaScript 블록이 독립적 인 &lt;code&gt;.md&lt;/code&gt; 파일의 경우 여러 항목을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6560f835b7a7d5870e94eb9b41e3fcd77d90d7e8" translate="yes" xml:space="preserve">
          <source>JSCS allows you to specify a configuration file to use on the command line using either &lt;code&gt;--config&lt;/code&gt; or &lt;code&gt;-c&lt;/code&gt;, such as:</source>
          <target state="translated">JSCS를 사용하면 &lt;code&gt;--config&lt;/code&gt; 또는 &lt;code&gt;-c&lt;/code&gt; 를 사용하여 명령 행에서 사용할 구성 파일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad2824b434b68a13856ffaff984918c67213b72f" translate="yes" xml:space="preserve">
          <source>JSCS uses the &lt;code&gt;--fix&lt;/code&gt; option to apply automatic fixes to code:</source>
          <target state="translated">JSCS는 &lt;code&gt;--fix&lt;/code&gt; 옵션을 사용하여 코드에 자동 수정을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7e6a7de74786bb8a06e6cd1f198e6bb251b32a02" translate="yes" xml:space="preserve">
          <source>JSCS: &lt;a href=&quot;https://jscs-dev.github.io/rule/requireNewlineBeforeSingleStatementsInIf&quot;&gt;requireNewlineBeforeSingleStatementsInIf&lt;/a&gt;</source>
          <target state="translated">JSCS : &lt;a href=&quot;https://jscs-dev.github.io/rule/requireNewlineBeforeSingleStatementsInIf&quot;&gt;requireNewlineBeforeSingleStatementsInIf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb066eaad6fec2a6a994996f176b5cede7d0c117" translate="yes" xml:space="preserve">
          <source>JSDoc</source>
          <target state="translated">JSDoc</target>
        </trans-unit>
        <trans-unit id="03371684afaf55d8f3d68e5dc095125a09ff3cd3" translate="yes" xml:space="preserve">
          <source>JSON whitespace issues</source>
          <target state="translated">JSON 공백 문제</target>
        </trans-unit>
        <trans-unit id="ae37798c9273d9a9a11bbfcf191ad17fc943238e" translate="yes" xml:space="preserve">
          <source>JSX attribute values can contain string literals, which are delimited with single or double quotes.</source>
          <target state="translated">JSX 속성 값은 작은 리터럴 또는 큰 따옴표로 구분 된 문자열 리터럴을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb39ed38ed1f1854a0f052be116e2d4d4ed3892" translate="yes" xml:space="preserve">
          <source>JSX exception</source>
          <target state="translated">JSX 예외</target>
        </trans-unit>
        <trans-unit id="3755f3f206953314cab133719791d70c7c568127" translate="yes" xml:space="preserve">
          <source>Jasmine</source>
          <target state="translated">Jasmine</target>
        </trans-unit>
        <trans-unit id="aeb477733ef3bd24e40cc3ef2f023ec0e75bb981" translate="yes" xml:space="preserve">
          <source>JavaScript Scoping and Hoisting</source>
          <target state="translated">JavaScript 범위 지정 및 게양</target>
        </trans-unit>
        <trans-unit id="35fd2acb7480cdbfc20e463c2d778164a28c3af8" translate="yes" xml:space="preserve">
          <source>JavaScript Semicolon Insertion</source>
          <target state="translated">자바 스크립트 세미콜론 삽입</target>
        </trans-unit>
        <trans-unit id="a1533b7dece4ef1e890cbfd9e9b05d2df5893150" translate="yes" xml:space="preserve">
          <source>JavaScript allows for placing unnecessary spaces between an expression and the closing semicolon.</source>
          <target state="translated">JavaScript는 표현식과 닫는 세미콜론 사이에 불필요한 공백을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb3776e4f2a012989a09983f23fbfa42da091730" translate="yes" xml:space="preserve">
          <source>JavaScript allows operands of ternary expressions to be separated by newlines, which can improve the readability of your program.</source>
          <target state="translated">JavaScript는 삼항 표현식의 피연산자를 개행으로 분리하여 프로그램의 가독성을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70238e7446b2c14f3c63ee52342d01ab306e0ac0" translate="yes" xml:space="preserve">
          <source>JavaScript allows the omission of curly braces when a block contains only one statement. However, it is considered by many to be best practice to &lt;em&gt;never&lt;/em&gt; omit curly braces around blocks, even when they are optional, because it can lead to bugs and reduces code clarity. So the following:</source>
          <target state="translated">블록에 하나의 명령문 만 포함 된 경우 JavaScript는 중괄호를 생략 할 수 있습니다. 그러나 버그로 이어질 수 있고 코드 선명도를 떨어 뜨릴 수 있기 때문에 선택 사항 인 경우에도 블록 주위에 중괄호를 생략 &lt;em&gt;하지 않는&lt;/em&gt; 것이 가장 좋습니다 . 그래서 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="874615b72be77374791ea953ea46256b48a8b2d9" translate="yes" xml:space="preserve">
          <source>JavaScript allows the omission of parentheses when invoking a function via the &lt;code&gt;new&lt;/code&gt; keyword and the constructor has no arguments. However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus makes code less clear.</source>
          <target state="translated">JavaScript는 &lt;code&gt;new&lt;/code&gt; 키워드 를 통해 함수를 호출 할 때 괄호를 생략 할 수 있으며 생성자는 인수가 없습니다. 그러나 일부 코더는 괄호를 생략하면 나머지 언어와 일치하지 않으므로 코드가 명확하지 않다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="1b3cd75cba9ae18b5f809b6e802a6ac27d7d0cb6" translate="yes" xml:space="preserve">
          <source>JavaScript allows whitespace between objects and their properties. However, inconsistent spacing can make code harder to read and can lead to errors.</source>
          <target state="translated">JavaScript는 객체와 속성 사이에 공백을 허용합니다. 그러나 간격이 일치하지 않으면 코드를 읽기가 어려워지고 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc87ecb051dcb25ce39847b91018535b39fdc05" translate="yes" xml:space="preserve">
          <source>JavaScript allows you to define strings in one of three ways: double quotes, single quotes, and backticks (as of ECMAScript 6). For example:</source>
          <target state="translated">JavaScript를 사용하면 큰 따옴표, 작은 따옴표 및 백틱 (ECMAScript 6 기준) 중 한 가지 방법으로 문자열을 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5c94ad5d9baaf1eef18b221f414ea08803b2b2b" translate="yes" xml:space="preserve">
          <source>JavaScript allows you to place newlines before or after a dot in a member expression.</source>
          <target state="translated">JavaScript를 사용하면 멤버 표현식에서 점 앞뒤에 줄 바꿈을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9324f42b811ab6297f7a807c024f230020aaf3" translate="yes" xml:space="preserve">
          <source>JavaScript allows you to place unnecessary spaces before or after a semicolon.</source>
          <target state="translated">JavaScript를 사용하면 세미콜론 앞이나 뒤에 불필요한 공백을 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cecfbaf09bf74a3e6308e2394b0e0e42e4f3694" translate="yes" xml:space="preserve">
          <source>JavaScript environments contain a number of built-in global variables, such as &lt;code&gt;window&lt;/code&gt; in browsers and &lt;code&gt;process&lt;/code&gt; in Node.js. In almost all cases, you don't want to assign a value to these global variables as doing so could result in losing access to important functionality. For example, you probably don't want to do this in browser code:</source>
          <target state="translated">JavaScript 환경에는 브라우저의 &lt;code&gt;window&lt;/code&gt; 및 Node.js의 &lt;code&gt;process&lt;/code&gt; 와 같은 여러 내장 전역 변수가 포함됩니다 . 대부분의 경우 이러한 전역 변수에 값을 지정하지 않으면 중요한 기능에 대한 액세스 권한이 손실 될 수 있습니다. 예를 들어, 브라우저 코드에서이 작업을 수행하고 싶지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf5eedeafd607eaa45b9a97d92f8d8ae4ea268f" translate="yes" xml:space="preserve">
          <source>JavaScript functions can be written as a FunctionDeclaration &lt;code&gt;function foo() { ... }&lt;/code&gt; or as a FunctionExpression &lt;code&gt;var foo = function() { ... };&lt;/code&gt;. While a JavaScript interpreter might tolerate it, overwriting/reassigning a function written as a FunctionDeclaration is often indicative of a mistake or issue.</source>
          <target state="translated">JavaScript 함수는 FunctionDeclaration &lt;code&gt;function foo() { ... }&lt;/code&gt; 또는 FunctionExpression으로 작성할 수 있습니다. &lt;code&gt;var foo = function() { ... };&lt;/code&gt; . JavaScript 인터프리터가이를 용인 할 수 있지만 FunctionDeclaration으로 작성된 함수를 덮어 쓰거나 재지 정하는 것은 종종 실수 나 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46aa43f956749763c4c77aef295237374a62c29e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of language features, and not everyone likes all of them. As a result, some projects choose to disallow the use of certain language features altogether. For instance, you might decide to disallow the use of &lt;code&gt;try-catch&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;, or you might decide to disallow the use of the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">JavaScript에는 많은 언어 기능이 있으며 모든 사람이이를 좋아하는 것은 아닙니다. 결과적으로 일부 프로젝트는 특정 언어 기능을 모두 사용하지 못하도록 선택합니다. 예를 들어 &lt;code&gt;try-catch&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 사용을 허용하지 않거나 &lt;code&gt;in&lt;/code&gt; 연산자 사용을 허용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b4a005b83e68cac28ad34d043efe8c63977c815" translate="yes" xml:space="preserve">
          <source>JavaScript is unique amongst the C-like languages in that it doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as &lt;strong&gt;automatic semicolon insertion (ASI)&lt;/strong&gt; and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:</source>
          <target state="translated">JavaScript는 C와 유사한 언어 중에서 고유하므로 각 명령문 끝에 세미콜론이 필요하지 않습니다. 대부분의 경우 JavaScript 엔진은 세미콜론이 특정 지점에 있어야하고 자동으로 추가 할 것이라고 판단 할 수 있습니다. 이 기능은 &lt;strong&gt;자동 세미콜론 삽입 (ASI)&lt;/strong&gt; 이라고하며 JavaScript의 논란이 많은 기능 중 하나로 간주됩니다. 예를 들어 다음 줄은 모두 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ec241f3f76e7823d627bd4584bd71234938ed3c6" translate="yes" xml:space="preserve">
          <source>JavaScript provides shorthand operators that combine variable assignment and some simple mathematical operations. For example, &lt;code&gt;x = x + 4&lt;/code&gt; can be shortened to &lt;code&gt;x += 4&lt;/code&gt;. The supported shorthand forms are as follows:</source>
          <target state="translated">JavaScript는 변수 할당과 간단한 수학 연산을 결합한 속기 연산자를 제공합니다. 예를 들어, &lt;code&gt;x = x + 4&lt;/code&gt; 는 &lt;code&gt;x += 4&lt;/code&gt; 로 단축 될 수 있습니다 . 지원되는 속기 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47c3f29689bdd2ef62ccda2e081bc789ad36a502" translate="yes" xml:space="preserve">
          <source>JavaScript suspends the control flow statements of &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; blocks until the execution of &lt;code&gt;finally&lt;/code&gt; block finishes. So, when &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, or &lt;code&gt;continue&lt;/code&gt; is used in &lt;code&gt;finally&lt;/code&gt;, control flow statements inside &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are overwritten, which is considered as unexpected behavior. Such as:</source>
          <target state="translated">JavaScript 는 &lt;code&gt;finally&lt;/code&gt; 블록이 실행될 때까지 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 블록 의 제어 흐름 문을 일시 중단합니다 . 따라서 &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 가 &lt;code&gt;finally&lt;/code&gt; 에 사용될 때 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 내의 제어 흐름 문 을 덮어 쓰게되며 예기치 않은 동작으로 간주됩니다. 같은 :</target>
        </trans-unit>
        <trans-unit id="0bed567369bc5dad154764ff85e0f62d5a508f04" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;code&gt;alert&lt;/code&gt;, &lt;code&gt;confirm&lt;/code&gt;, and &lt;code&gt;prompt&lt;/code&gt; functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation. Furthermore, &lt;code&gt;alert&lt;/code&gt; is often used while debugging code, which should be removed before deployment to production.</source>
          <target state="translated">JavaScript의 &lt;code&gt;alert&lt;/code&gt; , &lt;code&gt;confirm&lt;/code&gt; 및 &lt;code&gt;prompt&lt;/code&gt; 기능은 UI 요소로서 방해가되는 것으로 널리 간주되며보다 적절한 사용자 정의 UI 구현으로 대체해야합니다. 또한 코드를 디버깅하는 동안 &lt;code&gt;alert&lt;/code&gt; 가 자주 사용되므로 프로덕션 환경에 배포하기 전에 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb36d203e1e163e1a6bae5dfbd3a4757283a3d47" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;code&gt;eval()&lt;/code&gt; function is potentially dangerous and is often misused. Using &lt;code&gt;eval()&lt;/code&gt; on untrusted code can open a program up to several different injection attacks. The use of &lt;code&gt;eval()&lt;/code&gt; in most contexts can be substituted for a better, alternative approach to a problem.</source>
          <target state="translated">JavaScript의 &lt;code&gt;eval()&lt;/code&gt; 함수는 잠재적으로 위험하며 종종 오용됩니다. 신뢰할 수없는 코드에서 &lt;code&gt;eval()&lt;/code&gt; 을 사용하면 여러 가지 다른 주입 공격까지 프로그램을 열 수 있습니다. 의 사용 &lt;code&gt;eval()&lt;/code&gt; 대부분의 상황에서이 문제에 대한 더 나은 다른 방법으로 대체 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ff0382e972b4c38f7e98ab4c1c45d9893b525347" translate="yes" xml:space="preserve">
          <source>JavaScript: Don&amp;rsquo;t Reassign Your Function Arguments</source>
          <target state="translated">JavaScript : 함수 인수를 다시 할당하지 마십시오</target>
        </trans-unit>
        <trans-unit id="1ca76be7b84d714e17e61b65c84bec4810f63dd5" translate="yes" xml:space="preserve">
          <source>Javascript</source>
          <target state="translated">Javascript</target>
        </trans-unit>
        <trans-unit id="de938f1548a4251b63d23119145ba2c835fe9fb6" translate="yes" xml:space="preserve">
          <source>Just as developers might type &lt;code&gt;-a + b&lt;/code&gt; when they mean &lt;code&gt;-(a + b)&lt;/code&gt; for the negative of a sum, they might type &lt;code&gt;!key in object&lt;/code&gt; by mistake when they almost certainly mean &lt;code&gt;!(key in object)&lt;/code&gt; to test that a key is not in an object.</source>
          <target state="translated">개발자가 합의 음수에 대해 &lt;code&gt;-(a + b)&lt;/code&gt; 를 의미 할 때 &lt;code&gt;-a + b&lt;/code&gt; 입력 할 수있는 것처럼, 키를 테스트하기 위해 거의 확실하게 &lt;code&gt;!(key in object)&lt;/code&gt; 를 의미 할 때 실수로 &lt;code&gt;!key in object&lt;/code&gt; 에 입력 할 수 있습니다 . 개체에 없습니다.</target>
        </trans-unit>
        <trans-unit id="000a2d9b669cfca9b9c610b40fd644d3f5bb04e7" translate="yes" xml:space="preserve">
          <source>Just as developers might type &lt;code&gt;-a + b&lt;/code&gt; when they mean &lt;code&gt;-(a + b)&lt;/code&gt; for the negative of a sum, they might type &lt;code&gt;!key in object&lt;/code&gt; by mistake when they almost certainly mean &lt;code&gt;!(key in object)&lt;/code&gt; to test that a key is not in an object. &lt;code&gt;!obj instanceof Ctor&lt;/code&gt; is similar.</source>
          <target state="translated">개발자가 합의 음수에 대해 &lt;code&gt;-(a + b)&lt;/code&gt; 를 의미 할 때 &lt;code&gt;-a + b&lt;/code&gt; 입력 할 수있는 것처럼, 키를 테스트하기 위해 거의 확실하게 &lt;code&gt;!(key in object)&lt;/code&gt; 를 의미 할 때 실수로 &lt;code&gt;!key in object&lt;/code&gt; 에 입력 할 수 있습니다 . 개체에 없습니다. &lt;code&gt;!obj instanceof Ctor&lt;/code&gt; 는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="e7c5d4963c2bb1e89fc55db41dc9f08d57c55c03" translate="yes" xml:space="preserve">
          <source>Keep in mind that comments are technically not a part of the AST and are only attached to it on demand, i.e. when you call &lt;code&gt;getComments()&lt;/code&gt;.</source>
          <target state="translated">주석은 기술적으로 AST의 일부가 아니며 요청시 (예 : &lt;code&gt;getComments()&lt;/code&gt; 호출 할 때만) 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0cf9d5c180dc8564a0d7f4b2a8b48a106463c1f" translate="yes" xml:space="preserve">
          <source>Keep in mind that the results of this method are calculated on demand.</source>
          <target state="translated">이 방법의 결과는 요청시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd26d701e8f6ce99367d708dc895d0600bdb131" translate="yes" xml:space="preserve">
          <source>Keep in mind that we have over 200 rules, and that is daunting both for end users and the ESLint team (who has to maintain them). As such, any new rules must be deemed of high importance to be considered for inclusion in ESLint.</source>
          <target state="translated">200 개가 넘는 규칙이 있으며 최종 사용자와 ESLint 팀 (규칙을 유지 관리해야 함) 모두에게 위배됩니다. 따라서 ESLint에 포함시키기 위해서는 새로운 규칙이 중요하다고 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa5d51b19a07be0d8f7c43f2a968f97c27a9cb40" translate="yes" xml:space="preserve">
          <source>Keep your rule names as short as possible, use abbreviations where appropriate, and no more than four words.</source>
          <target state="translated">규칙 이름을 가능한 짧게 유지하고 필요한 경우 약어를 사용하고 4 단어를 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0f1567b40d5b2ede1e1ea5371f1e60b1c78c78b4" translate="yes" xml:space="preserve">
          <source>Keeping to one of these styles across a project's codebase can help with maintaining code consistency.</source>
          <target state="translated">프로젝트 코드베이스에서 이러한 스타일 중 하나를 유지하면 코드 일관성을 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede3a17a01c5c55ed695487d421a99c9eb323e43" translate="yes" xml:space="preserve">
          <source>Keywords are syntax elements of JavaScript, such as &lt;code&gt;function&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;. These identifiers have special meaning to the language and so often appear in a different color in code editors. As an important part of the language, style guides often refer to the spacing that should be used around keywords. For example, you might have a style guide that says keywords should be always be preceded by spaces, which would mean &lt;code&gt;if-else&lt;/code&gt; statements must look like this:</source>
          <target state="translated">키워드는 &lt;code&gt;function&lt;/code&gt; 및 &lt;code&gt;if&lt;/code&gt; 와 같은 JavaScript의 구문 요소입니다 . 이 식별자는 언어에 특별한 의미가 있으므로 코드 편집기에서 다른 색으로 표시되는 경우가 많습니다. 언어의 중요한 부분으로 스타일 가이드는 종종 키워드와 함께 사용해야하는 간격을 나타냅니다. 예를 들어 키워드 앞에 항상 공백이 있어야한다는 스타일 가이드가있을 수 있습니다. 즉 &lt;code&gt;if-else&lt;/code&gt; 문은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="04fdc186fe5b056bf0b371917035f93e70f4315f" translate="yes" xml:space="preserve">
          <source>Keywords are syntax elements of JavaScript, such as &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;. These keywords have special meaning to the language and so often appear in a different color in code editors. As an important part of the language, style guides often refer to the spacing that should be used around keywords. For example, you might have a style guide that says keywords should be always surrounded by spaces, which would mean &lt;code&gt;if-else&lt;/code&gt; statements must look like this:</source>
          <target state="translated">키워드는 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;if&lt;/code&gt; 와 같은 JavaScript의 구문 요소입니다 . 이 키워드는 언어에 특별한 의미를 지니므로 종종 코드 편집기에서 다른 색상으로 나타납니다. 언어의 중요한 부분으로 스타일 가이드는 종종 키워드와 함께 사용해야하는 간격을 나타냅니다. 예를 들어 키워드는 항상 공백으로 묶어야한다는 스타일 가이드가있을 수 있습니다. 즉 &lt;code&gt;if-else&lt;/code&gt; 문은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="616ae0e516f073c066a59a8a38d5b52110f5407c" translate="yes" xml:space="preserve">
          <source>Known Limitations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefb9f3a1db6e7c07463bd61307df961e5c58166" translate="yes" xml:space="preserve">
          <source>Known issues these spaces cause:</source>
          <target state="translated">이러한 공간으로 인해 알려진 문제 :</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="2e1b2523d4a68ad42a3b6d5503d6d80ddf3b1ade" translate="yes" xml:space="preserve">
          <source>Labeled statements are only used in conjunction with labeled break and continue statements. ECMAScript has no goto statement.</source>
          <target state="translated">레이블이있는 명령문은 레이블이있는 break 및 continue 문과 함께 만 사용됩니다. ECMAScript에는 goto 문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4101de43a6ddffb71075f1f736064d12f1f6f81" translate="yes" xml:space="preserve">
          <source>Labeled statements in JavaScript are used in conjunction with &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; to control flow around multiple loops. For example:</source>
          <target state="translated">자바 스크립트의 레이블 문와 함께 사용되는 &lt;code&gt;break&lt;/code&gt; 와 &lt;code&gt;continue&lt;/code&gt; 여러 루프를 주위 흐름을 제어 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="578dee19c6502f01a038eb78b3e49185c558cf41" translate="yes" xml:space="preserve">
          <source>Labels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.</source>
          <target state="translated">코드에서 선언되어 사용되지 않은 레이블은 리팩토링이 불완전하기 때문에 오류 일 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="b541cfe1ccb84d2c69d0625a99389540b77207ad" translate="yes" xml:space="preserve">
          <source>Language Options</source>
          <target state="translated">언어 옵션</target>
        </trans-unit>
        <trans-unit id="c83f2b161b8660b0f54cc1c267ca1f4032a63ad5" translate="yes" xml:space="preserve">
          <source>Large - Runs ESLint on JSHint</source>
          <target state="translated">Large-JSHint에서 ESLint를 실행합니다</target>
        </trans-unit>
        <trans-unit id="6237b22967da3f057cb71015bdcdfde4226ee27a" translate="yes" xml:space="preserve">
          <source>Last, it advances to the end.</source>
          <target state="translated">마지막으로 끝까지 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="9791177c6b357c99f38a6978d495bcc8f01ed2dd" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;user-guide/configuring&quot;&gt;advanced configuration&lt;/a&gt; of ESLint.</source>
          <target state="translated">ESLint의 &lt;a href=&quot;user-guide/configuring&quot;&gt;고급 구성&lt;/a&gt; 에 대해 학습합니다 .</target>
        </trans-unit>
        <trans-unit id="cbbe2fab2ebf18de7304c94a0bc02843f5d36771" translate="yes" xml:space="preserve">
          <source>Less clear:</source>
          <target state="translated">덜 명확 :</target>
        </trans-unit>
        <trans-unit id="976713d5799583acf6a0e5a8fbc1bb4180537050" translate="yes" xml:space="preserve">
          <source>Let's fix Node.js Buffer API</source>
          <target state="translated">Node.js 버퍼 API를 수정하자</target>
        </trans-unit>
        <trans-unit id="b837d744af533d631032679a5d43e88b68690a08" translate="yes" xml:space="preserve">
          <source>Let's look at the following perfectly valid (but single line) code.</source>
          <target state="translated">다음과 같이 완벽하게 유효한 (단일 줄) 코드를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="230759061d18d6dc57a7ec18ba52827940445025" translate="yes" xml:space="preserve">
          <source>Level of indentation denotes the multiple of the indent specified. Example:</source>
          <target state="translated">들여 쓰기 수준은 지정된 들여 쓰기의 배수를 나타냅니다. 예:</target>
        </trans-unit>
        <trans-unit id="abe24f73a4adf73f80d772b8c813e00b0527dce6" translate="yes" xml:space="preserve">
          <source>Lexical declarations &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;, as well as &lt;code&gt;class&lt;/code&gt; declarations, create variables that are block-scoped.</source>
          <target state="translated">어휘 선언 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;class&lt;/code&gt; 선언은 블록 범위의 변수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="283e35c5290c66cc5d747cb923851a3eaf110a70" translate="yes" xml:space="preserve">
          <source>Lexically declared variables are shadowing properties of the global object, which might produce errors if a consuming script is using both the variable and the property.</source>
          <target state="translated">사전에 선언 된 변수는 전역 개체의 그림자 속성이므로 소비 스크립트가 변수와 속성을 모두 사용하는 경우 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2804cac1a3610e9d560401096d1b0ec1d1c27ea1" translate="yes" xml:space="preserve">
          <source>Lexically declared variables can produce a permanent Temporal Dead Zone (TDZ) if the initialization throws an exception. Even the &lt;code&gt;typeof&lt;/code&gt; check is not safe from TDZ reference exceptions.</source>
          <target state="translated">사전에 선언 된 변수는 초기화에서 예외가 발생하면 영구 TDZ (Temporal Dead Zone)를 생성 할 수 있습니다. 심지어 &lt;code&gt;typeof&lt;/code&gt; 검사는 TDZ 참조 예외로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f225bdc0c179471d37c539bc0687e6c4f1ede246" translate="yes" xml:space="preserve">
          <source>Lexically declared variables cannot be conditionally created. A script cannot check for the existence of a variable and then create a new one. &lt;code&gt;var&lt;/code&gt; variables are also always created, but redeclarations do not cause runtime exceptions.</source>
          <target state="translated">사전에 선언 된 변수는 조건부로 만들 수 없습니다. 스크립트는 변수가 있는지 확인한 다음 새 변수를 만들 수 없습니다. &lt;code&gt;var&lt;/code&gt; 변수도 항상 생성되지만 재 선언으로 인해 런타임 예외가 발생하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e80a36f53dbe317f96ffd3bade7375caa2f65f51" translate="yes" xml:space="preserve">
          <source>Lexically declared variables do not create properties on the global object, which is what a consuming script might expect.</source>
          <target state="translated">사전에 선언 된 변수는 전역 개체에 속성을 만들지 않으므로 소비하는 스크립트가 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="576a19e712655d862677383bbd691c58cb28af93" translate="yes" xml:space="preserve">
          <source>Limit Cyclomatic Complexity (complexity)</source>
          <target state="translated">순환 복잡성 제한 (복잡성)</target>
        </trans-unit>
        <trans-unit id="8063848dd725bd56f98d4d78213b9bcdc4a7dc13" translate="yes" xml:space="preserve">
          <source>Line Separator</source>
          <target state="translated">선 구분자</target>
        </trans-unit>
        <trans-unit id="f92175557e0de68fd93e204cef5f084870a15ddc" translate="yes" xml:space="preserve">
          <source>Line comments can be positioned above or beside code. This rule helps teams maintain a consistent style.</source>
          <target state="translated">줄 설명은 코드 위 또는 옆에 배치 할 수 있습니다. 이 규칙은 팀이 일관된 스타일을 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a034b76db3a8cd859ca69ba997a2e5b89502c859" translate="yes" xml:space="preserve">
          <source>Lines beginning with &lt;code&gt;#&lt;/code&gt; are treated as comments and do not affect ignore patterns.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 주석으로 취급되며 무시 패턴에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e1103eb32ea263486103b072ab0cb94ee3e35e9" translate="yes" xml:space="preserve">
          <source>Lines preceded by &lt;code&gt;!&lt;/code&gt; are negated patterns that re-include a pattern that was ignored by an earlier pattern.</source>
          <target state="translated">앞에 줄 &lt;code&gt;!&lt;/code&gt; 는 이전 패턴에서 무시 된 패턴을 다시 포함하는 무시 된 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="b4e10ddd90309b99f26fe4ef3e11b979bcef032a" translate="yes" xml:space="preserve">
          <source>Linter</source>
          <target state="translated">Linter</target>
        </trans-unit>
        <trans-unit id="bd52ff0399c852f8ad0d3b77ab2cbeba60a0d700" translate="yes" xml:space="preserve">
          <source>Linter#defineParser</source>
          <target state="translated">Linter#defineParser</target>
        </trans-unit>
        <trans-unit id="b3ec5ecd25a2470772a54fc04ae781a897dc4ac5" translate="yes" xml:space="preserve">
          <source>Linter#defineRule</source>
          <target state="translated">Linter#defineRule</target>
        </trans-unit>
        <trans-unit id="ab2d970ff5589fa92fce8827e35e3cb27afbb239" translate="yes" xml:space="preserve">
          <source>Linter#defineRules</source>
          <target state="translated">Linter#defineRules</target>
        </trans-unit>
        <trans-unit id="c4067e92f7ce3c6ae4a3d5aee194da0f0c54b6d7" translate="yes" xml:space="preserve">
          <source>Linter#getRules</source>
          <target state="translated">Linter#getRules</target>
        </trans-unit>
        <trans-unit id="aaff2261febbb9366e58763b28e5e7c542a2f676" translate="yes" xml:space="preserve">
          <source>Linter#verify</source>
          <target state="translated">Linter#verify</target>
        </trans-unit>
        <trans-unit id="2e5cf5d2293ba06968be45b3f4addc313adecbc1" translate="yes" xml:space="preserve">
          <source>Linter#verifyAndFix()</source>
          <target state="translated">Linter#verifyAndFix()</target>
        </trans-unit>
        <trans-unit id="cec5cfe559583c5da1e9000641be0f2df5c73dd3" translate="yes" xml:space="preserve">
          <source>Linter#version/Linter.version</source>
          <target state="translated">Linter#version/Linter.version</target>
        </trans-unit>
        <trans-unit id="6f0e0a2d089a5b32424b770572c725a6c435e42f" translate="yes" xml:space="preserve">
          <source>Linting completed successfully, but there are some linting errors</source>
          <target state="translated">Linting이 성공적으로 완료되었지만 일부 Linting 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c9a7f39e6010cad2bf31168096d66c5530b646" translate="yes" xml:space="preserve">
          <source>Linting message objects have a deprecated &lt;code&gt;source&lt;/code&gt; property. This property &lt;strong&gt;will be removed&lt;/strong&gt; from linting messages in an upcoming breaking release. If you depend on this property, you should now use the &lt;code&gt;SourceCode&lt;/code&gt; instance provided by the linter.</source>
          <target state="translated">Linting 메시지 객체에는 더 이상 사용되지 않는 &lt;code&gt;source&lt;/code&gt; 속성이 있습니다. 이 속보는 다음 속보 릴리스에서 보푸라기 메시지에서 &lt;strong&gt;제거됩니다&lt;/strong&gt; . 이 속성에 의존하는 경우 이제 린터에서 제공 한 &lt;code&gt;SourceCode&lt;/code&gt; 인스턴스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c1213d86c311a55a32e3f6456710a05c9c2fe6f4" translate="yes" xml:space="preserve">
          <source>Linting nonexistent files from the command line is now a fatal error</source>
          <target state="translated">명령 행에서 존재하지 않는 파일을 린팅하는 것은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a144df07dbce74479e8b92fdbe30e5e2b955fdd1" translate="yes" xml:space="preserve">
          <source>Linting was unsuccessful due to a fatal error (e.g. an invalid config file)</source>
          <target state="translated">치명적인 오류 (예 : 잘못된 구성 파일)로 인해 Linting에 실패했습니다</target>
        </trans-unit>
        <trans-unit id="7c38fe4b5e5c8c9cd3ce408dd2302ed5b7c90528" translate="yes" xml:space="preserve">
          <source>Lints all JavaScript (including tests) and JSON</source>
          <target state="translated">모든 JavaScript (테스트 포함)와 JSON을 보푸라기</target>
        </trans-unit>
        <trans-unit id="9859b39a8931642fd476002b377a57cd6f6500db" translate="yes" xml:space="preserve">
          <source>Listening for selectors in rules</source>
          <target state="translated">규칙에서 선택자를 청취</target>
        </trans-unit>
        <trans-unit id="32758c6a32e39c1401c20a7c7526852af5d1a0a6" translate="yes" xml:space="preserve">
          <source>Loads a plugin from configuration object with specified name. Name can include plugin prefix (&quot;eslint-plugin-&quot;)</source>
          <target state="translated">지정된 이름으로 구성 객체에서 플러그인을로드합니다. 이름은 플러그인 접두사 ( &quot;eslint-plugin-&quot;)를 포함 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a89b90142250f6a97e005e05eeb2bc4cbcdeb3e4" translate="yes" xml:space="preserve">
          <source>Local Config File Resolution</source>
          <target state="translated">로컬 구성 파일 확인</target>
        </trans-unit>
        <trans-unit id="bf880468615d510777cab4ad8eddc24def271ed4" translate="yes" xml:space="preserve">
          <source>Logical Operators: &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt;, &lt;code&gt;&quot;||&quot;&lt;/code&gt;</source>
          <target state="translated">논리 연산자 : &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; , &lt;code&gt;&quot;||&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3afad3c0cae14119bc8f48a27e6623f7df048b3" translate="yes" xml:space="preserve">
          <source>Looping over objects with a &lt;code&gt;for in&lt;/code&gt; loop will include properties that are inherited through the prototype chain. This behavior can lead to unexpected items in your for loop.</source>
          <target state="translated">&lt;code&gt;for in&lt;/code&gt; 루프를 사용하여 객체를 반복 하면 프로토 타입 체인을 통해 상속되는 속성이 포함됩니다. 이 동작으로 인해 for 루프에서 예기치 않은 항목이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7cc822b9501098075842137a86406605e675538" translate="yes" xml:space="preserve">
          <source>MDN - Iterators and Generators</source>
          <target state="translated">MDN-반복자와 생성기</target>
        </trans-unit>
        <trans-unit id="85f054c946360a1bdde533b30957e8ab936b4d2f" translate="yes" xml:space="preserve">
          <source>MDN Arithmetic Operators - Exponentiation</source>
          <target state="translated">MDN 산술 연산자-지수</target>
        </trans-unit>
        <trans-unit id="3e90f0d78176e3c84b42ca0c6d98e231385391cf" translate="yes" xml:space="preserve">
          <source>MDN setter</source>
          <target state="translated">MDN 세터</target>
        </trans-unit>
        <trans-unit id="a2193d22aa101ed468111273da4fc9a8ff26cb08" translate="yes" xml:space="preserve">
          <source>MDN: &lt;code&gt;typeof&lt;/code&gt; documentation</source>
          <target state="translated">MDN : &lt;code&gt;typeof&lt;/code&gt; 문서</target>
        </trans-unit>
        <trans-unit id="94dc241af5d9eb0a680088ee20211bc0c0311d3c" translate="yes" xml:space="preserve">
          <source>MDN: Functions getter</source>
          <target state="translated">MDN : 함수 게터</target>
        </trans-unit>
        <trans-unit id="afae02907d2f28836e8ebcf79b528469165b5953" translate="yes" xml:space="preserve">
          <source>MDN: Operator Precedence</source>
          <target state="translated">MDN : 운영자 우선 순위</target>
        </trans-unit>
        <trans-unit id="40980a42cc4812dad76a30f975d0ecb98f42a1d9" translate="yes" xml:space="preserve">
          <source>MDN: RegExp Constructor</source>
          <target state="translated">MDN : RegExp 생성자</target>
        </trans-unit>
        <trans-unit id="b2777e08fa18d849dfd73d3f3047a7b8ba8d3042" translate="yes" xml:space="preserve">
          <source>MDN: Regular Expressions</source>
          <target state="translated">MDN : 정규식</target>
        </trans-unit>
        <trans-unit id="09d82cc59ea6b15487145efc5860cbacae4c5187" translate="yes" xml:space="preserve">
          <source>Make ESLint even better by &lt;a href=&quot;developer-guide/contributing/index&quot;&gt;contributing&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;developer-guide/contributing/index&quot;&gt;기여&lt;/a&gt; 하여 ESLint를 더욱 개선하십시오 .</target>
        </trans-unit>
        <trans-unit id="08102ad0462aa310615f1de442b43a80696f3f09" translate="yes" xml:space="preserve">
          <source>Make fixes as small as possible. Fixes that are unnecessarily large could conflict with other fixes, and prevent them from being applied.</source>
          <target state="translated">가능한 한 작게 수정하십시오. 불필요하게 큰 수정 프로그램은 다른 수정 프로그램과 충돌하여 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49ba3a90310eda05b6222d40e80f85b80ab264cc" translate="yes" xml:space="preserve">
          <source>Make fixes that are as small as possible. Anything more than a single character is risky and could prevent other, simpler fixes from being made.</source>
          <target state="translated">가능한 작은 수정 사항을 작성하십시오. 하나 이상의 문자 만 있으면 위험하며 다른 더 간단한 수정 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="003acc6ee30f8dfe6d64cbf566782eadf992c2a5" translate="yes" xml:space="preserve">
          <source>Make frequent use of comments to aid others in understanding your code. Use comments when:</source>
          <target state="translated">코드를 이해하는 데 도움이되도록 주석을 자주 사용하십시오. 다음과 같은 경우 의견을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48605054d2a26e6ebeb6461152bd41032c424c7e" translate="yes" xml:space="preserve">
          <source>Make separate pull requests for unrelated changes. Large pull requests with multiple unrelated changes may be closed without merging.</source>
          <target state="translated">관련없는 변경에 대해 별도의 풀 요청을 작성하십시오. 관련이없는 여러 변경 사항이있는 대규모 풀 요청은 병합하지 않고 닫힐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66052a8bb781ea4c3486f29d92fd4d76dd3b173b" translate="yes" xml:space="preserve">
          <source>Make sure your commit is formatted correctly.</source>
          <target state="translated">커밋 형식이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2294106611bb7be36ee5d5d272a03c7e228c69ec" translate="yes" xml:space="preserve">
          <source>Make the changes to the code and tests, following the &lt;a href=&quot;../code-conventions&quot;&gt;code conventions&lt;/a&gt; as you go. Once you have finished, commit the changes to your branch:</source>
          <target state="translated">&lt;a href=&quot;../code-conventions&quot;&gt;코드 규칙&lt;/a&gt; 에 따라 코드 및 테스트를 변경하십시오 . 완료하면 지점에 변경 사항을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6914f73852714eeda13d3e462e3d5fdef8f379" translate="yes" xml:space="preserve">
          <source>Make your changes</source>
          <target state="translated">변경하십시오</target>
        </trans-unit>
        <trans-unit id="bae6e15f8b41918cf92f172d566b4d738bc07054" translate="yes" xml:space="preserve">
          <source>Managing the execution environment for &lt;code&gt;Linter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Linter&lt;/code&gt; 의 실행 환경 관리</target>
        </trans-unit>
        <trans-unit id="d0373508bebe8dbaeab01855b2503dec101737d8" translate="yes" xml:space="preserve">
          <source>Many JavaScript libraries use the callback pattern to manage asynchronous operations. A program of any complexity will most likely need to manage several asynchronous operations at various levels of concurrency. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.</source>
          <target state="translated">많은 JavaScript 라이브러리는 콜백 패턴을 사용하여 비동기 작업을 관리합니다. 복잡한 프로그램은 여러 수준의 동시성에서 여러 비동기 작업을 관리해야 할 가능성이 높습니다. 빠지기 쉬운 함정은 콜백 중첩이며, 콜백이 중첩 될수록 코드를 읽기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="f31b27c63c34d0475df6058a328447b442261068" translate="yes" xml:space="preserve">
          <source>Many codebases require strings to be defined in a consistent manner.</source>
          <target state="translated">많은 코드베이스에서는 문자열을 일관된 방식으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f3335e45cb0fe011f2c670521d47c996929538a" translate="yes" xml:space="preserve">
          <source>Many developers consider code difficult to read if blocks are nested beyond a certain depth.</source>
          <target state="translated">많은 개발자들은 블록이 특정 깊이를 넘어 중첩되어 있으면 코드를 읽기 어렵다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ec6dcf6f91e26c974d5a7820b7cb35c058c70329" translate="yes" xml:space="preserve">
          <source>Many people enjoy a terser code style and don't mind comments bumping up against code. If you fall into that category this rule is not for you.</source>
          <target state="translated">많은 사람들이 더 간결한 코드 스타일을 즐기고 코드와 충돌하는 주석은 신경 쓰지 않습니다. 해당 범주에 속하면이 규칙이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30142d0203615d41e1641b80d943d73cc5ab1f7d" translate="yes" xml:space="preserve">
          <source>Many style guides require a particular style for comments that span multiple lines. For example, some style guides prefer the use of a single block comment for multiline comments, whereas other style guides prefer consecutive line comments.</source>
          <target state="translated">많은 스타일 안내서에는 여러 줄에 걸쳐있는 주석에 특정 스타일이 필요합니다. 예를 들어, 일부 스타일 안내서는 여러 줄 주석에 단일 블록 주석을 사용하는 것을 선호하는 반면 다른 스타일 안내서는 연속적인 줄 주석을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="1b81db8af58d6a82844c2a7f8a0fb423a248acad" translate="yes" xml:space="preserve">
          <source>Many style guides require empty lines before or after comments. The primary goal of these rules is to make the comments easier to read and improve readability of the code.</source>
          <target state="translated">많은 스타일 가이드에는 주석 앞뒤에 빈 줄이 필요합니다. 이 규칙의 기본 목표는 주석을보다 쉽게 ​​읽고 코드의 가독성을 향상시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65510d0ed7112a32a93fbfa0f852ca9727017a1d" translate="yes" xml:space="preserve">
          <source>Many style guides require or disallow newlines inside of function parentheses.</source>
          <target state="translated">많은 스타일 가이드는 함수 괄호 안에 개행을 요구하거나 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ed12807412804e8c761c63c5aafe1b92dde8f29" translate="yes" xml:space="preserve">
          <source>Many users found this behavior confusing, because if they made a typo in a filename, ESLint would appear to lint that file successfully while actually not linting anything.</source>
          <target state="translated">파일 이름에 오타가 있으면 ESLint가 실제로 파일을 보푸라기가 보지 않고 해당 파일을 보푸라기가 보이기 때문에 많은 사용자가이 동작을 혼동하는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="75eae4786a36e18e4c433733218135d176e49561" translate="yes" xml:space="preserve">
          <source>Many versioning systems (like git and subversion) can automatically ensure the correct ending. However to cover all contingencies, you can activate this rule.</source>
          <target state="translated">git 및 subversion과 같은 많은 버전 관리 시스템은 자동으로 올바른 종료를 보장 할 수 있습니다. 그러나 모든 긴급 상황을 처리하기 위해이 규칙을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43df01241be64a2f04e14f16ff54fa881de6350" translate="yes" xml:space="preserve">
          <source>Medium - Runs ESLint on jQuery</source>
          <target state="translated">보통-jQuery에서 ESLint를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="08da200116809cb87f9df70d5b14e0b115e836c5" translate="yes" xml:space="preserve">
          <source>MemberExpression</source>
          <target state="translated">MemberExpression</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="78327bd6b1c4878fa59ed96c8e3108c92ded9378" translate="yes" xml:space="preserve">
          <source>Migrating</source>
          <target state="translated">Migrating</target>
        </trans-unit>
        <trans-unit id="f19f19cf7d792e42d3a20e6c6066ddb485e88b86" translate="yes" xml:space="preserve">
          <source>Migrating from JSCS</source>
          <target state="translated">JSCS에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="f4cc004b36f93dc98ec6cb8cdd988862d89b0841" translate="yes" xml:space="preserve">
          <source>Migrating to v1.0.0</source>
          <target state="translated">v1.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="207ad564379ab84e0bd1d9f94528cf475fccedfe" translate="yes" xml:space="preserve">
          <source>Migrating to v2.0.0</source>
          <target state="translated">v2.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="6996ff0c977043ad7b164e529401b9633d67d887" translate="yes" xml:space="preserve">
          <source>Migrating to v3.0.0</source>
          <target state="translated">v3.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="b7e113904f56ea23562186c3f481bcb45dd5dd88" translate="yes" xml:space="preserve">
          <source>Migrating to v4.0.0</source>
          <target state="translated">v4.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="3a672cb43559c6811fe6c8d12f1ff180dd8516ab" translate="yes" xml:space="preserve">
          <source>Migrating to v5.0.0</source>
          <target state="translated">v5.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="519f16166bf3e002d2ccde6246ebacf01cc0a2bb" translate="yes" xml:space="preserve">
          <source>Migrating to v6.0.0</source>
          <target state="translated">v6.0.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="528b503f97c282e46488116b7644afc7003a7185" translate="yes" xml:space="preserve">
          <source>Mimosa: &lt;a href=&quot;https://www.npmjs.com/package/mimosa-eslint&quot;&gt;mimosa-eslint&lt;/a&gt;</source>
          <target state="translated">미모사 : &lt;a href=&quot;https://www.npmjs.com/package/mimosa-eslint&quot;&gt;미모사-에슬 린트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="99c887ad129c82e774781a1e88541c3f8352bfe0" translate="yes" xml:space="preserve">
          <source>Mocha.js: &lt;a href=&quot;https://www.npmjs.com/package/mocha-eslint&quot;&gt;mocha-eslint&lt;/a&gt;</source>
          <target state="translated">Mocha.js : &lt;a href=&quot;https://www.npmjs.com/package/mocha-eslint&quot;&gt;모카-에슬 린트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d7a3d6a2ddcd05134bdb5c8786e8cf510ba6fd1" translate="yes" xml:space="preserve">
          <source>Modern terminals like &lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm2&lt;/a&gt; or &lt;a href=&quot;http://guake-project.org/&quot;&gt;Guake&lt;/a&gt; expect a specific results format to automatically open filenames when they are clicked. Most terminals support this format for that purpose:</source>
          <target state="translated">&lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm2&lt;/a&gt; 또는 &lt;a href=&quot;http://guake-project.org/&quot;&gt;Guake&lt;/a&gt; 와 같은 최신 터미널은 파일 이름을 클릭하면 특정 결과 형식이 자동으로 파일 이름을 열 것으로 예상합니다. 대부분의 터미널은 이러한 목적으로이 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3846ef909df0be6113f867ef70064e247aabbd00" translate="yes" xml:space="preserve">
          <source>Monitor the status of the Travis CI build for your pull request. If it fails, please investigate why. We cannot merge pull requests that fail Travis for any reason.</source>
          <target state="translated">풀 요청에 대한 Travis CI 빌드 상태를 모니터링하십시오. 실패하면 이유를 조사하십시오. 어떤 이유로 든 Travis에 실패한 풀 요청을 병합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dc20fad549e82acb25baf9beda60f2ad6f4782b" translate="yes" xml:space="preserve">
          <source>More Control on Unit Testing</source>
          <target state="translated">단위 테스트에 대한 추가 제어</target>
        </trans-unit>
        <trans-unit id="8985cd96f1b823aecfe823a7ea114c4ab4c77f3f" translate="yes" xml:space="preserve">
          <source>More about Complexity in JavaScript</source>
          <target state="translated">JavaScript의 복잡성에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="cf861d594fba09fdccc03924cfd4dbfa37e34457" translate="yes" xml:space="preserve">
          <source>More clear:</source>
          <target state="translated">더 분명한:</target>
        </trans-unit>
        <trans-unit id="f9a9f89b9373f2be282736f322c949e24ac40fdf" translate="yes" xml:space="preserve">
          <source>More on ES6 arrow functions</source>
          <target state="translated">ES6 화살표 기능에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="b4a364a72443f90f75eadeb97e6069788cc6ba06" translate="yes" xml:space="preserve">
          <source>More report messages now have full location ranges</source>
          <target state="translated">더 많은 보고서 메시지가 이제 전체 위치 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6e669deb33d5dab4d7c948c39f7c25a8a1410c31" translate="yes" xml:space="preserve">
          <source>Most code conventions require either tabs or spaces be used for indentation. As such, it's usually an error if a single line of code is indented with both tabs and spaces.</source>
          <target state="translated">대부분의 코드 규칙에서는 들여 쓰기에 탭이나 공백을 사용해야합니다. 따라서 한 줄의 코드에 탭과 공백이 들여 쓰기되면 일반적으로 오류입니다.</target>
        </trans-unit>
        <trans-unit id="cda170b39a2aee0a27ca48dc565c4de1f9771f33" translate="yes" xml:space="preserve">
          <source>Most of the installers come with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; already installed, but if for some reason it doesn't work on your system, you can install it manually using the instructions on the site.</source>
          <target state="translated">대부분의 설치 프로그램에는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm이&lt;/a&gt; 이미 설치되어 제공되지만 어떤 이유로 시스템에서 작동하지 않는 경우 사이트의 지시 사항을 사용하여 수동으로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c042b4288a4f46ee5fbcb5a35c3c86ee3a0aa9" translate="yes" xml:space="preserve">
          <source>Most parts of ESLint have unit tests associated with them. Unit tests are written using &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha&lt;/a&gt; and are required when making contributions to ESLint. You'll find all of the unit tests in the &lt;code&gt;tests&lt;/code&gt; directory.</source>
          <target state="translated">ESLint의 대부분의 부분에는 이와 관련된 단위 테스트가 있습니다. 단위 테스트는 &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha를&lt;/a&gt; 사용하여 작성 되며 ESLint에 기여할 때 필요합니다. 당신은에서 단위 테스트의 모든 찾을 수 있습니다 &lt;code&gt;tests&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="cd847d892e51c9af96a07d5f1327caaaa74f5961" translate="yes" xml:space="preserve">
          <source>Mozilla Developer Network</source>
          <target state="translated">모질라 개발자 네트워크</target>
        </trans-unit>
        <trans-unit id="1717de09461ac8ad667382f9284cc154ed5fcf13" translate="yes" xml:space="preserve">
          <source>Multi-Line Comments</source>
          <target state="translated">여러 줄 주석</target>
        </trans-unit>
        <trans-unit id="50ffbaa596feb6c3fce6a0ab79b26de80c0fc9ad" translate="yes" xml:space="preserve">
          <source>Multi-line &lt;code&gt;eslint-disable-line&lt;/code&gt; directives are now reported as problems</source>
          <target state="translated">여러 줄 &lt;code&gt;eslint-disable-line&lt;/code&gt; 지시문은 이제 문제로보고됩니다</target>
        </trans-unit>
        <trans-unit id="ebd80a2db4954a31bc8bbc5ce38618ea3077ca04" translate="yes" xml:space="preserve">
          <source>Multi-line comments should be used to document code that requires more explanation. Each multi-line comment should have at least three lines:</source>
          <target state="translated">추가 설명이 필요한 코드를 문서화하려면 여러 줄 주석을 사용해야합니다. 각 여러 줄 주석에는 최소한 세 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b97cd68ceb9fb3aefd437fb8bac6c169f39dc7ef" translate="yes" xml:space="preserve">
          <source>Multiline Properties</source>
          <target state="translated">여러 줄 속성</target>
        </trans-unit>
        <trans-unit id="25384bc20fcb587fe7b1a27bd9646bb5677ec5ce" translate="yes" xml:space="preserve">
          <source>Multiple glob patterns can be provided within a single override block. A file must match at least one of the supplied patterns for the configuration to apply.</source>
          <target state="translated">단일 오버라이드 블록 내에 여러 개의 글로 패턴이 제공 될 수 있습니다. 구성을 적용하려면 파일이 제공된 패턴 중 하나 이상과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="75af35131e430e8f953818ff04be0c62dc2c9f54" translate="yes" xml:space="preserve">
          <source>Multiple object/property values can be disallowed, and you can specify an optional message:</source>
          <target state="translated">여러 객체 / 속성 값을 허용하지 않을 수 있으며 선택적 메시지를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6c9b518828a9995fa8b5eaa2bb15a280c804ca" translate="yes" xml:space="preserve">
          <source>Multiple properties with the same key in object literals can cause unexpected behavior in your application.</source>
          <target state="translated">객체 리터럴에서 동일한 키를 가진 여러 속성이 응용 프로그램에서 예기치 않은 동작을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ea30e5e8aba10118d84047ac8d06b2fb97d351e" translate="yes" xml:space="preserve">
          <source>Multiple spaces in a row that are not used for indentation are typically mistakes. For example:</source>
          <target state="translated">들여 쓰기에 사용되지 않은 행의 여러 공백은 일반적으로 실수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe7b50504e864db175792f08ac3122cab2513fc4" translate="yes" xml:space="preserve">
          <source>Multiple var statements in JavaScript, not superfluous</source>
          <target state="translated">불필요한 JavaScript가 아닌 여러 var 문</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="45b150c33703661a4e069fa3f97c482cd27685ef" translate="yes" xml:space="preserve">
          <source>Naming Convention</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1334b26c176a4a0cf6f3310906a31587677f7c" translate="yes" xml:space="preserve">
          <source>Naming things consistently in a project is an often underestimated aspect of code creation. When done correctly, it can save your team hours of unnecessary head scratching and misdirections. This rule allows you to precisely define and enforce the variables and function names on your team should use. No more limiting yourself to camelCase, snake_case, PascalCase or oHungarianNotation. Id-match has all your needs covered!</source>
          <target state="translated">프로젝트에서 일관되게 이름을 지정하는 것은 코드 생성 측면에서 과소 평가되는 경우가 많습니다. 올바르게 수행하면 팀에서 불필요한 머리 긁힘과 잘못된 방향의 시간을 절약 할 수 있습니다. 이 규칙을 사용하면 팀에서 사용해야하는 변수 및 함수 이름을 정확하게 정의하고 시행 할 수 있습니다. camelCase, snake_case, PascalCase 또는 oHungarianNotation으로 더 이상 제한하지 않습니다. Id-match는 모든 요구 사항을 충족합니다!</target>
        </trans-unit>
        <trans-unit id="f9c51726a21f2c071e2eaecdc1f58e85c2e063e9" translate="yes" xml:space="preserve">
          <source>Negated conditions are more difficult to understand. Code can be made more readable by inverting the condition instead.</source>
          <target state="translated">부정 조건은 이해하기가 더 어렵습니다. 대신 조건을 반전시켜 코드를 더 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4be93dc7bf3a2d0c376b542c46f2be17b015f34" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;overrides&lt;/code&gt; setting will be applied only if the glob patterns of both of the parent config and the child config matched. This is the same when the extended configs have &lt;code&gt;overrides&lt;/code&gt; setting.</source>
          <target state="translated">중첩 구성 &lt;code&gt;overrides&lt;/code&gt; 설정은 상위 구성과 하위 구성의 글로브 패턴이 일치하는 경우에만 적용됩니다. 확장 구성에 &lt;code&gt;overrides&lt;/code&gt; 설정 이있는 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="bba2cf8efb9ea175365987d5e97406eab0eb07ac" translate="yes" xml:space="preserve">
          <source>Nested long method chains like the below example are often broken onto separate lines for readability:</source>
          <target state="translated">아래 예제와 같이 중첩 된 긴 메소드 체인은 종종 가독성을 위해 별도의 줄로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="0f7143e0984fd302373a44b923b04ef166d1d6d4" translate="yes" xml:space="preserve">
          <source>Nesting ternary expressions can make code more difficult to understand.</source>
          <target state="translated">중첩 삼항 표현식은 코드를 이해하기 어렵게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e868c2d163da18b704134c91dfe580b7476d872b" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;eval()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="17303bc383f07ad6ca5f1e713ad09a8e4c5aceb1" translate="yes" xml:space="preserve">
          <source>Never use the &lt;code&gt;with&lt;/code&gt; statement. This statement isn't available in strict mode and likely won't be available in future ECMAScript editions.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문을 사용하지 마십시오 . 이 문은 엄격 모드에서 사용할 수 없으며 향후 ECMAScript 버전에서는 제공되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccd1fb39539ac8b89e4d82497beb7205dfc545dc" translate="yes" xml:space="preserve">
          <source>Never use the primitive wrapper types, such as &lt;code&gt;String&lt;/code&gt;, to create new objects.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 과 같은 기본 래퍼 유형 을 사용하여 새 객체를 만들지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b8fd74418c174fa1a6547580b4f9d50c65e103b2" translate="yes" xml:space="preserve">
          <source>Never use the special value &lt;code&gt;undefined&lt;/code&gt;. To see if a variable has been defined, use the &lt;code&gt;typeof&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 특수 값을 사용하지 마십시오 . 변수가 정의되어 있는지 확인하려면 &lt;code&gt;typeof&lt;/code&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e29869dc1c4b4ed49384ced7f3787145a78ff2a6" translate="yes" xml:space="preserve">
          <source>Never.</source>
          <target state="translated">Never.</target>
        </trans-unit>
        <trans-unit id="c7c2bffc4ed85d835ff90e67b6700b9717359c25" translate="yes" xml:space="preserve">
          <source>New Rules</source>
          <target state="translated">새로운 규칙</target>
        </trans-unit>
        <trans-unit id="b90e91c1c9b0532e10c8d94b3242c03a7c521d78" translate="yes" xml:space="preserve">
          <source>New Rules in &lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;eslint:recommended&quot;&lt;/code&gt; 의 새로운 규칙</target>
        </trans-unit>
        <trans-unit id="098b5a1915693dd6ff64ee239f651997dde49e83" translate="yes" xml:space="preserve">
          <source>New rules have been added to &lt;code&gt;eslint:recommended&lt;/code&gt;</source>
          <target state="translated">새로운 규칙이 &lt;code&gt;eslint:recommended&lt;/code&gt; 에 추가되었습니다 : 권장</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76dd91a3359617271ed7ffd8b7df9bbc0c954e1" translate="yes" xml:space="preserve">
          <source>Next, push your changes to your clone:</source>
          <target state="translated">다음으로 변경 사항을 복제본으로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="432bb6269b57474b24c9803b75937c68ef4b90c5" translate="yes" xml:space="preserve">
          <source>No Longer Exporting cli</source>
          <target state="translated">더 이상 수출 클리닉</target>
        </trans-unit>
        <trans-unit id="6fe37c89ea3654de81c59847379a8780e76d887e" translate="yes" xml:space="preserve">
          <source>No one will blame you for backing out of an issue if you are unable to complete it. We just want to keep the process moving along as efficiently as possible.</source>
          <target state="translated">문제를 완수 할 수없는 사람은 아무도 문제를 해결하지 않았다고 비난하지 않습니다. 우리는 프로세스를 가능한 한 효율적으로 진행하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="015936150c4240bf1685a0beae94734e5c0fd2e7" translate="yes" xml:space="preserve">
          <source>No rules are enabled by default. The &lt;code&gt;&quot;extends&quot;: &quot;eslint:recommended&quot;&lt;/code&gt; property in a &lt;a href=&quot;../user-guide/configuring#extending-configuration-files&quot;&gt;configuration file&lt;/a&gt; enables rules that report common problems, which have a check mark  below.</source>
          <target state="translated">기본적으로 규칙이 활성화되어 있지 않습니다. &lt;a href=&quot;../user-guide/configuring#extending-configuration-files&quot;&gt;구성 파일&lt;/a&gt; 의 &lt;code&gt;&quot;extends&quot;: &quot;eslint:recommended&quot;&lt;/code&gt; 속성을 사용하면 아래에 확인 표시가있는 일반적인 문제를보고하는 규칙이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="43b56bdc9a2f449dd95a29cc4403aabc8d987dfc" translate="yes" xml:space="preserve">
          <source>Node.JS</source>
          <target state="translated">Node.JS</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="7c492f9c09c9ff17a16de6ed9c821ef76255da51" translate="yes" xml:space="preserve">
          <source>Node.js 10 (10.13.0 and above)</source>
          <target state="translated">Node.js 10 (10.13.0 이상)</target>
        </trans-unit>
        <trans-unit id="90d89d5227cc3415b0eef08538029343dc658ba6" translate="yes" xml:space="preserve">
          <source>Node.js 4 is no longer supported</source>
          <target state="translated">Node.js 4는 더 이상 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="5a40f605ee0fd0ee1b8acb34f313bb0a19612661" translate="yes" xml:space="preserve">
          <source>Node.js 6 (6.14.0 and above)</source>
          <target state="translated">Node.js 6 (6.14.0 이상)</target>
        </trans-unit>
        <trans-unit id="e90914a7b373d6529d8a016e66f5135b658d37af" translate="yes" xml:space="preserve">
          <source>Node.js 6 is no longer supported</source>
          <target state="translated">Node.js 6은 더 이상 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="2ceb71f6fc886f72cd41914593a377d2331bca2a" translate="yes" xml:space="preserve">
          <source>Node.js 8 (8.10.0 and above)</source>
          <target state="translated">Node.js 8 (8.10.0 이상)</target>
        </trans-unit>
        <trans-unit id="8b8214b8e226c143da7ac208d7ccfff6ed28e492" translate="yes" xml:space="preserve">
          <source>Node.js API</source>
          <target state="translated">Node.js API</target>
        </trans-unit>
        <trans-unit id="04fbd93b23e439f6b5bdb44a7ebe23e14c1d9127" translate="yes" xml:space="preserve">
          <source>Node.js and CommonJS</source>
          <target state="translated">Node.js 및 CommonJS</target>
        </trans-unit>
        <trans-unit id="e3f2bdd6d137ca1e9a98351c023627cbde0cec9c" translate="yes" xml:space="preserve">
          <source>Nodejitsu: What are the error conventions?</source>
          <target state="translated">Nodejitsu : 오류 규칙은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="40b5e952bb48a49486eed3f9c7473ff77e065932" translate="yes" xml:space="preserve">
          <source>Normally, if ESLint runs and finds no errors (only warnings), it will exit with a success exit status. However, if &lt;code&gt;--max-warnings&lt;/code&gt; is specified and the total warning count is greater than the specified threshold, ESLint will exit with an error status. Specifying a threshold of &lt;code&gt;-1&lt;/code&gt; or omitting this option will prevent this behavior.</source>
          <target state="translated">일반적으로 ESLint가 실행되고 오류가없는 경우 (경고 만) 성공 종료 상태로 종료됩니다. 그러나 &lt;code&gt;--max-warnings&lt;/code&gt; 가 지정되고 총 경고 수가 지정된 임계 값보다 큰 경우 ESLint는 오류 상태로 종료됩니다. 임계 값을 &lt;code&gt;-1&lt;/code&gt; 로 지정 하거나이 옵션을 생략하면이 동작이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="b25fdf6d849a83c39bb3f295e2b8c788a05b6b0d" translate="yes" xml:space="preserve">
          <source>Not be library-specific.</source>
          <target state="translated">라이브러리 별이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="35e36fc0294abf8492a00a6146dff86e708f4159" translate="yes" xml:space="preserve">
          <source>Not be the opposite of an existing rule.</source>
          <target state="translated">기존 규칙과 반대되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fad574db66b94391e41eddfcd296f39d4f94404a" translate="yes" xml:space="preserve">
          <source>Not overlap with an existing rule.</source>
          <target state="translated">기존 규칙과 겹치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9029138548f2a9fdd23c03ef55efcf761ab4cfd0" translate="yes" xml:space="preserve">
          <source>Not specifying this rule is equivalent of assigning it to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">이 규칙을 지정하지 않으면 &lt;code&gt;none&lt;/code&gt; 으로 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4861a0142b65983913e9d41b8290eade0ea43067" translate="yes" xml:space="preserve">
          <source>Notations</source>
          <target state="translated">Notations</target>
        </trans-unit>
        <trans-unit id="9b7b918044536aa7a7deb04ec10c32265cca907c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;always&quot;&lt;/code&gt; has a special case where &lt;code&gt;{}&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; are not considered problems.</source>
          <target state="translated">하는 것으로 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 특별한 경우가 &lt;code&gt;{}&lt;/code&gt; 와 &lt;code&gt;[]&lt;/code&gt; 고려하지 않는 문제.</target>
        </trans-unit>
        <trans-unit id="b8542e39cfc8468ccf1b75f31ccc5f6beca12d4a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/* exported */&lt;/code&gt; has no effect for any of the following:</source>
          <target state="translated">참고 &lt;code&gt;/* exported */&lt;/code&gt; 다음 중 하나에 영향을주지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="aca84c496113223feba48b89954e9ed6a64416c1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;defaultAssignment: false&lt;/code&gt; still allows expressions of the form &lt;code&gt;x ? expr : x&lt;/code&gt; (where the identifier is on the right hand side of the ternary).</source>
          <target state="translated">참고 것을 &lt;code&gt;defaultAssignment: false&lt;/code&gt; 여전히 양식의 표현 할 수 &lt;code&gt;x ? expr : x&lt;/code&gt; (여기서 식별자는 삼항의 오른쪽에 있습니다).</target>
        </trans-unit>
        <trans-unit id="9b7f17dafb1fc2ac631526c6b46f9a1d8ffa8e3b" translate="yes" xml:space="preserve">
          <source>Note that at least one of &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;loc&lt;/code&gt; is required.</source>
          <target state="translated">중 적어도 하나 있습니다 &lt;code&gt;node&lt;/code&gt; 또는 &lt;code&gt;loc&lt;/code&gt; 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f74885501a3e7134a66bf3df8110995866d5416" translate="yes" xml:space="preserve">
          <source>Note that configuration comments and comments which start with URLs are never reported.</source>
          <target state="translated">URL로 시작하는 구성 설명 및 설명은보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f78d136a146a36971c9e8628e71d64cc1bd5ef" translate="yes" xml:space="preserve">
          <source>Note that even with these compatibilities, there are no guarantees that an external parser will work correctly with ESLint and ESLint will not fix bugs related to incompatibilities with other parsers.</source>
          <target state="translated">이러한 호환성에도 불구하고 외부 파서는 ESLint에서 올바르게 작동하고 ESLint는 다른 파서와의 비 호환성 관련 버그를 수정하지 않을 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfc76a3bf8f752b8b71cfd21bce6317dc0eb6d26" translate="yes" xml:space="preserve">
          <source>Note that every &lt;code&gt;getter&lt;/code&gt; is expected to return a value.</source>
          <target state="translated">모든 &lt;code&gt;getter&lt;/code&gt; 는 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="973ad8dc3ee2a30a3d4c6e8e9554560da150053f" translate="yes" xml:space="preserve">
          <source>Note that leading and trailing whitespace is optional in message parameters.</source>
          <target state="translated">메시지 매개 변수에서 선행 및 후행 공백은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="8c038f50e970ff4a6c263baef88671b9b6797c2c" translate="yes" xml:space="preserve">
          <source>Note that one or more string expression statements (with or without semi-colons) will only be considered as unused if they are not in the beginning of a script, module, or function (alone and uninterrupted by other statements). Otherwise, they will be treated as part of a &quot;directive prologue&quot;, a section potentially usable by JavaScript engines. This includes &quot;strict mode&quot; directives.</source>
          <target state="translated">하나 이상의 문자열 표현식 명령문 (세미콜론이 있거나없는)은 스크립트, 모듈 또는 함수의 시작 부분에 있지 않은 경우 (사용하지 않고 다른 명령문에 의해 중단되지 않은 경우) 만 사용되지 않은 것으로 간주됩니다. 그렇지 않으면 JavaScript 엔진에서 사용할 수있는 섹션 인 &quot;지시적 프롤로그&quot;의 일부로 취급됩니다. 여기에는 &quot;엄격 모드&quot;지시문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="14eabcc20ca1ae6d595dd0146dacc275446c2785" translate="yes" xml:space="preserve">
          <source>Note that operator &lt;code&gt;+&lt;/code&gt; in &lt;code&gt;allow&lt;/code&gt; list would allow &lt;code&gt;+foo&lt;/code&gt; (number coercion) as well as &lt;code&gt;&quot;&quot; + foo&lt;/code&gt; (string coercion).</source>
          <target state="translated">&lt;code&gt;allow&lt;/code&gt; 목록의 연산자 &lt;code&gt;+&lt;/code&gt; 는 &lt;code&gt;&quot;&quot; + foo&lt;/code&gt; (문자열 강제) 뿐만 아니라 &lt;code&gt;+foo&lt;/code&gt; (숫자 강제)도 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a2ea103023fbbea878ee580810efa43b1ce5e514" translate="yes" xml:space="preserve">
          <source>Note that simply checking &lt;code&gt;foo.hasOwnProperty(key)&lt;/code&gt; is likely to cause an error in some cases; see &lt;a href=&quot;no-prototype-builtins&quot;&gt;no-prototype-builtins&lt;/a&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;foo.hasOwnProperty(key)&lt;/code&gt; 를 확인 하면 오류가 발생할 수 있습니다. &lt;a href=&quot;no-prototype-builtins&quot;&gt;프로토 타입이없는 내장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da8f31abf81fd1530a65a1c89cbaf28a84d87fe4" translate="yes" xml:space="preserve">
          <source>Note that the following words are always ignored by this rule: &lt;code&gt;[&quot;jscs&quot;, &quot;jshint&quot;, &quot;eslint&quot;, &quot;istanbul&quot;, &quot;global&quot;, &quot;globals&quot;, &quot;exported&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[&quot;jscs&quot;, &quot;jshint&quot;, &quot;eslint&quot;, &quot;istanbul&quot;, &quot;global&quot;, &quot;globals&quot;, &quot;exported&quot;]&lt;/code&gt; 규칙은 항상 다음 단어를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="92871ffd4aceb2bd3a9e8edec06e56e2e05d821f" translate="yes" xml:space="preserve">
          <source>Note that the last &lt;code&gt;case&lt;/code&gt; statement in these examples does not cause a warning because there is nothing to fall through into.</source>
          <target state="translated">이 예제에서 마지막 &lt;code&gt;case&lt;/code&gt; 문은 아무런 문제가 없으므로 경고를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fe60f0778016b7de275c5c3433b4ff7fcd68bdb" translate="yes" xml:space="preserve">
          <source>Note that the patterns considered problems are &lt;strong&gt;not&lt;/strong&gt; flagged by the &lt;a href=&quot;semi&quot;&gt;semi&lt;/a&gt; rule.</source>
          <target state="translated">문제로 간주되는 패턴 에는 &lt;a href=&quot;semi&quot;&gt;세미&lt;/a&gt; 규칙이 표시 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="649f078207c83d3aa9f8117c4caa24a177fa6e14" translate="yes" xml:space="preserve">
          <source>Note that this also affects the &lt;a href=&quot;../developer-guide/nodejs-api#cliengineexecuteonfiles&quot;&gt;&lt;code&gt;CLIEngine.executeOnFiles()&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">이는 &lt;a href=&quot;../developer-guide/nodejs-api#cliengineexecuteonfiles&quot;&gt; &lt;code&gt;CLIEngine.executeOnFiles()&lt;/code&gt; &lt;/a&gt; API 에도 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="4e1fc0ebbd12c442e0e5e74e0e029ef6f09efa61" translate="yes" xml:space="preserve">
          <source>Note that this also enables parsing for other features from ES2018, such as &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;async iteration&lt;/a&gt;. When using ESLint v5 with the default parser, it is no longer possible to toggle syntax support for object rest/spread independently of other features.</source>
          <target state="translated">이를 통해 &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;비동기 반복&lt;/a&gt; 과 같은 ES2018의 다른 기능을 구문 분석 할 수도 있습니다 . 기본 파서와 함께 ESLint v5를 사용하는 경우 더 이상 다른 기능과 독립적으로 객체 휴식 / 확산에 대한 구문 지원을 토글 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82d62f793b20020481672da21ac064b568a683e5" translate="yes" xml:space="preserve">
          <source>Note that this rule does not disallow assignments to read-only global variables. See &lt;a href=&quot;no-global-assign&quot;&gt;no-global-assign&lt;/a&gt; if you also want to disallow those assignments.</source>
          <target state="translated">이 규칙은 읽기 전용 전역 변수에 대한 할당을 허용하지 않습니다. 이러한 할당을 허용하지 않으려면 &lt;a href=&quot;no-global-assign&quot;&gt;no-global-assign을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a9767c41439a621031ba6529109fef573ecf23" translate="yes" xml:space="preserve">
          <source>Note that this rule does not enforce the usage of single-line statements in general. If you would like to disallow single-line statements, use the &lt;a href=&quot;curly&quot;&gt;&lt;code&gt;curly&lt;/code&gt;&lt;/a&gt; rule instead.</source>
          <target state="translated">이 규칙은 일반적으로 한 줄 문장의 사용을 강요하지 않습니다. 한 줄로 된 문장을 허용하지 않으려면 대신 &lt;a href=&quot;curly&quot;&gt; &lt;code&gt;curly&lt;/code&gt; &lt;/a&gt; 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d826b4d17235a608a3c9cd20c92fa11e3d5d2e94" translate="yes" xml:space="preserve">
          <source>Note that this rule only enforces spacing within parentheses; it does not check spacing within curly or square brackets, but will enforce or disallow spacing of those brackets if and only if they are adjacent to an opening or closing parenthesis.</source>
          <target state="translated">이 규칙은 괄호 안에 만 간격을 적용합니다. 중괄호 또는 대괄호 안의 간격을 확인하지는 않지만 괄호가 시작 또는 닫는 괄호에 인접한 경우에만 해당 브래킷의 간격을 적용하거나 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="347d91e7a5b838e6bcb85cf66bf52f2d967e3ca1" translate="yes" xml:space="preserve">
          <source>Note that when using the &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;commonjs&lt;/code&gt; environments (or &lt;code&gt;ecmaFeatures.globalReturn&lt;/code&gt;, if using the default parser), the top scope of a program is not actually the global scope, but rather a &quot;module&quot; scope. When this is the case, declaring a variable named after a builtin global is not a redeclaration, but rather a shadowing of the global variable. In that case, the &lt;a href=&quot;no-shadow&quot;&gt;&lt;code&gt;no-shadow&lt;/code&gt;&lt;/a&gt; rule with the &lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; option should be used.</source>
          <target state="translated">사용할 때주의 &lt;code&gt;node&lt;/code&gt; 또는 &lt;code&gt;commonjs&lt;/code&gt; (또는 환경을 &lt;code&gt;ecmaFeatures.globalReturn&lt;/code&gt; 기본 파서를 사용하는 경우), 프로그램의 정상 범위는 실제로 전역, 오히려 &quot;모듈&quot;의 범위가 아닙니다. 이 경우 내장 전역의 이름을 딴 변수를 선언하는 것은 재 선언이 아니라 전역 변수의 그림자입니다. 이 경우 &lt;code&gt;&quot;builtinGlobals&quot;&lt;/code&gt; 옵션이있는 &lt;a href=&quot;no-shadow&quot;&gt; &lt;code&gt;no-shadow&lt;/code&gt; &lt;/a&gt; 규칙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1125aced35499b31bb41c702c9945c7bd12e9b07" translate="yes" xml:space="preserve">
          <source>Note that you can leave off the &lt;code&gt;.js&lt;/code&gt; from the filename. In this way, you can add as many additional configs to your package as you'd like.</source>
          <target state="translated">파일 이름 에서 &lt;code&gt;.js&lt;/code&gt; 를 생략 할 수 있습니다 . 이런 식으로 패키지에 원하는만큼 구성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76aa0f033fd5d1d41d32bcaf6fd648d73e33b956" translate="yes" xml:space="preserve">
          <source>Note that, as with core rules and plugin rules, you still need to enable the rules in configuration or via the &lt;code&gt;--rule&lt;/code&gt; CLI option in order to actually run those rules during linting. Specifying a rules directory with &lt;code&gt;--rulesdir&lt;/code&gt; does not automatically enable the rules within that directory.</source>
          <target state="translated">핵심 규칙 및 플러그인 규칙과 마찬가지로 &lt;code&gt;--rule&lt;/code&gt; 중에 규칙을 실제로 실행하려면 구성에서 또는 --rule CLI 옵션을 통해 규칙을 활성화해야합니다 . &lt;code&gt;--rulesdir&lt;/code&gt; 을 사용 하여 rules 디렉토리를 지정해도 해당 디렉토리 내의 규칙이 자동으로 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9b6296c44a9bc30cef358e801b33c46b39d24f5" translate="yes" xml:space="preserve">
          <source>Note the use of a semicolon as the final part of this statement. There should be a space before and after the &lt;code&gt;while&lt;/code&gt; keyword.</source>
          <target state="translated">이 명령문의 마지막 부분으로 세미콜론을 사용하십시오. &lt;code&gt;while&lt;/code&gt; 키워드 앞뒤에 공백이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c88398cdded8def6acc02b6ff7133a562ee36" translate="yes" xml:space="preserve">
          <source>Note when using a custom parser, the &lt;code&gt;parserOptions&lt;/code&gt; configuration property is still required for ESLint to work properly with features not in ECMAScript 5 by default. Parsers are all passed &lt;code&gt;parserOptions&lt;/code&gt; and may or may not use them to determine which features to enable.</source>
          <target state="translated">사용자 정의 파서를 사용할 때 ESLint가 기본적으로 ECMAScript 5에없는 기능과 올바르게 작동하려면 &lt;code&gt;parserOptions&lt;/code&gt; 구성 등록 정보가 여전히 필요합니다. 파서는 모두 &lt;code&gt;parserOptions&lt;/code&gt; 에 전달 되며 이를 사용하여 사용할 기능을 결정하거나 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c39afa03191645dbc4d28c7d2359af7e538e42" translate="yes" xml:space="preserve">
          <source>Note: Currently &lt;code&gt;CLIEngine&lt;/code&gt; does not validate options passed to it, but may start doing so in the future.</source>
          <target state="translated">참고 : 현재 &lt;code&gt;CLIEngine&lt;/code&gt; 은 전달 된 옵션의 유효성을 검사하지 않지만 나중에 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984b1133cbe92feba750f10ab3475f0c23c1b51a" translate="yes" xml:space="preserve">
          <source>Note: For a rule preventing deletion of variables, see &lt;a href=&quot;no-delete-var&quot;&gt;no-delete-var instead&lt;/a&gt;</source>
          <target state="translated">참고 : 변수 삭제를 방지하는 규칙은 &lt;a href=&quot;no-delete-var&quot;&gt;대신 no-delete-var를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d25aa0b7adae8f5ed33576b5806bc8d4bbf49549" translate="yes" xml:space="preserve">
          <source>Note: Formatting for Terminals</source>
          <target state="translated">참고 : 터미널 포맷</target>
        </trans-unit>
        <trans-unit id="094162498ea0d1d13c56050f15e2107cd8551770" translate="yes" xml:space="preserve">
          <source>Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolumns. All of those things can be corrected by multipass autofix when the user triggers it.</source>
          <target state="translated">참고 : 제안 사항은 멀티 패스 수정을 트리거하지 않고 독립형 변경 사항으로 적용됩니다. 각 제안은 코드의 단일 변경에 중점을 두어야하며 사용자 정의 스타일을 따르지 않아야합니다. 예를 들어, 제안이 코드베이스에 새 명령문을 추가하는 경우 올바른 들여 쓰기를 일치 시키거나 세미 컬럼 유무에 대한 사용자 기본 설정을 확인하려고 시도해서는 안됩니다. 사용자가 트리거 할 때 멀티 패스 자동 수정으로 이러한 모든 사항을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a96d12cefbf530755a3476759379971f31c30b2" translate="yes" xml:space="preserve">
          <source>Note: This API is deprecated as of 4.0.0.</source>
          <target state="translated">참고 :이 API는 4.0.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24de5bcbd5c3607fa22b1b0d298fae9fdf45a3ea" translate="yes" xml:space="preserve">
          <source>Now here are ES6 equivalents:</source>
          <target state="translated">다음은 ES6에 해당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87fe1cc3d574f9be3c85d698f90d866c75ac44a8" translate="yes" xml:space="preserve">
          <source>Now inside your &lt;code&gt;/lib/ci/backend.js&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;/lib/ci/backend.js&lt;/code&gt; 내부</target>
        </trans-unit>
        <trans-unit id="35e2195ff597916ba2ef234cdbb68bdf57b69342" translate="yes" xml:space="preserve">
          <source>Now inside your package you have &lt;code&gt;/lib/defaults.js&lt;/code&gt;, which contains:</source>
          <target state="translated">이제 패키지 &lt;code&gt;/lib/defaults.js&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4137e109ac15d620738ab61f944d78dc01861a63" translate="yes" xml:space="preserve">
          <source>Now it is very clear that three spaces are expected to be matched.</source>
          <target state="translated">이제 세 개의 공백이 일치 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="5bca21c074e0d721a5fd90d89b255318c8ce0216" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;eslint&lt;/code&gt;, it will be running your local copy and showing your changes.</source>
          <target state="translated">이제 &lt;code&gt;eslint&lt;/code&gt; 를 실행하면 로컬 사본이 실행되고 변경 사항이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57c585f4798ef4591adf413472a8e4f97e198bfd" translate="yes" xml:space="preserve">
          <source>Now you're ready to send the pull request. Go to your ESLint fork and then follow the &lt;a href=&quot;https://help.github.com/articles/creating-a-pull-request&quot;&gt;GitHub documentation&lt;/a&gt; on how to send a pull request.</source>
          <target state="translated">이제 풀 요청을 보낼 준비가되었습니다. ESLint 포크로 이동하여 풀 요청을 보내는 방법에 대한 &lt;a href=&quot;https://help.github.com/articles/creating-a-pull-request&quot;&gt;GitHub 문서&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="20482a66574043c6f07e88950af557ca9ba4cb34" translate="yes" xml:space="preserve">
          <source>Now, consider the following group configuration: &lt;code&gt;{&quot;groups&quot;: [[&quot;&amp;amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;], [&quot;&amp;amp;&amp;amp;&quot;, &quot;||&quot;]]}&lt;/code&gt;. There are 2 groups specified in this configuration: bitwise operators and logical operators. This rule checks if the operators belong to the same group only. In this case, this rule checks if bitwise operators and logical operators are mixed, but ignores all other operators.</source>
          <target state="translated">이제 다음 그룹 구성을 고려하십시오 : &lt;code&gt;{&quot;groups&quot;: [[&quot;&amp;amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;], [&quot;&amp;amp;&amp;amp;&quot;, &quot;||&quot;]]}&lt;/code&gt; . 이 구성에는 비트 연산자와 논리 연산자의 두 그룹이 지정되어 있습니다. 이 규칙은 연산자가 동일한 그룹에만 속하는지 확인합니다. 이 경우이 규칙은 비트 연산자와 논리 연산자가 혼합되어 있는지 확인하지만 다른 모든 연산자는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b4992572eba9e898e29cdb06f84784a8f96e8a75" translate="yes" xml:space="preserve">
          <source>Now, the remote &lt;code&gt;upstream&lt;/code&gt; points to the upstream source.</source>
          <target state="translated">이제 원격 &lt;code&gt;upstream&lt;/code&gt; 이 업스트림 소스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8dad4f5a3bcf9c3bffdb2bf8a3903f51188938d6" translate="yes" xml:space="preserve">
          <source>Now, those variables and references have correct values in these properties.</source>
          <target state="translated">이제 이러한 변수와 참조는 이러한 속성에서 올바른 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b69cceaa39cc9827d135c31a0a311643f64c4242" translate="yes" xml:space="preserve">
          <source>Numbers should be written as decimal integers, e-notation integers, hexadecimal integers or floating-point decimals with at least one digit before and one digit after the decimal point. Never use octal literals.</source>
          <target state="translated">숫자는 소수점 앞뒤 한 자리 이상, 소수점 이하 한 자리 이상을 갖는 십진 정수, 전자 표기법 정수, 16 진 정수 또는 부동 소수점 십진수로 작성해야합니다. 8 진 리터럴을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="afb8e044bcdc5720b645f5bad798ce2422b144b7" translate="yes" xml:space="preserve">
          <source>Object Getters</source>
          <target state="translated">객체 게터</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">객체 리터럴</target>
        </trans-unit>
        <trans-unit id="8c039bd2c30b64d60bbf9c614cffee3af09daea6" translate="yes" xml:space="preserve">
          <source>Object Rest/Spread Properties for ECMAScript</source>
          <target state="translated">ECMAScript의 오브젝트 레스트 / 스프레드 속성</target>
        </trans-unit>
        <trans-unit id="5b78ac9af4a56a7e0611f75dde6336ad4efc93cf" translate="yes" xml:space="preserve">
          <source>Object Setters</source>
          <target state="translated">객체 세터</target>
        </trans-unit>
        <trans-unit id="4671b195767e872ed26e93314009bf9a02b4925b" translate="yes" xml:space="preserve">
          <source>Object initializer - MDN</source>
          <target state="translated">객체 이니셜 라이저-MDN</target>
        </trans-unit>
        <trans-unit id="ffa631f7811b9675c18511c35ebd3c5888d3c693" translate="yes" xml:space="preserve">
          <source>Object literal property names can be defined in two ways: using literals or using strings. For example, these two objects are equivalent:</source>
          <target state="translated">객체 리터럴 속성 이름은 리터럴 사용 또는 문자열 사용의 두 가지 방법으로 정의 할 수 있습니다. 예를 들어이 두 개체는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="01a531c72bfc336c6dd4074ad4379fdce5371193" translate="yes" xml:space="preserve">
          <source>Object literals should have the following format:</source>
          <target state="translated">객체 리터럴은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="593c1a9b247ae9203d0656b7697e245c92cca212" translate="yes" xml:space="preserve">
          <source>Object literals.</source>
          <target state="translated">객체 리터럴.</target>
        </trans-unit>
        <trans-unit id="d0906ffdbaac63ebcdad566357ec1fa32b660ce9" translate="yes" xml:space="preserve">
          <source>Object option (when &lt;code&gt;&quot;always&quot;&lt;/code&gt;):</source>
          <target state="translated">객체 옵션 ( &lt;code&gt;&quot;always&quot;&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="ac9c86f6b8a7b6cb8ef56a7d1efe7d9ef0bb7e18" translate="yes" xml:space="preserve">
          <source>Object option (when &lt;code&gt;&quot;never&quot;&lt;/code&gt;):</source>
          <target state="translated">객체 옵션 ( &lt;code&gt;&quot;never&quot;&lt;/code&gt; 인 경우 ) :</target>
        </trans-unit>
        <trans-unit id="f8eb5265b464019bacbbf51d8d1ff30364921024" translate="yes" xml:space="preserve">
          <source>Object option:</source>
          <target state="translated">객체 옵션 :</target>
        </trans-unit>
        <trans-unit id="149ecb5e6d435ef3f0c0b95567c172606e31d857" translate="yes" xml:space="preserve">
          <source>Object properties follow the same naming conventions as variables. Object methods follow the same naming conventions as functions. If a property or method is meant to be private, then it should be prefixed with an underscore character.</source>
          <target state="translated">객체 속성은 변수와 동일한 명명 규칙을 따릅니다. 객체 메소드는 함수와 동일한 명명 규칙을 따릅니다. 속성 또는 메서드가 개인용 인 경우 밑줄 문자가 접두사로 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="07cc26cad16fa208535abacfadeea81f2c8f08d7" translate="yes" xml:space="preserve">
          <source>Object properties for variants of the &lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;&quot;as-needed&quot;&lt;/code&gt; 옵션의 변형에 대한 객체 속성 :</target>
        </trans-unit>
        <trans-unit id="c4dfaa986b5d14c627c83c972171a7941c5b7be6" translate="yes" xml:space="preserve">
          <source>Object rest/spread is now an official part of the JavaScript language, so our support for it is no longer experimental. In both ESLint v4 and ESLint v5, object rest/spread can now be enabled with the &lt;code&gt;&quot;ecmaVersion&quot;: 2018&lt;/code&gt; option:</source>
          <target state="translated">객체 휴식 / 확산은 이제 JavaScript 언어의 공식적인 부분이므로 더 이상 실험적으로 지원되지 않습니다. ESLint v4 및 ESLint v5에서 &lt;code&gt;&quot;ecmaVersion&quot;: 2018&lt;/code&gt; 옵션을 사용하여 오브젝트 레스트 / 스프레드를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11a92c8196539fdab3857b1551dea0f331c775a8" translate="yes" xml:space="preserve">
          <source>Object.getPrototypeOf</source>
          <target state="translated">Object.getPrototypeOf</target>
        </trans-unit>
        <trans-unit id="fa8ae9f7df131e038e636e584d189c8515f58a8c" translate="yes" xml:space="preserve">
          <source>ObjectExpression</source>
          <target state="translated">ObjectExpression</target>
        </trans-unit>
        <trans-unit id="793061db282a75e8ed5dcc678e2f977602f536e5" translate="yes" xml:space="preserve">
          <source>ObjectExpression and ObjectPattern</source>
          <target state="translated">ObjectExpression 및 ObjectPattern</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="79c19740aba487d5c36feef2d71ebeab770748e7" translate="yes" xml:space="preserve">
          <source>Occasionally, a core ESLint rule needs to be changed. This is not necessarily a bug, but rather, an enhancement that makes a rule more configurable. In those situations, we will consider making changes to rules.</source>
          <target state="translated">때로는 핵심 ESLint 규칙을 변경해야합니다. 이것은 반드시 버그 일 필요는 없으며 규칙을보다 구성 가능하게 만드는 개선 사항입니다. 이러한 상황에서는 규칙을 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="503c1e8b34ff2b306e45ab8d949857759bce53e9" translate="yes" xml:space="preserve">
          <source>Octal literals are numerals that begin with a leading zero, such as:</source>
          <target state="translated">8 진 리터럴은 다음과 같이 선행 0으로 시작하는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5270a8f48af0485d13759bcff94f40182ae7fbe6" translate="yes" xml:space="preserve">
          <source>Of course, you could also have a style guide that disallows spaces around keywords.</source>
          <target state="translated">물론 키워드 주위에 공백을 허용하지 않는 스타일 가이드가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1125ca598816239bf6b761a79b64ee161ec9a9d7" translate="yes" xml:space="preserve">
          <source>Of course, you could also have a style guide that disallows spaces before keywords.</source>
          <target state="translated">물론 키워드 앞에 공백을 허용하지 않는 스타일 가이드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c141537fefa1f7236bb95371a0c1823cf3d5a82a" translate="yes" xml:space="preserve">
          <source>Of particular note is that like &lt;code&gt;.gitignore&lt;/code&gt; files, all paths used as patterns for both &lt;code&gt;.eslintignore&lt;/code&gt; and &lt;code&gt;--ignore-pattern&lt;/code&gt; must use forward slashes as their path separators.</source>
          <target state="translated">특히 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 마찬가지로 &lt;code&gt;.eslintignore&lt;/code&gt; 및 &lt;code&gt;--ignore-pattern&lt;/code&gt; 의 패턴으로 사용되는 모든 경로 는 슬래시를 경로 구분 기호로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="051c540be9962a7623f661578a805c175aaad210" translate="yes" xml:space="preserve">
          <source>On a separate line, describing the code beneath it.</source>
          <target state="translated">별도의 줄에 코드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="41a98baf04faa90e085c1d5b39d3f2303b09a371" translate="yes" xml:space="preserve">
          <source>On multiple lines, to comment out sections of code.</source>
          <target state="translated">여러 줄에서 코드 섹션을 주석 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dd6bc408351897c37ede1ee1ad09032dd8381b52" translate="yes" xml:space="preserve">
          <source>On the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.</source>
          <target state="translated">첫 번째 줄에서 JavaScript 엔진은 세미콜론을 자동으로 삽입하므로 구문 오류로 간주되지 않습니다. JavaScript 엔진은 여전히 ​​라인을 해석하는 방법을 알고 있으며 라인 끝은 명령문의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be62b8888255b7d5db97a2146275b0a473a3cd7f" translate="yes" xml:space="preserve">
          <source>On the other hand, if the code is targeting only ES5-compliant environments passing the radix &lt;code&gt;10&lt;/code&gt; may be redundant. In such a case you might want to disallow using such a radix.</source>
          <target state="translated">반면에 코드가 ES5 호환 환경 만 대상으로하는 경우 기수 &lt;code&gt;10&lt;/code&gt; 을 통과하는 것은 중복 될 수 있습니다. 이러한 경우 기수 사용을 금지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54325008781cc6962735603ca0f94ac6486bda16" translate="yes" xml:space="preserve">
          <source>On the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:</source>
          <target state="translated">반론의 반대편에는 세미콜론이 자동으로 삽입되므로 선택 사항이며 수동으로 삽입 할 필요가 없다고 말하는 사람들이 있습니다. 그러나 세미콜론을 사용하지 않는 사람들에게는 ASI 메커니즘이 까다로울 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="96134602d9113347d1bc859098545b8dd3e69676" translate="yes" xml:space="preserve">
          <source>Once again, the intent here is to show that the developer intended for there to be no default behavior.</source>
          <target state="translated">다시 한 번, 여기서 의도는 개발자가 기본 동작이 없도록 의도했음을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1de3fc4cbdd3e50999095504fb8e328eb84c3d2" translate="yes" xml:space="preserve">
          <source>Once npm is installed, run the following</source>
          <target state="translated">npm이 설치되면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c04fc496076254cace10e1520cd55bfc500cbbe1" translate="yes" xml:space="preserve">
          <source>Once the AST is available, &lt;code&gt;estraverse&lt;/code&gt; is used to traverse the AST from top to bottom. At each node, the &lt;code&gt;Linter&lt;/code&gt; object emits an event that has the same name as the node type (i.e., &quot;Identifier&quot;, &quot;WithStatement&quot;, etc.). On the way back up the subtree, an event is emitted with the AST type name and suffixed with &quot;:exit&quot;, such as &quot;Identifier:exit&quot; - this allows rules to take action both on the way down and on the way up in the traversal. Each event is emitted with the appropriate AST node available.</source>
          <target state="translated">AST가 사용 가능하면 &lt;code&gt;estraverse&lt;/code&gt; 를 사용하여 AST를 위에서 아래로 순회합니다. 각 노드에서 &lt;code&gt;Linter&lt;/code&gt; 객체는 노드 유형과 이름이 같은 이벤트 (예 : &quot;식별자&quot;, &quot;WithStatement&quot;등)를 생성합니다. 하위 트리를 백업하는 중에는 AST 유형 이름으로 이벤트가 생성되고 &quot;Identifier : exit&quot;와 같이 &quot;: exit&quot;로 접미사가 붙습니다. 이렇게하면 규칙이 진행중인 작업과 진행중인 작업을 모두 수행 할 수 있습니다. 순회. 각 이벤트는 사용 가능한 적절한 AST 노드와 함께 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="64e40e04906a03b72ac5f6ed6329c5032886299c" translate="yes" xml:space="preserve">
          <source>Once you get a report object, it's up to you to determine how to output the results. Fixes will not be automatically applied to the files, even if you set &lt;code&gt;fix: true&lt;/code&gt; when constructing the &lt;code&gt;CLIEngine&lt;/code&gt; instance. To apply fixes to the files, call &lt;a href=&quot;#cliengineoutputfixes&quot;&gt;&lt;code&gt;outputFixes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보고서 개체를 얻은 후에는 결과를 출력하는 방법을 결정해야합니다. &lt;code&gt;CLIEngine&lt;/code&gt; 인스턴스를 구성 할 때 &lt;code&gt;fix: true&lt;/code&gt; 를 설정하더라도 파일에 수정 사항이 자동으로 적용되지 않습니다 . 파일에 수정 사항을 적용하려면 &lt;a href=&quot;#cliengineoutputfixes&quot;&gt; &lt;code&gt;outputFixes&lt;/code&gt; 를&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b58e4b61287e965d92e76370ea203cbb83aba778" translate="yes" xml:space="preserve">
          <source>Once you have a local copy and have Node.JS and npm installed, you'll need to install the ESLint dependencies:</source>
          <target state="translated">로컬 사본이 있고 Node.JS 및 npm이 설치되면 ESLint 종속성을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7288581c9fd0f9fb86a36a0098329661fafddf0" translate="yes" xml:space="preserve">
          <source>Once you have an instance of &lt;code&gt;SourceCode&lt;/code&gt;, you can use the methods on it to work with the code:</source>
          <target state="translated">&lt;code&gt;SourceCode&lt;/code&gt; 의 인스턴스가 있으면 그 메소드를 사용하여 코드 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35dc0ae3fcf2f907c56b8a61b2d1c1013797195" translate="yes" xml:space="preserve">
          <source>Once you have the configuration information, you can pass it into the &lt;code&gt;linter&lt;/code&gt; object:</source>
          <target state="translated">구성 정보가 있으면이를 &lt;code&gt;linter&lt;/code&gt; 객체 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5819a1bbc0e4af2eebf7583e7e5176671549350" translate="yes" xml:space="preserve">
          <source>Once you have your development environment installed, you can make and submit changes to the ESLint source files. Doing this successfully requires careful adherence to our &lt;a href=&quot;contributing/pull-requests&quot;&gt;pull-request submission workflow&lt;/a&gt;.</source>
          <target state="translated">개발 환경이 설치되면 ESLint 소스 파일을 변경하고 제출할 수 있습니다. 이 작업을 성공적으로 수행하려면 &lt;a href=&quot;contributing/pull-requests&quot;&gt;풀 요청 제출 워크 플로우&lt;/a&gt; 를주의 깊게 준수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df1fc06bd4ba0916a355e415a08d9ac385fc744f" translate="yes" xml:space="preserve">
          <source>Once you've cloned the repository, run &lt;code&gt;npm install&lt;/code&gt; to get all the necessary dependencies:</source>
          <target state="translated">저장소를 복제 한 후 &lt;code&gt;npm install&lt;/code&gt; 을 실행 하여 필요한 모든 종속성을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="a952bd0499233ed62352245dbdd816bb714cb93a" translate="yes" xml:space="preserve">
          <source>Once you've got ESLint running, you'll probably want to adjust the configuration to better suit your project. This section explains all the different ways you can configure ESLint.</source>
          <target state="translated">ESLint를 실행 한 후에는 프로젝트에 더 적합하도록 구성을 조정하고 싶을 것입니다. 이 섹션에서는 ESLint를 구성 할 수있는 모든 다른 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="80320c8df4e958c73560fc248b42aa546a052559" translate="yes" xml:space="preserve">
          <source>Once you've made changes that you want to share with the community, the next step is to submit those changes back via a pull request.</source>
          <target state="translated">커뮤니티와 공유하고 싶은 변경을 한 후 다음 단계는 풀 요청을 통해 변경 사항을 다시 제출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73e73f412681c6b3c636b32c5dd0a954ee56c9f0" translate="yes" xml:space="preserve">
          <source>Once your pull request is sent, it's time for the team to review it. As such, please make sure to:</source>
          <target state="translated">풀 요청이 전송되면 팀이이를 검토 할 때입니다. 따라서 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="461bb8bc5f902440c44a097ed81d4ff591b9129d" translate="yes" xml:space="preserve">
          <source>Once your shareable config is ready, you can &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;publish to npm&lt;/a&gt; to share with others. We recommend using the &lt;code&gt;eslint&lt;/code&gt; and &lt;code&gt;eslintconfig&lt;/code&gt; keywords so others can easily find your module.</source>
          <target state="translated">공유 가능한 구성이 준비되면 &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;npm&lt;/a&gt; 에 게시하여 다른 사람들과 공유 할 수 있습니다. 다른 사용자가 쉽게 모듈을 찾을 수 있도록 &lt;code&gt;eslint&lt;/code&gt; 및 &lt;code&gt;eslintconfig&lt;/code&gt; 키워드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="968cb18b99b4f357f4169659789d6d35558a5b6b" translate="yes" xml:space="preserve">
          <source>One blank line should always be used in the following circumstances:</source>
          <target state="translated">다음 상황에서는 항상 빈 줄 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e05f3f48106cca4c55183384c239e9f6781eecf" translate="yes" xml:space="preserve">
          <source>One common variant of one true brace style is called Stroustrup, in which the &lt;code&gt;else&lt;/code&gt; statements in an &lt;code&gt;if-else&lt;/code&gt; construct, as well as &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt;, must be on its own line after the preceding closing brace. For example:</source>
          <target state="translated">진정한 중괄호 스타일의 하나 개의 일반적인 변형이있는, 스트로브 스트 룹라고 &lt;code&gt;else&lt;/code&gt; 에 문 &lt;code&gt;if-else&lt;/code&gt; 구조뿐만 아니라 &lt;code&gt;catch&lt;/code&gt; 하고 &lt;code&gt;finally&lt;/code&gt; , 앞의 닫는 중괄호 후 자신의 행에 있어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="074902a0b6265654f7818885f2c699f282da2808" translate="yes" xml:space="preserve">
          <source>One key is &lt;code&gt;VariableDeclarator&lt;/code&gt; and the other is &lt;code&gt;AssignmentExpression&lt;/code&gt;, which can be used to control the destructuring requirement for each of those types independently. Each property accepts an object that accepts two properties, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt;, which can be used to control the destructuring requirement for each of &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; independently for variable declarations and assignment expressions. By default, &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are set to true for both &lt;code&gt;VariableDeclarator&lt;/code&gt; and &lt;code&gt;AssignmentExpression&lt;/code&gt;.</source>
          <target state="translated">하나의 키는 &lt;code&gt;VariableDeclarator&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;AssignmentExpression&lt;/code&gt; 으로 , 각 유형에 대한 디스트 럭처링 요구 사항을 독립적으로 제어하는 ​​데 사용할 수 있습니다. 각 속성은 &lt;code&gt;array&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 의 두 속성을 허용하는 객체를 허용합니다.이 속성은 변수 선언과 할당 표현식에 대해 개별적으로 각 &lt;code&gt;array&lt;/code&gt; 과 &lt;code&gt;object&lt;/code&gt; 대한 구조화 요구 사항을 제어하는 ​​데 사용할 수 있습니다 . 기본적으로 &lt;code&gt;array&lt;/code&gt; 과 &lt;code&gt;object&lt;/code&gt; 는 &lt;code&gt;VariableDeclarator&lt;/code&gt; 및 &lt;code&gt;AssignmentExpression&lt;/code&gt; 모두에 대해 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b40cc8090e56f00ece04fc448cb76c1a5545421" translate="yes" xml:space="preserve">
          <source>One of benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:</source>
          <target state="translated">이 옵션의 장점 중 하나는 조건부에서 화살표 기능이 잘못 사용되는 것을 방지한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="93a084e0710ce98d42a3b6895d5f4238168d8a76" translate="yes" xml:space="preserve">
          <source>One of the great things about open source projects is that anyone can contribute in any number of meaningful ways. ESLint couldn't exist without the help of the many contributors it's had since the project began, and we want you to feel like you can contribute and make a difference as well.</source>
          <target state="translated">오픈 소스 프로젝트의 가장 큰 장점 중 하나는 누구나 의미있는 방식으로 많은 기여를 할 수 있다는 것입니다. 프로젝트가 시작된 이래 많은 기여자들의 도움 없이는 ESLint가 존재할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="8fe321b030cabb7b6a56d2b3c7ba46379fd8d541" translate="yes" xml:space="preserve">
          <source>One of the interesting, and sometimes confusing, aspects of JavaScript is that assignment can happen at almost any point. Because of this, an errant equals sign can end up causing assignment when the true intent was to do a comparison. This is especially true when using a &lt;code&gt;return&lt;/code&gt; statement. For example:</source>
          <target state="translated">JavaScript의 흥미롭고 때로는 혼란스러운 측면 중 하나는 거의 모든 시점에서 할당이 가능하다는 것입니다. 이 때문에 잘못된 의도 부호는 실제 의도가 비교를 수행 할 때 할당을 야기 할 수 있습니다. &lt;code&gt;return&lt;/code&gt; 문을 사용할 때 특히 그렇습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc2c724cf22353a00eb4d8e0b5ec68baf78eb5ec" translate="yes" xml:space="preserve">
          <source>One of the justifications for using Comma First style is that it can help track missing and trailing commas. These are problematic because missing commas in variable declarations can lead to the leakage of global variables and trailing commas can lead to errors in older versions of IE.</source>
          <target state="translated">쉼표 첫 번째 스타일을 사용하는 데 필요한 타당성 중 하나는 누락되고 후행 쉼표를 추적 할 수 있다는 것입니다. 변수 선언에서 쉼표가 누락되면 전역 변수가 누출되고 후행 쉼표가 이전 버전의 IE에서 오류가 발생할 수 있기 때문에 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="43739dc5f4290e33b069d3cbfc858a0190a0b218" translate="yes" xml:space="preserve">
          <source>One way to fix this issue would be to ensure that &lt;code&gt;totalLength&lt;/code&gt; is read at the same time as it's updated, like this:</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법 은 다음과 같이 &lt;code&gt;totalLength&lt;/code&gt; 가 업데이트되는 동시에 읽 도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="82d457ac979b2d749bfa1fff14b37ecb16e90d1f" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;return&lt;/code&gt; without a value is allowed, as it's a control flow statement.</source>
          <target state="translated">제어 흐름 문이므로 값이없는 &lt;code&gt;return&lt;/code&gt; 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="865b1b6e5f709be37accdd161c63ae845508b783" translate="yes" xml:space="preserve">
          <source>Only make one fix per message. This is enforced because you must return the result of the fixer operation from &lt;code&gt;fix()&lt;/code&gt;.</source>
          <target state="translated">메시지 당 하나만 수정하십시오. fixer 조작의 결과를 &lt;code&gt;fix()&lt;/code&gt; 에서 리턴해야하기 때문에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="651a50a7f66b3213d4ddbca3f4a04a538e94dae9" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;Property&lt;/code&gt; node type is ignored by default, because for the &lt;a href=&quot;key-spacing&quot;&gt;key-spacing&lt;/a&gt; rule some alignment options require multiple spaces in properties of object literals.</source>
          <target state="translated">&lt;a href=&quot;key-spacing&quot;&gt;키 간격&lt;/a&gt; 규칙의 경우 일부 정렬 옵션에는 객체 리터럴 속성에 여러 공백이 필요 하므로 &lt;code&gt;Property&lt;/code&gt; 노드 유형 만 기본적으로 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="29e0482fd1761fdd60ab2cbaa6f30278bf01c57e" translate="yes" xml:space="preserve">
          <source>Open up developer tools</source>
          <target state="translated">개발자 도구를 엽니 다</target>
        </trans-unit>
        <trans-unit id="528fa3274e8f2faac58c536989703b2a7691898b" translate="yes" xml:space="preserve">
          <source>Operator Spacing</source>
          <target state="translated">연산자 간격</target>
        </trans-unit>
        <trans-unit id="f31ac1bc0518dff16e20d2bee973046b839b0d11" translate="yes" xml:space="preserve">
          <source>Operators with two operands must be preceded and followed by a single space to make the expression clear. Operators include assignments and logical operators.</source>
          <target state="translated">피연산자가 두 개인 연산자는 앞에 공백이 있어야하고 그 뒤에식이 명확해야합니다. 연산자에는 할당 및 논리 연산자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf9f8318f166d81f0832974953640e35cb76c75" translate="yes" xml:space="preserve">
          <source>Opponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn't outweigh the readability hit the code takes while using Yoda conditions.</source>
          <target state="translated">Yoda 조건의 반대자들은 툴링이 &lt;code&gt;==&lt;/code&gt; 대신 실수로 &lt;code&gt;=&lt;/code&gt; 를 사용하기 때문에 툴링이 더 나은 프로그래머가되었다고 지적합니다 (ESLint가 이것을 잡을 것입니다). 따라서 그들은 패턴의 유용성이 Yoda 조건을 사용하는 동안 코드가 읽는 가독성을 초과하지 않는다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="cc2f1a7f94147f105a8901b8c9bb3f24406fa1ff" translate="yes" xml:space="preserve">
          <source>Optional Exception</source>
          <target state="translated">선택적 예외</target>
        </trans-unit>
        <trans-unit id="4f2085951383e2cdbc090c9683b06731c8ef7ac4" translate="yes" xml:space="preserve">
          <source>Optionally, this rule can also enforce consistent order (&lt;code&gt;getBeforeSet&lt;/code&gt; or &lt;code&gt;setBeforeGet&lt;/code&gt;).</source>
          <target state="translated">선택적으로이 규칙은 일관된 순서 ( &lt;code&gt;getBeforeSet&lt;/code&gt; 또는 &lt;code&gt;setBeforeGet&lt;/code&gt; )를 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f583032cbdd550a2873302394f975358318e3c2" translate="yes" xml:space="preserve">
          <source>Optionally, you may specify a &lt;code&gt;max&lt;/code&gt; object property:</source>
          <target state="translated">선택적으로 &lt;code&gt;max&lt;/code&gt; object 속성을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="babf5970a0d99737bb086b6569f51b231437e499" translate="yes" xml:space="preserve">
          <source>Options Schemas</source>
          <target state="translated">옵션 스키마</target>
        </trans-unit>
        <trans-unit id="125e188e5c535aba49305bcd42d96422853718e3" translate="yes" xml:space="preserve">
          <source>Options that accept array values can be specified by repeating the option or with a comma-delimited list (other than &lt;code&gt;--ignore-pattern&lt;/code&gt; which does not allow the second style).</source>
          <target state="translated">배열 값을 허용하는 옵션은 옵션을 반복하거나 쉼표로 구분 된 목록 ( 두 번째 스타일을 허용하지 않는 &lt;code&gt;--ignore-pattern&lt;/code&gt; 이외)으로 지정하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6d4354c518051842952b8b24cff75c301ac9bd" translate="yes" xml:space="preserve">
          <source>Or an object option (Requires line breaks if any of properties is satisfied. Otherwise, disallows line breaks):</source>
          <target state="translated">또는 객체 옵션 (속성이 충족되면 줄 바꿈이 필요합니다. 그렇지 않으면 줄 바꿈이 허용되지 않음) :</target>
        </trans-unit>
        <trans-unit id="48fb5dcfee6b391a00a0d645f582f3d72542e395" translate="yes" xml:space="preserve">
          <source>Or an object option:</source>
          <target state="translated">또는 객체 옵션 :</target>
        </trans-unit>
        <trans-unit id="8e04bc60d27598107203a60a335ed572e88264d3" translate="yes" xml:space="preserve">
          <source>Or for non-iterable 'array-like' objects:</source>
          <target state="translated">또는 반복 불가능한 '배열과 같은'객체의 경우 :</target>
        </trans-unit>
        <trans-unit id="8b117f5f38fcd06ba55849762c28b3c6a4df0d38" translate="yes" xml:space="preserve">
          <source>Or for tabbed indentation:</source>
          <target state="translated">또는 탭 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="534b36ed6d3baf1cd0fb88cab59bd33364f67414" translate="yes" xml:space="preserve">
          <source>Or in a &lt;code&gt;package.json&lt;/code&gt; file</source>
          <target state="translated">또는 &lt;code&gt;package.json&lt;/code&gt; 파일에서</target>
        </trans-unit>
        <trans-unit id="983504f1db047b4a14f090593364eea27f5c86b0" translate="yes" xml:space="preserve">
          <source>Or you can enforce that calls to &lt;code&gt;setTimeout&lt;/code&gt; always have two arguments:</source>
          <target state="translated">또는 &lt;code&gt;setTimeout&lt;/code&gt; 호출에 항상 두 개의 인수가 있도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2349626c15ba88b850dda985180df347efff61da" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;Variable&lt;/code&gt; objects and &lt;code&gt;Reference&lt;/code&gt; objects refer each other:</source>
          <target state="translated">원래 &lt;code&gt;Variable&lt;/code&gt; 객체와 &lt;code&gt;Reference&lt;/code&gt; 객체는 서로를 참조 합니다.</target>
        </trans-unit>
        <trans-unit id="0c7f2d70c0ac6c087885c2e18648286544190997" translate="yes" xml:space="preserve">
          <source>Other Integration Lists</source>
          <target state="translated">다른 통합 목록</target>
        </trans-unit>
        <trans-unit id="121423f7955be6f99034dbe35e9109d534d3bb31" translate="yes" xml:space="preserve">
          <source>Other code conventions allow you to skip the &lt;code&gt;default&lt;/code&gt; case so long as there is a comment indicating the omission is intentional, such as:</source>
          <target state="translated">다른 코드 규칙에서는 다음 과 같이 생략을 의도적으로 나타내는 주석이있는 경우 &lt;code&gt;default&lt;/code&gt; 사례 를 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c413664d095ba6eda32b2e5180bd3f63ad775b0e" translate="yes" xml:space="preserve">
          <source>Others prefer to declare one var per line.</source>
          <target state="translated">다른 사람들은 한 줄에 하나의 var를 선언하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="777e3867f41cdcbbc95d8a27831735e4439631d1" translate="yes" xml:space="preserve">
          <source>Otherwise are considered problems.</source>
          <target state="translated">그렇지 않으면 문제로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8f226c4b9fa003489fea8332ce25c85c4ade2f50" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;&quot;safe&quot;&lt;/code&gt; option corresponds to the &lt;code&gt;&quot;function&quot;&lt;/code&gt; option. Note that if &lt;code&gt;&quot;globalReturn&quot;: false&lt;/code&gt; is explicitly specified in the configuration, the &lt;code&gt;&quot;safe&quot;&lt;/code&gt; option will correspond to the &lt;code&gt;&quot;function&quot;&lt;/code&gt; option regardless of the specified environment.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;&quot;safe&quot;&lt;/code&gt; 옵션은 &lt;code&gt;&quot;function&quot;&lt;/code&gt; 옵션에 해당합니다 . 경우주의 &lt;code&gt;&quot;globalReturn&quot;: false&lt;/code&gt; 명시 적 구성에 지정되면, &lt;code&gt;&quot;safe&quot;&lt;/code&gt; 옵션은에 해당한다 &lt;code&gt;&quot;function&quot;&lt;/code&gt; 에 관계없이 지정된 환경의 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0b2741d82e791a60bad1a8621fcdbf97b20d60b3" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;RuleTester#run&lt;/code&gt; will simply execute all of the tests in sequence, and will throw an error if one of them fails. This means you can simply execute a test file that calls &lt;code&gt;RuleTester.run&lt;/code&gt; using &lt;code&gt;node&lt;/code&gt;, without needing a testing framework.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;RuleTester#run&lt;/code&gt; 은 모든 테스트를 순서대로 실행하며 그 중 하나가 실패하면 오류를 발생시킵니다. 즉 , 테스트 프레임 워크없이 &lt;code&gt;node&lt;/code&gt; 를 사용하여 &lt;code&gt;RuleTester.run&lt;/code&gt; 을 호출하는 테스트 파일을 간단히 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da453deb49d685f98fdc9eee6730a3db89861b4f" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;describe&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; are present as globals, &lt;code&gt;RuleTester&lt;/code&gt; will use &lt;code&gt;global.describe&lt;/code&gt; and &lt;code&gt;global.it&lt;/code&gt; to run tests. This allows &lt;code&gt;RuleTester&lt;/code&gt; to work when using frameworks like &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha&lt;/a&gt; without any additional configuration.</source>
          <target state="translated">그렇지 않으면, &lt;code&gt;describe&lt;/code&gt; 과 &lt;code&gt;it&lt;/code&gt; 전역와 같은 존재, &lt;code&gt;RuleTester&lt;/code&gt; 는 사용 &lt;code&gt;global.describe&lt;/code&gt; 을 하고 &lt;code&gt;global.it&lt;/code&gt; 테스트를 실행합니다. 따라서 추가 구성없이 &lt;a href=&quot;https://mochajs.org/&quot;&gt;Mocha&lt;/a&gt; 와 같은 프레임 워크를 사용할 때 &lt;code&gt;RuleTester&lt;/code&gt; 가 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f111dde36a2183fb8b31d84bb35478c7ad28ae40" translate="yes" xml:space="preserve">
          <source>Otherwise, if the node does not declare any variables, an empty array is returned.</source>
          <target state="translated">그렇지 않으면 노드가 변수를 선언하지 않으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="112f84fde1efd0a6b137f4ef4aeed3c549b08bd5" translate="yes" xml:space="preserve">
          <source>Our commit message format is as follows:</source>
          <target state="translated">커밋 메시지 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="874ef7e39663f7db82348ed922daa965002f8637" translate="yes" xml:space="preserve">
          <source>Our public &lt;a href=&quot;https://github.com/eslint/eslint/issues&quot;&gt;issues tracker&lt;/a&gt; lists all of the things we plan on doing as well as suggestions from the community. Before starting to work on an issue, be sure you read through the rest of this page.</source>
          <target state="translated">우리의 공개 &lt;a href=&quot;https://github.com/eslint/eslint/issues&quot;&gt;이슈 트래커&lt;/a&gt; 는 우리가 계획 한 모든 것들과 커뮤니티의 제안을 나열합니다. 문제 해결을 시작하기 전에이 페이지의 나머지 부분을 반드시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="50d578ebf4e00d8649eb4f95a59bf792edcd3b16" translate="yes" xml:space="preserve">
          <source>Output Examples</source>
          <target state="translated">출력 예</target>
        </trans-unit>
        <trans-unit id="f721699fc008a02ac10d406435648374991b8df2" translate="yes" xml:space="preserve">
          <source>Output object from this method:</source>
          <target state="translated">이 메소드의 출력 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="2ae3c877f13160bf4fb915afd2aa35c94e464b88" translate="yes" xml:space="preserve">
          <source>Output to the console</source>
          <target state="translated">콘솔로 출력</target>
        </trans-unit>
        <trans-unit id="afb6b4b6cae2618f58f61a3533c0fccfc233090f" translate="yes" xml:space="preserve">
          <source>Outputting to the console</source>
          <target state="translated">콘솔로 출력</target>
        </trans-unit>
        <trans-unit id="afdf6e15c0ce33e13907329dd18f3fa61951053c" translate="yes" xml:space="preserve">
          <source>Outputting to the filesystem</source>
          <target state="translated">파일 시스템으로 출력</target>
        </trans-unit>
        <trans-unit id="744acdca9924738f6ba20a057659f4dab8956cfb" translate="yes" xml:space="preserve">
          <source>Over the past several releases, we have been deprecating rules and introducing new rules to take their place. The following is a list of the removed rules and their replacements:</source>
          <target state="translated">지난 몇 가지 릴리스에서 우리는 규칙을 더 이상 사용하지 않고 새로운 규칙을 도입했습니다. 다음은 제거 된 규칙 및 대체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f15e25b67d56c0b50f6e65a89912cb8c44445c60" translate="yes" xml:space="preserve">
          <source>Overall Performance</source>
          <target state="translated">전반적인 성능</target>
        </trans-unit>
        <trans-unit id="bed3eb091eb6a1e8a3c68cc9f2b8cad9f0ea7e35" translate="yes" xml:space="preserve">
          <source>Override blocks can also specify patterns to exclude from matches. If a file matches any of the excluded patterns, the configuration won't apply.</source>
          <target state="translated">재정의 블록은 일치 항목에서 제외 할 패턴을 지정할 수도 있습니다. 파일이 제외 된 패턴과 일치하면 구성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d65d233ad72a12dd5f816f689346ed699f068f74" translate="yes" xml:space="preserve">
          <source>Overrides in a config file can now match dotfiles</source>
          <target state="translated">구성 파일의 재정의는 이제 점 파일과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7279b45cea6645bd003b55c34e4e0b68128806b" translate="yes" xml:space="preserve">
          <source>Overrides in an extended config file can now be overridden by a parent config file</source>
          <target state="translated">확장 구성 파일의 재정의를 상위 구성 파일로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e380bd7906ce369799455bb337baa4a7e912c3" translate="yes" xml:space="preserve">
          <source>Packaging the Custom Formatter</source>
          <target state="translated">커스텀 포맷터 패키징</target>
        </trans-unit>
        <trans-unit id="0a0e056314281df7ebe5bff4801d78e2bcb2e0da" translate="yes" xml:space="preserve">
          <source>Parentheses Spacing</source>
          <target state="translated">괄호 간격</target>
        </trans-unit>
        <trans-unit id="8b047ea57f8d4953d13e87c42cd0dfbacf8b9d4e" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Formatters</source>
          <target state="translated">포맷터에 인수 전달</target>
        </trans-unit>
        <trans-unit id="bbad3fbb9280e935e855b557b50f0feb18c726b1" translate="yes" xml:space="preserve">
          <source>Passing the callback by reference</source>
          <target state="translated">참조로 콜백 전달</target>
        </trans-unit>
        <trans-unit id="866764460d5b328ce01c5d25fea87d4f72c58d7e" translate="yes" xml:space="preserve">
          <source>Path to the cache file. If none specified &lt;code&gt;.eslintcache&lt;/code&gt; will be used. The file will be created in the directory where the &lt;code&gt;eslint&lt;/code&gt; command is executed. &lt;strong&gt;Deprecated&lt;/strong&gt;: Use &lt;code&gt;--cache-location&lt;/code&gt; instead.</source>
          <target state="translated">캐시 파일의 경로입니다. 지정하지 않으면 &lt;code&gt;.eslintcache&lt;/code&gt; 가 사용됩니다. &lt;code&gt;eslint&lt;/code&gt; 명령이 실행되는 디렉토리에 파일이 작성됩니다 . &lt;strong&gt;더 이상 사용되지 않음&lt;/strong&gt; : 대신 &lt;code&gt;--cache-location&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a4f2472b12ffd8aaa283f1912f4a749bb112a9e" translate="yes" xml:space="preserve">
          <source>Path to the cache location. Can be a file or a directory. If no location is specified, &lt;code&gt;.eslintcache&lt;/code&gt; will be used. In that case, the file will be created in the directory where the &lt;code&gt;eslint&lt;/code&gt; command is executed.</source>
          <target state="translated">캐시 위치에 대한 경로입니다. 파일 또는 디렉토리 일 수 있습니다. 위치를 지정하지 않으면 &lt;code&gt;.eslintcache&lt;/code&gt; 가 사용됩니다. 이 경우 파일은 &lt;code&gt;eslint&lt;/code&gt; 명령이 실행되는 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cf1a4ce359a6f23066671fb0ce9dcb0cf168d6e" translate="yes" xml:space="preserve">
          <source>Paths are relative to &lt;code&gt;.eslintignore&lt;/code&gt; location or the current working directory. This is also true of paths passed in via the &lt;code&gt;--ignore-pattern&lt;/code&gt;&lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">경로는 &lt;code&gt;.eslintignore&lt;/code&gt; 위치 또는 현재 작업 디렉토리에 상대적 입니다. &lt;code&gt;--ignore-pattern&lt;/code&gt; &lt;a href=&quot;command-line-interface#--ignore-pattern&quot;&gt;명령&lt;/a&gt; 을 통해 전달 된 경로에서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="0493aae6aa03f23cee93bbaad9b496620e893832" translate="yes" xml:space="preserve">
          <source>Peer Dependency</source>
          <target state="translated">동료 의존성</target>
        </trans-unit>
        <trans-unit id="d4a170a4c994882082963476d79b1a77b04c7ae7" translate="yes" xml:space="preserve">
          <source>Per-rule Performance</source>
          <target state="translated">규칙 별 성능</target>
        </trans-unit>
        <trans-unit id="ed363adcc6ae50f9e2d44c956c484ce493017156" translate="yes" xml:space="preserve">
          <source>Perform any asynchronous operations</source>
          <target state="translated">비동기 작업 수행</target>
        </trans-unit>
        <trans-unit id="9b69332b09b8aef3669c8068b4744d1b0de90bdd" translate="yes" xml:space="preserve">
          <source>Performance Testing</source>
          <target state="translated">성능 시험</target>
        </trans-unit>
        <trans-unit id="be4da6f0c7a2438c9087ddd0f224ce1c2084f2f0" translate="yes" xml:space="preserve">
          <source>Performing an operation on each element of an iterable is a common task. However, performing an &lt;code&gt;await&lt;/code&gt; as part of each operation is an indication that the program is not taking full advantage of the parallelization benefits of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">iterable의 각 요소에 대해 작업을 수행하는 것은 일반적인 작업입니다. 그러나 각 작업의 일부로 &lt;code&gt;await&lt;/code&gt; 를 수행 한다는 것은 프로그램이 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 의 병렬화 이점을 충분히 활용하지 않음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="95901ce3386d6d8922a77162d48436823c7874d9" translate="yes" xml:space="preserve">
          <source>Personal Configuration File (deprecated)</source>
          <target state="translated">개인 구성 파일 (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="df4e75f6b932e3d5f6b66dcca11234789a64b98d" translate="yes" xml:space="preserve">
          <source>Piping Code Into ESLint</source>
          <target state="translated">ESLint에 파이핑 코드</target>
        </trans-unit>
        <trans-unit id="06f50881a755583b161af4399bd829f0111ebe4f" translate="yes" xml:space="preserve">
          <source>Place all of your runtime rules in the same directory (e.g., &lt;code&gt;eslint_rules&lt;/code&gt;).</source>
          <target state="translated">모든 런타임 규칙을 동일한 디렉토리 (예 : &lt;code&gt;eslint_rules&lt;/code&gt; ) 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="31ccc366a57c10600d02a87ddb1627ad8fcf83e4" translate="yes" xml:space="preserve">
          <source>Place all of your runtime rules in the same directory (i.e., &lt;code&gt;eslint_rules&lt;/code&gt;).</source>
          <target state="translated">모든 런타임 규칙을 동일한 디렉토리 (예 : &lt;code&gt;eslint_rules&lt;/code&gt; ) 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="92009e0d6a0520471a107f4e981c2e736fb0840b" translate="yes" xml:space="preserve">
          <source>Placeholders in suggestion messages</source>
          <target state="translated">제안 메시지의 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="e51396525bede24fbfd195365328421b2712f903" translate="yes" xml:space="preserve">
          <source>Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that's time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.</source>
          <target state="translated">문제를 올바르게 해결하는 데 도움이되도록 최대한 자세하게 설명해주세요. 문제를 심사하고 지속적으로 사람들에게 더 자세한 정보를 요청해야하는 경우 실제로 문제를 해결하는 데 시간이 걸립니다. 귀하의 문제에 많은 세부 사항을 포함시켜 최대한 효율적으로 도와주십시오.</target>
        </trans-unit>
        <trans-unit id="cd6cb4e45c0a145bc991dcd0e8f4ab88f39165d4" translate="yes" xml:space="preserve">
          <source>Please note that supporting JSX syntax is not the same as supporting React. React applies specific semantics to JSX syntax that ESLint doesn't recognize. We recommend using &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react&quot;&gt;eslint-plugin-react&lt;/a&gt; if you are using React and want React semantics. By the same token, supporting ES6 syntax is not the same as supporting new ES6 globals (e.g., new types such as &lt;code&gt;Set&lt;/code&gt;). For ES6 syntax, use &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt;; for new ES6 global variables, use &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt;. &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; enables ES6 syntax automatically, but &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; does not enable ES6 globals automatically. Parser options are set in your &lt;code&gt;.eslintrc.*&lt;/code&gt; file by using the &lt;code&gt;parserOptions&lt;/code&gt; property. The available options are:</source>
          <target state="translated">JSX 구문 지원은 React 지원과 다릅니다. React는 ESLint가 인식하지 못하는 JSX 구문에 특정 의미를 적용합니다. React를 사용하고 있고 React 의미 를 &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react&quot;&gt;원하면 eslint-plugin-react를&lt;/a&gt; 사용하는 것이 좋습니다 . 같은 토큰으로 ES6 구문을 지원하는 것은 새로운 ES6 전역 (예 : &lt;code&gt;Set&lt;/code&gt; 과 같은 새로운 유형)을 지원하는 것과 다릅니다 . ES6 구문의 경우 &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; ; 새로운 ES6 전역 변수의 경우 &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; . &lt;code&gt;{ &quot;env&quot;: { &quot;es6&quot;: true } }&lt;/code&gt; 은 ES6 구문을 자동으로 활성화하지만 &lt;code&gt;{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }&lt;/code&gt; 은 ES6 전역을 자동으로 활성화하지 않습니다.파서 옵션은 &lt;code&gt;.eslintrc.*&lt;/code&gt; &lt;code&gt;parserOptions&lt;/code&gt; 속성 을 사용하여 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caa1e575508ae90c0c1f3ba9cbc5f1d6c3021954" translate="yes" xml:space="preserve">
          <source>Please note that the following methods have been deprecated and will be removed in a future version of ESLint:</source>
          <target state="translated">다음 방법은 더 이상 사용되지 않으며 향후 ESLint 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="32dcca51ba22590cfb1a0282165e0b20b80790ba" translate="yes" xml:space="preserve">
          <source>Please note that this option applies only to identifiers inside destructuring patterns. It doesn't additionally allow any particular use of the created variables later in the code apart from the use that is already allowed by default or by other options.</source>
          <target state="translated">이 옵션은 파괴 패턴 내부의 식별자에만 적용됩니다. 또한 기본적으로 또는 다른 옵션에 의해 이미 허용 된 사용과는 별도로 코드에서 나중에 생성 된 변수의 특정 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d2fdf1d62a3776fdec8b729a28be6e793bf8d2a" translate="yes" xml:space="preserve">
          <source>Please note that this rule does not compare conditions from the chain with conditions inside statements, and will not warn in the cases such as follows:</source>
          <target state="translated">이 규칙은 체인의 조건과 진술 내부의 조건을 비교하지 않으며 다음과 같은 경우에는 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="970fbd12b618363bade0db3e52057a632da36216" translate="yes" xml:space="preserve">
          <source>Please note that when passing a glob as a parameter, it will be expanded by your shell. The results of the expansion can vary depending on your shell, and its configuration. If you want to use node &lt;code&gt;glob&lt;/code&gt; syntax, you have to quote your parameter (using double quotes if you need it to run in Windows), as follows:</source>
          <target state="translated">glob를 매개 변수로 전달할 때 쉘에 의해 확장됩니다. 확장 결과는 쉘 및 구성에 따라 달라질 수 있습니다. 노드 &lt;code&gt;glob&lt;/code&gt; 구문 을 사용하려면 다음과 같이 매개 변수를 인용해야합니다 (Windows에서 실행해야하는 경우 큰 따옴표를 사용).</target>
        </trans-unit>
        <trans-unit id="7e110a34a2db33270f753e46f8b7ab8a3821147b" translate="yes" xml:space="preserve">
          <source>Please note that you can either use the top-level options or the grouped options (&lt;code&gt;singleLine&lt;/code&gt; and &lt;code&gt;multiLine&lt;/code&gt;) but not both.</source>
          <target state="translated">최상위 옵션 또는 그룹화 된 옵션 ( &lt;code&gt;singleLine&lt;/code&gt; 및 &lt;code&gt;multiLine&lt;/code&gt; )을 사용할 수 있지만 둘 다 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a115fb1f05052d949674b5ad9f4dd54cca5e205b" translate="yes" xml:space="preserve">
          <source>Please note that you have to provide &lt;code&gt;data&lt;/code&gt; on the suggestion's object. Suggestion messages cannot use properties from the overall error's &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">제안의 대상에 대한 &lt;code&gt;data&lt;/code&gt; 를 제공해야 합니다. 제안 메시지는 전체 오류 &lt;code&gt;data&lt;/code&gt; 의 속성을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8131e2054fa3d6ce5d0136ddb8d6ac107226cb3a" translate="yes" xml:space="preserve">
          <source>Please read the user guide's section on &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;configuring parser options&lt;/a&gt; to learn more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../user-guide/configuring#specifying-parser-options&quot;&gt;구문 분석기 옵션 구성&lt;/a&gt; 에 대한 사용자 안내서 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4e9e14b73e813f94faf81a7bf4b8e790aeed433c" translate="yes" xml:space="preserve">
          <source>Please see &lt;code&gt;.gitignore&lt;/code&gt;'s specification for further examples of valid syntax.</source>
          <target state="translated">유효한 구문의 추가 예제는 &lt;code&gt;.gitignore&lt;/code&gt; 의 사양을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="910be8bbebe15605e3211e93adb45fe019aed843" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt;generator documentation&lt;/a&gt; for instructions on how to use it.</source>
          <target state="translated">사용 방법에 대한 지침 은 &lt;a href=&quot;https://github.com/eslint/generator-eslint&quot;&gt;생성기 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c576146a981b5faae12b330f7bab5f655d4de92" translate="yes" xml:space="preserve">
          <source>Plugin authors may need to update installation instructions</source>
          <target state="translated">플러그인 작성자는 설치 지침을 업데이트해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="e3b560171bc6f34e81c89e0ab2f15568841517f3" translate="yes" xml:space="preserve">
          <source>Plugin environments can define the following objects:</source>
          <target state="translated">플러그인 환경은 다음 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbbbaf384cbc0ee72d4f8c606fcf5d504bca04e" translate="yes" xml:space="preserve">
          <source>Plugins No Longer Have Default Configurations</source>
          <target state="translated">더 이상 기본 구성이없는 플러그인</target>
        </trans-unit>
        <trans-unit id="7b2f2b7399c496bf73ff7e69192e8907b6ce6f81" translate="yes" xml:space="preserve">
          <source>Plugins and shareable configs are no longer affected by ESLint's location</source>
          <target state="translated">플러그인 및 공유 가능한 구성은 더 이상 ESLint의 위치에 영향을받지 않습니다</target>
        </trans-unit>
        <trans-unit id="ee9003d71c823216744370af56f21413e11f9752" translate="yes" xml:space="preserve">
          <source>Plugins can expose additional environments for use in ESLint. To do so, the plugin must export an &lt;code&gt;environments&lt;/code&gt; object. The keys of the &lt;code&gt;environments&lt;/code&gt; object are the names of the different environments provided and the values are the environment settings. For example:</source>
          <target state="translated">플러그인은 ESLint에서 사용하기 위해 추가 환경을 노출 할 수 있습니다. 그렇게하려면 플러그인이 &lt;code&gt;environments&lt;/code&gt; 객체를 내 보내야 합니다. &lt;code&gt;environments&lt;/code&gt; 오브젝트 의 키는 제공된 다른 환경의 이름이며 값은 환경 설정입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dec281e97d018cacc13382cfc427e305389a0405" translate="yes" xml:space="preserve">
          <source>Plugins can expose additional rules for use in ESLint. To do so, the plugin must export a &lt;code&gt;rules&lt;/code&gt; object containing a key-value mapping of rule ID to rule. The rule ID does not have to follow any naming convention (so it can just be &lt;code&gt;dollar-sign&lt;/code&gt;, for instance).</source>
          <target state="translated">플러그인은 ESLint에서 사용하기위한 추가 규칙을 노출 할 수 있습니다. 이를 위해 플러그인 은 규칙 ID와 규칙의 키-값 매핑이 포함 된 &lt;code&gt;rules&lt;/code&gt; 객체를 내 보내야합니다 . 규칙 ID는 이름 지정 규칙을 따를 필요가 없습니다 ( 예 : &lt;code&gt;dollar-sign&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b69b69c3f7bf908cf04b17050967f012181e0472" translate="yes" xml:space="preserve">
          <source>Plugins in scoped packages are now resolvable in configs</source>
          <target state="translated">범위가 지정된 패키지의 플러그인은 이제 구성에서 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ec5b88d6b7fe33abdb0cd312d875b7aee0a01e" translate="yes" xml:space="preserve">
          <source>Plugins may provide processors. Processors can extract JavaScript code from another kind of files, then lets ESLint lint the JavaScript code. Or processors can convert JavaScript code in preprocessing for some purpose.</source>
          <target state="translated">플러그인은 프로세서를 제공 할 수 있습니다. 프로세서는 다른 종류의 파일에서 JavaScript 코드를 추출한 다음 ESLint가 JavaScript 코드를 보풀이 할 수 있습니다. 또는 프로세서가 특정 목적으로 전처리에서 JavaScript 코드를 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04de60818b1275febaa49d420056bd8ab7e76e8e" translate="yes" xml:space="preserve">
          <source>Polyjuice works with JSON configuration files, so if you're using a JavaScript or YAML JSCS configuration file, you should first convert it into a JSON configuration file.</source>
          <target state="translated">Polyjuice는 JSON 구성 파일과 함께 작동하므로 JavaScript 또는 YAML JSCS 구성 파일을 사용하는 경우 먼저 JSON 구성 파일로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4db8807336771db69984fb33e2ecb89b2b778d76" translate="yes" xml:space="preserve">
          <source>Possible Errors</source>
          <target state="translated">가능한 오류</target>
        </trans-unit>
        <trans-unit id="51e379f50f0321cddf83015a5392ece47d742feb" translate="yes" xml:space="preserve">
          <source>Prefer destructuring from arrays and objects (prefer-destructuring)</source>
          <target state="translated">배열과 객체에서 구조 제거를 선호합니다 (구조 제거 선호)</target>
        </trans-unit>
        <trans-unit id="c228b3216b65c6046a15d3f0b6ae1deea05d3ecb" translate="yes" xml:space="preserve">
          <source>Prefer use of an object spread over &lt;code&gt;Object.assign&lt;/code&gt; (prefer-object-spread)</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; (object-spread) 보다 분산 된 객체 사용을 선호</target>
        </trans-unit>
        <trans-unit id="82062f1465f3be0589e9c94efa76e989985103e4" translate="yes" xml:space="preserve">
          <source>Prerequisites: &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (&lt;code&gt;^8.10.0&lt;/code&gt;, &lt;code&gt;^10.13.0&lt;/code&gt;, or &lt;code&gt;&amp;gt;=11.10.1&lt;/code&gt;) built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)</source>
          <target state="translated">전제 조건 : SSL 지원으로 빌드 된 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; ( &lt;code&gt;^8.10.0&lt;/code&gt; , &lt;code&gt;^10.13.0&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=11.10.1&lt;/code&gt; ) (공식 Node.js 배포를 사용하는 경우 SSL은 항상 내장되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2a14e1b8f5938872ffc8263a306ac7453d0b08cd" translate="yes" xml:space="preserve">
          <source>Previous versions of ESLint silently ignored any nonexistent files and globs provided on the command line:</source>
          <target state="translated">이전 버전의 ESLint는 명령 줄에 제공된 존재하지 않는 파일과 글로브를 자동으로 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="861eb458285d7d2f2e5428c183895fe75d599908" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;RuleTester&lt;/code&gt; used loose equality when making some of its assertions. For example, if a rule produced the string &lt;code&gt;&quot;7&quot;&lt;/code&gt; as a result of autofixing, &lt;code&gt;RuleTester&lt;/code&gt; would allow the number &lt;code&gt;7&lt;/code&gt; in an &lt;code&gt;output&lt;/code&gt; assertion, rather than the string &lt;code&gt;&quot;7&quot;&lt;/code&gt;. In ESLint v5, comparisons from &lt;code&gt;RuleTester&lt;/code&gt; use strict equality, so an assertion like this will no longer pass.</source>
          <target state="translated">이전에 &lt;code&gt;RuleTester&lt;/code&gt; 는 일부 어설 션을 만들 때 느슨한 동등성을 사용했습니다. 예를 들어, 규칙 이 자동 수정의 결과로 문자열 &lt;code&gt;&quot;7&quot;&lt;/code&gt; 을 생성 한 경우 &lt;code&gt;RuleTester&lt;/code&gt; 는 문자열 &lt;code&gt;&quot;7&quot;&lt;/code&gt; 대신 &lt;code&gt;output&lt;/code&gt; 어설 션 에서 숫자 &lt;code&gt;7&lt;/code&gt; 을 허용합니다 . ESLint v5에서 &lt;code&gt;RuleTester&lt;/code&gt; 와의 비교는 엄격한 동등성을 사용하므로 이와 같은 주장은 더 이상 통과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f50639030ce290e0b2d963a0feb9b72be44a4b6" translate="yes" xml:space="preserve">
          <source>Previously, ESLint loaded plugins relative to the location of the ESLint package itself. As a result, we suggested that users with global ESLint installations should also install plugins globally, and users with local ESLint installations should install plugins locally. However, due to a design bug, this strategy caused ESLint to randomly fail to load plugins and shareable configs under certain circumstances, particularly when using package management tools like &lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt;&lt;code&gt;lerna&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/pnp/&quot;&gt;Yarn Plug n' Play&lt;/a&gt;.</source>
          <target state="translated">이전에는 ESLint가 ESLint 패키지 자체의 위치를 ​​기준으로 플러그인을로드했습니다. 결과적으로 글로벌 ESLint 설치 사용자는 플러그인을 전체적으로 설치하고 로컬 ESLint 설치 사용자는 플러그인을 로컬로 설치해야합니다. 그러나 디자인 버그로 인해이 전략으로 인해 특정 상황에서, 특히 &lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt; &lt;code&gt;lerna&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/pnp/&quot;&gt;Yarn Plug n 'Play&lt;/a&gt; 와 같은 패키지 관리 도구를 사용할 때 ESLint가 플러그인 및 공유 가능한 구성을 임의로로드하지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="e5a31efe99bb4ae0265c26c456f8708e8b3abad7" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would add an &lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; property to &lt;code&gt;Variable&lt;/code&gt; objects in scope analysis to indicate that a variable was introduced as a result of a &lt;code&gt;/* global */&lt;/code&gt; comment. This property was undocumented, and the ESLint team was unable to find any usage of the property outside of ESLint core. The property has been removed in ESLint v6, and replaced with the &lt;code&gt;eslintExplicitGlobalComments&lt;/code&gt; property, which can contain a list of all &lt;code&gt;/* global */&lt;/code&gt; comments if a variable was declared with more than one of them.</source>
          <target state="translated">이전에는 ESLint가 범위 분석에서 &lt;code&gt;Variable&lt;/code&gt; 객체에 &lt;code&gt;eslintExplicitGlobalComment&lt;/code&gt; 속성을 추가하여 변수가 &lt;code&gt;/* global */&lt;/code&gt; 주석 의 결과로 도입되었음을 나타냅니다 . 이 속성은 문서화되지 않았으며 ESLint 팀이 ESLint 코어 외부에서 해당 속성의 사용법을 찾지 못했습니다. 이 건물은 ESLint 버전 6에서 제거하고 대체되었습니다 &lt;code&gt;eslintExplicitGlobalComments&lt;/code&gt; 의 모든 목록을 포함 할 수 있습니다 재산, &lt;code&gt;/* global */&lt;/code&gt; 변수가 그 중 하나 이상의로 선언 된 경우 의견을.</target>
        </trans-unit>
        <trans-unit id="a1d351994dd8ff11b19e958c9018b81f03cb97ca" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would ignore these malformed directive comments. ESLint v5 will report an error when it sees a problem like this, so that the issue can be more easily corrected.</source>
          <target state="translated">이전에는 ESLint가 이러한 잘못된 지시문 주석을 무시했습니다. ESLint v5는 이와 같은 문제가 발생하면 오류를보고하므로 문제를보다 쉽게 ​​해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b010cfb49c2bd7324d04fb33de705502ddf710" translate="yes" xml:space="preserve">
          <source>Previously, ESLint would set the &lt;code&gt;parent&lt;/code&gt; property on each AST node immediately before running rule listeners for that node. This caused some confusion for rule authors, because the &lt;code&gt;parent&lt;/code&gt; property would not initially be present on any nodes, and it was sometimes necessary to complicate the structure of a rule to ensure that the &lt;code&gt;parent&lt;/code&gt; property of a given node would be available when needed.</source>
          <target state="translated">이전에는 ESLint가 해당 노드의 규칙 수신기를 실행하기 직전에 각 AST 노드 에서 &lt;code&gt;parent&lt;/code&gt; 속성을 설정했습니다 . &lt;code&gt;parent&lt;/code&gt; 속성이 처음에는 어떤 노드에도 존재하지 않았기 때문에 규칙 작성자에게 약간의 혼동이 생겼으며, 때로는 주어진 노드 의 &lt;code&gt;parent&lt;/code&gt; 속성이 필요할 때 사용할 수 있도록 규칙의 구조를 복잡하게 해야했습니다.</target>
        </trans-unit>
        <trans-unit id="2efde3c7b07c84bb2b96e4b7cf3ee1a328ba78ff" translate="yes" xml:space="preserve">
          <source>Previously, it was possible for rules to report AST nodes without providing a report message. This was not intended behavior, and as a result the default formatter would crash if a rule omitted a message. However, it was possible to avoid a crash when using a non-default formatter, such as &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="translated">이전에는 규칙이보고 메시지를 제공하지 않고 AST 노드를보고 할 수있었습니다. 이것은 의도 된 동작이 아니므로 규칙에서 메시지를 생략하면 기본 포맷터가 충돌합니다. 그러나 &lt;code&gt;json&lt;/code&gt; 과 같은 기본이 아닌 포맷터를 사용할 때 충돌을 피할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="665203081aa657ef14f3fd259bc736ff48eade7a" translate="yes" xml:space="preserve">
          <source>Previously, rule context objects had an undocumented &lt;code&gt;_linter&lt;/code&gt; property, which was used internally within ESLint to process reports from rules. Some rules used this property to achieve functionality that was not intended to be possible for rules. For example, several plugins used the &lt;code&gt;_linter&lt;/code&gt; property in a rule to monitor reports from other rules, for the purpose of checking for unused &lt;code&gt;/* eslint-disable */&lt;/code&gt; directive comments. Although this functionality was useful for users, it could also cause stability problems for projects using ESLint. For example, an upgrade to a rule in one plugin could unexpectedly cause a rule in another plugin to start reporting errors.</source>
          <target state="translated">이전에는 규칙 컨텍스트 객체에 문서화되지 않은 &lt;code&gt;_linter&lt;/code&gt; 속성이있었습니다.이 속성은 ESLint 내부에서 규칙의 보고서를 처리하는 데 사용되었습니다. 일부 규칙은 규칙에 사용할 수없는 기능을 달성하기 위해이 속성을 사용했습니다. 예를 들어, 여러 플러그인 은 규칙에서 &lt;code&gt;_linter&lt;/code&gt; 속성을 사용하여 사용되지 않은 &lt;code&gt;/* eslint-disable */&lt;/code&gt; 지시문 주석 을 확인하기 위해 다른 규칙의 보고서를 모니터링했습니다 . 이 기능은 사용자에게 유용했지만 ESLint를 사용하는 프로젝트에서 안정성 문제를 일으킬 수도 있습니다. 예를 들어, 한 플러그인에서 규칙으로 업그레이드하면 예기치 않게 다른 플러그인의 규칙으로 인해 오류보고가 시작될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad7f54686fbe669487e9816787f55d0683c5950" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;a href=&quot;../rules/comma-dangle&quot;&gt;&lt;code&gt;comma-dangle&lt;/code&gt;&lt;/a&gt; rule would ignore trailing function arguments and parameters, unless explicitly configured to check for function commas. In ESLint v6, function commas are treated the same way as other types of trailing commas.</source>
          <target state="translated">이전에는 함수 쉼표를 확인하도록 명시 적으로 구성되지 않은 경우 &lt;a href=&quot;../rules/comma-dangle&quot;&gt; &lt;code&gt;comma-dangle&lt;/code&gt; &lt;/a&gt; 규칙은 후미 함수 인수 및 매개 변수를 무시합니다. ESLint v6에서 함수 쉼표는 다른 유형의 후행 쉼표와 동일한 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bb4d9004d86d873bce13da59ea0da1efcb652b6e" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;a href=&quot;../rules/indent&quot;&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/a&gt; rule was fairly lenient about checking indentation; there were many code patterns where indentation was not validated by the rule. This caused confusion for users, because they were accidentally writing code with incorrect indentation, and they expected ESLint to catch the issues.</source>
          <target state="translated">이전에는 &lt;a href=&quot;../rules/indent&quot;&gt; &lt;code&gt;indent&lt;/code&gt; &lt;/a&gt; 규칙이 들여 쓰기 확인에 상당히 관대했습니다. 규칙에 의해 들여 쓰기가 검증되지 않은 많은 코드 패턴이있었습니다. 실수로 들여 쓰기가 잘못된 코드를 작성했기 때문에 혼동을 일으켜 ESLint가 문제를 포착 할 것으로 예상했습니다.</target>
        </trans-unit>
        <trans-unit id="cac4dad357054ea6ee0c7634c9a4e7c59614fbef" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;code&gt;context.getScope()&lt;/code&gt; method changed its behavior based on the &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; property. However, this could cause confusing behavior when using a parser that doesn't respond to the &lt;code&gt;ecmaVersion&lt;/code&gt; option, such as &lt;code&gt;babel-eslint&lt;/code&gt;.</source>
          <target state="translated">이전에는 &lt;code&gt;context.getScope()&lt;/code&gt; 메서드가 &lt;code&gt;parserOptions.ecmaVersion&lt;/code&gt; 속성을 기반으로 동작을 변경했습니다 . 그러나 &lt;code&gt;babel-eslint&lt;/code&gt; 와 같이 &lt;code&gt;ecmaVersion&lt;/code&gt; 옵션에 응답하지 않는 구문 분석기를 사용할 때 혼란스러운 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40450d3f81bf0c288fef5278f775f18d1a6902ca" translate="yes" xml:space="preserve">
          <source>Previously, the &lt;code&gt;linter.verify()&lt;/code&gt; API accepted a &lt;code&gt;global&lt;/code&gt; config option, which was a synonym for the documented &lt;code&gt;globals&lt;/code&gt; property. The &lt;code&gt;global&lt;/code&gt; option was never documented or officially supported, and did not work in config files. It has been removed in 4.0.</source>
          <target state="translated">이전에 &lt;code&gt;linter.verify()&lt;/code&gt; API 는 문서화 된 &lt;code&gt;globals&lt;/code&gt; 특성과 동의어 인 &lt;code&gt;global&lt;/code&gt; 구성 옵션을 승인했습니다 . &lt;code&gt;global&lt;/code&gt; 옵션은 문서화하거나 공식적으로 지원하고, 설정 파일에 작동하지 않았다. 4.0에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="759b8740ec08f1087d9d1461adf3e37a3bf5b531" translate="yes" xml:space="preserve">
          <source>Previously, when configuring a set of global variables with an object, it was possible to use anything as the values of the object. An unknown value would be treated the same as &lt;code&gt;&quot;writable&quot;&lt;/code&gt;.</source>
          <target state="translated">이전에는 객체로 전역 변수 세트를 구성 할 때 객체의 값으로 무엇이든 사용할 수있었습니다. 알 수없는 값은 &lt;code&gt;&quot;writable&quot;&lt;/code&gt; 과 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b32ac883bfc23aab343c6372688bec1c7d6449" translate="yes" xml:space="preserve">
          <source>Previously, when linting code with a parser that had not been previously defined, the &lt;code&gt;Linter&lt;/code&gt; API would attempt to load the parser from the filesystem. However, this behavior was confusing because &lt;code&gt;Linter&lt;/code&gt; never access the filesystem in any other cases, and it was difficult to ensure that the correct parser would be found when loading the parser from the filesystem.</source>
          <target state="translated">이전에 정의되지 않은 파서와 코드를 linting 때 이전의 &lt;code&gt;Linter&lt;/code&gt; API는 파일 시스템에서 파서를로드하려고합니다. 그러나 &lt;code&gt;Linter&lt;/code&gt; 가 다른 경우에는 파일 시스템에 액세스하지 않기 때문에이 동작이 혼란 스러웠 으며 파일 시스템에서 구문 분석기를로드 할 때 올바른 구문 분석기를 찾을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="8a3ba3b815ccf0fde610368afb8b3a032a9740a4" translate="yes" xml:space="preserve">
          <source>Previously, when parsing JS code like &lt;code&gt;const foo = {...data}&lt;/code&gt; with the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option enabled, the default parser would generate an &lt;code&gt;ExperimentalSpreadProperty&lt;/code&gt; node type for the &lt;code&gt;...data&lt;/code&gt; spread element.</source>
          <target state="translated">이전 에는 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션이 활성화 된 &lt;code&gt;const foo = {...data}&lt;/code&gt; 와 같은 JS 코드를 구문 분석 할 때 기본 구문 분석기는 &lt;code&gt;...data&lt;/code&gt; spread 요소에 대한 &lt;code&gt;ExperimentalSpreadProperty&lt;/code&gt; 노드 유형을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="3572fe8f9bf308c3f1c32a5c5c8ecf7ade2e2992" translate="yes" xml:space="preserve">
          <source>Previously, when parsing JS code like &lt;code&gt;const {foo, ...rest} = data&lt;/code&gt; with the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option enabled, the default parser would generate an &lt;code&gt;ExperimentalRestProperty&lt;/code&gt; node type for the &lt;code&gt;...data&lt;/code&gt; rest element.</source>
          <target state="translated">이전 에는 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션이 활성화 된 &lt;code&gt;const {foo, ...rest} = data&lt;/code&gt; 와 같은 JS 코드를 구문 분석 할 때 기본 구문 분석기는 &lt;code&gt;...data&lt;/code&gt; rest 요소에 대한 &lt;code&gt;ExperimentalRestProperty&lt;/code&gt; 노드 유형을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="ac97c7d1bc4493830e4f2c35fbc7b98e9d1581e8" translate="yes" xml:space="preserve">
          <source>Previously, when using the default parser it was possible to use the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option to enable support for &lt;a href=&quot;https://developers.google.com/web/updates/2017/06/object-rest-spread&quot;&gt;rest/spread properties&lt;/a&gt;, as follows:</source>
          <target state="translated">이전에는 기본 파서를 사용할 때 다음과 같이 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;https://developers.google.com/web/updates/2017/06/object-rest-spread&quot;&gt;rest / spread 속성을&lt;/a&gt; 지원할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="393a7447e4d30c62abea4ddc9f0d3dfc3e208e74" translate="yes" xml:space="preserve">
          <source>Previously, when using the default parser, a config could use the &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; option to enable parsing support for object rest/spread properties:</source>
          <target state="translated">이전에는 기본 구문 분석기를 사용할 때 구성에서 &lt;code&gt;experimentalObjectRestSpread&lt;/code&gt; 옵션을 사용하여 오브젝트 휴지 / 스프레드 특성에 대한 구문 분석 지원을 사용할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1fec0a04a3eab043ee811142120d57785cfef0" translate="yes" xml:space="preserve">
          <source>Primitive Literals</source>
          <target state="translated">원시 리터럴</target>
        </trans-unit>
        <trans-unit id="8c8f400f7e3e42d398c134471b34479ab1e3ff12" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, if a directory contained both an &lt;code&gt;.eslintrc&lt;/code&gt; file and a &lt;code&gt;package.json&lt;/code&gt; file with ESLint configuration information, the settings from the two files would be merged together. In 2.0.0, only the settings from the &lt;code&gt;.eslintrc.*&lt;/code&gt; file are used and the ones in &lt;code&gt;package.json&lt;/code&gt; are ignored when both are present. Otherwise, &lt;code&gt;package.json&lt;/code&gt; can still be used with ESLint configuration, but only if no other &lt;code&gt;.eslintrc.*&lt;/code&gt; files are present.</source>
          <target state="translated">2.0.0 이전에는 디렉토리 에 ESLint 구성 정보가 있는 &lt;code&gt;.eslintrc&lt;/code&gt; 파일과 &lt;code&gt;package.json&lt;/code&gt; 파일이 모두 포함 된 경우 두 파일의 설정이 병합됩니다. 2.0.0에서는 &lt;code&gt;.eslintrc.*&lt;/code&gt; 파일 의 설정 만 사용되며 &lt;code&gt;package.json&lt;/code&gt; 의 설정 은 모두 무시됩니다. 그렇지 않으면 &lt;code&gt;package.json&lt;/code&gt; 을 ESLint 구성과 함께 사용할 수 있지만 다른 &lt;code&gt;.eslintrc.*&lt;/code&gt; 파일이 없는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacbbe4722ec9b78f85bdddd7ed97a705ae7d9fe" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, new global variables that were standardized as part of ES6 such as &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, and &lt;code&gt;Symbol&lt;/code&gt; were included in the built-in global environment. This could lead to potential issues when, for example, &lt;code&gt;no-undef&lt;/code&gt; permitted use of the &lt;code&gt;Promise&lt;/code&gt; constructor even in ES5 code where promises are unavailable. In 2.0.0, the built-in environment only includes the standard ES5 global variables, and the new ES6 global variables have been moved to the &lt;code&gt;es6&lt;/code&gt; environment.</source>
          <target state="translated">2.0.0 이전에는 &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Symbol&lt;/code&gt; 과 같은 ES6의 일부로 표준화 된 새로운 전역 변수가 내장 전역 환경에 포함되었습니다. 예를 들어 약속을 사용할 수없는 ES5 코드에서도 &lt;code&gt;Promise&lt;/code&gt; 생성자를 &lt;code&gt;no-undef&lt;/code&gt; 허용하는 경우 잠재적 인 문제가 발생할 수 있습니다. 2.0.0에서 내장 환경에는 표준 ES5 전역 변수 만 포함되며 새 ES6 전역 변수가 &lt;code&gt;es6&lt;/code&gt; 환경 으로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ea53a76cd88b434dcfaff09ec72ada7ae7831a08" translate="yes" xml:space="preserve">
          <source>Prior to 2.0.0, the way to enable language options was by using &lt;code&gt;ecmaFeatures&lt;/code&gt; in your configuration. In 2.0.0:</source>
          <target state="translated">2.0.0 이전에는 언어 옵션을 활성화하는 방법은 구성에서 &lt;code&gt;ecmaFeatures&lt;/code&gt; 를 사용하는 것이 었 습니다. 2.0.0에서 :</target>
        </trans-unit>
        <trans-unit id="6b9f0362f6ea97fabedbee28f3e42f7c63d479c2" translate="yes" xml:space="preserve">
          <source>Prior to 4.0, ESLint required parsers to implement comment attachment, a process where AST nodes would gain additional properties corresponding to their leading and trailing comments in the source file. This made it difficult for users to develop custom parsers, because they would have to replicate the confusing comment attachment semantics required by ESLint.</source>
          <target state="translated">4.0 이전에 ESLint는 구문 분석기가 주석 첨부 파일을 구현해야했습니다.이 프로세스는 AST 노드가 소스 파일에서 선행 및 후행 주석에 해당하는 추가 특성을 얻는 프로세스입니다. 따라서 ESLint에 필요한 혼란스러운 주석 첨부 파일 의미 체계를 복제해야하므로 사용자가 사용자 정의 파서를 개발하기가 어려웠습니다.</target>
        </trans-unit>
        <trans-unit id="5e3d392b20fe6d9664c81b4a65c6b601daf8e9bf" translate="yes" xml:space="preserve">
          <source>Prior to 4.0, shebang comments in a source file would not appear in the output of &lt;code&gt;sourceCode.getAllComments()&lt;/code&gt; or &lt;code&gt;sourceCode.getComments()&lt;/code&gt;, but they would appear in the output of &lt;code&gt;sourceCode.getTokenOrCommentBefore&lt;/code&gt; as line comments. This inconsistency led to some confusion for rule developers.</source>
          <target state="translated">4.0 이전에는 소스 파일의 shebang 주석이 &lt;code&gt;sourceCode.getAllComments()&lt;/code&gt; 또는 &lt;code&gt;sourceCode.getComments()&lt;/code&gt; 의 출력에 나타나지 않지만 &lt;code&gt;sourceCode.getTokenOrCommentBefore&lt;/code&gt; 의 출력에는 행 주석으로 표시됩니다. 이러한 불일치로 인해 규칙 개발자에게는 약간의 혼란이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b3be15561d5151f64c56456dc30fa7cef13a71e7" translate="yes" xml:space="preserve">
          <source>Prior to v0.16.0 this rule also enforced that there was only a single line at the end of the file. If you still want this behavior, consider enabling &lt;a href=&quot;no-multiple-empty-lines&quot;&gt;no-multiple-empty-lines&lt;/a&gt; with &lt;code&gt;maxEOF&lt;/code&gt; and/or &lt;a href=&quot;no-trailing-spaces&quot;&gt;no-trailing-spaces&lt;/a&gt;.</source>
          <target state="translated">v0.16.0 이전에는이 ​​규칙이 파일 끝에 한 줄만 존재하도록했습니다. 이 동작을 계속 원하면 &lt;code&gt;maxEOF&lt;/code&gt; 및 / 또는 &lt;a href=&quot;no-trailing-spaces&quot;&gt;후행 공백없이 &lt;/a&gt;&lt;a href=&quot;no-multiple-empty-lines&quot;&gt;여러 개의 빈 줄을&lt;/a&gt; 사용 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af52f1493bafbe39bd3dae2bc861bf916727dd6e" translate="yes" xml:space="preserve">
          <source>Prior to v2.0.0, plugins could specify a &lt;code&gt;rulesConfig&lt;/code&gt; for the plugin. The &lt;code&gt;rulesConfig&lt;/code&gt; would automatically be applied whenever someone uses the plugin, which is the opposite of what ESLint does in every other situation (where nothing is on by default). To bring plugins behavior in line, we have removed support for &lt;code&gt;rulesConfig&lt;/code&gt; in plugins.</source>
          <target state="translated">&lt;code&gt;rulesConfig&lt;/code&gt; 이전에는 플러그인이 플러그인에 대해 rulesConfig 를 지정할 수있었습니다 . &lt;code&gt;rulesConfig&lt;/code&gt; 는 사람이 ESLint은 (아무것도 기본적으로 없음) 다른 모든 상황에서 무엇의 반대 플러그인을 사용할 때마다 자동으로 적용됩니다. 플러그인 작동을 위해 플러그인에서 &lt;code&gt;rulesConfig&lt;/code&gt; 에 대한 지원을 제거 했습니다.</target>
        </trans-unit>
        <trans-unit id="692a54c10f74d805a38453bd22bb1d25068c3ba0" translate="yes" xml:space="preserve">
          <source>Processors in Plugins</source>
          <target state="translated">플러그인의 프로세서</target>
        </trans-unit>
        <trans-unit id="ee555673e8664c98d4ada2d762c610f965ba2a31" translate="yes" xml:space="preserve">
          <source>Processors may make named code blocks such as &lt;code&gt;0.js&lt;/code&gt; and &lt;code&gt;1.js&lt;/code&gt;. ESLint handles such a named code block as a child file of the original file. You can specify additional configurations for named code blocks in the &lt;code&gt;overrides&lt;/code&gt; section of the config. For example, the following disables &lt;code&gt;strict&lt;/code&gt; rule for the named code blocks which end with &lt;code&gt;.js&lt;/code&gt; in markdown files.</source>
          <target state="translated">프로세서는 &lt;code&gt;0.js&lt;/code&gt; 및 &lt;code&gt;1.js&lt;/code&gt; 와 같은 명명 된 코드 블록을 만들 수 있습니다 . ESLint는 이러한 명명 된 코드 블록을 원본 파일의 하위 파일로 처리합니다. 구성의 &lt;code&gt;overrides&lt;/code&gt; 섹션 에서 명명 된 코드 블록에 대한 추가 구성을 지정할 수 있습니다 . 예를 들어, 다음은 마크 다운 파일에서 &lt;code&gt;.js&lt;/code&gt; 로 끝나는 명명 된 코드 블록에 대해 &lt;code&gt;strict&lt;/code&gt; 규칙을 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="f32c5098fb499f12ad76958c7a61d5b8091f9763" translate="yes" xml:space="preserve">
          <source>Program is expressed with several code paths. A code path is expressed with objects of two kinds: &lt;code&gt;CodePath&lt;/code&gt; and &lt;code&gt;CodePathSegment&lt;/code&gt;.</source>
          <target state="translated">프로그램은 여러 코드 경로로 표현됩니다. 코드 경로는 &lt;code&gt;CodePath&lt;/code&gt; 및 &lt;code&gt;CodePathSegment&lt;/code&gt; 의 두 가지 개체로 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="42fa885d13da97a910ec7164bf19b94acb08d0f0" translate="yes" xml:space="preserve">
          <source>Programming language style guides are important for the long-term maintainability of software. This guide is based on the &lt;a href=&quot;https://java.sun.com/docs/codeconv/&quot;&gt;Code Conventions for the Java Programming Language&lt;/a&gt; and &lt;a href=&quot;http://javascript.crockford.com/code.html&quot;&gt;Douglas Crockford's Code Conventions for the JavaScript Programming Language&lt;/a&gt;. Modifications have been made due to my personal experience and preferences.</source>
          <target state="translated">프로그래밍 언어 스타일 가이드는 소프트웨어의 장기적인 유지 관리에 중요합니다. 이 안내서는 &lt;a href=&quot;https://java.sun.com/docs/codeconv/&quot;&gt;Java 프로그래밍 언어&lt;/a&gt; 에 대한 코드 규약 및 &lt;a href=&quot;http://javascript.crockford.com/code.html&quot;&gt;JavaScript 프로그래밍 언어에 대한 Douglas Crockford의 코드 규약을&lt;/a&gt; 기반으로합니다 . 개인적인 경험과 선호로 인해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="43f3ace69f2fe7131543d9052cb08b303ff904e4" translate="yes" xml:space="preserve">
          <source>Project-level configuration:</source>
          <target state="translated">프로젝트 레벨 구성 :</target>
        </trans-unit>
        <trans-unit id="33fb62ee4504c98b469fcbf6c4712f39685712fe" translate="yes" xml:space="preserve">
          <source>Property descriptors in &lt;code&gt;Object.create&lt;/code&gt;, &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and &lt;code&gt;Reflect.defineProperty&lt;/code&gt; methods of the global objects.</source>
          <target state="translated">전역 객체의 &lt;code&gt;Object.create&lt;/code&gt; , &lt;code&gt;Object.defineProperty&lt;/code&gt; , &lt;code&gt;Object.defineProperties&lt;/code&gt; 및 &lt;code&gt;Reflect.defineProperty&lt;/code&gt; 메서드의 속성 설명자</target>
        </trans-unit>
        <trans-unit id="b5e66a1596415565d4a94aaddcf8bb5751542451" translate="yes" xml:space="preserve">
          <source>Proponents of Yoda conditions highlight that it is impossible to mistakenly use &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available.</source>
          <target state="translated">Yoda 조건의 지지자들은 리터럴 값을 할당 할 수 없기 때문에 &lt;code&gt;==&lt;/code&gt; 대신 실수로 &lt;code&gt;=&lt;/code&gt; 를 사용할 수 없음을 강조합니다 . 그렇게하면 구문 오류가 발생하고 실수를 미리 알려줍니다. 따라서이 방법은 도구를 아직 사용할 수없는 초기 프로그래밍에서 매우 일반적이었습니다.</target>
        </trans-unit>
        <trans-unit id="d36f5aee868ae6db86c6284531cdd8f72d77db1c" translate="yes" xml:space="preserve">
          <source>Proposing a &lt;a href=&quot;new-rules&quot;&gt;New Rule&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;new-rules&quot;&gt;새로운 규칙&lt;/a&gt; 제안</target>
        </trans-unit>
        <trans-unit id="ecaeee3736f17c6a22f424961f98b463abcd212d" translate="yes" xml:space="preserve">
          <source>Proposing a &lt;a href=&quot;rule-changes&quot;&gt;Rule Change&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rule-changes&quot;&gt;규칙 변경&lt;/a&gt; 제안</target>
        </trans-unit>
        <trans-unit id="8fde9b438a1e10afec4812ddd08e7722642dc36e" translate="yes" xml:space="preserve">
          <source>Proposing a Rule</source>
          <target state="translated">규칙 제안</target>
        </trans-unit>
        <trans-unit id="341849141f80cca77602012c6f342ce4742319fd" translate="yes" xml:space="preserve">
          <source>Proposing a Rule Change</source>
          <target state="translated">규칙 변경 제안</target>
        </trans-unit>
        <trans-unit id="86ee7e213745f3cf674455c23534700070da7b53" translate="yes" xml:space="preserve">
          <source>Provide as many unit tests as possible. Your pull request will never be turned down for having too many tests submitted with it!</source>
          <target state="translated">가능한 많은 단위 테스트를 제공하십시오. 너무 많은 테스트를 제출하여 풀 요청이 거절되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="4ffdc87852320c6294c2b02843d1425e91d10cfc" translate="yes" xml:space="preserve">
          <source>Providing Suggestions</source>
          <target state="translated">제안하기</target>
        </trans-unit>
        <trans-unit id="5591bbc620225df439fe2bdef9369c8238d4af8c" translate="yes" xml:space="preserve">
          <source>Publishing a Shareable Config</source>
          <target state="translated">공유 가능한 구성 게시</target>
        </trans-unit>
        <trans-unit id="30ab8d084e2209d47a1dc198c8de1e251f390a94" translate="yes" xml:space="preserve">
          <source>Pull Requests</source>
          <target state="translated">Pull Requests</target>
        </trans-unit>
        <trans-unit id="8317963e9e1ff1e717106bf4888341b278d74c92" translate="yes" xml:space="preserve">
          <source>Push your changes</source>
          <target state="translated">당신의 변화를 밀어</target>
        </trans-unit>
        <trans-unit id="8c720088282bb804281d4141100281d68e2719bb" translate="yes" xml:space="preserve">
          <source>Putting default parameter at last allows function calls to omit optional tail arguments.</source>
          <target state="translated">기본 매개 변수를 마지막에두면 함수 호출로 선택적 꼬리 인수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="289df8885d703027d487fef77d56fc52e316d891" translate="yes" xml:space="preserve">
          <source>Rather than creating separate rules for every language feature you want to turn off, this rule allows you to configure the syntax elements you want to restrict use of. These elements are represented by their &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; node types. For example, a function declaration is represented by &lt;code&gt;FunctionDeclaration&lt;/code&gt; and the &lt;code&gt;with&lt;/code&gt; statement is represented by &lt;code&gt;WithStatement&lt;/code&gt;. You may find the full list of AST node names you can use &lt;a href=&quot;https://github.com/eslint/espree/blob/master/lib/ast-node-types.js&quot;&gt;on GitHub&lt;/a&gt; and use &lt;a href=&quot;https://astexplorer.net/&quot;&gt;AST Explorer&lt;/a&gt; with the espree parser to see what type of nodes your code consists of.</source>
          <target state="translated">사용하지 않으려는 모든 언어 기능에 대해 별도의 규칙을 작성하는 대신이 규칙을 사용하여 사용을 제한하려는 구문 요소를 구성 할 수 있습니다. 이 요소는 &lt;a href=&quot;https://github.com/estree/estree&quot;&gt;ESTree&lt;/a&gt; 노드 유형으로 표시됩니다 . 예를 들어, 함수 선언에 의해 표현된다 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 과 &lt;code&gt;with&lt;/code&gt; 문에 의해 표현된다 &lt;code&gt;WithStatement&lt;/code&gt; . &lt;a href=&quot;https://github.com/eslint/espree/blob/master/lib/ast-node-types.js&quot;&gt;GitHub&lt;/a&gt; 에서 사용할 수있는 AST 노드 이름의 전체 목록을 찾고 espree 파서와 함께 &lt;a href=&quot;https://astexplorer.net/&quot;&gt;AST Explorer&lt;/a&gt; 를 사용 하여 코드가 어떤 유형의 노드로 구성되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="8bf3ca1af55a4ac765bcc067d56c1abf4201ae04" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://js.foundation/community/code-of-conduct&quot;&gt;Code of Conduct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://js.foundation/community/code-of-conduct&quot;&gt;행동 강령&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="3c28870b2e40bf75ddc825d7f6ccf7aef23e7e4b" translate="yes" xml:space="preserve">
          <source>Read-only global variables</source>
          <target state="translated">읽기 전용 전역 변수</target>
        </trans-unit>
        <trans-unit id="f7f699bcbeea4f59d35cf84d686c1fe9d26c6cd2" translate="yes" xml:space="preserve">
          <source>Reading configuration information from config files (including &lt;code&gt;.eslintrc&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;)</source>
          <target state="translated">구성 파일에서 구성 정보 읽기 ( &lt;code&gt;.eslintrc&lt;/code&gt; 및 &lt;code&gt;package.json&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="c503dd1f9c9f723f78d9b1e948ede74c06ed1112" translate="yes" xml:space="preserve">
          <source>Reading from the file system</source>
          <target state="translated">파일 시스템에서 읽기</target>
        </trans-unit>
        <trans-unit id="256ac291cd34fa721dc7063e9c7a456d831fad1e" translate="yes" xml:space="preserve">
          <source>Rebase onto upstream</source>
          <target state="translated">업스트림으로 리베이스</target>
        </trans-unit>
        <trans-unit id="3636419e1cfae4b85f914484288a2e7b2429d45d" translate="yes" xml:space="preserve">
          <source>Rebasing</source>
          <target state="translated">Rebasing</target>
        </trans-unit>
        <trans-unit id="15bc3424085a46a8b413590042e27673eda36b4b" translate="yes" xml:space="preserve">
          <source>Recommended keywords:</source>
          <target state="translated">추천 키워드 :</target>
        </trans-unit>
        <trans-unit id="8532988ca58a814f1543477fc268a1acefe668d0" translate="yes" xml:space="preserve">
          <source>Redeclarations of read-only global variables and assignments to read-only global variables.</source>
          <target state="translated">읽기 전용 전역 변수의 재 선언 및 읽기 전용 전역 변수에 대한 할당.</target>
        </trans-unit>
        <trans-unit id="4462d29bec3d07aaf9a71ae4d7273bee7d450028" translate="yes" xml:space="preserve">
          <source>Reference Information</source>
          <target state="translated">참조 정보</target>
        </trans-unit>
        <trans-unit id="df9e76446650cac75008b6bf87079e749a453bdb" translate="yes" xml:space="preserve">
          <source>Reference interface</source>
          <target state="translated">참조 인터페이스</target>
        </trans-unit>
        <trans-unit id="53c2a1c2bb6e1d4d8148660156aec1a0a17d24a8" translate="yes" xml:space="preserve">
          <source>ReferenceError: assignment to undeclared variable</source>
          <target state="translated">ReferenceError : 선언되지 않은 변수에 대입</target>
        </trans-unit>
        <trans-unit id="eb264a799738b600bd47d5135f4fc05dfcd5b1d5" translate="yes" xml:space="preserve">
          <source>References to scoped plugins in config files are now required to include the scope</source>
          <target state="translated">구성 파일에서 범위가 지정된 플러그인에 대한 참조는 이제 범위를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4409d5bd36638733bfa9227649affbe8de8da69" translate="yes" xml:space="preserve">
          <source>Reflect.apply</source>
          <target state="translated">Reflect.apply</target>
        </trans-unit>
        <trans-unit id="f2f9fd068e4242fbb4c065fab823928d6658dcc6" translate="yes" xml:space="preserve">
          <source>Reflect.defineProperty</source>
          <target state="translated">Reflect.defineProperty</target>
        </trans-unit>
        <trans-unit id="d9c40e72ed42277e621938140990fecec31860d2" translate="yes" xml:space="preserve">
          <source>Reflect.deleteProperty</source>
          <target state="translated">Reflect.deleteProperty</target>
        </trans-unit>
        <trans-unit id="dca299dec7c4b27406c99a9db8613312969fc8ef" translate="yes" xml:space="preserve">
          <source>Reflect.getOwnPropertyDescriptor</source>
          <target state="translated">Reflect.getOwnPropertyDescriptor</target>
        </trans-unit>
        <trans-unit id="9e55b43471522e73de67aec1ebffc5cdb9fa1436" translate="yes" xml:space="preserve">
          <source>Reflect.getOwnPropertyNames</source>
          <target state="translated">Reflect.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="c4ccc5cd40402aca6f2327273b607a16273c4cf3" translate="yes" xml:space="preserve">
          <source>Reflect.getPrototypeOf</source>
          <target state="translated">Reflect.getPrototypeOf</target>
        </trans-unit>
        <trans-unit id="67b946573d9e6181078c2c26d4ca78a319f779cb" translate="yes" xml:space="preserve">
          <source>Reflect.isExtensible</source>
          <target state="translated">Reflect.isExtensible</target>
        </trans-unit>
        <trans-unit id="9578443035eb8705bd126e9acab6f34b58453535" translate="yes" xml:space="preserve">
          <source>Reflect.preventExtensions</source>
          <target state="translated">Reflect.preventExtensions</target>
        </trans-unit>
        <trans-unit id="a5a0796157a708b39407cdcc3b1149e74aa1ba55" translate="yes" xml:space="preserve">
          <source>Reflect.setPrototypeOf</source>
          <target state="translated">Reflect.setPrototypeOf</target>
        </trans-unit>
        <trans-unit id="5a1a35c83df714211f74bb546dc5facc26363344" translate="yes" xml:space="preserve">
          <source>RegExp &lt;code&gt;u&lt;/code&gt; flag has two effects:</source>
          <target state="translated">RegExp &lt;code&gt;u&lt;/code&gt; 플래그에는 두 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc019f867ae1e63caad1e171c9ac68f393022fd6" translate="yes" xml:space="preserve">
          <source>RegExp literals such as &lt;code&gt;(/abc/).test(var)&lt;/code&gt; to avoid conflicts with the &lt;a href=&quot;wrap-regex&quot;&gt;wrap-regex&lt;/a&gt; rule</source>
          <target state="translated">&lt;a href=&quot;wrap-regex&quot;&gt;wrap-regex&lt;/a&gt; 규칙 과의 충돌을 피하기 위해 &lt;code&gt;(/abc/).test(var)&lt;/code&gt; 와 같은 RegExp 리터럴</target>
        </trans-unit>
        <trans-unit id="7114653a737d7346ec01e388401a05144edff375" translate="yes" xml:space="preserve">
          <source>Regular expression literals, e.g., &lt;code&gt;/abc/u&lt;/code&gt;.</source>
          <target state="translated">정규 표현식 리터럴, 예를 들어, &lt;code&gt;/abc/u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ccd845025a375ba8f53989cf7554162e8cbfee" translate="yes" xml:space="preserve">
          <source>Regular expressions can be very complex and difficult to understand, which is why it's important to keep them as simple as possible in order to avoid mistakes. One of the more error-prone things you can do with a regular expression is to use more than one space, such as:</source>
          <target state="translated">정규 표현식은 매우 복잡하고 이해하기 어려울 수 있으므로 실수를 피하기 위해 가능한 한 단순하게 유지하는 것이 중요합니다. 정규식으로 수행 할 수있는 오류가 발생하기 쉬운 작업 중 하나는 다음과 같이 둘 이상의 공백을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73df01ef95fe676ecd6771adb485003ded6e2733" translate="yes" xml:space="preserve">
          <source>Related Rules</source>
          <target state="translated">관련 규칙</target>
        </trans-unit>
        <trans-unit id="33749d1fd374471a64ca2130b8acf29edc1c7f83" translate="yes" xml:space="preserve">
          <source>Related rules</source>
          <target state="translated">관련 규칙</target>
        </trans-unit>
        <trans-unit id="c8ca31e64125f97916f5430dc1a846a8fb66cb93" translate="yes" xml:space="preserve">
          <source>Relational Operators: &lt;code&gt;&quot;in&quot;&lt;/code&gt;, &lt;code&gt;&quot;instanceof&quot;&lt;/code&gt;</source>
          <target state="translated">관계 연산자 : &lt;code&gt;&quot;in&quot;&lt;/code&gt; , &lt;code&gt;&quot;instanceof&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4f647ac04e2d41dbb5b8e09ff6b1cdb35b950d" translate="yes" xml:space="preserve">
          <source>Relative glob patterns</source>
          <target state="translated">상대 글로브 패턴</target>
        </trans-unit>
        <trans-unit id="e67d73e5c8870b0aee2e6a5b9e1177d2a9866243" translate="yes" xml:space="preserve">
          <source>Remember that ESLint is completely pluggable, which means you can create your own rules and distribute them using plugins. We did this on purpose because we don't want to be the gatekeepers for all possible rules. Even if we don't accept a rule into the core, that doesn't mean you can't have the exact rule that you want. See the &lt;a href=&quot;../working-with-rules&quot;&gt;working with rules&lt;/a&gt; and &lt;a href=&quot;../working-with-plugins&quot;&gt;working with plugins&lt;/a&gt; documentation for more information.</source>
          <target state="translated">ESLint는 완전히 플러그 가능하므로 자신 만의 규칙을 만들고 플러그인을 사용하여 배포 할 수 있습니다. 가능한 모든 규칙의 게이트 키퍼가되기를 원하지 않기 때문에 의도적으로 수행했습니다. 핵심 규칙을 수락하지 않더라도 원하는 정확한 규칙을 가질 수는 없습니다. 참고 항목 &lt;a href=&quot;../working-with-rules&quot;&gt;규칙 작업&lt;/a&gt; 및 &lt;a href=&quot;../working-with-plugins&quot;&gt;플러그인 작업&lt;/a&gt; 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="960f6a4b27df973ccb71be9fd4f6a93b7639f03e" translate="yes" xml:space="preserve">
          <source>Remove the severity from the schema</source>
          <target state="translated">스키마에서 심각도 제거</target>
        </trans-unit>
        <trans-unit id="b5e77c5c02a90c01b16fea8f21a1083425ebe0e0" translate="yes" xml:space="preserve">
          <source>Removed</source>
          <target state="translated">Removed</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
