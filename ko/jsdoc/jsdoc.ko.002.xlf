<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="jsdoc">
    <body>
      <group id="jsdoc">
        <trans-unit id="48f6d87a2e23c4f8e1183903287718e90f22f84f" translate="yes" xml:space="preserve">
          <source>Variable number of that type</source>
          <target state="translated">해당 유형의 변수 번호</target>
        </trans-unit>
        <trans-unit id="2a2f99b3009842dc4c58122072b074442d3291bd" translate="yes" xml:space="preserve">
          <source>Variations help JSDoc distinguish between different symbols with the same longname. For example, if &quot;@variation 2&quot; is added to the JSDoc comment for the Widget class, &quot;{@link Widget(2)}&quot; will refer to the class, and &quot;{@link Widget}&quot; will refer to the namespace. Alternatively, you can include the variation when you specify the symbol's with tags such as &lt;a href=&quot;tags-alias&quot;&gt;@alias&lt;/a&gt; or &lt;a href=&quot;tags-name&quot;&gt;@name&lt;/a&gt; (for example, &quot;@alias Widget(2)&quot;).</source>
          <target state="translated">변형은 JSDoc이 동일한 긴 이름을 가진 다른 기호를 구별하는 데 도움이됩니다. 예를 들어 위젯 클래스의 JSDoc 주석에 &quot;@variation 2&quot;가 추가되면 &quot;{@link Widget (2)}&quot;은 클래스를 참조하고 &quot;{@link Widget}&quot;은 네임 스페이스를 참조합니다. 또는 &lt;a href=&quot;tags-alias&quot;&gt;@alias&lt;/a&gt; 또는 &lt;a href=&quot;tags-name&quot;&gt;@name&lt;/a&gt; 과 같은 태그로 기호를 지정할 때 변형을 포함 할 수 있습니다 (예 : &quot;@alias Widget (2)&quot;).</target>
        </trans-unit>
        <trans-unit id="e9abd46bd86fe3e68832400780f387ce49aba547" translate="yes" xml:space="preserve">
          <source>Virtual comment with @async tag</source>
          <target state="translated">@async 태그가 포함 된 가상 댓글</target>
        </trans-unit>
        <trans-unit id="aaf5f140bde3e7f177338302fcb3bbf0db15ae6b" translate="yes" xml:space="preserve">
          <source>Virtual comment with @generator tag</source>
          <target state="translated">@generator 태그가 포함 된 가상 댓글</target>
        </trans-unit>
        <trans-unit id="c4be2d52e1ed137ba3b43a0ce08d5f6393e9f9b0" translate="yes" xml:space="preserve">
          <source>Virtual comments that define an interface</source>
          <target state="translated">인터페이스를 정의하는 가상 주석</target>
        </trans-unit>
        <trans-unit id="062be3a9f97dfdc102013d35e9da2f6714aa293b" translate="yes" xml:space="preserve">
          <source>What does the 'this' keyword refer to here?</source>
          <target state="translated">여기서 'this'키워드는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="c3d502bf8c4cd478197cdaf0359423282e9dbaf8" translate="yes" xml:space="preserve">
          <source>What kind of symbol is this?</source>
          <target state="translated">이것은 어떤 종류의 상징입니까?</target>
        </trans-unit>
        <trans-unit id="d40a80b30ac9436f169ac3c9df59f7f174233909" translate="yes" xml:space="preserve">
          <source>When a module adds a property to its &lt;code&gt;this&lt;/code&gt; object, JSDoc 3 automatically recognizes that the new property is exported by the module:</source>
          <target state="translated">모듈 &lt;code&gt;this&lt;/code&gt; 객체에 속성을 추가하면 JSDoc 3은 모듈이 새 속성을 내보냈 음을 자동으로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d7538011f3eb84f3ebadd1bef02eaa96417b4b3b" translate="yes" xml:space="preserve">
          <source>When an exported symbol is defined as a member of &lt;code&gt;module.exports&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, or &lt;code&gt;this&lt;/code&gt;, JSDoc infers that the symbol is a static member of the module.</source>
          <target state="translated">내 보낸 심볼이 &lt;code&gt;module.exports&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;this&lt;/code&gt; 의 멤버로 정의 되면 JSDoc은 해당 심볼이 모듈의 정적 멤버임을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="389576799c3ba6ff6002378425542dcd27a5013c" translate="yes" xml:space="preserve">
          <source>When options are specified on the command line &lt;em&gt;and&lt;/em&gt; in the configuration file, the command line takes precedence.</source>
          <target state="translated">명령 행 &lt;em&gt;과&lt;/em&gt; 구성 파일 에 옵션이 지정되면 명령 행이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="8f2f15799355377c7156c1daee937dc255007dbc" translate="yes" xml:space="preserve">
          <source>When referring to a JavaScript variable that is elsewhere in your documentation, you must provide a unique identifier that maps to that variable. A namepath provides a way to do so and disambiguate between instance members, static members and inner variables.</source>
          <target state="translated">설명서의 다른 곳에있는 JavaScript 변수를 참조 할 때는 해당 변수에 매핑되는 고유 식별자를 제공해야합니다. 네임 패스는이를 수행하고 인스턴스 멤버, 정적 멤버 및 내부 변수를 명확하게하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2450782a8af2ce7fa0adddfc4248b2c9729c9c70" translate="yes" xml:space="preserve">
          <source>When running tests, do not use color in the console output. On Windows, this option is enabled by default.</source>
          <target state="translated">테스트를 실행할 때 콘솔 출력에 색상을 사용하지 마십시오. Windows에서는이 옵션이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdeee41aca8cc63fd09b85a13af4fe3fd26ae2cd" translate="yes" xml:space="preserve">
          <source>When using an object literal to define a class (for example with the &lt;code&gt;@lends&lt;/code&gt; tag) the &lt;code&gt;@constructs&lt;/code&gt; tag allows you to document that a particular function will be used to construct instances of that class.</source>
          <target state="translated">객체 리터럴을 사용하여 클래스를 정의 할 때 (예 : &lt;code&gt;@lends&lt;/code&gt; 태그 사용) &lt;code&gt;@constructs&lt;/code&gt; 태그를 사용하면 특정 함수가 해당 클래스의 인스턴스를 구성하는 데 사용될 것임을 문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a37f7a9567dff66717fe66e755aa3dd20076026" translate="yes" xml:space="preserve">
          <source>When was this feature added?</source>
          <target state="translated">이 기능은 언제 추가 되었습니까?</target>
        </trans-unit>
        <trans-unit id="511f4349c834f82cfaf03b4b9b974e28e0972beb" translate="yes" xml:space="preserve">
          <source>When you document an AMD module, you'll use an &lt;a href=&quot;tags-exports&quot;&gt;&lt;code&gt;@exports&lt;/code&gt; tag&lt;/a&gt; or &lt;a href=&quot;tags-module&quot;&gt;&lt;code&gt;@module&lt;/code&gt; tag&lt;/a&gt; to document the identifier that's passed to the &lt;code&gt;require()&lt;/code&gt; function. For example, if users load the module by calling &lt;code&gt;require('my/shirt', /* callback */)&lt;/code&gt;, you'll write a JSDoc comment that contains the tag &lt;code&gt;@exports my/shirt&lt;/code&gt; or &lt;code&gt;@module my/shirt&lt;/code&gt;. The examples below can help you decide which of these tags to use.</source>
          <target state="translated">AMD 모듈을 문서화 할 때 &lt;a href=&quot;tags-exports&quot;&gt; &lt;code&gt;@exports&lt;/code&gt; 태그&lt;/a&gt; 또는 &lt;a href=&quot;tags-module&quot;&gt; &lt;code&gt;@module&lt;/code&gt; 태그&lt;/a&gt; 를 사용하여 &lt;code&gt;require()&lt;/code&gt; 함수에 전달 된 식별자를 문서화합니다 . 예를 들어, 사용자가 &lt;code&gt;require('my/shirt', /* callback */)&lt;/code&gt; 를 호출하여 모듈을로드하면 &lt;code&gt;@exports my/shirt&lt;/code&gt; 또는 &lt;code&gt;@module my/shirt&lt;/code&gt; 태그가 포함 된 JSDoc 주석을 작성합니다 . 아래 예는 사용할 태그를 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2ece8a48301e27713e687ba0d3399240c2cfe4" translate="yes" xml:space="preserve">
          <source>When you document an ES 2015 module, you'll use a &lt;a href=&quot;tags-module&quot;&gt;&lt;code&gt;@module&lt;/code&gt; tag&lt;/a&gt; to document the identifier for the module. For example, if users load the module by calling &lt;code&gt;import * as myShirt
from 'my/shirt'&lt;/code&gt;, you'll write a JSDoc comment that contains the tag &lt;code&gt;@module my/shirt&lt;/code&gt;.</source>
          <target state="translated">ES 2015 모듈을 문서화 할 때 &lt;a href=&quot;tags-module&quot;&gt; &lt;code&gt;@module&lt;/code&gt; 태그&lt;/a&gt; 를 사용 하여 모듈의 식별자를 문서화합니다. 예를 들어, 사용자가 &lt;code&gt;import * as myShirt from 'my/shirt'&lt;/code&gt; 호출하여 모듈을로드하면 &lt;code&gt;@module my/shirt&lt;/code&gt; 태그가 포함 된 JSDoc 주석을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="15d2f06e691f648fa1497ccc076f73b7460aaed3" translate="yes" xml:space="preserve">
          <source>When you use a JSDoc &lt;a href=&quot;about-namepaths&quot;&gt;namepath&lt;/a&gt; to refer to a module from another JSDoc comment, you must add the prefix &lt;code&gt;module:&lt;/code&gt;. For example, if you want the documentation for the module &lt;code&gt;my/pants&lt;/code&gt; to link to the module &lt;code&gt;my/shirt&lt;/code&gt;, you could use the &lt;a href=&quot;tags-see&quot;&gt;&lt;code&gt;@see&lt;/code&gt; tag&lt;/a&gt; to document &lt;code&gt;my/pants&lt;/code&gt; as follows:</source>
          <target state="translated">JSDoc 이름 &lt;a href=&quot;about-namepaths&quot;&gt;경로&lt;/a&gt; 를 사용하여 다른 JSDoc 주석에서 모듈을 참조 할 때 접 두부 &lt;code&gt;module:&lt;/code&gt; 추가해야합니다 . 예를 들어, &lt;code&gt;my/pants&lt;/code&gt; 모듈에 대한 문서를 &lt;code&gt;my/shirt&lt;/code&gt; 모듈에 링크 하려면 &lt;a href=&quot;tags-see&quot;&gt; &lt;code&gt;@see&lt;/code&gt; 태그&lt;/a&gt; 를 사용하여 다음과 같이 &lt;code&gt;my/pants&lt;/code&gt; 를 문서화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb222248eda6ba2c024e30bfa6657d4cc5f56ed0" translate="yes" xml:space="preserve">
          <source>When you use multiple block tags in a JSDoc comment, they must be separated by line breaks:</source>
          <target state="translated">JSDoc 주석에서 여러 블록 태그를 사용하는 경우 줄 바꿈으로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ceafaaf084ac1ad89d460d3f5351ad62d8ac5f6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;extends&lt;/code&gt; keyword to extend an existing class, you also need to tell JSDoc which class you're extending. You do this with the &lt;a href=&quot;tags-augments&quot;&gt;&lt;code&gt;@augments&lt;/code&gt; (or &lt;code&gt;@extends&lt;/code&gt;) tag&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 키워드를 사용하여 기존 클래스를 확장 할 때 JSDoc에게 확장중인 클래스를 알려줘야합니다. &lt;a href=&quot;tags-augments&quot;&gt; &lt;code&gt;@augments&lt;/code&gt; (또는 &lt;code&gt;@extends&lt;/code&gt; ) 태그를 사용 하여이&lt;/a&gt; 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="dc97ed64fe986ee9a0ea88975559c477dbfc7b22" translate="yes" xml:space="preserve">
          <source>When you use the @name tag, you must provide additional tags that tell JSDoc what kind of symbol you are documenting; whether the symbol is a member of another symbol; and so on. If you do not provide this information, the symbol will not be documented correctly.</source>
          <target state="translated">@name 태그를 사용할 때는 JSDoc에 어떤 종류의 기호를 문서화하는지 알려주는 추가 태그를 제공해야합니다. 심볼이 다른 심볼의 멤버인지 여부; 등등. 이 정보를 제공하지 않으면 기호가 올바르게 문서화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="447c93f8818c836798caef4cc0ac3b3992408063" translate="yes" xml:space="preserve">
          <source>When you use the @property tag to document a property, you cannot link to the property using its longname. We can force the property to be linkable by using &quot;@alias&quot; and &quot;@memberof!&quot; to tell JSDoc that Data#point.y should be documented as a member &quot;point.y&quot; of &quot;Data#&quot;, rather than a member &quot;y&quot; of &quot;point&quot; of &quot;Data#&quot;.</source>
          <target state="translated">@property 태그를 사용하여 속성을 문서화하면 해당 이름을 사용하여 속성에 연결할 수 없습니다. &quot;@alias&quot;및 &quot;@memberof!&quot;를 사용하여 속성을 강제로 연결할 수 있습니다. JSDoc에게 Data # point.y는 &quot;Data #&quot;의 &quot;point&quot;의 &quot;y&quot;멤버가 아니라 &quot;Data #&quot;의 &quot;point.y&quot;멤버로 문서화되어야한다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c308da0b019d6344f546b6ae4ad717500b5dbd99" translate="yes" xml:space="preserve">
          <source>While the @alias tag may sound similar to the @name tag, these tags behave very differently. The @name tag tells JSDoc to ignore any code associated with the comment. For example, when JSDoc processes the following code, it ignores the fact that the comment for &lt;code&gt;bar&lt;/code&gt; is attached to a function:</source>
          <target state="translated">@alias 태그는 @name 태그와 비슷하게 들릴 수 있지만 이러한 태그는 매우 다르게 동작합니다. @name 태그는 JSDoc이 주석과 관련된 코드를 무시하도록 지시합니다. 예를 들어 JSDoc은 다음 코드를 처리 할 때 &lt;code&gt;bar&lt;/code&gt; 에 대한 주석 이 함수에 첨부되어 있다는 사실을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="b502b2acf1f9c9ec5bd430c3bfe8d2eb494722a0" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#jsdoc-tags&quot;&gt;Closure Compiler&lt;/a&gt; tag dictionary:</source>
          <target state="translated">으로 &lt;a href=&quot;https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#jsdoc-tags&quot;&gt;폐쇄 컴파일러&lt;/a&gt; 태그 사전 :</target>
        </trans-unit>
        <trans-unit id="f06ba56e7d4b13b0a9390599b8426875e1319e72" translate="yes" xml:space="preserve">
          <source>With the JSDoc tag dictionary (enabled by default):</source>
          <target state="translated">JSDoc 태그 사전을 사용하는 경우 (기본적으로 활성화 됨) :</target>
        </trans-unit>
        <trans-unit id="a7a8e6fb489222a90385313ac926f1471829b026" translate="yes" xml:space="preserve">
          <source>Without @lends you must provide the name of the class</source>
          <target state="translated">@lends가 없으면 클래스 이름을 제공해야합니다</target>
        </trans-unit>
        <trans-unit id="546851856aeac05c59dd315b9c39639f8d6272e5" translate="yes" xml:space="preserve">
          <source>Without any comments, JSDoc won't recognize that this code creates a &lt;code&gt;Person&lt;/code&gt; class with two methods. To document the methods, we must use a &lt;code&gt;@lends&lt;/code&gt; tag in a doc comment immediately before the object literal. The &lt;code&gt;@lends&lt;/code&gt; tag tells JSDoc that all the member names of that object literal are being &quot;loaned&quot; to a variable named &lt;code&gt;Person&lt;/code&gt;. We must also add comments to each of the methods.</source>
          <target state="translated">주석이 없으면 JSDoc은이 코드가 두 개의 메소드 로 &lt;code&gt;Person&lt;/code&gt; 클래스를 작성한다는 것을 인식하지 못합니다 . 메소드를 문서화하려면 객체 리터럴 직전에 문서 주석에 &lt;code&gt;@lends&lt;/code&gt; 태그를 사용해야합니다 . &lt;code&gt;@lends&lt;/code&gt; 의 태그는 객체 리터럴의 모든 구성원 이름라는 변수에 &quot;대여&quot;되고 있다는 JSDoc 알려줍니다 &lt;code&gt;Person&lt;/code&gt; . 또한 각 방법에 주석을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="72a9991384d8f2cb34c0f03a560f0d2ad219a274" translate="yes" xml:space="preserve">
          <source>Without the @function tag, the &lt;code&gt;paginate&lt;/code&gt; object would be documented as a generic object (a &lt;a href=&quot;tags-member&quot;&gt;@member&lt;/a&gt;), because it isn't possible to tell from examining the line of code what type of value &lt;code&gt;paginate&lt;/code&gt; will hold when it is run.</source>
          <target state="translated">@function 태그가 없으면 &lt;code&gt;paginate&lt;/code&gt; 객체는 일반 객체 ( &lt;a href=&quot;tags-member&quot;&gt;@member&lt;/a&gt; ) 로 문서화됩니다. &lt;code&gt;paginate&lt;/code&gt; 가 실행될 때 보유 할 값 유형 유형을 코드 줄에서 확인할 수 없기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d2ca254c55536723fc510717091e1d358931503c" translate="yes" xml:space="preserve">
          <source>You can add a hyphen before the description to make it more readable. Be sure to include a space before and after the hyphen.</source>
          <target state="translated">설명 앞에 하이픈을 추가하여 더 읽기 쉽게 만들 수 있습니다. 하이픈 앞뒤에 공백을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="df5f15f71d91495d4c93f34f9779842af0a7c5cc" translate="yes" xml:space="preserve">
          <source>You can also combine this syntax with JSDoc's syntax for array parameters. For example, if multiple employees can be assigned to a project:</source>
          <target state="translated">이 구문을 배열 매개 변수에 대한 JSDoc의 구문과 결합 할 수도 있습니다. 예를 들어, 여러 직원을 프로젝트에 할당 할 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="072064a3a22340a1f3b53f5f2b3bd35a426e5d1e" translate="yes" xml:space="preserve">
          <source>You can also document classes that are defined in a class expression, which assigns the class to a variable or constant:</source>
          <target state="translated">클래스 표현식에 정의 된 클래스를 문서화하여 클래스를 변수 또는 상수에 할당 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b72723e3db8eefcc02599ab7c8acd698254031" translate="yes" xml:space="preserve">
          <source>You can also indicate an array by appending &lt;code&gt;[]&lt;/code&gt; to the type that is contained in the array. For example, the expression &lt;code&gt;string[]&lt;/code&gt; indicates an array of strings.</source>
          <target state="translated">배열에 포함 된 유형에 &lt;code&gt;[]&lt;/code&gt; 를 추가하여 배열을 나타낼 수도 있습니다 . 예를 들어, &lt;code&gt;string[]&lt;/code&gt; 표현식 은 문자열 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebbcb2e9fd33a573203c7651e2731baf22784977" translate="yes" xml:space="preserve">
          <source>You can also provide an individual &lt;code&gt;.json&lt;/code&gt; file for each tutorial, using the tutorial identifier as the filename. This method is deprecated and should not be used for new projects.</source>
          <target state="translated">튜토리얼 식별자를 파일 이름으로 사용하여 각 튜토리얼에 대해 개별 &lt;code&gt;.json&lt;/code&gt; 파일을 제공 할 수도 있습니다 . 이 방법은 더 이상 사용되지 않으며 새 프로젝트에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bf9c20fe324d702bddf27c43aa337c632102659f" translate="yes" xml:space="preserve">
          <source>You can also set one of the following options in JSDoc's configuration file; see &lt;a href=&quot;about-configuring-jsdoc&quot;&gt;Configuring JSDoc&lt;/a&gt; for more details:</source>
          <target state="translated">JSDoc의 구성 파일에서 다음 옵션 중 하나를 설정할 수도 있습니다. 자세한 내용 은 &lt;a href=&quot;about-configuring-jsdoc&quot;&gt;JSDoc 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="84e02664666e12b047e932d2d3c2e2ee8c8e0bc1" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tags-inline-tutorial&quot;&gt;&lt;code&gt;{@tutorial}&lt;/code&gt; inline tag&lt;/a&gt; to link to a tutorial within the text of another tag. By default, JSDoc will use the tutorial's title as the link text.</source>
          <target state="translated">&lt;a href=&quot;tags-inline-tutorial&quot;&gt; &lt;code&gt;{@tutorial}&lt;/code&gt; 인라인 태그&lt;/a&gt; 를 사용하여 다른 태그의 텍스트 내에서 자습서에 연결할 수도 있습니다 . 기본적으로 JSDoc은 튜토리얼 제목을 링크 텍스트로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dcfcff443dc7b85a22b737098922aaabc89918ea" translate="yes" xml:space="preserve">
          <source>You can also use the @alias tag with members that are created within an immediately invoked function expression (IIFE). The @alias tag tells JSDoc that these members are exposed outside of the IIFE's scope.</source>
          <target state="translated">@alias 태그를 즉시 호출 된 함수 식 (IIFE) 내에 생성 된 멤버와 함께 사용할 수도 있습니다. @alias 태그는 JSDoc에게이 멤버들이 IIFE의 범위 밖에서 노출되었음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="332d34175bb06a2c7483a74515618a8562e7b50c" translate="yes" xml:space="preserve">
          <source>You can also use this pattern if you add properties to &lt;code&gt;module.exports&lt;/code&gt; outside of the object literal:</source>
          <target state="translated">객체 리터럴 외부의 &lt;code&gt;module.exports&lt;/code&gt; 에 속성을 추가하는 경우 에도이 패턴을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fed63cad6cf17910a6434a658a68897be9b3de8" translate="yes" xml:space="preserve">
          <source>You can configure the Markdown plugin by adding a &lt;code&gt;markdown&lt;/code&gt; object to your configuration file. See &lt;a href=&quot;plugins-markdown&quot;&gt;Configuring the Markdown Plugin&lt;/a&gt; for details.</source>
          <target state="translated">마크 &lt;code&gt;markdown&lt;/code&gt; 객체를 구성 파일 에 추가하여 마크 다운 플러그인을 구성 할 수 있습니다 . 자세한 내용 &lt;a href=&quot;plugins-markdown&quot;&gt;은 마크 다운 플러그인 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70e600dbc77b8d63fbd1c716a007510ddc097987" translate="yes" xml:space="preserve">
          <source>You can document complex types using the &lt;a href=&quot;tags-typedef&quot;&gt;@typedef&lt;/a&gt; tag, then refer to the type definition elsewhere in your documentation.</source>
          <target state="translated">&lt;a href=&quot;tags-typedef&quot;&gt;@typedef&lt;/a&gt; 태그를 사용하여 복합 유형을 문서화 한 다음 문서의 다른 곳에서 유형 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="389cf2a1f9c2bfe547d576d2d29a7bef7a9f7d00" translate="yes" xml:space="preserve">
          <source>You can get the same result by omitting the JSDoc comment from &lt;code&gt;Socket#open&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Socket#open&lt;/code&gt; 에서 JSDoc 주석을 생략하여 동일한 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa83982db381e8304fede25cc53a44fa271690b9" translate="yes" xml:space="preserve">
          <source>You can provide any value with the @variation tag, as long as the combination of the value and the longname results in a globally unique version of the longname. As a best practice, use a predictable pattern for choosing the values, which will make it easier for you to document your code.</source>
          <target state="translated">값과 긴 이름을 조합하여 전체적으로 고유 한 긴 이름 버전을 만드는 한 @variation 태그를 사용하여 모든 값을 제공 할 수 있습니다. 모범 사례로서 예측 가능한 패턴을 사용하여 값을 선택하면 코드를보다 쉽게 ​​문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b451c9752530b71acbc8779ed9c9ae1d04ff1e" translate="yes" xml:space="preserve">
          <source>You can put many of JSDoc's &lt;a href=&quot;about-commandline&quot;&gt;command-line options&lt;/a&gt; into the configuration file instead of specifying them on the command line. To do this, add the long names of the relevant options into an &lt;code&gt;opts&lt;/code&gt; section of the configuration file, with the value set to the option's value.</source>
          <target state="translated">많은 JSDoc의 &lt;a href=&quot;about-commandline&quot;&gt;명령 행 옵션&lt;/a&gt; 을 명령 행에서 지정하는 대신 구성 파일에 넣을 수 있습니다 . 이렇게하려면 관련 옵션의 긴 이름을 구성 파일 의 &lt;code&gt;opts&lt;/code&gt; 섹션에 값을 옵션 값으로 설정하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="29a1f18ae14ad668a870d2e8601087acc0d483bf" translate="yes" xml:space="preserve">
          <source>You can use any text to identify the license you are using. If your code uses a standard open-source license, consider using the appropriate identifier from the &lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;Software Package Data Exchange (SPDX) License List&lt;/a&gt;.</source>
          <target state="translated">텍스트를 사용하여 사용중인 라이센스를 식별 할 수 있습니다. 코드에서 표준 오픈 소스 라이센스를 사용하는 경우 &lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;SPDX (Software Package Data Exchange) 라이센스 목록&lt;/a&gt; 에서 적절한 식별자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e7f282f924f3e57f2fd70f4abc01da96dececcb" translate="yes" xml:space="preserve">
          <source>You can use inline tags within a description, as shown above, or within a block tag, as shown below:</source>
          <target state="translated">위에 표시된대로 설명 내에서 또는 아래에 표시된대로 블록 태그 내에서 인라인 태그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35c42b1cab1481c425c69fced8542718a6227d59" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@tutorial&lt;/code&gt; tag more than once in a single JSDoc comment.</source>
          <target state="translated">단일 JSDoc 주석에서 &lt;code&gt;@tutorial&lt;/code&gt; 태그를 두 번 이상 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bc06147c2b461b3992483a0297ff7029e9ebe1c" translate="yes" xml:space="preserve">
          <source>You can use the @deprecated tag by itself, or include some text that describes more about the deprecation.</source>
          <target state="translated">@deprecated 태그를 단독으로 사용하거나 사용 중단에 대해 자세히 설명하는 텍스트를 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee79c69f9c6e0af858cb01d6bfa67b18943208a" translate="yes" xml:space="preserve">
          <source>You may need to document a namespace whose name includes unusual characters, such as &quot;#&quot; or &quot;!&quot;. In these cases, when you document or link to the namespace, you must add quotation marks around the portion of the namespace that includes unusual characters. See the examples below for details.</source>
          <target state="translated">이름에 &quot;#&quot;또는 &quot;!&quot;와 같이 이상한 문자가 포함 된 네임 스페이스를 문서화해야 할 수도 있습니다. 이러한 경우 네임 스페이스를 문서화하거나 링크 할 때 네임 스페이스 부분에 특수 문자가 포함 된 따옴표를 추가해야합니다. 자세한 내용은 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="553e9778b4c240707726937a06966014e171bbb6" translate="yes" xml:space="preserve">
          <source>You might wonder why there is a syntax to refer to an inner method when that method isn't directly accessible from outside the function it is defined in. While that is true, and thus the &quot;~&quot; syntax is rarely used, it &lt;em&gt;is&lt;/em&gt; possible to return a reference to an inner method from another method inside that container, so it is possible that some object elsewhere in your code might borrow an inner method.</source>
          <target state="translated">정의 된 함수 외부에서 해당 메소드에 직접 액세스 할 수없는 경우 내부 메소드를 참조하는 구문이있는 이유가 궁금 할 수 있습니다. 이것이 사실이므로 &quot;~&quot;구문이 거의 사용되지 않는 &lt;em&gt;것이&lt;/em&gt; 가능합니다. 컨테이너 내의 다른 메소드에서 내부 메소드에 대한 참조를 리턴하므로 코드의 다른 곳에서 일부 메소드가 내부 메소드를 빌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2443e20ade45a71ed7bb9b65a7431036c6b4cf18" translate="yes" xml:space="preserve">
          <source>You should only add the &lt;code&gt;@external&lt;/code&gt; tag to the highest-level symbol that is defined outside of your project. In the following example, the documentation refers to the external class &lt;code&gt;security.TLS&lt;/code&gt;. As a result, the &lt;code&gt;@external&lt;/code&gt; tag is used to document the external namespace &lt;code&gt;external:security&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; the external class &lt;code&gt;external:security.TLS&lt;/code&gt;.</source>
          <target state="translated">프로젝트 외부에 정의 된 최상위 심볼 에만 &lt;code&gt;@external&lt;/code&gt; 태그를 추가해야합니다 . 다음 예제에서 문서는 외부 클래스 &lt;code&gt;security.TLS&lt;/code&gt; 를 참조 합니다. 결과적으로 &lt;code&gt;@external&lt;/code&gt; 태그는 외부 네임 스페이스 &lt;code&gt;external:security&lt;/code&gt; 를 문서화하는 데 사용 되지만 외부 클래스 &lt;code&gt;external:security.TLS&lt;/code&gt; 는 문서화 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd3125a13ddd8225b17096fb4519f43ce89ffd04" translate="yes" xml:space="preserve">
          <source>You would use three different namepath syntaxes to refer to the three different methods:</source>
          <target state="translated">세 가지 다른 이름 경로 구문을 사용하여 세 가지 다른 방법을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="8d767bf5b72373d12f0efd4406677e9ed076f592" translate="yes" xml:space="preserve">
          <source>class</source>
          <target state="translated">class</target>
        </trans-unit>
        <trans-unit id="d810ca965a236c6f46a932efff918a4b3a191918" translate="yes" xml:space="preserve">
          <source>constant</source>
          <target state="translated">constant</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="59d8f3ec5b13131f7856e6ed51dca3c6adb97cd4" translate="yes" xml:space="preserve">
          <source>external</source>
          <target state="translated">external</target>
        </trans-unit>
        <trans-unit id="971c419dd609331343dee105fffd0f4608dc0bf2" translate="yes" xml:space="preserve">
          <source>file</source>
          <target state="translated">file</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="6467baa3b187373e3931422e2a8ef22f3e447d77" translate="yes" xml:space="preserve">
          <source>member</source>
          <target state="translated">member</target>
        </trans-unit>
        <trans-unit id="eb39cd7e3640cec9a8c5d3c208d02c0a32d59b73" translate="yes" xml:space="preserve">
          <source>mixin</source>
          <target state="translated">mixin</target>
        </trans-unit>
        <trans-unit id="fbd34a2b6e6a9fe8161f97dc435642609ac0bc29" translate="yes" xml:space="preserve">
          <source>module</source>
          <target state="translated">module</target>
        </trans-unit>
        <trans-unit id="1963ebc61173a88a0385135580dc1b7cd78e2c17" translate="yes" xml:space="preserve">
          <source>namespace</source>
          <target state="translated">namespace</target>
        </trans-unit>
        <trans-unit id="6dc2082b65ff3a9aefc09caca29756531dea041a" translate="yes" xml:space="preserve">
          <source>typedef</source>
          <target state="translated">typedef</target>
        </trans-unit>
        <trans-unit id="65d2beee69b90e00ef0fa86266685f294c31214f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;kindName&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;kindName&amp;gt;&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="b0e3cd94c308c55afae143631cefd44a841037c6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;...&lt;/code&gt; are paths to other files to generate documentation for.</source>
          <target state="translated">여기서 &lt;code&gt;...&lt;/code&gt; 는 문서를 생성 할 다른 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="3c419961de9fa7d1b78c40d7d48ea1cd734165e7" translate="yes" xml:space="preserve">
          <source>with JSDoc 3</source>
          <target state="translated">JSDoc 3 사용</target>
        </trans-unit>
        <trans-unit id="ec7160a2f41c989874fe1a314b9ab97d7cbde636" translate="yes" xml:space="preserve">
          <source>{@link}</source>
          <target state="translated">{@link}</target>
        </trans-unit>
        <trans-unit id="e22ba425121c0962405e598b43740e2b3d049d4d" translate="yes" xml:space="preserve">
          <source>{@tutorial}</source>
          <target state="translated">{@tutorial}</target>
        </trans-unit>
        <trans-unit id="041d153fc8bda3f6c0870df0cbbfd665a997ff43" translate="yes" xml:space="preserve">
          <source>{@tutorial} inline tag</source>
          <target state="translated">{@tutorial} inline tag</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
