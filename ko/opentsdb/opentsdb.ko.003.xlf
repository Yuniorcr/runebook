<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="opentsdb">
    <body>
      <group id="opentsdb">
        <trans-unit id="73049b543635fbae9eb9096dea2c4be0c2566a4a" translate="yes" xml:space="preserve">
          <source>The UID FSCK command will scan the entire UID table for errors pertaining to name and UID mappings. By default, the run will scan every column in the table and log any errors that were found. With version 2.1 it is possible to fix errors in the table by passing the &quot;fix&quot; flag. UIDMeta objects are skipped during scanning. Possible errors include:</source>
          <target state="translated">UID FSCK 명령은 이름 및 UID 매핑과 관련된 오류가 있는지 전체 UID 테이블을 스캔합니다. 기본적으로 실행은 테이블의 모든 열을 스캔하고 발견 된 오류를 기록합니다. 버전 2.1에서는 &quot;fix&quot;플래그를 전달하여 테이블의 오류를 수정할 수 있습니다. 스캔하는 동안 UIDMeta 객체를 건너 뜁니다. 가능한 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d95ba2bd5d873b20be72b2a526e2a30e1117d3ee" translate="yes" xml:space="preserve">
          <source>The UID is a positive integer that is unique to the name of the UID object and it's type. Within the storage system there is a counter that is incremented for each &lt;code&gt;metric&lt;/code&gt;, &lt;code&gt;tagk&lt;/code&gt; and &lt;code&gt;tagv&lt;/code&gt;. When you create a new &lt;code&gt;tsdb-uid&lt;/code&gt; table, this counter is set to 0 for each type. So if you put a new data point with a metric of &lt;code&gt;sys.cpu.0&lt;/code&gt; and a tag pair of &lt;code&gt;host=web01&lt;/code&gt; you will have 3 new UID objects, each with a UID of 1.</source>
          <target state="translated">UID는 UID 객체의 이름과 유형에 고유 한 양의 정수입니다. 스토리지 시스템에는 각 &lt;code&gt;metric&lt;/code&gt; , &lt;code&gt;tagk&lt;/code&gt; 및 &lt;code&gt;tagv&lt;/code&gt; 에 대해 증가하는 카운터가 있습니다 . 새 &lt;code&gt;tsdb-uid&lt;/code&gt; 테이블 을 작성하면 이 카운터는 각 유형에 대해 0으로 설정됩니다. 따라서 메트릭이 &lt;code&gt;sys.cpu.0&lt;/code&gt; 이고 태그 쌍이 &lt;code&gt;host=web01&lt;/code&gt; 인 새 데이터 포인트를 배치하면 각각 UID가 1 인 3 개의 새로운 UID 객체 가 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="e7e1e3a6d9ff79ec6731a69970e3e5cc61bc6622" translate="yes" xml:space="preserve">
          <source>The UID limit is usually not an issue, however. A tag value is assigned a UID that is completely disassociated from its tag name. If you use numeric identifiers for tag values, the number is assigned a UID once and can be used with many tag names. For example, if we assign a UID to the number &lt;code&gt;2&lt;/code&gt;, we could store timeseries with the tag pairs &lt;code&gt;cpu=2&lt;/code&gt;, &lt;code&gt;interface=2&lt;/code&gt;, &lt;code&gt;hdd=2&lt;/code&gt; and &lt;code&gt;fan=2&lt;/code&gt; while consuming only 1 tag value UID (&lt;code&gt;2&lt;/code&gt;) and 4 tag name UIDs (&lt;code&gt;cpu&lt;/code&gt;, &lt;code&gt;interface&lt;/code&gt;, &lt;code&gt;hdd&lt;/code&gt; and &lt;code&gt;fan&lt;/code&gt;).</source>
          <target state="translated">그러나 UID 제한은 일반적으로 문제가되지 않습니다. 태그 값에는 태그 이름과 완전히 분리 된 UID가 할당됩니다. 태그 값에 숫자 식별자를 사용하면 숫자에 UID가 한 번 할당되며 많은 태그 이름과 함께 사용할 수 있습니다. 예를 들어, UID를 숫자 &lt;code&gt;2&lt;/code&gt; 에 할당 하면 태그 쌍 &lt;code&gt;cpu=2&lt;/code&gt; , &lt;code&gt;interface=2&lt;/code&gt; , &lt;code&gt;hdd=2&lt;/code&gt; 및 &lt;code&gt;fan=2&lt;/code&gt; 와 함께 시계열을 저장할 수 있지만 1 태그 값 UID ( &lt;code&gt;2&lt;/code&gt; ) 및 4 태그 이름 만 소비 할 수 있습니다 UID ( &lt;code&gt;cpu&lt;/code&gt; , &lt;code&gt;interface&lt;/code&gt; , &lt;code&gt;hdd&lt;/code&gt; 및 &lt;code&gt;fan&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eb1650b024a45f4e97f5f6fd59780ee0a5115163" translate="yes" xml:space="preserve">
          <source>The UID utility provides various functions to search or modify information in the &lt;code&gt;tsdb-uid&lt;/code&gt; table. This includes UID assignments for metrics, tag names and tag values as well as UID meta data, timeseries meta data and tree definitions or data.</source>
          <target state="translated">UID 유틸리티는 &lt;code&gt;tsdb-uid&lt;/code&gt; 테이블 에서 정보를 검색하거나 수정하는 다양한 기능을 제공 합니다. 여기에는 UID 메타 데이터, 시계열 메타 데이터 및 트리 정의 또는 데이터뿐만 아니라 메트릭, 태그 이름 및 태그 값에 대한 UID 할당이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e08bed21feaf3e99b75b4edf4aa04f9f1051b0d" translate="yes" xml:space="preserve">
          <source>The UIDMeta endpoint returns a list of UIDMeta objects that match the query.</source>
          <target state="translated">UIDMeta 엔드 포인트는 조회와 일치하는 UIDMeta 오브젝트 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1d976e19573504c57c28735643d660b168bf137e" translate="yes" xml:space="preserve">
          <source>The VCL configuration language</source>
          <target state="translated">VCL 구성 언어</target>
        </trans-unit>
        <trans-unit id="24ca27b960057be9c692b385d99b7a666adff482" translate="yes" xml:space="preserve">
          <source>The aggregated average for &lt;code&gt;sys.cpu.user host=webserver01,cpu=0&lt;/code&gt; and &lt;code&gt;sys.cpu.user host=webserver01,cpu=1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys.cpu.user host=webserver01,cpu=0&lt;/code&gt; 및 &lt;code&gt;sys.cpu.user host=webserver01,cpu=1&lt;/code&gt; 의 집계 평균</target>
        </trans-unit>
        <trans-unit id="a45776fa5e8350c63b337ad6bc694c6f27db1d2b" translate="yes" xml:space="preserve">
          <source>The aggregated average for &lt;code&gt;sys.cpu.user host=webserver02,cpu=0&lt;/code&gt; and &lt;code&gt;sys.cpu.user host=webserver02,cpu=1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys.cpu.user host=webserver02,cpu=0&lt;/code&gt; 및 &lt;code&gt;sys.cpu.user host=webserver02,cpu=1&lt;/code&gt; 의 집계 평균</target>
        </trans-unit>
        <trans-unit id="13c03174f347e84fca00daa6ce64815011680a8b" translate="yes" xml:space="preserve">
          <source>The aggregated average for &lt;code&gt;sys.cpu.user host=webserver03,cpu=0&lt;/code&gt; and &lt;code&gt;sys.cpu.user host=webserver03,cpu=1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys.cpu.user host=webserver03,cpu=0&lt;/code&gt; 및 &lt;code&gt;sys.cpu.user host=webserver03,cpu=1&lt;/code&gt; 의 집계 평균</target>
        </trans-unit>
        <trans-unit id="eba351138c443c19cb20675cbf937722a601e1aa" translate="yes" xml:space="preserve">
          <source>The aggregation function to use for reducing the data points</source>
          <target state="translated">데이터 포인트를 줄이기 위해 사용하는 집계 함수</target>
        </trans-unit>
        <trans-unit id="9c0eccdfb114c1b37e44d5d689e3ec2caad45fab" translate="yes" xml:space="preserve">
          <source>The amount of time it took, in milliseconds, to complete the query</source>
          <target state="translated">쿼리를 완료하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="3a13244f2127b9fdf12c7a6030cbceebc92780b2" translate="yes" xml:space="preserve">
          <source>The array of results. Each sub array starts with the timestamp in ms as the first (offset 0) value. The remaining values are the results for each series when a group by was applied.</source>
          <target state="translated">결과 배열입니다. 각 하위 배열은 타임 스탬프 (ms)를 첫 번째 (오프셋 0) 값으로 시작합니다. 나머지 값은 그룹 기준이 적용될 때 각 계열에 대한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e267991298a37837615e4e72157ba4d9e30432e6" translate="yes" xml:space="preserve">
          <source>The benefits of this schema are that you have very deep granularity in your data, e.g., storing usage metrics on a per-core basis. You can also easily craft a query to get the average usage across all cores an all hosts: &lt;code&gt;start=1d-ago&amp;amp;m=avg:sys.cpu.user&lt;/code&gt;. However queries against that particular metric will take longer as there are more rows to sift through.</source>
          <target state="translated">이 스키마의 장점은 코어 단위로 사용 메트릭을 저장하는 등 데이터를 매우 세밀하게 처리 할 수 ​​있다는 것입니다. &lt;code&gt;start=1d-ago&amp;amp;m=avg:sys.cpu.user&lt;/code&gt; 모든 코어의 평균 사용량을 얻기 위해 쿼리를 쉽게 만들 수도 있습니다 . 그러나 특정 메트릭에 대한 쿼리는 더 많은 행을 탐색할수록 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="bed1a5b3684d300fe09cb4e822d78aebd51db9b7" translate="yes" xml:space="preserve">
          <source>The best way to contribute code is to fork the main repo and &lt;a href=&quot;https://help.github.com/articles/using-pull-requests&quot;&gt;send a pull request&lt;/a&gt; on GitHub.</source>
          <target state="translated">코드를 제공하는 가장 좋은 방법은 메인 리포지토리를 포크하고 GitHub에 &lt;a href=&quot;https://help.github.com/articles/using-pull-requests&quot;&gt;풀 요청&lt;/a&gt; 을 보내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d60310296c86c8b1058f1d388b722a7acbce3dee" translate="yes" xml:space="preserve">
          <source>The class name of a real time publishing plugin to instantiate. If &lt;code&gt;tsd.rtpublisher.enable&lt;/code&gt; is set to false, this value is ignored. E.g. net.opentsdb.tsd.RabbitMQPublisher</source>
          <target state="translated">인스턴스화 할 실시간 게시 플러그인의 클래스 이름입니다. 경우 &lt;code&gt;tsd.rtpublisher.enable&lt;/code&gt; 가 false로 설정되어,이 값은 무시됩니다. 예 : net.opentsdb.tsd.RabbitMQPublisher</target>
        </trans-unit>
        <trans-unit id="60e91bd5659196a1e84d26096d4ec1d5238af397" translate="yes" xml:space="preserve">
          <source>The class name of a search plugin to instantiate. If &lt;code&gt;tsd.search.enable&lt;/code&gt; is set to false, this value is ignored. E.g. net.opentsdb.search.ElasticSearch</source>
          <target state="translated">인스턴스화 할 검색 플러그인의 클래스 이름입니다. 경우 &lt;code&gt;tsd.search.enable&lt;/code&gt; 가 false로 설정되어,이 값은 무시됩니다. 예 : net.opentsdb.search.ElasticSearch</target>
        </trans-unit>
        <trans-unit id="152c9c578960286e497ea54d46a3d98b2252050a" translate="yes" xml:space="preserve">
          <source>The class that will be used to implement the HBase API AsyncBigtable will use as a shim between the Bigtable client and OpenTSDB. Set this to</source>
          <target state="translated">HBase API AsyncBigtable을 구현하는 데 사용될 클래스는 Bigtable 클라이언트와 OpenTSDB 사이의 shim으로 사용됩니다. 이것을로 설정하십시오</target>
        </trans-unit>
        <trans-unit id="c6d6f0098f89f002b1a2dc4cbc9d8c59a69d57e5" translate="yes" xml:space="preserve">
          <source>The clients for Bigtable are in beta and undergoing a number of changes. Performance should improve as we adjust the code and uncover new tuning parameters. Please help us out on the mailing list or by modifying the code in GitHub.</source>
          <target state="translated">Bigtable의 고객은 베타 버전이며 많은 변경이 진행되고 있습니다. 코드를 조정하고 새로운 튜닝 매개 변수를 발견하면 성능이 향상되어야합니다. 메일 링리스트 나 GitHub의 코드를 수정하여 도와주세요.</target>
        </trans-unit>
        <trans-unit id="67776a1b0a970f817e1cf55bbb42c7a9c5b121cc" translate="yes" xml:space="preserve">
          <source>The cluster ID you assigned to your Bigtable cluster at creation.</source>
          <target state="translated">생성시 Bigtable 클러스터에 할당 한 클러스터 ID</target>
        </trans-unit>
        <trans-unit id="2fed16c75eb1b8b5eb43dc5dc8d3216b5b97b026" translate="yes" xml:space="preserve">
          <source>The code for this endpoint is very simple and does not include any security. Thus you should make sure that permissions on your static root directory are secure so that users can't write malicious files and serve them out of OpenTSDB. Users shouldn't be able to write files via OpenTSDB, but take precautions just to be safe.</source>
          <target state="translated">이 엔드 포인트의 코드는 매우 간단하며 보안이 포함되어 있지 않습니다. 따라서 사용자가 악의적 인 파일을 작성하여 OpenTSDB에서 제공 할 수 없도록 정적 루트 디렉토리에 대한 권한이 안전한지 확인해야합니다. 사용자는 OpenTSDB를 통해 파일을 작성할 수 없지만 안전을 위해 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="49b3800038fbec2c89910cb9e10a9597dabe4b0b" translate="yes" xml:space="preserve">
          <source>The command format is:</source>
          <target state="translated">명령 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba3127b1b2c8ecbc3b318ccdb2bcf59e6900c2e4" translate="yes" xml:space="preserve">
          <source>The common parameters above are required by all the CLI commands. It can be tedious to manually type them over and over again. You can instead store typically used values in a file &lt;code&gt;./tsdb.local&lt;/code&gt;. This file is expected to be a shell script and will be sourced by &lt;code&gt;./tsdb&lt;/code&gt; if it exists.</source>
          <target state="translated">위의 공통 매개 변수는 모든 CLI 명령에 필요합니다. 수동으로 반복해서 입력하는 것이 번거로울 수 있습니다. 대신 일반적으로 사용되는 값을 &lt;code&gt;./tsdb.local&lt;/code&gt; 파일에 저장할 수 있습니다 . 이 파일은 쉘 스크립트 일 것으로 예상되며 존재하는 경우 &lt;code&gt;./tsdb&lt;/code&gt; 가 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3e6b905af8bbb89afc4e1f923d87d75e3a401eca" translate="yes" xml:space="preserve">
          <source>The configuration file conforms to the Java properties specification. Configuration names are lower-case, dotted strings without spaces. Each name is followed by an equals sign, then the value for the property. All OpenTSDB properties start with &lt;code&gt;tsd.&lt;/code&gt; Comments or inactive configuration lines are blocked by a hash symbol &lt;code&gt;#&lt;/code&gt;. For example:</source>
          <target state="translated">구성 파일은 Java 특성 스펙을 준수합니다. 구성 이름은 공백이없는 소문자, 점선 문자열입니다. 각 이름 뒤에는 등호, 속성 값이옵니다. 모든 OpenTSDB 속성은 &lt;code&gt;tsd.&lt;/code&gt; 시작 합니다. 주석 또는 비활성 구성 줄은 해시 기호 &lt;code&gt;#&lt;/code&gt; 로 차단됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="071768e6e986b3028f383e41796ac237ff910ee3" translate="yes" xml:space="preserve">
          <source>The connection queue depth for completed or incomplete connection requests depending on OS. The default may be limited by the 'somaxconn' kernel setting or set by Netty to 3072.</source>
          <target state="translated">OS에 따라 완료되거나 완료되지 않은 연결 요청에 대한 연결 큐 깊이. 기본값은 'somaxconn'커널 설정에 의해 제한되거나 Netty에 의해 3072로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3899cefd6118b1ea06bf5519e8afb8b6d8bc96a8" translate="yes" xml:space="preserve">
          <source>The correct Content-Type is returned for each response, e.g. &lt;code&gt;text/html; charset=UTF-8&lt;/code&gt; for HTML, &lt;code&gt;application/json&lt;/code&gt; for JSON and &lt;code&gt;image/png&lt;/code&gt; for images.</source>
          <target state="translated">각 응답에 대해 올바른 Content-Type이 반환됩니다 (예 : &lt;code&gt;text/html; charset=UTF-8&lt;/code&gt; HTML의 경우 charset = UTF-8 , JSON의 경우 &lt;code&gt;application/json&lt;/code&gt; , &lt;code&gt;image/png&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65812624ee468c4cf05eadca4a42dd6837f4242e" translate="yes" xml:space="preserve">
          <source>The current number of RPCs sent to HBase and awaiting a response.</source>
          <target state="translated">HBase에 전송되어 응답을 기다리는 현재 RPC 수입니다.</target>
        </trans-unit>
        <trans-unit id="c3a2f281de19405e21c4f338555a6008c9b6b1ed" translate="yes" xml:space="preserve">
          <source>The current number of assigned metric UIDs. (NOTE: if random metric UID generation is enabled ids-used will always be 0)</source>
          <target state="translated">할당 된 메트릭 UID의 현재 수입니다. (참고 : 임의의 메트릭 UID 생성이 활성화 된 경우 id-used는 항상 0입니다)</target>
        </trans-unit>
        <trans-unit id="0b5b94c6f5790c5d3e8952b201226be89b62f8fa" translate="yes" xml:space="preserve">
          <source>The current number of assigned tagk UIDs</source>
          <target state="translated">할당 된 태그 UID의 현재 수</target>
        </trans-unit>
        <trans-unit id="df997c8fb6c02251f8baa21c4d2ddb9ec13c7ff5" translate="yes" xml:space="preserve">
          <source>The current number of assigned tagv UIDs</source>
          <target state="translated">할당 된 tagv UID의 현재 수</target>
        </trans-unit>
        <trans-unit id="22e9102c387374533af0182fe6a01032baccd42f" translate="yes" xml:space="preserve">
          <source>The current number of available metric UIDs, decrements as UIDs are assigned. (NOTE: if random metric UID generation is enabled ids-used will always be 0)</source>
          <target state="translated">사용 가능한 메트릭 UID의 현재 수는 UID가 할당 될 때 감소합니다. (참고 : 임의의 메트릭 UID 생성이 활성화 된 경우 id-used는 항상 0입니다)</target>
        </trans-unit>
        <trans-unit id="0bb1f9f5cc6842912153742777c47386c3b5a3e9" translate="yes" xml:space="preserve">
          <source>The current number of available tagk UIDs, decrements as UIDs are assigned.</source>
          <target state="translated">사용 가능한 tagk UID의 현재 수는 UID가 할당 될 때 감소합니다.</target>
        </trans-unit>
        <trans-unit id="fb8804dda7913c3868e69c38d8b49e91051b5c7c" translate="yes" xml:space="preserve">
          <source>The current number of available tagv UIDs, decrements as UIDs are assigned.</source>
          <target state="translated">사용 가능한 tagv UID의 현재 수는 UID가 할당 될 때 감소합니다.</target>
        </trans-unit>
        <trans-unit id="accf7b069d5c2a3cb119a1870acd0905e5917ba3" translate="yes" xml:space="preserve">
          <source>The current number of cached metric UIDs</source>
          <target state="translated">캐시 된 메트릭 UID의 현재 수</target>
        </trans-unit>
        <trans-unit id="b2aae198b0379715915537d200598fa2c49858ec" translate="yes" xml:space="preserve">
          <source>The current number of cached tagk UIDs</source>
          <target state="translated">캐시 된 태그 UID의 현재 수</target>
        </trans-unit>
        <trans-unit id="96d3777742d33d8e59b4c95bb80d9386648564b9" translate="yes" xml:space="preserve">
          <source>The current number of cached tagv UIDs</source>
          <target state="translated">캐시 된 tagv UID의 현재 수</target>
        </trans-unit>
        <trans-unit id="f7a9409d7b90be8afebed8b0f75be99c82c6cacd" translate="yes" xml:space="preserve">
          <source>The daemon will continue to run until killed via a Telnet or HTTP command is sent to tell it to stop. If an error occurred, such as failure to connect to Zookeeper or the inability to bind to the proper interface and port, an error will be logged and the daemon will exit.</source>
          <target state="translated">데몬은 Telnet 또는 HTTP 명령을 통해 종료 될 때까지 계속 실행되어 중지하도록 지시합니다. Zookeeper에 연결하지 못했거나 적절한 인터페이스 및 포트에 바인드 할 수없는 등의 오류가 발생하면 오류가 기록되고 디먼이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="00e0f033f646c3e9721702fe4fb9558fb456f9b6" translate="yes" xml:space="preserve">
          <source>The data table above would be stored as:</source>
          <target state="translated">위의 데이터 테이블은 다음과 같이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0608e7ddc139367bd4dd93c9e54b570b70503e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;/annotation&lt;/code&gt; endpoint deals with one notation at a time. The &lt;code&gt;/annotation/bulk&lt;/code&gt; endpoint allows for adding or updating multiple annotations at a time.</source>
          <target state="translated">기본 &lt;code&gt;/annotation&lt;/code&gt; 엔드 포인트는 한 번에 하나의 표기법을 처리합니다. &lt;code&gt;/annotation/bulk&lt;/code&gt; 엔드 포인트는 한 번에 여러 주석을 추가하거나 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3f92cf92e007b1a65a3368774fdbb20337fd33" translate="yes" xml:space="preserve">
          <source>The default OpenTSDB serializer parses and returns JSON formatted data. Below you'll find details about the serializer and request parameters that affect only the the JSON serializer. If the serializer has extra parameters for a specific endpoint, they'll be listed below.</source>
          <target state="translated">기본 OpenTSDB 시리얼 라이저는 JSON 형식의 데이터를 구문 분석하고 반환합니다. 아래는 serializer 및 JSON serializer에만 영향을 미치는 요청 매개 변수에 대한 세부 정보를 제공합니다. 시리얼 라이저에 특정 엔드 포인트에 대한 추가 매개 변수가있는 경우 아래에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b5225bbf06ce02d610354ecb466517ea92482f" translate="yes" xml:space="preserve">
          <source>The default for the UI is to aggregate each time series for each host by adding them together (sum). What this means is, TSD is taking the three time series with this metric (host=A, B and C) and adding their values together to come up with the total hits by all web servers at a given time . Note you don't need to send your datapoints at exactly the same time, the TSD will figure it out. So, if each of your hosts was serving 1000 hits per second each at some point in time, the graph would show 3000. What if you wanted to show about how many hits each web server was serving? Two ways. If you just care about the average that each web server was serving, just change the Aggregator method from sum to avg. You can also try the others (max, min) to see the maximum or minimum value. More aggregation functions are in the works (percentiles, etc.). This is done on a per-interval basis , so if at some point in time one of your webservers was serving 50 QPS and the others were serving 100 and later a different webserver was serving 50 QPS and the others were serving 100, for these two points the Min would be 50. In other words it doesn't figure out which time series was the total minimum and just show you that host plot. The other way to see how many hits each web server is serving? This is where we look at the tag fields.</source>
          <target state="translated">UI의 기본값은 각 호스트에 대한 각 시계열을 합산하여 합산하는 것입니다 (sum). 이것이 의미하는 바, TSD는이 지표 (host = A, B 및 C)로 3 개의 시계열을 취하고 주어진 시간에 모든 웹 서버의 총 적중을 산출하기 위해 그 값을 더합니다. 데이터 포인트를 정확히 동시에 전송할 필요는 없으며 TSD가이를 파악합니다. 따라서 각 호스트가 특정 시점에 초당 1000 개의 조회를 제공 한 경우 그래프에 3000이 표시됩니다. 각 웹 서버가 제공하는 조회 수를 표시하려면 어떻게해야합니까? 두 가지 방법. 각 웹 서버가 제공 한 평균에 관심이있는 경우 집계 방법을 합계에서 평균으로 변경하면됩니다. 다른 값 (최대, 최소)을 사용하여 최대 값 또는 최소값을 볼 수도 있습니다. 더 많은 집계 함수가 백분위 수 등의 작업에 있습니다.이는 간격별로 수행되므로 특정 시점에서 웹 서버 중 하나가 50 QPS를 제공하고 다른 웹 서버가 100을 제공하고 나중에 다른 웹 서버가 50 QPS를 제공하고 다른 웹 서버가 50 QPS를 제공하는 경우 다른 두 개는 100을 제공하는 경우 즉, 최소값은 50이됩니다. 즉, 어떤 최소 시계열이 총 최소값인지 파악하지 못하고 해당 호스트 플롯 만 표시합니다. 각 웹 서버가 얼마나 많은 조회수를 제공하는지 확인하는 다른 방법은 무엇입니까? 여기서 태그 필드를 볼 수 있습니다.t 총계가 어느 시계열인지 파악하고 해당 호스트 도표를 보여줍니다. 각 웹 서버가 얼마나 많은 조회수를 제공하는지 확인하는 다른 방법은 무엇입니까? 여기서 태그 필드를 볼 수 있습니다.t 총계가 어느 시계열인지 파악하고 해당 호스트 도표를 보여줍니다. 각 웹 서버가 얼마나 많은 조회수를 제공하는지 확인하는 다른 방법은 무엇입니까? 여기서 태그 필드를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f12b686f4b6de6773c99daafb597141723b62b" translate="yes" xml:space="preserve">
          <source>The default output for &lt;code&gt;scan&lt;/code&gt; is a raw dump of the rows and columns that match the given queries. This is useful in debugging situations such as data point collisions or encoding issues. As the output includes raw byte arrays and the format changes slightly depending on the data, it is not easily machine paresable.</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; 의 기본 출력 은 주어진 쿼리와 일치하는 행과 열의 원시 덤프입니다. 데이터 포인트 충돌 또는 인코딩 문제와 같은 상황을 디버깅하는 데 유용합니다. 출력에 원시 바이트 배열이 포함되고 형식에 따라 데이터에 따라 형식이 약간 변경되므로 쉽게 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02e21c2cebb9ebadbe23edf09f25124ac4eaaeac" translate="yes" xml:space="preserve">
          <source>The different metric names included in the expression</source>
          <target state="translated">식에 포함 된 다른 메트릭 이름</target>
        </trans-unit>
        <trans-unit id="563d3e773d2e2edbd26dd4ba5a6f0bfba07628f6" translate="yes" xml:space="preserve">
          <source>The documentation for each endpoint listed below will contain details about how to use that endpoint. Eahc page will contain a description of the endpoint, what verbs are supported, the fields in a request, fields in a respone and examples.</source>
          <target state="translated">아래에 나열된 각 엔드 포인트에 대한 문서에는 해당 엔드 포인트 사용 방법에 대한 세부 사항이 포함되어 있습니다. Eahc 페이지에는 엔드 포인트에 대한 설명, 지원되는 동사, 요청의 필드, 응답의 필드 및 예제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="489d7dad3ad92f6c176eada509f15bb5a1140a27" translate="yes" xml:space="preserve">
          <source>The easiest way to get started with OpenTSDB is to open up a terminal or telnet client, connect to your TSD and issue a &lt;code&gt;put&lt;/code&gt; command and hit 'enter'. If you are writing a program, simply open a socket, print the string command with a new line and send the packet. The telnet command format is:</source>
          <target state="translated">OpenTSDB를 시작하는 가장 쉬운 방법은 터미널 또는 텔넷 클라이언트를 열고 TSD에 연결 한 후 &lt;code&gt;put&lt;/code&gt; 명령을 실행하고 'enter'를 누르는 것입니다. 프로그램을 작성하는 경우 소켓을 열고 새 줄로 문자열 명령을 인쇄 한 후 패킷을 보내십시오. 텔넷 명령 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67dea75abaa4aadbf40544a29fd55f78fb7a47c0" translate="yes" xml:space="preserve">
          <source>The end time for the query. If left out, the end is &lt;em&gt;now&lt;/em&gt;</source>
          <target state="translated">쿼리 종료 시간 빠지면 끝은 &lt;em&gt;이제&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1421c0901110c8ca97d08883a6a667427626a477" translate="yes" xml:space="preserve">
          <source>The exception so far has been the introduction of salted rows in 2.2.0. Disabled by default, using this feature requires creating a new HBase table with a new set of pre-splits and modifying the configuration of every TSD to use the new table with salting enabled. The schema for salted and unsalted tables is incompatible so if users have a lot of data in a previous table, it may be best to leave a few TSDs running to query against the old table and new TSDs to write to and read from the new salted table. For smaller amounts of data, the &lt;a href=&quot;user_guide/cli/scan&quot;&gt;&lt;em&gt;scan&lt;/em&gt;&lt;/a&gt; tool can be used to export and re-import your data.</source>
          <target state="translated">지금까지 예외는 2.2.0에서 소금에 절인 행을 도입 한 것입니다. 기본적으로 사용하지 않도록 설정하면이 기능을 사용하려면 새로운 사전 분할 세트를 사용하여 새 HBase 테이블을 작성하고 모든 테이블 구성을 수정하여 새 테이블을 솔팅이 사용되도록 설정해야합니다. 소금에 절인 테이블과 소금에 절인 테이블에 대한 스키마가 호환되지 않으므로 사용자가 이전 테이블에 많은 데이터가있는 경우 이전 테이블에 대해 쿼리하기 위해 몇 개의 TSD를 실행하고 새 테이블에 대한 새 TSD에 대해 읽고 쓰려면 새 TSD를 남겨 두는 것이 가장 좋습니다. 표. 적은 양의 데이터의 경우 &lt;a href=&quot;user_guide/cli/scan&quot;&gt;&lt;em&gt;스캔&lt;/em&gt;&lt;/a&gt; 도구를 사용하여 데이터를 내보내고 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f1f82119554290d1086f80c8f289712fc2e7e7" translate="yes" xml:space="preserve">
          <source>The existing UID name</source>
          <target state="translated">기존 UID 이름</target>
        </trans-unit>
        <trans-unit id="fd47bdebd4b7e0aae03c785f9eed4d0fa343cf79" translate="yes" xml:space="preserve">
          <source>The expression ID the output matches</source>
          <target state="translated">출력이 일치하는 표현식 ID</target>
        </trans-unit>
        <trans-unit id="a3cfd8e05ed701d61e15b3c6fc6e98f2bbff37cd" translate="yes" xml:space="preserve">
          <source>The expression to execute</source>
          <target state="translated">실행할 식</target>
        </trans-unit>
        <trans-unit id="c7cda25d432adec655738db531a0d578e5011d69" translate="yes" xml:space="preserve">
          <source>The fields and examples below refer to the default JSON serializer.</source>
          <target state="translated">아래의 필드와 예제는 기본 JSON 시리얼 라이저를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eda8250ed6ae8ff2bb5698bf327b530554ee150e" translate="yes" xml:space="preserve">
          <source>The filter expression to evaluate and depends on the filter being used</source>
          <target state="translated">평가할 필터 표현식이며 사용중인 필터에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ec7cb1415ec42139dc99bc02e58a51d0cf10d7da" translate="yes" xml:space="preserve">
          <source>The filter to use when fetching this metric. It must match a filter in the filters array</source>
          <target state="translated">이 측정 항목을 가져올 때 사용할 필터입니다. 필터 배열의 필터와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="aedda4e03a58e0682434ffdc05f2df1e5ee28489" translate="yes" xml:space="preserve">
          <source>The first column is a timestamp, the second is the average latency for that 30 second window, and the third is the type of request we're talking about. If you run your cron job on a day worth of logs, you'll end up with 8640 such lines. In order to import those into OpenTSDB, you need to adjust your cron job slightly to produce its output in the following format:</source>
          <target state="translated">첫 번째 열은 타임 스탬프이고 두 번째 열은 30 초 동안의 평균 대기 시간이며 세 번째 열은 우리가 이야기하는 요청 유형입니다. 하루 동안의 로그에서 크론 작업을 실행하면 8640 줄이 생깁니다. 이들을 OpenTSDB로 가져 오려면 cron 작업을 약간 조정하여 다음 형식으로 출력을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1d51c08dde0f40971599ecc76a1bea5bec1d5cc" translate="yes" xml:space="preserve">
          <source>The first sticking point folks run into is ''uid assignment''. Every string for a metric, tag key and tag value must be assigned a UID before the data point can be stored. For example, the metric &lt;code&gt;sys.cpu.user&lt;/code&gt; may be assigned a UID of &lt;code&gt;000001&lt;/code&gt; the first time it is encountered by a TSD. This assignment takes a fair amount of time as it must fetch an available UID, write a UID to name mapping and a name to UID mapping, then use the UID to write the data point's row key. The UID will be stored in the TSD's cache so that the next time the same metric comes through, it can find the UID very quickly.</source>
          <target state="translated">The first sticking point folks run into is ''uid assignment''. Every string for a metric, tag key and tag value must be assigned a UID before the data point can be stored. For example, the metric &lt;code&gt;sys.cpu.user&lt;/code&gt; may be assigned a UID of &lt;code&gt;000001&lt;/code&gt; the first time it is encountered by a TSD. This assignment takes a fair amount of time as it must fetch an available UID, write a UID to name mapping and a name to UID mapping, then use the UID to write the data point's row key. The UID will be stored in the TSD's cache so that the next time the same metric comes through, it can find the UID very quickly.</target>
        </trans-unit>
        <trans-unit id="5bda1276e1087b43dceacf7ef436f70ff364207f" translate="yes" xml:space="preserve">
          <source>The fix is to delete the forward maps for all names that map to the same UID. Then the UID is given a new name that is a dot seperated concatenation of the previous names with an &quot;fsck&quot; prefix. E.g. in the example above we would have a new name of &quot;fsck.bar.foo&quot;. This name may be used to access data from the corrupt time series. The next time data is written for the errant names, new UIDs will be assigned to each and new time series created.</source>
          <target state="translated">해결 방법은 동일한 UID에 매핑되는 모든 이름의 정방향 맵을 삭제하는 것입니다. 그런 다음 UID에 &quot;fsck&quot;접두사가있는 이전 이름의 점으로 분리 된 새 이름이 지정됩니다. 예를 들어 위의 예에서 &quot;fsck.bar.foo&quot;라는 새로운 이름을 갖게됩니다. 이 이름은 손상된 시계열의 데이터에 액세스하는 데 사용될 수 있습니다. 다음에 잘못된 이름에 대한 데이터를 쓸 때 새로운 UID가 생성 된 각 시계열에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="33888d85e4774941d6ae808e9100e601d835527b" translate="yes" xml:space="preserve">
          <source>The fix is to restore the missing reverse map.</source>
          <target state="translated">해결 방법은 누락 된 리버스 맵을 복원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a5be541b1898ab9beb07b9dc54e70a221b916a6c" translate="yes" xml:space="preserve">
          <source>The following fields are required for this endpoint.</source>
          <target state="translated">이 엔드 포인트에는 다음 필드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d14021537cbf1dea9a206e688d7202d686d5851" translate="yes" xml:space="preserve">
          <source>The following fields are used for this endpoint</source>
          <target state="translated">이 엔드 포인트에 사용되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40a490344f5c8df49584a493584f5de67ccb626d" translate="yes" xml:space="preserve">
          <source>The following fields can be used for all rule endpoint requests:</source>
          <target state="translated">모든 규칙 엔드 포인트 요청에 다음 필드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dc00ec9a4fb8b8a220ee32cdc8f38b0773a3c0" translate="yes" xml:space="preserve">
          <source>The following fields can be used for all tree endpoint requests:</source>
          <target state="translated">모든 트리 엔드 포인트 요청에 다음 필드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17677b932c406b4853ef0fea88d650bebddc8056" translate="yes" xml:space="preserve">
          <source>The following fields can be used to request a branch. Only one or the other may be used.</source>
          <target state="translated">지점을 요청하는 데 다음 필드를 사용할 수 있습니다. 하나만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b733e0ace0e2c16ab424bf1f42485c504235c6c7" translate="yes" xml:space="preserve">
          <source>The following is a description of the aggregation functions available in OpenTSDB.</source>
          <target state="translated">다음은 OpenTSDB에서 사용 가능한 집계 함수에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="d314305af8f5ea00840d2075c12b927b65a9ff3a" translate="yes" xml:space="preserve">
          <source>The following is a list of errors and/or fixes that can be found or performed with fsck.</source>
          <target state="translated">다음은 fsck로 발견하거나 수행 할 수있는 오류 및 / 또는 수정 사항 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f3640dec83901a77bacdb01cd6696e4aad98c809" translate="yes" xml:space="preserve">
          <source>The following is a list of example queries using an example data set. We'll illustrate a number of common query types that may be encountered so you can get an understanding of how the query system works. Each time series in the example set has only a single data point stored and the UIDs have been truncated to a single byte to make it easier to read. The example queries are all &lt;em&gt;Metric&lt;/em&gt; queries from the HTTP API and only show the &lt;code&gt;m=&lt;/code&gt; component. See &lt;a href=&quot;../../api_http/query/index&quot;&gt;&lt;em&gt;/api/query&lt;/em&gt;&lt;/a&gt; for details. If you are using a CLI tool, the query format will differ slightly so read the documentation for the particular command.</source>
          <target state="translated">다음은 예제 데이터 세트를 사용하는 예제 쿼리 목록입니다. 쿼리 시스템의 작동 방식을 이해할 수 있도록 발생할 수있는 여러 가지 일반적인 쿼리 유형을 설명합니다. 예제 세트의 각 시계열에는 단일 데이터 포인트 만 저장되어 있으며 UID는 읽기 쉽도록 단일 바이트로 잘 렸습니다. 예제 쿼리는 HTTP API의 모든 &lt;em&gt;메트릭&lt;/em&gt; 쿼리 &lt;code&gt;m=&lt;/code&gt; 구성 요소 만 표시합니다 . 자세한 내용은 &lt;a href=&quot;../../api_http/query/index&quot;&gt;&lt;em&gt;/ api / query&lt;/em&gt;&lt;/a&gt; 를 참조하십시오. CLI 도구를 사용하는 경우 조회 형식이 약간 다르므로 특정 명령에 대한 문서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="2fe0337727548d1bffb65cfa2a3e693e34df1285" translate="yes" xml:space="preserve">
          <source>The following is a list of query string parameters that are used by OpenTSDB across the entire API. Don't try to overload their use please:</source>
          <target state="translated">다음은 전체 API에서 OpenTSDB가 사용하는 쿼리 문자열 매개 변수 목록입니다. 과부하를 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="84a8c6027630480ec102b4f89cfdece34f0d7903" translate="yes" xml:space="preserve">
          <source>The following is a sample Varnish configuration recommended for use with OpenTSDB. It uses a slightly custom load balancing strategy to achieve optimal cache hit rate at the TSD level. This configuration requires at least Varnish 2.1.0 to run, but using Varnish 3.0 or above is strongly recommended.</source>
          <target state="translated">다음은 OpenTSDB와 함께 사용하도록 권장되는 샘플 니스 구성입니다. 약간의 사용자 정의로드 밸런싱 전략을 사용하여 TSD 레벨에서 최적의 캐시 적중률을 달성합니다. 이 구성을 실행하려면 Varnish 2.1.0 이상이 필요하지만 Varnish 3.0 이상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bba2289969bbd2bae75f0f262b70437d8cef1b8e" translate="yes" xml:space="preserve">
          <source>The following is a table of configuration options for all tools. When applicable, the corresponding command line override is provided. Please note that individual command line tools may have their own values so see their documentation for details.</source>
          <target state="translated">다음은 모든 도구에 대한 구성 옵션 표입니다. 적용 가능한 경우 해당 명령 행 대체가 제공됩니다. 개별 명령 줄 도구에는 고유 한 값이있을 수 있으므로 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff54a7c5820d0e7fe994cda1943a845462bc49ff" translate="yes" xml:space="preserve">
          <source>The following is a table of required and optional parameters to run OpenTSDB with Bigtable. These are in addition to the standard TSD configuration parameters from &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 Bigtable과 함께 OpenTSDB를 실행하기위한 필수 및 선택적 매개 변수 표입니다. 이것들은 &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt; 의 표준 TSD 구성 매개 변수에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="531073ca8bb5b65d21144d46d03a5bac3094991f" translate="yes" xml:space="preserve">
          <source>The following is a table with required and optional parameters to run OpenTSDB with Cassandra. These are in addition to the standard TSD configuration parameters from &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">다음은 Cassandra와 함께 OpenTSDB를 실행하기위한 필수 및 선택적 매개 변수가있는 테이블입니다. 이것들은 &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt; 의 표준 TSD 구성 매개 변수에 추가됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1e2f5f0a7dcdba3c71f7c4381c8318b55a42749" translate="yes" xml:space="preserve">
          <source>The following options are supported via query string:</source>
          <target state="translated">쿼리 문자열을 통해 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8e1faa1a1e775dd96dfabf4eb2a5d9b9c234557e" translate="yes" xml:space="preserve">
          <source>The following rules apply to metric and tag values:</source>
          <target state="translated">다음 규칙이 메트릭 및 태그 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3f99a3b8e96e1e2736d8433b03395c1dc3118ec" translate="yes" xml:space="preserve">
          <source>The following will be returned if &lt;code&gt;tsd.core.auto_create_metrics&lt;/code&gt; are disabled.</source>
          <target state="translated">&lt;code&gt;tsd.core.auto_create_metrics&lt;/code&gt; 가 비활성화 된 경우 다음이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b94da3c91a0402e08d50f9828d0b058c8a95a98" translate="yes" xml:space="preserve">
          <source>The format is the same as the Telnet &lt;code&gt;put&lt;/code&gt; interface.</source>
          <target state="translated">형식은 Telnet &lt;code&gt;put&lt;/code&gt; 인터페이스 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5dab0ae626d3fdeb7c3bbf2adec77e86b2808766" translate="yes" xml:space="preserve">
          <source>The full class name of the storage exception handler plugin you wish to use.</source>
          <target state="translated">사용하려는 스토리지 예외 핸들러 플러그인의 전체 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d248d767a2e64201569e76a3f7f88402ce8f7143" translate="yes" xml:space="preserve">
          <source>The full name of a metric in the system. Must be the complete name. Case sensitive</source>
          <target state="translated">시스템에서 측정 항목의 전체 이름입니다. 완전한 이름이어야합니다. 대소 문자 구분</target>
        </trans-unit>
        <trans-unit id="4b3c23f056197444f6f471666f9ee3d767d47114" translate="yes" xml:space="preserve">
          <source>The full or relative path to an OpenTSDB &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt; file. If this parameter is not provided, the command will attempt to load the default config file.</source>
          <target state="translated">OpenTSDB &lt;a href=&quot;../configuration&quot;&gt;&lt;em&gt;구성&lt;/em&gt;&lt;/a&gt; 파일 의 전체 또는 상대 경로 입니다. 이 매개 변수가 제공되지 않으면 명령은 기본 구성 파일로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="8202158d85e13e0e77f0ff9720a58abe54f41c3a" translate="yes" xml:space="preserve">
          <source>The full path to a location where temporary files can be written. E.g. /tmp/opentsdb</source>
          <target state="translated">임시 파일을 쓸 수있는 위치의 전체 경로입니다. 예를 들어 / tmp / opentsdb</target>
        </trans-unit>
        <trans-unit id="803a3ab6e5ef239d01180a2eac92d3e15b9e4297" translate="yes" xml:space="preserve">
          <source>The full path to the JSON formatted key file associated with the service account you want to use for Bigtable access. Download this from your cloud console.</source>
          <target state="translated">Bigtable 액세스에 사용하려는 서비스 계정과 연관된 JSON 형식 키 파일의 전체 경로입니다. 클라우드 콘솔에서 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="9ec4ea9b88f6564030fcb7c270a717141d5e7b29" translate="yes" xml:space="preserve">
          <source>The full specification for a metric query string sub query is as follows:</source>
          <target state="translated">메트릭 쿼리 문자열 하위 쿼리의 전체 사양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6414a465be1ce4ed8e3e07f2d841e2479e1bb875" translate="yes" xml:space="preserve">
          <source>The full tree if successfully parsed</source>
          <target state="translated">성공적으로 구문 분석 된 경우 전체 트리</target>
        </trans-unit>
        <trans-unit id="81bdfadb95bb3d8f40c806cda84ac9009d156d1b" translate="yes" xml:space="preserve">
          <source>The general process for creating and building a tree is as follows:</source>
          <target state="translated">트리를 만들고 구축하는 일반적인 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d70f82c07d5d5e2512211f3851667d2f0bf67d7b" translate="yes" xml:space="preserve">
          <source>The global aggregation function to use for all metrics. It may be overridden on a per metric basis.</source>
          <target state="translated">모든 메트릭에 사용할 글로벌 집계 함수입니다. 메트릭별로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4e4c3a8ca7ca52992b61ebea3096c1cc482ccd7" translate="yes" xml:space="preserve">
          <source>The goal for this set of rules is to order our timeseres by data center, then host, then by metric. Our company may have thousands of servers around the world so it doesn't make sense to display all of them in one branch of the tree, rather we want to group them by data center and let users drill down as needed.</source>
          <target state="translated">이 규칙 세트의 목표는 데이터 센터, 호스트, 메트릭별로 시간 순서를 정렬하는 것입니다. 우리 회사에는 전 세계에 수천 대의 서버가있을 수 있으므로 모든 서버를 트리의 한 지점에 표시하는 것이 이치에 맞지 않습니다. 오히려 데이터 센터별로 서버를 그룹화하고 사용자가 필요에 따라 드릴 다운하도록하려고합니다.</target>
        </trans-unit>
        <trans-unit id="af0db921ea5ba40549f69c4d43ff6ff7aea6ac1b" translate="yes" xml:space="preserve">
          <source>The graph area that displays query results</source>
          <target state="translated">쿼리 결과를 표시하는 그래프 영역</target>
        </trans-unit>
        <trans-unit id="a9dbccd7eb6802186d2065e99df37084d777f9bf" translate="yes" xml:space="preserve">
          <source>The grep sub command performs a regular expression search for the given UID type and returns a list of all UID names that match the expression. Fields required for the grep command include:</source>
          <target state="translated">grep sub 명령은 주어진 UID 유형에 대한 정규 표현식 검색을 수행하고 표현식과 일치하는 모든 UID 이름 목록을 리턴합니다. grep 명령에 필요한 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1c8d094bd817bf3589fad4441b9b388baf3bff3" translate="yes" xml:space="preserve">
          <source>The hexadecimal TSUID for the time series</source>
          <target state="translated">시계열에 대한 16 진 TSUID</target>
        </trans-unit>
        <trans-unit id="7031078bbb9a1a9bf3b44a19ca648f0328f00cb3" translate="yes" xml:space="preserve">
          <source>The import command enables bulk loading of time series data into OpenTSDB. You provide one or more files and OpenTSDB will parse and load the data. Data must be formatted in the Telnet &lt;code&gt;put&lt;/code&gt; style with one data point per line in a text file. Each file may optionally be compressed with GZip and if so, must end with the &lt;code&gt;.gz&lt;/code&gt; extension.</source>
          <target state="translated">import 명령을 사용하면 시계열 데이터를 OpenTSDB로 대량로드 할 수 있습니다. 하나 이상의 파일을 제공하면 OpenTSDB가 데이터를 구문 분석하고로드합니다. 텍스트 파일에서 한 줄에 하나의 데이터 포인트를 사용 하여 Telnet &lt;code&gt;put&lt;/code&gt; 스타일로 데이터 형식을 지정해야 합니다. 각 파일은 선택적으로 GZip으로 압축 될 수 있으며, 그렇다면 &lt;code&gt;.gz&lt;/code&gt; 확장자로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="8213f17f3af6cc9c5a3bf467164339e89f731295" translate="yes" xml:space="preserve">
          <source>The import format is the same as a Telnet style &lt;code&gt;put&lt;/code&gt; command.</source>
          <target state="translated">가져 오기 형식은 Telnet 스타일 &lt;code&gt;put&lt;/code&gt; 명령 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="31df8054b02c20495ba31f9f9e8b30bf72b2cf92" translate="yes" xml:space="preserve">
          <source>The index in the data point arrays that the meta refers to</source>
          <target state="translated">메타가 참조하는 데이터 포인트 배열의 인덱스</target>
        </trans-unit>
        <trans-unit id="72bf1f3a2c0e64f6ae7f279a87245d5610b367d8" translate="yes" xml:space="preserve">
          <source>The index of the sub query in the original user supplied query list.</source>
          <target state="translated">원래 사용자 제공 쿼리 목록에서 하위 쿼리의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="c3252afe50e71a23c38fa8efcdc8c8103ec74829" translate="yes" xml:space="preserve">
          <source>The information printed will change depending on the JVM you are running the TSD under. In particular, the pools and GC sections will differ quite a bit.</source>
          <target state="translated">인쇄 된 정보는 TSD를 실행중인 JVM에 따라 변경됩니다. 특히 풀과 GC 섹션은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a0c3ab992cb930f99e0b5d8b697c5fbba8984186" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;min&lt;/code&gt;, it returns the largest data point from all of the time series or within a time span. This function will perform linear interpolation across time series. It's useful for looking at the upper bounds of gauge metrics.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 의 역수는 모든 시계열 또는 시간 범위 내에서 가장 큰 데이터 포인트를 반환합니다. 이 함수는 시계열에 걸쳐 선형 보간을 수행합니다. 게이지 메트릭의 상한을 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d26c769e2c822b35c01c88768f58bc1dbcb75baf" translate="yes" xml:space="preserve">
          <source>The join object controls how the various time series for a given metric are merged within an expression. The two basic operations supported at this time are the union and intersection operators. Additional flags control join behavior.</source>
          <target state="translated">조인 개체는 주어진 메트릭에 대한 다양한 시계열이 식 내에서 병합되는 방식을 제어합니다. 현재 지원되는 두 가지 기본 작업은 공용 및 교차 연산자입니다. 추가 플래그는 조인 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="293bd7323da60f7f1f043f2e95d57dd83d999d5e" translate="yes" xml:space="preserve">
          <source>The kind of data stored in the timeseries such as &lt;code&gt;counter&lt;/code&gt;, &lt;code&gt;gauge&lt;/code&gt;, &lt;code&gt;absolute&lt;/code&gt;, etc. These may be defined later but they should be similar to Data Source Types in an &lt;a href=&quot;http://oss.oetiker.ch/rrdtool&quot;&gt;RRD&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;counter&lt;/code&gt; , &lt;code&gt;gauge&lt;/code&gt; , &lt;code&gt;absolute&lt;/code&gt; 등과 같은 시계열에 저장된 데이터의 종류 . 나중에 정의 할 수 있지만 &lt;a href=&quot;http://oss.oetiker.ch/rrdtool&quot;&gt;RRD의&lt;/a&gt; 데이터 소스 유형과 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="c870f06ddc45ae975a4dab298cf2f95624cc5c3d" translate="yes" xml:space="preserve">
          <source>The last 4 bits of either column type describe the data stored. The first bit is a flag that indicates whether or not the value is an integer or floating point. A value of 0 indicates an integer, 1 indicates a float. The last 3 bits indicate the length of the data, offset by 1. A value of &lt;code&gt;000&lt;/code&gt; indicates a 1 byte value while &lt;code&gt;010&lt;/code&gt; indicates a 2 byte value. The length must reflect a value of 1, 2, 4 or 8. Anything else indicates an error.</source>
          <target state="translated">열 유형의 마지막 4 비트는 저장된 데이터를 설명합니다. 첫 번째 비트는 값이 정수인지 부동 소수점인지를 나타내는 플래그입니다. 값이 0이면 정수, 1은 부동 소수점을 나타냅니다. 마지막 3 비트는 데이터 길이를 나타내며 1만큼 오프셋됩니다. 값 &lt;code&gt;000&lt;/code&gt; 은 1 바이트 값을 나타내고 &lt;code&gt;010&lt;/code&gt; 은 2 바이트 값을 나타냅니다. 길이는 1, 2, 4 또는 8의 값을 반영해야합니다. 다른 것은 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ff7cca3f1d147ed538ed4e121c61283152e22c0f" translate="yes" xml:space="preserve">
          <source>The last byte of a compacted value is for storing meta data. It will usually be &lt;code&gt;0&lt;/code&gt; if all of the data points are encoded in seconds or milliseconds. If there is a mixture of seconds and milliseconds will be set to &lt;code&gt;1&lt;/code&gt;. If the value is something else then it may be from a future version of OpenTSDB or the column may be invalid.</source>
          <target state="translated">압축 된 값의 마지막 바이트는 메타 데이터를 저장하기위한 것입니다. 모든 데이터 포인트가 초 또는 밀리 초로 인코딩 된 경우 일반적으로 &lt;code&gt;0&lt;/code&gt; 입니다. 초와 밀리 초가 혼합되어 있으면 &lt;code&gt;1&lt;/code&gt; 로 설정됩니다 . 값이 다른 값이면 향후 버전의 OpenTSDB에서 왔거나 열이 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="301934179c5fc6daaf00f7d5e08f485f36b5d21b" translate="yes" xml:space="preserve">
          <source>The level in the rule heirarchy where the rule resides. Must be 0 or greater.</source>
          <target state="translated">규칙이있는 규칙 계층의 수준입니다. 0 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4077d304412f517af725dfa2c9999ad3e8681950" translate="yes" xml:space="preserve">
          <source>The list of nodes in your Cassandra cluster. These can be formatted</source>
          <target state="translated">Cassandra 클러스터의 노드 목록 이들은 형식화 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ffbb8f16b8d5d8ff9ebef8e03a17736af78b6ef4" translate="yes" xml:space="preserve">
          <source>The list of tag pairs used for lookup queries. May be an empty list.</source>
          <target state="translated">조회 쿼리에 사용되는 태그 쌍 목록입니다. 빈 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2628768948ce66614e7f32faf395f06cb2046dfe" translate="yes" xml:space="preserve">
          <source>The list of tag pairs used for the lookup. May be an empty list.</source>
          <target state="translated">조회에 사용되는 태그 쌍 목록입니다. 빈 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13b43e7f51c5e1d9f9200d7c400b06da7719c26d" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;rate&lt;/code&gt; if the timeseries represents a counter and the results should be returned as delta per second</source>
          <target state="translated">시계열이 카운터를 나타내고 결과가 초당 델타로 반환되는 경우 리터럴 &lt;code&gt;rate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0e398c498a55222470992a4f8b53936a057819" translate="yes" xml:space="preserve">
          <source>The lookup command is the default for &lt;code&gt;uid&lt;/code&gt; used to lookup the UID assigned to a name or the name assinged to a UID for a given type.</source>
          <target state="translated">lookup 명령은 이름에 지정된 UID 또는 주어진 유형의 UID에 지정된 이름을 조회하는 데 사용되는 &lt;code&gt;uid&lt;/code&gt; 의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="b4ebef67ed7a2f73114e936f42125088e2ab671a" translate="yes" xml:space="preserve">
          <source>The maximum number of compaction calls inflight to HBase at any given time</source>
          <target state="translated">주어진 시간에 HBase에 기내 최대 압축 호출 수</target>
        </trans-unit>
        <trans-unit id="8d84e121f2dcad3d5d48c4788a379ffe7a669811" translate="yes" xml:space="preserve">
          <source>The maximum number of items returned in the result set. Currently the limit is ignored for lookup queries</source>
          <target state="translated">결과 집합에 반환 된 최대 항목 수입니다. 현재 조회 조회에 대한 제한이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dd17309f79612b9487ab0c28fc667e17491e35c" translate="yes" xml:space="preserve">
          <source>The maximum number of items returned in the result set. Note that the actual number returned may be less than the limit.</source>
          <target state="translated">결과 집합에 반환 된 최대 항목 수입니다. 반환 된 실제 수는 한도보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31d1e273849669598bd1b77738b99b3c83ebb638" translate="yes" xml:space="preserve">
          <source>The maximum number of suggested results to return. Must be greater than 0</source>
          <target state="translated">반환 할 최대 제안 결과 수입니다. 0보다 커야합니다</target>
        </trans-unit>
        <trans-unit id="bef9a441366c417a88dcd8019d29de54951a6b1a" translate="yes" xml:space="preserve">
          <source>The maximum number of tag values to include in the regular expression sent to storage during scanning for data. A larger value means more computation on the HBase region servers.</source>
          <target state="translated">데이터 스캔 중 스토리지로 전송되는 정규식에 포함 할 최대 태그 값 수입니다. 값이 클수록 HBase 리젼 서버에서 더 많은 계산을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a9d2780f4390fd2e8f8fff7a74e8092062fe8af0" translate="yes" xml:space="preserve">
          <source>The maximum number of tags allowed on a data point is defined by a constant (Const.MAX_NUM_TAGS), which at time of writing is 8. Metric names, tag names and tag values have to be made of alpha numeric characters, dash &quot;-&quot;, underscore &quot;_&quot;, period &quot;.&quot;, and forward slash &quot;/&quot;, as is enforced by the package-private function Tags.validateString.</source>
          <target state="translated">데이터 포인트에 허용되는 최대 태그 수는 상수 (Const.MAX_NUM_TAGS)로 정의되며, 기록시 8입니다. 메트릭 이름, 태그 이름 및 태그 값은 알파벳 숫자, 대시 &quot;-&quot;로 이루어져야합니다. , 밑줄 &quot;_&quot;, 마침표 &quot;.&quot;및 슬래시 &quot;/&quot;(패키지 전용 함수 Tags.validateString에 의해 강제 됨)</target>
        </trans-unit>
        <trans-unit id="95ecad35cea9de4aa2587448eeee4f37440434e5" translate="yes" xml:space="preserve">
          <source>The maximum number of tags allowed per data point. &lt;strong&gt;NOTE&lt;/strong&gt; Please be aware of the performance tradeoffs of overusing tags &lt;code&gt;writing&lt;/code&gt;</source>
          <target state="translated">데이터 포인트 당 허용되는 최대 태그 수입니다. &lt;strong&gt;참고&lt;/strong&gt; 태그 &lt;code&gt;writing&lt;/code&gt; 남용의 성능 상충 관계에 &lt;strong&gt;유의&lt;/strong&gt; 하십시오</target>
        </trans-unit>
        <trans-unit id="b7d7129af3c7c98986f0449813a701882ab2801c" translate="yes" xml:space="preserve">
          <source>The maximum request body size to support for incoming HTTP requests when chunking is enabled.</source>
          <target state="translated">청킹이 활성화 된 경우 들어오는 HTTP 요청을 지원하기위한 최대 요청 본문 크기입니다.</target>
        </trans-unit>
        <trans-unit id="07fedf03caa96a729453a5ca03f3574b5140aee8" translate="yes" xml:space="preserve">
          <source>The menu is a group of tabs that can be clicked for different options.</source>
          <target state="translated">메뉴는 다른 옵션을 위해 클릭 할 수있는 탭 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="e4534fce9cbba9e1f6bb5e382011540ca8c0c905" translate="yes" xml:space="preserve">
          <source>The meta section contains ordered information about each time series in the output arrays. The first element in the array will always have a &lt;code&gt;metrics&lt;/code&gt; value of &lt;code&gt;timestamp&lt;/code&gt; and no other data.</source>
          <target state="translated">메타 섹션에는 출력 배열의 각 시계열에 대한 순서 정보가 포함되어 있습니다. 배열의 첫 번째 요소는 항상 &lt;code&gt;timestamp&lt;/code&gt; 의 &lt;code&gt;metrics&lt;/code&gt; 값을 가지며 다른 데이터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fcb3e4a1d25a1275d034d4a978feaeef6b49e851" translate="yes" xml:space="preserve">
          <source>The metric should be a specific thing, like &quot;Ethernet packets&quot; but not be broken out into a particular instance of a thing. Generally you don't want to collect a metric like net.bytes.eth0, net.bytes.eth1, etc. Collect net.bytes and tag eth0 datapoints with iface=eth0, etc. Don't bother creating separate &quot;in&quot; and &quot;out&quot; metrics, either. Add the tag direction=in or direction=out. This way you can easily see the total network activity for a given box without having to plot a bunch of metrics. This still gives you the flexibility to drill down and just show activity for a particular interface, or just a particular direction.</source>
          <target state="translated">메트릭은 &quot;이더넷 패킷&quot;과 같은 특정 항목이어야하지만 특정 인스턴스로 분리되지 않아야합니다. 일반적으로 net.bytes.eth0, net.bytes.eth1 등과 같은 메트릭을 수집하지 않습니다. net.bytes를 수집하고 ifeth = eth0 등으로 eth0 데이터 포인트에 태그를 지정하십시오. 별도의 &quot;in&quot;및 &quot;out&quot;메트릭도. direction = in 또는 direction = out 태그를 추가하십시오. 이 방법을 사용하면 많은 메트릭을 플롯하지 않고도 주어진 상자의 총 네트워크 활동을 쉽게 볼 수 있습니다. 이것은 여전히 ​​특정 인터페이스 또는 특정 방향에 대한 활동을 드릴 다운하고 보여줄 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="68fad968f442475f6052d9d8569fd158a095b589" translate="yes" xml:space="preserve">
          <source>The metric used for the lookup</source>
          <target state="translated">조회에 사용되는 측정 항목</target>
        </trans-unit>
        <trans-unit id="9f001dcf6e3c76d3bb62a090fcde0de3d9bb7dd5" translate="yes" xml:space="preserve">
          <source>The metrics for a number of systems are generally strings with a separator, such as a period, to deliniate components of the metric. For example, &quot;sys.cpu.0.user&quot;. To build a useful tree, you can use a separator rule that will break apart the string based on a character sequence and create a branch or leaf from each individual value. Setting the separator to &quot;.&quot; for the previous example would yield three branches &quot;sys&quot;, &quot;cpu&quot;, &quot;0&quot; and one leaf &quot;user&quot;.</source>
          <target state="translated">여러 시스템의 메트릭은 일반적으로 메트릭의 구성 요소를 제거하기 위해 마침표와 같은 구분 기호가있는 문자열입니다. 예를 들어 &quot;sys.cpu.0.user&quot;입니다. 유용한 트리를 만들려면 문자 시퀀스를 기반으로 문자열을 분리하고 각 개별 값에서 분기 또는 리프를 만드는 구분 기호 규칙을 사용할 수 있습니다. 구분 기호를 &quot;.&quot;로 설정 이전 예제의 경우 세 가지 &quot;sys&quot;, &quot;cpu&quot;, &quot;0&quot;및 하나의 리프 &quot;user&quot;가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="197c77d451c0245ebb53006d01427a269dd7288f" translate="yes" xml:space="preserve">
          <source>The metrics list determines which metrics are included in the expression. There must be at least one metric.</source>
          <target state="translated">메트릭 목록은 식에 포함되는 메트릭을 결정합니다. 하나 이상의 측정 항목이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f5126c5f2e36e2ac9523a48cd2cd8511fa9f555" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;TSMeta&lt;/code&gt; custom field for the rule to operate on. Note that the &lt;code&gt;field&lt;/code&gt; value must also be configured or an exception will be raised.</source>
          <target state="translated">룰이 작동 할 &lt;code&gt;TSMeta&lt;/code&gt; 사용자 정의 필드 의 이름 . 점을 유의 &lt;code&gt;field&lt;/code&gt; 값도 구성해야합니다 또는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7f4161e82690ef9abdac3c461920adaec29c8742" translate="yes" xml:space="preserve">
          <source>The name of a field for the rule to operate on</source>
          <target state="translated">규칙이 작동 할 필드 이름</target>
        </trans-unit>
        <trans-unit id="1f71e67e8770a311101ecd79601ba5f301f02731" translate="yes" xml:space="preserve">
          <source>The name of a metric in OpenTSDB</source>
          <target state="translated">OpenTSDB의 메트릭 이름</target>
        </trans-unit>
        <trans-unit id="3141e988a778fa3abb1b298adf3935d588cf46fc" translate="yes" xml:space="preserve">
          <source>The name of a metric or a wildcard for lookup queries</source>
          <target state="translated">조회 쿼리에 대한 메트릭 또는 와일드 카드 이름</target>
        </trans-unit>
        <trans-unit id="9946f8e9c70c21bad1d1815dc355867cbb6eede6" translate="yes" xml:space="preserve">
          <source>The name of a metric stored in the system</source>
          <target state="translated">시스템에 저장된 메트릭의 이름</target>
        </trans-unit>
        <trans-unit id="154f60ab1cfc97b714ca839feaaf9c370570a974" translate="yes" xml:space="preserve">
          <source>The name of a policy to use. The values are listed in the table below</source>
          <target state="translated">사용할 정책의 이름입니다. 값은 아래 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="952dc822ea9c45e305f1e2a5fadfef8ff5ebd9e0" translate="yes" xml:space="preserve">
          <source>The name of a serializer to use for parsing input or formatting return data</source>
          <target state="translated">입력을 구문 분석하거나 리턴 데이터를 형식화하는 데 사용할 직렬 변환기의 이름</target>
        </trans-unit>
        <trans-unit id="6ad7fff4892ee1df7c5fdd2b1d335a261816055f" translate="yes" xml:space="preserve">
          <source>The name of an aggregation function to use. See &lt;a href=&quot;../aggregators&quot;&gt;&lt;em&gt;/api/aggregators&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">사용할 집계 함수의 이름입니다. &lt;a href=&quot;../aggregators&quot;&gt;&lt;em&gt;/ api / aggregators&lt;/em&gt;&lt;/a&gt; 참조&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc6cadd522f694d375e9ce2006bc816e8a699211" translate="yes" xml:space="preserve">
          <source>The name of the UID as given when the data point was stored or the UID assigned</source>
          <target state="translated">데이터 포인트가 저장되거나 UID가 할당 될 때 제공된 UID의 이름</target>
        </trans-unit>
        <trans-unit id="9d1c4944dbe72c2a59346de4713ee107a3e7fb01" translate="yes" xml:space="preserve">
          <source>The name of the filter from the API</source>
          <target state="translated">API의 필터 이름</target>
        </trans-unit>
        <trans-unit id="aa06645aaf46bec58acf4e979ffebe5cf374c6ce" translate="yes" xml:space="preserve">
          <source>The name of the filter to invoke. See &lt;a href=&quot;../config/filters&quot;&gt;&lt;em&gt;/api/config/filters&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">호출 할 필터의 이름입니다. &lt;a href=&quot;../config/filters&quot;&gt;&lt;em&gt;/ api / config / filters를&lt;/em&gt;&lt;/a&gt; 참조하십시오&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6f0779d2f9def81baa6f9ddd98795a23a3f7ee2" translate="yes" xml:space="preserve">
          <source>The name of the metric for the timeseries</source>
          <target state="translated">시계열에 대한 지표의 이름</target>
        </trans-unit>
        <trans-unit id="852cde5ce00c947cdc441c0a56b6af42f033ea69" translate="yes" xml:space="preserve">
          <source>The name of the metric you are storing</source>
          <target state="translated">저장중인 측정 항목의 이름</target>
        </trans-unit>
        <trans-unit id="8212085940dd7e7f01c6e6bc380c7d8100f0de94" translate="yes" xml:space="preserve">
          <source>The name of the serializer, suitable for use in the query string &lt;code&gt;serializer=&amp;lt;serializer_name&amp;gt;&lt;/code&gt; parameter</source>
          <target state="translated">쿼리 문자열 &lt;code&gt;serializer=&amp;lt;serializer_name&amp;gt;&lt;/code&gt; 매개 변수 에 사용하기에 적합한 serializer의 이름</target>
        </trans-unit>
        <trans-unit id="d44db74cd4c2937e6ae827ab9ca40472263d869a" translate="yes" xml:space="preserve">
          <source>The name of the tagk or custom tag associated with the value.</source>
          <target state="translated">값과 연관된 태그 또는 사용자 정의 태그의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3a454817298f6866ae8461fdb144eefe80785a2d" translate="yes" xml:space="preserve">
          <source>The new name UID name</source>
          <target state="translated">새로운 이름 UID 이름</target>
        </trans-unit>
        <trans-unit id="67ce3d2f0149204124a8c5fe35a4eddc7a825a5b" translate="yes" xml:space="preserve">
          <source>The notification area and tab area that serves as a menu</source>
          <target state="translated">메뉴 역할을하는 알림 영역 및 탭 영역</target>
        </trans-unit>
        <trans-unit id="3eb2ac45afc1849782be45ed57c78bbaba4ab1af" translate="yes" xml:space="preserve">
          <source>The number of RPCs queued and waiting for the connection handshake with the region server to complete</source>
          <target state="translated">대기하고 리젼 서버와의 연결 핸드 셰이크가 완료되기를 기다리는 RPC의 수</target>
        </trans-unit>
        <trans-unit id="b5decc4e8026138e6612b5a06b5bb4e02cbdce26" translate="yes" xml:space="preserve">
          <source>The number of RPCs queued in the batched RPC awaiting the next flush or the batch limit.</source>
          <target state="translated">다음 번 플러시 또는 배치 제한을 기다리는 배치 된 RPC에 대기중인 RPC의 수입니다.</target>
        </trans-unit>
        <trans-unit id="ebde0448e7b01c723866014a02096215a769165e" translate="yes" xml:space="preserve">
          <source>The number of asynchronous IO worker threads for Netty</source>
          <target state="translated">Netty의 비동기 IO 작업자 스레드 수</target>
        </trans-unit>
        <trans-unit id="8d1668ea1da5c6f32c0c80a1668c308cf8290b03" translate="yes" xml:space="preserve">
          <source>The number of bytes reported as free by the JVM's Runtime.freeMemory()</source>
          <target state="translated">JVM의 Runtime에서 사용 가능한 것으로보고 된 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ccc1b9d297c749e7d255593bf1f602227b7e45c0" translate="yes" xml:space="preserve">
          <source>The number of bytes reported as used by the JVM's Runtime.totalMemory()</source>
          <target state="translated">JVM의 Runtime에서 사용 된 것으로보고 된 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4371f76ac122c7eaf6d8c8559a31a5126b54571" translate="yes" xml:space="preserve">
          <source>The number of currently open Telnet and HTTP connections.</source>
          <target state="translated">현재 열려있는 텔넷 및 HTTP 연결 수</target>
        </trans-unit>
        <trans-unit id="9d5b1f7a15194a68e90df0bb8ff2d4736487420a" translate="yes" xml:space="preserve">
          <source>The number of data points emitted</source>
          <target state="translated">방출 된 데이터 포인트 수</target>
        </trans-unit>
        <trans-unit id="c9a3c5a5f093a4d48a74b515415e80faa2a104f6" translate="yes" xml:space="preserve">
          <source>The number of data points that could not be queued for storage</source>
          <target state="translated">스토리지를 위해 큐에 넣을 수없는 데이터 포인트 수</target>
        </trans-unit>
        <trans-unit id="715cd41b518e3ca970b77c3d42e38517a1d33696" translate="yes" xml:space="preserve">
          <source>The number of data points that were queued successfully for storage</source>
          <target state="translated">스토리지를 위해 큐에 대기 한 데이터 포인트 수</target>
        </trans-unit>
        <trans-unit id="d2ebaf6f797f2ac60a316c118f4f484c3aaf1e8d" translate="yes" xml:space="preserve">
          <source>The number of days of data points to retain for the given timeseries. &lt;strong&gt;Not Implemented&lt;/strong&gt;. When set to 0, the default, data is retained indefinitely.</source>
          <target state="translated">주어진 시계열에 대해 보유 할 데이터 포인트 수입니다. &lt;strong&gt;구현되지 않았습니다&lt;/strong&gt; . 기본값 인 0으로 설정하면 데이터가 무기한 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="078be455f49f4f44728254c8acc4782a4e75f2e3" translate="yes" xml:space="preserve">
          <source>The number of raw data points in the set</source>
          <target state="translated">세트의 원시 데이터 포인트 수</target>
        </trans-unit>
        <trans-unit id="6d4d27dfdb41acf84fe74e19c93b83d63c2c1dbe" translate="yes" xml:space="preserve">
          <source>The number of raw values wrapped into the result</source>
          <target state="translated">결과에 래핑 된 원시 값의 수</target>
        </trans-unit>
        <trans-unit id="ccdf739dfdf6cf8aad5aefe0d2b3ba0f5e4de4e7" translate="yes" xml:space="preserve">
          <source>The number of rows to scan for UID pre-loading.</source>
          <target state="translated">UID 사전로드를 스캔 할 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="635c891804ad141bbff5f915bc1ad20b10872afd" translate="yes" xml:space="preserve">
          <source>The number of salt buckets used to distribute load across regions. &lt;strong&gt;NOTE&lt;/strong&gt; Changing this value after writing data may cause TSUID based queries to fail.</source>
          <target state="translated">여러 지역에로드를 분배하는 데 사용되는 솔트 버킷 수입니다. &lt;strong&gt;참고&lt;/strong&gt; 데이터 쓰기 후이 값을 변경하면 TSUID 기반 쿼리가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3883dde14f93fcdd6d36e1486632673494034af8" translate="yes" xml:space="preserve">
          <source>The number of sockets opened to the Bigtable API for handling RPCs. For higher throughput consider increasing the channel count.</source>
          <target state="translated">RPC를 처리하기 위해 Bigtable API에 열린 소켓 수입니다. 처리량을 높이려면 채널 수를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="3abd99d3812e4addbf1124f9a64218572e553290" translate="yes" xml:space="preserve">
          <source>The number of threads to use when performing a full scan. The default is twice the number of CPU cores.</source>
          <target state="translated">전체 스캔을 수행 할 때 사용할 스레드 수입니다. 기본값은 CPU 코어 수의 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="3ac75df285786129827b182d163ce73c47b6ce6b" translate="yes" xml:space="preserve">
          <source>The number of unique tag values associated with a tag name</source>
          <target state="translated">태그 이름과 관련된 고유 한 태그 값의 수</target>
        </trans-unit>
        <trans-unit id="59978e2bbc1e833eb9a1b55f93dc249d6fd44740" translate="yes" xml:space="preserve">
          <source>The number of unique time series for a given metric</source>
          <target state="translated">주어진 측정 항목에 대한 고유 한 시계열 수</target>
        </trans-unit>
        <trans-unit id="2a830b13194a1d7bed520640d817a7b34e3efca9" translate="yes" xml:space="preserve">
          <source>The numeric value for the statistic</source>
          <target state="translated">통계량의 숫자 값</target>
        </trans-unit>
        <trans-unit id="85b2807e16754e68c2c7837689a5d497b679bec4" translate="yes" xml:space="preserve">
          <source>The only fix for this error is to delete the column by specifying the &lt;code&gt;--delete-bad-compacts&lt;/code&gt; flag.</source>
          <target state="translated">이 오류의 유일한 수정은 &lt;code&gt;--delete-bad-compacts&lt;/code&gt; 플래그 를 지정하여 열을 삭제하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b9f99483dcd547dd3bfe7940a3ff8af4244c38ae" translate="yes" xml:space="preserve">
          <source>The operator to use, either union or intersection</source>
          <target state="translated">유니온 또는 교차로를 사용할 연산자</target>
        </trans-unit>
        <trans-unit id="b76da30c69de974ffea9bde9c0a67763a01c072c" translate="yes" xml:space="preserve">
          <source>The order within a level where the rule resides. Must be 0 or greater.</source>
          <target state="translated">규칙이있는 레벨 내의 순서입니다. 0 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="31229ed69fdd674c054b7f05817e197642455f90" translate="yes" xml:space="preserve">
          <source>The original way of interacting with OpenTSDB was through a Telnet style API. A user or application simply had to open a socket to the TSD and start sending ASCII string commands and expect a response. This documentation lists the various commands provided by OpenTSDB.</source>
          <target state="translated">OpenTSDB와 상호 작용하는 원래 방법은 Telnet 스타일 API를 사용하는 것입니다. 사용자 나 응용 프로그램은 TSD에 대한 소켓을 열고 ASCII 문자열 명령 전송을 시작하고 응답을 기대해야했습니다. 이 문서는 OpenTSDB가 제공하는 다양한 명령을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="410dd2ba63c71e7590d28107510c57040e02aa1c" translate="yes" xml:space="preserve">
          <source>The output for log files and the stats page include other fields with single values as listed below:</source>
          <target state="translated">로그 파일 및 통계 페이지의 출력에는 아래 나열된 단일 값을 가진 다른 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b8c264d46abefbbc974d91484bbd8af29b5f6a" translate="yes" xml:space="preserve">
          <source>The output generated for a query depends heavily on the chosen serializer &lt;a href=&quot;../serializers/index&quot;&gt;&lt;em&gt;HTTP Serializers&lt;/em&gt;&lt;/a&gt;. A request may result in multiple sets of data returned, particularly if the request included multiple queries or grouping was requested. Some common fields included with each data set in the response will be:</source>
          <target state="translated">쿼리에 대해 생성 된 출력은 선택한 serializer &lt;a href=&quot;../serializers/index&quot;&gt;&lt;em&gt;HTTP Serializer&lt;/em&gt;&lt;/a&gt; 에 크게 좌우 됩니다. 요청에 여러 쿼리가 포함되거나 그룹화가 요청 된 경우 요청에 따라 여러 데이터 집합이 반환 될 수 있습니다. 응답에 각 데이터 세트에 포함 된 일부 공통 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d33b5b780baca645aec7549422132b41c1cb5808" translate="yes" xml:space="preserve">
          <source>The output is identical to &lt;a href=&quot;index&quot;&gt;&lt;em&gt;/api/query&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">출력은 &lt;a href=&quot;index&quot;&gt;&lt;em&gt;/ api / query와&lt;/em&gt;&lt;/a&gt; 동일 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56bad0de9c1293d4eca9b76b82af02b1c7548e4c" translate="yes" xml:space="preserve">
          <source>The output will be an array of 0 or more data points depending on the data that was found. If a data point for a particular time series was not located within the time specified, it will not appear in the output. Output fields depend on whether or not the &lt;code&gt;resolve&lt;/code&gt; flag was set.</source>
          <target state="translated">출력은 찾은 데이터에 따라 0 개 이상의 데이터 포인트의 배열이됩니다. 특정 시계열에 대한 데이터 포인트가 지정된 시간 내에 없으면 출력에 나타나지 않습니다. 출력 필드는 &lt;code&gt;resolve&lt;/code&gt; 플래그 설정 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="bc47d9c90013b3e94343e18039d8fff6454a8feb" translate="yes" xml:space="preserve">
          <source>The output will contain a list of objects in the &lt;code&gt;outputs&lt;/code&gt; array with the results in an array of arrays representing each time series followed by meta data for each series and the query overall. Also included is the original query and some summary statistics. The fields include:</source>
          <target state="translated">출력에는 &lt;code&gt;outputs&lt;/code&gt; 배열 의 개체 목록이 포함되며 각 시계열을 나타내는 배열 배열과 각 시리즈의 메타 데이터 및 쿼리 전체가 결과로 표시됩니다. 원래 쿼리와 일부 요약 통계도 포함되어 있습니다. 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66736a0377edb55f02e254e05e7bacb4be08eac7" translate="yes" xml:space="preserve">
          <source>The plugin may be missing configuration settings required for it to be initialized. Read the docs and see if anything is missing.</source>
          <target state="translated">플러그인을 초기화하는 데 필요한 구성 설정이 누락되었을 수 있습니다. 문서를 읽고 빠진 것이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="191962eabb05d6a65009577691f540a6c10be808" translate="yes" xml:space="preserve">
          <source>The plugin may not have access to the dependencies it needs. If it has dependencies that are not included with OpenTSDB or packaged into it's own JAR you need to drop the dependencies in the plugin path.</source>
          <target state="translated">플러그인이 필요한 종속성에 액세스하지 못할 수 있습니다. OpenTSDB에 포함되지 않거나 자체 JAR로 패키지 된 종속성이있는 경우 플러그인 경로에서 종속성을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b764e034236058b7f25b94624fa2bbf5ce7d1c4" translate="yes" xml:space="preserve">
          <source>The primary purpose of OpenTSDB is to store timeseries data points and allow for various operations on that data. However it helps to know what kind of data is stored and provide some context when working with the information. OpenTSDB's metadata is data about the data points. Much of it is user configurable to provide tie-ins with external tools such as search engines or issue tracking systems. This chapter describes various metadata available and what it's used for.</source>
          <target state="translated">OpenTSDB의 주요 목적은 시계열 데이터 포인트를 저장하고 해당 데이터에 대한 다양한 작업을 허용하는 것입니다. 그러나 어떤 종류의 데이터가 저장되어 있는지 알고 정보 작업시 컨텍스트를 제공하는 데 도움이됩니다. OpenTSDB의 메타 데이터는 데이터 포인트에 대한 데이터입니다. 대부분 검색 엔진 또는 이슈 추적 시스템과 같은 외부 도구를 타이 인에 제공하도록 사용자가 구성 할 수 있습니다. 이 장에서는 사용 가능한 다양한 메타 데이터와 그 용도에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b5e3360831a8ed8e25864d2acccde3a45cdc8727" translate="yes" xml:space="preserve">
          <source>The processed value. If a rule has an extracted regex group or the value was split by a separator, this represents the value after that processing has occured.</source>
          <target state="translated">처리 된 값입니다. 규칙에 추출 된 정규식 그룹이 있거나 값이 구분 기호로 분할 된 경우 해당 처리가 발생한 후의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db9544ff698310643cde3d42f22214472276f26d" translate="yes" xml:space="preserve">
          <source>The project ID hosting your Bigtable cluster.</source>
          <target state="translated">Bigtable 클러스터를 호스팅하는 프로젝트 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2929db7c0186edee3ae301aed931650437d9da34" translate="yes" xml:space="preserve">
          <source>The query builder that lets you select what will be displayed and how</source>
          <target state="translated">표시 할 내용과 방법을 선택할 수있는 쿼리 작성기</target>
        </trans-unit>
        <trans-unit id="d8299b8b4f8d30841e666138cd4a2c2e8c9cb59e" translate="yes" xml:space="preserve">
          <source>The query command line tool is meant to be a quick debugging tool for extracting data from OpenTSDB. The HTTP API will usually be much quicker when querying data as it incorprates caches and open connections to storage. Results are printed to stdout in a text format with one data point per line.</source>
          <target state="translated">쿼리 명령 줄 도구는 OpenTSDB에서 데이터를 추출하기위한 빠른 디버깅 도구입니다. HTTP API는 캐시를 통합하고 스토리지에 대한 연결을 열기 때문에 데이터를 쿼리 할 때 일반적으로 훨씬 빠릅니다. 결과는 한 줄에 하나의 데이터 포인트가있는 텍스트 형식으로 표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="058794b1bb6600ec55040b485850f113993fa3fc" translate="yes" xml:space="preserve">
          <source>The query is parsed and verified to make sure that the format is correct and that the metrics, tag names and tag values exist. If a single metric, tag name or value doesn't exist in the system, it will kick back an error.</source>
          <target state="translated">형식이 올 바르고 메트릭, 태그 이름 및 태그 값이 존재하는지 확인하기 위해 쿼리를 구문 분석하고 확인합니다. 시스템에 단일 메트릭, 태그 이름 또는 값이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f93253c5f0fb78f6b76111b124ffe5c6688aea18" translate="yes" xml:space="preserve">
          <source>The query string submitted. May be altered by the plugin</source>
          <target state="translated">쿼리 문자열이 제출되었습니다. 플러그인에 의해 변경 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7fab6b28e78a50ac766aed105642effe584b7ef1" translate="yes" xml:space="preserve">
          <source>The rate is the first derivative of the values. It's defined as (v2 - v1) / (t2 - t1). Therefore you will get the rate of change per second. Currently the rate of change between millisecond values defaults to a per second calculation.</source>
          <target state="translated">비율은 값의 첫 번째 미분입니다. (v2-v1) / (t2-t1)로 정의됩니다. 따라서 초당 변경 속도를 얻게됩니다. 현재 밀리 초 값 사이의 변경 비율은 기본적으로 초당 계산입니다.</target>
        </trans-unit>
        <trans-unit id="23b7309dbc6f98aae7173c1474bcf0c5e28992f7" translate="yes" xml:space="preserve">
          <source>The regex expression to search with</source>
          <target state="translated">검색 할 정규식</target>
        </trans-unit>
        <trans-unit id="f009d9456dc63cade32093a4bcb0423b4ac8e8dc" translate="yes" xml:space="preserve">
          <source>The remaining rows are branch and leaf rows containing information about the hierarchy. The rows are keyed on &lt;code&gt;&amp;lt;tree ID&amp;gt;&amp;lt;branch ID&amp;gt;&lt;/code&gt; where the &lt;code&gt;branch ID&lt;/code&gt; is a concatenation of hashes of the branch display names. For example, if we have a flattened branch &lt;code&gt;dal.web01.myapp.bytes_sent&lt;/code&gt; where each branch name is separated by a period, we would have 3 levels of branching. &lt;code&gt;dal&lt;/code&gt;, &lt;code&gt;web01&lt;/code&gt; and &lt;code&gt;myapp&lt;/code&gt;. The leaf would be named &lt;code&gt;bytes_sent&lt;/code&gt; and links to a TSUID. Hashing each branch name in Java returns a 4 byte integer and converting to hex for readability yields:</source>
          <target state="translated">나머지 행은 계층 구조에 대한 정보가 포함 된 분기 및 리프 행입니다. 행 &lt;code&gt;&amp;lt;tree ID&amp;gt;&amp;lt;branch ID&amp;gt;&lt;/code&gt; 는 &amp;lt;tree ID&amp;gt; &amp;lt;branch ID&amp;gt; 에서 입력되며 여기서 &lt;code&gt;branch ID&lt;/code&gt; 는 분기 표시 이름의 해시 연결입니다. 예를 들어, 각 분기 이름이 마침표로 구분 된 평평한 분기 &lt;code&gt;dal.web01.myapp.bytes_sent&lt;/code&gt; 가 있는 경우 3 가지 분기 수준이 있습니다. &lt;code&gt;dal&lt;/code&gt; , &lt;code&gt;web01&lt;/code&gt; 및 &lt;code&gt;myapp&lt;/code&gt; 입니다. 리프의 이름은 &lt;code&gt;bytes_sent&lt;/code&gt; 이며 TSUID 에 연결됩니다. Java에서 각 분기 이름을 해시하면 4 바이트 정수가 반환되고 가독성을 높이기 위해 16 진수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e057841fb19b18d8555055157dc697db684072d7" translate="yes" xml:space="preserve">
          <source>The request completed successfully</source>
          <target state="translated">요청이 성공적으로 완료되었습니다</target>
        </trans-unit>
        <trans-unit id="f6b0ee21b2ec56cf1554f390d3fccaff2a797cdf" translate="yes" xml:space="preserve">
          <source>The request could not generate a response in the format specified. For example, if you ask for a PNG file of the &lt;code&gt;logs&lt;/code&gt; endpoing, you will get a 406 response since log entries cannot be converted to a PNG image (easily)</source>
          <target state="translated">요청이 지정된 형식으로 응답을 생성 할 수 없습니다. 예를 들어, &lt;code&gt;logs&lt;/code&gt; 엔도 핑 의 PNG 파일을 요청 하면 로그 항목을 PNG 이미지로 쉽게 변환 할 수 없으므로 406 응답이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b0fab9a45bd903c1aabda7df5017f2ac22c06446" translate="yes" xml:space="preserve">
          <source>The request has timed out. This may be due to a timeout fetching data from the underlying storage system or other issues</source>
          <target state="translated">요청 시간이 초과되었습니다. 기본 스토리지 시스템에서 데이터를 가져 오는 시간 초과 또는 기타 문제로 인한 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c579d2a3832956208b697c66246559f8f7b45a" translate="yes" xml:space="preserve">
          <source>The requested endpoint or file was not found. This is usually related to the static file endpoint.</source>
          <target state="translated">요청한 엔드 포인트 또는 파일을 찾을 수 없습니다. 이것은 일반적으로 정적 파일 엔드 포인트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bda3e15051b540e14c4181bb60ff547119934c4" translate="yes" xml:space="preserve">
          <source>The requested feature has not been implemented yet. This may appear with formatters or when calling methods that depend on plugins</source>
          <target state="translated">요청한 기능이 아직 구현되지 않았습니다. 이것은 포맷터와 함께 또는 플러그인에 의존하는 메소드를 호출 할 때 나타날 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0cc0a391c59bf6d25d70897af75e304c611899e3" translate="yes" xml:space="preserve">
          <source>The requested verb or method was not allowed. Please see the documentation for the endpoint you are attempting to access</source>
          <target state="translated">요청하신 동사 또는 방법이 허용되지 않았습니다. 액세스하려는 엔드 포인트에 대한 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="4558d8aa0b487055f3f30b8830e8c9addd185c32" translate="yes" xml:space="preserve">
          <source>The response includes two arrays. &lt;code&gt;completed&lt;/code&gt; lists the 256 most recent queries that have finished execution, whether successfully or with an error. The &lt;code&gt;running&lt;/code&gt; array contains a list of queries currently executing. If this list is growing, the TSD is under heavy load. Note that the running list will not contain an exception, response code or timing details.</source>
          <target state="translated">응답에는 두 개의 배열이 포함됩니다. &lt;code&gt;completed&lt;/code&gt; 는 성공적으로 또는 오류로 실행을 완료 한 가장 최근의 256 개의 쿼리를 나열합니다. &lt;code&gt;running&lt;/code&gt; 배열은 쿼리의 목록은 현재 실행이 포함되어 있습니다. 이 목록이 늘어 나면 TSD에 과부하가 걸린 것입니다. 실행 목록에는 예외, 응답 코드 또는 타이밍 세부 사항이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e93df8c21ccd1a6d8fa7cf69b9eddb61805c137" translate="yes" xml:space="preserve">
          <source>The response is a hash map of configuration properties and values.</source>
          <target state="translated">응답은 구성 특성 및 값의 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ef463fd8dc1536462cc6e63f6b0db13d2df900d5" translate="yes" xml:space="preserve">
          <source>The response is a hash map of information. Unless something goes wrong, this should always result in a &lt;code&gt;status&lt;/code&gt; of &lt;code&gt;200&lt;/code&gt; and a message of &lt;code&gt;Caches dropped&lt;/code&gt;.</source>
          <target state="translated">응답은 정보의 해시 맵입니다. 문제가 발생하지 않으면 항상 &lt;code&gt;200&lt;/code&gt; 의 &lt;code&gt;status&lt;/code&gt; 가 되고 &lt;code&gt;Caches dropped&lt;/code&gt; 메시지가 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebfcf7fa5a04d98d7bd9eb0581f8e764a43f9cc7" translate="yes" xml:space="preserve">
          <source>The response is a hash map of version properties and values.</source>
          <target state="translated">응답은 버전 속성 및 값의 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="a39e2c939a7c5eaaf42f3226c95b85598736d45a" translate="yes" xml:space="preserve">
          <source>The response is a map of filter names or types and sub maps of examples and descriptions. The examples show how to use them in both URI and JSON queries.</source>
          <target state="translated">응답은 필터 이름 또는 유형의 맵과 예제 및 설명의 서브맵입니다. 예제는 URI 및 JSON 쿼리에서 모두 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="383d1f4a3838ab98445852338968e6e6f95f77f0" translate="yes" xml:space="preserve">
          <source>The response is an array of objects. Fields in the response include:</source>
          <target state="translated">응답은 객체의 배열입니다. 응답의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01660dda87f9025281612c3c56856c02b46fac2d" translate="yes" xml:space="preserve">
          <source>The response is an array of serializer objects. Each object has the following fields:</source>
          <target state="translated">응답은 serializer 객체의 배열입니다. 각 객체에는 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2886ff0fdb8bbbc1d92b65f33d22e6a6906bb7ae" translate="yes" xml:space="preserve">
          <source>The response is an array of strings of the given type that match the query. If nothing was found to match the query, an empty array will be returned.</source>
          <target state="translated">응답은 쿼리와 일치하는 지정된 유형의 문자열 배열입니다. 쿼리와 일치하는 것이 없으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1de923e099d8f37ce04a9da810c69b69f826cee0" translate="yes" xml:space="preserve">
          <source>The response is an array of strings that are the names of aggregation functions that can be used in a timeseries query.</source>
          <target state="translated">응답은 시계열 쿼리에 사용할 수있는 집계 함수의 이름 인 문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a5fdf7bbb6d9bb75714a41da6285c17da610a617" translate="yes" xml:space="preserve">
          <source>The response is an object with multiple sub objects. Top level objects include</source>
          <target state="translated">응답은 여러 하위 개체가있는 개체입니다. 최상위 개체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5de73f3f092c415eab72c3b9ea0977e9ea41ac36" translate="yes" xml:space="preserve">
          <source>The response is the literal &quot;metrics&quot; followed by the name of the metric and a Java formatted byte array representing the UID assigned or retrieved for each metric, one per line.</source>
          <target state="translated">응답은 리터럴 &quot;metrics&quot;다음에 메트릭 이름과 각 메트릭에 대해 할당되거나 검색된 UID를 나타내는 Java 형식 바이트 배열입니다 (한 줄에 하나씩).</target>
        </trans-unit>
        <trans-unit id="5e2280020465f2b55a92cdbdce5742287135f181" translate="yes" xml:space="preserve">
          <source>The response will be the contents of the requested file with appropriate HTTP headers configured.</source>
          <target state="translated">응답은 적절한 HTTP 헤더가 구성된 요청 된 파일의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="580115e289fecdcf6ac8cd4d9693407cb57e37d2" translate="yes" xml:space="preserve">
          <source>The response will contain a map of successful assignments along with the hex encoded UID value. If one or more values were not assigned, a separate map will contain a list of the values and the reason why they were not assigned. Maps with the type name and &lt;code&gt;&amp;lt;type&amp;gt;_errors&lt;/code&gt; will be generated only if one or more values for that type were provided.</source>
          <target state="translated">응답에는 16 진수로 인코딩 된 UID 값과 함께 성공적인 할당 맵이 포함됩니다. 하나 이상의 값이 지정되지 않은 경우 별도의 맵에 값 목록과 값이 지정되지 않은 이유가 포함됩니다. 유형 이름과 &lt;code&gt;&amp;lt;type&amp;gt;_errors&lt;/code&gt; 가있는 맵 은 해당 유형에 대해 하나 이상의 값이 제공된 경우에만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e888f859bcc4a020940fcab98a80a43e4af880a7" translate="yes" xml:space="preserve">
          <source>The result set with the TSUID, metric and tags for each series.</source>
          <target state="translated">각 시리즈의 TSUID, 메트릭 및 태그가 포함 된 결과 집합입니다.</target>
        </trans-unit>
        <trans-unit id="8ea3f04cde272db0ce7365404600bfc171bd4dd0" translate="yes" xml:space="preserve">
          <source>The result set. The format depends on the endpoint requested.</source>
          <target state="translated">결과 세트. 형식은 요청 된 엔드 포인트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5c94c8b132a9bb1a02ef4947c7f801e9e3ec9088" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;avg&lt;/code&gt; for a &lt;code&gt;2h&lt;/code&gt; downsampling query would look like this:</source>
          <target state="translated">그 결과 &lt;code&gt;avg&lt;/code&gt; A에 대한 &lt;code&gt;2h&lt;/code&gt; 다운 샘플링의 쿼리는 다음과 같을 것이다 :</target>
        </trans-unit>
        <trans-unit id="b5846db8915403c138cb9a6be94e03bf270cc6c8" translate="yes" xml:space="preserve">
          <source>The resulting tree would look like this:</source>
          <target state="translated">결과 트리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="425abba753ebcf08b975d219efa61270ecf8e7d5" translate="yes" xml:space="preserve">
          <source>The results returned from a query may be too large for the server's buffers to handle. This can happen if you request a lot of raw data from OpenTSDB. In such cases break your query up into smaller queries and run each individually</source>
          <target state="translated">쿼리에서 반환 된 결과가 너무 커서 서버 버퍼가 처리 할 수 ​​없습니다. OpenTSDB에서 많은 원시 데이터를 요청하면 이런 일이 발생할 수 있습니다. 이러한 경우 쿼리를 작은 쿼리로 나누고 각각을 개별적으로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="03e2f5949cc33008bb4ed0df9163659c72104486" translate="yes" xml:space="preserve">
          <source>The results will be logged with settings in the &lt;code&gt;logback.xml&lt;/code&gt; file. For long fscks, it's recommended to run in the background and configure LogBack to have plenty of space for writing data. On completion, statistics about the run will be printed. An example looks like:</source>
          <target state="translated">결과는 &lt;code&gt;logback.xml&lt;/code&gt; 파일의 설정으로 기록 됩니다. 긴 fscks의 경우 백그라운드에서 실행하고 데이터 쓰기를위한 충분한 공간을 갖도록 LogBack을 구성하는 것이 좋습니다. 완료되면 실행에 대한 통계가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0926190af8ecef763121a2190af951f3d338844b" translate="yes" xml:space="preserve">
          <source>The results will be the data points that you requested.</source>
          <target state="translated">결과는 요청한 데이터 포인트가됩니다.</target>
        </trans-unit>
        <trans-unit id="a66f14e9007d9b11efec9771d67ed40cbef70ab1" translate="yes" xml:space="preserve">
          <source>The reverse map points to a different name than the forward map and this should rarely happen. It will be paired with another message.</source>
          <target state="translated">리버스 맵은 포워드 맵과 다른 이름을 가리키며 거의 발생하지 않습니다. 다른 메시지와 페어링됩니다.</target>
        </trans-unit>
        <trans-unit id="a47f7ab0c0351aea2b993671f17f6037f5cfc217" translate="yes" xml:space="preserve">
          <source>The reverse map will be restored, in this case: 000002 -&amp;gt; bar</source>
          <target state="translated">이 경우 리버스 맵이 복원됩니다 : 000002-&amp;gt; bar</target>
        </trans-unit>
        <trans-unit id="fbf8211de5cf959fefd2c19450df6497580a914d" translate="yes" xml:space="preserve">
          <source>The root section is the catch-all logger that determines that default logging level for all messages that don't match an explicit logger. It also handles routing to the different appenders.</source>
          <target state="translated">루트 섹션은 명시 적 로거와 일치하지 않는 모든 메시지의 기본 로깅 수준을 결정하는 범용 로거입니다. 또한 다른 어 펜더로의 라우팅을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dc3bd0d3a0635f68c39659954f885bbf1ed5de60" translate="yes" xml:space="preserve">
          <source>The rules endpoint is used for bulk merging, replacing or deleting the entire ruleset of a tree. Instead of calling the &lt;code&gt;tree/rule&lt;/code&gt; endpoint multiple times for a single rule, you can supply a list of rules that will be merged into, or replace, the current rule set. Note that the &lt;code&gt;GET&lt;/code&gt; verb is not supported for this endpoint. To fetch the ruleset, load the tree via the &lt;code&gt;/tree&lt;/code&gt; endpoint. Also, all data must be provided in request content, query strings are not supported.</source>
          <target state="translated">규칙 끝점은 트리의 전체 규칙 집합을 대량 병합, 교체 또는 삭제하는 데 사용됩니다. 단일 규칙에 대해 &lt;code&gt;tree/rule&lt;/code&gt; 끝점을 여러 번 호출하는 대신 현재 규칙 집합에 병합하거나 대체 할 규칙 목록을 제공 할 수 있습니다. 이 엔드 포인트 에는 &lt;code&gt;GET&lt;/code&gt; 동사가 지원되지 않습니다. 규칙 세트를 가져 오려면 &lt;code&gt;/tree&lt;/code&gt; 엔드 포인트 를 통해 트리를로드하십시오 . 또한 모든 데이터는 요청 내용으로 제공되어야하며 쿼리 문자열은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8207a79775a9822d7026ff28655cd29b0bf39267" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;wildcard&lt;/code&gt; but case insensitive.</source>
          <target state="translated">&lt;code&gt;wildcard&lt;/code&gt; 와 동일 하지만 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b29a47bf30edf4593879faec37eb7f684f3af0c" translate="yes" xml:space="preserve">
          <source>The same as a &lt;code&gt;literal_or&lt;/code&gt; but is case insensitive. Note that this is not efficient like the literal or as it must post-process all rows from storage.</source>
          <target state="translated">&lt;code&gt;literal_or&lt;/code&gt; 와 동일 하지만 대소 문자를 구분하지 않습니다. 리터럴과 같이 효율적이지 않거나 스토리지에서 모든 행을 사후 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1172c35f5ed7f8d775d731d36396dba763dbb111" translate="yes" xml:space="preserve">
          <source>The scan command is useful for debugging and exporting data points. Provide a start time, optional end time and one or more queries and the response will be raw byte data from storage or data points in a text format acceptable for use with the &lt;strong&gt;import&lt;/strong&gt; command. Scan also provides a rudimentary means of deleting data. The scan command accepts common CLI arguments. Data is emitted to standard out.</source>
          <target state="translated">scan 명령은 데이터 포인트를 디버깅하고 내보내는 데 유용합니다. 시작 시간, 선택적 종료 시간 및 하나 이상의 쿼리를 제공하면 응답은 &lt;strong&gt;가져 오기&lt;/strong&gt; 명령 에 사용할 수있는 텍스트 형식의 스토리지 또는 데이터 포인트의 원시 바이트 데이터입니다 . 또한 스캔은 데이터를 삭제하는 기본적인 수단을 제공합니다. scan 명령은 공통 CLI 인수를 허용합니다. 데이터는 표준 출력으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="cb41a38ecc595b6685d3d1487f2377a8ae92c048" translate="yes" xml:space="preserve">
          <source>The scan command returns data on row boundaries (1 hour) so results may include data previous to and after the specified start and end times.</source>
          <target state="translated">scan 명령은 행 경계에있는 데이터를 반환하므로 (1 시간) 지정된 시작 및 종료 시간 전후의 데이터가 결과에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417f747fc6688fab17f691430ebb22a06e8c2c97" translate="yes" xml:space="preserve">
          <source>The search command allows for searching OpenTSDB to reteive a list of time series or associated meta data. Search does not return actual data points or time series objects stored in the data table. Use the query tools to access that data. Currently only the &lt;code&gt;lookup&lt;/code&gt; command is implemented.</source>
          <target state="translated">검색 명령을 사용하면 OpenTSDB를 검색하여 시계열 또는 관련 메타 데이터 목록을 수신 할 수 있습니다. 검색은 데이터 테이블에 저장된 실제 데이터 포인트 또는 시계열 개체를 반환하지 않습니다. 쿼리 도구를 사용하여 해당 데이터에 액세스하십시오. 현재 &lt;code&gt;lookup&lt;/code&gt; 명령 만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="05d268d5cbe7b936fce86df9f0dd8eed0f712ac1" translate="yes" xml:space="preserve">
          <source>The second method of operation for aggregation functions is &lt;code&gt;downsampling&lt;/code&gt;. Since OpenTSDB stores data at the original resolution indefinitely, requesting data for a long time span can return millions of points. This can cause a burden on bandwidth or graphing libraries so it's common to request data at a lower resolution for longer spans. Downsampling breaks the long span of data into smaller spans and merges the data for the smaller span into a single data point. Aggregation functions will perform the same calculation as for an aggregation process but instead of working across data points for multiple time series at a single time stamp, downsampling works across multiple data points within a single time series over a given time span.</source>
          <target state="translated">집계 함수의 두 번째 작동 방법은 &lt;code&gt;downsampling&lt;/code&gt; 입니다. OpenTSDB는 원래 해상도로 데이터를 무한정 저장하기 때문에 오랫동안 데이터를 요청하면 수백만 포인트를 반환 할 수 있습니다. 이로 인해 대역폭 또는 그래프 라이브러리에 부담이 생길 수 있으므로 더 긴 범위에 대해 낮은 해상도로 데이터를 요청하는 것이 일반적입니다. 다운 샘플링은 긴 범위의 데이터를 더 작은 범위로 나누고 더 작은 범위의 데이터를 단일 데이터 포인트로 병합합니다. 집계 함수는 집계 프로세스와 동일한 계산을 수행하지만 단일 타임 스탬프에서 여러 시계열에 대한 여러 데이터 포인트에서 작업하는 대신, 지정된 시간 범위 동안 단일 시계열 내에서 여러 데이터 포인트에 대해 다운 샘플링이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3c5af2c577a918fc1ea28eba04af791f5d57efc4" translate="yes" xml:space="preserve">
          <source>The server has completed the request successfully but is not returning content in the body. This is primarily used for storing data points as it is not necessary to return data to caller</source>
          <target state="translated">서버가 요청을 성공적으로 완료했지만 본문의 내용을 반환하지 않습니다. 이것은 발신자에게 데이터를 반환 할 필요가 없으므로 주로 데이터 포인트를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="213d21eeae2dea6eb00df949152b5bb48e0aad4e" translate="yes" xml:space="preserve">
          <source>The set operation or &quot;join&quot; to perform for series across sets.</source>
          <target state="translated">일련의 세트에 대해 수행 할 세트 조작 또는 &quot;결합&quot;.</target>
        </trans-unit>
        <trans-unit id="a44d20b8251aaa40f1728ae8514d24651fe0212d" translate="yes" xml:space="preserve">
          <source>The simple split method above assumes that you have roughly an equal number of time series per metric (i.e. a fairly consistent cardinality). E.g. the metric with a UID of &lt;code&gt;000001&lt;/code&gt; may have 200 time series and &lt;code&gt;000FA0&lt;/code&gt; has about 150. If you have a wide range of time series per metric, e.g. &lt;code&gt;000001&lt;/code&gt; has 10,000 time series while &lt;code&gt;000FA0&lt;/code&gt; only has 2, you may need to develop a more complex splitting algorithm.</source>
          <target state="translated">위의 간단한 분할 방법은 측정 항목 당 대략 동일한 수의 시계열 (즉, 상당히 일관된 카디널리티)이 있다고 가정합니다. 예를 들어 UID가 &lt;code&gt;000001&lt;/code&gt; 인 메트릭 은 200 개의 시계열을 가질 수 있고 &lt;code&gt;000FA0&lt;/code&gt; 은 약 150을 가질 수 있습니다. 메트릭 당 광범위한 시계열 범위를 갖는 경우 (예 : &lt;code&gt;000001&lt;/code&gt; 은 10,000 개의 시계열을 &lt;code&gt;000FA0&lt;/code&gt; 반면 000FA0 는 2 만있는 경우) 복잡한 분할 알고리즘.</target>
        </trans-unit>
        <trans-unit id="d29df3f8f422b6091009eea5d0f1c0278c1a3084" translate="yes" xml:space="preserve">
          <source>The simplest way to pre-split your &lt;code&gt;tsdb&lt;/code&gt; table regions is to estimate the number of unique metric names you'll be recording. If you have designed a naming schema, you should have a pretty good idea. Let's say that we will track 4,000 metrics in our system. That's not to say 4,000 time series, as we're not counting the tags yet, just the metric names such as &quot;sys.cpu.user&quot;. Data points are written in row keys where the metric's UID comprises the first bytes, 3 bytes by default. The first metric will be assigned a UID of &lt;code&gt;000001&lt;/code&gt; as a hex encoded value. The 4,000th metric will have a UID of &lt;code&gt;000FA0&lt;/code&gt; in hex. You can use these as the start and end keys in the script from the &lt;a href=&quot;http://hbase.apache.org/book/perf.writing.html&quot;&gt;HBase Book&lt;/a&gt; to split your table into any number of regions. 256 regions may be a good place to start depending on how many time series share each metric.</source>
          <target state="translated">&lt;code&gt;tsdb&lt;/code&gt; 테이블 영역 을 사전 분할하는 가장 간단한 방법 은 기록 할 고유 메트릭 이름의 수를 추정하는 것입니다. 네이밍 스키마를 디자인했다면 꽤 좋은 생각이 있어야합니다. 시스템에서 4,000 개의 메트릭을 추적한다고 가정하겠습니다. 아직 태그를 세지 않고 &quot;sys.cpu.user&quot;와 같은 메트릭 이름 만 사용하므로 4,000 개의 시계열을 말하는 것은 아닙니다. 데이터 포인트는 메트릭의 UID가 기본적으로 3 바이트 인 첫 번째 바이트를 구성하는 행 키로 작성됩니다. 첫 번째 메트릭 에는 16 진수로 인코딩 된 값 으로 &lt;code&gt;000001&lt;/code&gt; 의 UID가 할당됩니다 . 4,000 번째 메트릭의 UID는 16 진수 로 &lt;code&gt;000FA0&lt;/code&gt; 입니다. &lt;a href=&quot;http://hbase.apache.org/book/perf.writing.html&quot;&gt;HBase Book&lt;/a&gt; 에서 스크립트의 시작 및 종료 키로 사용할 수 있습니다.테이블을 여러 지역으로 분할합니다. 각 측정 항목을 공유하는 시계열 수에 따라 256 개의 영역을 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c600707ebcabc7e4cbee4ee824f59fa6f8b189fd" translate="yes" xml:space="preserve">
          <source>The start time for the query. This can be a relative or absolute timestamp. See &lt;a href=&quot;../../user_guide/query/index&quot;&gt;&lt;em&gt;Querying or Reading Data&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">쿼리 시작 시간입니다. 이것은 상대적 또는 절대 타임 스탬프 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../user_guide/query/index&quot;&gt;&lt;em&gt;데이터 쿼리 또는 읽기&lt;/em&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="336a8af369345cce2a8cc8bf21725d8bea6ba66b" translate="yes" xml:space="preserve">
          <source>The start time for the query. This may be relative, absolute human readable or absolute Unix Epoch.</source>
          <target state="translated">쿼리 시작 시간입니다. 이것은 절대적이고 사람이 읽을 수 있거나 절대 유닉스 시대 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4370be6833f21a7f028b22204fbec3c3b1b99d" translate="yes" xml:space="preserve">
          <source>The starting index for the current result set as provided in the query</source>
          <target state="translated">쿼리에 제공된 현재 결과 세트의 시작 색인</target>
        </trans-unit>
        <trans-unit id="6242b8c1f26a51faf4237cf41226ae600cca0c13" translate="yes" xml:space="preserve">
          <source>The string based query to pass to the search engine. This will be parsed by the engine or plugin to perform the actual search. Allowable values depends on the plugin. Ignored for lookups.</source>
          <target state="translated">검색 엔진에 전달할 문자열 기반 쿼리입니다. 실제 검색을 수행하기 위해 엔진 또는 플러그인에서 구문 분석합니다. 허용되는 값은 플러그인에 따라 다릅니다. 조회를 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="c756b532f032b67c5333a87c0a1eabf30cc8e02c" translate="yes" xml:space="preserve">
          <source>The style tab currently has a single box, the &lt;strong&gt;Smooth&lt;/strong&gt; check box. With this checked, the data point characters will be removed from the graph (showing the lines only) and the data will be smoothed with splines (at least three points need to be plotted). Some users prefer this over the default.</source>
          <target state="translated">스타일 탭에는 현재 단일 확인란 인 &lt;strong&gt;스무딩&lt;/strong&gt; 확인란이 있습니다. 이 옵션을 선택하면 데이터 포인트 문자가 그래프에서 제거되고 (선만 표시) 스플라인으로 데이터가 매끄럽게됩니다 (적어도 3 개의 포인트를 플롯해야 함). 일부 사용자는 기본값보다이를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="4387e95fdd2160045011cfbcfa06b9127ecc200a" translate="yes" xml:space="preserve">
          <source>The tag key name such as &lt;em&gt;host&lt;/em&gt; or &lt;em&gt;colo&lt;/em&gt; that we filter on</source>
          <target state="translated">필터링 한 &lt;em&gt;호스트&lt;/em&gt; 또는 &lt;em&gt;콜로&lt;/em&gt; 와 같은 태그 키 이름</target>
        </trans-unit>
        <trans-unit id="66cd7ecbbe08c3d60b68074706d64f836de66d38" translate="yes" xml:space="preserve">
          <source>The tag key to invoke the filter on</source>
          <target state="translated">필터를 호출 할 태그 키</target>
        </trans-unit>
        <trans-unit id="6f8503fb7c4f0122fa4e5fe2768573df962094b5" translate="yes" xml:space="preserve">
          <source>The tag value box can use grouping operators such as the &lt;code&gt;*&lt;/code&gt; and the &lt;code&gt;|&lt;/code&gt;. See &lt;a href=&quot;../query/index&quot;&gt;&lt;em&gt;Querying or Reading Data&lt;/em&gt;&lt;/a&gt; for details. Tag value boxes can also use filters as of version 2.2. E.g. you can enter &quot;wildcard(webserver*)&quot; as a tag value and it will match all hosts starting with &quot;webserver&quot;.</source>
          <target state="translated">태그 값 상자는 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../query/index&quot;&gt;&lt;em&gt;데이터 쿼리 또는 읽기&lt;/em&gt;&lt;/a&gt; 를 참조하십시오. 태그 값 상자는 버전 2.2부터 필터를 사용할 수도 있습니다. 예를 들어 &quot;wildcard (webserver *)&quot;를 태그 값으로 입력하면 &quot;webserver&quot;로 시작하는 모든 호스트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="417530952e075c2348105d9e01119f6144a23903" translate="yes" xml:space="preserve">
          <source>The thick blue line with triangles is the an aggregation with the &lt;code&gt;avg&lt;/code&gt; function of multiple time series as per the query &lt;code&gt;start=1h-ago&amp;amp;m=avg:duration_seconds&lt;/code&gt;. As we can see, the resulting time series has one data point at each timestamp of all the underlying time series it aggregates, and that data point is computed by taking the average of the values of all the time series at that timestamp. This is also true for the lonely data point of the squared-purple time series, that temporarily boosted the average until the next data point.</source>
          <target state="translated">삼각형이있는 진한 파란색 선 은 쿼리 &lt;code&gt;start=1h-ago&amp;amp;m=avg:duration_seconds&lt;/code&gt; 따라 여러 시계열 의 &lt;code&gt;avg&lt;/code&gt; 함수를 사용하여 집계 한 것 입니다. 보시다시피 결과 시계열에는 집계 된 모든 기본 시계열의 각 타임 스탬프마다 하나의 데이터 포인트가 있으며 해당 데이터 포인트는 해당 타임 스탬프에서 모든 시계열의 값의 평균을 취하여 계산됩니다. 이는 다음 데이터 포인트까지 평균을 일시적으로 향상시킨 제곱 보라색 시계열의 외로운 데이터 포인트에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="58dc3df0680582b1389888fef9672b89ad6f85de" translate="yes" xml:space="preserve">
          <source>The threads endpoint is used for debugging the TSD and providing insight into the state and execution of various threads without having to resort to a JStack trace. (v2.2)</source>
          <target state="translated">스레드 엔드 포인트는 TSD를 디버깅하고 JStack 추적에 의존하지 않고 다양한 스레드의 상태 및 실행에 대한 통찰력을 제공하는 데 사용됩니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="063deeee801f96e1aa0e14306366036c564f3a0d" translate="yes" xml:space="preserve">
          <source>The threads endpoint is used for debugging the TSD's JVM process and includes stats about the garbage collector, system load and memory usage. (v2.2)</source>
          <target state="translated">스레드 엔드 포인트는 TSD의 JVM 프로세스 디버깅에 사용되며 가비지 콜렉터, 시스템로드 및 메모리 사용량에 대한 통계를 포함합니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="2786c92c51875f3a2e6458503054b21d01e159a7" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer HTTP requests for the 50th percentile cases</source>
          <target state="translated">50 번째 백분위 수 사례에 대한 HTTP 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="a4fab44f220643fb61e13ef4ab0977d7edbe9487" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer HTTP requests for the 75th percentile cases</source>
          <target state="translated">75 번째 백분위 수 사례에 대한 HTTP 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="c48cf3b50ede1d98d6ab4fd26f44af7aca939fc1" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer HTTP requests for the 90th percentile cases</source>
          <target state="translated">90 번째 백분위 수 사례에 대한 HTTP 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="453a77780203fa1a65f7220fae61018e6df7d713" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer HTTP requests for the 95th percentile cases</source>
          <target state="translated">95 번째 백분위 수 사례에 대한 HTTP 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="475436a474dc98e26cb863ca0de8452ab0c27cb0" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer graphing requests for the 50th percentile cases</source>
          <target state="translated">50 번째 백분위 수 사례에 대한 그래프 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="c47579000412f893471498b758b92334a10b8130" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer graphing requests for the 75th percentile cases</source>
          <target state="translated">75 번째 백분위 수 사례에 대한 그래프 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="6780b3e94a0c46d814921a4d862c4cc73f17b43e" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer graphing requests for the 90th percentile cases</source>
          <target state="translated">90 번째 백분위 수 사례에 대한 그래프 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="699d788b10b53c2d9083af27dcd15c4919a809db" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to answer graphing requests for the 95th percentile cases</source>
          <target state="translated">95 번째 백분위 수 사례에 대한 그래프 요청에 응답하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="428780c9fda31fb8873a2e53752458e1d1f90f16" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Put call for the 50th percentile cases</source>
          <target state="translated">50 번째 백분위 수 사례에 Put Put을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="f5a57d606fa5905d5d92e988dc7bab9fb614307d" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Put call for the 75th percentile cases</source>
          <target state="translated">75 번째 백분위 수 사례에 Put Put을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="bb9ed0a82641ca11311d7c99c97ee7ca6f05e3f5" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Put call for the 90th percentile cases</source>
          <target state="translated">90 번째 백분위 수 사례에 대해 Put 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="bd5fe18534f1eab46f1c4bbaa9ee02715d58e04f" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Put call for the 95th percentile cases</source>
          <target state="translated">95 번째 백분위 수 사례에 대해 Put 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="cc31c451582a56fb97dcfd2e4f4d77eb3e1b63af" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Scan call for the 50th percentile cases</source>
          <target state="translated">50 번째 백분위 수 사례에 대한 스캔 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="ebef049c13e6a08c7e0cf8c9abcbb957e520d6b6" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Scan call for the 75th percentile cases</source>
          <target state="translated">75 번째 백분위 수 사례에 대한 스캔 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="0f8bf64937db9bf466e9ac76b1bed8e4ac840ae9" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Scan call for the 90th percentile cases</source>
          <target state="translated">90 번째 백분위 수 사례에 대한 스캔 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="8d9465be6e25ec9aeb33e4410b2f8d7aa1a33ade" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to execute a Scan call for the 95th percentile cases</source>
          <target state="translated">95 번째 백분위 수 사례에 대한 스캔 호출을 실행하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="24f5c91753a6495f501ba0a9aeb2d1046c1060d2" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to generate the GnuPlot graphs for the 50th percentile cases</source>
          <target state="translated">50 번째 백분위 수 사례에 대한 GnuPlot 그래프를 생성하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="a374ffd1f742157c831da3653b10677212e1d63f" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to generate the GnuPlot graphs for the 75th percentile cases</source>
          <target state="translated">75 번째 백분위 수 사례에 대한 GnuPlot 그래프를 생성하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="a635d4058125074c6be59a1954c13074658a790e" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to generate the GnuPlot graphs for the 90th percentile cases</source>
          <target state="translated">90 번째 백분위 수 사례에 대한 GnuPlot 그래프를 생성하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="327007d9a86b200a7006d9172ab347d49f8260a8" translate="yes" xml:space="preserve">
          <source>The time it took, in milliseconds, to generate the GnuPlot graphs for the 95th percentile cases</source>
          <target state="translated">95 번째 백분위 수 사례에 대한 GnuPlot 그래프를 생성하는 데 걸린 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="020944482490138e479955c1933abbcee8415af9" translate="yes" xml:space="preserve">
          <source>The time secion determines the timespan for all metrics and time series in your graph. The &lt;strong&gt;Frome&lt;/strong&gt; time determines when your graph will start and the &lt;strong&gt;End&lt;/strong&gt; time determines when it will stop. Both fields must be filled out for a query to execute. Times may be in human readable, absolute format or a relative format. See &lt;a href=&quot;../query/dates&quot;&gt;&lt;em&gt;Dates and Times&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">시간 secion은 그래프의 모든 메트릭 및 시계열에 대한 시간 범위를 결정합니다. &lt;strong&gt;프롬&lt;/strong&gt; 그래프가 시작되고 때 시간이 결정 &lt;strong&gt;끝&lt;/strong&gt; 이 중지됩니다 때 시간을 결정합니다. 쿼리를 실행하려면 두 필드를 모두 채워야합니다. 시간은 사람이 읽을 수있는 형식, 절대 형식 또는 상대 형식 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;../query/dates&quot;&gt;&lt;em&gt;날짜 및 시간&lt;/em&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8ccce5de8301dd02ceabd408807ad0339941321" translate="yes" xml:space="preserve">
          <source>The time section is required and is a single JSON object. This affects the time range and optional reductions for all metrics requested.</source>
          <target state="translated">시간 섹션은 필수이며 단일 JSON 오브젝트입니다. 이는 요청 된 모든 메트릭의 시간 범위 및 선택적 감소에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="234dca44892cd7412d1846135b9d5d0af850a3e8" translate="yes" xml:space="preserve">
          <source>The timestamp (Unix epoch in milliseconds) when the query was finished and sent to the client.</source>
          <target state="translated">쿼리가 완료되어 클라이언트로 전송 된 타임 스탬프 (Unix epoch (밀리 초))</target>
        </trans-unit>
        <trans-unit id="19ad9cfdf1ff6dec81f25efa4e2c794f49048a1c" translate="yes" xml:space="preserve">
          <source>The timestamp (Unix epoch in milliseconds) when the query was received and started processing.</source>
          <target state="translated">쿼리를 수신하고 처리를 시작한 타임 스탬프 (Unix epoch (밀리 초))</target>
        </trans-unit>
        <trans-unit id="fc6e57f863d5f2fbb7b65243aa10fb4084a94f3c" translate="yes" xml:space="preserve">
          <source>The timestamp is a Unix epoch value in seconds encoded on 4 bytes. Rows are broken up into hour increments, reflected by the timestamp in each row. Thus each timestamp will be normalized to an hour value, e.g. &lt;em&gt;2013-01-01 08:00:00&lt;/em&gt;. This is to avoid stuffing too many data points in a single row as that would affect region distribution. Also, since HBase sorts on the row key, data for the same metric and time bucket, but with different tags, will be grouped together for efficient queries.</source>
          <target state="translated">타임 스탬프는 4 바이트로 인코딩 된 Unix epoch 값 (초)입니다. 각 행의 타임 스탬프에 따라 행이 시간 단위로 분할됩니다. 따라서 각 타임 스탬프는 시간 값 (예 : &lt;em&gt;2013-01-01 08:00:00)&lt;/em&gt; 으로 정규화됩니다 . 이는 단일 행에 너무 많은 데이터 포인트를 채워서 지역 분포에 영향을 미치지 않도록하기위한 것입니다. 또한 HBase는 행 키를 기준으로 정렬하므로 동일한 메트릭 및 시간 버킷에 대한 데이터가 있지만 태그가 다른 데이터는 그룹화되어 효율적인 쿼리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="958c23f05930b1d234248d1bd33838113224936c" translate="yes" xml:space="preserve">
          <source>The timestamp must be a positive Unix epoch timestamp. E.g. &lt;code&gt;1479496100&lt;/code&gt; to represent &lt;code&gt;Fri, 18 Nov 2016 19:08:20 GMT&lt;/code&gt;</source>
          <target state="translated">타임 스탬프는 양의 유닉스 시대 타임 스탬프 여야합니다. 예 : &lt;code&gt;1479496100&lt;/code&gt; 표현하기 &lt;code&gt;Fri, 18 Nov 2016 19:08:20 GMT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30835a029357c57a199c514e89a8f262da9d1d99" translate="yes" xml:space="preserve">
          <source>The timestamp of a rolled-up data point should snap to the top of the rollup interval. E.g. if the rollup interval is &lt;code&gt;1h&lt;/code&gt; then it contains 1 hour of data and should snap to the top of the hour. (As all timestamps are written in Unix Epoch format, defined as the UTC timezone, this would be the start of an hour UTC time).</source>
          <target state="translated">롤업 된 데이터 포인트의 타임 스탬프는 롤업 간격의 상단에 스냅되어야합니다. 예를 들어 롤업 간격이 &lt;code&gt;1h&lt;/code&gt; 이면 1 시간 분량의 데이터가 포함되며 시간의 맨 위에 맞춰져야합니다. 모든 타임 스탬프는 UTC 시간대로 정의 된 Unix Epoch 형식으로 작성되므로 UTC 시간으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="830f869009a936b7a1c40ee6b80a1d61598f62b4" translate="yes" xml:space="preserve">
          <source>The timestamps for count and sum values must match. However, if the expected count value for a sum is missing, the sum will be kicked out of the results. Take the following example set from above where we're now missing a count data point in &lt;code&gt;ts2&lt;/code&gt;.</source>
          <target state="translated">카운트 및 합계 값의 타임 스탬프가 일치해야합니다. 그러나 합계의 예상 카운트 값이 누락되면 합계가 결과에서 제외됩니다. &lt;code&gt;ts2&lt;/code&gt; 의 카운트 데이터 포인트가 누락 된 위의 다음 예제 세트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="655a7653a1ea8f1bff3104c0aeaf7dfff8be030c" translate="yes" xml:space="preserve">
          <source>The top half of the key tab's section deals with the location of the graph key. This is a series of buttons layed out to show you where the key will appear. A box surrounds some of the buttons indicating that the key will appear inside of the graph's box, overlaying the data. The default location is the top right inside of the graph box. Simply select a button to move the key box.</source>
          <target state="translated">키 탭 섹션의 상단 절반은 그래프 키의 위치를 ​​처리합니다. 키가 나타날 위치를 표시하기 위해 배치 된 일련의 버튼입니다. 일부 버튼 주위에 상자가 있으면 키가 그래프 상자 안에 나타나 데이터를 오버레이 함을 나타냅니다. 기본 위치는 그래프 상자의 오른쪽 상단입니다. 버튼을 선택하기 만하면 키 박스가 이동합니다.</target>
        </trans-unit>
        <trans-unit id="48128361438a06820f696edb98e78bd400500192" translate="yes" xml:space="preserve">
          <source>The total exceptions caused by a socket inactivity timeout, i.e. the TSD neither wrote nor received data from a socket within the timeout period. This includes all Telnet and HTTP connections.</source>
          <target state="translated">소켓 비 활동 시간 초과로 인한 총 예외, 즉 TSD는 시간 초과 기간 내에 소켓에서 데이터를 쓰거나받지 못했습니다. 여기에는 모든 텔넷 및 HTTP 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8cf984a3ad34ecbc349a6ff4b6d1343f2a1d3f6" translate="yes" xml:space="preserve">
          <source>The total exceptions with an unknown cause. Check the logs for details. This includes all Telnet and HTTP connections.</source>
          <target state="translated">원인을 알 수없는 총 예외입니다. 자세한 내용은 로그를 확인하십시오. 여기에는 모든 텔넷 및 HTTP 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e88cdc6884140bcd5b71b63c876d66152387c0f" translate="yes" xml:space="preserve">
          <source>The total number data queries sent to the /api/query endpoint that completed successfully. Note that these may have returned an empty result. (v2.2)</source>
          <target state="translated">성공적으로 완료된 / api / query 엔드 포인트로 전송 된 총 데이터 쿼리 수입니다. 이것들은 빈 결과를 반환했을 수도 있습니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="9973186aa110e7d56d88d057adb7c24784cd79e0" translate="yes" xml:space="preserve">
          <source>The total number data queries sent to the /api/query endpoint that threw an exception due to bad user input or an underlying error. See logs for details. (v2.2)</source>
          <target state="translated">잘못된 사용자 입력 또는 기본 오류로 인해 예외를 발생시킨 / api / query 엔드 포인트로 전송 된 총 데이터 쿼리 수입니다. 자세한 내용은 로그를 참조하십시오. (v2.2)</target>
        </trans-unit>
        <trans-unit id="3fff48fcab5e2917cf838e274c09fe3f1aba1ca0" translate="yes" xml:space="preserve">
          <source>The total number data queries sent to the /api/query endpoint that were invalid due to user errors such as using the wrong HTTP method, missing parameters or using metrics and tags without UIDs. (v2.2)</source>
          <target state="translated">잘못된 HTTP 메소드 사용, 매개 변수 누락 또는 UID가없는 메트릭 및 태그 사용과 같은 사용자 오류로 인해 유효하지 않은 / api / query 엔드 포인트로 전송 된 총 데이터 쿼리 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="dbbd5d3c97a2c63c0a29f44cca3bd7e497f6b4d4" translate="yes" xml:space="preserve">
          <source>The total number exceptions caught during RPC calls. These may be user error or bugs.</source>
          <target state="translated">RPC 호출 중에 발생한 총 예외 수입니다. 사용자 오류 또는 버그 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1062ef9c9250429ec7314de8926389b316cbf649" translate="yes" xml:space="preserve">
          <source>The total number of &lt;code&gt;put&lt;/code&gt; requests for writing data points</source>
          <target state="translated">데이터 포인트 쓰기에 대한 총 &lt;code&gt;put&lt;/code&gt; 요청 수</target>
        </trans-unit>
        <trans-unit id="5d12dd55b0dc5376b6cd0b8c0bb68d7a008756be" translate="yes" xml:space="preserve">
          <source>The total number of Delete requests performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 삭제 요청 수</target>
        </trans-unit>
        <trans-unit id="221e64aad27f9c41f0d04e1356ebed12bb08ba92" translate="yes" xml:space="preserve">
          <source>The total number of Get requests performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 Get 요청 수</target>
        </trans-unit>
        <trans-unit id="5fc6fd3aaea7dbc3d15ff57c8cbc981304373f5b" translate="yes" xml:space="preserve">
          <source>The total number of Http RPC requests received</source>
          <target state="translated">수신 된 총 HTTP RPC 요청 수</target>
        </trans-unit>
        <trans-unit id="c12389d71fc7ecf74a62f9a030474891993bd0b8" translate="yes" xml:space="preserve">
          <source>The total number of Http RPC requests received and handled by a plugin instead of the built-in APIs. (v2.2)</source>
          <target state="translated">내장 API 대신 플러그인이 수신하고 처리 한 총 HTTP RPC 요청 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="a83dbe59fb62fc9a061d856f895278f4f6de8e45" translate="yes" xml:space="preserve">
          <source>The total number of Increment requests performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 증가 요청 수</target>
        </trans-unit>
        <trans-unit id="12b8776cf18cd839538e3c98ef84e13bf02e48c0" translate="yes" xml:space="preserve">
          <source>The total number of No Such Region Exceptions caught. These can happen when a region server crashes, is taken offline or when a region splits (?)</source>
          <target state="translated">발생한 해당 지역 예외 없음의 총 수입니다. 리전 서버가 충돌하거나 오프라인 상태가되거나 리전이 분할 된 경우 (?)</target>
        </trans-unit>
        <trans-unit id="f6f251c821ad3565827da0f954bbb0cc1cfdeb29" translate="yes" xml:space="preserve">
          <source>The total number of Open Scanner requests performed by the</source>
          <target state="translated">에 의해 수행 된 총 Open Scanner 요청 수</target>
        </trans-unit>
        <trans-unit id="8f58692484c1e038ed564d19f6e984dd0cc1c4b6" translate="yes" xml:space="preserve">
          <source>The total number of Put requests performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 Put 요청 수</target>
        </trans-unit>
        <trans-unit id="496dbf7ef2aa7b1415c61275342785ec4ce81f31" translate="yes" xml:space="preserve">
          <source>The total number of RPC errors caused by HBase exceptions</source>
          <target state="translated">HBase 예외로 인한 총 RPC 오류 수</target>
        </trans-unit>
        <trans-unit id="36473b84707596f83fb479eb601721e7ccba5406" translate="yes" xml:space="preserve">
          <source>The total number of RPC errors caused by attempts to &lt;code&gt;put&lt;/code&gt; a metric without an assigned UID. This only increments if &lt;em&gt;auto metrics&lt;/em&gt; is disabled.</source>
          <target state="translated">시도에 의한 RPC 오류의 총 수는 다음의 제품에 &lt;code&gt;put&lt;/code&gt; 할당 된 UID없이 메트릭을. &lt;em&gt;자동 메트릭&lt;/em&gt; 이 비활성화 된 경우에만 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="f2ffe0fcbea61eed4d2f23db8672269c97ffc786" translate="yes" xml:space="preserve">
          <source>The total number of RPC errors caused by bad data from the user</source>
          <target state="translated">사용자의 잘못된 데이터로 인한 총 RPC 오류 수</target>
        </trans-unit>
        <trans-unit id="5743e9e1cbcd2c2553b23a42b81913732167f08f" translate="yes" xml:space="preserve">
          <source>The total number of RPC errors caused invalid &lt;code&gt;put&lt;/code&gt; values from user requests, such as a string instead of a number</source>
          <target state="translated">총 RPC 오류 수로 인해 숫자 대신 문자열과 같이 사용자 요청에서 잘못된 &lt;code&gt;put&lt;/code&gt; 값이 발생 했습니다.</target>
        </trans-unit>
        <trans-unit id="f2adc23b8826a4585a90f46428fe6bb1bb285252" translate="yes" xml:space="preserve">
          <source>The total number of RPCs sent to HBase.</source>
          <target state="translated">HBase로 전송 된 총 RPC 수입니다.</target>
        </trans-unit>
        <trans-unit id="d423d164c40e67c7160691a47b05de2318b1ce17" translate="yes" xml:space="preserve">
          <source>The total number of RPCs that have timed out. This may indicate a slow region server, poor network performance or GC issues with the TSD.</source>
          <target state="translated">시간이 초과 된 총 RPC 수입니다. 이는 TSD의 느린 서버, 네트워크 성능 저하 또는 GC 문제를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="686ad84878031c70b3d206b68721f167e5a3b46d" translate="yes" xml:space="preserve">
          <source>The total number of Row Lock requests performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 행 잠금 요청 수</target>
        </trans-unit>
        <trans-unit id="b371b780ae435dd53e61190f9d18b4b42a7a85d9" translate="yes" xml:space="preserve">
          <source>The total number of Scan requests performed by the client. These indicate a scan-&amp;gt;next() call.</source>
          <target state="translated">클라이언트가 수행 한 총 스캔 요청 수입니다. 이것은 scan-&amp;gt; next () 호출을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d8cad79cdfa5eef9757599cc46153bc22dc8aea" translate="yes" xml:space="preserve">
          <source>The total number of batched requests sent by the client</source>
          <target state="translated">클라이언트가 보낸 일괄 처리 된 총 요청 수</target>
        </trans-unit>
        <trans-unit id="2a63e8db3498ccb1794cf38cf3b4c1184d5bae7a" translate="yes" xml:space="preserve">
          <source>The total number of calls delayed due to an NSRE that were later successfully executed</source>
          <target state="translated">나중에 성공적으로 실행 된 NSRE로 인해 지연된 총 통화 수</target>
        </trans-unit>
        <trans-unit id="8c53888723b36b0724ff1726856bf196fc2c1ffa" translate="yes" xml:space="preserve">
          <source>The total number of complex compactions performed by the TSD</source>
          <target state="translated">TSD에 의해 수행 된 총 복합 압축 수</target>
        </trans-unit>
        <trans-unit id="bcb99174d34a025edaba2c371a735867ebd9eabc" translate="yes" xml:space="preserve">
          <source>The total number of connections made by the client to region servers</source>
          <target state="translated">클라이언트가 리젼 서버로 연결 한 총 연결 수</target>
        </trans-unit>
        <trans-unit id="9cd00fa6239a545e612edce0822b794f876dc448" translate="yes" xml:space="preserve">
          <source>The total number of connections made to OpenTSDB. This includes all Telnet and HTTP connections.</source>
          <target state="translated">OpenTSDB에 대한 총 연결 수입니다. 여기에는 모든 텔넷 및 HTTP 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="77e7b1c8345130e2d2ecc43d019365912aa53207" translate="yes" xml:space="preserve">
          <source>The total number of connections opened to region servers since the TSD started. If this number is climbing the region servers may be crashing and restarting. (v2.2)</source>
          <target state="translated">TSD가 시작된 이후 리젼 서버에 열린 총 연결 수입니다. 이 수가 증가하면 리젼 서버가 충돌하고 다시 시작될 수 있습니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="d93c14ad925b79a3120214161fe805967ca28229" translate="yes" xml:space="preserve">
          <source>The total number of connections to region servers that were closed due to idle connections. This indicates nothing was read from or written to a server in some time and the TSD will reconnect when it needs to. (v2.2)</source>
          <target state="translated">유휴 연결로 인해 닫힌 지역 서버에 대한 총 연결 수입니다. 이는 서버에서 읽거나 읽지 않은 것을 나타내며 TSD는 필요할 때 다시 연결됩니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="82e7653e95c6486b303454167056e5adc883c914" translate="yes" xml:space="preserve">
          <source>The total number of contended meta table lookups performed by the client</source>
          <target state="translated">클라이언트가 수행 한 경합 메타 테이블 조회의 총 수</target>
        </trans-unit>
        <trans-unit id="e3ca4092c2545803d4000682f3c64ae63c04af98" translate="yes" xml:space="preserve">
          <source>The total number of data points found during compaction that were duplicates at the same time and with the same value. (v2.2)</source>
          <target state="translated">압축 중 발견 된 동일한 데이터 값과 동시에 중복 된 총 데이터 포인트 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="415385239c6fb7dc7b463d55996138ac1b1fc82c" translate="yes" xml:space="preserve">
          <source>The total number of data points found during compaction that were duplicates at the same time but with a different value. (v2.2)</source>
          <target state="translated">압축 중에 발견되었지만 동시에 다른 값을 가진 총 데이터 포인트 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="c2a8f30e7bc63321972f3b2d8ab8c97e68a2d939" translate="yes" xml:space="preserve">
          <source>The total number of data points recorded for the timeseries. NOTE: This may not be accurate unless you have enabled metadata tracking since creating the TSDB tables.</source>
          <target state="translated">시계열에 대해 기록 된 총 데이터 포인트 수입니다. 참고 : TSDB 테이블을 생성 한 후 메타 데이터 추적을 활성화하지 않으면 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c0fa34de1674c3dd1abb90f22a5a8feb3a37dc" translate="yes" xml:space="preserve">
          <source>The total number of data points returned to the user after aggregation</source>
          <target state="translated">집계 후 사용자에게 반환 된 총 데이터 포인트 수</target>
        </trans-unit>
        <trans-unit id="ce6130355b3dd1eacef97d5c910f2e741b24fecc" translate="yes" xml:space="preserve">
          <source>The total number of data points serialized in the output. Note that this may include NaNs or Nulls if the query specified such.</source>
          <target state="translated">출력에서 직렬화 된 총 데이터 포인트 수입니다. 쿼리에 지정된 경우 NaN 또는 Null이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17943109f66df6c249a399f513d21965d0cef278" translate="yes" xml:space="preserve">
          <source>The total number of delete calls made to storage to remove old data that has been compacted. (v2.2)</source>
          <target state="translated">압축 된 이전 데이터를 제거하기 위해 스토리지에 작성된 총 삭제 호출 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="d436ce2c50966127048509b425c806846c934d7f" translate="yes" xml:space="preserve">
          <source>The total number of exceptions caused by a client disconnecting without closing the socket. This includes all Telnet and HTTP connections.</source>
          <target state="translated">소켓을 닫지 않고 클라이언트 연결이 끊어져 발생한 총 예외 수입니다. 여기에는 모든 텔넷 및 HTTP 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6724594a5963286ca94f1ec2a693a11bb0444802" translate="yes" xml:space="preserve">
          <source>The total number of exceptions caused by writes to a channel that was already closed. This can occur if a query takes too long, the client closes their connection gracefully, and the TSD attempts to write to the socket. This includes all Telnet and HTTP connections.</source>
          <target state="translated">이미 닫힌 채널에 대한 쓰기로 인해 발생한 총 예외 수입니다. 쿼리가 너무 오래 걸리고 클라이언트가 연결을 정상적으로 종료 한 후 TSD가 소켓에 쓰려고 시도하는 경우에 발생할 수 있습니다. 여기에는 모든 텔넷 및 HTTP 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a49427592d0d6f0219b890ed6d2e0ee0ac8b557f" translate="yes" xml:space="preserve">
          <source>The total number of failed cache lookups for metric UIDs that required a call to storage</source>
          <target state="translated">스토리지에 대한 호출이 필요한 메트릭 UID에 대한 총 캐시 실패 조회 수</target>
        </trans-unit>
        <trans-unit id="14ecaa795aba4a6e539df4316d488bf6e1c232fc" translate="yes" xml:space="preserve">
          <source>The total number of failed cache lookups for tagk UIDs that required a call to storage</source>
          <target state="translated">스토리지 호출이 필요한 태그 UID에 대해 실패한 총 캐시 조회 수</target>
        </trans-unit>
        <trans-unit id="dba2eaadf4eecd4fc3f5eb14134b8f60cadbd8d2" translate="yes" xml:space="preserve">
          <source>The total number of failed cache lookups for tagv UIDs that required a call to storage</source>
          <target state="translated">스토리지 호출이 필요한 tagv UID에 대한 총 캐시 실패 조회 수</target>
        </trans-unit>
        <trans-unit id="5b2c3b743b1f4bcc2c59666486c685c8b34a7010" translate="yes" xml:space="preserve">
          <source>The total number of flushes performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 플러시 수</target>
        </trans-unit>
        <trans-unit id="e2886bd8a557a12f4e81b9a456da1855cf006a3f" translate="yes" xml:space="preserve">
          <source>The total number of graph requests satisfied from the disk cache</source>
          <target state="translated">디스크 캐시에서 충족 된 총 그래프 요청 수</target>
        </trans-unit>
        <trans-unit id="496af99794a7800114f9bee6c9544d6f55e6621d" translate="yes" xml:space="preserve">
          <source>The total number of graph requests that were not cached and required a fetch from storage</source>
          <target state="translated">캐시되지 않았으며 스토리지에서 페치해야하는 총 그래프 요청 수</target>
        </trans-unit>
        <trans-unit id="01b49a908f3d1c7d788418be4405d1cb90a5fa76" translate="yes" xml:space="preserve">
          <source>The total number of responses from HBase for RPCs that have previously timedout. This means HBase may be catching up and responding to stale RPCs.</source>
          <target state="translated">이전에 시간 초과 된 RPC에 대한 HBase의 총 응답 수입니다. 이는 HBase가 오래된 RPC를 따라 잡고 응답 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3b68792b0290c4301805d78b50dea54043d5b8e4" translate="yes" xml:space="preserve">
          <source>The total number of responses received from HBase for which we couldn't find an RPC. This may indicate packet corruption or an incompatible HBase version.</source>
          <target state="translated">RPC를 찾을 수없는 HBase로부터받은 총 응답 수입니다. 이는 패킷 손상 또는 호환되지 않는 HBase 버전을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dddac542d3608eaf39d0ca1720ba53289836a9d" translate="yes" xml:space="preserve">
          <source>The total number of results matched by the query</source>
          <target state="translated">쿼리와 일치하는 총 결과 수</target>
        </trans-unit>
        <trans-unit id="370115b5a52ca60a9fd5a15c4f8c917afa4847da" translate="yes" xml:space="preserve">
          <source>The total number of root lookups performed by the client</source>
          <target state="translated">클라이언트가 수행 한 총 루트 조회 수</target>
        </trans-unit>
        <trans-unit id="38752b937fa910ed5d0b440441b590bc050a7057" translate="yes" xml:space="preserve">
          <source>The total number of rows that couldn't be re-written to storage due to an error of some sort. (v2.2)</source>
          <target state="translated">일종의 오류로 인해 스토리지에 다시 쓸 수없는 총 행 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="279a160b8d01a2f8b9da11dae8a2e7a741503802" translate="yes" xml:space="preserve">
          <source>The total number of rows that couldn't be read from storage due to an error of some sort. (v2.2)</source>
          <target state="translated">일종의 오류로 인해 스토리지에서 읽을 수없는 총 행 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="51ef7a96dcd9d75e6d29b9ca216fa55f1eece0cb" translate="yes" xml:space="preserve">
          <source>The total number of rows that couldn't have the old non-compacted data deleted from storage due to an error of some sort. (v2.2)</source>
          <target state="translated">일종의 오류로 인해 스토리지에서 오래된 비 압축 데이터를 삭제할 수 없었던 총 행 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="5a051ae2a8afdf0c927c2bb8f807f53105af5b1b" translate="yes" xml:space="preserve">
          <source>The total number of successful cache lookups for metric UIDs</source>
          <target state="translated">메트릭 UID에 대한 총 캐시 조회 수</target>
        </trans-unit>
        <trans-unit id="8162c3099d67f9b7b5ce53c2b3cb7375bb19d1f4" translate="yes" xml:space="preserve">
          <source>The total number of successful cache lookups for tagk UIDs</source>
          <target state="translated">tagk UID에 대한 총 캐시 조회 수</target>
        </trans-unit>
        <trans-unit id="696f182b0d7b89ecd241147a6112103802c80df3" translate="yes" xml:space="preserve">
          <source>The total number of successful cache lookups for tagv UIDs</source>
          <target state="translated">tagv UID에 대한 총 캐시 조회 수</target>
        </trans-unit>
        <trans-unit id="e251d90703033688a7156510f47f05032949d082" translate="yes" xml:space="preserve">
          <source>The total number of telnet RPC requests received</source>
          <target state="translated">수신 된 총 Telnet RPC 요청 수</target>
        </trans-unit>
        <trans-unit id="9b1c07b3246c02eb0068024fff4cfb3b652348fc" translate="yes" xml:space="preserve">
          <source>The total number of times RPCs were blocked due to too many outstanding RPCs waiting for a response from HBase. A positive value indicates the region server is slow or network performance is poor.</source>
          <target state="translated">HBase의 응답을 기다리는 미해결 RPC가 너무 많아 RPC가 차단 된 총 횟수입니다. 양수 값은 리젼 서버가 느리거나 네트워크 성능이 좋지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d2660c4bb31250407f3bb890daa8c205f2076ecd" translate="yes" xml:space="preserve">
          <source>The total number of times the TSD was unable to write back to the telnet socket due to a full buffer. If this happens it likely means a number of exceptions were happening. (v2.2)</source>
          <target state="translated">전체 버퍼로 인해 TSD가 텔넷 소켓에 다시 쓸 수없는 총 횟수입니다. 이 경우 많은 예외가 발생했음을 의미합니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="d32bffdd0f6e09fb130fbc132f40b8c02845fd91" translate="yes" xml:space="preserve">
          <source>The total number of times writes to a new region client were discarded because it's pending RPC buffer was full. This should almost always be zero and a positive value indicates the TSD took a long time to connect to a region server.</source>
          <target state="translated">보류중인 RPC 버퍼가 가득 차서 새 리전 클라이언트에 대한 쓰기가 삭제 된 총 횟수입니다. 거의 항상 0이어야하고 양수 값은 TSD가 리젼 서버에 연결하는 데 오랜 시간이 걸렸음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f0c9368290dce0eee4958e2f4df35735d592d066" translate="yes" xml:space="preserve">
          <source>The total number of trivial compactions performed by the TSD</source>
          <target state="translated">TSD가 수행 한 사소한 압축 횟수</target>
        </trans-unit>
        <trans-unit id="d72046ce6c6d9ab17e010fc21d9dd5ea9aa131f1" translate="yes" xml:space="preserve">
          <source>The total number of uncontended meta table lookups performed by the client</source>
          <target state="translated">클라이언트가 수행 한 비경쟁 메타 테이블 조회의 총 수</target>
        </trans-unit>
        <trans-unit id="322af25b51b01d21f023dc490e0caa5fad305523" translate="yes" xml:space="preserve">
          <source>The total number of writes back to storage of compacted values. (v2.2)</source>
          <target state="translated">압축 된 값을 저장하기위한 총 쓰기 수입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="d102fd64cebfe1514d7b12a007274f93e367df5b" translate="yes" xml:space="preserve">
          <source>The total time from initialization of the scanner to when the scanner completed and closed.</source>
          <target state="translated">스캐너 초기화부터 스캐너가 완료되어 닫힐 때까지의 총 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ad56ca1176ad280f1ad30491f01dbfa9705752df" translate="yes" xml:space="preserve">
          <source>The tree the requested rule belongs to</source>
          <target state="translated">요청한 규칙이 속한 트리</target>
        </trans-unit>
        <trans-unit id="930086a8eea5fe112013bc42e5d3b7c6ce7176a0" translate="yes" xml:space="preserve">
          <source>The type of UID, must be &lt;code&gt;metric&lt;/code&gt;, &lt;code&gt;tagk&lt;/code&gt; or &lt;code&gt;tagv&lt;/code&gt;</source>
          <target state="translated">UID 유형은 &lt;code&gt;metric&lt;/code&gt; , &lt;code&gt;tagk&lt;/code&gt; 또는 &lt;code&gt;tagv&lt;/code&gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f0e7f2bf13343fde65ee3f9284fefcdb9a3fc473" translate="yes" xml:space="preserve">
          <source>The type of data to auto complete on. Must be one of the following: &lt;strong&gt;metrics&lt;/strong&gt;, &lt;strong&gt;tagk&lt;/strong&gt; or &lt;strong&gt;tagv&lt;/strong&gt;</source>
          <target state="translated">자동 완성 할 데이터 유형입니다. &lt;strong&gt;metrics&lt;/strong&gt; , &lt;strong&gt;tagk&lt;/strong&gt; 또는 &lt;strong&gt;tagv&lt;/strong&gt; 중 하나 여야합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37091c2adf7e45b05b33de559d111cde2b6ac764" translate="yes" xml:space="preserve">
          <source>The type of query submitted, i.e. the endpoint called.</source>
          <target state="translated">제출 된 쿼리의 유형 (예 : 호출 된 엔드 포인트)</target>
        </trans-unit>
        <trans-unit id="30e1363af28fab79a20e5eced03013eb3c1903f4" translate="yes" xml:space="preserve">
          <source>The type of query submitted, i.e. the endpoint called. Will be one of the endpoints listed above.</source>
          <target state="translated">제출 된 쿼리의 유형 (예 : 호출 된 엔드 포인트) 위에 나열된 엔드 포인트 중 하나가됩니다.</target>
        </trans-unit>
        <trans-unit id="65ab5ae2d798671ac4e6bd10b728c960bbae32c3" translate="yes" xml:space="preserve">
          <source>The type of rule represented. See &lt;a href=&quot;../../user_guide/trees&quot;&gt;&lt;em&gt;Trees&lt;/em&gt;&lt;/a&gt;. &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;*&lt;/span&gt;&lt;/a&gt;Required when creating a new rule.</source>
          <target state="translated">표현 된 규칙의 유형. &lt;a href=&quot;../../user_guide/trees&quot;&gt;&lt;em&gt;나무를&lt;/em&gt;&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;*&lt;/span&gt;&lt;/a&gt; 새 규칙을 만들 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a2646ead7d3c71bd6aa41ebd25aa6727da07bcce" translate="yes" xml:space="preserve">
          <source>The type of the UID the name represent. Must be one of &lt;code&gt;metrics&lt;/code&gt;, &lt;code&gt;tagk&lt;/code&gt; or &lt;code&gt;tagv&lt;/code&gt;</source>
          <target state="translated">이름이 나타내는 UID의 유형입니다. 중 하나 여야합니다 &lt;code&gt;metrics&lt;/code&gt; , &lt;code&gt;tagk&lt;/code&gt; 또는 &lt;code&gt;tagv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e308fccb54801a945c7a717f922162ca6a5dcf5" translate="yes" xml:space="preserve">
          <source>The type of the UID the names represent. Must be one of &lt;code&gt;metrics&lt;/code&gt;, &lt;code&gt;tagk&lt;/code&gt; or &lt;code&gt;tagv&lt;/code&gt;</source>
          <target state="translated">이름이 나타내는 UID의 유형입니다. 중 하나 여야합니다 &lt;code&gt;metrics&lt;/code&gt; , &lt;code&gt;tagk&lt;/code&gt; 또는 &lt;code&gt;tagv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e8003c957a4624cbcc0e5a1002c8926406b1a2f" translate="yes" xml:space="preserve">
          <source>The type of the UID to search for. Must be one of &lt;code&gt;metrics&lt;/code&gt;, &lt;code&gt;tagk&lt;/code&gt; or &lt;code&gt;tagv&lt;/code&gt;</source>
          <target state="translated">검색 할 UID의 유형입니다. 중 하나 여야합니다 &lt;code&gt;metrics&lt;/code&gt; , &lt;code&gt;tagk&lt;/code&gt; 또는 &lt;code&gt;tagv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c84b62f7052ca739576428709222b8130a5e6498" translate="yes" xml:space="preserve">
          <source>The value must be a number. It may be an integer (maximum and minimum values of Java's &lt;code&gt;long&lt;/code&gt; data type), a floating point value or scientific notation (in the format &lt;code&gt;[-]&amp;lt;#&amp;gt;.&amp;lt;#&amp;gt;[e|E][-]&amp;lt;#&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">값은 숫자 여야합니다. 정수 (Java &lt;code&gt;long&lt;/code&gt; 데이터 유형 의 최대 값 및 최소값 ), 부동 소수점 값 또는 과학적 표기법 ( &lt;code&gt;[-]&amp;lt;#&amp;gt;.&amp;lt;#&amp;gt;[e|E][-]&amp;lt;#&amp;gt;&lt;/code&gt; ) 일 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="d26fa4693759e7ab9e7a4125474c7c848b219460" translate="yes" xml:space="preserve">
          <source>The value of the data point enclosed in quotation marks as a string</source>
          <target state="translated">따옴표로 묶은 데이터 요소의 값을 문자열로</target>
        </trans-unit>
        <trans-unit id="2aa559d7a54d337b47e006c63da7f40cb23f6c8b" translate="yes" xml:space="preserve">
          <source>The value to filter on. This depends on the filter in use. See the API for details</source>
          <target state="translated">필터링 할 값입니다. 사용중인 필터에 따라 다릅니다. 자세한 내용은 API를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="b8f64926c04e10167fad7484c5f019616a6e977d" translate="yes" xml:space="preserve">
          <source>The value to record for this data point. It may be quoted or not quoted and must conform to the OpenTSDB value rules: &lt;code&gt;../../user_guide/writing&lt;/code&gt;</source>
          <target state="translated">이 데이터 포인트에 대해 기록 할 값입니다. 인용되거나 인용되지 않을 수 있으며 OpenTSDB 값 규칙을 준수해야합니다. &lt;code&gt;../../user_guide/writing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42c48be25424005988158a77356f56aedd628103" translate="yes" xml:space="preserve">
          <source>The various formats are listed below. The &lt;code&gt;\t&lt;/code&gt; expression represents a tab. &lt;code&gt;space&lt;/code&gt; indicates a space character.</source>
          <target state="translated">다양한 형식이 아래에 나열되어 있습니다. &lt;code&gt;\t&lt;/code&gt; 표현은 탭을 나타냅니다. &lt;code&gt;space&lt;/code&gt; 은 공백 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5c58119eb81ebc9f99e4c6813e78bd4336ace299" translate="yes" xml:space="preserve">
          <source>The various sections implemented include:</source>
          <target state="translated">구현 된 다양한 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69263e7df3167d4896202d18f2cb39b64751945d" translate="yes" xml:space="preserve">
          <source>The width, in bytes, of metric UIDs. &lt;strong&gt;WARNING&lt;/strong&gt; Do not change after writing data to HBase or you will corrupt your tables and not be able to query any more.</source>
          <target state="translated">메트릭 UID의 너비 (바이트)입니다. &lt;strong&gt;경고&lt;/strong&gt; HBase에 데이터를 쓴 후 변경하지 마십시오. 그렇지 않으면 테이블이 손상되어 더 이상 쿼리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="20e3a956de9714dd26ae2c2d758c9215f237aa9f" translate="yes" xml:space="preserve">
          <source>The width, in bytes, of tag name UIDs. &lt;strong&gt;WARNING&lt;/strong&gt; Do not change after writing data to HBase or you will corrupt your tables and not be able to query any more.</source>
          <target state="translated">태그 이름 UID의 너비 (바이트)입니다. &lt;strong&gt;경고&lt;/strong&gt; HBase에 데이터를 쓴 후 변경하지 마십시오. 그렇지 않으면 테이블이 손상되어 더 이상 쿼리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="f2ab8b06b2956a28f95907111d3ab635f705608a" translate="yes" xml:space="preserve">
          <source>The width, in bytes, of tag value UIDs. &lt;strong&gt;WARNING&lt;/strong&gt; Do not change after writing data to HBase or you will corrupt your tables and not be able to query any more.</source>
          <target state="translated">태그 값 UID의 너비 (바이트)입니다. &lt;strong&gt;경고&lt;/strong&gt; HBase에 데이터를 쓴 후 변경하지 마십시오. 그렇지 않으면 테이블이 손상되어 더 이상 쿼리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="eaf339cb70d5f4d21555724b9e22186f1aed4975" translate="yes" xml:space="preserve">
          <source>The width, in bytes, of the salt prefix used to indicate which bucket a time series belongs in. A value of 0 means salting is disabled. &lt;strong&gt;WARNING&lt;/strong&gt; Do not change after writing data to HBase or you will corrupt your tables and not be able to query any more.</source>
          <target state="translated">시계열이 속하는 버킷을 나타내는 데 사용되는 솔트 접두사의 너비 (바이트)입니다. 값이 0이면 솔트가 비활성화됨을 의미합니다. &lt;strong&gt;경고&lt;/strong&gt; HBase에 데이터를 쓴 후 변경하지 마십시오. 그렇지 않으면 테이블이 손상되어 더 이상 쿼리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="48f5c25fa38e88bf674150c9d7238e3a27afc87f" translate="yes" xml:space="preserve">
          <source>The zone where your Bigtable cluster is operating; chosen at creation.</source>
          <target state="translated">Bigtable 클러스터가 작동하는 영역입니다. 창조시 선택.</target>
        </trans-unit>
        <trans-unit id="0df5c661a026c9e8d851885023819c18a0370354" translate="yes" xml:space="preserve">
          <source>Then click the &lt;code&gt;From&lt;/code&gt; box at the top and a date-picker pop-up should appear. Select any time from yesterday and click on another box. At this point you should see &quot;Loading graph..&quot; very briefly followed by the actual graph. If the graph is empty, it may not have found the most recent data points so click the &lt;code&gt;(now)&lt;/code&gt; link and the page should refresh.</source>
          <target state="translated">그런 다음 클릭 &lt;code&gt;From&lt;/code&gt; 상단에있는 상자와 날짜 선택기 팝업이 나타납니다. 어제부터 시간을 선택하고 다른 상자를 클릭하십시오. 이 시점에서 &quot;그래프로드 중&quot;이라는 메시지가 표시됩니다. 그래프가 비어 있으면 최신 데이터 포인트를 찾지 못했을 수 있으므로 &lt;code&gt;(now)&lt;/code&gt; 링크를 클릭하면 페이지가 새로 고쳐집니다.</target>
        </trans-unit>
        <trans-unit id="d3b7ebbaff2c841d9837d162e41d90bbd44acf27" translate="yes" xml:space="preserve">
          <source>Then define a host in nagios for your TSD server(s). You can give it a check_command that is guaranteed to always return something if the backend is healthy.</source>
          <target state="translated">그런 다음 TSD 서버의 호스트를 nagios로 정의하십시오. 백엔드가 정상이면 항상 무언가를 반환하도록 보장하는 check_command를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6876c62eb70cfe6b8711723a3784d118546a643" translate="yes" xml:space="preserve">
          <source>Then define some service checks for the things you want to monitor.</source>
          <target state="translated">그런 다음 모니터링 할 사항에 대한 서비스 점검을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="2ca0f243f2f1272256a4da48a4e19568ea1a7180" translate="yes" xml:space="preserve">
          <source>Then each group of data is aggregated using the specific aggregation function</source>
          <target state="translated">그런 다음 특정 집계 함수를 사용하여 각 데이터 그룹을 집계합니다.</target>
        </trans-unit>
        <trans-unit id="63284ed2453cef2f8bebb895d4c247f2756af494" translate="yes" xml:space="preserve">
          <source>Then it sets up a scanner for the underlying storage system.</source>
          <target state="translated">그런 다음 기본 스토리지 시스템에 대한 스캐너를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="66dcc1ff3d161d0a99ed961f678a4496ffa6ec09" translate="yes" xml:space="preserve">
          <source>There are a number of potential causes for this problem including:</source>
          <target state="translated">이 문제의 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7895001178ade180a1f558f03068b4e86ec3c92c" translate="yes" xml:space="preserve">
          <source>There are a number of ways to setup a Hadoop/HBase cluster and a ton of various tuning tweaks to make, so Google around and ask user groups for advice. Some general recommendations include:</source>
          <target state="translated">Hadoop / HBase 클러스터 및 다양한 튜닝 조정을 설정하는 방법에는 여러 가지가 있으므로 Google은 사용자 그룹을 둘러보고 조언을 요청합니다. 몇 가지 일반적인 권장 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba96c9a8aba116571fb0c92d1a45ab13d7347a4d" translate="yes" xml:space="preserve">
          <source>There are almost as many build systems as there are developers so it's impossible to satisfy everyone no matter which system or layout is chosen. Autotools and GNU Make were chosen early on for OpenTSDB because of their flexibility, portability, and especially speed and popular usage. It's not the easiest to configure but for our needs, it's really not too difficult. We'll spell out what you need to change below and give tips for IDE users who want to setup an environment. Note that the build script can now compile a &lt;code&gt;pom.xml&lt;/code&gt; file for compiling with Maven and work is underway to provide better Maven support. However you still have to modify &lt;code&gt;Makefile.am&lt;/code&gt; if you add or remove classes or dependencies and such.</source>
          <target state="translated">개발자만큼 빌드 시스템이 거의 있으므로 어떤 시스템이나 레이아웃을 선택하더라도 모든 사람을 만족시킬 수는 없습니다. Autotools와 GNU Make는 유연성, 이식성, 특히 속도와 대중적인 사용으로 OpenTSDB를 위해 초기에 선택되었습니다. 구성하는 것이 가장 쉽지는 않지만 우리의 요구에 따라 실제로 그렇게 어렵지는 않습니다. 아래에서 변경해야 할 사항을 설명하고 환경을 설정하려는 IDE 사용자를위한 팁을 제공합니다. 빌드 스크립트는 이제 Maven으로 컴파일하기 위해 &lt;code&gt;pom.xml&lt;/code&gt; 파일을 컴파일 할 수 있으며 더 나은 Maven 지원을 제공하기위한 작업이 진행 중입니다. 그러나 클래스 나 종속성 등을 추가하거나 제거하는 경우 여전히 &lt;code&gt;Makefile.am&lt;/code&gt; 을 수정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="d057ae687c726f63028fec43b1e21c2e1540fe97" translate="yes" xml:space="preserve">
          <source>There are currently three main methods to get data into OpenTSDB: Telnet API, HTTP API and batch import from a file. Alternatively you can use a tool that provides OpenTSDB support, or if you're extremely adventurous, use the Java library.</source>
          <target state="translated">현재 OpenTSDB로 데이터를 가져 오는 세 가지 주요 방법은 Telnet API, HTTP API 및 파일에서 일괄 가져 오기입니다. 또는 OpenTSDB 지원을 제공하는 도구를 사용하거나 매우 모험적인 경우 Java 라이브러리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4ef7b05c4f6a4207ced602f8bf9a48e5d20804b7" translate="yes" xml:space="preserve">
          <source>There are four hooks available, and they are called in this order:</source>
          <target state="translated">사용 가능한 네 가지 후크가 있으며 다음 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="989225c129cce6949b9e94a97e1b702248becc57" translate="yes" xml:space="preserve">
          <source>There are three main areas of the GUI:</source>
          <target state="translated">GUI에는 세 가지 주요 영역이 있습니다.</target>
        </trans-unit>
        <trans-unit id="245bade0901d8c08351eefd7c3ca74185fc84583" translate="yes" xml:space="preserve">
          <source>There are three types of rolled up data:</source>
          <target state="translated">롤업 데이터에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2d1ec80b469f7195e79b964aa92890b58b5ffd" translate="yes" xml:space="preserve">
          <source>There are two main branches in the GIT repo. The &lt;code&gt;master&lt;/code&gt; branch is the latest stable release along with any bug fixes that have been committed between releases. Currently, the &lt;code&gt;master&lt;/code&gt; branch is OpenTSDB 2.0.1. The &lt;code&gt;next&lt;/code&gt; branch is the next major or minor version of OpenTSDB with new features and development. When &lt;code&gt;next&lt;/code&gt; is stable, it will be merged into &lt;code&gt;master&lt;/code&gt;. Currently the &lt;code&gt;next&lt;/code&gt; branch is 2.1.0 RC 1. Additional branches may be present and are used for testing or developing specific features.</source>
          <target state="translated">GIT 리포에는 두 가지 주요 지점이 있습니다. &lt;code&gt;master&lt;/code&gt; 브랜치는 릴리스 사이에 약속 된 모든 버그 수정과 함께 최신의 안정적인 릴리스입니다. 현재 &lt;code&gt;master&lt;/code&gt; 브랜치는 OpenTSDB 2.0.1입니다. &lt;code&gt;next&lt;/code&gt; 분기 새로운 기능과 개발 OpenTSDB의 다음 주요 또는 부 버전입니다. &lt;code&gt;next&lt;/code&gt; 이 안정 되면 &lt;code&gt;master&lt;/code&gt; 로 병합됩니다 . 현재 &lt;code&gt;next&lt;/code&gt; 분기는 2.1.0 RC 1입니다. 추가 분기가 존재할 수 있으며 특정 기능을 테스트하거나 개발하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b949991b3b4f7ffcd63402708e365b3ae0d78b1" translate="yes" xml:space="preserve">
          <source>There is a limited number of unique IDs to assign for each metric, tag name and tag value. By default there are just over 16 million possible IDs per type. If, for example, you ran a very popular web service and tried to track the IP address of clients as a tag, e.g. &lt;code&gt;web.app.hits clientip=38.26.34.10&lt;/code&gt;, you may quickly run into the UID assignment limit as there are over 4 billion possible IP version 4 addresses. Additionally, this approach would lead to creating a very sparse time series as the user at address &lt;code&gt;38.26.34.10&lt;/code&gt; may only use your app sporadically, or perhaps never again from that specific address.</source>
          <target state="translated">각 메트릭, 태그 이름 및 태그 값에 할당 할 고유 ID 수가 제한되어 있습니다. 기본적으로 유형 당 가능한 1600 만 개 이상의 ID가 있습니다. 예를 들어, 매우 인기있는 웹 서비스를 실행하고 클라이언트의 IP 주소를 태그로 추적하려고하면 (예 : &lt;code&gt;web.app.hits clientip=38.26.34.10&lt;/code&gt; ) UID 할당 제한이 초과 될 수 있습니다. 40 억 개의 가능한 IP 버전 4 주소. 또한이 방법은 주소 &lt;code&gt;38.26.34.10&lt;/code&gt; 의 사용자가 산발적으로 앱을 사용할 수 있거나 해당 특정 주소에서 다시는 사용하지 않을 수 있으므로 매우 드문 시계열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="eea61e713dc01c14e1334538087794d65b1d234e" translate="yes" xml:space="preserve">
          <source>There's a bunch of things in here that we've introduced so far. To help you understand how things work, I'll start with a typical example. Let's say you have a bunch of web servers and you want to track two things: hits to the web server and load average of the system. Let's make up metric names to express this. For load average, let's call it &lt;code&gt;proc.loadavg.1min&lt;/code&gt; (since on Linux you can easily get this data by reading &lt;code&gt;/proc/loadavg&lt;/code&gt;). For many web servers, there is a way to ask the web server for a counter expressing the number of hits to the server since it started. This is a convenient counter upon which to use for a metric we'll call &lt;code&gt;http.hits&lt;/code&gt;. I chose these two examples for two reasons. One, we'll get to see how OpenTSDB easily handles both counters (values that increase over time, except when they get reset by a restart/reboot or overflow) and how it handles normal values that go up and down, like load average. A great advantage of OpenTSDB is that you don't need to do any rate calculation of your counters. It will do it all for you. The second reason is that we can also show you how you can plot two different metrics with different scales on the same graph, which is a great way to correlate different metrics.</source>
          <target state="translated">여기에 우리가 지금까지 소개 한 것들이 많이 있습니다. 작동 방식을 이해하는 데 도움이되도록 전형적인 예부터 시작하겠습니다. 웹 서버가 많고 웹 서버에 대한 적중과 시스템의 평균로드 두 가지를 추적하려고한다고 가정 해 봅시다. 이것을 표현하기 위해 메트릭 이름을 만들어 봅시다. 평균로드의 경우이를 &lt;code&gt;proc.loadavg.1min&lt;/code&gt; 이라고합니다 (Linux에서는 &lt;code&gt;/proc/loadavg&lt;/code&gt; 를 읽어서이 데이터를 쉽게 얻을 수 있음 ). 많은 웹 서버의 경우, 웹 서버가 시작된 이후 서버에 대한 히트 수를 표시하는 카운터를 웹 서버에 요청하는 방법이 있습니다. 이것은 &lt;code&gt;http.hits&lt;/code&gt; 라고 부르는 메트릭에 사용할 편리한 카운터입니다.. 두 가지 이유로이 두 가지 예를 선택했습니다. 첫째, OpenTSDB가 두 카운터를 쉽게 처리하는 방법 (다시 시작 / 재부팅 또는 오버플로로 재설정되는 경우를 제외하고 시간이 지남에 따라 증가하는 값)과로드 평균과 같이 올라가거나 내려가는 정상 값을 처리하는 방법을 살펴 보겠습니다. OpenTSDB의 가장 큰 장점은 카운터를 계산할 필요가 없다는 것입니다. 그것은 당신을 위해 모든 것을 할 것입니다. 두 번째 이유는 동일한 그래프에서 서로 다른 스케일로 두 개의 서로 다른 메트릭을 플로팅하는 방법을 보여줄 수 있기 때문에 서로 다른 메트릭을 상호 연관시키는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="550725a0970e6ee14cb0ffa04d6e278d186206e7" translate="yes" xml:space="preserve">
          <source>Therefore, we recommend that you 'pre-assign' UID to as many metrics, tag keys and tag values as you can. If you have designed a naming schema as recommended above, you'll know most of the values to assign. You can use the CLI tools &lt;code&gt;cli/mkmetric&lt;/code&gt;, &lt;code&gt;cli/uid&lt;/code&gt; or the HTTP API &lt;code&gt;../api_http/uid/index&lt;/code&gt; to perform pre-assignments. Any time you are about to send a bunch of new metrics or tags to a running OpenTSDB cluster, try to pre-assign or the TSDs will bog down a bit when they get the new data.</source>
          <target state="translated">따라서 가능한 많은 메트릭, 태그 키 및 태그 값에 UID를 '사전 할당'하는 것이 좋습니다. 위에서 권장 한대로 명명 스키마를 설계 한 경우 할당 할 값의 대부분을 알 수 있습니다. CLI 도구 &lt;code&gt;cli/mkmetric&lt;/code&gt; , &lt;code&gt;cli/uid&lt;/code&gt; 또는 HTTP API &lt;code&gt;../api_http/uid/index&lt;/code&gt; 를 사용하여 사전 할당을 수행 할 수 있습니다. 실행중인 OpenTSDB 클러스터에 여러 가지 새로운 메트릭 또는 태그를 보내려고 할 때마다 사전 할당을 시도하십시오. 그렇지 않으면 TSD가 새 데이터를 가져올 때 약간 멈출 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d5beb9c7eb16c3ba7e622bf98afe5dd3da76e3f" translate="yes" xml:space="preserve">
          <source>These are just some of the awesome front-ends, utilities, libraries and resources created by the OpenTSDB community. Please let us know if you have a project you'd like to see listed and if you don't see something you need, search for it on Github (new projects are popping up all the time) or your favorite search engine.</source>
          <target state="translated">이것들은 OpenTSDB 커뮤니티가 만든 멋진 프론트 엔드, 유틸리티, 라이브러리 및 리소스 중 일부입니다. 보고 싶은 프로젝트가 있고 필요한 것이 보이지 않으면 Github (새 프로젝트가 항상 팝업) 또는 즐겨 찾는 검색 엔진에서 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="6f00362ef8453cfb6689990e8b5c820321717fbf" translate="yes" xml:space="preserve">
          <source>These are some notes on adding to the HTTP API.</source>
          <target state="translated">HTTP API에 추가 할 때주의해야 할 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9de416d414128a58b840c6f7ade8431ff16321be" translate="yes" xml:space="preserve">
          <source>These are used to replace &quot;missing&quot; values, i.e. when a data point was expected but couldn't be found in storage.</source>
          <target state="translated">이들은 &quot;누락 된&quot;값을 대체하는 데 사용됩니다 (예 : 데이터 포인트가 예상되었지만 스토리지에서 찾을 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="5c627be4f48ef9a8e28fdedb19570e4165c47093" translate="yes" xml:space="preserve">
          <source>These columns are atomic incrementers that count the number of data points stored for a time series. The qualifier is &lt;code&gt;ts_counter&lt;/code&gt; and the value is an 8 byte signed integer.</source>
          <target state="translated">이 열은 시계열에 저장된 데이터 포인트 수를 계산하는 원자 증 분기입니다. 규정자는 &lt;code&gt;ts_counter&lt;/code&gt; 이고 값은 8 바이트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b73bac7bac36846285acee79b3a98b651073b60c" translate="yes" xml:space="preserve">
          <source>These columns store UTF-8 encoded, JSON formatted objects similar to UIDMeta objects. The qualifier is always &lt;code&gt;ts_meta&lt;/code&gt;. Do not modify these column values outside of OpenTSDB or it may break CAS calls.</source>
          <target state="translated">이 열은 UIDMeta 객체와 유사한 UTF-8로 인코딩 된 JSON 형식의 객체를 저장합니다. 규정자는 항상 &lt;code&gt;ts_meta&lt;/code&gt; 입니다. 이 열 값을 OpenTSDB 외부에서 수정하지 마십시오. CAS 호출이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0b538637db6880dbf37aca6a0377a2cbb475e8" translate="yes" xml:space="preserve">
          <source>These determine the output behavior and allow you to eliminate some expressions from the results or include the raw metrics. By default, if this section is missing, all expressions and only the expressions will be serialized. The field is a list of one or more output objects. More fields will be added later with flags to affect the output.</source>
          <target state="translated">출력 결과를 결정하고 결과에서 일부 표현식을 제거하거나 원시 메트릭을 포함 할 수 있습니다. 기본적으로이 섹션이 없으면 모든 표현식과 표현식 만 직렬화됩니다. 이 필드는 하나 이상의 출력 개체 목록입니다. 나중에 더 많은 필드가 플래그에 추가되어 출력에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8eec44d938049427329b4684186c89011e3bf49d" translate="yes" xml:space="preserve">
          <source>These endpoints provides a means of adding, editing or deleting annotations stored in the OpenTSDB backend. Annotations are very basic objects used to record a note of an arbitrary event at some point, optionally associated with a timeseries. Annotations are not meant to be used as a tracking or event based system, rather they are useful for providing links to such systems by displaying a notice on graphs or via API query calls.</source>
          <target state="translated">이 엔드 포인트는 OpenTSDB 백엔드에 저장된 주석을 추가, 편집 또는 삭제하는 수단을 제공합니다. 주석은 선택적으로 시계열과 연관된 임의의 시점에서 임의의 이벤트에 대한 메모를 기록하는 데 사용되는 매우 기본적인 객체입니다. 주석은 추적 또는 이벤트 기반 시스템으로 사용하기위한 것이 아니라 그래프 또는 API 쿼리 호출을 통해 알림을 표시하여 이러한 시스템에 대한 링크를 제공하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cb73c5dc28f46181357ee65d6b0d4373e968f7e5" translate="yes" xml:space="preserve">
          <source>These errors occur when compacted column is found that cannot be parsed into individual data points. This can happen if the qualifier appears correct but the number of bytes in the value array do not match the lengths encoded in the qualifier. Compacted columns with their data points out of order are not considered bad columns. Instead, the column will be sorted properly and re-written if the &lt;code&gt;--fix&lt;/code&gt; or &lt;code&gt;--fix-all&lt;/code&gt; flags are present.</source>
          <target state="translated">이러한 오류는 개별 데이터 포인트로 구문 분석 할 수없는 압축 컬럼이 발견 될 때 발생합니다. 한정자가 올바르게 나타나지만 값 배열의 바이트 수가 한정자로 인코딩 된 길이와 일치하지 않는 경우에 발생할 수 있습니다. 데이터 포인트가 잘못된 압축 열은 잘못된 열로 간주되지 않습니다. 대신 &lt;code&gt;--fix&lt;/code&gt; 또는 &lt;code&gt;--fix-all&lt;/code&gt; 플래그가 있으면 열이 올바르게 정렬되고 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfb03d0720df4a6ebeb50b7185fe55e0b33f5989" translate="yes" xml:space="preserve">
          <source>These pages serve as a user and administration guide. We highly recommend that you start with the &lt;code&gt;writing&lt;/code&gt; and &lt;a href=&quot;query/index&quot;&gt;&lt;em&gt;Querying or Reading Data&lt;/em&gt;&lt;/a&gt; sections to understand how OpenTSDB handles its core purpose of storing and serving time series information. Then follow up with the &lt;a href=&quot;quickstart&quot;&gt;&lt;em&gt;Quick Start&lt;/em&gt;&lt;/a&gt; section to play around with getting some data into your OpenTSDB instance. Finally follow up with the other pages for details on the other features of OpenTSDB.</source>
          <target state="translated">이 페이지는 사용자 및 관리 안내서 역할을합니다. OpenTSDB가 시계열 정보 저장 및 서비스의 핵심 목적을 처리하는 방법을 이해하려면 &lt;a href=&quot;query/index&quot;&gt;&lt;em&gt;데이터&lt;/em&gt;&lt;/a&gt; &lt;code&gt;writing&lt;/code&gt; 및 &lt;em&gt;쿼리 또는 읽기&lt;/em&gt; 섹션으로 시작하는 것이 좋습니다 . 그런 다음 &lt;a href=&quot;quickstart&quot;&gt;&lt;em&gt;빠른 시작&lt;/em&gt;&lt;/a&gt; 섹션을 따라 OpenTSDB 인스턴스로 데이터를 가져옵니다. 마지막으로 OpenTSDB의 다른 기능에 대한 자세한 내용은 다른 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2aa9dec9d9c25d2d72d60e2d7ac0b9a2165aeaad" translate="yes" xml:space="preserve">
          <source>Think about how you may want to drill down when querying</source>
          <target state="translated">쿼리 할 때 드릴 다운 방법을 생각하십시오</target>
        </trans-unit>
        <trans-unit id="0200e3229f1d2e06b491783e40a31061618cd2ab" translate="yes" xml:space="preserve">
          <source>Think about the most common queries you'll be executing and optimize your schema for those queries</source>
          <target state="translated">실행할 가장 일반적인 쿼리를 생각하고 해당 쿼리에 대한 스키마를 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="b310868a344407f4ec06d2ebc2f54b39d4441c99" translate="yes" xml:space="preserve">
          <source>This appender will write to a log file called &lt;code&gt;/var/log/opentsdb/opentsdb.log&lt;/code&gt;. When the file reaches 128MB in size, it will rotate the log to &lt;code&gt;opentsdb.log.1&lt;/code&gt; and start a new &lt;code&gt;opentsdb.log&lt;/code&gt; file. Once the new log fills up, it bumps &lt;code&gt;.1&lt;/code&gt; to &lt;code&gt;.2&lt;/code&gt;, &lt;code&gt;.log&lt;/code&gt; to &lt;code&gt;.1&lt;/code&gt; and creates a new one. It repeats this until there are four log files in total. The next time the log fills up, the last log is deleted. This way you are gauranteed to only use up to 512MB of disk space. Many other appenders are available so see what fits your needs the best.</source>
          <target state="translated">이 어 펜더는 &lt;code&gt;/var/log/opentsdb/opentsdb.log&lt;/code&gt; 라는 로그 파일에 기록합니다 . 파일 크기가 128MB가되면 로그를 &lt;code&gt;opentsdb.log.1&lt;/code&gt; 로 회전하고 새 &lt;code&gt;opentsdb.log&lt;/code&gt; 파일을 시작 합니다. 새 로그가 가득 차면 &lt;code&gt;.1&lt;/code&gt; 에서 &lt;code&gt;.2&lt;/code&gt; 로 , &lt;code&gt;.log&lt;/code&gt; 에서 &lt;code&gt;.1&lt;/code&gt; 로 충돌하여 새 로그가 작성됩니다. 총 4 개의 로그 파일이있을 때까지이를 반복합니다. 다음에 로그가 가득 차면 마지막 로그가 삭제됩니다. 이 방법으로 최대 512MB의 디스크 공간 만 사용하도록 보장됩니다. 다른 많은 어 펜더를 사용할 수 있으므로 귀하의 요구에 가장 적합한 것을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d013260cc758c7bfd073fbe30d6769daff20b6dd" translate="yes" xml:space="preserve">
          <source>This area deals with altering the Y axes of the graph. &lt;strong&gt;Y&lt;/strong&gt; settings affect the axis on the left and &lt;strong&gt;Y2&lt;/strong&gt; settings affect the axis on the right. Y2 settings are only enabled if at least one of the metrics has had the &lt;strong&gt;Right Axis&lt;/strong&gt; check box checked.</source>
          <target state="translated">이 영역은 그래프의 Y 축 변경을 다룹니다. &lt;strong&gt;Y&lt;/strong&gt; 설정은 왼쪽 축에 영향을 주며 &lt;strong&gt;Y2&lt;/strong&gt; 설정은 오른쪽 축에 영향을줍니다. Y2 설정은 메트릭 중 하나 이상에 &lt;strong&gt;오른쪽 축&lt;/strong&gt; 확인란이 선택된 경우에만 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b2519ae99de8eee80fc3bcced8090ff25676a02" translate="yes" xml:space="preserve">
          <source>This area is where you choose the metrics, optional tags, aggregation function and a possible down sampler for your graph. Along the top are a pair of blue tabs. Each graph can display multiple metrics and the tabs organize the different sub queries. Each graph requires at least one metric so you'll choose that metric in the first tab. To add another metric to your graph, click the &lt;code&gt;+&lt;/code&gt; tab and you'll be able to setup another sub query. If you have configured multiple metrics, simply click on the tab that corresponds to the metric you want to modify. The tab will display a subset of the metric name it is associated with.</source>
          <target state="translated">이 영역에서는 메트릭, 선택적 태그, 집계 함수 및 그래프의 가능한 다운 샘플러를 선택할 수 있습니다. 상단에는 파란색 탭 쌍이 있습니다. 각 그래프는 여러 메트릭을 표시 할 수 있으며 탭은 서로 다른 하위 쿼리를 구성합니다. 각 그래프에는 하나 이상의 측정 항목이 필요하므로 첫 번째 탭에서 해당 측정 항목을 선택합니다. 그래프에 다른 측정 항목을 추가하려면 &lt;code&gt;+&lt;/code&gt; 탭을 클릭하면 다른 하위 검색어를 설정할 수 있습니다. 여러 측정 항목을 구성한 경우 수정하려는 측정 항목에 해당하는 탭을 클릭하면됩니다. 탭에 연결된 메트릭 이름의 하위 집합이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9cc76e3fd3579aa98deae76a2b67da0a13b0238c" translate="yes" xml:space="preserve">
          <source>This can be caused if you use millisecond timestamps and write thousands of data points for a single metric in a single hour. In this case, the column qualifier and row key can grow larger than the configured &lt;code&gt;hfile.index.block.max.size&lt;/code&gt;. In this situation we recommend that you disable TSD compaction code. In the future we will support appends which will allow for compacted columns with small qualifiers.</source>
          <target state="translated">밀리 초 타임 스탬프를 사용하고 한 시간에 단일 메트릭에 대해 수천 개의 데이터 포인트를 쓰는 경우에 발생할 수 있습니다. 이 경우 열 한정자와 행 키는 구성된 &lt;code&gt;hfile.index.block.max.size&lt;/code&gt; 보다 커질 수 있습니다 . 이 상황에서는 TSD 압축 코드를 비활성화하는 것이 좋습니다. 앞으로 작은 한정자가있는 압축 열을 허용하는 추가 기능을 지원할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f9c3b039b471d6f5ffde625a623e33adf5dc8592" translate="yes" xml:space="preserve">
          <source>This command is similar to the HTTP &lt;a href=&quot;../api_http/stats/index&quot;&gt;&lt;em&gt;/api/stats&lt;/em&gt;&lt;/a&gt; endpoint in that it will return a list of the TSD stats, one per line, in the &lt;code&gt;put&lt;/code&gt; format. This command does not modify TSD in any way.</source>
          <target state="translated">이 명령은 &lt;code&gt;put&lt;/code&gt; 형식으로 한 줄에 하나씩 TSD 통계 목록을 리턴한다는 점에서 HTTP &lt;a href=&quot;../api_http/stats/index&quot;&gt;&lt;em&gt;/ api / stats&lt;/em&gt;&lt;/a&gt; 엔드 포인트 와 유사 합니다. 이 명령은 어떤 식 으로든 TSD를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5baf3e866fc3f670d3d82184f3f443063d58cac" translate="yes" xml:space="preserve">
          <source>This command is similar to the HTTP &lt;a href=&quot;../api_http/version&quot;&gt;&lt;em&gt;/api/version&lt;/em&gt;&lt;/a&gt; endpoint in that it will return information about the currently running version of OpenTSDB. This command does not modify TSD in any way.</source>
          <target state="translated">이 명령은 현재 실행중인 OpenTSDB 버전에 대한 정보를 반환한다는 점에서 HTTP &lt;a href=&quot;../api_http/version&quot;&gt;&lt;em&gt;/ api / version&lt;/em&gt;&lt;/a&gt; 엔드 포인트 와 유사합니다 . 이 명령은 어떤 식 으로든 TSD를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb2626e3fcb51afa38258edcbf9eb5a731beba6" translate="yes" xml:space="preserve">
          <source>This command will cause the running TSD to shutdown and the process to exit. Please use carefully.</source>
          <target state="translated">이 명령으로 실행중인 TSD가 종료되고 프로세스가 종료됩니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cbaf3ac750d2cfa2c9e446a99ac238049cbaaa07" translate="yes" xml:space="preserve">
          <source>This command will run through the entire data table, scanning each row of timeseries data and generate missing TSMeta objects and UIDMeta objects or update the created timestamps for each object type if necessary. Use this command after enabling meta tracking with existing data or if you suspect that some timeseries may not have been indexed properly. The command will also push new or updated meta entries to a search engine if a plugin has been configured. If existing meta is corrupted, meaning the TSD is unable to deserialize the object, it will be replaced with a new entry.</source>
          <target state="translated">이 명령은 전체 데이터 테이블을 실행하여 시계열 데이터의 각 행을 스캔하고 누락 된 TSMeta 오브젝트 및 UIDMeta 오브젝트를 생성하거나 필요한 경우 각 오브젝트 유형에 대해 작성된 시간 소인을 업데이트합니다. 기존 데이터로 메타 추적을 사용하도록 설정 한 후 또는 일부 시계열이 올바르게 색인화되지 않은 것으로 의심되는 경우이 명령을 사용하십시오. 플러그인이 구성된 경우이 명령은 또한 새로운 메타 항목이나 업데이트 된 메타 항목을 검색 엔진에 푸시합니다. 기존 메타가 손상되어 TSD가 객체를 직렬화 해제 할 수 없으면 새로운 항목으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="50c5e9494e3bb24cf6cd228d92ad32c31cec61ff" translate="yes" xml:space="preserve">
          <source>This endpoint (2.1 and later) provides support for accessing the latest value of individual time series. It provides an optimization over a regular query when only the last data point is required. Locating the last point can be done with the timestamp of the meta data counter or by scanning backwards from the current system time.</source>
          <target state="translated">이 엔드 포인트 (2.1 이상)는 개별 시계열의 최신 값에 액세스하기위한 지원을 제공합니다. 마지막 데이터 포인트 만 필요한 경우 일반 쿼리에 대한 최적화를 제공합니다. 마지막 지점 찾기는 메타 데이터 카운터의 타임 스탬프를 사용하거나 현재 시스템 시간에서 뒤로 검색하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1957e328706c269ae7824a2f2c142dc556d45ad" translate="yes" xml:space="preserve">
          <source>This endpoint allows for querying data using expressions. The query is broken up into different sections.</source>
          <target state="translated">이 엔드 포인트는 표현식을 사용하여 데이터를 조회 할 수 있습니다. 쿼리는 여러 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="27843bbaf2dd95717fe878da3811208806ebda89" translate="yes" xml:space="preserve">
          <source>This endpoint allows for storing data in OpenTSDB over HTTP as an alternative to the Telnet interface. Put requests can only be performed via content associated with the POST method. The format of the content is dependent on the serializer selected. However there are some common parameters and responses as documented below.</source>
          <target state="translated">이 엔드 포인트는 Telnet 인터페이스의 대안으로 HTTP를 통해 OpenTSDB에 데이터를 저장할 수 있습니다. Put 요청은 POST 메소드와 연관된 컨텐츠를 통해서만 수행 할 수 있습니다. 내용의 형식은 선택한 시리얼 라이저에 따라 다릅니다. 그러나 아래에 설명 된 몇 가지 일반적인 매개 변수와 응답이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be5e10393b5cbf435de0aa48ffdeb0be667517e" translate="yes" xml:space="preserve">
          <source>This endpoint allows for storing rolled up and/or pre-aggregated data in OpenTSDB over HTTP. For details on rollups and pre-aggs, please see the user guide: &lt;a href=&quot;../user_guide/rollups&quot;&gt;&lt;em&gt;Rollup And Pre-Aggregates&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">이 엔드 포인트를 사용하면 롤업 및 / 또는 사전 집계 된 데이터를 OpenTSDB over HTTP에 저장할 수 있습니다. 롤업 및 사전 집계에 대한 자세한 내용은 사용 설명서 : &lt;a href=&quot;../user_guide/rollups&quot;&gt;&lt;em&gt;롤업 및 사전 집계&lt;/em&gt;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3d08780148baef0e976164f83ab4fb7a5fa31c9" translate="yes" xml:space="preserve">
          <source>This endpoint can also change the logging level of ______ at runtime. The query string parameter to use is &lt;code&gt;level=&amp;lt;logging_level&amp;gt;&lt;/code&gt;. For example, you can call &lt;code&gt;http://localhost:4242/logs?level=INFO&lt;/code&gt; to set the log level to &lt;code&gt;INFO&lt;/code&gt;. Valid parameter values are (from the most verbose to the least): &lt;code&gt;ALL&lt;/code&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;code&gt;INFO&lt;/code&gt;&lt;code&gt;WARN&lt;/code&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;code&gt;OFF&lt;/code&gt; (names are case insensitive). Note that this method does not change the &lt;code&gt;logback.xml&lt;/code&gt; configuration file and restarting the TSD will reload from that file.</source>
          <target state="translated">이 엔드 포인트는 런타임시 ______의 로깅 레벨을 변경할 수도 있습니다. 사용할 쿼리 문자열 매개 변수는 &lt;code&gt;level=&amp;lt;logging_level&amp;gt;&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;http://localhost:4242/logs?level=INFO&lt;/code&gt; 를 호출 하여 로그 수준을 &lt;code&gt;INFO&lt;/code&gt; 로 설정할 수 있습니다. 유효한 매개 변수 값은 (자세한 가장에서에 적어도)입니다 : &lt;code&gt;ALL&lt;/code&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;code&gt;INFO&lt;/code&gt; &lt;code&gt;WARN&lt;/code&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;code&gt;OFF&lt;/code&gt; 를 (이름은 대소의 문자를 구별하지 않는다). 이 방법은 &lt;code&gt;logback.xml&lt;/code&gt; 구성 파일을 변경하지 않으며 TSD를 다시 시작하면 해당 파일에서 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="876d9759e8951fa52d1a079475d72a1988a93f9c" translate="yes" xml:space="preserve">
          <source>This endpoint can be used for tracking and troubleshooting queries executed against a TSD. It maintains an unbounded list of currently executing queries as well as a list of up to 256 completed queries (rotating the oldest queries out of memory). Information about each query includes the original query, request headers, response code, timing and an exception if thrown. (v2.2)</source>
          <target state="translated">이 엔드 포인트는 TSD에 대해 실행 된 쿼리를 추적하고 문제를 해결하는 데 사용할 수 있습니다. 현재 실행중인 쿼리의 무제한 목록과 최대 256 개의 완료된 쿼리 목록 (가장 오래된 쿼리를 메모리에서 회전)을 유지 관리합니다. 각 쿼리에 대한 정보에는 원래 쿼리, 요청 헤더, 응답 코드, 타이밍 및 발생 된 예외가 포함됩니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="049cadd4ac580c2006c235b53f07e4db37b1ba39" translate="yes" xml:space="preserve">
          <source>This endpoint does not purge the on-disk temporary cache where graphs and other files are stored.</source>
          <target state="translated">이 엔드 포인트는 그래프 및 기타 파일이 저장된 디스크 임시 캐시를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa382d4916d2efb7bdd7b1f14dc482e30650197b" translate="yes" xml:space="preserve">
          <source>This endpoint does not require any parameters via query string or body.</source>
          <target state="translated">이 엔드 포인트에는 쿼리 문자열 또는 본문을 통한 매개 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33a246ac9a78406e5c51a185c9fbf623b4c43f36" translate="yes" xml:space="preserve">
          <source>This endpoint enables assigning UIDs to new metrics, tag names and tag values. Multiple types and names can be provided in a single call and the API will process each name individually, reporting which names were assigned UIDs successfully, along with the UID assigned, and which failed due to invalid characters or had already been assigned. Assignment can be performed via query string or content data.</source>
          <target state="translated">이 엔드 포인트는 UID를 새로운 메트릭, 태그 이름 및 태그 값에 할당 할 수있게합니다. 한 번의 호출로 여러 유형과 이름을 제공 할 수 있으며 API는 각 이름을 개별적으로 처리하여 할당 된 UID와 함께 UID에 할당 된 이름과 유효하지 않은 문자로 인해 실패했거나 이미 할당 된 이름을보고합니다. 할당은 쿼리 문자열 또는 콘텐츠 데이터를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a546dda6ed71f39a1cd3ce043775ca2d7ac16b9" translate="yes" xml:space="preserve">
          <source>This endpoint enables editing or deleting UID meta data information, that is meta data associated with &lt;em&gt;metrics&lt;/em&gt;, &lt;em&gt;tag names&lt;/em&gt; and &lt;em&gt;tag values&lt;/em&gt;. Some fields are set by the TSD but others can be set by the user. When using the &lt;code&gt;POST&lt;/code&gt; method, only the fields supplied with the request will be stored. Existing fields that are not included will be left alone. Using the &lt;code&gt;PUT&lt;/code&gt; method will overwrite all user mutable fields with given values or defaults if a given field is not provided.</source>
          <target state="translated">이 엔드 포인트는 UID 메타 데이터 정보, 즉 &lt;em&gt;메트릭&lt;/em&gt; , &lt;em&gt;태그 이름&lt;/em&gt; 및 &lt;em&gt;태그 값&lt;/em&gt; 과 연관된 메타 데이터를 편집하거나 삭제할 수 &lt;em&gt;있습니다&lt;/em&gt; . 일부 필드는 TSD에 의해 설정되지만 다른 필드는 사용자가 설정할 수 있습니다. &lt;code&gt;POST&lt;/code&gt; 방법을 사용하는 경우 요청과 함께 제공된 필드 만 저장됩니다. 포함되지 않은 기존 필드는 그대로 유지됩니다. &lt;code&gt;PUT&lt;/code&gt; 방법을 사용하면 주어진 필드가 제공되지 않으면 모든 사용자 변경 가능 필드를 지정된 값 또는 기본값으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="5f008c5fb0114a12aec4b9f01601d721048b196d" translate="yes" xml:space="preserve">
          <source>This endpoint enables searching, editing or deleting timeseries meta data information, that is meta data associated with a specific timeseries associated with a &lt;em&gt;metric&lt;/em&gt; and one or more &lt;em&gt;tag name/value&lt;/em&gt; pairs. Some fields are set by the TSD but others can be set by the user. When using the &lt;code&gt;POST&lt;/code&gt; method, only the fields supplied with the request will be stored. Existing fields that are not included will be left alone. Using the &lt;code&gt;PUT&lt;/code&gt; method will overwrite all user mutable fields with given values or defaults if a given field is not provided.</source>
          <target state="translated">이 엔드 포인트는 시계열 메타 데이터 정보, 즉 &lt;em&gt;메트릭&lt;/em&gt; 및 하나 이상의 &lt;em&gt;태그 이름 / 값&lt;/em&gt; 쌍 과 관련된 특정 시계열과 관련된 메타 데이터를 검색, 편집 또는 삭제할 수 있습니다 . 일부 필드는 TSD에 의해 설정되지만 다른 필드는 사용자가 설정할 수 있습니다. &lt;code&gt;POST&lt;/code&gt; 방법을 사용하면 요청과 함께 제공된 필드 만 저장됩니다. 포함되지 않은 기존 필드는 그대로 유지됩니다. &lt;code&gt;PUT&lt;/code&gt; 방법을 사용하면 주어진 필드가 제공되지 않으면 모든 사용자 변경 가능 필드를 지정된 값 또는 기본값으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b32afc8b883821954a2771b093ad7eae2cd9ca4f" translate="yes" xml:space="preserve">
          <source>This endpoint lists the serializer plugins loaded by the running TSD. Information given includes the name, implemented methods, content types and methods.</source>
          <target state="translated">이 엔드 포인트는 실행중인 TSD에 의해로드 된 시리얼 라이저 플러그인을 나열합니다. 제공된 정보에는 이름, 구현 된 메소드, 컨텐츠 유형 및 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="af366f361c8d1bd9e146c06ed78cc3a31fe69d79" translate="yes" xml:space="preserve">
          <source>This endpoint provides a basic means of searching OpenTSDB meta data. Lookups can be performed against the &lt;code&gt;tsdb-meta&lt;/code&gt; table when enabled. Optionally, a search plugin can be installed to send and retreive information from an external search indexing service such as Elastic Search. It is up to each search plugin to implement various parts of this endpoint and return data in a consistent format. The type of object searched and returned depends on the endpoint chosen.</source>
          <target state="translated">이 엔드 포인트는 OpenTSDB 메타 데이터를 검색하는 기본 수단을 제공합니다. 활성화 된 경우 &lt;code&gt;tsdb-meta&lt;/code&gt; 테이블 에 대해 조회를 수행 할 수 있습니다 . 선택적으로, 검색 플러그인을 설치하여 Elastic Search와 같은 외부 검색 인덱싱 서비스에서 정보를주고받을 수 있습니다. 이 엔드 포인트의 다양한 부분을 구현하고 일관된 형식으로 데이터를 리턴하는 것은 각 검색 플러그인에 달려 있습니다. 검색 및 반환되는 개체 유형은 선택한 끝점에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d2db88164678a1141454effd7e09b73a11e68744" translate="yes" xml:space="preserve">
          <source>This endpoint provides a list of statistics for the running TSD. Sub endpoints return details about other TSD components such as the JVM, thread states or storage client. All statistics are read only.</source>
          <target state="translated">이 엔드 포인트는 실행중인 TSD에 대한 통계 목록을 제공합니다. 하위 엔드 포인트는 JVM, 스레드 상태 또는 스토리지 클라이언트와 같은 다른 TSD 구성 요소에 대한 세부 사항을 리턴합니다. 모든 통계는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5e15c71f2016f88d4133c556633cb5116f346762" translate="yes" xml:space="preserve">
          <source>This endpoint provides a means of implementing an &quot;auto-complete&quot; call that can be accessed repeatedly as a user types a request in a GUI. It does not offer full text searching or wildcards, rather it simply matches the entire string passed in the query on the first characters of the stored data. For example, passing a query of &lt;code&gt;type=metrics&amp;amp;q=sys&lt;/code&gt; will return the top 25 metrics in the system that start with &lt;code&gt;sys&lt;/code&gt;. Matching is case sensitive, so &lt;code&gt;sys&lt;/code&gt; will not match &lt;code&gt;System.CPU&lt;/code&gt;. Results are sorted alphabetically.</source>
          <target state="translated">이 엔드 포인트는 사용자가 GUI에 요청을 입력 할 때 반복적으로 액세스 할 수있는 &quot;자동 완성&quot;호출을 구현하는 수단을 제공합니다. 전체 텍스트 검색 또는 와일드 카드를 제공하지 않고 저장된 데이터의 첫 문자에서 쿼리에 전달 된 전체 문자열과 단순히 일치합니다. 예를 들어,의 쿼리 통과 &lt;code&gt;type=metrics&amp;amp;q=sys&lt;/code&gt; 로 시작하는 시스템에서 상위 25 통계를 반환합니다 &lt;code&gt;sys&lt;/code&gt; . 일치는 대소 문자를 구분하므로 &lt;code&gt;sys&lt;/code&gt; 는 &lt;code&gt;System.CPU&lt;/code&gt; 와 일치하지 않습니다 . 결과는 알파벳순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a09d5b94ec3a413ae983f81250ed77a8523cbc9e" translate="yes" xml:space="preserve">
          <source>This endpoint purges the in-memory data cached in OpenTSDB. This includes all UID to name and name to UID maps for metrics, tag names and tag values.</source>
          <target state="translated">이 엔드 포인트는 OpenTSDB에 캐시 된 메모리 내 데이터를 제거합니다. 여기에는 메트릭, 태그 이름 및 태그 값에 대한 모든 UID 이름 및 UID 맵 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b91eda958b5dbf24b3da74baba73246c3a56f2f" translate="yes" xml:space="preserve">
          <source>This endpoint returns information about the running configuration of the TSD. It is read only and cannot be used to set configuration options.</source>
          <target state="translated">이 엔드 포인트는 TSD의 실행 구성에 대한 정보를 리턴합니다. 읽기 전용이며 구성 옵션을 설정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="69783aaf1556ffa9a6949e2cacb0cb0a50e98b57" translate="yes" xml:space="preserve">
          <source>This endpoint returns information about the running version of OpenTSDB.</source>
          <target state="translated">이 엔드 포인트는 실행중인 OpenTSDB 버전에 대한 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="828a9d481adcd20c2c5e492e569b18d27fa8bb71" translate="yes" xml:space="preserve">
          <source>This endpoint should always return data with the JSON serializer as the default. If you think the TSD should have other formatters listed, check the plugin documentation to make sure you have the proper plugin and it's located in the right directory.</source>
          <target state="translated">이 엔드 포인트는 항상 JSON 직렬 변환기를 기본값으로 사용하여 데이터를 리턴해야합니다. TSD에 다른 포맷터가 나열되어 있어야한다고 생각되면 플러그인 설명서에서 올바른 플러그인이 있고 올바른 디렉토리에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="77f19c13c7a0611a273d095830229f023b30e4f9" translate="yes" xml:space="preserve">
          <source>This endpoint simply lists the names of implemented aggregation functions used in timeseries queries.</source>
          <target state="translated">이 엔드 포인트에는 시계열 쿼리에 사용 된 구현 된 집계 함수의 이름 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="e4d313a35eaf6cdef9049f36e2da537009043454" translate="yes" xml:space="preserve">
          <source>This endpoint was introduced in 1.0 as a means of accessing static files on the local system. &lt;code&gt;/s&lt;/code&gt; will be maintained in the future and will not be deprecated. The static root is definied in the config file as &lt;code&gt;tsd.http.staticroot&lt;/code&gt; or CLI via &lt;code&gt;--staticroot&lt;/code&gt;.</source>
          <target state="translated">이 엔드 포인트는 로컬 시스템의 정적 파일에 액세스하기 위해 1.0에서 도입되었습니다. &lt;code&gt;/s&lt;/code&gt; 는 앞으로 유지 될 것이며 더 이상 사용되지 않을 것입니다. 정적 루트는 구성 파일에서 &lt;code&gt;tsd.http.staticroot&lt;/code&gt; 또는 &lt;code&gt;--staticroot&lt;/code&gt; 를 통해 CLI로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef373281324018aae312ce22e59494791a5d6c9" translate="yes" xml:space="preserve">
          <source>This endpoint will almost always return a &lt;code&gt;200&lt;/code&gt; with content body. If the query doesn't match any results, the &lt;code&gt;results&lt;/code&gt; field will be an empty array and &lt;code&gt;totalResults&lt;/code&gt; will be 0. If an error occurs, such as a failure to resolve a metric or tag name to a UID, an exception will be returned.</source>
          <target state="translated">이 엔드 포인트는 거의 항상 내용 본문이 있는 &lt;code&gt;200&lt;/code&gt; 을 반환합니다 . 쿼리가 결과와 일치하지 않으면 &lt;code&gt;results&lt;/code&gt; 필드는 빈 배열이되고 &lt;code&gt;totalResults&lt;/code&gt; 는 0이됩니다. 메트릭 또는 태그 이름을 UID로 해석하지 못하는 등의 오류가 발생하면 예외가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b3dd96be71602f0d90499c76832706003b1ef079" translate="yes" xml:space="preserve">
          <source>This endpoint will almost always return a &lt;code&gt;200&lt;/code&gt; with content body. If the query doesn't match any results, the &lt;code&gt;results&lt;/code&gt; field will be an empty array and &lt;code&gt;totalResults&lt;/code&gt; will be 0. If an error occurs, such as the plugin being disabled or not configured, an exception will be returned.</source>
          <target state="translated">이 엔드 포인트는 거의 항상 내용 본문이 있는 &lt;code&gt;200&lt;/code&gt; 을 반환합니다 . 쿼리가 결과와 일치하지 않으면 &lt;code&gt;results&lt;/code&gt; 필드는 빈 배열이되고 &lt;code&gt;totalResults&lt;/code&gt; 는 0이됩니다. 플러그인을 사용하지 않거나 구성하지 않는 등의 오류가 발생하면 예외가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="86a453f5b99cf8e227780904f75d83c8e7670d59" translate="yes" xml:space="preserve">
          <source>This field contains the numeric HTTP response code and a textual representation of that code.</source>
          <target state="translated">이 필드에는 숫자 HTTP 응답 코드와 해당 코드의 텍스트 표현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="38358ddf81a17abe01a11d8a145b6cba4513b51d" translate="yes" xml:space="preserve">
          <source>This hook could be used to register OpenTSDB with a service discovery mechanism or look up the location of an HBase cluster dynamically and populate the connfiguration. You could potentially create HBase tables if they do not exist at this time.</source>
          <target state="translated">이 후크를 사용하여 서비스 검색 메커니즘으로 OpenTSDB를 등록하거나 HBase 클러스터의 위치를 ​​동적으로 조회하고 구성을 채울 수 있습니다. 현재 HBase 테이블이 없으면 잠재적으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="649c3d5f5f204ef2376dcc2e6051d0e5cfe96732" translate="yes" xml:space="preserve">
          <source>This hook is called once OpenTSDB has been fully initialized and is ready to serve traffic. This hook could be used to set the status to READY in a service discovery system, change the state of in a load balancer or perform other tasks which require a fully functioning OpenTSDB instance.</source>
          <target state="translated">이 후크는 OpenTSDB가 완전히 초기화되고 트래픽을 처리 할 준비가되면 호출됩니다. 이 후크는 서비스 검색 시스템에서 상태를 READY로 설정하거나로드 밸런서의 상태를 변경하거나 완전히 작동하는 OpenTSDB 인스턴스가 필요한 다른 작업을 수행하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86190ca41285324ae2280f129a757c79a911aa85" translate="yes" xml:space="preserve">
          <source>This hook is called when OpenTSDB is performing shutdown tasks. No work should be done here which requires a functioning and connected OpenTSDB instance. You could use this to update the status of this node within your service discovery mechanism.</source>
          <target state="translated">이 후크는 OpenTSDB가 종료 작업을 수행 할 때 호출됩니다. 작동하고 연결된 OpenTSDB 인스턴스가 필요한 작업은 여기서 수행하지 않아야합니다. 이를 사용하여 서비스 검색 메커니즘 내에서이 노드의 상태를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22a06a4032fb20337a084c07b295dbe7d3a642a8" translate="yes" xml:space="preserve">
          <source>This indicates one or more UIDs were not used for mapping entries. If a UID was deleted, this message is normal. If UIDs were not deleted, this can indicate wasted UIDs due to auto-assignments by TSDs where data was coming in too fast. Try assigning UIDs up-front as much as possible.</source>
          <target state="translated">이는 하나 이상의 UID가 항목 맵핑에 사용되지 않았 음을 나타냅니다. UID가 삭제 된 경우이 메시지는 정상입니다. UID가 삭제되지 않은 경우, 데이터가 너무 빨리 들어오는 TSD의 자동 할당으로 인해 낭비 된 UID를 나타낼 수 있습니다. UID를 최대한 미리 할당 해보십시오.</target>
        </trans-unit>
        <trans-unit id="9bc680d085ae0e88d3ce7388744023732da91126" translate="yes" xml:space="preserve">
          <source>This initial graph will aggregate all of the time series for the metric you selected. Try limiting your query to a specific host by adding &lt;code&gt;host&lt;/code&gt; as a value in the left-hand box next to the &lt;code&gt;Tags&lt;/code&gt; label (if it isn't already there) and add the specific host name (e.g. &lt;code&gt;foo&lt;/code&gt;) in the right-hand box. After clicking in another box you should see the graph re-draw with different information.</source>
          <target state="translated">이 초기 그래프는 선택한 측정 항목에 대한 모든 시계열을 집계합니다. &lt;code&gt;Tags&lt;/code&gt; 레이블 옆의 왼쪽 상자에 &lt;code&gt;host&lt;/code&gt; 를 값 으로 추가하여 쿼리를 특정 호스트로 제한 하고 (아직없는 경우) 오른쪽 상자에 특정 호스트 이름 (예 : &lt;code&gt;foo&lt;/code&gt; )을 추가하십시오 . 다른 상자를 클릭하면 다른 정보로 그래프가 다시 그려집니다.</target>
        </trans-unit>
        <trans-unit id="b7b2b609b28de0e5e9f0b3b5223da6403cab3cec" translate="yes" xml:space="preserve">
          <source>This is a map of the headers sent with the HTTP request. In a mediocre effort at security, the &lt;code&gt;Cookie&lt;/code&gt; header field is obfuscated with asterisks in the case that it contains user identifiable or secure information. Each request is different so lookup the headers in the HTTP RFCs or your web browser or clients documentation.</source>
          <target state="translated">이것은 HTTP 요청과 함께 전송 된 헤더의 맵입니다. 보안에 대한 평범한 노력으로 &lt;code&gt;Cookie&lt;/code&gt; 헤더 필드에는 사용자 식별 가능 정보 나 보안 정보가 포함 된 경우 별표가 표시됩니다. 각 요청은 다르므로 HTTP RFC 또는 웹 브라우저 또는 클라이언트 설명서에서 헤더를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="015a2b7323ff6165f90564be33cda3d8670e6c4d" translate="yes" xml:space="preserve">
          <source>This is a simple utility for consuming data points from collectors while a TSD, HBase or HDFS is underoing maintenance. The script should be run on the same port as a TSD and accepts data in the &lt;code&gt;put&lt;/code&gt; Telnet style. Data points are then written directly to disk in a format that can be used with the &lt;a href=&quot;../cli/import&quot;&gt;&lt;em&gt;import&lt;/em&gt;&lt;/a&gt; command once HBase is back up.</source>
          <target state="translated">TSD, HBase 또는 HDFS에서 유지 관리 작업을 수행하는 동안 수집기에서 데이터 포인트를 사용하기위한 간단한 유틸리티입니다. 스크립트는 TSD와 동일한 포트에서 실행되어야하며 &lt;code&gt;put&lt;/code&gt; Telnet 스타일의 데이터를 승인합니다 . 그런 다음 HBase가 백업되면 &lt;a href=&quot;../cli/import&quot;&gt;&lt;em&gt;가져 오기&lt;/em&gt;&lt;/a&gt; 명령 과 함께 사용할 수있는 형식으로 데이터 포인트가 디스크에 직접 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddad3041f947e1b4165040525621f1ffc833e679" translate="yes" xml:space="preserve">
          <source>This is an interface used to implement additional HTTP API endpoints for OpenTSDB. (v2.2)</source>
          <target state="translated">OpenTSDB에 대한 추가 HTTP API 엔드 포인트를 구현하는 데 사용되는 인터페이스입니다. (v2.2)</target>
        </trans-unit>
        <trans-unit id="e888767d78bd77862d02d07d6f827e85615814b0" translate="yes" xml:space="preserve">
          <source>This is much easier than dealing with a dependency. You only need to modify &lt;code&gt;Makefile.am&lt;/code&gt; and edit the &lt;code&gt;tsdb_SRC := \&lt;/code&gt; or the &lt;code&gt;test_SRC := \&lt;/code&gt; lists. If you're adding a class, put it in the proper alphabetical position and account for the proper directory and class name. It is case sensitive so make sure to get that right. If removing a class, just delete the line. If moving a class, add the new line and delete the old one. Be careful to handle the line continuation &lt;code&gt;\&lt;/code&gt; backslashes. The last class in each list should NOT end with a backslash, the rest need it.</source>
          <target state="translated">이것은 의존성을 다루는 것보다 훨씬 쉽습니다. &lt;code&gt;Makefile.am&lt;/code&gt; 만 수정하고 &lt;code&gt;tsdb_SRC := \&lt;/code&gt; 또는 &lt;code&gt;test_SRC := \&lt;/code&gt; 목록 만 편집하면 됩니다. 클래스를 추가하는 경우 적절한 알파벳 위치에 놓고 적절한 디렉토리 및 클래스 이름을 고려하십시오. 대소 문자를 구분하므로 올바르게 입력하십시오. 수업을 제거하는 경우 줄을 삭제하십시오. 수업을 이동하는 경우 새 줄을 추가하고 이전 줄을 삭제하십시오. 줄 연속 &lt;code&gt;\&lt;/code&gt; 백 슬래시를 주의해서 다루십시오 . 각 목록의 마지막 클래스는 백 슬래시로 끝나서는 안되며 나머지 클래스는 백 슬래시로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="f493fa749ec34b3ab40005594d6b1386d149aae2" translate="yes" xml:space="preserve">
          <source>This is the same as a data point table row key without the timestamp. E.g. &lt;code&gt;&amp;lt;metric_uid&amp;gt;&amp;lt;tagk1&amp;gt;&amp;lt;tagv1&amp;gt;[...&amp;lt;tagkN&amp;gt;&amp;lt;tagvN&amp;gt;]&lt;/code&gt;. It is shared for all column types.</source>
          <target state="translated">타임 스탬프가없는 데이터 포인트 테이블 행 키와 동일합니다. 예 : &lt;code&gt;&amp;lt;metric_uid&amp;gt;&amp;lt;tagk1&amp;gt;&amp;lt;tagv1&amp;gt;[...&amp;lt;tagkN&amp;gt;&amp;lt;tagvN&amp;gt;]&lt;/code&gt; . 모든 열 유형에 대해 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="fd82e65415794bb7608fe85f279c2a2f25660af9" translate="yes" xml:space="preserve">
          <source>This is the simplest query to make. TSDB will setup a scanner to fetch all data points for the metric UID &lt;code&gt;01&lt;/code&gt; between &lt;em&gt;&amp;lt;start&amp;gt;&lt;/em&gt; and &lt;em&gt;&amp;lt;end&amp;gt;&lt;/em&gt;. The result will be the a single dataset with time series #1 through #7 summed together. If you have thousands of unique tag combinations for a given metric, they will all be added together into one series.</source>
          <target state="translated">가장 간단한 쿼리입니다. TSDB는 &lt;em&gt;&amp;lt;start&amp;gt;&lt;/em&gt; 와 &lt;em&gt;&amp;lt;end&amp;gt;&lt;/em&gt; 사이 의 메트릭 UID &lt;code&gt;01&lt;/code&gt; 에 대한 모든 데이터 포인트를 가져 오도록 스캐너를 설정합니다 . 결과는 시계열 # 1에서 # 7까지의 단일 데이터 집합이됩니다. 특정 측정 항목에 대해 수천 개의 고유 한 태그 조합이있는 경우 모두 하나의 시리즈에 함께 추가됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d970fd785437692bddc537d86d2d886407b3947b" translate="yes" xml:space="preserve">
          <source>This is the solution used by many next-generation monitoring solutions such as that at Yahoo!. Yahoo is working to open source their stream processing system for others who need monitoring at massive scales and it plugs neatly into TSDB.</source>
          <target state="translated">Yahoo!와 같은 많은 차세대 모니터링 솔루션에서 사용하는 솔루션입니다. Yahoo는 대규모 모니터링이 필요한 다른 사람들을 위해 스트림 처리 시스템을 오픈 소스로 만들고 있으며 TSDB에 깔끔하게 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8353208005c79e2131dacc3b1ab066dbd7443e8d" translate="yes" xml:space="preserve">
          <source>This is where a tagging scheme will stand or fall. Let's say you want to get just the data from timeseries #4. With the current system, you are unable to. You would send in query #2 &lt;code&gt;m=sum:cpu.system{host=web01}&lt;/code&gt; thinking that it will return just the data from #4, but as we saw, you'll get the aggregate results for #1, #4, #5 and #6. To prevent such an occurance, you would need to add another tag to #4 that differentiates it from other timeseries in the group. Or if you've already commited, you can use TSUID queries.</source>
          <target state="translated">태그 지정 체계가 작동하거나 중단되는 위치입니다. 시계열 # 4의 데이터 만 가져 오겠다고 가정 해 보겠습니다. 현재 시스템으로는 할 수 없습니다. 쿼리 # 2에서 &lt;code&gt;m=sum:cpu.system{host=web01}&lt;/code&gt; # 4의 데이터 만 반환 할 것이라고 생각하지만, 보시다시피 # 1, # 4, # 5와 # 6. 이러한 상황을 방지하려면 그룹의 다른 시계열과 구별되는 다른 태그를 # 4에 추가해야합니다. 또는 이미 커밋 한 경우 TSUID 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7be9ac81acff15dbc749a1b53fba73ca5ccdc310" translate="yes" xml:space="preserve">
          <source>This isn't necesarily the best way to setup your metrics and tags, rather it's meant to be illustrative of how the query system works. In particular, TS #4 and 5, while legitimate timeseries, may screw up your queries unless you know how they work. In general, try to maintain the same number and type of tags for each timeseries.</source>
          <target state="translated">이는 통계와 태그를 설정하는 가장 좋은 방법은 아니지만 쿼리 시스템의 작동 방식을 설명하기위한 것입니다. 특히 TS # 4 및 5는 합법적 인 시계열이지만 작동 방식을 모르는 경우 쿼리를 망칠 수 있습니다. 일반적으로 각 시계열에 대해 동일한 수와 유형의 태그를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="3b26a1055602062320232887d91061404659b1f7" translate="yes" xml:space="preserve">
          <source>This may be used in the event that an API call has migrated or should be forwarded to another server</source>
          <target state="translated">API 호출이 마이그레이션되었거나 다른 서버로 전달되어야하는 경우에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf2c70fb568a00af90f6ec1e0bbd91aeab2ad47" translate="yes" xml:space="preserve">
          <source>This may occur if a TSD crashes before the reverse map is written and would only prevent queries from executing against time series using the UID as they would not be able to lookukp the name.</source>
          <target state="translated">리버스 맵이 작성되기 전에 TSD가 충돌하고 이름을 찾을 수 없으므로 UID를 사용하여 시계열에 대해 쿼리가 실행되지 못하게하는 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2baf6afc2f4b1810059afbae84793a88a0e017c9" translate="yes" xml:space="preserve">
          <source>This may occur if a value is recorded on greater than 8 bytes for a single data point column. Individual data points are stored on 2 or 4 byte qualifiers. This error cannot happen for a data point within a compacted column. If it was compacted, the column would throw a bad compacted column error as it wouldn't be parseable.</source>
          <target state="translated">단일 데이터 포인트 열에 대해 8 바이트보다 큰 값이 기록 된 경우 발생할 수 있습니다. 개별 데이터 포인트는 2 또는 4 바이트 한정자에 저장됩니다. 압축 된 열 내의 데이터 요소에 대해서는이 오류가 발생할 수 없습니다. 압축 된 경우 열을 구문 분석 할 수 없으므로 잘못된 압축 된 열 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb32bc9083008f7b41ccb92b735be384be4e7087" translate="yes" xml:space="preserve">
          <source>This method cannot be undone.</source>
          <target state="translated">이 방법은 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db112be712f809354b5281590875cd399e9738b4" translate="yes" xml:space="preserve">
          <source>This method cannot be undone. Once executed, the purge will continue running unless the TSD is shutdown.</source>
          <target state="translated">이 방법은 취소 할 수 없습니다. 일단 실행되면 TSD가 종료되지 않으면 제거가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="76122dc54a50987c90e3460f54ffe173cd2d2fd0" translate="yes" xml:space="preserve">
          <source>This page documents the OpenTSDB 2.1 fsck utility. For previous versions, only the &lt;code&gt;--fix&lt;/code&gt; flag is available and only data within a query may be fsckd.</source>
          <target state="translated">이 페이지는 OpenTSDB 2.1 fsck 유틸리티를 설명합니다. 이전 버전의 경우 &lt;code&gt;--fix&lt;/code&gt; 플래그 만 사용할 수 있으며 쿼리 내의 데이터 만 fsckd 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2db495251b3552764e3e02414803326a940a924" translate="yes" xml:space="preserve">
          <source>This page lists common issues encountered by users of OpenTSDB along with various troubleshooting steps. If you run into an issue, please check the &lt;a href=&quot;https://groups.google.com/forum/#!forum/opentsdb&quot;&gt;OpenTSDB Google Group&lt;/a&gt; or the &lt;a href=&quot;https://github.com/OpenTSDB/opentsdb/issues&quot;&gt;Github Issues&lt;/a&gt;. If you can't find an answer, please include your operating system, TSD version and HBase version in your question.</source>
          <target state="translated">이 페이지에는 다양한 문제 해결 단계와 함께 OpenTSDB 사용자가 겪는 일반적인 문제가 나열되어 있습니다. 문제가 발생하면 &lt;a href=&quot;https://groups.google.com/forum/#!forum/opentsdb&quot;&gt;OpenTSDB Google 그룹&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/OpenTSDB/opentsdb/issues&quot;&gt;Github 문제&lt;/a&gt; 를 확인하십시오 . 답변을 찾을 수없는 경우 운영 체제, TSD 버전 및 HBase 버전을 질문에 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="926d5d665c45a5917ed630c6f3319dbb2799673e" translate="yes" xml:space="preserve">
          <source>This page lists some of the utilities or projects included with OpenTSDB or maintained by the OpenTSDB group. Additional utilities, such as front-ends, clients and publishers can be found on the &lt;a href=&quot;../../resources&quot;&gt;&lt;em&gt;Additional Resources&lt;/em&gt;&lt;/a&gt; page or via a simple Google search.</source>
          <target state="translated">이 페이지는 OpenTSDB에 포함되어 있거나 OpenTSDB 그룹에 의해 유지 보수되는 일부 유틸리티 또는 프로젝트를 나열합니다. 프론트 엔드, 클라이언트 및 게시자와 같은 추가 유틸리티는 &lt;a href=&quot;../../resources&quot;&gt;&lt;em&gt;추가 리소스&lt;/em&gt;&lt;/a&gt; 페이지 또는 간단한 Google 검색을 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad91c59b836f74855823446b2409a8179a92c97f" translate="yes" xml:space="preserve">
          <source>This question is asked often enough it's worth laying out the reasons here. Looking up or assigning a UID takes up precious cycles in the TSD so folks wonder if it wouldn't be faster to use the raw name of the metric or computer a hash. Indeed, from a write perspective it would be slightly faster, but there are a number of drawbacks that become apparent.</source>
          <target state="translated">이 질문은 종종 여기에 이유를 설명 할 가치가 충분히 묻습니다. UID를 조회하거나 할당하면 TSD에서 귀중한주기가 걸리므로 메트릭 또는 컴퓨터의 원시 이름을 해시로 사용하는 것이 더 빠르지 않은지 궁금해하는 사람들이 있습니다. 실제로 쓰기 관점에서는 약간 빠르지 만 많은 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcbcf243f445811e0be0595e9a083adcdda2e40b" translate="yes" xml:space="preserve">
          <source>This represents a single metric but four time series across three hours. Note how there is one time series with two sets of tags:</source>
          <target state="translated">이는 3 시간 동안 단일 메트릭이지만 4 개의 시계열을 나타냅니다. 두 개의 태그 세트가있는 시계열이 어떻게 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e9e40067f86fb5cd493d907dd7c1501f07c5039" translate="yes" xml:space="preserve">
          <source>This requests the stats from the TSD (assuming it's running on the local host and listening to port 4242), extract the names of the metrics from the stats and assigns them UIDs. Then you can use this simple script to collect stats and store them in OpenTSDB:</source>
          <target state="translated">그러면 로컬 호스트에서 실행 중이고 포트 4242를 수신한다고 가정하여 TSD에 통계를 요청하고 통계에서 메트릭 이름을 추출하여 UID에 지정합니다. 그런 다음이 간단한 스크립트를 사용하여 통계를 수집하여 OpenTSDB에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53de11373587c9acdeb60a465bab7dffd85de86d" translate="yes" xml:space="preserve">
          <source>This sample configuration is for 2 backends, named &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. You need to substitute at least the host names.</source>
          <target state="translated">이 샘플 구성은 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 라는 2 개의 백엔드를위한 것 입니다. 최소한 호스트 이름을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="8834c7c3c11d237e291cf5e51a3a1d1176f51918" translate="yes" xml:space="preserve">
          <source>This script will purge all files in the directory. Don't store anything important in the temp directory.</source>
          <target state="translated">이 스크립트는 디렉토리의 모든 파일을 제거합니다. temp 디렉토리에 중요한 것을 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="806443a19d2027595bb82f79781eb38501cef7fe" translate="yes" xml:space="preserve">
          <source>This section is a serialization of the query given by the user. In the logs and stats page this will be the full query with timing and global options. When returned with the query results, only the sub query (metric and filters) are returned with the associated result set for identification purposes (e.g. if you request the same metric twice with two different aggregators, you need to know which data set corresponds to which aggregator).</source>
          <target state="translated">이 섹션은 사용자가 제공 한 쿼리의 직렬화입니다. 로그 및 통계 페이지에서 타이밍 및 전역 옵션이 포함 된 전체 쿼리입니다. 쿼리 결과와 함께 반환 된 경우 식별 목적으로 하위 쿼리 (메트릭 및 필터) 만 관련 결과 집합과 함께 반환됩니다 (예 : 두 개의 서로 다른 수집기로 동일한 메트릭을 두 번 요청하는 경우 어떤 데이터 세트가 어떤 데이터 세트에 해당하는지 알아야합니다) 애그리 게이터).</target>
        </trans-unit>
        <trans-unit id="71efceea22777b3b589cabfe55f0dd3f4b4b7fb9" translate="yes" xml:space="preserve">
          <source>This sub command is used to assign IDs to new unique names for metrics, tag names or tag values. Supply a list of one or more values to assign UIDs and the list of assignments will be returned.</source>
          <target state="translated">이 하위 명령은 메트릭, 태그 이름 또는 태그 값의 고유 한 새 이름에 ID를 할당하는 데 사용됩니다. UID를 지정할 하나 이상의 값 목록을 제공하면 할당 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cce588c613745b801fd6ad90920e887bdda2798a" translate="yes" xml:space="preserve">
          <source>This sub command will mark all TSMeta and UIDMeta objects for deletion in the UID table. This is useful for downgrading from 2.0 to a 1.x version or simply flushing all meta data and starting over with a &lt;code&gt;metasync&lt;/code&gt;.</source>
          <target state="translated">이 부속 명령은 모든 TSMeta 및 UIDMeta 오브젝트를 UID 테이블에서 삭제하도록 표시합니다. 이는 2.0에서 1.x 버전으로 다운 그레이드하거나 모든 메타 데이터를 플러시하고 &lt;code&gt;metasync&lt;/code&gt; 로 시작하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="942a2678bea6be3b4d6775c3e5979711cbc95a09" translate="yes" xml:space="preserve">
          <source>This table behaves as an index, organizing time series into a hierarchical structure similar to a file system for use with tools such as Graphite or other dashboards. A tree is defined by a set of rules that process a TSMeta object to determine where in the hierarchy, if at all, a time series should appear.</source>
          <target state="translated">이 테이블은 인덱스로 작동하여 Graphite 또는 기타 대시 보드와 같은 도구와 함께 사용하기 위해 파일 시스템과 유사한 계층 구조로 시계열을 구성합니다. 트리는 TSMeta 오브젝트를 처리하여 계층 구조에서 시계열이 표시 될 위치를 결정하는 일련의 규칙으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b8b1a6fda56c16d277fa9c4ac750e2117fb66b0c" translate="yes" xml:space="preserve">
          <source>This table is an index of the different time series stored in OpenTSDB and can contain meta-data for each series as well as the number of data points stored for each series. Note that data will only be written to this table if OpenTSDB has been configured to track meta-data or the user creates a TSMeta object via the API. Only one column family is used, the &lt;code&gt;name&lt;/code&gt; family and currently there are two types of columns, the meta column and the counter column.</source>
          <target state="translated">이 테이블은 OpenTSDB에 저장된 다른 시계열의 인덱스이며 각 시리즈에 대해 저장된 데이터 포인트 수뿐만 아니라 각 시리즈에 대한 메타 데이터를 포함 할 수 있습니다. 메타 데이터를 추적하도록 OpenTSDB가 구성되었거나 사용자가 API를 통해 TSMeta 오브젝트를 작성하는 경우에만이 테이블에 데이터가 기록됩니다. 하나의 열 계열 ( &lt;code&gt;name&lt;/code&gt; 계열) 만 사용 되며 현재 메타 열과 카운터 열의 두 가지 유형의 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67c524512b16bd8e1aefdf3d9db4d16ca9e470d4" translate="yes" xml:space="preserve">
          <source>This way you will collect and store stats from the TSD every 15 seconds.</source>
          <target state="translated">이렇게하면 15 초마다 TSD에서 통계를 수집하고 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="621450dc24b9ecc77453e16609469d2a6d570e83" translate="yes" xml:space="preserve">
          <source>This will create 2 metrics: &lt;code&gt;mysql.bytes_received&lt;/code&gt; and &lt;code&gt;mysql.bytes_sent&lt;/code&gt;</source>
          <target state="translated">그러면 &lt;code&gt;mysql.bytes_received&lt;/code&gt; 및 &lt;code&gt;mysql.bytes_sent&lt;/code&gt; 라는 두 가지 메트릭이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fdccbc8057607c1804602198f96157b485765a57" translate="yes" xml:space="preserve">
          <source>This will find all of the timeseries that include &quot;host&quot; values for &quot;web01&quot; OR &quot;web02&quot;, then group them by value, similar to the &lt;code&gt;*&lt;/code&gt; operator. Our groups, this time, will look like this:</source>
          <target state="translated">&quot;web01&quot;또는 &quot;web02&quot;에 &quot;host&quot;값이 포함 된 모든 시계열을 찾은 다음 &lt;code&gt;*&lt;/code&gt; 연산자 와 비슷한 값으로 그룹화합니다 . 이번에 우리 그룹은 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="654f8bc2509d4ebf03859dd5d4f821e6e290b188" translate="yes" xml:space="preserve">
          <source>This will return an aggregate of time series #1, #4, #5 and #6 since they're the only series that include &lt;code&gt;host=web01&lt;/code&gt;.</source>
          <target state="translated">이것은 시계열 # 1, # 4, # 5 및 # 6의 집계를 반환합니다 . &lt;code&gt;host=web01&lt;/code&gt; 을 포함하는 유일한 시리즈이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="9f2c0df9fea30d675d23e6bc773d61b1d8c6ee0f" translate="yes" xml:space="preserve">
          <source>This will return the data from timeseries #6 only.</source>
          <target state="translated">시계열 # 6의 데이터 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c92aa1008f141bfbd5b5476ebafb1b06aaa347a6" translate="yes" xml:space="preserve">
          <source>This will store a reading of the 1-minute and 5-minute load average of your server in OpenTSDB by sending simple &quot;telnet-style commands&quot; to the TSD:</source>
          <target state="translated">여기에는 간단한 &quot;telnet 스타일 명령&quot;을 TSD에 전송하여 OpenTSDB에 서버의 1 분 및 5 분로드 평균값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8871f0d36be99653aff86c38153695bf07943111" translate="yes" xml:space="preserve">
          <source>This won't compile the GWT UI. If you want to do UI work and have made changes, recompile OpenTSDB or export it as a JAR from your IDE, then execute the following command (assuming the directory structure above):</source>
          <target state="translated">이것은 GWT UI를 컴파일하지 않습니다. UI 작업을 수행하고 변경을 수행하려면 OpenTSDB를 다시 컴파일하거나 IDE에서 JAR로 내보내고 다음 디렉토리 구조를 가정하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a5fd51c7fb6faddc5022431da395feb115c0998d" translate="yes" xml:space="preserve">
          <source>Time Offset - This is an offset based on the rollup table config, generally on 2 bytes. The offset is not a specific number of seconds or minutes from the base, instead it's the index of an interval of an offset. For example, if the table is configured to store 1 day of data at a resolution of 1 hour per row, then the base timestamp of the row key will align on daily boundaries (on Unix epoch timestamps). Then there would be a potential of 24 offsets (1 for each hour in the day) for the row. A data point at midnight for the given day would have an offset of 0 whereas the 23:00 hour value would have an offset of 22. Since rollup timestamps are aligned to time boundaries, qualifiers can save a fair amount of space.</source>
          <target state="translated">시간 오프셋-롤업 테이블 구성을 기반으로하는 오프셋이며 일반적으로 2 바이트입니다. 오프셋은베이스에서 특정 초 또는 분이 아니라 오프셋 간격의 인덱스입니다. 예를 들어, 테이블이 행당 1 시간의 해상도로 1 일의 데이터를 저장하도록 구성된 경우 행 키의 기본 타임 스탬프는 일일 경계 (UNIX epoch 타임 스탬프)에 맞춰 정렬됩니다. 그런 다음 행에 대해 24 개의 오프셋 (하루에 시간당 1 개)이있을 수 있습니다. 주어진 날짜에 대한 자정의 데이터 포인트는 오프셋이 0 인 반면 23:00 시간 값은 22의 오프셋을 갖습니다. 롤업 타임 스탬프는 시간 경계에 따라 정렬되므로 한정자는 상당한 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef3e11fdc38bd667d112d467edf82b75d8e7af5" translate="yes" xml:space="preserve">
          <source>Time Section</source>
          <target state="translated">시간 섹션</target>
        </trans-unit>
        <trans-unit id="489a0f7a9d63940dbd34658ef6fe08c5b76eb14d" translate="yes" xml:space="preserve">
          <source>Time Series</source>
          <target state="translated">시계열</target>
        </trans-unit>
        <trans-unit id="e312672056b00372b038ae5b2af207b4bc1f9637" translate="yes" xml:space="preserve">
          <source>Time Series Cardinality</source>
          <target state="translated">시계열 카디널리티</target>
        </trans-unit>
        <trans-unit id="9dea5b9bba29c7bd741f7030630fcdc003dda6ab" translate="yes" xml:space="preserve">
          <source>Time Series Included</source>
          <target state="translated">시계열 포함</target>
        </trans-unit>
        <trans-unit id="fd6da341ee1e31055bdb0caea844b3bc49547757" translate="yes" xml:space="preserve">
          <source>Time Zones</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0f911f6c1acd495213c1806c5d882c62bd147a" translate="yes" xml:space="preserve">
          <source>Times</source>
          <target state="translated">Times</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="1d859aacd2823c28173ee1beab47dd92ba175dd1" translate="yes" xml:space="preserve">
          <source>Timestamp (ms)</source>
          <target state="translated">타임 스탬프 (ms)</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="90ca97aea224ec84cb287b485cb7b0d08501b931" translate="yes" xml:space="preserve">
          <source>Timestamps are simply the absolute time when a value for a given metric was recorded.</source>
          <target state="translated">타임 스탬프는 단순히 주어진 메트릭에 대한 값이 기록 된 절대 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b760bd1302e15474980221297fe907f4f8fae6c7" translate="yes" xml:space="preserve">
          <source>Timestamps with second resolution are stored on 2 bytes while millisecond resolution are stored on 4. Thus if you do not need millisecond resolution or all of your data points are on 1 second boundaries, we recommend that you submit timestamps with 10 digits for second resolution so that you can save on storage space. It's also a good idea to avoid mixing second and millisecond timestamps for a given time series. Doing so will slow down queries as iteration across mixed timestamps takes longer than if you only record one type or the other. OpenTSDB will store whatever you give it.</source>
          <target state="translated">두 번째 해상도의 타임 스탬프는 2 바이트에 저장되고 밀리 초 해상도는 4에 저장됩니다. 따라서 밀리 초 해상도가 필요하지 않거나 모든 데이터 포인트가 1 초 경계에있는 경우 두 번째 해상도에 10 자리의 타임 스탬프를 제출하는 것이 좋습니다. 저장 공간을 절약 할 수 있습니다. 주어진 시계열에 대해 초와 밀리 초 타임 스탬프를 혼합하지 않는 것이 좋습니다. 이렇게하면 혼합 된 타임 스탬프에 대한 반복이 한 유형 만 기록하는 것보다 시간이 오래 걸리므로 쿼리 속도가 느려집니다. OpenTSDB는 사용자가 제공 한 모든 것을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="76dd21534bedcff12519881f5fabc50b73412369" translate="yes" xml:space="preserve">
          <source>To actually run OpenTSDB, you'll need to meet the following:</source>
          <target state="translated">실제로 OpenTSDB를 실행하려면 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="60359f1b6b7026f69889540ac74c9fdac4b36942" translate="yes" xml:space="preserve">
          <source>To avoid having to run &lt;code&gt;mkmetric&lt;/code&gt; for every metric that tcollector tracks you can to start TSD with the &lt;code&gt;--auto-metric&lt;/code&gt; flag. This is useful to get started quickly, but it's not recommended to keep this flag in the long term, to avoid accidental metric creation.</source>
          <target state="translated">실행하는 것을 방지하기 위해 &lt;code&gt;mkmetric&lt;/code&gt; 당신이 할 수있는 tcollector 트랙이 함께 TSD를 시작하는 모든 통계에 대한 &lt;code&gt;--auto-metric&lt;/code&gt; 플래그. 이 기능은 빠르게 시작하는 데 유용하지만 우발적 인 메트릭 작성을 피하기 위해이 플래그를 장기적으로 유지하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e07e592b71efeb2f1e2ed46b2e03ae11cfb2df8" translate="yes" xml:space="preserve">
          <source>To create a plugin, all you have to do is extend one of the &lt;em&gt;abstract&lt;/em&gt; plugin classes, write a service description/manifest, compile, drop your JAR (along with any dependencies needed) into the OpenTSDB plugin folder, edit the TSD config and restart. That's all there is to it. No fancy frameworks, no worrying about loading and unloading at strange times, etc.</source>
          <target state="translated">플러그인을 만들려면 &lt;em&gt;추상&lt;/em&gt; 플러그인 클래스 중 하나를 확장 하고, 서비스 설명 / 매니페스트를 작성하고, 컴파일하고, 필요한 종속성과 함께 JAR을 OpenTSDB 플러그인 폴더에 놓고, TSD 구성을 편집하고 다시 시작하면됩니다. . 그것이 전부입니다. 멋진 프레임 워크가 없으며 이상한 시간에로드 및 언로드에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c443d4b058fc3575c15f9b2bcf9e9e374ad7449a" translate="yes" xml:space="preserve">
          <source>To develop a plugin, simply extend the &lt;code&gt;net.opentsdb.query.filter.TagVFilter&lt;/code&gt; class, create JAR per the &lt;a href=&quot;../../development/plugins&quot;&gt;&lt;em&gt;Plugins&lt;/em&gt;&lt;/a&gt; documentation and drop it in your plugins directory. On start, the TSD will search for the plugin and load it. If there was an error with the implementation the TSD will not start up and will log the exception.</source>
          <target state="translated">플러그인을 개발하려면 &lt;code&gt;net.opentsdb.query.filter.TagVFilter&lt;/code&gt; 클래스 를 확장 하고 &lt;a href=&quot;../../development/plugins&quot;&gt;&lt;em&gt;플러그인&lt;/em&gt;&lt;/a&gt; 문서 별로 JAR을 작성 하여 플러그인 디렉토리에 놓으십시오. 시작할 때 TSD는 플러그인을 검색하여로드합니다. 구현에 오류가 있으면 TSD가 시작되지 않고 예외를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="eb46c7d21ad8320d4fcce025edb6319d46e93c2d" translate="yes" xml:space="preserve">
          <source>To drill down to specific timeseries or group results by tag, supply one or more map values in the same format as the query string. Tags are converted to filters in 2.2. See the notes below about conversions. Note that if no tags are specified, all metrics in the system will be aggregated into the results. &lt;em&gt;Deprecated in 2.2&lt;/em&gt;</source>
          <target state="translated">태그별로 특정 시계열 또는 그룹 결과로 드릴 다운하려면 쿼리 문자열과 동일한 형식으로 하나 이상의 맵 값을 제공하십시오. 태그는 2.2에서 필터로 변환됩니다. 변환에 대한 아래 참고 사항을 참조하십시오. 태그를 지정하지 않으면 시스템의 모든 메트릭이 결과에 집계됩니다. &lt;em&gt;2.2에서 사용되지 않음&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7a2b367bd5bb346ca7de35c2c9b87f0df2c8259" translate="yes" xml:space="preserve">
          <source>To enable salting you must modify the config file parameter &lt;code&gt;tsd.storage.salt.width&lt;/code&gt; and optionally &lt;code&gt;tsd.storage.salt.buckets&lt;/code&gt;. We recommend setting the salt width to &lt;code&gt;1&lt;/code&gt; and determine the number of buckets based on a factor of the number of region servers in your cluster. Note that at query time, the TSD will fire &lt;code&gt;tsd.storage.salt.buckets&lt;/code&gt; number of scanners to fetch data. The proper number of salt buckets must be determined through experimentation as at some point query performance may suffer due to having too many scanners open and collating the results. In the future the salt width and buckets may be configurable but we didn't want folks changing settings on accident and losing data.</source>
          <target state="translated">&lt;code&gt;tsd.storage.salt.width&lt;/code&gt; 을 활성화하려면 구성 파일 매개 변수 tsd.storage.salt.width 및 선택적으로 &lt;code&gt;tsd.storage.salt.buckets&lt;/code&gt; 를 수정해야합니다 . 솔트 너비를 &lt;code&gt;1&lt;/code&gt; 로 설정하고 클러스터의 리전 서버 수에 따라 버킷 수를 결정하는 것이 좋습니다 . 쿼리시 TSD는 &lt;code&gt;tsd.storage.salt.buckets&lt;/code&gt; 수의 스캐너를 실행하여 데이터를 가져옵니다. 어떤 시점에서 너무 많은 스캐너를 열고 결과를 수집하여 쿼리 성능이 저하 될 수 있으므로 적절한 소금 버킷 수는 실험을 통해 결정해야합니다. 앞으로 소금 너비와 버켓을 구성 할 수 있지만 사고로 인한 설정 변경 및 데이터 손실을 원하지 않는 사람들이있었습니다.</target>
        </trans-unit>
        <trans-unit id="e89381af42351d3225bfe932a7ba6493d1b4f2fa" translate="yes" xml:space="preserve">
          <source>To extract data with millisecond resolution, use the &lt;code&gt;/api/query&lt;/code&gt; endpoint and specify the &lt;code&gt;msResolution&lt;/code&gt; (</source>
          <target state="translated">밀리 초 해상도로 데이터를 추출하려면 &lt;code&gt;/api/query&lt;/code&gt; 엔드 포인트를 사용하고 &lt;code&gt;msResolution&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="4a2b8d9808dd030eb53be711ada35e8fb4d66a48" translate="yes" xml:space="preserve">
          <source>To fetch a specific tree, supply a &lt;a href=&quot;#id5&quot;&gt;&lt;span id=&quot;id6&quot;&gt;``&lt;/span&gt;&lt;/a&gt;treeId' value. The response will include the tree object if found. If the requested tree does not exist, a 404 exception will be returned.</source>
          <target state="translated">특정 트리를 가져 오려면 &lt;a href=&quot;#id5&quot;&gt;&lt;span id=&quot;id6&quot;&gt;``&lt;/span&gt;&lt;/a&gt; treeId ''값을 제공하십시오. 응답은 발견 된 경우 트리 개체를 포함합니다. 요청 된 트리가 존재하지 않으면 404 예외가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="04bb0ce2063725f6800f6e9adaea2ecac40bcb94" translate="yes" xml:space="preserve">
          <source>To help describe the lower resolution data, lets look at some full resolution (also known as &lt;em&gt;raw&lt;/em&gt; data) example data. The first table defines the time series with a short-cut identifier.</source>
          <target state="translated">저해상도 데이터를 설명하는 데 도움이되도록 전체 해상도 ( &lt;em&gt;원시&lt;/em&gt; 데이터 라고도 함 ) 예제 데이터를 살펴 보겠습니다 . 첫 번째 표는 바로 가기 식별자로 시계열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0289a01433a99be32878ebc034f5f7cc75a214ca" translate="yes" xml:space="preserve">
          <source>To plot HTTP hits, you just go to the UI and enter &lt;code&gt;http.hits&lt;/code&gt; as your metric name, and enter the time range. Check the &quot;Rate&quot; button since this particular metric is a rate counter, and voil?, you have a plot of the rate of HTTP hits to your web servers over time.</source>
          <target state="translated">HTTP 적중을 표시하려면 UI로 이동 하여 메트릭 이름으로 &lt;code&gt;http.hits&lt;/code&gt; 를 입력하고 시간 범위를 입력하십시오. 이 특정 측정 항목이 요율 카운터이므로 &quot;등급&quot;버튼을 확인하십시오. 시간이 지남에 따라 웹 서버에 대한 HTTP 적중률의 도표가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2f1d0961ccf579d8319c865282051b5dcc1682" translate="yes" xml:space="preserve">
          <source>To reduce the number of datapoints returned, you can specify a downsampling interval and method, such as 1h-avg or 1d-sum. This is also useful (such as when using the max and min) to find best and worst-case datapoints over a given period. Downsampling is most useful to make the graphing phase less intensive and more readable, especially when graphing more datapoints than screen pixels.</source>
          <target state="translated">반환되는 데이터 포인트 수를 줄이려면 다운 샘플링 간격 및 방법 (예 : 1h-avg 또는 1d-sum)을 지정할 수 있습니다. 이는 주어진 기간 동안 최고 및 최악의 데이터 포인트를 찾는 데 유용합니다 (예 : 최대 및 최소 사용시). 다운 샘플링은 특히 화면 픽셀보다 많은 데이터 포인트를 그래프로 그릴 때 그래프 단계를 덜 집중적이고 읽기 쉽게 만드는 데 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="206fc5278f71889a5df790996622469345082b57" translate="yes" xml:space="preserve">
          <source>To retreive a list of all time series with a specific tag value, e.g. a particular host, you could issue a query like &lt;code&gt;{*=web01}&lt;/code&gt; that will return all time series with a tag value of &lt;code&gt;web01&lt;/code&gt;. This can be useful in debugging tag name issues such as some series having &lt;code&gt;host=web01&lt;/code&gt; or &lt;code&gt;server=web01&lt;/code&gt;.</source>
          <target state="translated">특정 호스트와 같은 특정 태그 값을 가진 모든 시계열 목록을 검색하려면 &lt;code&gt;{*=web01}&lt;/code&gt; 과 같은 쿼리를 발행 하여 태그 값이 &lt;code&gt;web01&lt;/code&gt; 인 모든 시계열을 반환 할 수 있습니다 . &lt;code&gt;host=web01&lt;/code&gt; 또는 &lt;code&gt;server=web01&lt;/code&gt; 인 일부 시리즈와 같은 태그 이름 문제를 디버깅하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae3ba06a81941ae0793fa2e863e31650dabaf207" translate="yes" xml:space="preserve">
          <source>To save on bandwidth, the put API allows clients to store multiple data points in a single request. The data points do not have to be related in any way. Each data point is processed individually and an error with one piece of data will not affect the storing of good data. This means if your request has 100 data points and 1 of them has an error, 99 data points will still be written and one will be rejected. See the Response section below for details on determining what data point was not stored.</source>
          <target state="translated">대역폭을 절약하기 위해 put API를 사용하면 클라이언트가 단일 요청으로 여러 데이터 포인트를 저장할 수 있습니다. 데이터 포인트는 어떤 식 으로든 관련 될 필요가 없습니다. 각 데이터 포인트는 개별적으로 처리되며 한 데이터의 오류는 양호한 데이터 저장에 영향을 미치지 않습니다. 즉, 요청에 100 개의 데이터 요소가 있고 그 중 하나에 오류가 있으면 99 개의 데이터 요소가 여전히 기록되고 하나는 거부됩니다. 저장되지 않은 데이터 포인트 결정에 대한 자세한 내용은 아래 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cb26e03bf6caa382462bbb080b416f004afb7dfd" translate="yes" xml:space="preserve">
          <source>To see the values retreived, and potentially ignored (due to duration), use the &lt;code&gt;--verbose&lt;/code&gt; option.</source>
          <target state="translated">값이 검색되어 잠재적으로 무시되는 (기간으로 인해) 값을 보려면 &lt;code&gt;--verbose&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1141eb96836ed960ae0be11b9889597388b5df0" translate="yes" xml:space="preserve">
          <source>Token</source>
          <target state="translated">Token</target>
        </trans-unit>
        <trans-unit id="f3eadee436bb785948d8a4454eac0ffa93e13c6b" translate="yes" xml:space="preserve">
          <source>Tokens are case sensitive and must appear only one time per formatter. They must also appear exactly as deliniated in the table below:</source>
          <target state="translated">토큰은 대소 문자를 구분하며 포맷터 당 한 번만 나타나야합니다. 또한 아래 표에서 정확하게 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f87ec395ac606db76f200b147dec7a31e7b7452" translate="yes" xml:space="preserve">
          <source>Too many writes - If the rate of writes to TSD is high, queues can build up in AsyncHBase (see above) or in the compaction queue. If this is the case, check HBase performance and try disabling compactions.</source>
          <target state="translated">쓰기 횟수가 너무 많음-TSD 쓰기 속도가 높으면 AsyncHBase (위 참조) 또는 압축 큐에 큐가 쌓일 수 있습니다. 이 경우 HBase 성능을 확인하고 압축 해제를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="36bdc9b93299ca57fdc5e1139fc6188616a66b82" translate="yes" xml:space="preserve">
          <source>Total number of row key UIDs resolved to tag values when a regex or wildcard filter is used. If neither filter is used this value should be zero.</source>
          <target state="translated">정규식 또는 와일드 카드 필터를 사용할 때 태그 값으로 확인 된 총 행 키 UID 수입니다. 필터를 사용하지 않으면이 값은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5aecfccdd05af19794f77cc2c4ef521342c8b36d" translate="yes" xml:space="preserve">
          <source>Total time spent merging the salt scanner results into a single set prior to group by operations.</source>
          <target state="translated">작업별로 그룹화하기 전에 솔트 스캐너 결과를 단일 세트로 병합하는 데 소요 된 총 시간입니다.</target>
        </trans-unit>
        <trans-unit id="657758eebef269a1e952bb28be026e73eb271ce1" translate="yes" xml:space="preserve">
          <source>Total time spent on the query including writing to the socket. This is only found in the log files and stats API.</source>
          <target state="translated">소켓에 쓰는 것을 포함하여 쿼리에 소요 된 총 시간입니다. 이것은 로그 파일 및 통계 API에서만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="089890710e57b5c26fc22670530dccd26bbae1a6" translate="yes" xml:space="preserve">
          <source>Total time spent processing, fetching data and serializing results for the query until it is written over the wire. This value is sent in the API summary results and used as an estimate of the total time spent processing by the TSD. However it does not include the amount of time it took to send the value over the wire.</source>
          <target state="translated">유선으로 쓰여질 때까지 쿼리 처리, 데이터 페치 및 결과 직렬화에 소요 된 총 시간입니다. 이 값은 API 요약 결과로 전송되며 TSD에서 처리하는 데 소요 된 총 시간의 추정치로 사용됩니다. 그러나 와이어를 통해 값을 전송하는 데 걸린 시간은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60dcd3d4b81bf17688ed3e6350df63bb4f6b2b1d" translate="yes" xml:space="preserve">
          <source>Total time spent serializing the query results. This includes &lt;code&gt;aggregationTime&lt;/code&gt; and &lt;code&gt;uidToStringTime&lt;/code&gt;.</source>
          <target state="translated">쿼리 결과를 직렬화하는 데 소요 된 총 시간입니다. 여기에는 &lt;code&gt;aggregationTime&lt;/code&gt; 및 &lt;code&gt;uidToStringTime&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="861ac34b9540c7796fe135cd52c2e3d0c4aad8b8" translate="yes" xml:space="preserve">
          <source>Total time spent waiting on the scanners to return results. This includes the &lt;code&gt;groupByTime&lt;/code&gt;.</source>
          <target state="translated">스캐너에서 결과를 반환하기 위해 대기 한 총 시간입니다. 여기에는 &lt;code&gt;groupByTime&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="af560b2e24f1ad58d5d62ac075d516d0ac93b2b5" translate="yes" xml:space="preserve">
          <source>Tree API Endpoints</source>
          <target state="translated">트리 API 엔드 포인트</target>
        </trans-unit>
        <trans-unit id="b7de4b14bbae9e0420e5c0c37a4da24123a1d451" translate="yes" xml:space="preserve">
          <source>Tree Building</source>
          <target state="translated">트리 빌딩</target>
        </trans-unit>
        <trans-unit id="a4d9834abfeee6127bb018e1483be51797d10f3d" translate="yes" xml:space="preserve">
          <source>Tree Collision Column</source>
          <target state="translated">트리 충돌 열</target>
        </trans-unit>
        <trans-unit id="b9a9ebf94115bd223f813e222f6b56c26ab39a7b" translate="yes" xml:space="preserve">
          <source>Tree Column</source>
          <target state="translated">트리 열</target>
        </trans-unit>
        <trans-unit id="f0ac3f920b03c026fea222b53c72371a16560c9c" translate="yes" xml:space="preserve">
          <source>Tree Table Schema</source>
          <target state="translated">트리 테이블 스키마</target>
        </trans-unit>
        <trans-unit id="04cbb348b9d0c2549479656118483f2904a6d60a" translate="yes" xml:space="preserve">
          <source>Tree Terminology</source>
          <target state="translated">트리 용어</target>
        </trans-unit>
        <trans-unit id="3dccf7d04c71370b16ef3dc41b6463668e09ce6c" translate="yes" xml:space="preserve">
          <source>Tree containing all network gear</source>
          <target state="translated">모든 네트워크 장비를 포함하는 트리</target>
        </trans-unit>
        <trans-unit id="ff805fc3d6a56a8ed5a7cf7471cef456e1ac21c3" translate="yes" xml:space="preserve">
          <source>Tree definition rows are keyed with the ID of the tree on two bytes. Columns pertaining to the tree definition, as well as the root branch, appear in this row. Definitions are generated by the user.</source>
          <target state="translated">트리 정의 행은 2 바이트의 트리 ID로 키가 지정됩니다. 루트 정의뿐만 아니라 트리 정의와 관련된 열이이 행에 나타납니다. 정의는 사용자가 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d39b5d285f0cc598f0cb5321e34fab826ebc29f0" translate="yes" xml:space="preserve">
          <source>Trees - Flatten metric and tag combinations into a single name for navigation or usage with different tools</source>
          <target state="translated">트리-다른 도구를 사용하여 탐색 또는 사용하기 위해 메트릭 및 태그 조합을 단일 이름으로 병합</target>
        </trans-unit>
        <trans-unit id="794e328c103f1eb70d87f054a9067530d5625342" translate="yes" xml:space="preserve">
          <source>Trees are meta data used to organize time series in a heirarchical structure for browsing similar to a typical file system. A number of endpoints under the &lt;code&gt;/tree&lt;/code&gt; root allow working with various tree related data:</source>
          <target state="translated">트리는 일반적인 파일 시스템과 유사한 탐색을 위해 계층 구조로 시계열을 구성하는 데 사용되는 메타 데이터입니다. &lt;code&gt;/tree&lt;/code&gt; 루트 아래의 여러 엔드 포인트 는 다양한 트리 관련 데이터로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="61f6794803111387499c42973f9ace9b4eb6f76c" translate="yes" xml:space="preserve">
          <source>Tsddrain does not accept HTTP input at this time.</source>
          <target state="translated">현재 Tsddrain은 HTTP 입력을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92244b78a999e203c54499593c498f2f97de32b2" translate="yes" xml:space="preserve">
          <source>Tweaking the load balancing strategy</source>
          <target state="translated">로드 밸런싱 전략 조정</target>
        </trans-unit>
        <trans-unit id="77da6d1f7dff0d1135159537ab9d17076370fa57" translate="yes" xml:space="preserve">
          <source>Two set operations (or Joins) are allowed. The union of all time series ore the intersection.</source>
          <target state="translated">두 가지 설정 작업 (또는 조인)이 허용됩니다. 모든 시계열의 합집합은 교차점입니다.</target>
        </trans-unit>
        <trans-unit id="dbb69f29376fb89b3259001b13f296cf3415d2af" translate="yes" xml:space="preserve">
          <source>Two special rows may be included. They are keyed on &lt;code&gt;&amp;lt;tree ID&amp;gt;\x01&lt;/code&gt; for the &lt;code&gt;collisions&lt;/code&gt; row and &lt;code&gt;&amp;lt;tree ID&amp;gt;\x02&lt;/code&gt; for the &lt;code&gt;not matched&lt;/code&gt; row. These are generated during tree processing and will be described later.</source>
          <target state="translated">두 개의 특수 행이 포함될 수 있습니다. 그들은에 맞도록 제작되어 &lt;code&gt;&amp;lt;tree ID&amp;gt;\x01&lt;/code&gt; 에 대한 &lt;code&gt;collisions&lt;/code&gt; 행과 &lt;code&gt;&amp;lt;tree ID&amp;gt;\x02&lt;/code&gt; 에 대한 &lt;code&gt;not matched&lt;/code&gt; 행입니다. 이들은 트리 처리 중에 생성되며 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="ca3c1a6731e5a44411741fd9a605c6bf895f304b" translate="yes" xml:space="preserve">
          <source>Type and Length - Similar to the original data table, the last 4 bits of each offset byte array contains the encoding of the data value including it's length and whether or not it's a floating point value.</source>
          <target state="translated">유형 및 길이-원래 데이터 테이블과 유사하게 각 오프셋 바이트 배열의 마지막 4 비트에는 길이 및 부동 소수점 값인지 여부를 포함하여 데이터 값의 인코딩이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f01d55f40f860d30f2fe8a43da1f39c80d3145" translate="yes" xml:space="preserve">
          <source>Types of Errors and Fixes</source>
          <target state="translated">오류 및 수정 유형</target>
        </trans-unit>
        <trans-unit id="7ee1ceab41a26272255db21efaed512deff2e8ff" translate="yes" xml:space="preserve">
          <source>Types of UID objects include:</source>
          <target state="translated">UID 객체의 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62fab72bfc6f28ab4ed716737c471e31e8c43bb5" translate="yes" xml:space="preserve">
          <source>Typically you want to gather data about everything in your system. This generates a lot of datapoints, the majority of which don't change very often over time (if ever). However, you want fine-grained resolution when they do change. Tcollector remembers the last value and timestamp that was sent for all of the time series for all of the collectors it manages. If the value doesn't change between sample intervals, it suppresses sending that datapoint. Once the value does change (or 10 minutes have passed), it sends the last suppressed value and timestamp, plus the current value and timestamp. In this way all of your graphs and such are correct. Deduplication typically reduces the number of datapoints TSD needs to collect by a large fraction. This reduces network load and storage in the backend. A future OpenTSDB release however will improve on the storage format by using RLE (among other things), making it essentially free to store repeated values.</source>
          <target state="translated">일반적으로 시스템의 모든 정보를 수집하려고합니다. 이로 인해 많은 데이터 포인트가 생성되며 대부분의 데이터 포인트는 시간이 지남에 따라 자주 변경되지 않습니다. 그러나 변경 될 때 세밀한 해상도를 원합니다. Tcollector는 관리하는 모든 수집기의 모든 시계열에 대해 전송 된 마지막 값과 타임 스탬프를 기억합니다. 샘플 간격간에 값이 변경되지 않으면 해당 데이터 포인트 전송을 억제합니다. 값이 변경되면 (또는 10 분이 지난 후) 마지막으로 억제 된 값과 타임 스탬프와 현재 값 및 타임 스탬프를 보냅니다. 이런 식으로 모든 그래프와 같은 것이 정확합니다. 중복 제거는 일반적으로 TSD가 수집해야하는 데이터 포인트 수를 크게 줄입니다. 이는 백엔드의 네트워크로드 및 스토리지를 줄입니다.그러나 향후 OpenTSDB 릴리스는 RLE를 사용하여 스토리지 형식을 개선하여 본질적으로 반복되는 값을 자유롭게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d946adf52a4783929f122d341b29ac0fe188371c" translate="yes" xml:space="preserve">
          <source>UID</source>
          <target state="translated">UID</target>
        </trans-unit>
        <trans-unit id="efc8bfd13b8d10b2d1a130a353a77c47b91c9dbc" translate="yes" xml:space="preserve">
          <source>UID API Endpoints</source>
          <target state="translated">UID API 엔드 포인트</target>
        </trans-unit>
        <trans-unit id="543b3c677091a05fcea7bdb14f924473c3f72a77" translate="yes" xml:space="preserve">
          <source>UID Assignment</source>
          <target state="translated">UID 할당</target>
        </trans-unit>
        <trans-unit id="b5675582ba86f151cbdddf91455de2dde6130b4a" translate="yes" xml:space="preserve">
          <source>UID Assignment Row</source>
          <target state="translated">UID 할당 행</target>
        </trans-unit>
        <trans-unit id="5f8448ea278c4664343196814797d2d7b33c3d96" translate="yes" xml:space="preserve">
          <source>UID Cache - Preload portions of the UID table on startup to improve writes</source>
          <target state="translated">UID 캐시-쓰기 향상을 위해 시작시 UID 테이블의 일부를 미리로드</target>
        </trans-unit>
        <trans-unit id="4e2ace2601b87fcaa65a51ba9d42e5638b39d99c" translate="yes" xml:space="preserve">
          <source>UID Table Schema</source>
          <target state="translated">UID 테이블 스키마</target>
        </trans-unit>
        <trans-unit id="974c6cb360ec0dbd84dd5a168cb80c2dd357af25" translate="yes" xml:space="preserve">
          <source>UIDMETA Response</source>
          <target state="translated">UIDMETA 응답</target>
        </trans-unit>
        <trans-unit id="5f7157a721abe60ace958d566e1fe3a2cbebb1a7" translate="yes" xml:space="preserve">
          <source>UIDMeta</source>
          <target state="translated">UIDMeta</target>
        </trans-unit>
        <trans-unit id="f9197c1a4e42b1ade480a1238ddff20479bf283e" translate="yes" xml:space="preserve">
          <source>UIDs and TSUIDs</source>
          <target state="translated">UID 및 TSUID</target>
        </trans-unit>
        <trans-unit id="6c1f9e85962ff3151f54f7c8ea05b7a45c5f8f09" translate="yes" xml:space="preserve">
          <source>UIDs are assigned automatically for new &lt;code&gt;tagk&lt;/code&gt; and &lt;code&gt;tagv&lt;/code&gt; objects when data points are written to a TSD. &lt;code&gt;metric&lt;/code&gt; objects also receive new UIDs but only if the &lt;em&gt;auto metric&lt;/em&gt; setting has been configured to &lt;code&gt;true&lt;/code&gt;. Otherwise data points with new metrics are rejected. The UIDs are looked up in a cached map for every incoming data point. If the lookup fails, then the TSD will attempt to assign a new UID.</source>
          <target state="translated">데이터 포인트가 TSD에 기록 될 때 새 &lt;code&gt;tagk&lt;/code&gt; 및 &lt;code&gt;tagv&lt;/code&gt; 객체에 UID가 자동으로 할당됩니다 . &lt;code&gt;metric&lt;/code&gt; 개체는 새 UID를 수신하지만 &lt;em&gt;자동 메트릭&lt;/em&gt; 설정이 &lt;code&gt;true&lt;/code&gt; 로 구성된 경우에만 가능 합니다 . 그렇지 않으면 새 메트릭이있는 데이터 포인트가 거부됩니다. UID는 모든 수신 데이터 포인트에 대해 캐시 된 맵에서 조회됩니다. 조회가 실패하면 TSD는 새 UID를 할당하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="8ae22773b0650a5a7f4513a10651c639d8523b6d" translate="yes" xml:space="preserve">
          <source>UIDs can be displayed in a few ways. The most common method is via the HTTP API where the 3 bytes of UID data are encoded as a hexadecimal string. For example, the UID of &lt;code&gt;1&lt;/code&gt; would be written in binary as &lt;code&gt;000000000000000000000001&lt;/code&gt;. As an array of unsigned byte values, you could imagine it as &lt;code&gt;[0, 0, 1]&lt;/code&gt;. Encoded as a hex string, the value would be &lt;code&gt;000001&lt;/code&gt; where the string is padded with 0s for each byte. The UID of 255 would result in a hex value of &lt;code&gt;0000FF&lt;/code&gt; (or as a byte array, &lt;code&gt;[0, 0, 255]&lt;/code&gt;. To convert between a decimal UID to a hex, use any kind of hex conversion tool you prefer and put 0s in front of the resulting value until you have a total of 6 characters. To convert from a hex UID to decimal, simply drop any 0s from the front, then use a tool to convert the hex string to a decimal.</source>
          <target state="translated">UID는 몇 가지 방법으로 표시 될 수 있습니다. 가장 일반적인 방법은 3 바이트의 UID 데이터가 16 진 문자열로 인코딩되는 HTTP API를 사용하는 것입니다. 예를 들어 &lt;code&gt;1&lt;/code&gt; 의 UID는 이진수로 &lt;code&gt;000000000000000000000001&lt;/code&gt; 로 작성됩니다 . 부호없는 바이트 값의 배열로 &lt;code&gt;[0, 0, 1]&lt;/code&gt; 로 상상할 수 있습니다. 16 진 문자열로 인코딩 된 값은 문자열이 각 바이트에 대해 0으로 채워지는 &lt;code&gt;000001&lt;/code&gt; 입니다. UID가 255이면 16 진수 값이 &lt;code&gt;0000FF&lt;/code&gt; 가됩니다 (또는 바이트 배열 &lt;code&gt;[0, 0, 255]&lt;/code&gt; . 10 진수 UID를 16 진수로 변환하려면 원하는 모든 16 진수 변환 도구를 사용하고 총 6자가 될 때까지 결과 값 앞에 0을 입력하십시오. 16 진수 UID에서 10 진수로 변환하려면 앞에 0을 놓은 다음 도구를 사용하여 16 진수 문자열을 10 진수로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="275fba4d52934eeeeaea4a6e1704ebdc91c91c93" translate="yes" xml:space="preserve">
          <source>UIDs can be renamed or deleted. Renaming can be accomplished via the CLI and is generally safe but will affect EVERY time series that includes the renamed ID. E.g. if we have a series &lt;code&gt;sys.cpu.user host=web01&lt;/code&gt; and another &lt;code&gt;apache.requests host=web01&lt;/code&gt; and rename the &lt;code&gt;web01&lt;/code&gt; tag value to &lt;code&gt;web01.mysite.org&lt;/code&gt;, then both series will now reflect the new host name and all queries referring to the old name must be updated.. If a data point comes in that has the previous string, a new UID will be assigned.</source>
          <target state="translated">UID의 이름을 바꾸거나 삭제할 수 있습니다. 이름 바꾸기는 CLI를 통해 수행 할 수 있으며 일반적으로 안전하지만 이름이 바뀐 ID를 포함하는 모든 시계열에 영향을 미칩니다. 예를 들어 &lt;code&gt;sys.cpu.user host=web01&lt;/code&gt; 시리즈 와 다른 &lt;code&gt;apache.requests host=web01&lt;/code&gt; 시리즈가 있고 &lt;code&gt;web01&lt;/code&gt; 태그 값의 이름 을 &lt;code&gt;web01.mysite.org&lt;/code&gt; 로 바꾸면 두 시리즈 모두 새로운 호스트 이름과 참조하는 모든 쿼리를 반영합니다. 이전 이름을 업데이트해야합니다. 이전 문자열이있는 데이터 포인트가 있으면 새 UID가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f6111ab8aff19e224fd7aa0713279e191d852ba7" translate="yes" xml:space="preserve">
          <source>UIDs exposed via the API are encoded as hexadecimal strings. The UID &lt;code&gt;42&lt;/code&gt; would be expressed as &lt;code&gt;00002A&lt;/code&gt; given the default UID width of 3 bytes.</source>
          <target state="translated">API를 통해 노출 된 UID는 16 진 문자열로 인코딩됩니다. UID &lt;code&gt;42&lt;/code&gt; 는 기본 UID 너비가 3 바이트 인 경우 &lt;code&gt;00002A&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a0b22dcd5350ecefbdaa9c79785bca53d21d47" translate="yes" xml:space="preserve">
          <source>Under Arguments, add the runtime arguments to select your Zookeeper quorum and the static and cache directories</source>
          <target state="translated">인수에서 런타임 인수를 추가하여 Zookeeper 쿼럼과 정적 및 캐시 디렉토리를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5065ce45ae6cb88021a77e3a856fb9a062137074" translate="yes" xml:space="preserve">
          <source>Under Java Application, right click and select New from the pop-up</source>
          <target state="translated">Java 애플리케이션 아래에서 마우스 오른쪽 단추를 클릭하고 팝업에서 새로 작성을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="91ba162b681d6b6ee5e37c09ea2e8e36df8b03a6" translate="yes" xml:space="preserve">
          <source>Under the Hood</source>
          <target state="translated">후드</target>
        </trans-unit>
        <trans-unit id="ea8c61b5e1c51a7efed319315012fd68842885a8" translate="yes" xml:space="preserve">
          <source>Under the Main tab, brows to your &lt;code&gt;opentsdb_dev&lt;/code&gt; project</source>
          <target state="translated">기본 탭에서 &lt;code&gt;opentsdb_dev&lt;/code&gt; 프로젝트로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0c6b221514dced57c82259e527fb1c95f2148db2" translate="yes" xml:space="preserve">
          <source>Understanding Metrics and Time Series</source>
          <target state="translated">지표 및 시계열 이해</target>
        </trans-unit>
        <trans-unit id="539285ded1b7120d839ed3fe9fcd9a4e66098a62" translate="yes" xml:space="preserve">
          <source>Understanding the order of operations is important. When returning query results the following is the order in which processing takes place:</source>
          <target state="translated">작업 순서를 이해하는 것이 중요합니다. 쿼리 결과를 반환 할 때 처리 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c33600cf6d51f9346e2f37fe157401ec25b6bb4b" translate="yes" xml:space="preserve">
          <source>Unfortunately OpenTSDB requires metrics to be named as a single, long word without spaces. Thus metrics are usually recorded using &quot;dotted notation&quot;. For example, the metrics above would have names like:</source>
          <target state="translated">불행하게도 OpenTSDB는 메트릭을 공백없이 하나의 긴 단어로 명명해야합니다. 따라서 메트릭은 일반적으로 &quot;점 표기법&quot;을 사용하여 기록됩니다. 예를 들어 위 측정 항목의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ee342101204865fad114187a2c29e871861faf6" translate="yes" xml:space="preserve">
          <source>Unicode characters must be escaped with their hexadecimal representation, e.g.:</source>
          <target state="translated">16 진수로 유니 코드 문자를 이스케이프해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1991628ada29bf2f101603a9262a20c08a71bc46" translate="yes" xml:space="preserve">
          <source>Unit test dependencies go here as well as regular items</source>
          <target state="translated">단위 테스트 종속성 및 일반 항목</target>
        </trans-unit>
        <trans-unit id="1b634528810ec52e76f56b6ea40ab7999a71da6f" translate="yes" xml:space="preserve">
          <source>Units reflective of the data stored in the timeseries, may be used in GUIs or calculations</source>
          <target state="translated">시계열에 저장된 데이터를 반영하는 단위는 GUI 또는 계산에 사용될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="95d7c16a612d93451970f944811995c4f0403e4b" translate="yes" xml:space="preserve">
          <source>Unix epoch timestamp, in seconds, when the statistic was collected and displayed</source>
          <target state="translated">통계가 수집되어 표시된 유닉스 시대 타임 스탬프 (초)</target>
        </trans-unit>
        <trans-unit id="b439a28e7a28b340333b5212b063a2eef57c7e97" translate="yes" xml:space="preserve">
          <source>Unix timestamps are not supported directly in the boxes. You can click in a box to display the calendar, then paste a Unix timestamp (in seconds) in the &lt;em&gt;UNIX Timestamp&lt;/em&gt; box, then press the &lt;em&gt;TAB&lt;/em&gt; key to convert to a human readable time stamp.</source>
          <target state="translated">유닉스 타임 스탬프는 박스에서 직접 지원되지 않습니다. 상자를 클릭하여 달력을 표시 한 다음 &lt;em&gt;UNIX 타임 스탬프&lt;/em&gt; 상자 에 Unix 타임 스탬프 (초)를 붙여 넣은 다음 &lt;em&gt;Tab&lt;/em&gt; 키를 눌러 사람이 읽을 수있는 타임 스탬프로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62769f032e81de985972e84a3c510109f83d37ca" translate="yes" xml:space="preserve">
          <source>Unknown Object</source>
          <target state="translated">미지의 물체</target>
        </trans-unit>
        <trans-unit id="da44612554286f7b344d56ffdbb816c4c5a27e73" translate="yes" xml:space="preserve">
          <source>Unless there was an error with the query, you will generally receive a &lt;code&gt;200&lt;/code&gt; status with content. However if your query couldn't find any data, it will return an empty result set. In the case of the JSON serializer, the result will be an empty array:</source>
          <target state="translated">쿼리에 오류가없는 경우 일반적으로 내용이 포함 된 &lt;code&gt;200&lt;/code&gt; 상태를 받습니다 . 그러나 쿼리에서 데이터를 찾을 수 없으면 빈 결과 집합이 반환됩니다. JSON 시리얼 라이저의 경우 결과는 빈 배열입니다.</target>
        </trans-unit>
        <trans-unit id="887725b9b2d9de5942f6fd25be6171e1707834a8" translate="yes" xml:space="preserve">
          <source>Unlike other solutions, OpenTSDB allows for writing data for a given time series in any order you want. This enables significant flexibility in writing data to a TSD, allowing for populating current data from your systems, then importing historical data at a later time.</source>
          <target state="translated">다른 솔루션과 달리 OpenTSDB를 사용하면 원하는 시계열에 대해 원하는 순서대로 데이터를 쓸 수 있습니다. 이를 통해 TSD에 데이터를 쓸 때 유연성이 크게 향상되어 시스템에서 현재 데이터를 채운 후 나중에 기록 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7efdcfaa5fef1886c5eac143fdd11d5e446bb90" translate="yes" xml:space="preserve">
          <source>Unlike rollups, pre-aggregates require only one extra piece of information:</source>
          <target state="translated">롤업과 달리 사전 집계에는 추가 정보가 하나만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="268e1b3bfe651b314080183be7d9af48bbefa66a" translate="yes" xml:space="preserve">
          <source>Unlike, say, the Apache Software Foundation, we do not require every single code change to be attached to an issue. Feel free to send as many small fixes as you want.</source>
          <target state="translated">예를 들어 Apache Software Foundation과 달리 모든 단일 코드 변경 사항을 문제에 첨부 할 필요는 없습니다. 원하는만큼 작은 수정 사항을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="723bf1f1b206c7d57fb30b939691510cc908d91f" translate="yes" xml:space="preserve">
          <source>Upgrading from 1.x</source>
          <target state="translated">1.x에서 업그레이드</target>
        </trans-unit>
        <trans-unit id="4bada923eb537c32b1130b46b21e345aa88e57e6" translate="yes" xml:space="preserve">
          <source>Upgrading from 2.x to a Later 2.x</source>
          <target state="translated">2.x에서 이후 2.x로 업그레이드</target>
        </trans-unit>
        <trans-unit id="812d4982309d008f7c03d0cb3a94bc41a59d939a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;final&lt;/code&gt; keyword as much as you can, particularly in method parameters and returns statements.</source>
          <target state="translated">특히 메소드 매개 변수 및 리턴 문에서 &lt;code&gt;final&lt;/code&gt; 키워드를 최대한 많이 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7179b86bb974ee303c899e0371bb8cc7a88fc161" translate="yes" xml:space="preserve">
          <source>Use the UID utility with the command line:</source>
          <target state="translated">명령 행과 함께 UID 유틸리티를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a62d7be4d20f3ca36605734857c9d9a4f255fc4" translate="yes" xml:space="preserve">
          <source>Use the same number and type of tags for each metric. E.g. don't store &lt;code&gt;my.metric host=foo&lt;/code&gt; and &lt;code&gt;my.metric datacenter=lga&lt;/code&gt;.</source>
          <target state="translated">각 측정 항목에 동일한 수와 유형의 태그를 사용하십시오. 예를 들어 &lt;code&gt;my.metric host=foo&lt;/code&gt; 및 &lt;code&gt;my.metric datacenter=lga&lt;/code&gt; 를 저장하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d0f58237f9a77c653e547056f98607e47737c630" translate="yes" xml:space="preserve">
          <source>Used for auto-complete calls to match metrics, tag names or tag values on the given string. Returns JSON data only.</source>
          <target state="translated">지정된 문자열의 메트릭, 태그 이름 또는 태그 값을 일치시키기 위해 자동 완성 호출에 사용됩니다. JSON 데이터 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="889e3ce88b4e100bf58ad78f2e5dee7ca859f022" translate="yes" xml:space="preserve">
          <source>Used in combination with the &lt;code&gt;limit&lt;/code&gt; value to page through results. Allowable values depends on the plugin. Ignored for lookups.</source>
          <target state="translated">결과를 페이지 간 &lt;code&gt;limit&lt;/code&gt; 값 과 함께 사용 합니다. 허용되는 값은 플러그인에 따라 다릅니다. 조회를 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="7caa59a04649df7ca329cc939d0163d6e2ab43f1" translate="yes" xml:space="preserve">
          <source>Used only when &lt;code&gt;DELETE&lt;/code&gt; ing a tree, if this flag is set to true, then the entire tree definition will be deleted along with all branches, collisions and not matched entries</source>
          <target state="translated">트리를 &lt;code&gt;DELETE&lt;/code&gt; 때만 사용되며 ,이 플래그가 true로 설정되면 전체 트리 정의가 모든 분기, 충돌 및 일치하지 않는 항목과 함께 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ec32471cc339eb0bbad07fecfae799469fe69b" translate="yes" xml:space="preserve">
          <source>Used to delete data from the system</source>
          <target state="translated">시스템에서 데이터를 삭제하는 데 사용</target>
        </trans-unit>
        <trans-unit id="f01497acb828100c6704a58798225da6666dd614" translate="yes" xml:space="preserve">
          <source>Used to fetch or modify a specific tree. &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;*&lt;/span&gt;&lt;/a&gt;When creating a new tree, the &lt;code&gt;tree&lt;/code&gt; value must not be present.</source>
          <target state="translated">특정 트리를 가져 오거나 수정하는 데 사용됩니다. &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;*&lt;/span&gt;&lt;/a&gt; 새 트리를 만들 때 &lt;code&gt;tree&lt;/code&gt; 값이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="fcf7c7b636b7ef81cedeaaa54cc8a16bfb376544" translate="yes" xml:space="preserve">
          <source>Used to fetch the root branch of the tree. If used in combination with a branchId, the tree ID will be ignored.</source>
          <target state="translated">트리의 루트 분기를 가져 오는 데 사용됩니다. branchId와 함께 사용하면 트리 ID가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="da66c1b3889159b91772a81e88c3f8b48fa82323" translate="yes" xml:space="preserve">
          <source>Used to retrieve data from OpenTSDB. Overrides can be provided to modify content. &lt;strong&gt;Note&lt;/strong&gt;: Requests via GET can only use query string parameters; see the note below.</source>
          <target state="translated">OpenTSDB에서 데이터를 검색하는 데 사용됩니다. 내용을 수정하기 위해 재정의를 제공 할 수 있습니다. &lt;strong&gt;참고&lt;/strong&gt; : GET을 통한 요청은 쿼리 문자열 매개 변수 만 사용할 수 있습니다. 아래 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0001998e0bdef58f01b9c91f784804a24cb51eb3" translate="yes" xml:space="preserve">
          <source>Used to update or create an object in OpenTSDB using the content body from the request. Will use a formatter to parse the content body</source>
          <target state="translated">요청의 컨텐츠 본문을 사용하여 OpenTSDB에서 오브젝트를 업데이트하거나 작성하는 데 사용됩니다. 포맷터를 사용하여 컨텐츠 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="bec249e659662f7d5947bf09a1ea1d4a552885b0" translate="yes" xml:space="preserve">
          <source>User Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955e61c4b54b25cea569ccd1cd940c5fb31b3c07" translate="yes" xml:space="preserve">
          <source>User Guide: CLI Tools</source>
          <target state="translated">사용자 안내서 : CLI 도구</target>
        </trans-unit>
        <trans-unit id="6116fdb4f95e1db34ca319f9fbd0dcc6f44e6a83" translate="yes" xml:space="preserve">
          <source>User Guide: GUI</source>
          <target state="translated">사용자 안내서 : GUI</target>
        </trans-unit>
        <trans-unit id="f100edabcc385a5a77e1583f7f67e983511e64b0" translate="yes" xml:space="preserve">
          <source>User Guide: Querying or Reading Data</source>
          <target state="translated">사용자 안내서 : 데이터 조회 또는 읽기</target>
        </trans-unit>
        <trans-unit id="af33bc99d6f7c86cdb26f88a939e207bccabd558" translate="yes" xml:space="preserve">
          <source>User Guide: Storage</source>
          <target state="translated">사용자 안내서 : 스토리지</target>
        </trans-unit>
        <trans-unit id="360751baad77a78b3942433ccf2631a3004e902d" translate="yes" xml:space="preserve">
          <source>User Guide: Utilities</source>
          <target state="translated">사용자 안내서 : 유틸리티</target>
        </trans-unit>
        <trans-unit id="47a5fdfb4caff6a0ef66e67942a892980a681ece" translate="yes" xml:space="preserve">
          <source>User Guide: Writing Data</source>
          <target state="translated">사용자 안내서 : 데이터 작성</target>
        </trans-unit>
        <trans-unit id="0f6565f0a0dc77432c23144a7ed97d2c2a617525" translate="yes" xml:space="preserve">
          <source>Users can add, edit and delete annotations via the Http API at &lt;code&gt;../api_http/annotation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;../api_http/annotation&lt;/code&gt; 의 Http API를 통해 주석을 추가, 편집 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a67ba8fd3a2de0f48e4a4945a68e05232da1127d" translate="yes" xml:space="preserve">
          <source>Using down sampling we can cleanup the previous graph to arrive at something much more useful:</source>
          <target state="translated">다운 샘플링을 사용하면 이전 그래프를 정리하여 훨씬 더 유용한 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eeab03d439e1d9633f9594cc9c120763dda7475" translate="yes" xml:space="preserve">
          <source>Using rollups and pre-aggregates require some analysis and a choice between various trade-offs. Since some OpenTSDB users already have means in place for calculating this kind of data, we simply provide the API to store and query. However here are some tips on how to compute these on your own.</source>
          <target state="translated">롤업 및 사전 집계를 사용하려면 약간의 분석과 다양한 트레이드 오프 중에서 선택해야합니다. 일부 OpenTSDB 사용자는 이미 이러한 종류의 데이터를 계산할 수단이 있으므로 저장 및 쿼리 할 API를 제공하기 만하면됩니다. 그러나 여기에 스스로 계산하는 방법에 대한 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e84e40800d75197197a3cc68e6dfce2260cbaeb" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--full-scan&lt;/code&gt; flag, the entire OpenTSDB &lt;code&gt;tsdb&lt;/code&gt; data table will be scanned. By default the utility will launch &lt;code&gt;2 x CPU core&lt;/code&gt; threads for optimal performance. Data is stored with the metric UID as the start of each row key so the utility will determine the maximum metric UID and split up the main data table equally among threads. If your data is distributed among metrics fairly evenly, then each thread should complete in roughly the same amount of time. However some metrics usually have more data or time series than others so these threads may be running much longer than others. Future updates to OpenTSDB will be able to divy up the workload in a more efficient manner.</source>
          <target state="translated">은 Using &lt;code&gt;--full-scan&lt;/code&gt; 플래그를, 전체 OpenTSDB의 &lt;code&gt;tsdb&lt;/code&gt; 데이터 테이블 스캔 할 것입니다. 기본적으로 유틸리티는 최적의 성능을 위해 &lt;code&gt;2 x CPU core&lt;/code&gt; 스레드를 시작 합니다. 데이터는 각 행 키의 시작으로 메트릭 UID와 함께 저장되므로 유틸리티는 최대 메트릭 UID를 결정하고 기본 데이터 테이블을 스레드간에 균등하게 분할합니다. 데이터가 측정 항목간에 상당히 균등하게 분배되면 각 스레드는 대략 같은 시간 내에 완료되어야합니다. 그러나 일부 메트릭에는 일반적으로 다른 메트릭보다 많은 데이터 또는 시계열이 있으므로 이러한 스레드가 다른 스레드보다 훨씬 오래 실행될 수 있습니다. 향후 OpenTSDB 업데이트는보다 효율적인 방식으로 워크로드를 분산시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c02e9f523f3e75838914c64307790f5b450bce" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;DELETE&lt;/code&gt; method will remove a rule from a tree. A successful deletion will respond with a &lt;code&gt;204&lt;/code&gt; status code and no content body. If the rule did not exist, a &lt;code&gt;404&lt;/code&gt; error will be returned.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 방법을 사용하면 트리에서 규칙이 제거됩니다. 성공적으로 삭제되면 &lt;code&gt;204&lt;/code&gt; 상태 코드로 응답하며 컨텐츠 본문은 없습니다. 규칙이 존재하지 않으면 &lt;code&gt;404&lt;/code&gt; 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="81f769c31fbe1979b47e3d5884c1b5ca03bdcfab" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;DELETE&lt;/code&gt; method will remove all rules from a tree. A successful deletion will respond with a &lt;code&gt;204&lt;/code&gt; status code and no content body. If the tree did not exist, a &lt;code&gt;404&lt;/code&gt; error will be returned.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 방법을 사용하면 트리에서 모든 규칙이 제거됩니다. 성공적으로 삭제되면 &lt;code&gt;204&lt;/code&gt; 상태 코드로 응답하며 컨텐츠 본문은 없습니다. 트리가 존재하지 않으면 &lt;code&gt;404&lt;/code&gt; 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b26af793f872504a81d53e941fc79c1ec865a0ee" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;DELETE&lt;/code&gt; method will remove only collisions, not matched entries and branches for the given tree from storage. This endpoint starts a delete. Because the delete can take some time, the endpoint will return a successful 204 response without data if the delete completed. If the tree was not found, it will return a 404. If you want to delete the tree definition itself, you can supply the &lt;code&gt;defintion&lt;/code&gt; flag in the query string with a value of &lt;code&gt;true&lt;/code&gt; and the tree and rule definitions will be removed as well.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 방법을 사용하면 지정된 트리에 대해 일치하는 항목과 분기가 아닌 충돌 만 저장소에서 제거됩니다. 이 엔드 포인트는 삭제를 시작합니다. 삭제에 시간이 걸릴 수 있으므로 엔드 포인트는 삭제가 완료되면 데이터없이 성공적인 204 응답을 리턴합니다. 트리를 찾을 수 없으면 404를 반환합니다. 트리 정의 자체를 삭제하려는 경우 쿼리 문자열에서 &lt;code&gt;defintion&lt;/code&gt; 플래그를 &lt;code&gt;true&lt;/code&gt; 값으로 제공 하면 트리 및 규칙 정의도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e060c6a169bbd5cc7d8f67f11885eea850a73cc4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;POST&lt;/code&gt; or &lt;code&gt;PUT&lt;/code&gt; methods, you can create a new rule or edit an existing rule. New rules require a &lt;code&gt;type&lt;/code&gt; value. Existing trees require a valid &lt;code&gt;treeId&lt;/code&gt; ID and any fields that require modification. A successful request will return the modified rule object. Note that if a rule exists at the given level and order, any changes will be merged with or overwrite the existing rule.</source>
          <target state="translated">은 Using &lt;code&gt;POST&lt;/code&gt; 나 &lt;code&gt;PUT&lt;/code&gt; 방법을 새 규칙 또는 편집 기존 규칙을 만들 수 있습니다. 새로운 규칙에는 &lt;code&gt;type&lt;/code&gt; 값이 필요 합니다. 기존 트리에는 유효한 &lt;code&gt;treeId&lt;/code&gt; ID와 수정이 필요한 모든 필드가 필요합니다. 요청이 성공하면 수정 된 규칙 객체가 반환됩니다. 규칙이 지정된 수준과 순서로 존재하면 변경 사항이 기존 규칙과 병합되거나 기존 규칙을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="a5d62ecf5accd6b4f56e139e4bd5594c2887feb2" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;POST&lt;/code&gt; or &lt;code&gt;PUT&lt;/code&gt; methods, you can create a new tree or edit most of the fields for an existing tree. New trees require a &lt;code&gt;name&lt;/code&gt; value and for the &lt;code&gt;treeId' value to be empty. Existing trees require a valid ``treeId&lt;/code&gt; ID and any fields that require modification. A successful request will return the modified tree object.</source>
          <target state="translated">은 Using &lt;code&gt;POST&lt;/code&gt; 나 &lt;code&gt;PUT&lt;/code&gt; 방법을 기존 트리에 대한 새 트리 또는 편집 필드의 대부분을 만들 수 있습니다. 새 트리에는 &lt;code&gt;name&lt;/code&gt; 값이 필요 하고 &lt;code&gt;treeId' value to be empty. Existing trees require a valid ``treeId&lt;/code&gt; ID 및 수정이 필요한 모든 필드가 필요합니다. 요청이 성공하면 수정 된 트리 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc32e8ff10fcc6d195c144a9f9e2bab905e251e5" translate="yes" xml:space="preserve">
          <source>Usually aggregating all of the time series for a metric isn't particularly useful. Instead we can drill down a little by filtering for time series that contain a specific tagk/tagv pair combination. Simply put the pair in curly braces:</source>
          <target state="translated">일반적으로 지표에 대한 모든 시계열을 집계하는 것은 특히 유용하지 않습니다. 대신 특정 tagk / tagv 쌍 조합을 포함하는 시계열을 필터링하여 조금 드릴 다운 할 수 있습니다. 쌍을 중괄호로 묶기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="0f8ca40d96a452e4180cc0d6220a7564a5e3380c" translate="yes" xml:space="preserve">
          <source>Value Too Long Or Short</source>
          <target state="translated">너무 길거나 짧은 값</target>
        </trans-unit>
        <trans-unit id="225bed68259ba651e2d6c1d327a5491b646a2a9a" translate="yes" xml:space="preserve">
          <source>Values in the POST query &lt;code&gt;tags&lt;/code&gt; map and the &lt;em&gt;group by&lt;/em&gt; curly brace of URI queries are automatically converted to filters to provide backwards compatibility with existing systems. The auto conversions include:</source>
          <target state="translated">POST 쿼리 &lt;code&gt;tags&lt;/code&gt; 맵과 URI 쿼리 중괄호로 묶은 &lt;em&gt;그룹의&lt;/em&gt; 값은 필터로 자동 변환되어 기존 시스템과의 하위 호환성을 제공합니다. 자동 변환에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9704bafa7ca1f65bf78a2d7c4af65d12ed352bb9" translate="yes" xml:space="preserve">
          <source>Variable Length Encoding - Use less storage space for smaller integer values</source>
          <target state="translated">가변 길이 인코딩-더 작은 정수 값에 더 적은 저장 공간 사용</target>
        </trans-unit>
        <trans-unit id="e6a656cb32022254fe55cc6243baea743427517a" translate="yes" xml:space="preserve">
          <source>Variable-Length Encoding</source>
          <target state="translated">가변 길이 인코딩</target>
        </trans-unit>
        <trans-unit id="6bec7b100d00a8c0be466bd00f9d09aaf0240be3" translate="yes" xml:space="preserve">
          <source>Variables need descriptive names &lt;code&gt;like_this&lt;/code&gt; (instead of the typical Java style of &lt;code&gt;likeThis&lt;/code&gt;)</source>
          <target state="translated">변수 설명 이름을 필요 &lt;code&gt;like_this&lt;/code&gt; (대신의 전형적인 자바 스타일의 &lt;code&gt;likeThis&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="33817a63b651d4a84e7a5d740d58bef5f67a6a2a" translate="yes" xml:space="preserve">
          <source>Verb</source>
          <target state="translated">Verb</target>
        </trans-unit>
        <trans-unit id="7802ad32f0ce92df70c7ae50d17c25d1ff11aa8c" translate="yes" xml:space="preserve">
          <source>Verbs</source>
          <target state="translated">Verbs</target>
        </trans-unit>
        <trans-unit id="174d53e18dd86a2b98465bd93b7e2a7071028b04" translate="yes" xml:space="preserve">
          <source>Version - Displays version information about the TSD</source>
          <target state="translated">버전-TSD에 대한 버전 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="152a325cb9dde54e5d5c0bfad81b6b60308e2bb2" translate="yes" xml:space="preserve">
          <source>Version 1.0 of OpenTSDB included a rudimentary HTTP API that allowed for querying data, suggesting metric or tag names and a means of accessing static files. The 1.0 API has been carried over to 2.0 for backwards compatibility though most of the calls have been deprecated. Below is a list of the different endpoints and how to use them.</source>
          <target state="translated">OpenTSDB 버전 1.0에는 메트릭 또는 태그 이름을 제안하고 정적 파일에 액세스하는 방법을 제안하는 데이터 쿼리를 허용하는 기초적인 HTTP API가 포함되었습니다. 대부분의 호출은 더 이상 사용되지 않지만 1.0 API는 이전 버전과의 호환성을 위해 2.0으로 이전되었습니다. 아래는 다양한 엔드 포인트 목록과 사용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="835a37d5985d765c753e15d8f664fe8a438884b5" translate="yes" xml:space="preserve">
          <source>Version 1.X to 2.x</source>
          <target state="translated">버전 1.X ~ 2.x</target>
        </trans-unit>
        <trans-unit id="c697058b729e0797b0d7ec09e225f99744db8420" translate="yes" xml:space="preserve">
          <source>Version 3.0 may discard these deprecated methods so if you are developing tools against the HTTP API, make sure to use the 2.0 version.</source>
          <target state="translated">버전 3.0은 이러한 사용되지 않는 메소드를 버릴 수 있으므로 HTTP API에 대해 도구를 개발하는 경우 2.0 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="775b477f882de4305a43dd316c67cb826bb73391" translate="yes" xml:space="preserve">
          <source>Watch your JVM heap usage when enabling any of the real-time meta data settings.</source>
          <target state="translated">실시간 메타 데이터 설정을 활성화 할 때 JVM 힙 사용량을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7a1779a979cc8742130b8b722998971bd414106f" translate="yes" xml:space="preserve">
          <source>We found an ID of 42 for metrics but the max ID is only 41! Future IDs may be double-assigned!</source>
          <target state="translated">측정 항목의 ID는 42이지만 최대 ID는 41입니다! 미래의 ID는 이중으로 할당 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="9d050bac18e579e8de2a962599f4d131c6f6ed92" translate="yes" xml:space="preserve">
          <source>We'll make a quick detour here to talk about the actual graph section. Below the query building area is a spot where details about query results are displayed as well as the actual graph.</source>
          <target state="translated">실제 그래프 섹션에 대해 이야기하기 위해 여기서 우회합니다. 쿼리 작성 영역 아래에는 실제 그래프뿐만 아니라 쿼리 결과에 대한 세부 정보가 표시되는 지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c345da795a9556bc36b310cd688ccc41bccbd52e" translate="yes" xml:space="preserve">
          <source>Webservers usually have many files so we could have a &lt;code&gt;tagk&lt;/code&gt; of &lt;code&gt;file&lt;/code&gt; to arrive at &lt;code&gt;file=logo.jpg&lt;/code&gt; or &lt;code&gt;file=index.php&lt;/code&gt;</source>
          <target state="translated">우리가 가질 수 있도록 웹 서버는 일반적으로 많은 파일이 &lt;code&gt;tagk&lt;/code&gt; 의 &lt;code&gt;file&lt;/code&gt; 에 도달하기 위해 &lt;code&gt;file=logo.jpg&lt;/code&gt; 또는 &lt;code&gt;file=index.php&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92c1691245ecf75a0486528560dc971aba0c7613" translate="yes" xml:space="preserve">
          <source>Welcome to OpenTSDB 2.3, the scalable, distributed time series database. We recommend that you start with the &lt;a href=&quot;user_guide/index&quot;&gt;&lt;em&gt;User Guide&lt;/em&gt;&lt;/a&gt; then test your understanding with an &lt;a href=&quot;installation&quot;&gt;&lt;em&gt;Installation&lt;/em&gt;&lt;/a&gt; and read on the &lt;a href=&quot;api_http/index&quot;&gt;&lt;em&gt;HTTP API&lt;/em&gt;&lt;/a&gt; if you need to develop against it.</source>
          <target state="translated">확장 가능한 분산 시계열 데이터베이스 인 OpenTSDB 2.3에 오신 것을 환영합니다. &lt;a href=&quot;user_guide/index&quot;&gt;&lt;em&gt;사용자 안내서&lt;/em&gt;&lt;/a&gt; 부터 시작 하여 &lt;a href=&quot;installation&quot;&gt;&lt;em&gt;설치에&lt;/em&gt;&lt;/a&gt; 대한 이해를 테스트 하고 &lt;a href=&quot;api_http/index&quot;&gt;&lt;em&gt;HTTP API&lt;/em&gt;&lt;/a&gt; 에 대해 개발해야하는 경우 &lt;em&gt;HTTP API를&lt;/em&gt; 읽어 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9f707dd631007e6f00674e6df653a50cb3b80c8e" translate="yes" xml:space="preserve">
          <source>What does the script do? If you're not a big fan of shell and awk scripting, it may not be obvious how this works. But it's simple. The &lt;code&gt;set -e&lt;/code&gt; command simply instructs bash to exit with an error if any of the commands fail. This simplifies error handling. The script then enters an infinite loop. In this loop, we query MySQL to retrieve 2 of its status variables:</source>
          <target state="translated">스크립트는 무엇을합니까? 쉘과 awk 스크립팅을 좋아하지 않는다면 어떻게 작동하는지 명확하지 않을 수 있습니다. 그러나 간단합니다. &lt;code&gt;set -e&lt;/code&gt; 명령 중 하나가 실패하는 경우 명령은 단순히 오류와 출구 bash에 지시합니다. 이것은 오류 처리를 단순화합니다. 그런 다음 스크립트는 무한 루프로 들어갑니다. 이 루프에서 MySQL에 쿼리하여 상태 변수 2 개를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6ed3699ff66978ac502b6045e640df53c3a9561a" translate="yes" xml:space="preserve">
          <source>What if you want a specific timeseries? You have to include every tag and coresponding value.</source>
          <target state="translated">특정 시계열을 원하면 어떻게합니까? 모든 태그와 핵심 응답 값을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5327b36090577d46345fd56199590737f1090b4" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New</source>
          <target state="translated">새로운 소식</target>
        </trans-unit>
        <trans-unit id="a2efe202772f684e9538c631455d896fa7d07336" translate="yes" xml:space="preserve">
          <source>What's New</source>
          <target state="translated">새로운 소식</target>
        </trans-unit>
        <trans-unit id="4cde1cbe4dd3701ac40deff8cf090d85f5d496fd" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict matching&lt;/em&gt; is enabled for a tree, a TSMeta must match on a rule on every level of the rule set in order to be added to the tree. If one or more levels fail to match, the TSUID will not be added. Similar to &lt;em&gt;collisions&lt;/em&gt;, a not matched entry will be recorded for every TSUID that failed to be written to the tree. The entry will contain the TSUID and a brief message about which rule and level failed to match.</source>
          <target state="translated">때 &lt;em&gt;엄격한 일치가&lt;/em&gt; 나무를 사용할 수있다하는 TSMeta 트리에 추가하기 위해 규칙 세트의 모든 수준에서 규칙에 일치해야합니다. 하나 이상의 레벨이 일치하지 않으면 TSUID가 추가되지 않습니다. &lt;em&gt;충돌&lt;/em&gt; 과 유사하게 , 트리에 쓰지 못한 모든 TSUID에 대해 일치하지 않는 항목이 기록됩니다. 이 항목에는 TSUID와 일치하지 않은 규칙 및 수준에 대한 간단한 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c2abdabf275377290315e15b4d52f5d153f27b13" translate="yes" xml:space="preserve">
          <source>When OpenTSDB is calculating an aggregation it starts at the first data point found for any series, in this case it will be the data for &lt;code&gt;B&lt;/code&gt; at &lt;code&gt;ts0&lt;/code&gt;. We request a value for &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;ts0&lt;/code&gt; but there isn't any data there. We know that there is data for &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;ts0+10s&lt;/code&gt; but since we don't have any value before that, we can't make a guess as to what it would be. Thus we simply return the value for &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">OpenTSDB는 집계를 계산할 때 모든 시리즈에 대해 발견 된 첫 번째 데이터 포인트에서 시작합니다.이 경우 &lt;code&gt;ts0&lt;/code&gt; 의 &lt;code&gt;B&lt;/code&gt; 에 대한 데이터가됩니다 . &lt;code&gt;ts0&lt;/code&gt; 에서 &lt;code&gt;A&lt;/code&gt; 에 대한 값을 요청 하지만 거기에 데이터가 없습니다. 우리 는 &lt;code&gt;ts0+10s&lt;/code&gt; 에 &lt;code&gt;A&lt;/code&gt; 에 대한 데이터가 있다는 것을 알고 있지만 그 전에는 아무런 가치가 없기 때문에 그것이 무엇인지 추측 할 수는 없습니다. 따라서 우리는 단순히 &lt;code&gt;B&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2bff2db77a7dc18ca13d3f20a4ff0b0c0a401243" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; request arrives with the &lt;code&gt;Origin&lt;/code&gt; header set to a valid domain name, the server will compare the domain against the configured list. If the domain appears in the list or the wild card was set, the server will add the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; and &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; headers to the response after processing is complete. The allowed methods will always be &lt;code&gt;GET, POST, PUT, DELETE&lt;/code&gt;. It does not change per end point. If the request is a CORS preflight, i.e. the &lt;code&gt;OPTION&lt;/code&gt; method is used, the response will be the same but with an empty content body and a 200 status code.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; 헤더가 유효한 도메인 이름으로 설정된 상태 에서 &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 요청이 도착 하면 서버는 도메인을 구성된 목록과 비교합니다. 도메인이 목록에 나타나거나 와일드 카드가 설정된 경우, 서버는 처리가 완료된 후 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 및 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 헤더를 응답에 추가합니다. 허용되는 메소드는 항상 &lt;code&gt;GET, POST, PUT, DELETE&lt;/code&gt; 입니다. 종점마다 변경되지 않습니다. 요청이 CORS 프리 플라이트 인 경우, 즉 &lt;code&gt;OPTION&lt;/code&gt; 메소드가 사용되면 응답은 동일하지만 컨텐츠 본문이 비어 있고 상태 코드가 200입니다.</target>
        </trans-unit>
        <trans-unit id="c90483ecb75f33c66504aec57044b74b4ddb9446" translate="yes" xml:space="preserve">
          <source>When a data point is written to OpenTSDB, the row key is formatted as &lt;code&gt;&amp;lt;metric_UID&amp;gt;&amp;lt;timestamp&amp;gt;&amp;lt;tagk1_UID&amp;gt;&amp;lt;tagv1_UID&amp;gt;[...&amp;lt;tagkN_UID&amp;gt;&amp;lt;tagvN_UID&amp;gt;]&lt;/code&gt;. By simply dropping the timestamp from the row key, we have a long array of UIDs that combined, form a unique timeseries ID. Encoding the bytes as a hex string will give us a useful TSUID that can be passed around various API calls. Thus from our UID example above where each metric, tag name and value has a UID of 1, our TSUID, encoded as a hexadecimal string, would be &lt;code&gt;000001000001000001&lt;/code&gt;.</source>
          <target state="translated">데이터 포인트가 OpenTSDB에 기록되면 행 키는 &lt;code&gt;&amp;lt;metric_UID&amp;gt;&amp;lt;timestamp&amp;gt;&amp;lt;tagk1_UID&amp;gt;&amp;lt;tagv1_UID&amp;gt;[...&amp;lt;tagkN_UID&amp;gt;&amp;lt;tagvN_UID&amp;gt;]&lt;/code&gt; 로 형식화 됩니다. 행 키에서 타임 스탬프를 삭제함으로써 고유 한 시계열 ID를 구성하는 긴 UID 배열이 만들어집니다. 바이트를 16 진 문자열로 인코딩하면 다양한 API 호출 주위에 전달할 수있는 유용한 TSUID가 제공됩니다. 따라서 각 메트릭, 태그 이름 및 값의 UID가 1 인 위의 UID 예에서 16 진 문자열로 인코딩 된 TSUID는 &lt;code&gt;000001000001000001&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3fab944abf51c879bc1b01b659f566bb9c864d1" translate="yes" xml:space="preserve">
          <source>When a request for &lt;code&gt;GET /s/queryui.nocache.js&lt;/code&gt; comes in, for instance, the file &lt;code&gt;${staticroot}/queryui.nocache.js&lt;/code&gt; is sent to the browser.</source>
          <target state="translated">예를 들어 &lt;code&gt;GET /s/queryui.nocache.js&lt;/code&gt; 에 대한 요청이 들어 오면 &lt;code&gt;${staticroot}/queryui.nocache.js&lt;/code&gt; 파일 이 브라우저로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3eb795a0996434169e7936c08d9e37cf097ed440" translate="yes" xml:space="preserve">
          <source>When aggregating multiple series OpenTSDB generally performs linear interpolation when a series is missing a value at a timestamp present in one or more other series. Some aggregators substitute specific values such as zero, min or max values. With fill policies you can modify aggregation behavior by flagging a missing value as a NaN or a scalar such as zero. When a NaN is emitted for a series, it is skipped for all calculations. For example, if a query asks for the average of a metric and one or more series are missing values, substituting a 0 would drive down the average and lerping introduces non-extant values. However with NaNs we can flag the value as missing and skip it in the calculation.</source>
          <target state="translated">여러 계열을 집계 할 때 OpenTSDB는 일반적으로 계열에 하나 이상의 다른 계열에있는 타임 스탬프에 값이없는 경우 선형 보간을 수행합니다. 일부 집계 기는 0, 최소 또는 최대 값과 같은 특정 값을 대체합니다. 채우기 정책을 사용하면 결 측값을 NaN 또는 0과 같은 스칼라로 플래그를 지정하여 집계 동작을 수정할 수 있습니다. NaN이 계열에 대해 방출되면 모든 계산에서 생략됩니다. 예를 들어 쿼리에서 메트릭의 평균을 요구하고 하나 이상의 계열에 결 측값이있는 경우 0을 대체하면 평균이 낮아지고 lerping은 비 존재 값을 유발합니다. 그러나 NaN을 사용하면 값을 누락 된 것으로 표시하고 계산에서 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f307b85a8de7fbc9cab4207a27f8e15baa9065a" translate="yes" xml:space="preserve">
          <source>When all values are assigned, the endpoint returns a 200 status code but if any value failed assignment, it will return a 400.</source>
          <target state="translated">모든 값이 할당되면 끝점은 200 상태 코드를 반환하지만 값이 할당에 실패하면 400을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b7042cd70af33c4def83a3a4348fcca04bdeace" translate="yes" xml:space="preserve">
          <source>When building a graph, if an error occurs, a message will appear above the menu. Click on the arrow to expand the message and determine what the error was.</source>
          <target state="translated">그래프를 작성할 때 오류가 발생하면 메뉴 위에 메시지가 나타납니다. 화살표를 클릭하여 메시지를 펼치고 오류가 무엇인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="3d44031378cc2fb1b7ef9801c12128a9c51a9f44" translate="yes" xml:space="preserve">
          <source>When combining configuration files and command line arguments, the order of processing is as follows:</source>
          <target state="translated">구성 파일과 명령 행 인수를 결합 할 때 처리 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f928ec1bfcd516d4fbf90e96fd29ce7a6b8f8717" translate="yes" xml:space="preserve">
          <source>When converting human readable timestamps, OpenTSDB will convert to UTC from the timezone configured on the system where the TSD is running. While many servers are configured to UTC, and we recommend that all systems running OpenTSDB use UTC, sometimes a local timezone is used.</source>
          <target state="translated">사람이 읽을 수있는 타임 스탬프를 변환 할 때 OpenTSDB는 TSD가 실행중인 시스템에 구성된 시간대에서 UTC로 변환됩니다. 많은 서버가 UTC로 구성되어 있지만 OpenTSDB를 실행하는 모든 시스템에서 UTC를 사용하는 것이 좋지만 때로는 현지 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="edf539127020f4b17e6954b4a5f7859e3b6d89e6" translate="yes" xml:space="preserve">
          <source>When creating a tree it will have the &lt;code&gt;enabled&lt;/code&gt; field set to &lt;code&gt;false&lt;/code&gt; by default. After creating a tree you should add rules then use the &lt;code&gt;tree/test&lt;/code&gt; endpoint with a few TSUIDs to make sure the resulting tree will be what you expected. After you have verified the results, you can set the &lt;code&gt;enabled&lt;/code&gt; field to &lt;code&gt;true&lt;/code&gt; and new TSMeta objects or a tree synchronization will start to populate branches.</source>
          <target state="translated">트리를 만들 때 &lt;code&gt;enabled&lt;/code&gt; 필드 는 기본적 으로 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다. 트리를 생성 한 후에는 규칙을 추가 한 다음 몇 가지 TSUID와 함께 &lt;code&gt;tree/test&lt;/code&gt; 엔드 포인트를 사용하여 결과 트리가 예상 한 것인지 확인하십시오. 결과를 확인한 후, &lt;code&gt;enabled&lt;/code&gt; 필드를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 새 TSMeta 오브젝트 또는 트리 동기화가 분기를 채우기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="00ad345ce54d744e0d4346875a589bbcf877ecd3" translate="yes" xml:space="preserve">
          <source>When creating, modifying or deleting annotations, all changes will be propagated to the search plugin if configured.</source>
          <target state="translated">주석을 작성, 수정 또는 삭제할 때 모든 변경 사항이 구성된 경우 검색 플러그인으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="8810e9d5143441e456baf25d86b384e054aa61ef" translate="yes" xml:space="preserve">
          <source>When editing rules, it may happen that some levels or orders are skipped or left empty. In these situations, processing simply skips the empty locations. You should do your best to keep things organized properly but the rule processor is a little forgiving.</source>
          <target state="translated">규칙을 편집 할 때 일부 레벨 또는 주문을 건너 뛰거나 비워 둘 수 있습니다. 이러한 상황에서 처리는 단순히 빈 위치를 건너 뜁니다. 일을 제대로 정리하기 위해 최선을 다해야하지만 규칙 처리기는 약간 용서해야합니다.</target>
        </trans-unit>
        <trans-unit id="768400609d1a6d467fe36b04fe25126e2c1edd8c" translate="yes" xml:space="preserve">
          <source>When generating random IDs, TSDB will try up to 10 times to assign a UID without a collision. Thus as the number of assigned metrics increases so too will the number of collisions and the likely hood that a data point may be dropped due to retries. If you enable random IDs and keep adding more metrics then you may want to increase the number of bytes on metric UIDs. Note that the UID change is not backwards compatible so you have to create a new table and migrate your old data.</source>
          <target state="translated">임의의 ID를 생성 할 때 TSDB는 충돌없이 UID를 할당하기 위해 최대 10 번 시도합니다. 따라서 할당 된 메트릭 수가 증가하면 재시 도로 인해 충돌 횟수와 데이터 포인트가 삭제 될 가능성이 높아집니다. 임의의 ID를 사용 설정하고 메트릭을 계속 추가하면 메트릭 UID의 바이트 수를 늘릴 수 있습니다. UID 변경은 이전 버전과 호환되지 않으므로 새 테이블을 작성하고 이전 데이터를 마이그레이션해야합니다.</target>
        </trans-unit>
        <trans-unit id="786fb35a9c614a66abb9ebbc3b2fcec92eae77db" translate="yes" xml:space="preserve">
          <source>When it comes to timeseries data, there are lots of terms tossed about that can lead to some confusion. This page is a sort of glossary that helps to define words related to the use of OpenTSDB.</source>
          <target state="translated">시계열 데이터에 관해서는 혼란 스러울 수있는 많은 용어가 있습니다. 이 페이지는 OpenTSDB 사용과 관련된 단어를 정의하는 데 도움이되는 일종의 용어집입니다.</target>
        </trans-unit>
        <trans-unit id="589290daaeac9fa4a537718e78a27d42e565c382" translate="yes" xml:space="preserve">
          <source>When making a query string request, multiple names for a given type can be supplied in a comma separated fashion. E.g. &lt;code&gt;metric=sys.cpu.0,sys.cpu.1,sys.cpu.2,sys.cpu.3&lt;/code&gt;. Naming conventions apply: see _______.</source>
          <target state="translated">쿼리 문자열 요청을 할 때 주어진 유형에 대한 여러 이름을 쉼표로 구분하여 제공 할 수 있습니다. 예 : &lt;code&gt;metric=sys.cpu.0,sys.cpu.1,sys.cpu.2,sys.cpu.3&lt;/code&gt; . 명명 규칙이 적용됩니다. _______를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db46ecc896bc829a3ede30c6a67d1a838ab0ecce" translate="yes" xml:space="preserve">
          <source>When passing rate options in a query string, the options must be enclosed in curly braces. For example: &lt;code&gt;m=sum:rate{counter,,1000}:if.octets.in&lt;/code&gt;. If you wish to use the default &lt;code&gt;counterMax&lt;/code&gt; but do want to supply a &lt;code&gt;resetValue&lt;/code&gt;, you must add two commas as in the previous example. Additional fields in the &lt;code&gt;rateOptions&lt;/code&gt; object include the following:</source>
          <target state="translated">쿼리 문자열에 속도 옵션을 전달할 때는 옵션을 중괄호로 묶어야합니다. 예를 들어 &lt;code&gt;m=sum:rate{counter,,1000}:if.octets.in&lt;/code&gt; . 기본 사용하려면 &lt;code&gt;counterMax&lt;/code&gt; 을 하지만 공급 싶어 &lt;code&gt;resetValue&lt;/code&gt; 을 , 당신은 앞의 예에서와 같이 두 개의 쉼표를 추가해야합니다. &lt;code&gt;rateOptions&lt;/code&gt; 객체의 추가 필드 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d5fba73f279100bd3a481913b14403bacac26b84" translate="yes" xml:space="preserve">
          <source>When performing an aggregation, what happens if the time stamps of the data points for each time series fail to line up? Say we record the temperature every 5 minutes in different regions around the world. A sensor in Paris may send a temperature of &lt;code&gt;27c&lt;/code&gt; at &lt;code&gt;1356998400&lt;/code&gt;. Then a sensor in San Francisco may send a value of &lt;code&gt;18c&lt;/code&gt; at &lt;code&gt;1356998430&lt;/code&gt;, 30 seconds later. Antarctica may report &lt;code&gt;-29c&lt;/code&gt; at &lt;code&gt;1356998529&lt;/code&gt;. If we run a query requesting the average temperature, we want all of the data points averaged together into a single point. This is where &lt;strong&gt;interpolation&lt;/strong&gt; comes into play. See &lt;a href=&quot;aggregators&quot;&gt;&lt;em&gt;Aggregators&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">집계를 수행 할 때 각 시계열에 대한 데이터 포인트의 타임 스탬프가 정렬되지 않으면 어떻게됩니까? 전 세계 다른 지역에서 5 분마다 온도를 기록한다고 가정 해 보겠습니다. 파리의 센서는 &lt;code&gt;1356998400&lt;/code&gt; 에서 &lt;code&gt;27c&lt;/code&gt; 의 온도를 보낼 수 있습니다 . 이어서 샌프란시스코 센서의 값을 전송할 수있다 &lt;code&gt;18c&lt;/code&gt; 에 &lt;code&gt;1356998430&lt;/code&gt; 30초 이상. 남극 대륙은 &lt;code&gt;-29c&lt;/code&gt; 에서 &lt;code&gt;1356998529&lt;/code&gt; 보고 할 수 있습니다 . 평균 온도를 요청하는 쿼리를 실행하면 모든 데이터 포인트가 단일 포인트로 평균화되기를 원합니다. &lt;strong&gt;보간&lt;/strong&gt; 이 시작 되는 곳 입니다. 자세한 내용은 &lt;a href=&quot;aggregators&quot;&gt;&lt;em&gt;수집기&lt;/em&gt;&lt;/a&gt; 를 참조하십시오.&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="397054dbf8d59aec11d0f6f634cc9306b25819e0" translate="yes" xml:space="preserve">
          <source>When processing a TSMeta, if the resulting leaf would overwrite an existing leaf with a different TSUID, a collision will be recorded. This endpoint allows retreiving a list of the TSUIDs that were not included in a tree due to collisions. It is useful for debugging in that if you find a TSUID in this list, you can pass it through the &lt;code&gt;/tree/test&lt;/code&gt; endpoint to get details on why the collision occurred.</source>
          <target state="translated">TSMeta를 처리 할 때 결과 리프가 다른 TSUID로 기존 리프를 겹쳐 쓰면 충돌이 기록됩니다. 이 엔드 포인트는 충돌로 인해 트리에 포함되지 않은 TSUID 목록을 검색 할 수 있습니다. 이 목록에서 TSUID를 찾으면 &lt;code&gt;/tree/test&lt;/code&gt; 엔드 포인트를 통해 충돌을 일으킨 원인에 대한 세부 정보를 전달할 수 있다는 점에서 디버깅에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="43f7e3102f2d64532ed98f3f277346a42abfa591" translate="yes" xml:space="preserve">
          <source>When processing a TSMeta, if the tree has &lt;code&gt;strictMatch&lt;/code&gt; enabled and the meta fails to match on a rule in any level of the set, a &lt;em&gt;not matched&lt;/em&gt; entry will be recorded. This endpoint allows for retrieving the list of TSUIDs that failed to match a rule set. It is useful for debugging in that if you find a TSUID in this list, you can pass it through the &lt;code&gt;/tree/test&lt;/code&gt; endpoint to get details on why the meta failed to match.</source>
          <target state="translated">TSMeta를 처리 할 때 트리에서 &lt;code&gt;strictMatch&lt;/code&gt; 가 사용 가능하고 메타가 세트의 임의 레벨의 규칙에서 &lt;em&gt;일치하지 않으면 일치하지 않는&lt;/em&gt; 항목이 기록됩니다. 이 엔드 포인트는 규칙 세트와 일치하지 않은 TSUID 목록을 검색 할 수 있습니다. 이 목록에서 TSUID를 찾으면 &lt;code&gt;/tree/test&lt;/code&gt; 엔드 포인트를 통해 메타를 일치시키지 못한 이유에 대한 세부 정보를 얻을 수 있다는 점에서 디버깅에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb36a57fc88a67adf5ad26a06aec101b87e6899c" translate="yes" xml:space="preserve">
          <source>When rollups are enabled and you request a downsampler with the &lt;code&gt;avg&lt;/code&gt; function from OpenTSDB, the TSD will scan storage for &lt;code&gt;SUM&lt;/code&gt; and &lt;code&gt;COUNT&lt;/code&gt; values. Then while iterating over the data it will accurately compute the average.</source>
          <target state="translated">롤업이 활성화되고 OpenTSDB 에서 &lt;code&gt;avg&lt;/code&gt; 기능을 사용하여 다운 샘플러를 요청 하면 TSD는 저장소에서 &lt;code&gt;SUM&lt;/code&gt; 및 &lt;code&gt;COUNT&lt;/code&gt; 값 을 검색 합니다. 그런 다음 데이터를 반복하면서 평균을 정확하게 계산합니다.</target>
        </trans-unit>
        <trans-unit id="37ede39a087efd7518931b086a9dab4a33170282" translate="yes" xml:space="preserve">
          <source>When set, deletes all but the most recently written data point when resolving duplicates. If the config value &lt;code&gt;tsd.storage.fix_duplicates&lt;/code&gt; is set to true, then the latest data point will be kept regardless of this value.</source>
          <target state="translated">설정하면 중복을 해결할 때 가장 최근에 작성된 데이터 포인트를 제외한 모든 데이터 포인트가 삭제됩니다. 구성 값 &lt;code&gt;tsd.storage.fix_duplicates&lt;/code&gt; 가 true로 설정되면이 값에 관계없이 최신 데이터 포인트가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="97127e549ccb13a79e2f4409316d1dec6b12ef6e" translate="yes" xml:space="preserve">
          <source>When starting a TSD or CLI tool, a number of errors may prevent a successful launch due to plugin issues. If something happens you should see an exception in the logs related to a plugin. Some things to troubleshoot include:</source>
          <target state="translated">TSD 또는 CLI 도구를 시작할 때 여러 가지 오류로 인해 플러그인 문제로 인해 성공적으로 시작하지 못할 수 있습니다. 문제가 발생하면 플러그인과 관련된 로그에 예외가 표시됩니다. 다음과 같은 문제를 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="fca9aca34575fa85650c8b6b24cb0c1cbb36090c" translate="yes" xml:space="preserve">
          <source>When storing rollups, it's best to avoid functions such as &lt;strong&gt;average&lt;/strong&gt;, &lt;strong&gt;median&lt;/strong&gt; or &lt;strong&gt;deviation&lt;/strong&gt;. When performing further downsampling or grouping aggregations, such values become meaningless. Instead it's much better to always store the &lt;strong&gt;sum&lt;/strong&gt; and &lt;strong&gt;count&lt;/strong&gt; from which, at least, the &lt;strong&gt;average&lt;/strong&gt; can be computed at query time. For more information, see the section below.</source>
          <target state="translated">롤업을 저장할 때 &lt;strong&gt;average&lt;/strong&gt; , &lt;strong&gt;median&lt;/strong&gt; 또는 &lt;strong&gt;deviation&lt;/strong&gt; 과 같은 기능을 피하는 것이 가장 좋습니다 . 추가 다운 샘플링 또는 그룹화 집계를 수행 할 때 이러한 값은 의미가 없습니다. 대신 훨씬 더 항상 저장에의 &lt;strong&gt;합계를&lt;/strong&gt; 하고 &lt;strong&gt;계산&lt;/strong&gt; 최소한의,있는 &lt;strong&gt;평균은&lt;/strong&gt; 쿼리 시간에 계산 될 수있다. 자세한 내용은 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4af2402471f4ef066b11aaa2c4169a62abd87658" translate="yes" xml:space="preserve">
          <source>When submitting a JSON query to OpenTSDB 2.2 or later, use either &lt;code&gt;tags&lt;/code&gt; OR &lt;code&gt;filters&lt;/code&gt;. Only one will take effect and the order is indeterminate as the JSON parser may deserialize one before the other. We recommend using filters for all future queries.</source>
          <target state="translated">JSON 쿼리를 OpenTSDB 2.2 이상에 제출할 때 &lt;code&gt;tags&lt;/code&gt; 또는 &lt;code&gt;filters&lt;/code&gt; 중 하나를 사용하십시오 . JSON 구문 분석기가 순서대로 직렬화를 해제 할 수 있으므로 하나만 적용되며 순서는 불확실합니다. 향후 모든 쿼리에 필터를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6043e0afa414523f13d52ceb29591765986e78b4" translate="yes" xml:space="preserve">
          <source>When supplying a &lt;code&gt;separator&lt;/code&gt; or a &lt;code&gt;regex&lt;/code&gt; value, you must supply a valid regular expression. For separators, the most common use is to split dotted metrics into branches. E.g. you may want &quot;sys.cpu.0.user&quot; to be split into &quot;sys&quot;, &quot;cpu&quot;, &quot;0&quot; and &quot;user&quot; branches. You cannot supply just a &quot;.&quot; for the separator value as that will not match properly. Instead, escape the period via &quot;.&quot;. Note that if you are supplying JSON via a POST request, you must escape the backslash as well and supply &quot;\.&quot;. GET request responses will escape all backslashes.</source>
          <target state="translated">&lt;code&gt;separator&lt;/code&gt; 나 &lt;code&gt;regex&lt;/code&gt; 값을 제공 할 때 유효한 정규식을 제공해야합니다. 구분 기호의 경우 가장 일반적인 용도는 점선 메트릭을 분기로 분할하는 것입니다. 예를 들어 &quot;sys.cpu.0.user&quot;를 &quot;sys&quot;, &quot;cpu&quot;, &quot;0&quot;및 &quot;user&quot;분기로 분할 할 수 있습니다. &quot;.&quot;만 제공 할 수 없습니다. 구분 기호 값이 제대로 일치하지 않습니다. 대신 &quot;.&quot;를 통해 마침표를 이스케이프하십시오. POST 요청을 통해 JSON을 제공하는 경우 백 슬래시를 이스케이프 처리하고 &quot;\&quot;를 제공해야합니다. GET 요청 응답은 모든 백 슬래시를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="77b516fb80a54d0ce36c259cedbe5128a56b9e78" translate="yes" xml:space="preserve">
          <source>When using HTTP for puts, you may need to enable support for chunks if your HTTP client automatically breaks large requests into smaller packets. For example, CURL will break up messages larger than 2 or 3 data points and by default, OpenTSDB disables chunk support. Enable it by setting &lt;code&gt;tsd.http.request.enable_chunked&lt;/code&gt; to true in the config file.</source>
          <target state="translated">넣기에 HTTP를 사용할 때 HTTP 클라이언트가 자동으로 큰 요청을 작은 패킷으로 나누는 경우 청크 지원을 활성화해야 할 수 있습니다. 예를 들어 CURL은 2 개 또는 3 개의 데이터 포인트보다 큰 메시지를 분할하며 기본적으로 OpenTSDB는 청크 지원을 비활성화합니다. 구성 파일에서 &lt;code&gt;tsd.http.request.enable_chunked&lt;/code&gt; 를 true 로 설정하여 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="16edde5b640ab67d81700527469fa623a2baec01" translate="yes" xml:space="preserve">
          <source>When using the CliQuery tool, you must use the format that separates the date from the time with a dash. This is because the command line is split on spaces, so if you put a space in the timestamp, it will fail to parse execute properly.</source>
          <target state="translated">CliQuery 도구를 사용할 때는 날짜와 시간을 구분하는 형식을 대시로 사용해야합니다. 명령 행이 공백으로 분할 되었기 때문에 시간 소인에 공백을 넣으면 실행 구문 분석이 제대로 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31611eb440a6bdaa3e0dfeba7d497e00b321d461" translate="yes" xml:space="preserve">
          <source>When using the built-in UI, graphs are cached on disk for 60 seconds. If auto-refresh is enabled and the default of 15s is used, the cached graph will be displayed until the 60 seconds have elapsed. If you have higher resolution data coming in and want to bypass the cache, simply append &lt;code&gt;&amp;amp;nocache&lt;/code&gt; to the GUI URL.</source>
          <target state="translated">내장 UI를 사용하면 그래프가 60 초 동안 디스크에 캐시됩니다. 자동 새로 고침이 활성화되고 기본값 인 15 초가 사용되면 60 초가 경과 할 때까지 캐시 된 그래프가 표시됩니다. 더 높은 해상도의 데이터가 들어오고 캐시를 우회 하려면 GUI URL에 &lt;code&gt;&amp;amp;nocache&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1ab6ba7bb84ba6584c2480a222d126dbf0c85ed" translate="yes" xml:space="preserve">
          <source>When writing to the telnet interface, timestamps may optionally be written in the form &lt;code&gt;1364410924.250&lt;/code&gt;, where three digits representing the milliseconds are placed after a period. Timestamps sent to the &lt;code&gt;/api/put&lt;/code&gt; endpoint over HTTP &lt;em&gt;must&lt;/em&gt; be integers and may not have periods. Data with millisecond resolution can only be extracted via the &lt;code&gt;/api/query&lt;/code&gt; endpoint or CLI command at this time. See &lt;code&gt;query/index&lt;/code&gt; for details.</source>
          <target state="translated">텔넷 인터페이스에 쓸 때 타임 스탬프는 선택적으로 &lt;code&gt;1364410924.250&lt;/code&gt; 형식으로 작성 될 수 있으며 , 여기서 밀리 초를 나타내는 3 자리 숫자는 마침표 뒤에 배치됩니다. HTTP &lt;em&gt;를&lt;/em&gt; 통해 &lt;code&gt;/api/put&lt;/code&gt; 엔드 포인트로 전송 된 시간 소인은 정수 &lt;em&gt;여야&lt;/em&gt; 하며 마침표가 &lt;em&gt;없어야합니다&lt;/em&gt; . 현재 밀리 초 해상도의 데이터는 &lt;code&gt;/api/query&lt;/code&gt; 엔드 포인트 또는 CLI 명령을 통해서만 추출 할 수 있습니다 . 자세한 내용은 &lt;code&gt;query/index&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6dfed8adaf8fe61a9a599411f87a9d33b813a69" translate="yes" xml:space="preserve">
          <source>When you create a new tree, it will be disabled by default so TSMeta objects will not be processed through the rule set. This is so you have time to configure the rule set and test it to verify that the tree would be built as you expect it to.</source>
          <target state="translated">새 트리를 작성하면 기본적으로 사용 불가능하게되어 TSMeta 오브젝트가 룰 세트를 통해 처리되지 않습니다. 이제 규칙 세트를 구성하고 테스트하여 예상대로 트리가 빌드되는지 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb089def2b4d5e5bc0e3bcc4ca78ecee3266e1c0" translate="yes" xml:space="preserve">
          <source>When you design your naming schema, keep these suggestions in mind:</source>
          <target state="translated">명명 스키마를 디자인 할 때는 다음 제안 사항을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="ab61fbb775962c4046d49dd5034b3dcb8d13991f" translate="yes" xml:space="preserve">
          <source>When you query OpenTSDB, here's what happens under the hood.</source>
          <target state="translated">OpenTSDB를 쿼리하면 다음과 같은 상황이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18723fce86eabf30e06c61bf94652b6169134bf6" translate="yes" xml:space="preserve">
          <source>Whenever a new UIDMeta object is created or modified, it will be pushed to the Search plugin if a plugin has been configured and loaded. For information about UID values, see &lt;a href=&quot;uids&quot;&gt;&lt;em&gt;UIDs and TSUIDs&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 UIDMeta 객체가 생성 또는 수정 될 때마다 플러그인이 구성되고로드 된 경우 검색 플러그인으로 푸시됩니다. UID 값에 대한 정보는 UID &lt;a href=&quot;uids&quot;&gt;&lt;em&gt;및 TSUID를&lt;/em&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81732fdbcbb0e58074d7496ed19db5c64eee7db8" translate="yes" xml:space="preserve">
          <source>Whenever the aggregation calculations are taking place, overall write throughput of the raw data can be affected.</source>
          <target state="translated">집계 계산이 수행 될 때마다 원시 데이터의 전체 쓰기 처리량이 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac495d484d102835eb66994a9d41d51a062bfc9d" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;&amp;lt;list of class files&amp;gt;&lt;/code&gt; includes the services file that you created above. E.g.:</source>
          <target state="translated">어디 &lt;code&gt;&amp;lt;list of class files&amp;gt;&lt;/code&gt; 위에서 만든 서비스 파일이 포함되어 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f230fa1239f7e7d698c3d89d81f5a1e0c225ec0d" translate="yes" xml:space="preserve">
          <source>Where the aggregator is &lt;code&gt;SUM&lt;/code&gt;, the offset is &lt;code&gt;1&lt;/code&gt; and the length is 1 byte of an integer value.</source>
          <target state="translated">어 그리 게이터가 &lt;code&gt;SUM&lt;/code&gt; 인 경우 오프셋은 &lt;code&gt;1&lt;/code&gt; 이고 길이는 1 바이트의 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2b843fc9afdf09ccda360b4d66a3051b0b5d180a" translate="yes" xml:space="preserve">
          <source>Whether or not TSMeta should be processed through the tree. By default this is set to &lt;code&gt;false&lt;/code&gt; so that you can setup rules and test some objects before building branches.</source>
          <target state="translated">TSMeta가 트리를 통해 처리되어야하는지 여부입니다. 기본적으로 이는 분기를 구축하기 전에 규칙을 설정하고 일부 개체를 테스트 할 수 있도록 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="92fb82f13005f01b45888694358987792184c447" translate="yes" xml:space="preserve">
          <source>Whether or not a data point with a new metric will assign a UID to the metric. When false, a data point with a metric that is not in the database will be rejected and an exception will be thrown.</source>
          <target state="translated">새 지표가있는 데이터 요소가 지표에 UID를 할당할지 여부입니다. false 인 경우 데이터베이스에없는 메트릭을 가진 데이터 포인트가 거부되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e056e3395384a9fa3fc1fab7c41a0a24f281c400" translate="yes" xml:space="preserve">
          <source>Whether or not a data point with a new tag name will assign a UID to the tagk. When false, a data point with a tag name that is not in the database will be rejected and an exception will be thrown.</source>
          <target state="translated">새로운 태그 이름을 가진 데이터 포인트가 tagk에 UID를 할당할지 여부. false 인 경우, 데이터베이스에없는 태그 이름을 가진 데이터 포인트가 거부되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69590288c499f79f4ddfbd4b4f825175abd36436" translate="yes" xml:space="preserve">
          <source>Whether or not a data point with a new tag value will assign a UID to the tagv. When false, a data point with a tag value that is not in the database will be rejected and an exception will be thrown.</source>
          <target state="translated">새로운 태그 값을 가진 데이터 포인트가 tagv에 UID를 할당할지 여부. False 인 경우 데이터베이스에없는 태그 값을 가진 데이터 포인트가 거부되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="992728e06d868d95054e870177650f497add931f" translate="yes" xml:space="preserve">
          <source>Whether or not collisions and 'not matched' TSUIDs should be recorded. This can create very wide rows.</source>
          <target state="translated">충돌 및 '일치하지 않은'TSUID를 기록해야하는지 여부 이것은 매우 넓은 행을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5798958fb653f100730bd334766bb03f9ac1b80" translate="yes" xml:space="preserve">
          <source>Whether or not global annotations should be deleted for the range</source>
          <target state="translated">범위에 대한 글로벌 주석을 삭제해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="229c50b46a62cd66fb2d49e3cb01e191f0992fcb" translate="yes" xml:space="preserve">
          <source>Whether or not the FQDN should be returned with statistics requests. The default stats are returned with &lt;code&gt;host=&amp;lt;hostname&amp;gt;&lt;/code&gt; which is not guaranteed to perform a lookup and return the FQDN. Setting this to true will perform a name lookup and return the FQDN if found, otherwise it may return the IP. The stats output should be &lt;code&gt;fqdn=&amp;lt;hostname&amp;gt;&lt;/code&gt;</source>
          <target state="translated">통계 요청과 함께 FQDN을 반환해야하는지 여부입니다. 기본 통계는 &lt;code&gt;host=&amp;lt;hostname&amp;gt;&lt;/code&gt; 과 함께 반환되며 조회를 수행하고 FQDN을 반환하지는 않습니다. 이 값을 true로 설정하면 이름 조회가 수행되고 FQDN (있는 경우)이 반환되고 그렇지 않으면 IP가 반환 될 수 있습니다. 통계 출력은 &lt;code&gt;fqdn=&amp;lt;hostname&amp;gt;&lt;/code&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2928ab81f443be9b1b71644ec4608e9c573c27d" translate="yes" xml:space="preserve">
          <source>Whether or not the TSD will allow writing data points. Must be either &lt;code&gt;rw&lt;/code&gt; to allow writing data or &lt;code&gt;ro&lt;/code&gt; to block data point writes. Note that meta data such as UIDs can still be written/modified.</source>
          <target state="translated">TSD가 데이터 포인트 쓰기를 허용할지 여부. 데이터 쓰기를 허용하려면 &lt;code&gt;rw&lt;/code&gt; 이거나 데이터 포인트 쓰기를 차단하려면 &lt;code&gt;ro&lt;/code&gt; 여야합니다 . UID와 같은 메타 데이터는 여전히 작성 / 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fee3723508088846b43df6181f7405721462e7" translate="yes" xml:space="preserve">
          <source>Whether or not the data should be converted into deltas before returning. This is useful if the metric is a continuously incrementing counter and you want to view the rate of change between data points.</source>
          <target state="translated">데이터를 반환하기 전에 델타로 변환해야하는지 여부입니다. 메트릭이 지속적으로 증가하는 카운터이고 데이터 포인트 간 변경 비율을 보려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0118d8b3a3584c6e4155bc69a80184d499723c8d" translate="yes" xml:space="preserve">
          <source>Whether or not the query should retrieve global annotations for the requested timespan</source>
          <target state="translated">쿼리가 요청 된 시간 범위에 대한 전역 주석을 검색해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="1fe9abad84a3dfa1c653d18579f3e28a939a0b6c" translate="yes" xml:space="preserve">
          <source>Whether or not the query was successfully sent to the client. It may be blocked due to a socket exception or full write buffer.</source>
          <target state="translated">쿼리가 클라이언트에 성공적으로 전송되었는지 여부 소켓 예외 또는 전체 쓰기 버퍼로 인해 차단되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63bf620a6bac1c701e8a3350b730ddc5e886663e" translate="yes" xml:space="preserve">
          <source>Whether or not the region client is marked as dead due to a connection close event (such as region server going down)</source>
          <target state="translated">연결 종료 이벤트 (예 : 리젼 서버 작동 중지)로 인해 리젼 클라이언트가 사용 불능으로 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="58c2e3bc7c9769928d70c818854c84167125cbf9" translate="yes" xml:space="preserve">
          <source>Whether or not the thread was interrupted</source>
          <target state="translated">스레드가 중단되었는지 여부</target>
        </trans-unit>
        <trans-unit id="52d9d9344fc19152ac718aeae419205bb5b5e1a9" translate="yes" xml:space="preserve">
          <source>Whether or not the underlying data is a monotonically increasing counter that may roll over</source>
          <target state="translated">기본 데이터가 롤오버 될 수있는 단조 증가 카운터인지 여부</target>
        </trans-unit>
        <trans-unit id="6bd265c20aa0e541f52665acf21a016df5a4f491" translate="yes" xml:space="preserve">
          <source>Whether or not timeseries should be included in the tree if they fail to match one or more rule levels.</source>
          <target state="translated">시계열이 하나 이상의 규칙 수준과 일치하지 않는 경우 트리에 시계열을 포함할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a38d1e886b3a0876c0d8d6a3965dfffc564d03f8" translate="yes" xml:space="preserve">
          <source>Whether or not to accept the last written value when parsing data points with duplicate timestamps. When enabled in conjunction with compactions, a compacted column will be written with the latest data points.</source>
          <target state="translated">중복 타임 스탬프가있는 데이터 포인트를 구문 분석 할 때 마지막으로 쓴 값을 수락할지 여부입니다. 압축과 함께 사용하면 압축 된 열이 최신 데이터 포인트로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d4e16d1303427a7f9243648ff8539ea549453345" translate="yes" xml:space="preserve">
          <source>Whether or not to allow deleting data points from storage during query time.</source>
          <target state="translated">쿼리 시간 동안 스토리지에서 데이터 포인트를 삭제할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="14adbb1ae45de1920f0e6015fd10faff41ef753b" translate="yes" xml:space="preserve">
          <source>Whether or not to allow keep-alive connections</source>
          <target state="translated">연결 유지 연결 허용 여부</target>
        </trans-unit>
        <trans-unit id="d7c9aa1d9063e688e7f64084ab3dc5f6fb13ee96" translate="yes" xml:space="preserve">
          <source>Whether or not to allow out-of-order values when bulk importing data from a text file.</source>
          <target state="translated">텍스트 파일에서 데이터를 대량으로 가져올 때 순서가 잘못된 값을 허용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="50d232cdc861ea15bab031fed84c857bcc7528e7" translate="yes" xml:space="preserve">
          <source>Whether or not to allow reuse of the bound port within Netty</source>
          <target state="translated">Netty 내에서 바인드 된 포트의 재사용 허용 여부</target>
        </trans-unit>
        <trans-unit id="cab348117bd5116da679356c083ee4c1f4563518" translate="yes" xml:space="preserve">
          <source>Whether or not to allow simultaneous duplicate queries from the same host. If disabled, a second query that comes in matching one already running will receive an exception.</source>
          <target state="translated">동일한 호스트에서 동시 복제 쿼리를 허용할지 여부 비활성화하면 이미 실행중인 쿼리와 일치하는 두 번째 쿼리에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3699f371db34e670f733070f507531cce9d0329" translate="yes" xml:space="preserve">
          <source>Whether or not to allow the 2.x HTTP API to function. When disabled, calls to endpoints such as &lt;code&gt;/api/query&lt;/code&gt; or &lt;code&gt;/api/suggest&lt;/code&gt; will return a 404.</source>
          <target state="translated">2.x HTTP API의 기능 허용 여부입니다. 비활성화하면 &lt;code&gt;/api/query&lt;/code&gt; 또는 &lt;code&gt;/api/suggest&lt;/code&gt; 와 같은 끝점을 호출 하면 404가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="861b570620c672f04a4d9a00d6bb19c27bc6f631" translate="yes" xml:space="preserve">
          <source>Whether or not to allow the built-in GUI and legacy HTTP API to function. When disabled, calls to the root endpoint or other such as &lt;code&gt;/logs&lt;/code&gt; or &lt;code&gt;/suggest&lt;/code&gt; will return a 404.</source>
          <target state="translated">내장 GUI 및 레거시 HTTP API가 작동 할 수 있는지 여부 비활성화하면 루트 끝점 또는 &lt;code&gt;/logs&lt;/code&gt; 또는 &lt;code&gt;/suggest&lt;/code&gt; 와 같은 다른 호출 이 404를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11dc9c2008b7e65e407d0319bfe5be6d94901c90" translate="yes" xml:space="preserve">
          <source>Whether or not to append data to columns when writing data points instead of creating new columns for each value. Avoids the need for compactions after each hour but can use more resources on HBase.</source>
          <target state="translated">각 값에 대해 새 열을 만드는 대신 데이터 포인트를 쓸 때 열에 데이터를 추가할지 여부입니다. 매시간마다 압축이 필요하지 않지만 HBase에서 더 많은 리소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9eb649157c779d2f1be59a4b5e9d01fe3bd5610" translate="yes" xml:space="preserve">
          <source>Whether or not to block storing derived aggregations such as &lt;code&gt;AVG&lt;/code&gt; and &lt;code&gt;DEV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AVG&lt;/code&gt; 및 &lt;code&gt;DEV&lt;/code&gt; 와 같은 파생 집계 저장을 차단할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="28505634d988f522cda1f2ed1ad967e5bec3a6ef" translate="yes" xml:space="preserve">
          <source>Whether or not to calculate all metrics as rates, i.e. value per second. This is computed before expressions.</source>
          <target state="translated">모든 메트릭을 비율 (예 : 초당 값)로 계산할지 여부 이것은 식 전에 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="529e0d79e9369608c2cef416f47003b954d34d4f" translate="yes" xml:space="preserve">
          <source>Whether or not to continue querying when the query includes a tag value that hasn't been assigned a UID yet and may not exist.</source>
          <target state="translated">쿼리에 아직 UID가 할당되지 않았거나 존재하지 않을 수있는 태그 값이 포함 된 경우 쿼리를 계속할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f603ab5b2d072b6ec003ccba408fd0cc5347af12" translate="yes" xml:space="preserve">
          <source>Whether or not to disable TCP buffering before sending data</source>
          <target state="translated">데이터를 보내기 전에 TCP 버퍼링을 비활성화할지 여부</target>
        </trans-unit>
        <trans-unit id="ee79332a44bff878821ca044799116d906e8a21a" translate="yes" xml:space="preserve">
          <source>Whether or not to enable a real time publishing plugin. If true, you must supply a valid &lt;code&gt;tsd.rtpublisher.plugin&lt;/code&gt; class name</source>
          <target state="translated">실시간 게시 플러그인 사용 여부입니다. true 인 경우 유효한 &lt;code&gt;tsd.rtpublisher.plugin&lt;/code&gt; 클래스 이름을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3570c0200db9b03cd1b58be33bc3c54c79e56305" translate="yes" xml:space="preserve">
          <source>Whether or not to enable compactions</source>
          <target state="translated">압축을 사용할지 여부</target>
        </trans-unit>
        <trans-unit id="fc6aa451ecce15df3191daa4943a8e35935b25ae" translate="yes" xml:space="preserve">
          <source>Whether or not to enable incoming chunk support for the HTTP RPC</source>
          <target state="translated">HTTP RPC에 대한 수신 청크 지원 사용 가능 여부</target>
        </trans-unit>
        <trans-unit id="6014803f3002387d0fa5c501a9f8500e82d6b195" translate="yes" xml:space="preserve">
          <source>Whether or not to enable processing new/edited TSMeta through tree rule sets</source>
          <target state="translated">트리 규칙 세트를 통해 새 / 편집 된 TSMeta를 처리 할 수 ​​있는지 여부</target>
        </trans-unit>
        <trans-unit id="6dca489c3a6f58cfe6b3b5440f7c5a016d0939f8" translate="yes" xml:space="preserve">
          <source>Whether or not to enable real-time TSMeta object creation. See &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;Metadata&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">실시간 TSMeta 오브젝트 작성 사용 여부입니다. &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;메타 데이터&lt;/em&gt;&lt;/a&gt; 참조&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b136963a4e2f95c8ae4a78ea4cad024cd3b68b9d" translate="yes" xml:space="preserve">
          <source>Whether or not to enable real-time UIDMeta object creation. See &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;Metadata&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">실시간 UIDMeta 객체 생성 활성화 여부. &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;메타 데이터&lt;/em&gt;&lt;/a&gt; 참조&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74cda710fa010befe002b614be668bc760b34b82" translate="yes" xml:space="preserve">
          <source>Whether or not to enable rollup and pre-aggregation storage and writing.</source>
          <target state="translated">롤업 및 사전 집계 저장 및 쓰기 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3770e3dfd0a3a6a122871666b527d79bb420b8d8" translate="yes" xml:space="preserve">
          <source>Whether or not to enable search functionality. If true, you must supply a valid &lt;code&gt;tsd.search.plugin&lt;/code&gt; class name</source>
          <target state="translated">검색 기능을 사용할지 여부입니다. true 인 경우 유효한 &lt;code&gt;tsd.search.plugin&lt;/code&gt; 클래스 이름을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccb52c1230617405dbda44c3f4e4ebdbec08df85" translate="yes" xml:space="preserve">
          <source>Whether or not to enable the FuzzyRowFilter for HBase when making queries using the &lt;code&gt;explicitTags&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;explicitTags&lt;/code&gt; 플래그를 사용하여 쿼리 할 때 HBase에 FuzzyRowFilter를 사용할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="04ee4c881001a62a42410ef19ec64e29a7744237" translate="yes" xml:space="preserve">
          <source>Whether or not to enable the configured storage exception handler plugin.</source>
          <target state="translated">구성된 스토리지 예외 핸들러 플러그인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="353a4b3a7f49373563d3ff5bf56ce4a04ecb88cc" translate="yes" xml:space="preserve">
          <source>Whether or not to enable tracking of TSUIDs by incrementing a counter every time a data point is recorded. See &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;Metadata&lt;/em&gt;&lt;/a&gt; (Overrides &quot;tsd.core.meta.enable_tsuid_tracking&quot;)</source>
          <target state="translated">데이터 포인트가 기록 될 때마다 카운터를 증가시켜 TSUID 추적을 활성화할지 여부. &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;메타 데이터&lt;/em&gt;&lt;/a&gt; 참조 ( &quot;tsd.core.meta.enable_tsuid_tracking 재정의&quot;)</target>
        </trans-unit>
        <trans-unit id="85d686533fa75c2faa6b9a109cfc87778be32557" translate="yes" xml:space="preserve">
          <source>Whether or not to enable tracking of TSUIDs by storing a &lt;code&gt;1&lt;/code&gt; with the current timestamp every time a data point is recorded. See &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;Metadata&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">데이터 포인트가 기록 될 때마다 현재 타임 스탬프와 함께 &lt;code&gt;1&lt;/code&gt; 을 저장하여 TSUID를 추적 할 수 있는지 여부 입니다. &lt;a href=&quot;metadata&quot;&gt;&lt;em&gt;메타 데이터&lt;/em&gt;&lt;/a&gt; 참조&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef950eef44232380b37e62fb66d6d8bb0332e746" translate="yes" xml:space="preserve">
          <source>Whether or not to group results by the tag values matching this filter. E.g. grouping by host will return one result per host. Not grouping by host would aggregate (using the aggregation function) all results for the metric into one series</source>
          <target state="translated">이 필터와 일치하는 태그 값으로 결과를 그룹화할지 여부입니다. 예를 들어 호스트별로 그룹화하면 호스트 당 하나의 결과가 반환됩니다. 호스트별로 그룹화하지 않으면 (집계 함수를 사용하여) 메트릭의 모든 결과를 하나의 시리즈로 집계합니다.</target>
        </trans-unit>
        <trans-unit id="7d27dd5444bfaafa3253a98d8da289ad0552a83d" translate="yes" xml:space="preserve">
          <source>Whether or not to group the results by each value matched by the filter. By default all values matching the filter will be aggregated into a single series.</source>
          <target state="translated">필터와 일치하는 각 값으로 결과를 그룹화할지 여부입니다. 기본적으로 필터와 일치하는 모든 값은 단일 계열로 집계됩니다.</target>
        </trans-unit>
        <trans-unit id="492ca99e5ba6f54f5b39a49e12336d4e5aaaba4f" translate="yes" xml:space="preserve">
          <source>Whether or not to include the tag keys that were aggregated out of a series in the join key</source>
          <target state="translated">결합 키에 시리즈에서 집계 된 태그 키를 포함 시킬지 여부</target>
        </trans-unit>
        <trans-unit id="18618b4ac750344ceb6449519bfc260ad6ae3e02" translate="yes" xml:space="preserve">
          <source>Whether or not to output data point timestamps in milliseconds or seconds. The msResolution flag is recommended. If this flag is not provided and there are multiple data points within a second, those data points will be down sampled using the query's aggregation function.</source>
          <target state="translated">데이터 포인트 타임 스탬프를 밀리 초 또는 초 단위로 출력할지 여부입니다. msResolution 플래그가 권장됩니다. 이 플래그가 제공되지 않고 1 초 내에 여러 데이터 포인트가있는 경우 해당 데이터 포인트는 쿼리 집계 함수를 사용하여 다운 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="1d3b182cf801a8fa5aa134a6332ab1a9d00b0bb9" translate="yes" xml:space="preserve">
          <source>Whether or not to output the TSUIDs associated with timeseries in the results. If multiple time series were aggregated into one set, multiple TSUIDs will be returned in a sorted manner</source>
          <target state="translated">결과에서 시계열과 관련된 TSUID를 출력할지 여부입니다. 여러 시계열이 하나의 집합으로 집계 된 경우 여러 TSUID가 정렬 된 방식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcecf625115a1ee0c49c9bbc0a204603ba7d158" translate="yes" xml:space="preserve">
          <source>Whether or not to prefetch the regions for the TSDB tables before starting the network interface. This can improve performance.</source>
          <target state="translated">네트워크 인터페이스를 시작하기 전에 TSDB 테이블의 리젼을 프리 페치할지 여부입니다. 이것은 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9169a8d667557fe4766713119f1851bdcdc8a4da" translate="yes" xml:space="preserve">
          <source>Whether or not to randomly assign UIDs to new metrics as they are created</source>
          <target state="translated">UID가 생성 될 때 UID를 임의로 새 메트릭에 할당할지 여부</target>
        </trans-unit>
        <trans-unit id="4321164037f2a96b4af57bf981c0594d141a47aa" translate="yes" xml:space="preserve">
          <source>Whether or not to re-write appended data point columns at query time when the columns contain duplicate or out of order data.</source>
          <target state="translated">열에 중복되거나 잘못된 데이터가 포함 된 쿼리시 추가 된 데이터 포인트 열을 다시 쓸지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2f4d9fd0af4d3d9448cb2213a6b3873c430464c4" translate="yes" xml:space="preserve">
          <source>Whether or not to resolve the TSUIDs of results to their metric and tag names.</source>
          <target state="translated">결과의 TSUID를 메트릭 및 태그 이름으로 해결할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="550637fe92e6d005e19797a19b147482eea521cd" translate="yes" xml:space="preserve">
          <source>Whether or not to return annotations with a query. The default is to return annotations for the requested timespan but this flag can disable the return. This affects both local and global notes and overrides &lt;code&gt;globalAnnotations&lt;/code&gt;</source>
          <target state="translated">쿼리로 주석을 반환할지 여부입니다. 기본값은 요청 된 시간 범위에 대한 주석을 반환하는 것이지만이 플래그는 반환을 비활성화 할 수 있습니다. 이것은 로컬 및 글로벌 노트 모두에 영향을 미치며 &lt;code&gt;globalAnnotations&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="80f3b2631904fccb383e285afe53c2c068dd85ff" translate="yes" xml:space="preserve">
          <source>Whether or not to return detailed information</source>
          <target state="translated">자세한 정보를 반환할지 여부</target>
        </trans-unit>
        <trans-unit id="6384effdcffc75246c202722da4fb8f4dfb3c295" translate="yes" xml:space="preserve">
          <source>Whether or not to return errors to the Telnet style socket when writing data via &lt;code&gt;put&lt;/code&gt; or &lt;code&gt;rollup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 또는 &lt;code&gt;rollup&lt;/code&gt; 통해 데이터를 쓸 때 Telnet 스타일 소켓에 오류를 반환할지 여부</target>
        </trans-unit>
        <trans-unit id="de6cc40adbfc2d0eac1424e10b7a379bd5863b09" translate="yes" xml:space="preserve">
          <source>Whether or not to return summary information</source>
          <target state="translated">요약 정보를 반환할지 여부</target>
        </trans-unit>
        <trans-unit id="f423af18230c493ddbf1d8030b9f7671921abe18" translate="yes" xml:space="preserve">
          <source>Whether or not to return the original sub query with the query results. If the request contains many sub queries then this is a good way to determine which results belong to which sub query. Note that in the case of a &lt;code&gt;*&lt;/code&gt; or wildcard query, this can produce a lot of duplicate output.</source>
          <target state="translated">쿼리 결과와 함께 원래 하위 쿼리를 반환할지 여부입니다. 요청에 많은 하위 쿼리가 포함되어 있으면 어떤 하위 쿼리에 속하는 결과를 결정하는 좋은 방법입니다. &lt;code&gt;*&lt;/code&gt; 또는 와일드 카드 쿼리 의 경우 많은 중복 출력이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005924bdd11a48040101cd50d8b7adc3aca9363c" translate="yes" xml:space="preserve">
          <source>Whether or not to return the stack trace with an API query response when an exception occurs.</source>
          <target state="translated">예외 발생시 API 쿼리 응답으로 스택 추적을 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="91bf2479d4ecac75d7ba89e0a43de8126e26974c" translate="yes" xml:space="preserve">
          <source>Whether or not to show a summary of timings surrounding the query in the results. This creates another object in the map that is unlike the data point objects.</source>
          <target state="translated">결과에서 쿼리를 둘러싼 타이밍 요약을 표시할지 여부입니다. 이것은 데이터 포인트 객체와는 다른 맵에 다른 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="78acf4fa58b83664fa38920de9b687457808f221" translate="yes" xml:space="preserve">
          <source>Whether or not to tag non-rolled-up and non-pre-aggregated values with the tag key configured in &lt;code&gt;tsd.rollups.agg_tag_key&lt;/code&gt; and value configured in &lt;code&gt;tsd.rollups.raw_agg_tag_value&lt;/code&gt;</source>
          <target state="translated">태그할지 여부는 비 - 권취 및 구성 태그 키 값이 비 합산 이전 &lt;code&gt;tsd.rollups.agg_tag_key&lt;/code&gt; 구성된 가치 &lt;code&gt;tsd.rollups.raw_agg_tag_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4ed931f6305a4628c38f4fe5bcdd92cbb48423d" translate="yes" xml:space="preserve">
          <source>Whether or not to use NIO or traditional blocking IO</source>
          <target state="translated">NIO 사용 여부 또는 기존 차단 IO 사용 여부</target>
        </trans-unit>
        <trans-unit id="e19ff3245d09adfc362f3921bde6c745660f0751" translate="yes" xml:space="preserve">
          <source>Whether or not to use a Google cloud service account to connect. Set this to</source>
          <target state="translated">Google 클라우드 서비스 계정을 사용하여 연결할지 여부 이것을로 설정하십시오</target>
        </trans-unit>
        <trans-unit id="835e633d8d5d5719a99ed362127b9bbdb48a1094" translate="yes" xml:space="preserve">
          <source>Whether or not to use just the tags explicitly defined in the filters when computing the join keys</source>
          <target state="translated">조인 키를 계산할 때 필터에 명시 적으로 정의 된 태그 만 사용할지 여부</target>
        </trans-unit>
        <trans-unit id="4b26d3679c68600295952bb614ef32c75add04a3" translate="yes" xml:space="preserve">
          <source>Whether or not to use the meta data table or the raw data table. The raw table will be much slower.</source>
          <target state="translated">메타 데이터 테이블 또는 원시 데이터 테이블을 사용할지 여부입니다. 원시 테이블이 훨씬 느려집니다.</target>
        </trans-unit>
        <trans-unit id="43f77819eb09770b3b432b9ffdf41d70920144be" translate="yes" xml:space="preserve">
          <source>Whether or not to wait for the data to be flushed to storage before returning the results.</source>
          <target state="translated">결과를 리턴하기 전에 데이터가 스토리지로 비워 질 때까지 대기할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e63cb314d8dc49c6f4e71ab4943364b92f4ed5d2" translate="yes" xml:space="preserve">
          <source>While 3.0 is still a ways off, we'll be pushing some of the new features into a new branch of the repo. Some are in progress and other features are planned. If you have any features that you want to see, let us know.</source>
          <target state="translated">3.0은 아직 해결되지 않았지만 새로운 기능 중 일부를 새로운 리포지토리로 끌어들일 것입니다. 일부는 진행 중이며 다른 기능은 계획되어 있습니다. 보고 싶은 기능이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="cdd2acce73b6a7906871da3ff3fff4abcc6eb515" translate="yes" xml:space="preserve">
          <source>While OpenTSDB can store data with millisecond resolution, most queries will return the data with second resolution to provide backwards compatibility for existing tools. Unless a down sampling algorithm has been specified with a query, the data will automatically be down sampled to 1 second using the same aggregation function specified in a query. This way, if multiple data points are stored for a given second, they will be aggregated and returned in a normal query correctly.</source>
          <target state="translated">OpenTSDB는 밀리 초 해상도로 데이터를 저장할 수 있지만 대부분의 쿼리는 기존 도구에 대한 하위 호환성을 제공하기 위해 데이터를 두 번째 해상도로 반환합니다. 쿼리에 다운 샘플링 알고리즘을 지정하지 않으면 쿼리에 지정된 동일한 집계 함수를 사용하여 데이터가 1 ​​초로 자동 다운 샘플링됩니다. 이런 식으로, 주어진 데이터에 대해 여러 데이터 포인트가 저장되는 경우, 해당 데이터 포인트가 집계되어 일반 쿼리에서 올바르게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8278442fcd31dc7e9149a94cebaece41bf0e3c23" translate="yes" xml:space="preserve">
          <source>While TSDB is designed to store original, full resolution data as long as there is space, queries for wide time ranges or over many tag combinations can be quite painful. Such queries can take a long time to complete or, in the worst case, kill TSDs with out-of-memory exceptions. As of OpenTSDB 2.4, a set of new APIs allow for storing and querying lower resolution data to answer such queries much quicker. This page will give you an overview of what rollups and pre-aggregates are, how they work in TSDB and how best to use them. Look in the API's section for specific implementation details.</source>
          <target state="translated">TSDB는 공간이있는 한 원래의 전체 해상도 데이터를 저장하도록 설계되었지만 넓은 시간 범위 또는 여러 태그 조합에 대한 쿼리는 상당히 고통 스러울 수 있습니다. 이러한 쿼리는 메모리 부족 예외로 TSD를 완료하거나 최악의 경우 종료하는 데 시간이 오래 걸릴 수 있습니다. OpenTSDB 2.4부터는 새로운 API 세트가 저해상도 데이터를 저장하고 쿼리하여 이러한 쿼리에 훨씬 빠르게 응답 할 수 있습니다. 이 페이지는 롤업 및 사전 집계의 개요, TSDB에서의 작동 방식 및 최상의 사용법에 대한 개요를 제공합니다. 구체적인 구현 세부 사항은 API 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c25f75fbaa41b53012f8c4d7139a4132647d2b2" translate="yes" xml:space="preserve">
          <source>While it's not strictly an error, fsck can be used to compact rows into a single column. Compacting rows saves storage space by merging multiple columns into one. This cuts down on HBase overhead. If a TSD that is configured to compact columns crashes, some rows may be missed and remain in stand-alone data point form. As compaction can consume resources, you can use fsck to compact rows when the load on your cluster is reduced.</source>
          <target state="translated">엄격하게 오류는 아니지만 fsck를 사용하여 행을 단일 열로 압축 할 수 있습니다. 압축 행은 여러 열을 하나로 병합하여 저장 공간을 절약합니다. HBase 오버 헤드가 줄어 듭니다. 열을 압축하도록 구성된 TSD가 충돌하면 일부 행이 누락되어 독립형 데이터 포인트 형식으로 유지 될 수 있습니다. 압축은 리소스를 소비 할 수 있으므로 클러스터의로드가 줄어들 때 fsck를 사용하여 행을 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842e644f281154f62e9911304df57208f08763dc" translate="yes" xml:space="preserve">
          <source>While pre-aggregates certainly help with high-cardinality metrics, users may still want to ask for wide time spans but run into slow queries. Thankfully you can roll up a pre-aggregate in the same way as raw data. Just generate the pre-aggregate, then roll it up using the information above.</source>
          <target state="translated">사전 집계는 높은 카디널리티 메트릭을 확실히 지원하지만 사용자는 여전히 넓은 시간 범위를 요청하지만 쿼리 속도가 느려질 수 있습니다. 고맙게도 원시 데이터와 같은 방식으로 사전 집계를 롤업 할 수 있습니다. 사전 집계를 생성 한 다음 위 정보를 사용하여 롤업하십시오.</target>
        </trans-unit>
        <trans-unit id="718d9b6c2ad7a30de4003fe0108a891c8d098cd2" translate="yes" xml:space="preserve">
          <source>While rollups help with wide time span queries, you can still run into query performance issues with small ranges if the metric has high cardinality (i.e. the unique number of time series for the given metric). In the example above, we have 4 web servers. But lets say that we have 10,000 servers. Fetching the sum or average of interface traffic may be fairly slow. If users are often fetching the group by (or some think of it as the spatial aggregate) of large sets like this then it makes sense to store the aggregate and query that instead, fetching &lt;em&gt;much&lt;/em&gt; less data.</source>
          <target state="translated">롤업은 광범위한 시간 범위 쿼리에 도움이되지만 메트릭에 높은 카디널리티 (예 : 주어진 메트릭에 대한 고유 한 시계열 수)가 있으면 작은 범위에서 쿼리 성능 문제가 발생할 수 있습니다. 위의 예에는 4 개의 웹 서버가 있습니다. 그러나 10,000 대의 서버가 있다고 가정 해 봅시다. 인터페이스 트래픽의 합계 또는 평균을 가져 오는 것이 상당히 느릴 수 있습니다. 사용자가 이와 같이 큰 집합을 사용하여 그룹을 가져 오는 경우 (또는 일부는 공간 집계로 생각하는 경우) 집계를 저장하고 그 대신 쿼리를 수행하는 것이 &lt;em&gt;훨씬&lt;/em&gt; 적은 데이터를 가져 오는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="37ddfa18dd5d13220375399a26cf79d75d8f65b2" translate="yes" xml:space="preserve">
          <source>While stream processing is better you still have problems to deal with such as:</source>
          <target state="translated">스트림 처리가 더 좋지만 여전히 다음과 같은 문제를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac958bf7e83608770f4fbceffd960a357bec1468" translate="yes" xml:space="preserve">
          <source>While the API does support multiple data points per request, the API will not return until every one has been processed. That means metric and tag names/values must be verified, the value parsed and the data queued for storage. If your put request has a large number of data points, it may take a long time for the API to respond, particularly if OpenTSDB has to assign UIDs to tag names or values. Therefore it is a good idea to limit the maximum number of data points per request; 50 per request is a good starting point.</source>
          <target state="translated">API는 요청 당 여러 데이터 포인트를 지원하지만 모든 데이터 포인트가 처리 될 때까지 API가 반환되지 않습니다. 즉, 메트릭 및 태그 이름 / 값을 확인하고 값을 구문 분석하고 데이터를 저장하기 위해 대기해야합니다. Put 요청에 많은 데이터 포인트가있는 경우, 특히 OpenTSDB가 UID를 태그 이름 또는 값에 할당해야하는 경우 API가 응답하는 데 시간이 오래 걸릴 수 있습니다. 따라서 요청 당 최대 데이터 포인트 수를 제한하는 것이 좋습니다. 요청 당 50은 좋은 출발점입니다.</target>
        </trans-unit>
        <trans-unit id="3aa10e0e7d1bd8c1379c2e05612180c0047d7347" translate="yes" xml:space="preserve">
          <source>While the aggregators and interval are marked as optional above, at least one of the combinations documented below must be satisfied for data to be recorded.</source>
          <target state="translated">어 그리 게이터 및 간격은 위에서 선택 사항으로 표시되지만, 데이터를 기록하려면 아래에 문서화 된 조합 중 하나 이상이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="47574020ba368affa36deadb89be0ec866451049" translate="yes" xml:space="preserve">
          <source>While the tagging system is flexible, some problems can arise if you don't understand the querying side of OpenTSDB, hence the need for some forethought. Take the example query above: &lt;code&gt;sum:sys.cpu.user{host=webserver01}&lt;/code&gt;. We recorded 64 unique time series for &lt;code&gt;webserver01&lt;/code&gt;, one time series for each of the CPU cores. When we issued that query, all of the time series for metric &lt;code&gt;sys.cpu.user&lt;/code&gt; with the tag &lt;code&gt;host=webserver01&lt;/code&gt; were retrieved, averaged, and returned as one series of numbers. Let's say the resulting average was &lt;code&gt;50&lt;/code&gt; for timestamp &lt;code&gt;1356998400&lt;/code&gt;. Now we were migrating from another system to OpenTSDB and had a process that pre-aggregated all 64 cores so that we could quickly get the average value and simply wrote a new time series &lt;code&gt;sys.cpu.user host=webserver01&lt;/code&gt;. If we run the same query, we'll get a value of &lt;code&gt;100&lt;/code&gt; at &lt;code&gt;1356998400&lt;/code&gt;. What happened? OpenTSDB aggregated all 64 time series &lt;em&gt;and&lt;/em&gt; the pre-aggregated time series to get to that 100. In storage, we would have something like this:</source>
          <target state="translated">태깅 시스템은 융통성이 있지만 OpenTSDB의 쿼리 측면을 이해하지 못하면 일부 문제가 발생할 수 있으므로 일부 예측이 필요합니다. : 위의 예제 쿼리 받아 &lt;code&gt;sum:sys.cpu.user{host=webserver01}&lt;/code&gt; . &lt;code&gt;webserver01&lt;/code&gt; 에 대해 64 개의 고유 한 시계열을 기록 했으며 각 CPU 코어에 대해 하나의 시계열을 기록했습니다 . 이 쿼리를 실행하면 &lt;code&gt;host=webserver01&lt;/code&gt; 태그가있는 메트릭 &lt;code&gt;sys.cpu.user&lt;/code&gt; 의 모든 시계열 이 검색되고 평균화되어 일련의 숫자로 반환되었습니다. 타임 스탬프 &lt;code&gt;1356998400&lt;/code&gt; 의 결과 평균이 &lt;code&gt;50&lt;/code&gt; 이라고 가정합니다.. 이제 다른 시스템에서 OpenTSDB로 마이그레이션하고 64 개의 코어를 모두 미리 집계하여 평균값을 빠르게 얻을 수 있고 새로운 시계열 &lt;code&gt;sys.cpu.user host=webserver01&lt;/code&gt; 을 작성하는 프로세스가있었습니다 . 동일한 쿼리를 실행하면 &lt;code&gt;1356998400&lt;/code&gt; 에서 &lt;code&gt;100&lt;/code&gt; 값을 얻습니다 . 어떻게 된 거예요? OpenTSDB는 모든 64 개의 시계열 &lt;em&gt;과&lt;/em&gt; 사전 집계 된 시계열을 집계하여 100 개에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="d249938ceaef496a889ce10e60cbd877db410ee3" translate="yes" xml:space="preserve">
          <source>While this TSUID format may be long and ugly, particularly with all of the 0s for early UIDs, there are a few reasons why this is useful:</source>
          <target state="translated">이 TSUID 형식은 특히 초기 UID의 경우 모든 0에서 길고 추한 형식 일 수 있지만 이것이 유용한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e87a2f2ff276e3bf5b63a6eafc384f15bc2def2b" translate="yes" xml:space="preserve">
          <source>While you can start a 2.3 TSD with the same command line options as a 1.0 TSD, we highly recommend that you create a configuration file based on the config included at &lt;code&gt;./src/opentsdb.conf&lt;/code&gt;. Or if you install from a package, you'll want to edit the included default config. The config file includes many more options than are accessible via command line and the file is shared with CLI tools. See &lt;a href=&quot;user_guide/configuration&quot;&gt;&lt;em&gt;Configuration&lt;/em&gt;&lt;/a&gt; for details.</source>
          <target state="translated">1.0 TSD와 동일한 명령 줄 옵션으로 2.3 TSD를 시작할 수 있지만 &lt;code&gt;./src/opentsdb.conf&lt;/code&gt; 에 포함 된 구성을 기반으로 구성 파일을 작성하는 것이 좋습니다 . 또는 패키지에서 설치하는 경우 포함 된 기본 구성을 편집하려고합니다. 구성 파일에는 명령 줄을 통해 액세스 할 수있는 것보다 더 많은 옵션이 포함되어 있으며 파일은 CLI 도구와 공유됩니다. 자세한 내용은 &lt;a href=&quot;user_guide/configuration&quot;&gt;&lt;em&gt;구성&lt;/em&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4cc94a04e3a2538b6d0a9fdef7b1ad136c720128" translate="yes" xml:space="preserve">
          <source>Why UIDs?</source>
          <target state="translated">왜 UID인가?</target>
        </trans-unit>
        <trans-unit id="1ea0e9037888b4eee31f78346d3a6d6c59b28ece" translate="yes" xml:space="preserve">
          <source>Why do this instead of creating another metric? Well, what if sometimes you care about plotting total HTTP hits and sometimes you care about breaking out static vs. dynamic hits? With a tag, it's easy. With this new tag, you'll see a webserver tag appear in the UI when plotting this metric. You can leave it blank and it will aggregate up both values into one plot (according to your Aggregator setting) and you can see the total hits, or you can do webserver=* to break out how much each of your static and dynamic instances are collectively doing across your web servers. You can even go deeper and specify webserver=* and host=* to see the full breakdown.</source>
          <target state="translated">다른 측정 항목을 만드는 대신 왜 이렇게합니까? 글쎄, 때로는 총 HTTP 적중을 플로팅하고 정적 및 동적 적중을 구분하는 데 관심이 있다면 어떨까요? 태그를 사용하면 쉽습니다. 이 새로운 태그를 사용하면이 메트릭을 플로팅 할 때 웹 서버 태그가 UI에 표시됩니다. 비워두면 (Aggregator 설정에 따라) 두 값을 하나의 플롯으로 집계하고 총 히트 수를 보거나 webserver = *를 수행하여 각 정적 및 동적 인스턴스의 양을 알아낼 수 있습니다 웹 서버를 통틀어 수행합니다. 더 깊이 들어가서 webserver = * 및 host = *를 지정하여 전체 분석을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9724f27e4f1a676a8791067133fc6fbe9ea83e1" translate="yes" xml:space="preserve">
          <source>Wildcard filter, effectively makes sure the tag key is present in the series</source>
          <target state="translated">와일드 카드 필터, 태그 키가 시리즈에 효과적으로 존재하는지 확인</target>
        </trans-unit>
        <trans-unit id="fa2b074f3ab603ca7204f27b34e36b238adb0d16" translate="yes" xml:space="preserve">
          <source>With 2.2 you can randomly assign UIDs to metrics for better region server write distribution. Because metric UIDs are located at the start of the row key, if a new set of busy metric are created, all writes for those metric will be on the same server until the region splits. With random UID generation enabled, the new metrics will be distributed across the key space and likely to wind up in different regions on different servers.</source>
          <target state="translated">2.2를 사용하면 더 나은 리젼 서버 쓰기 분배를 위해 임의로 UID를 메트릭에 지정할 수 있습니다. 메트릭 UID는 행 키의 시작 부분에 있기 때문에 새로운 통화 중 메트릭 집합이 생성되면 해당 메트릭에 대한 모든 쓰기는 영역이 분할 될 때까지 동일한 서버에있게됩니다. 임의의 UID 생성을 사용하면 새 지표가 주요 공간에 분산되어 다른 서버의 다른 지역에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bda2e277078ccbdb4f186d03fd10e1154d8c96a" translate="yes" xml:space="preserve">
          <source>With OpenTSDB 2.1 you can enable last-write-wins by setting the &lt;code&gt;tsd.storage.fix_duplicates&lt;/code&gt; configuration value to &lt;code&gt;true&lt;/code&gt;. With this flag enabled, at query time, the most recent value recorded will be returned instead of throwing an exception. A warning will also be written to the log file noting a duplicate was found. If compaction is also enabled, then the original compacted value will be overwritten with the latest value.</source>
          <target state="translated">OpenTSDB 2.1을 사용하면 &lt;code&gt;tsd.storage.fix_duplicates&lt;/code&gt; 구성 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 last-write-wins를 사용할 수 있습니다 . 이 플래그를 사용하면 쿼리시 예외가 발생하지 않고 가장 최근에 기록 된 값이 반환됩니다. 중복이 발견되었다는 경고도 로그 파일에 기록됩니다. 압축도 활성화 된 경우 원래 압축 된 값을 최신 값으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="00cca1944fbd7459f4bb7d581803389088c5864f" translate="yes" xml:space="preserve">
          <source>With OpenTSDB 2.1 you may supply a metric style query and, if UIDs exist for the given metric and tags, a new TS meta object will be stored. Data may be supplied via POST for the fields above as per a normal request, however the &lt;code&gt;tsuid&lt;/code&gt; field must be left empty. Additionally two query string parameters must be supplied:</source>
          <target state="translated">OpenTSDB 2.1을 사용하면 메트릭 스타일 쿼리를 제공 할 수 있으며 주어진 메트릭 및 태그에 대한 UID가 존재하면 새로운 TS 메타 객체가 저장됩니다. 정상적인 요청에 따라 위의 필드에 대해 POST를 통해 데이터를 제공 할 수 있지만 &lt;code&gt;tsuid&lt;/code&gt; 필드는 비워 두어야합니다. 또한 두 개의 쿼리 문자열 매개 변수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df200950f2e0bb750dcfe39498dc2c46bd4a6eab" translate="yes" xml:space="preserve">
          <source>With a forward/reverse miss-match, it is possible that a UID was assigned to multiple names for the same type. If this occurs, then data for two different names has been written to the same time series and that data is effectively corrupt.</source>
          <target state="translated">정방향 / 역방향 미스 매치를 사용하면 UID가 동일한 유형의 여러 이름에 지정되었을 수 있습니다. 이 경우 두 개의 다른 이름에 대한 데이터가 동일한 시계열에 기록되고 해당 데이터가 효과적으로 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="4f813fc6057263ad6f9d8235350c9559a5978eee" translate="yes" xml:space="preserve">
          <source>With compactions enabled, it is possible (though unlikely) that a data point is written while a row is being compacted. In this case, the compacted column will have a &lt;em&gt;later&lt;/em&gt; timestamp than a data point written during the compaction. Therefore the default result of &lt;code&gt;--resolve-duplicates&lt;/code&gt; will keep the stand-alone data point or, if last writes win, then the compacted value.</source>
          <target state="translated">압축을 사용하면 행을 압축하는 동안 데이터 포인트가 기록 될 수 있습니다. 이 경우 압축 된 열은 압축 하는 동안 작성된 데이터 포인트보다 &lt;em&gt;늦은&lt;/em&gt; 타임 스탬프 를 갖습니다 . 따라서 &lt;code&gt;--resolve-duplicates&lt;/code&gt; 의 기본 결과는 독립형 데이터 포인트를 유지하거나 마지막 쓰기가 성공하면 압축 된 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e318cf17acebae19ff4970ab4d4e46dc0314d224" translate="yes" xml:space="preserve">
          <source>With rollups enabled, if you plan to use pre-aggregates, you may want to help differentiate raw data from pre-aggregates by having TSDB automatically inject &lt;code&gt;_aggregate=RAW&lt;/code&gt;. Just configure the &lt;code&gt;tsd.rollups.tag_raw&lt;/code&gt; setting to true.</source>
          <target state="translated">롤업이 사용 가능한 상태에서 사전 집계를 사용하려는 경우 TSDB가 &lt;code&gt;_aggregate=RAW&lt;/code&gt; 를 자동으로 주입하여 원시 데이터를 사전 집계와 구별 할 수 있습니다 . &lt;code&gt;tsd.rollups.tag_raw&lt;/code&gt; 설정을 true로 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="90eedcfc697b3778decfae88e385efd2b06b8863" translate="yes" xml:space="preserve">
          <source>With salting enabled (as of OpenTSDB 2.2) the first byte (or bytes) are a hashed salt ID to better distribute data across multiple regions and/or region servers.</source>
          <target state="translated">솔트를 활성화하면 (OpenTSDB 2.2에서) 첫 번째 바이트 (또는 바이트)는 해시 된 솔트 ID로 여러 지역 및 / 또는 지역 서버에 데이터를 더 잘 분산시킵니다.</target>
        </trans-unit>
        <trans-unit id="b078764a7eede9f0bcb50cb7e86a61a6b348f727" translate="yes" xml:space="preserve">
          <source>With the config file written, you can start a tsd with the command:</source>
          <target state="translated">구성 파일이 작성된 상태에서 다음 명령으로 tsd를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930d8603becb44c0222ac71734f3e58560577628" translate="yes" xml:space="preserve">
          <source>With the intersection operator, the expression will effectively add &quot;a.web01 + b.web01&quot; and &quot;a.web02 + b.web02&quot; but will skip emitting anything for &quot;web03&quot;. Be aware of this if you see fewer outputs that you expected or you see errors about no series available after intersection.</source>
          <target state="translated">교집합 연산자를 사용하면 표현식에 &quot;a.web01 + b.web01&quot;및 &quot;a.web02 + b.web02&quot;가 효과적으로 추가되지만 &quot;web03&quot;에 대해서는 아무것도 방출하지 않습니다. 예상 한 출력이 적거나 교차 후 사용 가능한 시리즈가 없다는 오류가 표시되는 경우이 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="2ebd0430bc98cecc73400fb01b504ac62bb5b0a6" translate="yes" xml:space="preserve">
          <source>With the union operator the expression will add the &lt;code&gt;web01&lt;/code&gt; and &lt;code&gt;web02&lt;/code&gt; series but for metric &quot;b&quot;, it will substitute the metric's fill policy value for the results.</source>
          <target state="translated">통합 연산자를 사용하면 표현식에 &lt;code&gt;web01&lt;/code&gt; 및 &lt;code&gt;web02&lt;/code&gt; 시리즈 가 추가 되지만 메트릭 &quot;b&quot;의 경우 결과에 대한 메트릭의 채우기 정책 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9c8346b62154dfe300e2d43246c28cafd072a8a2" translate="yes" xml:space="preserve">
          <source>With version 2.2 a downsampling query can emit a &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; when a downsample bucket is missing a value for all of the series involved. Because OpenTSDB does not allow for storing literal NaNs at this time, nor does it impose specific intervals on storage, this can be used to mimic systems that do such as RRDs.</source>
          <target state="translated">버전 2.2에서는 다운 샘플링 버킷에 관련된 모든 계열의 값이 누락 된 경우 다운 샘플링 쿼리에서 &lt;code&gt;NaN&lt;/code&gt; 을 발생 하거나 &lt;code&gt;null&lt;/code&gt; 을 생성 할 수 있습니다 . OpenTSDB는 현재 리터럴 NaN을 저장할 수 없으며 스토리지에 특정 간격을 부과하지 않기 때문에 RRD와 같은 시스템을 모방하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038a325537f7eb1e3aeda1b73f395c496d495cc4" translate="yes" xml:space="preserve">
          <source>With version 2.2 of OpenTSDB a number of details are now available around queries as we focus on improving flexibility and performance. Query details include who made the request (via headers and socket), what the response was (HTTP status codes and/or exceptions) and timing around the various processes the TSD takes.</source>
          <target state="translated">OpenTSDB 버전 2.2에서는 유연성과 성능 향상에 중점을 두어 쿼리에 대한 여러 가지 세부 정보를 사용할 수 있습니다. 쿼리 세부 정보에는 요청한 사람 (헤더 및 소켓을 통해), 응답 내용 (HTTP 상태 코드 및 / 또는 예외) 및 TSD가 수행하는 다양한 프로세스의 타이밍이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c95eddf6ecb7d244940d2690e5174e56dafc80a6" translate="yes" xml:space="preserve">
          <source>With version 2.2 you can enable or disable grouping per tag filter. Additional filters are also available including wildcards and regular expressions.</source>
          <target state="translated">버전 2.2에서는 태그 필터 당 그룹화를 활성화 또는 비활성화 할 수 있습니다. 와일드 카드 및 정규식을 포함한 추가 필터도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de545dec559f7f886f3804870f7b22fa9755080" translate="yes" xml:space="preserve">
          <source>With version 2.2 you can specify a fill policy when downsampling to substitute values for use in cross-series aggregations when data points are &quot;missing&quot;. Because OpenTSDB does not impose constraints on time alignment or when values are supposed to exist, such constraints must be specified at query time. At serialization time, if all series are missing values for an expected timestamp, nothing is emitted. For example, if a series is writing data every minute from T0 to T4, but for some reason the source fails to write data at T3, only 4 values will be serialized when the user may expect 5. With fill policies you can now choose what value is emitted for T3.</source>
          <target state="translated">버전 2.2에서는 다운 샘플링시 데이터 포인트가 &quot;누락 된&quot;경우 계열 간 집계에 사용되는 값을 대체하도록 채우기 정책을 지정할 수 있습니다. OpenTSDB는 시간 정렬이나 값이 존재할 때 제약 조건을 부과하지 않기 때문에 이러한 제약 조건은 쿼리시 지정해야합니다. 직렬화 시간에 모든 계열에 예상 타임 스탬프에 대한 값이 없으면 아무 것도 방출되지 않습니다. 예를 들어 시리즈가 T0에서 T4까지 매분마다 데이터를 쓰고 있지만 어떤 이유로 소스가 T3에서 데이터를 쓰지 못하는 경우 사용자가 5를 기대할 수있는 경우 4 개의 값만 직렬화됩니다. 채우기 정책을 사용하여 T3에 대한 값이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="8d32239ddee6f91af4ef59471d1f00eb8a41b814" translate="yes" xml:space="preserve">
          <source>With version 2.2, a checkbox to the right of each pair of check boxes is used to determine if the results should be grouped by the tag filter (checked) or aggregated (unchecked). The boxes are checked by default to exhibit the behavior of TSD prior to 2.2.</source>
          <target state="translated">버전 2.2에서는 각 확인란 쌍의 오른쪽에있는 확인란을 사용하여 결과를 태그 필터로 그룹화 (체크) 또는 집계 (체크되지 않음)할지 여부를 결정합니다. 이 상자는 기본적으로 2.2 이전 TSD의 동작을 나타내도록 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="574eb9f5dadbbac36625546f4e776021be173d1b" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;services&lt;/code&gt; create a file with the canonical class name of the abstract plugin class you are implementing. E.g. if you implement &lt;code&gt;net.opentsdb.search.SearchPlugin&lt;/code&gt;, use that for the name of the file.</source>
          <target state="translated">&lt;code&gt;services&lt;/code&gt; 내에서 구현중인 추상 플러그인 클래스의 표준 클래스 이름으로 파일을 작성하십시오. 예를 들어 &lt;code&gt;net.opentsdb.search.SearchPlugin&lt;/code&gt; 을 구현 하는 경우 파일 이름으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="39d9325878900bebf331a9be22ca1bf35f8a4cb8" translate="yes" xml:space="preserve">
          <source>Within the &quot;tags&quot; field you can have one or more filter. The list of filters can be found via the &lt;a href=&quot;../config/filters&quot;&gt;&lt;em&gt;/api/config/filters&lt;/em&gt;&lt;/a&gt; endpoint.</source>
          <target state="translated">&quot;태그&quot;필드 내에 하나 이상의 필터가있을 수 있습니다. 필터 목록은 &lt;a href=&quot;../config/filters&quot;&gt;&lt;em&gt;/ api / config / filters&lt;/em&gt;&lt;/a&gt; 엔드 포인트 를 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fdfa7d0b914f4b237c569c0bea2f7b2ac19edab" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;META-INF&lt;/code&gt; directory, create a file named &lt;code&gt;MANIFEST.MF&lt;/code&gt;. Again some IDEs can generate this automatically.</source>
          <target state="translated">&lt;code&gt;META-INF&lt;/code&gt; 디렉토리 내에 &lt;code&gt;MANIFEST.MF&lt;/code&gt; 라는 파일을 작성하십시오 . 다시 말하지만 일부 IDE는 이것을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76fcb6ebd41de2561360d3da0d7d1ad67ee2b3a" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;id&lt;/code&gt; column family is a row with a single byte key of &lt;code&gt;\x00&lt;/code&gt;. This is the UID row that is incremented for the proper column type (metrics, tagk or tagv) when a new UID is assigned. The column values are 8 byte signed integers and reflect the maximum UID assigned for each type. On assignment, OpenTSDB calls HBase's atomic increment command on the proper column to fetch a new UID.</source>
          <target state="translated">내 &lt;code&gt;id&lt;/code&gt; 열 가족의 단일 바이트 키 행입니다 &lt;code&gt;\x00&lt;/code&gt; . 새 UID가 지정 될 때 적절한 열 유형 (메트릭, tagk 또는 tagv)에 대해 증가하는 UID 행입니다. 열 값은 8 바이트 부호있는 정수이며 각 유형에 지정된 최대 UID를 반영합니다. 할당시 OpenTSDB는 새 UID를 가져 오기 위해 적절한 열에서 HBase의 원자 적 증가 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1db6f51cd372a9779928412e73d84ae9f1d0c599" translate="yes" xml:space="preserve">
          <source>Without going into too much detail on how collectors send data to the TSD , you write a collector that periodically sends the current value of these datapoints for each server to the TSD. So the TSD can aggregate the data from multiple hosts, you tag each value with a &quot;host&quot; tag. So, if you have web servers A, B, C, etc, they each periodically send something like this to the TSD:</source>
          <target state="translated">콜렉터가 TSD에 데이터를 보내는 방법에 대해 너무 자세하게 설명하지 않고 각 서버에 대한 이러한 데이터 포인트의 현재 값을 TSD에 주기적으로 보내는 콜렉터를 작성합니다. 따라서 TSD는 여러 호스트의 데이터를 집계 할 수 있으므로 각 값에 &quot;host&quot;태그를 지정하십시오. 따라서 웹 서버 A, B, C 등이있는 경우 각각 주기적으로 TSD에 다음과 같은 것을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="237f79e47a81786e062a5ff7dda7819ed3b03979" translate="yes" xml:space="preserve">
          <source>Wraps the response in a JavaScript function name passed to the parameter.</source>
          <target state="translated">매개 변수에 전달 된 JavaScript 함수 이름으로 응답을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="61199b6bf5d6d15ab4f6651eb4f149e3437d3584" translate="yes" xml:space="preserve">
          <source>Write Filters - Block or allow time series or UID assignments based on plugins or whitelists.</source>
          <target state="translated">필터 쓰기-플러그인 또는 화이트리스트를 기반으로 시계열 또는 UID 할당을 차단하거나 허용합니다.</target>
        </trans-unit>
        <trans-unit id="869cfa07031a8520d7782bfbf436635d232db0a6" translate="yes" xml:space="preserve">
          <source>Write Performance</source>
          <target state="translated">쓰기 성능</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f02859565ff731f647fdc8f9ed8924ec5f29579" translate="yes" xml:space="preserve">
          <source>Writing data points in OpenTSDB is generally idempotent within an hour of the original write. This means you can write the value &lt;code&gt;42&lt;/code&gt; at timestamp &lt;code&gt;1356998400&lt;/code&gt; and then write &lt;code&gt;42&lt;/code&gt; again for the same time and nothing bad will happen. However if you have compactions enabled to reduce storage consumption and write the same data point after the row of data has been compacted, an exception may be returned when you query over that row. If you attempt to write two different values with the same timestamp, a duplicate data point exception may be thrown during query time. This is due to a difference in encoding integers on 1, 2, 4 or 8 bytes and floating point numbers. If the first value was an integer and the second a floating point, the duplicate error will always be thrown. However if both values were floats or they were both integers that could be encoded on the same length, then the original value may be overwritten if a compaction has not occurred on the row.</source>
          <target state="translated">OpenTSDB에서 데이터 포인트 쓰기는 일반적으로 원래 쓰기 후 1 시간 이내에 dem 등합니다. 이 방법 당신은 값을 쓸 수 &lt;code&gt;42&lt;/code&gt; 타임 스탬프에 &lt;code&gt;1356998400&lt;/code&gt; 다음 쓰기 &lt;code&gt;42&lt;/code&gt; 다시 같은 시간에 나쁜 일이 일어나지 않을 것입니다. 그러나 압축을 사용하여 스토리지 소비를 줄이고 데이터 행을 압축 한 후 동일한 데이터 포인트를 쓰면 해당 행을 쿼리 할 때 예외가 리턴 될 수 있습니다. 동일한 시간 소인으로 두 개의 다른 값을 쓰려고하면 쿼리 시간 동안 중복 데이터 포인트 예외가 발생할 수 있습니다. 이는 1, 2, 4 또는 8 바이트의 정수 인코딩과 부동 소수점 숫자의 차이로 인한 것입니다. 첫 번째 값이 정수이고 두 번째 값이 부동 소수점이면 중복 오류가 항상 발생합니다. 그러나 두 값이 모두 부동이거나 동일한 길이로 인코딩 될 수있는 정수인 경우 행에서 압축이 발생하지 않으면 원래 값을 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="2a9269c1bb899a9c9fd07cd34ecc3fab5ac20773" translate="yes" xml:space="preserve">
          <source>You can also aggregate multiple TSUIDs in the same query, provided they share the same metric. If you attempt to aggregate multiple metrics, the API will issue an error.</source>
          <target state="translated">동일한 메트릭을 공유하는 경우 동일한 쿼리에서 여러 TSUID를 집계 할 수도 있습니다. 여러 메트릭을 집계하려고하면 API에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c7793c86abbf16c608719149f90541bfdfa5bf8" translate="yes" xml:space="preserve">
          <source>You can also zoom in on a time range by clicking and dragging a red box across a section of the graph. Release and the query will be updated with the new time span. Note that the browser cursor doesn't change when you're over the graph, it will still remain the default arrow your browser or OS provides.</source>
          <target state="translated">또한 그래프 섹션에서 빨간색 상자를 클릭하고 드래그하여 시간 범위를 확대 할 수도 있습니다. 릴리스 및 쿼리가 새로운 시간 범위로 업데이트됩니다. 그래프 위에있을 때 브라우저 커서는 변경되지 않으며 브라우저 나 OS가 제공하는 기본 화살표로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="33be7848021f6226fcebc01d2e3a6bde8b921961" translate="yes" xml:space="preserve">
          <source>You can copy and paste the query into a POST client to execute and find out what data was returned.</source>
          <target state="translated">쿼리를 복사하여 POST 클라이언트에 붙여 넣어 어떤 데이터가 반환되었는지 확인하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191d8640c33bf1180997cdddc16068c5b686a8dd" translate="yes" xml:space="preserve">
          <source>You can generate a Debian package by calling &lt;code&gt;sh build.sh debian&lt;/code&gt;. The package will be located at &lt;code&gt;./build/opentsdb-2.x.x/opentsdb-2.x.x_all.deb&lt;/code&gt;. Then simply distribute the package and install it as you regularly would. For example &lt;code&gt;dpkg -i opentsdb-2.0.0_all.deb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sh build.sh debian&lt;/code&gt; 을 호출하여 데비안 패키지를 생성 할 수 있습니다 . 패키지는 &lt;code&gt;./build/opentsdb-2.x.x/opentsdb-2.x.x_all.deb&lt;/code&gt; 있습니다. 그런 다음 패키지를 배포하고 정기적으로 설치하십시오. 예를 들어 &lt;code&gt;dpkg -i opentsdb-2.0.0_all.deb&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5814ba67dfcc6e44a26311a01e14487c47c9db2b" translate="yes" xml:space="preserve">
          <source>You can have more than one implementation of the same abstract class in one JAR and in this file. NOTE: If you have widely different implementations, start a different project and JAR. E.g. if you implement a search plugin for ElasticSearch and another for Solr, put Solr in a different project. However if you have two implementations that are very similar but slightly different, you can create one project. For example you could write an ElasticSearch plugin that uses HTTP for a protocol and another that uses Thrift. In that case, you could have a file like:</source>
          <target state="translated">하나의 JAR 및이 파일에서 동일한 추상 클래스의 구현을 둘 이상 가질 수 있습니다. 참고 : 구현이 크게 다른 경우 다른 프로젝트와 JAR을 시작하십시오. 예를 들어 ElasticSearch 용 검색 플러그인과 Solr 용 검색 플러그인을 구현하는 경우 Solr을 다른 프로젝트에 배치하십시오. 그러나 매우 유사하지만 약간 다른 두 가지 구현이있는 경우 하나의 프로젝트를 작성할 수 있습니다. 예를 들어 프로토콜에 HTTP를 사용하고 Thrift를 사용하는 다른 플러그인을 작성할 수 있습니다. 이 경우 다음과 같은 파일을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61be89b3adba257fe58dc648c322b6c14b4a8da9" translate="yes" xml:space="preserve">
          <source>You can put comments in the service implementation file. The comment character is the &lt;code&gt;#&lt;/code&gt;, just like a Java properties file. E.g.:</source>
          <target state="translated">서비스 구현 파일에 주석을 넣을 수 있습니다. 주석 문자는 Java 특성 파일과 마찬가지로 &lt;code&gt;#&lt;/code&gt; 입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="833a39b790f27c21f775475776dc615b93fc0f1b" translate="yes" xml:space="preserve">
          <source>You can supply a single data point in a request:</source>
          <target state="translated">요청에 단일 데이터 포인트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce453fdc225642de974d8f8c0bc3e8b1447a6126" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;--config&lt;/code&gt; command line argument to specify the full path to a configuration file. Otherwise if not specified, OpenTSDB and some of the command-line tools will attempt to search for a valid configuration file in the following locations:</source>
          <target state="translated">&lt;code&gt;--config&lt;/code&gt; 명령 줄 인수를 사용하여 구성 파일의 전체 경로를 지정할 수 있습니다 . 그렇지 않으면 OpenTSDB 및 일부 명령 줄 도구는 다음 위치에서 유효한 구성 파일을 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3c57b11eea5e4730f4f4c23765201429fc61deee" translate="yes" xml:space="preserve">
          <source>You do not have to upgrade all of your TSDs to 2.3 at the same time. Some users upgrade their read-only TSDs first to gain access to the full HTTP API and test the new features. Later on you can upgrade the write-only TSDs at leisure. You can also perform a rolling upgrade without issues. Simply stop traffic to one TSD, upgrade it, restore traffic, and continue on until you have upgraded all of your TSDs.</source>
          <target state="translated">모든 TSD를 동시에 2.3으로 업그레이드 할 필요는 없습니다. 일부 사용자는 전체 HTTP API에 액세스하여 새로운 기능을 테스트하기 위해 먼저 읽기 전용 TSD를 업그레이드합니다. 나중에 여가 시간에 쓰기 전용 TSD를 업그레이드 할 수 있습니다. 문제없이 롤링 업그레이드를 수행 할 수도 있습니다. 하나의 TSD에 대한 트래픽을 중지하고, 업그레이드하고, 트래픽을 복원 한 후 모든 TSD를 업그레이드 할 때까지 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef56348bf8327f3e140ddb8c003ee282b7d9138" translate="yes" xml:space="preserve">
          <source>You don't have to embed all of this code in every collector you write</source>
          <target state="translated">작성하는 모든 수집기에이 코드를 모두 포함시킬 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c470865b18ec646b328f4b7123cdef9fd3a890c3" translate="yes" xml:space="preserve">
          <source>You may also edit meta data associated with timeseries or individual UID objects via the UID endpoint.</source>
          <target state="translated">UID 끝점을 통해 시계열 또는 개별 UID 개체와 관련된 메타 데이터를 편집 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f83a186df4f6494a3f12f267ca7b646459124b7" translate="yes" xml:space="preserve">
          <source>You may want to jump right in and start throwing data into your TSD, but to really take advantage of OpenTSDB's power and flexibility, you may want to pause and think about your naming schema. After you've done that, you can proceed to pushing data over the Telnet or HTTP APIs, or use an existing tool with OpenTSDB support such as 'tcollector'.</source>
          <target state="translated">바로 들어가서 TSD에 데이터를 던지기를 원할 수도 있지만 OpenTSDB의 강력 함과 유연성을 실제로 활용하기 위해 이름 지정 스키마를 일시 중지하고 생각할 수 있습니다. 그런 다음 텔넷 또는 HTTP API를 통해 데이터를 푸시하거나 'tcollector'와 같은 OpenTSDB를 지원하는 기존 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46af65e160401371668ca6a0a38cbc7af72f4b13" translate="yes" xml:space="preserve">
          <source>You may want to read up on how OpenTSDB stores timeseries data here: &lt;a href=&quot;../backends/index&quot;&gt;&lt;em&gt;Storage&lt;/em&gt;&lt;/a&gt;. Otherwise, remember that each row in storage has a unique key formatted:</source>
          <target state="translated">OpenTSDB가 시계열 데이터를 저장하는 방법에 대한 정보는 &lt;a href=&quot;../backends/index&quot;&gt;&lt;em&gt;Storage&lt;/em&gt;&lt;/a&gt; :를 참조하십시오 . 그렇지 않으면 스토리지의 각 행에는 고유 한 키 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f8e5dd79b4228591ebf914c9d06415143fed98" translate="yes" xml:space="preserve">
          <source>You might want to adjust JVM parameters, for instance to turn on GC activity logging or to set the size of various memory regions. In order to do so, simply set the variable JVMARGS in &lt;code&gt;./tsdb.local&lt;/code&gt;.</source>
          <target state="translated">예를 들어 GC 활동 로깅을 켜거나 다양한 메모리 영역의 크기를 설정하기 위해 JVM 매개 변수를 조정할 수 있습니다. 그렇게하려면 변수 JVMARGS를 &lt;code&gt;./tsdb.local&lt;/code&gt; 에 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c28589fb392b8188752a92c1923552020d4451c9" translate="yes" xml:space="preserve">
          <source>You need to clone tcollector from GitHub:</source>
          <target state="translated">GitHub에서 tcollector를 복제해야합니다.</target>
        </trans-unit>
        <trans-unit id="d61823390ea02b1530bcca7967069bd8a6277470" translate="yes" xml:space="preserve">
          <source>You should always test a new plugin in a development or QA environment before enabling them in production. Plugins may adversely affect write or read performance so be sure to do some load testing to avoid taking down your TSDs and losing data.</source>
          <target state="translated">프로덕션 환경에서 활성화하기 전에 항상 개발 또는 QA 환경에서 새 플러그인을 테스트해야합니다. 플러그인은 쓰기 또는 읽기 성능에 부정적인 영향을 줄 수 있으므로 TSD를 중단하고 데이터를 유실하지 않도록로드 테스트를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfa722f496f60c073a9035295d136673bca221f8" translate="yes" xml:space="preserve">
          <source>You still have the late/historical data issue.</source>
          <target state="translated">여전히 늦게 / 역사적인 데이터 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c3ada727198ca05a3eb567b57355809f064c18" translate="yes" xml:space="preserve">
          <source>You will want to make sure you set the status to PENDING or some other non-ready state in your service discovery system when this is called. TSDB has not been initialized yet at this point.</source>
          <target state="translated">호출 될 때 서비스 발견 시스템에서 상태를 보류 중 또는 다른 비 준비 상태로 설정해야합니다. 현재 TSDB가 초기화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="26553997c4ead536b7bf0c4987caca36fc51a4a2" translate="yes" xml:space="preserve">
          <source>You'll likely spend a lot of time in this area since there are a number of options to play with. You'll likely want to start by choosing one or more metrics and tags to graph.</source>
          <target state="translated">사용할 수있는 옵션이 많으므로이 영역에서 많은 시간을 할애 할 것입니다. 그래프로 표시 할 하나 이상의 측정 항목과 태그를 선택하여 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7fa167b95720a348339af0af51b8b872ecb6dc13" translate="yes" xml:space="preserve">
          <source>Your dev directory should now have a &lt;code&gt;./src&lt;/code&gt; directory</source>
          <target state="translated">dev 디렉토리는 이제 &lt;code&gt;./src&lt;/code&gt; 디렉토리를 가져야합니다</target>
        </trans-unit>
        <trans-unit id="41391104648519ac2d9b476302196de092ae24d9" translate="yes" xml:space="preserve">
          <source>Your first datapoints</source>
          <target state="translated">첫 번째 데이터 포인트</target>
        </trans-unit>
        <trans-unit id="e83191c972e70698326927c9531da95d6089d765" translate="yes" xml:space="preserve">
          <source>Your first plot</source>
          <target state="translated">첫 줄거리</target>
        </trans-unit>
        <trans-unit id="1a0c76d0c7d81a9c8fc26ff8abe58ec0cf006e68" translate="yes" xml:space="preserve">
          <source>Zero (&lt;code&gt;zero&lt;/code&gt;) - Substitutes a zero when a timestamp is missing. The zero value will be incorporated in aggregated results.</source>
          <target state="translated">Zero ( &lt;code&gt;zero&lt;/code&gt; )-타임 스탬프가 없으면 0을 대체합니다. 제로 값은 집계 결과에 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="9c167276bd45514c8b739ca546a838ff44f0cd3b" translate="yes" xml:space="preserve">
          <source>Zero if missing</source>
          <target state="translated">없는 경우 0</target>
        </trans-unit>
        <trans-unit id="98116df9b9f5748e301fdccd687e8f2e85084726" translate="yes" xml:space="preserve">
          <source>ZimSum</source>
          <target state="translated">ZimSum</target>
        </trans-unit>
        <trans-unit id="cdcd5c9a3a475f2298b5ee3f4258f8207ba10879" translate="yes" xml:space="preserve">
          <source>[ ]</source>
          <target state="translated">[ ]</target>
        </trans-unit>
        <trans-unit id="c9257f8fd31ea852baf734ef06d37348bf6e8cb2" translate="yes" xml:space="preserve">
          <source>\.</source>
          <target state="translated">\.</target>
        </trans-unit>
        <trans-unit id="d203bdcf492d3ee0d583a405ec9f3e0fee8888d3" translate="yes" xml:space="preserve">
          <source>\\.</source>
          <target state="translated">\\.</target>
        </trans-unit>
        <trans-unit id="d96542ec7f0676c9533df80d8687eb19c68d93f1" translate="yes" xml:space="preserve">
          <source>^.*\.([a-zA-Z]{3,4})[0-9]{0,1}\..*\..*$</source>
          <target state="translated">^.*\.([a-zA-Z]{3,4})[0-9]{0,1}\..*\..*$</target>
        </trans-unit>
        <trans-unit id="44007aca9b1fe559f5a621c9ab2a5cafce3ff6b7" translate="yes" xml:space="preserve">
          <source>_aggregate</source>
          <target state="translated">_aggregate</target>
        </trans-unit>
        <trans-unit id="fa9044d8655992432f27d07c523bf8678a5e5826" translate="yes" xml:space="preserve">
          <source>_aggregate=COUNT</source>
          <target state="translated">_aggregate=COUNT</target>
        </trans-unit>
        <trans-unit id="e2c8bac773a310bfb50e7c798f61c5d4d17d55f1" translate="yes" xml:space="preserve">
          <source>_aggregate=SUM</source>
          <target state="translated">_aggregate=SUM</target>
        </trans-unit>
        <trans-unit id="f33afba6cd2526e029d8789dd92e3374ebbe8d7b" translate="yes" xml:space="preserve">
          <source>a + b / 1024</source>
          <target state="translated">a + b / 1024</target>
        </trans-unit>
        <trans-unit id="bbbc2f496199bc34430af8b5f58b0f2ab4ef6bcd" translate="yes" xml:space="preserve">
          <source>absolute(&amp;lt;metric&amp;gt;)</source>
          <target state="translated">absolute(&amp;lt;metric&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="d9a3787d14a071684ac0a5d63ebf75a8a57c3e95" translate="yes" xml:space="preserve">
          <source>accumulation.snow</source>
          <target state="translated">accumulation.snow</target>
        </trans-unit>
        <trans-unit id="2bce561952deb300d9ad49d8a1a12e14e7fee32b" translate="yes" xml:space="preserve">
          <source>additional queries</source>
          <target state="translated">추가 쿼리</target>
        </trans-unit>
        <trans-unit id="c4e796251bd817f3f52264d2d2055bc3b6f80261" translate="yes" xml:space="preserve">
          <source>aggregatedTags</source>
          <target state="translated">aggregatedTags</target>
        </trans-unit>
        <trans-unit id="8af3cd7b7305ba8436016127f5357e9bc38c5afc" translate="yes" xml:space="preserve">
          <source>aggregationTime</source>
          <target state="translated">aggregationTime</target>
        </trans-unit>
        <trans-unit id="e23534fcc52d69727f1ff8041e4f37a323457b0a" translate="yes" xml:space="preserve">
          <source>aggregator</source>
          <target state="translated">aggregator</target>
        </trans-unit>
        <trans-unit id="cdb6fdbe91faa53a7c573c80b7c18108c73c0480" translate="yes" xml:space="preserve">
          <source>alias</source>
          <target state="translated">alias</target>
        </trans-unit>
        <trans-unit id="0a14c6830bde2e5a07c0b9cf963faef9759a1142" translate="yes" xml:space="preserve">
          <source>alpn-boot</source>
          <target state="translated">alpn-boot</target>
        </trans-unit>
        <trans-unit id="02a488a3bef14bed8b1c9d90a682184a103c7cb6" translate="yes" xml:space="preserve">
          <source>and edit 'tcollector/startstop' script to set following variable: &lt;code&gt;TSD_HOST=dns.name.of.tsd&lt;/code&gt;</source>
          <target state="translated">'tcollector / startstop'스크립트를 편집하여 다음 변수를 설정하십시오. &lt;code&gt;TSD_HOST=dns.name.of.tsd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dfbedeaad5d654a234d901eab80b3ade99ae988" translate="yes" xml:space="preserve">
          <source>and remove the comments so it appears as &lt;code&gt;&amp;lt;appender-ref ref=&quot;FILE&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;appender-ref ref=&quot;FILE&quot;/&amp;gt;&lt;/code&gt; 로 표시되도록 주석을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc61586d1845fc597104237063a69d8b179b8173" translate="yes" xml:space="preserve">
          <source>and set the &lt;code&gt;level&lt;/code&gt; to &lt;code&gt;INFO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 을 &lt;code&gt;INFO&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e97da103dbeb4d7fd95f61361ad321d9d2e9d58" translate="yes" xml:space="preserve">
          <source>and simply craft a query &lt;code&gt;start=1356998400&amp;amp;m=sum:sys.cpu.user&lt;/code&gt;, we will get a value of &lt;code&gt;8&lt;/code&gt; at &lt;code&gt;1356998400&lt;/code&gt; that incorporates all 4 time series.</source>
          <target state="translated">&lt;code&gt;start=1356998400&amp;amp;m=sum:sys.cpu.user&lt;/code&gt; 쿼리 를 &lt;code&gt;1356998400&lt;/code&gt; 하면 4 개의 시계열을 모두 포함하는 1356998400 에서 &lt;code&gt;8&lt;/code&gt; 의 값을 얻게됩니다 .</target>
        </trans-unit>
        <trans-unit id="516d70777b5ffab32d73d264205e523acd04b40b" translate="yes" xml:space="preserve">
          <source>annotations</source>
          <target state="translated">annotations</target>
        </trans-unit>
        <trans-unit id="9715442fe61cdf241769790be1cc2289815cb06e" translate="yes" xml:space="preserve">
          <source>api/query</source>
          <target state="translated">api/query</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="dd9dcb17eb80061a479a56fb4dd120e2398ffc40" translate="yes" xml:space="preserve">
          <source>app.connections</source>
          <target state="translated">app.connections</target>
        </trans-unit>
        <trans-unit id="a277673e9a9147ec07cbb026c5f78d9610de8d0d" translate="yes" xml:space="preserve">
          <source>app.errors</source>
          <target state="translated">app.errors</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="5148d094f461f44844d3dc310cdd8aa818bd66e0" translate="yes" xml:space="preserve">
          <source>arrays=true</source>
          <target state="translated">arrays=true</target>
        </trans-unit>
        <trans-unit id="9009b730f26e909d049a4a0c3612e3c61160f37f" translate="yes" xml:space="preserve">
          <source>assign</source>
          <target state="translated">assign</target>
        </trans-unit>
        <trans-unit id="02579e3ca74c551aba701841597c5217ae3827af" translate="yes" xml:space="preserve">
          <source>asynccassandra.port</source>
          <target state="translated">asynccassandra.port</target>
        </trans-unit>
        <trans-unit id="b3fe693b69b34aecc891ab18387793e60b924e9c" translate="yes" xml:space="preserve">
          <source>asynccassandra.seeds</source>
          <target state="translated">asynccassandra.seeds</target>
        </trans-unit>
        <trans-unit id="cd6bf061d2e573b8ffa3f7e8ab2a923895b3703d" translate="yes" xml:space="preserve">
          <source>asynccassandra.seeds=127.0.0.1:9160</source>
          <target state="translated">asynccassandra.seeds=127.0.0.1:9160</target>
        </trans-unit>
        <trans-unit id="97e77871b5fcc4941bebceb4338c97c1fd149f8c" translate="yes" xml:space="preserve">
          <source>avg</source>
          <target state="translated">avg</target>
        </trans-unit>
        <trans-unit id="a2022eac1538a124bb766c22eb9a8194545014b3" translate="yes" xml:space="preserve">
          <source>backScan</source>
          <target state="translated">backScan</target>
        </trans-unit>
        <trans-unit id="aeb1356eb9b58d2e1bddca59f80648a387dc5281" translate="yes" xml:space="preserve">
          <source>back_scan</source>
          <target state="translated">back_scan</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="b1720429f630ba3df16dc2e8e9d85f8b545ae2e4" translate="yes" xml:space="preserve">
          <source>branchId</source>
          <target state="translated">branchId</target>
        </trans-unit>
        <trans-unit id="52a9ce4a0d3c21f1c0c5dc576930fbb59ad74018" translate="yes" xml:space="preserve">
          <source>branches</source>
          <target state="translated">branches</target>
        </trans-unit>
        <trans-unit id="f887e9a160c52393e3db17bec26927e61e0b8211" translate="yes" xml:space="preserve">
          <source>build/tsdb tsd --config=&amp;lt;path&amp;gt;/opentsdb.conf</source>
          <target state="translated">빌드 / tsdb tsd --config = &amp;lt;경로&amp;gt; /opentsdb.conf</target>
        </trans-unit>
        <trans-unit id="f5cb4600e426f15f31b3528e927fc2ade8e3a111" translate="yes" xml:space="preserve">
          <source>cache=disk</source>
          <target state="translated">cache=disk</target>
        </trans-unit>
        <trans-unit id="0d8396810c147522298cd72fd5c134a55f486c4e" translate="yes" xml:space="preserve">
          <source>cache=miss</source>
          <target state="translated">cache=miss</target>
        </trans-unit>
        <trans-unit id="62395a980f92ab81a874944ebaa050217e60575d" translate="yes" xml:space="preserve">
          <source>cassandra-cli</source>
          <target state="translated">cassandra-cli</target>
        </trans-unit>
        <trans-unit id="2942224b5018940d48da74f8f2199d27881cc139" translate="yes" xml:space="preserve">
          <source>clean_cache.sh</source>
          <target state="translated">clean_cache.sh</target>
        </trans-unit>
        <trans-unit id="d2a04d71301a8915217dd5faf81d12cffd6cd958" translate="yes" xml:space="preserve">
          <source>client</source>
          <target state="translated">client</target>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="0d55cc664ee8208d4ce6f4beb81c49ceb6477476" translate="yes" xml:space="preserve">
          <source>colo=lga</source>
          <target state="translated">colo=lga</target>
        </trans-unit>
        <trans-unit id="ac91d4f2b77a51b67ee115f2d8cf21eca9794cf0" translate="yes" xml:space="preserve">
          <source>colo=sjc</source>
          <target state="translated">colo=sjc</target>
        </trans-unit>
        <trans-unit id="ddac9447659b6c8efde284788aa37855deb5de5d" translate="yes" xml:space="preserve">
          <source>com.google.cloud.bigtable.hbase1_0.BigtableConnection</source>
          <target state="translated">com.google.cloud.bigtable.hbase1_0.BigtableConnection</target>
        </trans-unit>
        <trans-unit id="e9bb6fb51756982a94d0905494becbcc7d0ec273" translate="yes" xml:space="preserve">
          <source>commonTags</source>
          <target state="translated">commonTags</target>
        </trans-unit>
        <trans-unit id="db1a055c47b46c9b5bfa651555bbdcf5545c7925" translate="yes" xml:space="preserve">
          <source>compactionTime</source>
          <target state="translated">compactionTime</target>
        </trans-unit>
        <trans-unit id="2b34caee3c0875057e11d789b213e242683248f5" translate="yes" xml:space="preserve">
          <source>configuration property. Simply list the class name of any RPC plugins you wish to load, separated by a comma if you have more than one. RPC plugins are only initialized when running a TSD.</source>
          <target state="translated">구성 속성. 로드하려는 RPC 플러그인의 클래스 이름을 쉼표로 구분하여 나열하십시오 (하나 이상인 경우). RPC 플러그인은 TSD를 실행할 때만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1926f1c722b8ae2344dc2f421f855357562e7a" translate="yes" xml:space="preserve">
          <source>connections (tsuid=010101)</source>
          <target state="translated">연결 (tsuid = 010101)</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">count</target>
        </trans-unit>
        <trans-unit id="458796e4e963a163322319ba62d683315a930a09" translate="yes" xml:space="preserve">
          <source>counter</source>
          <target state="translated">counter</target>
        </trans-unit>
        <trans-unit id="9f36c5eabbfb13f34b69137d62c20c4bbd172631" translate="yes" xml:space="preserve">
          <source>counterMax</source>
          <target state="translated">counterMax</target>
        </trans-unit>
        <trans-unit id="ca49ca4bb6732ef61577364cb33b115854e88f06" translate="yes" xml:space="preserve">
          <source>cpu</source>
          <target state="translated">cpu</target>
        </trans-unit>
        <trans-unit id="202fb7d88c9021d0cd6d53e27c0ad55b8e53da8f" translate="yes" xml:space="preserve">
          <source>cpu.system</source>
          <target state="translated">cpu.system</target>
        </trans-unit>
        <trans-unit id="b933d083a588f4a5d9d6fad0dbbc70d33e6b4ab6" translate="yes" xml:space="preserve">
          <source>cpu.user</source>
          <target state="translated">cpu.user</target>
        </trans-unit>
        <trans-unit id="368a540ac36639b82a203e852076b8a0f93441a5" translate="yes" xml:space="preserve">
          <source>cpubusy</source>
          <target state="translated">cpubusy</target>
        </trans-unit>
        <trans-unit id="9c58a9ea87c0fad123bdb1584a59edf262bf3b0a" translate="yes" xml:space="preserve">
          <source>cpunice</source>
          <target state="translated">cpunice</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="f9ac14b63a75faf57d8db6f919bfabb2502d273c" translate="yes" xml:space="preserve">
          <source>custom</source>
          <target state="translated">custom</target>
        </trans-unit>
        <trans-unit id="f670fbad453981e3c4c72aca0f91ab0282001bd6" translate="yes" xml:space="preserve">
          <source>customField</source>
          <target state="translated">customField</target>
        </trans-unit>
        <trans-unit id="83c4bf215b4492f7696aeba9447f33ae0149b63d" translate="yes" xml:space="preserve">
          <source>custom_field</source>
          <target state="translated">custom_field</target>
        </trans-unit>
        <trans-unit id="57f1e58d6f9bcae6d4976bfc8b1f60d6b22672ae" translate="yes" xml:space="preserve">
          <source>d - Days (24 hours)</source>
          <target state="translated">d-일 (24 시간)</target>
        </trans-unit>
        <trans-unit id="a63194b027e7a2143aa423aec5fdd002760ba72a" translate="yes" xml:space="preserve">
          <source>dal</source>
          <target state="translated">dal</target>
        </trans-unit>
        <trans-unit id="edb7da5c9962dd5bb5faa1890386c1e1d4392661" translate="yes" xml:space="preserve">
          <source>dataType</source>
          <target state="translated">dataType</target>
        </trans-unit>
        <trans-unit id="5411ba018172ec73e64e74bf5b04f39c227da5f0" translate="yes" xml:space="preserve">
          <source>data_type</source>
          <target state="translated">data_type</target>
        </trans-unit>
        <trans-unit id="0086257c8d753a2c5d8fec60d0c53a8de180b779" translate="yes" xml:space="preserve">
          <source>datapoints</source>
          <target state="translated">datapoints</target>
        </trans-unit>
        <trans-unit id="13211ef68928d927b98c56e3497bfbc0a93a377a" translate="yes" xml:space="preserve">
          <source>dc</source>
          <target state="translated">dc</target>
        </trans-unit>
        <trans-unit id="ba370350516e33319964d063bc7f71f51bc3bb14" translate="yes" xml:space="preserve">
          <source>dc=dal host=web01</source>
          <target state="translated">dc = dal 호스트 = web01</target>
        </trans-unit>
        <trans-unit id="1a973aba8ea311707d67e45899ddfbf17e77d405" translate="yes" xml:space="preserve">
          <source>dc=dal host=web02</source>
          <target state="translated">dc = dal 호스트 = web02</target>
        </trans-unit>
        <trans-unit id="8157efa0b67d1e4fad31b09b5bff2ca59a3d6244" translate="yes" xml:space="preserve">
          <source>dc=dal host=web03</source>
          <target state="translated">dc = dal 호스트 = web03</target>
        </trans-unit>
        <trans-unit id="65e5897727634f1137a19e3f16df0a64b00c9c57" translate="yes" xml:space="preserve">
          <source>dc=dal, host=web01.dal.mysite.com</source>
          <target state="translated">dc = dal, host = web01.dal.mysite.com</target>
        </trans-unit>
        <trans-unit id="720df9e4d09f33a6012636e9a2571534c5e5f47c" translate="yes" xml:space="preserve">
          <source>dc=dal, host=web02.dal.mysite.com</source>
          <target state="translated">dc = dal, host = web02.dal.mysite.com</target>
        </trans-unit>
        <trans-unit id="115b1ab9983c4fa088a8dacdad822f874d861a85" translate="yes" xml:space="preserve">
          <source>dc=dal, host=web03.dal.mysite.com</source>
          <target state="translated">dc = dal, host = web03.dal.mysite.com</target>
        </trans-unit>
        <trans-unit id="8481228a03f36ff2de1151c449fef29951faccfb" translate="yes" xml:space="preserve">
          <source>dc=lax host=web01</source>
          <target state="translated">dc = lax 호스트 = web01</target>
        </trans-unit>
        <trans-unit id="bc4851723087a1d53f54e65f6e9b73141f6e62ac" translate="yes" xml:space="preserve">
          <source>dc=lax host=web02</source>
          <target state="translated">dc = lax 호스트 = web02</target>
        </trans-unit>
        <trans-unit id="1627974efcbef652c6c588dd9d0b92ca603feb77" translate="yes" xml:space="preserve">
          <source>dc=lax, host=web01.lax.mysite.com</source>
          <target state="translated">dc = lax, host = web01.lax.mysite.com</target>
        </trans-unit>
        <trans-unit id="90fbf8ecbcf3726c8fcd8fe863c7254fea9db2f5" translate="yes" xml:space="preserve">
          <source>dc=lax, host=web02.lax.mysite.com</source>
          <target state="translated">dc = lax, host = web02.lax.mysite.com</target>
        </trans-unit>
        <trans-unit id="5eb965dd8c804a3a2833ac61fe1d1f6b1960735a" translate="yes" xml:space="preserve">
          <source>dead</source>
          <target state="translated">dead</target>
        </trans-unit>
        <trans-unit id="f3f1dd33eb2a8b380b64a830e5fd90eab77d9ff3" translate="yes" xml:space="preserve">
          <source>definition</source>
          <target state="translated">definition</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="82afdd3f25d27bb747d796b038ebdfa395b92077" translate="yes" xml:space="preserve">
          <source>delete_unknown - Removes any columns in the UID table that do not belong to OpenTSDB</source>
          <target state="translated">delete_unknown-UID 테이블에서 OpenTSDB에 속하지 않은 열을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f82a8e8dd311d353948062cb1a0b67c9e9850be1" translate="yes" xml:space="preserve">
          <source>depth</source>
          <target state="translated">depth</target>
        </trans-unit>
        <trans-unit id="cb329146a0dd0d566b0628744d67936558741ffa" translate="yes" xml:space="preserve">
          <source>description</source>
          <target state="translated">description</target>
        </trans-unit>
        <trans-unit id="e9711657b066fc8697f6f46ac6be9ce246e43aac" translate="yes" xml:space="preserve">
          <source>details</source>
          <target state="translated">details</target>
        </trans-unit>
        <trans-unit id="34c6fceca75e456f25e7e99531e2425c6c1de443" translate="yes" xml:space="preserve">
          <source>dev</source>
          <target state="translated">dev</target>
        </trans-unit>
        <trans-unit id="85484524bc3731825005a49c09b3177ea61afd65" translate="yes" xml:space="preserve">
          <source>diediedie</source>
          <target state="translated">diediedie</target>
        </trans-unit>
        <trans-unit id="4479a6ed88bff418f5d3e45959fe62a5845e8f9e" translate="yes" xml:space="preserve">
          <source>diffSeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</source>
          <target state="translated">diffSeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</target>
        </trans-unit>
        <trans-unit id="8d392f56d616a516ceabb82ed8906418bce4647d" translate="yes" xml:space="preserve">
          <source>directory</source>
          <target state="translated">directory</target>
        </trans-unit>
        <trans-unit id="47a6d8cf98dc893dfcfcdc3e76bfc495d739ace8" translate="yes" xml:space="preserve">
          <source>disk.*write</source>
          <target state="translated">disk.*write</target>
        </trans-unit>
        <trans-unit id="cd44da5a3afc7d2e396569dd7e065f22f3f30b5c" translate="yes" xml:space="preserve">
          <source>displayFormat</source>
          <target state="translated">displayFormat</target>
        </trans-unit>
        <trans-unit id="226e8ab97c399ef7e520a8c77ae9ce3fd60b449f" translate="yes" xml:space="preserve">
          <source>displayName</source>
          <target state="translated">displayName</target>
        </trans-unit>
        <trans-unit id="6b4c645670d6ddfd60a953c6b89e294709580692" translate="yes" xml:space="preserve">
          <source>display_format</source>
          <target state="translated">display_format</target>
        </trans-unit>
        <trans-unit id="586e05edd180b07c41035fe36ef32451431ff3ca" translate="yes" xml:space="preserve">
          <source>display_name</source>
          <target state="translated">display_name</target>
        </trans-unit>
        <trans-unit id="85da8257efc5da99dedbe78b1ea957613a1c028f" translate="yes" xml:space="preserve">
          <source>divideSeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</source>
          <target state="translated">divideSeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</target>
        </trans-unit>
        <trans-unit id="f93b869698002e31cc57bb9c1c0c10fa39a2fb18" translate="yes" xml:space="preserve">
          <source>document, and run the</source>
          <target state="translated">문서를 작성하고</target>
        </trans-unit>
        <trans-unit id="d6b4e84ee7f31d88617a6b60421451272ebf1a3a" translate="yes" xml:space="preserve">
          <source>doe</source>
          <target state="translated">doe</target>
        </trans-unit>
        <trans-unit id="5de27eebf8673f140fbb5d3be88fa415829e73fa" translate="yes" xml:space="preserve">
          <source>downsample</source>
          <target state="translated">downsample</target>
        </trans-unit>
        <trans-unit id="6138ca35d93bc3370d9c7f0b1b312fe159abcbbb" translate="yes" xml:space="preserve">
          <source>downsample 300000 avg</source>
          <target state="translated">다운 샘플 300000 평균</target>
        </trans-unit>
        <trans-unit id="d86181c94e60c3495757bd52c2d71b385dcb7ab6" translate="yes" xml:space="preserve">
          <source>downsample N FUNC</source>
          <target state="translated">다운 샘플 N 기능</target>
        </trans-unit>
        <trans-unit id="210053af815b1c93d095dddcd6bd93953095e6dc" translate="yes" xml:space="preserve">
          <source>downsampler</source>
          <target state="translated">downsampler</target>
        </trans-unit>
        <trans-unit id="bb8d6769ab7d3343061f77b7addd4e364179bbed" translate="yes" xml:space="preserve">
          <source>dps</source>
          <target state="translated">dps</target>
        </trans-unit>
        <trans-unit id="2287b1b741e03105262aa9720b993f1b89870fd5" translate="yes" xml:space="preserve">
          <source>dpsMeta</source>
          <target state="translated">dpsMeta</target>
        </trans-unit>
        <trans-unit id="c856763788359b31ded158e284774cfe1b8134d9" translate="yes" xml:space="preserve">
          <source>dropcaches</source>
          <target state="translated">dropcaches</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="4a9aa7f56fa0e37769dff5a6b6f662b963010d7e" translate="yes" xml:space="preserve">
          <source>emittedDPs</source>
          <target state="translated">emittedDPs</target>
        </trans-unit>
        <trans-unit id="3ea3f9802accf8817bacd6f3df46a73b93ccddec" translate="yes" xml:space="preserve">
          <source>enabled</source>
          <target state="translated">enabled</target>
        </trans-unit>
        <trans-unit id="7a92f3d26362d6557d5701de77a63a01df61e57f" translate="yes" xml:space="preserve">
          <source>end</source>
          <target state="translated">end</target>
        </trans-unit>
        <trans-unit id="e18933dd75bb5faa24508a6926e473485a7d95ae" translate="yes" xml:space="preserve">
          <source>endTime</source>
          <target state="translated">endTime</target>
        </trans-unit>
        <trans-unit id="9a2e74625cb3b1673e6d2c83984aff90684209da" translate="yes" xml:space="preserve">
          <source>end_time</source>
          <target state="translated">end_time</target>
        </trans-unit>
        <trans-unit id="e13fe41b5c330dd923da91992ed0cedb7e30960f" translate="yes" xml:space="preserve">
          <source>endpoint</source>
          <target state="translated">endpoint</target>
        </trans-unit>
        <trans-unit id="8807d7f9602a93027fa2df1f137390d421aebfaf" translate="yes" xml:space="preserve">
          <source>environment variable to your Bigtable shell directory, make sure the</source>
          <target state="translated">환경 변수를 Bigtable 쉘 디렉토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ca9c1f03495d307d164b9d31383616054ab8fd68" translate="yes" xml:space="preserve">
          <source>environment variables have been set according to the values in</source>
          <target state="translated">환경 변수는의 값에 따라 설정되었습니다</target>
        </trans-unit>
        <trans-unit id="0d3ab2fbfc186c7e1b93b3de1faf738b30f2aab1" translate="yes" xml:space="preserve">
          <source>ep50r3</source>
          <target state="translated">ep50r3</target>
        </trans-unit>
        <trans-unit id="f91dc6f72b3a8f5c9f38b8ae3eeef97b3fb810d0" translate="yes" xml:space="preserve">
          <source>ep50r7</source>
          <target state="translated">ep50r7</target>
        </trans-unit>
        <trans-unit id="85e7dbf3af7808d12043b2c6e80bf0cac62d2475" translate="yes" xml:space="preserve">
          <source>ep75r3</source>
          <target state="translated">ep75r3</target>
        </trans-unit>
        <trans-unit id="bbb93524e261d41f7958b97e960476af49495b1f" translate="yes" xml:space="preserve">
          <source>ep75r7</source>
          <target state="translated">ep75r7</target>
        </trans-unit>
        <trans-unit id="ebebcc6a5d34f26a1676aa87eefbdc4b0b69ec16" translate="yes" xml:space="preserve">
          <source>ep90r3</source>
          <target state="translated">ep90r3</target>
        </trans-unit>
        <trans-unit id="a430f039e1748a80a3c623f5706e7223d9f71dfc" translate="yes" xml:space="preserve">
          <source>ep90r7</source>
          <target state="translated">ep90r7</target>
        </trans-unit>
        <trans-unit id="4733e6bd7b67eac1eff306ca77535cba31e93703" translate="yes" xml:space="preserve">
          <source>ep95r3</source>
          <target state="translated">ep95r3</target>
        </trans-unit>
        <trans-unit id="d0a61665a115eb28c867b1aa2c60a4acde203112" translate="yes" xml:space="preserve">
          <source>ep95r7</source>
          <target state="translated">ep95r7</target>
        </trans-unit>
        <trans-unit id="5fe2ecb8b4fa3eb5e3e1c8edd636da0cf8a6935c" translate="yes" xml:space="preserve">
          <source>ep999r3</source>
          <target state="translated">ep999r3</target>
        </trans-unit>
        <trans-unit id="93dfc9456d2829925990ac518bc10f4abbd564b2" translate="yes" xml:space="preserve">
          <source>ep999r7</source>
          <target state="translated">ep999r7</target>
        </trans-unit>
        <trans-unit id="b5376c4672b4e3cb03fcce8ddf33ae864ff8e120" translate="yes" xml:space="preserve">
          <source>ep99r3</source>
          <target state="translated">ep99r3</target>
        </trans-unit>
        <trans-unit id="aa4b820c48d69bbb9e221305bf20703320a5dc8e" translate="yes" xml:space="preserve">
          <source>ep99r7</source>
          <target state="translated">ep99r7</target>
        </trans-unit>
        <trans-unit id="570043596e41f9067d43fbff99f1acb348a090bf" translate="yes" xml:space="preserve">
          <source>errors</source>
          <target state="translated">errors</target>
        </trans-unit>
        <trans-unit id="3d3e78fa9058f34c5d5d72f50fc3fc55a53ef5af" translate="yes" xml:space="preserve">
          <source>errors (tsuid=0101010306)</source>
          <target state="translated">오류 (tsuid = 0101010306)</target>
        </trans-unit>
        <trans-unit id="a8aacba1d9f18d2d80cfb1a099bd84111b2e91a4" translate="yes" xml:space="preserve">
          <source>executed</source>
          <target state="translated">executed</target>
        </trans-unit>
        <trans-unit id="86b77de2442fe05048f19c766138a551aa2543be" translate="yes" xml:space="preserve">
          <source>exp</source>
          <target state="translated">exp</target>
        </trans-unit>
        <trans-unit id="fe5acb27d5d5ff4351ab1040b9a001bc797c4dca" translate="yes" xml:space="preserve">
          <source>explicitTags &lt;em&gt;(2.3)&lt;/em&gt;</source>
          <target state="translated">explicitTags &lt;em&gt;(2.3)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fd1860204d6cee43392972817e66792ee702b89" translate="yes" xml:space="preserve">
          <source>expr</source>
          <target state="translated">expr</target>
        </trans-unit>
        <trans-unit id="ec9814396ba26fa02dc3261046ba55a3b4bb32a6" translate="yes" xml:space="preserve">
          <source>expression</source>
          <target state="translated">expression</target>
        </trans-unit>
        <trans-unit id="c09bb890b096f7306f688cc6d1dad34e7e52a223" translate="yes" xml:space="preserve">
          <source>f1</source>
          <target state="translated">f1</target>
        </trans-unit>
        <trans-unit id="5f5f8758f5f22d523e531f58123b6db9161683a4" translate="yes" xml:space="preserve">
          <source>failed</source>
          <target state="translated">failed</target>
        </trans-unit>
        <trans-unit id="7cb6efb98ba5972a9b5090dc2e517fe14d12cb04" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>
        </trans-unit>
        <trans-unit id="2da0b68df8841752bb747a76780679bcd87c6215" translate="yes" xml:space="preserve">
          <source>field</source>
          <target state="translated">field</target>
        </trans-unit>
        <trans-unit id="4d3a2209aac04f489a73bef2b0ec5aebc0bbc055" translate="yes" xml:space="preserve">
          <source>file with the</source>
          <target state="translated">파일</target>
        </trans-unit>
        <trans-unit id="480a62ddd1b086a325db8ed26d2b71a47d59f118" translate="yes" xml:space="preserve">
          <source>file with the required and/or optional configuration parameters below.</source>
          <target state="translated">아래 필수 및 / 또는 선택적 구성 매개 변수가있는 파일.</target>
        </trans-unit>
        <trans-unit id="294864eb85ac48bb3ef51ce6d14341480ea3617b" translate="yes" xml:space="preserve">
          <source>fillPolicy</source>
          <target state="translated">fillPolicy</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="063bb71e199e75a4d65523c5d5ed89f1f55303e5" translate="yes" xml:space="preserve">
          <source>filters &lt;em&gt;(2.2)&lt;/em&gt;</source>
          <target state="translated">필터 &lt;em&gt;(2.2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0996a37c13d44c3b06074939d43fa3759bd32c1" translate="yes" xml:space="preserve">
          <source>first</source>
          <target state="translated">first</target>
        </trans-unit>
        <trans-unit id="efed8af022a1709dbc89181294acd3f7d1eb5d21" translate="yes" xml:space="preserve">
          <source>fix - Attempts to fix errors per the table above</source>
          <target state="translated">fix-위의 표에 따라 오류를 수정하려고합니다</target>
        </trans-unit>
        <trans-unit id="112f3a99b283a4e1788dedd8e0e5d35375c33747" translate="yes" xml:space="preserve">
          <source>flag</source>
          <target state="translated">flag</target>
        </trans-unit>
        <trans-unit id="2ce12ec02ae86424bb052211552a086509094dd2" translate="yes" xml:space="preserve">
          <source>formatters</source>
          <target state="translated">formatters</target>
        </trans-unit>
        <trans-unit id="82f512f0d7f5f026e6c6fb35ff1e6c50701a05c9" translate="yes" xml:space="preserve">
          <source>fsck</source>
          <target state="translated">fsck</target>
        </trans-unit>
        <trans-unit id="ec6d9083d77b970950e8340ff01d89108b346e38" translate="yes" xml:space="preserve">
          <source>gc</source>
          <target state="translated">gc</target>
        </trans-unit>
        <trans-unit id="9027cc5a2c1321de60a2d71ccde6229d1152d6d3" translate="yes" xml:space="preserve">
          <source>global</source>
          <target state="translated">global</target>
        </trans-unit>
        <trans-unit id="38f2d6d5bd8a9eaf90d4431b8ecef5dd2e3bbe0c" translate="yes" xml:space="preserve">
          <source>globalAnnotations</source>
          <target state="translated">globalAnnotations</target>
        </trans-unit>
        <trans-unit id="404e01df758154c3fcd5ea0abef9592fbc606de1" translate="yes" xml:space="preserve">
          <source>global_annotations</source>
          <target state="translated">global_annotations</target>
        </trans-unit>
        <trans-unit id="999c7db205b9e43d7f6108cf85e18af2b7c13ed4" translate="yes" xml:space="preserve">
          <source>google.bigtable.auth.json.keyfile</source>
          <target state="translated">google.bigtable.auth.json.keyfile</target>
        </trans-unit>
        <trans-unit id="fa71c4df23962aff5b8afb5f633cebe93aada718" translate="yes" xml:space="preserve">
          <source>google.bigtable.auth.service.account.enable</source>
          <target state="translated">google.bigtable.auth.service.account.enable</target>
        </trans-unit>
        <trans-unit id="7ad2beb43a8a168cbbdcc0a7a985ae16595ba2a0" translate="yes" xml:space="preserve">
          <source>google.bigtable.cluster.name</source>
          <target state="translated">google.bigtable.cluster.name</target>
        </trans-unit>
        <trans-unit id="7a9d7c0b3c87191110f21c0ea8d63758fce18d3a" translate="yes" xml:space="preserve">
          <source>google.bigtable.grpc.channel.count</source>
          <target state="translated">google.bigtable.grpc.channel.count</target>
        </trans-unit>
        <trans-unit id="b503a2e41ca54aaac25a15280226b619e0b6a240" translate="yes" xml:space="preserve">
          <source>google.bigtable.project.id</source>
          <target state="translated">google.bigtable.project.id</target>
        </trans-unit>
        <trans-unit id="cc13179307b5e80e24bfb6d17ead8019ee886fc5" translate="yes" xml:space="preserve">
          <source>google.bigtable.zone.name</source>
          <target state="translated">google.bigtable.zone.name</target>
        </trans-unit>
        <trans-unit id="6f99ebe40786111b7cceba8dccba662029d1e094" translate="yes" xml:space="preserve">
          <source>grep</source>
          <target state="translated">grep</target>
        </trans-unit>
        <trans-unit id="efb22615df12aa7f71e4c5d9ccbcd20e67a8dacd" translate="yes" xml:space="preserve">
          <source>groupBy</source>
          <target state="translated">groupBy</target>
        </trans-unit>
        <trans-unit id="c6afddb4d91603863673224b68b3056dd717d128" translate="yes" xml:space="preserve">
          <source>groupByAggregator</source>
          <target state="translated">groupByAggregator</target>
        </trans-unit>
        <trans-unit id="e44c652e2bc0bcbf54a321c747dee2e504e97db2" translate="yes" xml:space="preserve">
          <source>groupByTime</source>
          <target state="translated">groupByTime</target>
        </trans-unit>
        <trans-unit id="cf55a9599e13a6dec304f2ef3513f6fd8fa184eb" translate="yes" xml:space="preserve">
          <source>h - Hours</source>
          <target state="translated">h-시간</target>
        </trans-unit>
        <trans-unit id="3fecdb00d68384740995d1d4d602d4b8eb4812e6" translate="yes" xml:space="preserve">
          <source>hbase.client.connection.impl</source>
          <target state="translated">hbase.client.connection.impl</target>
        </trans-unit>
        <trans-unit id="bf12ba0ea7920aee4052e5c37b3de046d84bbcf9" translate="yes" xml:space="preserve">
          <source>hbaseTime</source>
          <target state="translated">hbaseTime</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">help</target>
        </trans-unit>
        <trans-unit id="c807582f56ce0e2a7bc3727f595c5fa112eca3db" translate="yes" xml:space="preserve">
          <source>highestCurrent(&amp;lt;metric&amp;gt;,&amp;lt;n&amp;gt;)</source>
          <target state="translated">highestCurrent(&amp;lt;metric&amp;gt;,&amp;lt;n&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="e7175502d48a44fe479e54a57b6895c49cab1d3d" translate="yes" xml:space="preserve">
          <source>highestMax(&amp;lt;metric&amp;gt;,&amp;lt;n&amp;gt;)</source>
          <target state="translated">highestMax(&amp;lt;metric&amp;gt;,&amp;lt;n&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="86dd1cf45142e904cb2e99c2721fac3ca198c6ca" translate="yes" xml:space="preserve">
          <source>host</source>
          <target state="translated">host</target>
        </trans-unit>
        <trans-unit id="3cf9e785ff4811c0b87f7fbd4443d82407af7109" translate="yes" xml:space="preserve">
          <source>host=*,dc=lax</source>
          <target state="translated">host=*,dc=lax</target>
        </trans-unit>
        <trans-unit id="25f22f8350c5aefac09e607cc84181cc7d7d5071" translate="yes" xml:space="preserve">
          <source>host=web01</source>
          <target state="translated">host=web01</target>
        </trans-unit>
        <trans-unit id="2df581d02763416de733a273f309a9fe0eb3b7c1" translate="yes" xml:space="preserve">
          <source>host=web01 owner=jdoe</source>
          <target state="translated">호스트 = web01 소유자 = jdoe</target>
        </trans-unit>
        <trans-unit id="cdab9a695bcbd8854082b13edd1b1a6f2530d89c" translate="yes" xml:space="preserve">
          <source>host=web01.dal.mysite.com</source>
          <target state="translated">host=web01.dal.mysite.com</target>
        </trans-unit>
        <trans-unit id="561a24c17c5cf8651a76cc345396253e8baac455" translate="yes" xml:space="preserve">
          <source>host=web01.dal.mysite.com, owner=doe</source>
          <target state="translated">host = web01.dal.mysite.com, owner = doe</target>
        </trans-unit>
        <trans-unit id="5bf700b56826b8efdf7824152f98e24d7360ac1e" translate="yes" xml:space="preserve">
          <source>host=web02</source>
          <target state="translated">host=web02</target>
        </trans-unit>
        <trans-unit id="77b8a912d88d4966700ffdfa0b8553102d978f89" translate="yes" xml:space="preserve">
          <source>host=web03</source>
          <target state="translated">host=web03</target>
        </trans-unit>
        <trans-unit id="3747c621cc54403bfdcd8d79815d6358b53da38f" translate="yes" xml:space="preserve">
          <source>host=web04</source>
          <target state="translated">host=web04</target>
        </trans-unit>
        <trans-unit id="6007e764af356b3472405384b5f2888bede7bf7d" translate="yes" xml:space="preserve">
          <source>hours worked by an employee</source>
          <target state="translated">직원이 근무한 시간</target>
        </trans-unit>
        <trans-unit id="4aefcac1c6526980e5d37b0f4e6f52b2ed99be1e" translate="yes" xml:space="preserve">
          <source>hours.worked</source>
          <target state="translated">hours.worked</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">id</target>
        </trans-unit>
        <trans-unit id="356f93e02f0fb61e3f15b3d83c11f15ee0ee22ed" translate="yes" xml:space="preserve">
          <source>if you're using Varnish 2.x (which is not recommended as we would strongly encourage you to migrate to 3.x) you have to replace each function call &lt;code&gt;hash_data(foo);&lt;/code&gt; to set &lt;code&gt;req.hash += foo;&lt;/code&gt; in the VCL configuration above.</source>
          <target state="translated">Varnish 2.x를 사용하는 경우 (3.x로 마이그레이션하도록 강력히 권장하지 않으므로 권장하지 않음) 각 함수 호출을 교체해야합니다 &lt;code&gt;hash_data(foo);&lt;/code&gt; &lt;code&gt;req.hash += foo;&lt;/code&gt; 를 설정 하려면 + = foo; 위의 VCL 구성에서.</target>
        </trans-unit>
        <trans-unit id="e96f1994da3bd2b91b5d51333f4de7ae8bdcae2f" translate="yes" xml:space="preserve">
          <source>ilteral_or</source>
          <target state="translated">ilteral_or</target>
        </trans-unit>
        <trans-unit id="62fdfbd55d19b2a4671102ad7bca17d875f8207a" translate="yes" xml:space="preserve">
          <source>import</source>
          <target state="translated">import</target>
        </trans-unit>
        <trans-unit id="ea5166cd37d8a9db256bd0363dfc70118314a1ce" translate="yes" xml:space="preserve">
          <source>includeAggTags</source>
          <target state="translated">includeAggTags</target>
        </trans-unit>
        <trans-unit id="e540cdd1328b2b21e29a95405c301b9313b7c346" translate="yes" xml:space="preserve">
          <source>index</source>
          <target state="translated">index</target>
        </trans-unit>
        <trans-unit id="35dbeee2557cf5a762703d915858c46573218533" translate="yes" xml:space="preserve">
          <source>inflightBreached</source>
          <target state="translated">inflightBreached</target>
        </trans-unit>
        <trans-unit id="f7a660b70c6bca397a183acbda77a0a045edeffc" translate="yes" xml:space="preserve">
          <source>interface=eth0</source>
          <target state="translated">interface=eth0</target>
        </trans-unit>
        <trans-unit id="d897bf481c6d3038f32cd50b3a8b5f6cf56b6348" translate="yes" xml:space="preserve">
          <source>interrupted</source>
          <target state="translated">interrupted</target>
        </trans-unit>
        <trans-unit id="4b6914c620d2daa62ebe5994f36f361b3a759bf8" translate="yes" xml:space="preserve">
          <source>intersection</source>
          <target state="translated">intersection</target>
        </trans-unit>
        <trans-unit id="84f4675c98d93edd17ec2f6ed54e9f3ee1086612" translate="yes" xml:space="preserve">
          <source>interval</source>
          <target state="translated">interval</target>
        </trans-unit>
        <trans-unit id="017e3d699559508b1f649695bd3b104568dcb34e" translate="yes" xml:space="preserve">
          <source>is also okay, but not recommended) JSON parameter or query string flag and it will bypass down sampling (unless specified) and return all timestamps in Unix epoch millisecond resolution. Also, the &lt;code&gt;scan&lt;/code&gt; commandline utility will return the timestamp as written in storage.</source>
          <target state="translated">JSON 매개 변수 또는 쿼리 문자열 플래그도 괜찮습니다. 샘플링을 생략하고 (지정하지 않는 한) Unix epoch 밀리 초 해상도로 모든 타임 스탬프를 반환합니다. 또한 &lt;code&gt;scan&lt;/code&gt; 명령 줄 유틸리티는 스토리지에 기록 된 타임 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e198bafc877fefae0a0d5020566052ee9a49cbb" translate="yes" xml:space="preserve">
          <source>iwildcard</source>
          <target state="translated">iwildcard</target>
        </trans-unit>
        <trans-unit id="c455b38e076228392d1c751d14fe95da50519334" translate="yes" xml:space="preserve">
          <source>join</source>
          <target state="translated">join</target>
        </trans-unit>
        <trans-unit id="def0b140f03f857ea362eab215b3da5f740c15ac" translate="yes" xml:space="preserve">
          <source>jsonp</source>
          <target state="translated">jsonp</target>
        </trans-unit>
        <trans-unit id="8baa94b9eb9d8cdbad001ba02d92e63cc5922993" translate="yes" xml:space="preserve">
          <source>jsonp=callback</source>
          <target state="translated">jsonp=callback</target>
        </trans-unit>
        <trans-unit id="0ef25ae00f40c8471ee44b720036abcc25e96cee" translate="yes" xml:space="preserve">
          <source>kind</source>
          <target state="translated">kind</target>
        </trans-unit>
        <trans-unit id="b93e4cc0e468cfa94c40d341802b83416288622d" translate="yes" xml:space="preserve">
          <source>kind=metrics</source>
          <target state="translated">kind=metrics</target>
        </trans-unit>
        <trans-unit id="dfb7439f3062374e33329b50be099eeb9d1d14bd" translate="yes" xml:space="preserve">
          <source>kind=tagk</source>
          <target state="translated">kind=tagk</target>
        </trans-unit>
        <trans-unit id="d8bcc4703ee93b8e8d95745e2c56201316654d96" translate="yes" xml:space="preserve">
          <source>kind=tagv</source>
          <target state="translated">kind=tagv</target>
        </trans-unit>
        <trans-unit id="213ed3ea453bf610688ff8041e0a3b7b6abb5e6e" translate="yes" xml:space="preserve">
          <source>last</source>
          <target state="translated">last</target>
        </trans-unit>
        <trans-unit id="8bde6241aa14d9c2fb18a3b4efcd53f8adbe72e3" translate="yes" xml:space="preserve">
          <source>lastReceived</source>
          <target state="translated">lastReceived</target>
        </trans-unit>
        <trans-unit id="e6b0d4635e40ebf7418288dc387bb14a1ae0e326" translate="yes" xml:space="preserve">
          <source>lax</source>
          <target state="translated">lax</target>
        </trans-unit>
        <trans-unit id="841117513f5207a85011298832ca7037b432af53" translate="yes" xml:space="preserve">
          <source>leaves</source>
          <target state="translated">leaves</target>
        </trans-unit>
        <trans-unit id="ad60c535ff88e85bf0254452fe3934f24e9668d5" translate="yes" xml:space="preserve">
          <source>level</source>
          <target state="translated">level</target>
        </trans-unit>
        <trans-unit id="e4d68c5a97e466323c2fbe2b655ab578066a1cd5" translate="yes" xml:space="preserve">
          <source>limit</source>
          <target state="translated">limit</target>
        </trans-unit>
        <trans-unit id="306f2966b55ec9df17b9e0eefeea942d00d78d61" translate="yes" xml:space="preserve">
          <source>literal_or</source>
          <target state="translated">literal_or</target>
        </trans-unit>
        <trans-unit id="334389048b872a533002b34d73f8c29fd09efc50" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="486da61596d214851d41ab4464b607ab8733642e" translate="yes" xml:space="preserve">
          <source>m - Minutes</source>
          <target state="translated">m-분</target>
        </trans-unit>
        <trans-unit id="0b60224608c449f1f90ee4a4a046395ed573e4db" translate="yes" xml:space="preserve">
          <source>m or tsuids</source>
          <target state="translated">m 또는 tsuids</target>
        </trans-unit>
        <trans-unit id="688b30bc8e5317bcb6b8ecc957e2a49a0d5d09ba" translate="yes" xml:space="preserve">
          <source>making sure to end with a blank line. You can add more manifest information if you like. This is the bare minimum to satisfy plugin requirements.</source>
          <target state="translated">빈 줄로 끝나야합니다. 원하는 경우 매니페스트 정보를 더 추가 할 수 있습니다. 이것은 플러그인 요구 사항을 충족시키기위한 최소한의 것입니다.</target>
        </trans-unit>
        <trans-unit id="0706025b2bbcec1ed8d64822f4eccd96314938d0" translate="yes" xml:space="preserve">
          <source>max</source>
          <target state="translated">max</target>
        </trans-unit>
        <trans-unit id="b4442021d377cb623bbdef272bfeb438acf4f55c" translate="yes" xml:space="preserve">
          <source>max - An optional maximum number of results to return. The default is 25 and given values must be greater than 0.</source>
          <target state="translated">max-반환 할 선택적인 최대 결과 수입니다. 기본값은 25이며 제공된 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="81c5d49be9505089d8d248ea96f6d077fd0ab9bd" translate="yes" xml:space="preserve">
          <source>memory</source>
          <target state="translated">memory</target>
        </trans-unit>
        <trans-unit id="6f9b9af3cd6e8b8a73c2cdced37fe9f59226e27d" translate="yes" xml:space="preserve">
          <source>message</source>
          <target state="translated">message</target>
        </trans-unit>
        <trans-unit id="17f3467db103e03ea7354dd6da9a32c1ed2a07e8" translate="yes" xml:space="preserve">
          <source>messages</source>
          <target state="translated">messages</target>
        </trans-unit>
        <trans-unit id="cb030491157b26a570b6ee91e5b068d99c3b72f6" translate="yes" xml:space="preserve">
          <source>meta</source>
          <target state="translated">meta</target>
        </trans-unit>
        <trans-unit id="fba4184c97471f3a6191a3af089ee43f14ba4d37" translate="yes" xml:space="preserve">
          <source>metapurge</source>
          <target state="translated">metapurge</target>
        </trans-unit>
        <trans-unit id="0320e1e38b4e5f4c07f727b0a41ba0c2bebbcbfb" translate="yes" xml:space="preserve">
          <source>metasync</source>
          <target state="translated">metasync</target>
        </trans-unit>
        <trans-unit id="bfbaf8b2d1cdf92bf83857fe1748c0f68de03d47" translate="yes" xml:space="preserve">
          <source>method</source>
          <target state="translated">method</target>
        </trans-unit>
        <trans-unit id="15c3f21db033f3a8080a7523fa0447cea8585a24" translate="yes" xml:space="preserve">
          <source>method=put</source>
          <target state="translated">method=put</target>
        </trans-unit>
        <trans-unit id="aa0c92ca8cd36fcc9557aff33c6d83234ddc6c1a" translate="yes" xml:space="preserve">
          <source>method=scan</source>
          <target state="translated">method=scan</target>
        </trans-unit>
        <trans-unit id="cce1e70e53070c18b728ffb075ada682db114de5" translate="yes" xml:space="preserve">
          <source>method_override=delete</source>
          <target state="translated">method_override=delete</target>
        </trans-unit>
        <trans-unit id="2aa8dd50af1fa5748ea1dcf05102f95e63fcd1dd" translate="yes" xml:space="preserve">
          <source>method_override=post</source>
          <target state="translated">method_override=post</target>
        </trans-unit>
        <trans-unit id="47804c7c9bf1254e17ed5727102bfd4822b57f55" translate="yes" xml:space="preserve">
          <source>method_override=put</source>
          <target state="translated">method_override=put</target>
        </trans-unit>
        <trans-unit id="c5a39a3a7b3df7a7c25d3954cca5306e26c2073a" translate="yes" xml:space="preserve">
          <source>metric</source>
          <target state="translated">metric</target>
        </trans-unit>
        <trans-unit id="3c70a6e31e734ee672eb72958df26f0b333ec349" translate="yes" xml:space="preserve">
          <source>metric - A generic name for the time series such as &lt;code&gt;sys.cpu.user&lt;/code&gt;, &lt;code&gt;stock.quote&lt;/code&gt; or &lt;code&gt;env.probe.temp&lt;/code&gt;.</source>
          <target state="translated">metric- &lt;code&gt;sys.cpu.user&lt;/code&gt; , &lt;code&gt;stock.quote&lt;/code&gt; 또는 &lt;code&gt;env.probe.temp&lt;/code&gt; 와 같은 시계열의 일반적인 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="966b9734015a6d617d09dae170c907a100bded72" translate="yes" xml:space="preserve">
          <source>metrics</source>
          <target state="translated">metrics</target>
        </trans-unit>
        <trans-unit id="9bb610f6224ad54149157dd6ed4f50e46577af3b" translate="yes" xml:space="preserve">
          <source>mimmax</source>
          <target state="translated">mimmax</target>
        </trans-unit>
        <trans-unit id="19f61b7e3b8bf0d80f8108554b2742961f18a0ad" translate="yes" xml:space="preserve">
          <source>mimmin</source>
          <target state="translated">mimmin</target>
        </trans-unit>
        <trans-unit id="b6c935d4f3c7b220fa038613a1f9c1b56b255a86" translate="yes" xml:space="preserve">
          <source>min</source>
          <target state="translated">min</target>
        </trans-unit>
        <trans-unit id="478108dbd1f658359503addd9638d8e3095ff33c" translate="yes" xml:space="preserve">
          <source>mkmetric</source>
          <target state="translated">mkmetric</target>
        </trans-unit>
        <trans-unit id="efb18431a18389a54ddf17a8d29ca0791f70a869" translate="yes" xml:space="preserve">
          <source>mkmetric is a shortcut to the &lt;code&gt;uid assign metrics &amp;lt;metric&amp;gt;&lt;/code&gt; command where you can provide multiple metric names in a single call and UIDs will be assigned or retrieved. If any of the metrics already exist, the assigned UID will be returned.</source>
          <target state="translated">mkmetric은 단일 호출에서 여러 메트릭 이름을 제공 할 수 있는 &lt;code&gt;uid assign metrics &amp;lt;metric&amp;gt;&lt;/code&gt; 명령 의 바로 가기 이며 UID가 할당되거나 검색됩니다. 메트릭이 이미 있으면 할당 된 UID가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="550a7fbb732ca9ce1311fcfed266ec219b3a5522" translate="yes" xml:space="preserve">
          <source>movingAverage(&amp;lt;metric&amp;gt;,&amp;lt;window&amp;gt;)</source>
          <target state="translated">movingAverage(&amp;lt;metric&amp;gt;,&amp;lt;window&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="26cc3217be640e8220112c25628da6e11c78db95" translate="yes" xml:space="preserve">
          <source>ms</source>
          <target state="translated">ms</target>
        </trans-unit>
        <trans-unit id="d284da330c83f9125bb577857b28c233a983e645" translate="yes" xml:space="preserve">
          <source>ms - Milliseconds</source>
          <target state="translated">ms-밀리 초</target>
        </trans-unit>
        <trans-unit id="bee3749525306d28a33dd697a636a459bae96a77" translate="yes" xml:space="preserve">
          <source>msResolution (or ms)</source>
          <target state="translated">msResolution (또는 ms)</target>
        </trans-unit>
        <trans-unit id="44c56aa7176731ddc93694ae8f8ffc1788c7a8de" translate="yes" xml:space="preserve">
          <source>ms`</source>
          <target state="translated">ms`</target>
        </trans-unit>
        <trans-unit id="a40f0ad5e01638dccd0399c4515923a361e1c07e" translate="yes" xml:space="preserve">
          <source>multiplySeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</source>
          <target state="translated">multiplySeries(&amp;lt;metric&amp;gt;[,&amp;lt;metricN&amp;gt;])</target>
        </trans-unit>
        <trans-unit id="a53743bacf14055dfe04245f4cf3e4b35684a0f6" translate="yes" xml:space="preserve">
          <source>n - Months (30 days)</source>
          <target state="translated">n-월 (30 일)</target>
        </trans-unit>
        <trans-unit id="5efb4ac2212f109ebc889dc2a735f791dfc4119a" translate="yes" xml:space="preserve">
          <source>na</source>
          <target state="translated">na</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="78ee359464258aa746b3c005d807ccac3b4d5d71" translate="yes" xml:space="preserve">
          <source>name:sys.cpu.*</source>
          <target state="translated">name:sys.cpu.*</target>
        </trans-unit>
        <trans-unit id="11e623a37e87cf7995c466723ec99688d55cae8c" translate="yes" xml:space="preserve">
          <source>nan</source>
          <target state="translated">nan</target>
        </trans-unit>
        <trans-unit id="d982642c00a934c0ea242fef2adb115c557da4e3" translate="yes" xml:space="preserve">
          <source>newname</source>
          <target state="translated">newname</target>
        </trans-unit>
        <trans-unit id="57cfa7f941288ab210f80f513936aaddbfe83839" translate="yes" xml:space="preserve">
          <source>noAnnotations</source>
          <target state="translated">noAnnotations</target>
        </trans-unit>
        <trans-unit id="92be4aa1940f7a143e860afd85c1168c5155b1f0" translate="yes" xml:space="preserve">
          <source>no_annotations</source>
          <target state="translated">no_annotations</target>
        </trans-unit>
        <trans-unit id="71f8e7976e4cbc4561c9d62fb283e7f788202acb" translate="yes" xml:space="preserve">
          <source>none</source>
          <target state="translated">none</target>
        </trans-unit>
        <trans-unit id="8934268070d758174fe585719b02f3509b21599a" translate="yes" xml:space="preserve">
          <source>not_iliteral_or</source>
          <target state="translated">not_iliteral_or</target>
        </trans-unit>
        <trans-unit id="229f7ff16dea4f2e83e00ed82141e9719a1006ce" translate="yes" xml:space="preserve">
          <source>not_literal_or</source>
          <target state="translated">not_literal_or</target>
        </trans-unit>
        <trans-unit id="3add7b9612102f2a7dbe4ed4fe886e07e847c24d" translate="yes" xml:space="preserve">
          <source>notes</source>
          <target state="translated">notes</target>
        </trans-unit>
        <trans-unit id="c9bc849a968f2432684aca234f30596c5a91654f" translate="yes" xml:space="preserve">
          <source>now</source>
          <target state="translated">now</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="eeee9b9d7dfb75e03ceb8aba3c54b81c5e829202" translate="yes" xml:space="preserve">
          <source>numRunningQueries</source>
          <target state="translated">numRunningQueries</target>
        </trans-unit>
        <trans-unit id="3fa3b3086702a46dd922100856883a440d31f72c" translate="yes" xml:space="preserve">
          <source>opentsdb.conf</source>
          <target state="translated">opentsdb.conf</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
