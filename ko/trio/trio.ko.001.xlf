<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="bef2203120014b5ce1e1289eaeb349f7fcdca3b8" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2017 Nathaniel J. Smith</source>
          <target state="translated">&amp;copy; 2017 나다니엘 제이 스미스</target>
        </trans-unit>
        <trans-unit id="ec517f2497a37647b77da539c8fae55191e1180f" translate="yes" xml:space="preserve">
          <source>&amp;hellip;but sometimes things aren&amp;rsquo;t so simple, and this trick comes in handy.</source>
          <target state="translated">&amp;hellip; 때때로 일이 그렇게 간단하지 않은 경우가 많으며이 방법은 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4fb6d2402a1cbcb31359bea4775e8e1f08d418c1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Closing&amp;rdquo; a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; will close any pipes to the child and wait for it to exit; if cancelled, the child will be forcibly killed and we will ensure it has finished exiting before allowing the cancellation to propagate.</source>
          <target state="translated">&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; &amp;ldquo;닫는 중&amp;rdquo; 은 자식에 대한 모든 파이프를 닫고 종료 될 때까지 기다립니다. 취소하면 아동이 강제로 사망하며 취소가 전파되기 전에 종료가 완료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f0f4adc8aea427469a8601d79f1dcd868ba5e686" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Someone&amp;rdquo; calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task, and &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; returns or raises whatever value or error was passed to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;누군가&amp;rdquo; 는 현재 작업에서 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 호출 하고 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 에 전달 된 값이나 오류를 반환하거나 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ccf9abfb241d7f438ec2c11e44c2435737b57df1" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="d8c7444763b78bba23c7dd50562415180fa069af" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="d0f014a4da71f7c88640d008d942aaa519cd93be" translate="yes" xml:space="preserve">
          <source>(Remember how in the tutorial we emphasized the importance of the &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;async sandwich&amp;rdquo;&lt;/a&gt;, and the way it means that &lt;code&gt;await&lt;/code&gt; ends up being a marker that shows when you&amp;rsquo;re calling a function that calls a function that &amp;hellip; eventually calls one of Trio&amp;rsquo;s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we&amp;rsquo;re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</source>
          <target state="translated">(튜토리얼에서 우리가 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&quot;비동기 샌드위치&quot;&lt;/a&gt; 의 중요성을 강조한 방법을 기억하십시오 . 그리고 &lt;code&gt;await&lt;/code&gt; 방법 은 결국 함수를 호출하는 함수를 호출 할 때 표시되는 마커가됩니다. 비동기 함수의 전이 비동기의 전이는 파이썬이 부과하는 기술적 요구 사항이지만, 검사 점의 전이와 정확히 일치하므로이를 활용하여 검사 점을 추적 할 수 있습니다. ?)</target>
        </trans-unit>
        <trans-unit id="d296b42ed1d09870d027c1410c66d13e95252382" translate="yes" xml:space="preserve">
          <source>(Terminology: in Trio, &amp;ldquo;aborting&amp;rdquo; is the process of attempting to interrupt a blocked task to deliver a cancellation.)</source>
          <target state="translated">(용어 : Trio에서 &quot;중지&quot;는 차단 된 작업을 중단하여 취소를 전달하는 프로세스입니다.)</target>
        </trans-unit>
        <trans-unit id="de6b4e9bc8ed194603578653ce489207afc96512" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; is Trio&amp;rsquo;s &amp;ldquo;hazardous materials&amp;rdquo; layer: it contains APIs useful for introspecting and extending Trio. If you&amp;rsquo;re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 는 Trio의 &quot;유해 물질&quot;레이어입니다. Trio.introspecting 및 확장에 유용한 API가 포함되어 있습니다. 일상적인 일상 코드를 작성하는 경우이 모듈을 완전히 무시할 수 있습니다. 그러나 때로는 약간 낮은 수준의 무언가가 필요합니다. 다음은&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; 에&lt;/a&gt; 도달해야하는 상황의 예입니다.</target>
        </trans-unit>
        <trans-unit id="16172e29d7c65bbb8fa0ac4bcac9e89dc906f3a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; -에 해당 호출하면&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 동안 완료 &lt;code&gt;afn(*args)&lt;/code&gt; 다음 실행 &lt;code&gt;afn&lt;/code&gt; 가능성이 제기하는 것입니다&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을&lt;/a&gt; 하고,이에 보내집니다</target>
        </trans-unit>
        <trans-unit id="4522539e2495d37a3558c4aca9b0391fd5659005" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; - 해당 호출하는 경우&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 동안 완료 &lt;code&gt;afn(*args)&lt;/code&gt; 실행을, 다음 &lt;code&gt;afn&lt;/code&gt; 인상 가능성이&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을&lt;/a&gt; , 이것은로 보내집니다</target>
        </trans-unit>
        <trans-unit id="82a5777a254e3527db31e1099d99402997315cfe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 이미 닫은 경우</target>
        </trans-unit>
        <trans-unit id="5221ef4c341ee662700ec147b45ff87a5fc43280" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 객체를 이미 닫은 경우</target>
        </trans-unit>
        <trans-unit id="50829a08be317170d9f389e8760f1224e6c7231b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; also expose several more features beyond the core channel interface:</source>
          <target state="translated">&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 은 코어 채널 인터페이스를 넘어 몇 가지 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1191d82fd801b160f1e9a28e8ee8a9d0ce275626" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface. In order to make sure your process doesn&amp;rsquo;t end up getting abandoned by mistake or after an exception, you can use &lt;code&gt;async with&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스를구현합니다. 실수로 또는 예외 후에 프로세스가 중단되지 않도록하기 위해 다음 &lt;code&gt;async with&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="766c979a03f106b8bb33b1bc540b87ed5047ca18" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 해당 호출이 이미 완료된 경우</target>
        </trans-unit>
        <trans-unit id="d2116e282390c51e8b03416366342a5e08cc1519" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; -에 해당 호출하면&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 은&lt;/a&gt; 이미 완료했다.</target>
        </trans-unit>
        <trans-unit id="e4d06d67b4f7143ccd7e612116d631feb4897116" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; wraps around another Listener, and converts all incoming connections to encrypted connections by wrapping them in a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 는 다른 리스너를 감싸고 들어오는 모든 연결을&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 감싸서 암호화 된 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="27eb0e1aa9b6f01d4feddc5e9ef9d83ad48d2eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; wraps an arbitrary &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and allows you to perform encrypted communication over it using the usual &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface. You pass regular data to &lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, then it encrypts it and sends the encrypted data on the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; takes encrypted data out of the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and decrypts it before returning it.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 은 임의의&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 을&lt;/a&gt; 감싸고일반적인&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를사용하여 암호화 된 통신을 수행 할 수 있습니다. &lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 일반 데이터를 전달한 다음이를 암호화하고 기본&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에서 암호화 된 데이터를 전송합니다. &lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 은 기본&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에서 암호화 된 데이터를 가져 와서반환하기 전에 해독합니다.</target>
        </trans-unit>
        <trans-unit id="8d9019328b65e5c7fec599529982887ad00ddabc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; is a &amp;ldquo;stream adapter&amp;rdquo; that can take any object that implements the &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt; interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; around a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 은&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 모든 객체를 가져 와서암호화 된 스트림으로 변환 할수있는 &quot;스트림 어댑터&quot;입니다. 트리오에서 네트워크를 통해 말하다 SSL에 대한 표준 방법은 래핑하는 것입니다&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 전세계 거의&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39dc95c50403cd2d43435da845f9299acf4c54d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b9f488f7b849505fd8967b05648e0aff408e168" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9511dac7a7d7e0421ef833ef7c70c4edf0bb546" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt; wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; &lt;/a&gt; 은 네트워크를 통한 TCP 연결과 같은 원시 소켓을 래핑하여 표준 스트림 인터페이스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ae6277fd3b5f495c7e304f8c1c45ef5f868ae8e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects implement the methods in the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. They also have two additional public attributes:</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스에서 메소드를 구현합니다. 또한 두 가지 추가 공용 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c670588016ac1f9cc12493b77b445b2978d80770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b58648e3befd84ce4fcd29135a2a900554b16eca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; provides an alternative. We can rewrite our example like:</source>
          <target state="translated">&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt; 은 대안을 제공합니다. 다음과 같이 예제를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc2626d3ed97353c2976e470d8167af2d83cc59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt;&lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt;&lt;/a&gt; is a special global object with a do-nothing &lt;code&gt;started&lt;/code&gt; method. This way your function supports being called either like &lt;code&gt;await nursery.start(async_fn, arg1,
arg2)&lt;/code&gt; or directly like &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt;, and either way it can call &lt;code&gt;task_status.started()&lt;/code&gt; without worrying about which mode it&amp;rsquo;s in. Defining your function like this will make it obvious to readers that it supports being used in both modes.</source>
          <target state="translated">&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt; &lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt; &lt;/a&gt; 는 아무것도 &lt;code&gt;started&lt;/code&gt; 하지 않은메소드를가진 특별한 전역 객체입니다. 이렇게하면 함수가 &lt;code&gt;await nursery.start(async_fn, arg1, arg2)&lt;/code&gt; 와 같이 또는 &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt; 와 같이 호출되는 것을 지원하고 어떤 모드에 있는지 걱정하지 않고 &lt;code&gt;task_status.started()&lt;/code&gt; 를호출 할 수 있습니다. 이와 같이 함수를 정의하면 독자가 두 모드 모두에서 사용할 수 있음을 분명히 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2b2153e4fdf6d653827336465dc85f015afdc90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception is raised in this scope and caught by the context manager.</source>
          <target state="translated">&lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 범위에서&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 발생하여 컨텍스트 관리자가 발견 한 경우.</target>
        </trans-unit>
        <trans-unit id="b00c291635e865ead631ad77bb672261484f29e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an unexpected error is encountered inside Trio&amp;rsquo;s internal machinery. This is a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; &amp;ndash; Trio의 내부 기계에 예기치 않은 오류가 발생한 경우. 이것은 버그이며&lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt; 저희에게 알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="549feaf6540c3715124d879f456890f89951c201" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no tokens are available.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 사용 가능한 토큰이없는 경우.</target>
        </trans-unit>
        <trans-unit id="3f9ca7941e6449091fb63e720a3c660944189b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is currently held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 잠금이 유지 된 경우.</target>
        </trans-unit>
        <trans-unit id="dc0a5bb70c6ad1196434a26fc4621b6dd99c673f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 잠금이 유지 된 경우.</target>
        </trans-unit>
        <trans-unit id="849c0db0436a026adf0117e8229b6378d06e4c9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the value is zero.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 값이 0 인 경우</target>
        </trans-unit>
        <trans-unit id="9d933041f11b3862064d016fb63e7fd87b9bf8e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; objects guarantee that if their &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is cancelled, then they will still close the resource (albeit in a potentially ungraceful fashion). &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;aclose_forcefully()&lt;/code&gt;&lt;/a&gt; is a convenience function that exploits this behavior to let you force a resource to be closed without blocking: it works by calling &lt;code&gt;await resource.aclose()&lt;/code&gt; and then cancelling it immediately.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드가 취소 된 경우에도 리소스를 닫을수 있음을 보증합니다 (잠재적이지 않은 방식으로도). &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 는이 동작을 이용하여 리소스를 차단하지 않고 강제로 닫을 수 있도록하는 편리한 함수입니다. &lt;code&gt;await resource.aclose()&lt;/code&gt; 를 호출한 다음 즉시 취소하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d1c77ff1d57034f8744ad3c068e6cd1972fa4642" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902354761b623469449754ba405ab35807f70b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8bab82170865ea40192808e48763d40474bfdf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e0fccdabd247d7386e1ff9a0f28c9659425e93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects can be used in &lt;code&gt;async for&lt;/code&gt; loops. Each iteration will produce an arbitrary sized chunk of bytes, like calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some&lt;/code&gt;&lt;/a&gt; with no arguments. Every chunk will contain at least one byte, and the loop automatically exits when reaching end-of-file.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 객체는 &lt;code&gt;async for&lt;/code&gt; 루프에서 사용될 수 있습니다. 각 반복은인수없이&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some&lt;/code&gt; &lt;/a&gt; 를호출하는 것과 같이 임의의 크기의 바이트 청크를 생성합니다. 모든 청크에는 최소한 하나의 바이트가 포함되며 파일 끝에 도달하면 루프가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9c08869ed76667edaa59772101eee697d85a3831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14d3253b8802ee45d506acd8a102a38c9d357ad1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29f1ba8ee04eadcbae71b426c5b4c069cccaf21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a035426238cc1a5b76516260e0a92a86d67708e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d28528d08e13f2a598e7a5c2f5e861d2e65160d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a0c215248a8073bfb6e7bd36af3aa832920275a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85d41edb56002d937851f7956c119621d70006ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7777fb2718686935e4d26fd0d8f654ba9dc32d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; supports wrapping Unix files (such as a pipe or TTY) as a stream.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 은 파이프 나 TTY와 같은 Unix 파일을 스트림으로 래핑하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1651f3be898b718cb8da61e7478aa37060209193" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt;&lt;code&gt;RunVar&lt;/code&gt;&lt;/a&gt; objects are similar to context variable objects, except that they are shared across a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; rather than a single task.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt; &lt;code&gt;RunVar&lt;/code&gt; &lt;/a&gt; 객체는단일 작업이 아닌&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 단일 호출에서 공유된다는 점을 제외하고 컨텍스트 변수 객체와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="028c21704b3033e686082fe0983e0e4f6f9f902e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; and all the other cancellation facilities provided by Trio are ultimately implemented in terms of &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 및 Trio가 제공하는 다른 모든 취소 기능은 궁극적으로&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 객체로구현됩니다.</target>
        </trans-unit>
        <trans-unit id="5faaf57ec2674b73c0641070aa02d4d816051ce1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; starts a process in the background and returns a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object to let you interact with it. Using it requires a bit more code than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process&lt;/code&gt;&lt;/a&gt;, but exposes additional capabilities: back-and-forth communication, processing output as soon as it is generated, and so forth. It is modelled after the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt; 는 백그라운드에서 프로세스를 시작하고상호 작용할 수 있도록&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체를반환합니다. 이를 사용하려면&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process&lt;/code&gt; &lt;/a&gt; 보다 약간 더 많은 코드가 필요하지만, 앞뒤 통신, 생성되는 즉시 출력 처리 등의 추가 기능이 노출됩니다. 표준 라이브러리&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 모델로합니다.</target>
        </trans-unit>
        <trans-unit id="6597caa4903e6c646d0ff25b3284f9e477331f08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt; runs a process from start to finish and returns a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object describing its outputs and return value. This is what you should reach for if you want to run a process to completion before continuing, while possibly sending it some input or capturing its output. It is modelled after the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; with some additional features and safer defaults.</source>
          <target state="translated">&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; &lt;/a&gt; 는 프로세스를 처음부터 끝까지 실행하고 출력 및 반환 값을 설명하는&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다. 이것은 입력을 보내거나 출력을 캡처하는 동안 계속하기 전에 프로세스를 완료하기 위해 실행하려는 경우 도달해야하는 것입니다. 추가 기능과 더 안전한 기본값으로표준&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; 을모델로합니다.</target>
        </trans-unit>
        <trans-unit id="97ef0dba9d3e1bd15283cea463e9501d21dba9ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt; is an abstract class and cannot be instantiated directly; you get concrete socket objects by calling constructors like &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;. However, you can use it to check if an object is a Trio socket via &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; &lt;/a&gt; 은 추상 클래스이며 직접 인스턴스화 할 수 없습니다. &lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 과 같은 생성자를 호출하여 구체적인 소켓 객체를 얻습니다. 그러나 객체를 사용하여 &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; 통해 객체가 Trio 소켓인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce4adfdbfdc2bb800ee793718d23c2370de1bab3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; with a few tricks up its sleeve to help you efficiently test code involving timeouts:</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 은타임 아웃과 관련된 코드를 효율적으로 테스트하는 데 도움이되는 몇 가지 트릭을 가진&lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05e5c6ddb0d8d65635c282460582a76e6cd7126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, in turn, is implemented using the low-ish level classes &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. These are implementations of (you guessed it) &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt; that on their own, aren&amp;rsquo;t attached to anything &amp;ndash; &amp;ldquo;sending&amp;rdquo; and &amp;ldquo;receiving&amp;rdquo; just put data into and get data out of a private internal buffer that each object owns. They also have some interesting hooks you can set, that let you customize the behavior of their methods. This is where you can insert the evil, if you want it. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; takes advantage of these hooks in a relatively boring way: it just sets it up so that when you call &lt;code&gt;sendall&lt;/code&gt;, or when you close the send stream, then it automatically triggers a call to &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt;, which is a convenience function that takes data out of a &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer and puts it into a &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer. But that&amp;rsquo;s just the default &amp;ndash; you can replace this with whatever arbitrary behavior you want.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 하위 레벨 클래스&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현됩니다. 이것들은&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt; 과&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; 의&lt;/a&gt; 구현으로, 그 자체로는 아무것도 붙어 있지 않습니다 &amp;ndash;&amp;ldquo;보내기&amp;rdquo;와&amp;ldquo;받기&amp;rdquo;는 단지 데이터를 넣고 개인으로부터 데이터를 가져옵니다 각 객체가 소유 한 내부 버퍼. 또한 메소드의 동작을 사용자 정의 할 수있는 몇 가지 흥미로운 후크가 있습니다. 원하는 경우 악을 삽입 할 수 있습니다.&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 상대적으로 지루한 방식으로 이러한 후크를 활용합니다. &lt;code&gt;sendall&lt;/code&gt; 을 호출 할 때 설정됩니다.또는 전송 스트림을 닫으면 &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt; 호출이 자동으로 트리거됩니다. memory_stream_pump () 는 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 버퍼에서 데이터를 가져 와서 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 버퍼에 넣는 편리한 함수입니다 . 그러나 이것은 기본값 일뿐입니다. 원하는 임의의 동작으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5e9dba828116b86ced1fe89ee88168dd4d81c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; gives you a pair of connected, bidirectional streams. It&amp;rsquo;s like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but without any involvement from that pesky operating system and its networking stack.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 는 한 쌍의 연결된 양방향 스트림을 제공합니다. 그것은처럼&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; 있지만 그 성가신 운영 체제에서 참여와 네트워킹 스택없이.</target>
        </trans-unit>
        <trans-unit id="608590cb52eebdf3161902f8706901acac61ca21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt; used as the return value from abort functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt; &lt;code&gt;enum.Enum&lt;/code&gt; &lt;/a&gt;중단 함수의 리턴 값으로 사용되는 열거 .</target>
        </trans-unit>
        <trans-unit id="6402fdb9fc1a5631193223a95083a060da7e2668" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검사 점이 실행 된 경우</target>
        </trans-unit>
        <trans-unit id="f90e2933d92ae8a2459cc2bcf2cd6da6697d864d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a test fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 테스트에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="82d82d3e6eb3abe1e3946fd8f65ce6b023bd7885" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검사 점이 실행되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="220ac26f9cd9eb78e827fe89be8de614e42a8708" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no &lt;code&gt;trio_token&lt;/code&gt; was provided, and we can&amp;rsquo;t infer one from context.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;trio_token&lt;/code&gt; 이 제공되지 않아 컨텍스트에서 추론 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="c4b7b16bc7e58f53144d0aba28de13f544017169" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; &amp;ndash; Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; raises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;sync_fn(*args)&lt;/code&gt; 가무엇이든 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c66cac55224b866c757ccbd926086af93e8dbe90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the instrument is not currently active. This could occur either because you never added it, or because you added it and then it raised an unhandled exception and was automatically deactivated.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 계측기가 현재 활성화되어 있지 않은 경우 추가하지 않았거나 추가 한 후 처리되지 않은 예외가 발생하여 자동으로 비활성화 되었기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0789287a862ca78af3db9ec09864f9caee6d9ff8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is &lt;em&gt;enabled&lt;/em&gt; by default; if you want &lt;code&gt;sync_fn&lt;/code&gt; to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호는기본적으로&lt;em&gt; 활성화&lt;/em&gt; 되어 있습니다. 당신이 원하는 경우 &lt;code&gt;sync_fn&lt;/code&gt; 제어-C에 의해 인터럽트로, 당신은 사용할 필요가&lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로.</target>
        </trans-unit>
        <trans-unit id="d338b5dcc6a2ea187ea6e503786905d62394bb9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the handle is invalid, e.g. when it is already closed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 핸들이 유효하지 않은 경우 (예 : 핸들이 이미 닫힌 경우)</target>
        </trans-unit>
        <trans-unit id="1eb12bd422acc39baf4fc829d812f0628bebdc08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the socket file could not be connected to.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 소켓 파일을 연결할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="c9321e21ed7e147c3ad7da16f75cebd93a1ea481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an error is encountered starting or communicating with the process</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 프로세스 시작 또는 통신과 관련된 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="fe1846f55ded122f0371eb200f705368a43f5442" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the connection fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 연결에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="fd16cd8999185f6d888fdea658dd8fa4b7c2a88a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the process spawning fails, for example because the specified command could not be found.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 지정된 명령을 찾을 수 없어서 프로세스 생성이 실패한 경우</target>
        </trans-unit>
        <trans-unit id="fbf301bdc49ec83493d111216f646a567eac9758" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the underlying call to &lt;code&gt;accept&lt;/code&gt; raises an unexpected error.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;accept&lt;/code&gt; 을위한기본 호출로예기치 않은 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="81892ce0edb345342bb81a23b92e24b5a76b2e45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If AF_UNIX sockets are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; AF_UNIX 소켓이 지원되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="820245345a01caefa04db07ba22a6f2b08955270" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If this nursery is no longer open (i.e. its &lt;code&gt;async with&lt;/code&gt; block has exited).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 보육원이 더 이상 열려 있지 않은 경우 (예 :블록 &lt;code&gt;async with&lt;/code&gt; 의 비동기 가 종료 된 경우)</target>
        </trans-unit>
        <trans-unit id="05d203f34970a37d3b8654fc60575144620cd718" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;borrower&lt;/code&gt; 이미이 자루의 토큰 중 하나를 보유하고있는경우.</target>
        </trans-unit>
        <trans-unit id="9caa41b116381d44b1035bd6583d9b2734e0bd7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;borrower&lt;/code&gt; 태스크에 이미이 자루의 토큰 중 하나가있는경우.</target>
        </trans-unit>
        <trans-unit id="1523a22843113284427f0c91f6126a1a2875b26a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if not inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출에없는 경우.</target>
        </trans-unit>
        <trans-unit id="9229918d00657fe5d5a04b1e6686e28c8ea7f6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the calling task does not hold the lock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 호출 작업이 잠금을 보유하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="7ee4591b74dc354d3a927e5412ee4a989fbf872b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 작업에 이미이 자루의 토큰 중 하나가있는 경우.</target>
        </trans-unit>
        <trans-unit id="a28b63ca276986b36ae501abe3cb5e7f8942f1e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 작업이이 자루의 토큰 중 하나를 얻지 못한 경우.</target>
        </trans-unit>
        <trans-unit id="a7febb292cf405a27200ef3bde9ebf3b57367acd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the given borrower has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 주어진 차용자가이 자루의 토큰 중 하나를 얻지 못한 경우.</target>
        </trans-unit>
        <trans-unit id="85a07d923bf91b8e2edc651f5b71c48321c79d50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; Trio 스레드 내부에서이를 호출하려고하면 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c49c0535d85c7b0fde828d34a6e9b90598bccef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to use this anywhere except Python&amp;rsquo;s main thread. (This is a Python limitation.)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 파이썬의 메인 스레드를 제외한 다른 곳에서 이것을 사용하려고하면. 이것은 Python 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="da83362d474942ed0891ee40b74e3b969d32a746" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if any of the passed in objects are not instances of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; - 객체에서 전달 중의 인스턴스가 아닌 경우&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; 이&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e359768ef7fbd567a74c4408d6fd2e1dc9d6267b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;stdin&lt;/code&gt; is specified as a Unicode string, rather than bytes</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 이 바이트가 아닌 유니 코드 문자열로 지정된경우</target>
        </trans-unit>
        <trans-unit id="a88563ac21fdb3a838f11487d501cc35ef5e4a02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;em&gt; 초가&lt;/em&gt; 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="a61df9e89e060351c934beaaef21748cc2170785" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is negative.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;em&gt; 초가&lt;/em&gt; 음수 인경우</target>
        </trans-unit>
        <trans-unit id="1b01b5d6e9534f01004484190f2fdfa1fac4b540" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if incrementing the value would cause it to exceed &lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; - 값이 증가하는 원인이 경우는 초과&lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt; &lt;code&gt;max_value&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fdec5829d0e7488e736c422c9e29e0a932a83e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if multiple redirections are specified for the same stream, e.g., both &lt;code&gt;capture_stdout=True&lt;/code&gt; and &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 같은 스트림에 대해 여러 리디렉션이 지정된 경우 (예 : &lt;code&gt;capture_stdout=True&lt;/code&gt; 및 &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2d46a94b78faa648664980bba903f899cd3b403f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if timeout is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 시간 초과가 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="ac60b6da0a8198ebedacab39a16e315085e433dc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to pass a negative value for &lt;code&gt;seconds&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;seconds&lt;/code&gt; 음수 값을 전달하려고하면.</target>
        </trans-unit>
        <trans-unit id="afe3c25042b0b29f15a85aa8688cec2acdbadf92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt;&lt;code&gt;setdefaulttimeout()&lt;/code&gt;&lt;/a&gt;: instead, use Trio&amp;rsquo;s standard support for &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt; &lt;code&gt;setdefaulttimeout()&lt;/code&gt; &lt;/a&gt; : 대신,&lt;a href=&quot;reference-core#cancellation&quot;&gt; 취소 및 시간 초과에&lt;/a&gt; 대한 Trio의 표준 지원을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="348e9e4e99c81e1efbcca8c3f74caec5f6b5fad8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt;&lt;code&gt;getfqdn()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt; &lt;code&gt;getfqdn()&lt;/code&gt; &lt;/a&gt; : 쓸모없는; 사용&lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 의 플래그.</target>
        </trans-unit>
        <trans-unit id="db0936a9e91afbf5ae1135fd9360542a5d0606c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt;&lt;code&gt;gethostbyname()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt;&lt;code&gt;gethostbyname_ex()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt;&lt;code&gt;gethostbyaddr()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt; &lt;code&gt;gethostbyname()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt; &lt;code&gt;gethostbyname_ex()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt; &lt;code&gt;gethostbyaddr()&lt;/code&gt; &lt;/a&gt; : 폐기 됨; 사용&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="17d69c94218d1ebabadf6e649a8c2e3df496a1d5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt;&lt;code&gt;getservbyname()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt; &lt;code&gt;getservbyname()&lt;/code&gt; &lt;/a&gt; : 더 이상 사용되지 않는&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt; 버그&lt;/a&gt; ; 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5eacd97b4458f5aa1b57894879655db6e99850c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt;&lt;code&gt;getservbyport()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt; &lt;code&gt;getservbyport()&lt;/code&gt; &lt;/a&gt; : 쓸모없고&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt; 버그가있는&lt;/a&gt; ; 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b5eb0f9ecdc2cf9e2ee4edbc8624978be2e45ca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt;: Python&amp;rsquo;s file-like API is synchronous, so it can&amp;rsquo;t be implemented on top of an async socket.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt; : Python의 파일 유사 API는 동기식이므로 비동기 소켓 위에는 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9fd2568d3df3a54030ed0a7a247ae1b1458a624" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="64a9f06a1eda38f9e0eed41e97838ad4116deb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt;&lt;code&gt;recvmsg_into()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt; &lt;code&gt;recvmsg_into()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="b1886c3f9044cff76ab5db335decfb991adc0b02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt;&lt;code&gt;sendall()&lt;/code&gt;&lt;/a&gt;: Could be supported, but you&amp;rsquo;re better off using the higher-level &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, and specifically its &lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; method, which also does additional error checking.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt; &lt;code&gt;sendall()&lt;/code&gt; &lt;/a&gt; : 지원 될 수 있지만, 더 높은 수준의&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 과 특히&lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b80ffb80eda2ef62aa200fd82d0be12179b5658b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="bf8f587cd6689ebc86645620fca231f8542839a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt;&lt;code&gt;setblocking()&lt;/code&gt;&lt;/a&gt;: Trio sockets always act like blocking sockets; if you need to read/write from multiple sockets at once, then create multiple tasks.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt; &lt;code&gt;setblocking()&lt;/code&gt; &lt;/a&gt; : Trio 소켓은 항상 블로킹 소켓처럼 작동합니다. 여러 소켓에서 한 번에 읽기 / 쓰기가 필요한 경우 여러 작업을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ad8b8dcdfd05706ebbce9d91167f8e26de5f6cc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt;: see &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt; :대신&lt;a href=&quot;reference-core#cancellation&quot;&gt; 취소 및 시간 초과&lt;/a&gt; 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63172ffa4cb84d85aa2280ba0d689e49680e3cf7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;bytes&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;bytearray&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;바이트&lt;/a&gt; 또는 바이트 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;배열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a159b020f5a5f92930f5910448af6b6024ec6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="169c0c7f34d41eeaedba1af87df42a6c0801aba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;check=False&lt;/code&gt; is not passed and the process exits with a nonzero exit status</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;check=False&lt;/code&gt; 가 전달되지 않고 프로세스가 0이 아닌 종료 상태로 종료되는 경우</target>
        </trans-unit>
        <trans-unit id="45c49afc36a9666b9a231b13adcca1634eef0223" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; is not provided as a method on &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; objects; use &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; instead, or write the loop yourself if you have unusual needs. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; has quite unusual cancellation behavior in the standard library (on some platforms it spawns a background thread which continues to read from the child process even after the timeout has expired) and we wanted to provide an interface with fewer surprises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 은&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체에서 메소드로 제공되지 않습니다. 사용&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 대신하거나, 특별한 요구 사항이있는 경우 루프를 직접 작성합니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 은 표준 라이브러리에서 매우 비정상적인 취소 동작을 갖습니다 (일부 플랫폼에서는 시간 초과가 만료 된 후에도 하위 프로세스에서 계속 읽는 백그라운드 스레드를 생성 함).</target>
        </trans-unit>
        <trans-unit id="2f50b4f2871137e469bff365fb01f51208de17a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 채널이 손상된 경우</target>
        </trans-unit>
        <trans-unit id="f0979f0e1697acb335032a114b3342bce2855877" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken. For example, you may get this if the receiver has already been closed.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 채널이 손상된 경우 예를 들어, 수신기가 이미 닫힌 경우이 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6bb7cd4db6ec2b88972d932c91f5595667a94f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the stream is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 스트림이 손상된 경우</target>
        </trans-unit>
        <trans-unit id="b93fe7550e185e7bdcf056cf2aab816e875bc344" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 태스크가 이미이&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 에서 send_all () ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt; &lt;/a&gt; 를실행중인 경우</target>
        </trans-unit>
        <trans-unit id="c4baab643c3e32e1ea96c8a8b00719b50047605f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 를이 스트림에서실행중인 경우</target>
        </trans-unit>
        <trans-unit id="a2451843bb01fc131a8d404e2893ebcd1964f7fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become readable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미 주어진 소켓을 읽을 수 있도록 대기중인 경우</target>
        </trans-unit>
        <trans-unit id="ca0b61e8669b4d0cbf2a0227e7a1ecd7f2f0eea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become writable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미 주어진 소켓이 쓰기 가능해지기를 기다리는 경우.</target>
        </trans-unit>
        <trans-unit id="a7e3b99113902fc66735a64cb19e67c7bfc85de4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; on the same listener at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 두 작업이 같은 리스너에서&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 를 동시에호출하려고하는 경우.</target>
        </trans-unit>
        <trans-unit id="7a02bb442196558eb15b2a8fa432cccf8bd2cab8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; on the same stream at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 두 작업이 같은 스트림에서&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 를 동시에호출하려고하는 경우.</target>
        </trans-unit>
        <trans-unit id="77d6c6089e93746cb93c8d866005f76290c5d564" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 일부 채널에서는 여러 작업이 동시에&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있지만 다른 채널은 그렇지 않습니다. 이를 지원하지 않는 채널의 여러 작업에서 동시에&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 을 호출하려고하면&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt; 를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c202ed75f39c32ad05b7c4535716ce47ebdf27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 일부 채널에서는 여러 작업이 동시에&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 을 호출 할 수있지만 다른채널에서는그렇지 않습니다. 지원하지 않는 채널에서 여러 작업에서 동시에&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 을 호출하려고하면&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49b6f53c167deed4c6f74f872864d447920b7d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed the socket.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 이미 소켓을 닫은 경우</target>
        </trans-unit>
        <trans-unit id="33039c1212f13a8f732f7e2da9d59ab6907c8278" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task calls &lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt;&lt;code&gt;notify_closing()&lt;/code&gt;&lt;/a&gt; while this function is still working.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 함수가 여전히 작동하는 동안다른 태스크가&lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt; &lt;code&gt;notify_closing()&lt;/code&gt; &lt;/a&gt; 을호출하는 경우.</target>
        </trans-unit>
        <trans-unit id="739f1b24bdaf701e82803b6e061c7bba5c4ad049" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 이전에 닫은 경우</target>
        </trans-unit>
        <trans-unit id="663a046b61214a99317618df73de81f588f099ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; object, or if another task closes it while &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 가 실행되는동안 다른 작업에서 닫은 경우.</target>
        </trans-unit>
        <trans-unit id="bbd2472c216fa77160785a706f4a34fb23febe0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this listener object, or if another task closes this listener object while &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 이전에이 리스너 객체를 닫았거나&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 가 실행되는동안 다른 작업이이 리스너 객체를 닫는 경우</target>
        </trans-unit>
        <trans-unit id="afd68c5665d9d4aea771006164e62b59cd9b5100" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 오브젝트를 이전에 닫았거나&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 가 실행중인동안 다른 태스크가이 스트림 오브젝트를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="b28dacbe058ec2a8d8214f4169b49933e418573a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 작업에서이 스트림 객체를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="4f700d42049380feaaff1f42e46ee8e755181a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 오브젝트를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 태스크가이 스트림 오브젝트를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="b8815102cec16d6dd7a950d42fde656e3466c9f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 작업이이 스트림 객체를 닫은 경우.</target>
        </trans-unit>
        <trans-unit id="49dec4aedbef1954e897290d01837d539edf6748" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;trio.EndOfChannel&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the sender has been closed cleanly, and no more objects are coming. This is not an error condition.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;trio.EndOfChannel&lt;/code&gt; &lt;/a&gt; &amp;ndash; 발신자가 깨끗하게 닫히고 더 이상 개체가없는 경우 이것은 오류 조건이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ebe40cdb42b8ee71ac10e277e89b41a334433b37" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt;&lt;code&gt;trio.RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the associated call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already exited. (Any call that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; raise this error is guaranteed to be fully processed before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; exits.)</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt; &lt;code&gt;trio.RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 관련 호출이 이미 종료 된 경우 (이 오류를 발생&lt;em&gt; 시키지 않는&lt;/em&gt; 모든 호출은&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 종료되기 전에 완전히 처리되도록 보장됩니다.)</target>
        </trans-unit>
        <trans-unit id="53b89351a19b01031449bc62fdf5c0206532a0a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no data is available to retrieve.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검색 할 데이터가없는 경우.</target>
        </trans-unit>
        <trans-unit id="ad34061454ddafc79274fd334d162936866c646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; also accepts any &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; and passes them on to the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; constructor. This includes the &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; options, which provide additional redirection possibilities such as &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;, &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;, or file descriptors.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#subprocess-options&quot;&gt;일반 하위 프로세스 옵션&lt;/a&gt; 도 허용 하고이를 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 생성자 에 전달합니다 . 여기에는 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 옵션 이 포함되어 있으며 &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt; , &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt; 또는 파일 디스크립터 와 같은 추가 경로 재 지정 가능성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3764750810169a9d10ba875c5f1a6c7742a2021f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; Other &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; are also accepted.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash; 다른 &lt;a href=&quot;#subprocess-options&quot;&gt;일반 하위 프로세스 옵션&lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="41febbb3b0834802a6746a8f5643cd9a2661975f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; &amp;ndash; Positional arguments to pass to sync_fn. If you need keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; &amp;ndash; sync_fn에 전달할 위치 인수. 키워드 인수가 필요한 경우 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6494d56ff44c758f33670f78cf4b315c1ac6a7ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash; if &lt;code&gt;async_fn&lt;/code&gt; raises an exception, then &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; propagates it.</source>
          <target state="translated">&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash; &lt;code&gt;async_fn&lt;/code&gt; 에서 예외가 발생하면 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이이를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="083b984922795569d238527957c899850bfdf049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EMFILE&lt;/code&gt;: process is out of file descriptors</source>
          <target state="translated">&lt;code&gt;EMFILE&lt;/code&gt; : 프로세스에 파일 설명자가 없습니다</target>
        </trans-unit>
        <trans-unit id="e6185dc2a89485bb87a58b6a4de5be31b3888068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENFILE&lt;/code&gt;: system is out of file descriptors</source>
          <target state="translated">&lt;code&gt;ENFILE&lt;/code&gt; : 시스템에 파일 설명자가 없습니다</target>
        </trans-unit>
        <trans-unit id="aa0e28c33bc1490f1c0a230755aa6bd6eeabb6cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;: the kernel hit some sort of memory limitation when trying to create a socket object</source>
          <target state="translated">&lt;code&gt;ENOBUFS&lt;/code&gt; , &lt;code&gt;ENOMEM&lt;/code&gt; : 소켓 객체를 만들려고 할 때 커널이 일종의 메모리 제한에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="d1ebb1933006763cb904d2510939655ae79810f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aenter__&lt;/code&gt;, &lt;code&gt;__aexit__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aenter__&lt;/code&gt; , &lt;code&gt;__aexit__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d9542cd2795bd32a4641b28995e15220369c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aiter__&lt;/code&gt;, &lt;code&gt;__anext__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aiter__&lt;/code&gt; , &lt;code&gt;__anext__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f721b10bca9ebf38d8f9a3b21ed2543d633607e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort_func&lt;/code&gt; &amp;ndash; Same as for &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, except that it must return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. (If it returned &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, then Trio would attempt to reschedule the detached task directly without going through &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt;, which would be bad.) Your &lt;code&gt;abort_func&lt;/code&gt; should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback, if possible.</source>
          <target state="translated">&lt;code&gt;abort_func&lt;/code&gt; -에 관해서는 동일 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; , 그것은 반환해야한다는 점을 제외하고 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; . (이 반환 된 경우 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; , 다음 트리오 직접 통하지 않고 분리 작업을 다시 예약하려고 시도합니다 &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 나쁜 것이다.) 당신의 &lt;code&gt;abort_func&lt;/code&gt; 를 는 여전히 코 루틴 객체가 취소하려는 작업을 정렬 한 다음 다시 연결해야합니다. 가능한 경우 &lt;code&gt;raise_cancel&lt;/code&gt; 콜백 을 Trio하고 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc87db35f7da4123b104b2897e7467f605432bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments for &lt;code&gt;async_fn&lt;/code&gt;. If you want to pass keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash; &lt;code&gt;async_fn&lt;/code&gt; 의 위치 인수 . 키워드 인수를 전달하려면 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f222164120ff2300840b55152e8406e1404dbe95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments to be passed to &lt;em&gt;async_fn&lt;/em&gt;. If you need to pass keyword arguments, then use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash; &lt;em&gt;async_fn에&lt;/em&gt; 전달할 위치 인수 . 키워드 인수를 전달해야하는 경우 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23a7b12dd1ab3f6f8a5d8f9fc0a01d9470689cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async callable.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; 비동기 호출 가능.</target>
        </trans-unit>
        <trans-unit id="6c052d400da7804ef69953fd35006966364a4f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async function.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; 비동기 함수</target>
        </trans-unit>
        <trans-unit id="d16ff931501131ab166e17998e960d09e520902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autojump_threshold&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;autojump_threshold&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초기 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5cad07808ed4a54386ed965aafec76c4909fc661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; &amp;ndash; The listen backlog, or None to have a good default picked. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; &amp;ndash; 수신 백 로그 또는 기본값을 적절하게 선택하려면 없음. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달 .</target>
        </trans-unit>
        <trans-unit id="eca11bd3398470cc2c5ce63c03786d3b1c4e8b0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64c93d1c8e192537d2c9150114742d87244de77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listen backlog to use. If you leave this as &lt;code&gt;None&lt;/code&gt; then Trio will pick a good default. (Currently: whatever your system has configured as the maximum backlog.)</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 사용할 청취 백 로그입니다. 이것을 그대로두면 &lt;code&gt;None&lt;/code&gt; 으로 Trio가 좋은 기본값을 선택합니다. (현재 : 시스템이 최대 백 로그로 구성한 모든 내용)</target>
        </trans-unit>
        <trans-unit id="ea4466c20b949ea4de4e437c5d6e61f834979d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowed_tokens&lt;/code&gt;: The number of tokens currently borrowed from the sack.</source>
          <target state="translated">&lt;code&gt;borrowed_tokens&lt;/code&gt; : 현재 자루에서 빌린 토큰 수.</target>
        </trans-unit>
        <trans-unit id="f6feab6d08fc0dda319bdf0f73f68dcba1e57757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token. This is used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; to allow threads to &amp;ldquo;hold tokens&amp;rdquo;, with the intention in the future of using it to &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;allow deadlock detection and other useful things&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 차용 한 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 객체입니다. 이것은에 의해 사용되는 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 하는 데 사용하는 미래의 의도로, &quot;보류 토큰&quot;에 실을 수 있도록 &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;교착 상태 감지 및 기타 유용한 일을 할 수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63ae0d201a862df2c367dba8dbfef938bd550ac5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token; see &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt;&lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 차용 한 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 객체. &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt; &lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c743acc9bc3e0874e5e27c3b6b53de4664abf68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowers&lt;/code&gt;: A list of all tasks or other entities that currently hold a token.</source>
          <target state="translated">&lt;code&gt;borrowers&lt;/code&gt; : 현재 토큰을 보유하고있는 모든 업무 또는 기타 실체의 목록.</target>
        </trans-unit>
        <trans-unit id="1ca252a9fc4a071afa1f0757fac085d9e3af70bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;broken1&lt;/code&gt; raises &lt;code&gt;KeyError&lt;/code&gt;. &lt;code&gt;broken2&lt;/code&gt; raises &lt;code&gt;IndexError&lt;/code&gt;. Obviously &lt;code&gt;parent&lt;/code&gt; should raise some error, but what? In some sense, the answer should be &amp;ldquo;both of these at once&amp;rdquo;, but in Python there can only be one exception at a time.</source>
          <target state="translated">&lt;code&gt;broken1&lt;/code&gt; 은 &lt;code&gt;KeyError&lt;/code&gt; 를 발생 시킵니다. &lt;code&gt;broken2&lt;/code&gt; 이 제기 &lt;code&gt;IndexError&lt;/code&gt; 를 . 분명히 &lt;code&gt;parent&lt;/code&gt; 는 약간의 오류를 제기해야하지만 무엇입니까? 어떤 의미에서 대답은 &quot;한 번에 둘 다&quot;여야하지만 Python에서는 한 번에 하나의 예외 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6eac22d9cac1a7ccb41256738a04eb6479e905d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cancellable&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether to allow cancellation of this operation. See discussion below.</source>
          <target state="translated">&lt;code&gt;cancellable&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;부울&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 작업을 취소 할 수 있는지 여부입니다. 아래 토론을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8460d73c85eb9a74fa84dacb8fc1250ae2e1d5e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stderr&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard error stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stderr&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; true이면 서브 프로세스가 표준 오류 스트림에 쓰는 바이트를 캡처 하여 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성으로 리턴합니다. 오브젝트 합니다.</target>
        </trans-unit>
        <trans-unit id="f9d55fd3be056b54509b1cd066b363be0eb761cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stdout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard output stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stdout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; true이면 서브 프로세스가 표준 출력 스트림에 쓰는 바이트를 캡처 하여 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 속성으로 리턴합니다. 오브젝트 .</target>
        </trans-unit>
        <trans-unit id="26e5c9c34fe9d980bcf61b99ecb8d833e5c6a87f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If false, don&amp;rsquo;t validate that the subprocess exits successfully. You should be sure to check the &lt;code&gt;returncode&lt;/code&gt; attribute of the returned object if you pass &lt;code&gt;check=False&lt;/code&gt;, so that errors don&amp;rsquo;t pass silently.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; false 인 경우 서브 프로세스가 성공적으로 종료되는지 검증하지 마십시오. &lt;code&gt;check=False&lt;/code&gt; 를 전달하면 반환 된 객체 의 &lt;code&gt;returncode&lt;/code&gt; 속성 을 확인해야합니다. 하면 오류가 자동으로 전달되지 않도록 .</target>
        </trans-unit>
        <trans-unit id="198b0222758f8b2ab4eae3d94ae5d1370fc0fc2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clock&lt;/code&gt; &amp;ndash; &lt;code&gt;None&lt;/code&gt; to use the default system-specific monotonic clock; otherwise, an object implementing the &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;trio.abc.Clock&lt;/code&gt;&lt;/a&gt; interface, like (for example) a &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; &amp;ndash; 기본 시스템 별 단조로운 시계를 사용 &lt;code&gt;None&lt;/code&gt; . 그렇지 않으면, 예를 들어 &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;trio.abc.Clock&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체 인스턴스 입니다.</target>
        </trans-unit>
        <trans-unit id="860eda59b396acc32f124935a38e145c0d3045f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash; Either None, or an async function similar to stream_maker, but with the extra property that the returned stream is in a state where &lt;code&gt;send_all&lt;/code&gt; and &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; will block until &lt;code&gt;receive_some&lt;/code&gt; has been called. This allows for more thorough testing of some edge cases, especially around &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash; 없음 또는 stream_maker와 유사한 비동기 함수이지만, &lt;code&gt;receive_some&lt;/code&gt; 이 호출 될 때까지 &lt;code&gt;send_all&lt;/code&gt; 및 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 이 차단 되는 상태에 리턴 된 스트림이 추가되는 추가 특성이 있습니다. 이를 통해 특히 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 주변의 일부 엣지 케이스를보다 철저히 테스트 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e779fb27fea43c8724925ef19c2fe9fd192b6d5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; 동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에서 호출. 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a2c41d8353693c8e391e1e84e166ceb5376daec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; 동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0ec103234df050921b19320c94e21db604369a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The command to run. Typically this is a sequence of strings such as &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt;, where the first element names the executable to invoke and the other elements specify its arguments. With &lt;code&gt;shell=True&lt;/code&gt; in the &lt;code&gt;**options&lt;/code&gt;, or on Windows, &lt;code&gt;command&lt;/code&gt; may alternatively be a string, which will be parsed following platform-dependent &lt;a href=&quot;#subprocess-quoting&quot;&gt;quoting rules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행할 명령입니다. 일반적으로 이것은 &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt; 같은 일련의 문자열입니다 . 여기서 첫 번째 요소는 호출 할 실행 파일의 이름을 지정하고 다른 요소는 해당 인수를 지정합니다. &lt;code&gt;**options&lt;/code&gt; 또는 Windows 에서 &lt;code&gt;shell=True&lt;/code&gt; 를 사용하면 &lt;code&gt;command&lt;/code&gt; 은 문자열 일 수 있으며 플랫폼에 따라 달라지는 &lt;a href=&quot;#subprocess-quoting&quot;&gt;인용 규칙에&lt;/a&gt; 따라 구문 분석 됩니다. .</target>
        </trans-unit>
        <trans-unit id="40140e686bf510b2f8293cc2dd5df21d12c89cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to move.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 이동할 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="0379bcb0cf80c0ae9106a2c0e8751a5cad9def29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to unpark.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 해제 할 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="690dccb2485b6c1efd90c85b494cf8f0b08f1e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_buffer_used&lt;/code&gt;: The number of items currently stored in the channel buffer.</source>
          <target state="translated">&lt;code&gt;current_buffer_used&lt;/code&gt; : 채널 버퍼에 현재 저장된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="dadcc8231dcf4bb29a9204af389689c14e03ab19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The data to send.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송할 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="9e0bcc2df98273163a158aa7256e7c594257e9ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The absolute time of the next deadline, according to this clock.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 시계에 따른 다음 마감 시간의 절대 시간.</target>
        </trans-unit>
        <trans-unit id="6fb54f7efa2bdbb464a3fe3aba7d3a68dc645d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The deadline.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 마감일.</target>
        </trans-unit>
        <trans-unit id="8667fcbc6dd78d180064c9e81498909f565d4887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The time at which we should wake up again. May be in the past, in which case this function executes a checkpoint but does not block.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 다시 일어날 시간. 과거에있을 수 있습니다.이 경우이 함수는 검사 점을 실행하지만 차단하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="77800851c9fc95abd8c97c6f9ad88ec4eff08a62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exceptions&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The exceptions</source>
          <target state="translated">&lt;code&gt;exceptions&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 예외</target>
        </trans-unit>
        <trans-unit id="d5fa2991cffd7cd3200dc0f2e56873f167c346ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fd&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The fd to be wrapped.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;INT&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 줄 바꿈 할 fd입니다.</target>
        </trans-unit>
        <trans-unit id="6415289b25910c926cfd7391cdb9f60b2e28f3d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; &amp;ndash; a &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0bf27129b492aab1ef62b22db0bcaa1bf5497cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The filename to open the connection to.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결을 열 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="87836835d2fe68db69d0949466e77097175300f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final_outcome&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Trio acts as if the current task exited with the given return value or exception.</source>
          <target state="translated">&lt;code&gt;final_outcome&lt;/code&gt; ( &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;result.Outcome&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; Trio는 현재 작업이 주어진 반환 값 또는 예외로 종료 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="157ed0b8e932f730a0991b1a4ea88e6876050de6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle&lt;/code&gt; &amp;ndash; A Win32 object handle, as a Python integer.</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; &amp;ndash; Python 정수로서의 Win32 객체 핸들.</target>
        </trans-unit>
        <trans-unit id="e1f256647adeb8c7357b02329e2fb43f4013fc47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; A callable that takes an atomic (non-MultiError) exception as input, and returns either a new exception object or None.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 원 자성 (MultiError가 아닌) 예외를 입력으로 받아서 새 예외 개체 또는 없음을 반환하는 호출 가능 개체입니다.</target>
        </trans-unit>
        <trans-unit id="e21bd96821ba01f78d8d00051deaba8766ae0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; An async callable, that will be invoked like &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; for each incoming connection.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 각각의 들어오는 연결에 대해 &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; 과 같이 호출되는 비동기 호출 가능 .</target>
        </trans-unit>
        <trans-unit id="a3090b03f0ea95979f385025f5e9b720564d49b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; The handler to start for each incoming connection. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 들어오는 각 연결에 대해 시작할 핸들러입니다. &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 전달 .</target>
        </trans-unit>
        <trans-unit id="fc9c1209bc96d45713b43b4c11b9c22fcd87dff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; as for &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56eeeda767ac09256570229477d193d581421b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery to start handlers in, or None to use an internal nursery. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; 처리기를 시작하는 종묘장 또는 내부 종묘장을 사용하는 종은 없습니다. &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4af545c35c53e61365a8ac2fa1e98f8b1d35398e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery used to start handlers, or any object with a &lt;code&gt;start_soon&lt;/code&gt; method. If &lt;code&gt;None&lt;/code&gt; (the default), then &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; will create a new nursery internally and use that.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; 핸들러 또는 &lt;code&gt;start_soon&lt;/code&gt; 메소드를 사용하는 오브젝트를 시작하는 데 사용되는 보육 입니다. 만약 &lt;code&gt;None&lt;/code&gt; (기본값), 다음 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 내부적으로 새로운 보육을 작성하지 않고 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bebdc09baf7871b5bce3ae32b267627c6ae9fe02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt; if you want to limit to only one connection attempt at a time (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt;&lt;code&gt;socket.create_connection()&lt;/code&gt;&lt;/a&gt;). Default: 0.3 (300 ms).</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초조해 다른 연결을 병렬로 시작하기 전에 각 연결의 성공 또는 실패를 기다리는 시간 (초)입니다. &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; 로&lt;/a&gt; 설정&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt; &lt;code&gt;socket.create_connection()&lt;/code&gt; &lt;/a&gt; 과 같이 한 번에 한 번의 연결 시도로만 제한 . 기본값 : 0.3 (300ms)</target>
        </trans-unit>
        <trans-unit id="affa03c7e502c2fc86242cb0d11615285683394e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 참조&lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dbac9a1a6994581b4b38e452eec92143adbf0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. We require the server to have a TLS certificate valid for this hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;바이트&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt; str&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 호스트입니다. 서버에이 호스트 이름에 유효한 TLS 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f31351856ccab3985f0e467499257fe16d6e8cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. Can be an IPv4 address, IPv6 address, or a hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt; bytes&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 호스트입니다. IPv4 주소, IPv6 주소 또는 호스트 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85169f444121eecc3bcbc7a396753fa7e069ed42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 바인딩 할 주소입니다. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. 보다&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b00dff8ee9e060b0c31fa547f761bf83cd361d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 바인딩 할 주소입니다. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. 궁극적으로 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bc4d39307a6d0cd1247b70528e7586e71641b59a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host interface to listen on; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 호스트 인터페이스. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3396b6088cb6d8d54f175511526c66926034c4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;bytes-like&lt;/em&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;em&gt;bytes-like &lt;/em&gt;&lt;em&gt;또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None)&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="074be0b2389e540f899b65e8e67b72f995eaf623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hostname_resolver&lt;/code&gt; (&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom hostname resolver, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;hostname_resolver&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 사용자 정의 호스트 이름 확인자 또는 기본 동작을 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d50447b98e80a0aea797f5d7a937152a4614467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="5babef15cad79840bbc9adbb50fdc59ccaa1cac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Passed on to &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="27c5784b8bbd8392a7507a351b92d3c67de27f32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="187c968d569e623f5011cfb88a3f14e72456d0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you want to use &amp;ldquo;HTTPS-style&amp;rdquo; TLS. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;&amp;ldquo;HTTPS 스타일&amp;rdquo;TLS를 사용하려면이를 True로 설정하십시오. 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d55552e0dd68f23f3e02c52abf767ab3de478c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you&amp;rsquo;re connecting to a web server. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details. Default: False.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 웹 서버에 연결하는 경우이를 True로 설정하십시오. 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오. 기본값 : False</target>
        </trans-unit>
        <trans-unit id="5707c6a5ce826447ce17e91733c254fe69ab1010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initial_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; A non-negative integer giving semaphore&amp;rsquo;s initial value.</source>
          <target state="translated">&lt;code&gt;initial_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 세마포어의 초기 값을 제공하는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="14019ce35d114be701b9b9da974d5295aa5190b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 활성화 할 계측기입니다.</target>
        </trans-unit>
        <trans-unit id="55e2a6f69308acbcba045cfc0acd6c283a528e56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to de-activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 비활성화 할 계측기입니다.</target>
        </trans-unit>
        <trans-unit id="58bb2b928e47ff336aa159dab8cacf8b0830e93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instruments&lt;/code&gt; (list of &lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; objects) &amp;ndash; Any instrumentation you want to apply to this run. This can also be modified during the run; see &lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;Instrument API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;instruments&lt;/code&gt; ( &lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 객체 목록 ) &amp;ndash;이 런에 적용하려는 모든 계측 실행 중에도 수정할 수 있습니다. &lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;인스트루먼트 API를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae228be9cdd956ffb549d3563e530e30e9b16eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_statistics&lt;/code&gt; (object): Some statistics from Trio&amp;rsquo;s I/O backend. This always has an attribute &lt;code&gt;backend&lt;/code&gt; which is a string naming which operating-system-specific I/O backend is in use; the other attributes vary between backends.</source>
          <target state="translated">&lt;code&gt;io_statistics&lt;/code&gt; (객체) : Trio I / O 백엔드의 일부 통계입니다. 이것은 항상 속성이 있습니다 &lt;code&gt;backend&lt;/code&gt; / O 백엔드를 사용 운영 체제 관련 I 인 문자열의 이름이다; 다른 속성은 백엔드마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="caa0288e42c5ed7aa4d4abe45de8d1a8397f2ac7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limiter&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;em&gt;CapacityLimiter-like object&lt;/em&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;limiter&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;em&gt;CapacityLimiter와 유사한 객체&lt;/em&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="e6b3136ebabc2e2d4a623b203fdbb4407f1a6cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; A list of &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects. &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; takes responsibility for closing them.</source>
          <target state="translated">&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 객체 목록입니다 . &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 는이를 닫는 책임을집니다.</target>
        </trans-unit>
        <trans-unit id="603520e5b0c2ec38ba7849c079a95865966b8532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; (&lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the lock object to use. If given, must be a &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt;. If None, a new &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; will be allocated and used.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; ( &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 사용할 잠금 개체입니다. 주어진 경우, &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt; 이어야합니다 . None이면 새로운 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 이 할당되어 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f95ec20797af7c898f2ac2ba1019bff94a70685" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_statistics&lt;/code&gt;: The result of calling the underlying &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;#trio.Lock.statistics&quot;&gt;&lt;code&gt;statistics()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;lock_statistics&lt;/code&gt; : 기본 호출의 결과 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.Lock.statistics&quot;&gt; &lt;code&gt;statistics()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="618a487482254c3b69d5735a445c55798f94a09f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;locked&lt;/code&gt;: boolean indicating whether the lock is held.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; : 잠금 유지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="f10292d0fadb857c306a0dc5948de94c6800fa10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt;) &amp;ndash; The maximum number of items that can be buffered in the channel before &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; blocks. Choosing a sensible value here is important to ensure that backpressure is communicated promptly and avoid unnecessary latency; see &lt;a href=&quot;#channel-buffering&quot;&gt;Buffering in channels&lt;/a&gt; for more details. If in doubt, use 0.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt; ) &amp;ndash; &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 블록 전에 채널에서 버퍼링 할 수있는 최대 항목 수입니다 . 여기에서 합리적인 값을 선택하는 것은 배압이 신속하게 전달되고 불필요한 대기 시간을 피하기 위해 중요합니다. 참조 &lt;a href=&quot;#channel-buffering&quot;&gt;채널에서 버퍼링&lt;/a&gt; 자세한 내용은. 확실하지 않은 경우 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c36c15f6dc63bafb000356c2e369cf94cea73a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt;: The maximum number of items allowed in the buffer, as passed to &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; : &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 전달 될 때 버퍼에 허용되는 최대 항목 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fb8421a300b0d79f331765927482a9927d7ef8ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum number of bytes to return. Must be greater than zero. Optional; if omitted, then the stream object is free to pick a reasonable default.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 반환 할 최대 바이트 수입니다. 0보다 커야합니다. 선택 과목; 생략하면, 스트림 객체는 합리적인 기본값을 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d7e5bd2cb1a725ab3e6f7c27796809e159dfc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to retrieve. None (the default) means to retrieve all the data that&amp;rsquo;s present (but still blocks until at least one byte is available).</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 검색 할 최대 데이터 양. 없음 (기본값)은 존재하는 모든 데이터를 검색하는 것을 의미합니다 (그러나 1 바이트 이상을 사용할 수있을 때까지 여전히 차단됨).</target>
        </trans-unit>
        <trans-unit id="1c0b9268404ebe0c19a43e52b1e0a3c679151746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to transfer in this call, or None to transfer all available data.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 호출에서 전송할 최대 데이터 양 또는 사용 가능한 모든 데이터를 전송하려면 없음</target>
        </trans-unit>
        <trans-unit id="73ab6bec5c64069d56daa42b165b5ad34cc59b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If given, makes this a &amp;ldquo;bounded&amp;rdquo; semaphore that raises an error if the value is about to exceed the given &lt;code&gt;max_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 지정된 경우, 값이 지정된 &lt;code&gt;max_value&lt;/code&gt; 를 초과하려고하면 오류를 발생시키는 &quot;바운드&quot;세마포어로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a7f5017fe0d3b3ed322b7919d7d0f3d41211f091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to put data into.</source>
          <target state="translated">&lt;code&gt;memory_receive_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 데이터를 넣을 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="654314fb938a88ac66124f8a48ddf7ed1de7b204" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to get data from.</source>
          <target state="translated">&lt;code&gt;memory_send_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 데이터를 가져올 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="f87ec8fb8d6920675823afbf0256991664011220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of tasks to wake.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 깨우는 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="706088dfef3e603575862e367adff10e8633b7eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; &amp;ndash;이 작업의 이름입니다. 디버깅 / 검사에만 사용됩니다 (예 : &lt;code&gt;repr(task_obj)&lt;/code&gt; ). 이것이 문자열이 아닌 경우 &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt; 은 문자열 을 만들려고 시도합니다. 일반적인 사용 사례는 새 작업을 생성하기 전에 함수를 래핑하는 경우 디버깅을 쉽게하기 위해 원래 함수를 &lt;code&gt;name=&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f9eda5653f8aa6042815ed9751de5914613b1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; &amp;ndash;이 작업의 이름입니다. 디버깅 / 검사에만 사용됩니다 (예 : &lt;code&gt;repr(task_obj)&lt;/code&gt; ). 이것이 문자열이 아닌 경우 &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 는 문자열 을 만들려고 시도합니다. 일반적인 사용 사례는 새 작업을 생성하기 전에 함수를 래핑하는 경우 디버깅을 쉽게하기 위해 원래 함수를 &lt;code&gt;name=&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39ac8639a60221cedf2bb1578c2d5ec107ccc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_lot&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the parking lot to move tasks to.</source>
          <target state="translated">&lt;code&gt;new_lot&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 작업을 이동할 주차장입니다.</target>
        </trans-unit>
        <trans-unit id="35e6f7353e18ba4378af44a443eab3903e024291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_send&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the value (or error) to return (or raise) from &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next_send&lt;/code&gt; ( &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt; ) - 값 (또는 그 이상)의 리턴 (또는 레이즈) &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af7731c5998c5de2534323659b85fd3f1e7fa3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_receive_channels&lt;/code&gt;: Likewise, but for open &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; endpoints.</source>
          <target state="translated">&lt;code&gt;open_receive_channels&lt;/code&gt; : 마찬가지로 오픈 &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 엔드 포인트 용.</target>
        </trans-unit>
        <trans-unit id="264c8c4e59d3770d771de5e9cb09326c7244420f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_send_channels&lt;/code&gt;: The number of open &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; endpoints pointing to this channel. Initially 1, but can be increased by &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;open_send_channels&lt;/code&gt; : 이 채널을 가리키는 열린 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 엔드 포인트 수입니다 . 처음에는 1이지만 &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone()&lt;/code&gt; &lt;/a&gt; 의해 증가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f687cd0584184d32b7163dd5ec69eb308effa6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt;: the &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; currently holding the lock, or None if the lock is not held.</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; : 현재 잠금을 보유하고 있는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 잠금이 보류되지 않은 경우 없음.</target>
        </trans-unit>
        <trans-unit id="1201160a78a8e4af5f332f34959d7081ecbb90c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; &amp;ndash; 청취 할 포트입니다. 커널이 열린 포트를 선택하게하려면 0을 사용하십시오. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bbf694beba17ba8adf62f6d69c28af08e967d77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="6d4d205a129177b41813c6bde450d0de597a83b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to connect to.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 포트입니다.</target>
        </trans-unit>
        <trans-unit id="688b71efb4d8d1187d700c0a0a375d12061437c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 포트입니다. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6309fbbaf79fb15176a3bcd81d0cc6f8c70527f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 포트입니다. 커널이 열린 포트를 선택하게하려면 0을 사용하십시오. 궁극적으로 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="891c4fdd705213cb6ca14177bb92af31c1871a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rate&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rate&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초기 &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99c33b6b52375c26e1c14f1877e1ed8f50108db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 에서 호출되었습니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05cee52381c53f6a92a6ebb9f868a6940a98367b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for receiving.</source>
          <target state="translated">&lt;code&gt;receive_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 수신에 사용할 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="83019553ed11c5b0a2f12316aebdf4dfe58596ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="80c4c0dd0899149a98e2267e9e03ce41e17d8e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;root_exc&lt;/code&gt; &amp;ndash; An exception, often (though not necessarily) a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;root_exc&lt;/code&gt; - (아니더라도) 종종 예외하는 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23ac615251cbc92f776d4eb5dd37246a0f6e203a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int): The number of unprocessed callbacks queued via &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int) : &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 통해 대기중인 처리되지 않은 콜백 수입니다 .</target>
        </trans-unit>
        <trans-unit id="0a7302082e39ea79ec9eaeeeac0d9e7da2f2ba73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds to sleep. May be zero to insert a checkpoint without actually blocking.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 잠자는 시간 ( 초 )입니다. 실제로 차단하지 않고 검사 점을 삽입하려면 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ade4f6da2a5244cad20deaa5a3a696936a36b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The timeout.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="32fe1f6ae1e106de0d3baafe02009b4b950630f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of seconds to jump the clock forward.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 시계를 앞으로 이동하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="18d4f5b4bc1104d436c602e9f9a08574a1159caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; (float): The time until the next pending cancel scope deadline. May be negative if the deadline has expired but we haven&amp;rsquo;t yet processed cancellations. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; if there are no pending deadlines.</source>
          <target state="translated">&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; (float) : 다음 보류 보류 취소 범위 마감 시간까지의 시간입니다. 마감 기한이 만료되었지만 취소를 아직 처리하지 않은 경우 음수 일 수 있습니다. 수 있음 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 보류중인 기한이없는 경우.</target>
        </trans-unit>
        <trans-unit id="425704c4d337d3cfd23941c9ff81629105fbe7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64d4f7072233419756f70e991aa5c980c32bdd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for sending.</source>
          <target state="translated">&lt;code&gt;send_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송에 사용할 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="eaaf6a4ba68b4eabf4bb722fc4dec40bd05dc617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_hostname&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The name of the server being connected to. Used for &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; and for validating the server&amp;rsquo;s certificate (if hostname checking is enabled). This is effectively mandatory for clients, and actually mandatory if &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;server_hostname&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결중인 서버의 이름입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; 및 서버 인증서 유효성 검증에 사용됩니다 (호스트 이름 확인이 사용 가능한 경우). 이는 클라이언트에게 효과적으로 필수이며 &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 실제로 필수 입니다.</target>
        </trans-unit>
        <trans-unit id="5fce58df86f9353ab8c11cd3da5a14acf3b35213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_side&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether this stream is acting as a client or server. Defaults to False, i.e. client mode.</source>
          <target state="translated">&lt;code&gt;server_side&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 스트림이 클라이언트인지 서버인지를 나타냅니다. 기본값은 False, 즉 클라이언트 모드입니다.</target>
        </trans-unit>
        <trans-unit id="fd831c422b81adc17c1c840d7c7aa39b79546dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signals&lt;/code&gt; &amp;ndash; the signals to listen for.</source>
          <target state="translated">&lt;code&gt;signals&lt;/code&gt; &amp;ndash; 청취 할 신호.</target>
        </trans-unit>
        <trans-unit id="625912886efc60b616144fe727ff83d70132ecbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be connected.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash; 랩할 Trio 소켓 오브젝트. &lt;code&gt;SOCK_STREAM&lt;/code&gt; 유형이어야 하며 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2c1de1f3e683851cbc2557271aa46b50d8af5d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be listening.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash; 랩할 Trio 소켓 오브젝트. &lt;code&gt;SOCK_STREAM&lt;/code&gt; 유형이어야 하고 듣고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ce3d562bcdafe947f34d36bf33565287516fe229" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_factory&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom socket factory, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;socket_factory&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 사용자 정의 소켓 팩토리 또는 기본 동작을 복원하려면 None.</target>
        </trans-unit>
        <trans-unit id="bd2352b22dc29b6e0af410069d9b9b812fbb387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_listener&lt;/code&gt; (&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; to connect to.</source>
          <target state="translated">&lt;code&gt;socket_listener&lt;/code&gt; ( &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7938a9a43d222d0ab03f10ecc37e3195daae0b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; or None) &amp;ndash; The SSL context to use. If None (the default), &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; will be called to create a context.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 또는 None) &amp;ndash; 사용할 SSL 컨텍스트. None (기본값)이면 컨텍스트를 만들기 위해 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3044a40c6a954d50347bd2af50ae331d1a87b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; that will be used for incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 연결에 사용될 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d2fb8dccd8c914b1156c75e0c98d5855b88fb786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; used for this connection. Required. Usually created by calling &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 이 연결에 사용 된 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다. 필수입니다. 일반적으로 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 를 호출하여 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1ab419f61b2ec42100b332c8c5e546b3e229c548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 모든 연결에 사용할 SSL 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="7755b90b4b9fc8ce6579cc8ad4420b411fd8ae29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections. Passed to &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 모든 연결에 사용할 SSL 컨텍스트입니다. &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="47ae01c666f68b1ba6200b2b9ccda68490f6c9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stderr&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard error stream. An additional value &lt;code&gt;subprocess.STDOUT&lt;/code&gt; is supported, which causes the child&amp;rsquo;s standard output and standard error messages to be intermixed on a single standard output stream, attached to whatever the &lt;code&gt;stdout&lt;/code&gt; option says to attach it to.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 과 유사 하지만 하위 프로세스의 표준 오류 스트림 추가 값 &lt;code&gt;subprocess.STDOUT&lt;/code&gt; 이 지원되어 표준 표준 출력 스트림에서 하위 표준 출력 및 표준 오류 메시지가 혼합되어 &lt;code&gt;stdout&lt;/code&gt; 옵션에 첨부 된 내용에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="c233d6ac159ddccb9de47ea18b335506c1a26ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; &amp;ndash; Specifies what the child process&amp;rsquo;s standard input stream should connect to: output written by the parent (&lt;code&gt;subprocess.PIPE&lt;/code&gt;), nothing (&lt;code&gt;subprocess.DEVNULL&lt;/code&gt;), or an open file (pass a file descriptor or something whose &lt;code&gt;fileno&lt;/code&gt; method returns one). If &lt;code&gt;stdin&lt;/code&gt; is unspecified, the child process will have the same standard input stream as its parent.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; &amp;ndash; 하위 프로세스의 표준 입력 스트림에 연결해야하는 대상을 지정합니다. 상위 ( &lt;code&gt;subprocess.PIPE&lt;/code&gt; )에 의해 작성된 출력 , 아무것도 없음 ( &lt;code&gt;subprocess.DEVNULL&lt;/code&gt; ) 또는 열린 파일 (파일 설명자 또는 &lt;code&gt;fileno&lt;/code&gt; 메소드가 1을 리턴 하는 파일 전달 ). &lt;code&gt;stdin&lt;/code&gt; 을 지정하지 않으면 하위 프로세스는 상위 프로세스와 동일한 표준 입력 스트림을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="68f9d2012a908ef5a582d735d8be7fe63553ac43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, file descriptor, or None) &amp;ndash; The bytes to provide to the subprocess on its standard input stream, or &lt;code&gt;None&lt;/code&gt; if the subprocess&amp;rsquo;s standard input should come from the same place as the parent Trio process&amp;rsquo;s standard input. As is the case with the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module, you can also pass a file descriptor or an object with a &lt;code&gt;fileno()&lt;/code&gt; method, in which case the subprocess&amp;rsquo;s standard input will come from that file.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , file descriptor 또는 None) &amp;ndash; 표준 입력 스트림에서 서브 프로세스에 제공 할 바이트 또는 서브 프로세스의 표준 입력이 상위 Trio 프로세스의 표준 입력과 같은 위치에서 오는 경우 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈 의 경우와 같이 &lt;code&gt;fileno()&lt;/code&gt; 메소드를 사용 하여 파일 디스크립터 또는 오브젝트를 전달할 수도 있습니다 .이 경우 서브 프로세스의 표준 입력은 해당 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e980d52d16fce215767351c556fb552a1d5bffb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdout&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard output stream.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 과 유사 하지만 하위 프로세스의 표준 출력 스트림 용</target>
        </trans-unit>
        <trans-unit id="5307a9d2c47f82bfe292dd0f7ce82f7c44754b75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash; An async (!) function which returns a connected (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;) pair.</source>
          <target state="translated">&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash; 연결된 ( &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; ) 쌍 을 반환하는 비동기 (!) 함수</target>
        </trans-unit>
        <trans-unit id="dbaffedf99c9721b690ce581e56db550d6d1ce43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash; An arbitrary synchronous callable.</source>
          <target state="translated">&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash; 임의의 동기 호출 가능.</target>
        </trans-unit>
        <trans-unit id="0478602722f26cd556aa77b98959d5d47941b3ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The Trio task object that the current coroutine was detached from.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 현재 코 루틴이 분리 된 Trio 작업 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b8540abdbca36847f75a769a7abd2d0aeb3a94bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The finished task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 완료된 작업.</target>
        </trans-unit>
        <trans-unit id="9fe76481d8eeaa8a4dbfc030b4847cce9b1efec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 작업.</target>
        </trans-unit>
        <trans-unit id="d8ba5f2e7e8869d83cfd9584d7d5035aefd3d68c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that became runnable.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행 가능한 태스크입니다.</target>
        </trans-unit>
        <trans-unit id="e010b6c5f0a9add2aefa00fbb0bedba0ed588d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that is about to run.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행하려는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0e0338010b8d26f21da19458356f1578f75bde21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that just ran.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 방금 실행 한 작업.</target>
        </trans-unit>
        <trans-unit id="7c992fd8856aef4de8e76153f474f4c8723fe894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the task to be rescheduled. Must be blocked in a call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 다시 예약 할 작업. &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 에 대한 호출에서 차단되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae78f69e427f390674360603ae4a398cb896dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;, which will return &lt;code&gt;listeners&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; 은 -이 기능을 사용할 수 있습니다 &lt;code&gt;nursery.start&lt;/code&gt; 돌아갑니다, &lt;code&gt;listeners&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c2e8a6341af61c1b587cccedca6d25b6d39287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; -이 기능을 사용할 수 있습니다 &lt;code&gt;nursery.start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea5a3fe7122dd4cee3302c7652c5eb464ad1bdb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_living&lt;/code&gt; (int): The number of tasks that have been spawned and not yet exited.</source>
          <target state="translated">&lt;code&gt;tasks_living&lt;/code&gt; (int) : 생성되었지만 아직 종료되지 않은 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="739001bea8c2726faa18e2b481895d4d53e1551e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_runnable&lt;/code&gt; (int): The number of tasks that are currently queued on the run queue (as opposed to blocked waiting for something to happen).</source>
          <target state="translated">&lt;code&gt;tasks_runnable&lt;/code&gt; (int) : 현재 실행 큐에 대기중인 작업 수입니다 (일이 발생하기를 기다리는 동안 차단됨).</target>
        </trans-unit>
        <trans-unit id="e37bd999a2be9d0cca34acb9d5d7f7c484e06fb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 메소드에서 차단 된 작업 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fda1f91fcfe6da6aebf6c3579f8a0aea2a69bb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this condition&amp;rsquo;s &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 조건의 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1d6625cb145e1100cf7de52ec9dbb0be655857c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this event&amp;rsquo;s &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 이벤트의 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e3ad2f4331209803091e2db33eab0ce1205d0f5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lock&amp;rsquo;s &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 잠금의 &lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수 .</target>
        </trans-unit>
        <trans-unit id="88bbbe67dedd42251a847f6ee743ed43450b6469" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lot&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 로트의 &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 작업 수 .</target>
        </trans-unit>
        <trans-unit id="18db8acf9a54103d76ab78ccb127f37723ab2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this semaphore&amp;rsquo;s &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 세마포어의 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 작업 수 .</target>
        </trans-unit>
        <trans-unit id="92e56ab1340f6bde5ee56f317abacbf5eef96b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_receive&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;receive&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_receive&lt;/code&gt; : 이 채널 에서 &lt;code&gt;receive&lt;/code&gt; 이 차단 된 작업 수 (모든 클론에 대해 합산).</target>
        </trans-unit>
        <trans-unit id="0743f953431a2d7039e1416f4aef32455fe417ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_send&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;send&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_send&lt;/code&gt; : 이 채널 에서 &lt;code&gt;send&lt;/code&gt; 에서 차단 된 작업 수 (모든 클론에 대해 합산).</target>
        </trans-unit>
        <trans-unit id="b0cd806769a469c3eb7d185d3d55b124c346a956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we are willing to wait.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 기다릴 시간 ( 초)입니다.</target>
        </trans-unit>
        <trans-unit id="6772102160e6a83ff561040a822f5e931e792a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we were willing to wait. This much time may or may not have elapsed, depending on whether any I/O was ready.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 기다릴 시간 ( 초)입니다. I / O가 준비되었는지 여부에 따라이 많은 시간이 경과했거나 경과하지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8da86bd9fc94c0ef68f668c12ad19f82b44ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_tokens&lt;/code&gt;: The total number of tokens in the sack. Usually this will be larger than &lt;code&gt;borrowed_tokens&lt;/code&gt;, but it&amp;rsquo;s possibly for it to be smaller if &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; was recently decreased.</source>
          <target state="translated">&lt;code&gt;total_tokens&lt;/code&gt; : 자루의 총 토큰 수입니다. 일반적으로이보다 더 큰 것 &lt;code&gt;borrowed_tokens&lt;/code&gt; 하지만 경우가 작게에 대한 가능성의 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; 이&lt;/a&gt; 최근 감소 하였다.</target>
        </trans-unit>
        <trans-unit id="721ef0f3e300e7cf8f0edc1509d146331ba8b835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_listener&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;Listener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listener whose incoming connections will be wrapped in &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transport_listener&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;리스너&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 수신 연결이 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 으로 랩핑되는 리스너 입니다.</target>
        </trans-unit>
        <trans-unit id="3ed9c34eae37c5affb57d8b6c4c9bf845d60f0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream used to transport encrypted data. Required.</source>
          <target state="translated">&lt;code&gt;transport_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 암호화 된 데이터를 전송하는 데 사용되는 스트림입니다. 필수입니다.</target>
        </trans-unit>
        <trans-unit id="3dd6532c01255f0b97ed0d038d5e4c93bf4f8295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to send.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="37cab4c9f0aba80ee1245aa0200db8f3d11b2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3286b37b0ab654001d8174fc1c05a0b46882511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to yield to the current coroutine runner.</source>
          <target state="translated">&lt;code&gt;yield_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 현재 코 루틴 러너에게 산출 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e5296fdbf5d6b180a8671cf7d7109308b00db56b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Channels&lt;/em&gt; allow you to safely and conveniently send objects between different tasks. They&amp;rsquo;re particularly useful for implementing producer/consumer patterns.</source>
          <target state="translated">&lt;em&gt;채널을&lt;/em&gt; 사용하면 서로 다른 작업간에 개체를 안전하고 편리하게 보낼 수 있습니다. 생산자 / 소비자 패턴을 구현하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eca91e08a24f38ddbaffe627fc1ea7890d9eef8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fd&lt;/em&gt; must refer to a file that is open for reading and/or writing and supports non-blocking I/O (pipes and TTYs will work, on-disk files probably not). The returned stream takes ownership of the fd, so closing the stream will close the fd too. As with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt;&lt;code&gt;os.fdopen&lt;/code&gt;&lt;/a&gt;, you should not directly use an fd after you have wrapped it in a stream using this function.</source>
          <target state="translated">&lt;em&gt;fd&lt;/em&gt; 는 읽기 및 / 또는 쓰기를 위해 열려 있고 비 차단 I / O를 지원하는 파일을 참조해야합니다 (파이프 및 TTY는 작동하지만 디스크 파일은 작동하지 않을 수 있음). 리턴 된 스트림은 fd의 소유권을 가지므로 스트림을 닫으면 fd도 닫힙니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt; &lt;code&gt;os.fdopen&lt;/code&gt; &lt;/a&gt; 과 마찬가지로이 함수를 사용하여 스트림에 fd를 감싼 후에는 fd를 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3a449a1116492e7a682dcafdf8f3b0e17dad5450" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cancellation handling&lt;/strong&gt;: Cancellation is a tricky issue here, because neither Python nor the operating systems it runs on provide any general mechanism for cancelling an arbitrary synchronous function running in a thread. This function will always check for cancellation on entry, before starting the thread. But once the thread is running, there are two ways it can handle being cancelled:</source>
          <target state="translated">&lt;strong&gt;취소 처리&lt;/strong&gt; : 파이썬이나 운영 체제가 스레드에서 실행중인 임의의 동기 함수를 취소하는 일반적인 메커니즘을 제공하지 않기 때문에 취소는 까다로운 문제입니다. 이 기능은 스레드를 시작하기 전에 항상 입력 취소를 확인합니다. 그러나 스레드가 실행되면 취소를 처리 할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4033660c96d382fe67327d68e57a52697f397ff3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error checking:&lt;/strong&gt; If the subprocess exits with a nonzero status code, indicating failure, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; raises a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception rather than returning normally. The captured outputs are still available as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of that exception. To disable this behavior, so that &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; returns normally even if the subprocess exits abnormally, pass &lt;code&gt;check=False&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;오류 검사 :&lt;/strong&gt; 하위 프로세스가 실패를 나타내는 0이 아닌 상태 코드로 종료되면 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 정상적으로 반환되지 않고 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다. 캡처 된 출력은 해당 예외 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성 으로 계속 사용할 수 있습니다 . 하위 프로세스가 비정상적으로 종료 되더라도 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 가 정상적으로 리턴 되도록이 동작을 사용하지 않으려면 &lt;code&gt;check=False&lt;/code&gt; 를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="289917c607cf1cbd1dadecced88ba530f15b1d0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure what to do, then we recommend that you use async disk I/O by default,&lt;/strong&gt; because it makes your code more robust when conditions are bad, especially with regards to tail latencies; this improves the chances that what your users see matches what you saw in testing. Blocking the main thread stops &lt;em&gt;all&lt;/em&gt; tasks from running for that time. 10,000 &amp;micro;s is 10 ms, and it doesn&amp;rsquo;t take many 10 ms glitches to start adding up to &lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;real money&lt;/a&gt;; async disk I/O can help prevent those. Just don&amp;rsquo;t expect it to be magic, and be aware of the tradeoffs.</source>
          <target state="translated">&lt;strong&gt;수행 할 작업이 확실하지 않은 경우 기본적으로 비동기 디스크 I / O를 사용하는 것이 좋습니다. 비동기&lt;/strong&gt; 테일 &lt;strong&gt;I / O&lt;/strong&gt; 는 특히 테일 대기 시간과 관련하여 조건이 나쁠 때 코드를 더욱 강력하게하기 때문입니다. 이렇게하면 사용자가 보는 것이 테스트에서 본 것과 일치 할 가능성이 높아집니다. 메인 스레드를 차단하면 해당 시간 동안 &lt;em&gt;모든&lt;/em&gt; 작업이 실행되지 않습니다 . 10,000 &amp;micro;s는 10ms이며 &lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;실제 돈을&lt;/a&gt; 더하기 위해 많은 10ms의 글리치가 필요하지 않습니다 . 비동기 디스크 I / O는이를 방지 할 수 있습니다. 마법이 될 것으로 기대하지 말고 트레이드 오프를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec61bac9cf0621f9189209568ab5b25a5e169125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input:&lt;/strong&gt; The subprocess&amp;rsquo;s standard input stream is set up to receive the bytes provided as &lt;code&gt;stdin&lt;/code&gt;. Once the given input has been fully delivered, or if none is provided, the subprocess will receive end-of-file when reading from its standard input. Alternatively, if you want the subprocess to read its standard input from the same place as the parent Trio process, you can pass &lt;code&gt;stdin=None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력 :&lt;/strong&gt; 서브 프로세스의 표준 입력 스트림은 &lt;code&gt;stdin&lt;/code&gt; 으로 제공된 바이트를 수신하도록 설정됩니다 . 제공된 입력이 완전히 전달되거나 제공되지 않은 경우 표준 입력에서 읽을 때 서브 프로세스는 파일 끝을 수신합니다. 또는 하위 프로세스가 상위 Trio 프로세스와 동일한 위치에서 표준 입력을 읽도록하려면 &lt;code&gt;stdin=None&lt;/code&gt; 을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23eb20482732e41e1dcfc558eb1f0c5909afb9bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locating a Trio Token&lt;/strong&gt;: There are two ways to specify which &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to reenter:</source>
          <target state="translated">&lt;strong&gt;트리오 토큰 찾기&lt;/strong&gt; : 재 입력 할 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 루프를 지정하는 두 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ade3e064f41faa18672b1500d3135b5e95f57be0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt; By default, any output produced by the subprocess is passed through to the standard output and error streams of the parent Trio process. If you would like to capture this output and do something with it, you can pass &lt;code&gt;capture_stdout=True&lt;/code&gt; to capture the subprocess&amp;rsquo;s standard output, and/or &lt;code&gt;capture_stderr=True&lt;/code&gt; to capture its standard error. Captured data is provided as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object. The value for any stream that was not captured will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;출력 :&lt;/strong&gt; 기본적으로 하위 프로세스에서 생성 된 모든 출력은 상위 Trio 프로세스의 표준 출력 및 오류 스트림으로 전달됩니다. 이 출력을 캡처하고 무언가를 수행하려면 &lt;code&gt;capture_stdout=True&lt;/code&gt; 를 전달 하여 하위 프로세스의 표준 출력 을 캡처 하거나 &lt;code&gt;capture_stderr=True&lt;/code&gt; 를 사용하여 표준 오류를 캡처 할 수 있습니다. 캡처 된 데이터는 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 오브젝트 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성으로 제공됩니다 . 캡처되지 않은 스트림의 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb197b3ed5b21d6850b4b2a58d709428c2897e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;: you should set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to be at least as large as the largest cushion you plan to pass to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요약&lt;/strong&gt; : &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 에 전달할 가장 큰 쿠션만큼 크게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9a93be6ab8e66c257afb2ac1fd8e3333d8c144f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why do we even support unbounded buffers then?&lt;/strong&gt; Good question! Despite everything we saw above, there are times when you actually do need an unbounded buffer. For example, consider a web crawler that uses a channel to keep track of all the URLs it still wants to crawl. Each crawler runs a loop where it takes a URL from the channel, fetches it, checks the HTML for outgoing links, and then adds the new URLs to the channel. This creates a &lt;em&gt;circular flow&lt;/em&gt;, where each consumer is also a producer. In this case, if your channel buffer gets full, then the crawlers will block when they try to add new URLs to the channel, and if all the crawlers got blocked, then they aren&amp;rsquo;t taking any URLs out of the channel, so they&amp;rsquo;re stuck forever in a deadlock. Using an unbounded channel avoids this, because it means that &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; never blocks.</source>
          <target state="translated">&lt;strong&gt;우리는 왜 언 바운드 버퍼를 지원합니까? &lt;/strong&gt;좋은 질문! 위에서 본 모든 내용에도 불구하고 실제로 무제한 버퍼가 필요한 경우가 있습니다. 예를 들어, 채널을 사용하여 여전히 크롤링하려는 모든 URL을 추적하는 웹 크롤러를 고려하십시오. 각 크롤러는 루프를 실행하여 채널에서 URL을 가져 와서 가져오고 HTML에서 발신 링크를 확인한 다음 새 URL을 채널에 추가합니다. 이것은 &lt;em&gt;순환 흐름을&lt;/em&gt; 만듭니다&lt;em&gt;&lt;/em&gt;각 소비자는 생산자이기도합니다. 이 경우 채널 버퍼가 가득 차면 새 URL을 채널에 추가하려고 할 때 크롤러가 차단되며 모든 크롤러가 차단되면 채널에서 URL을 가져 오지 않으므로 교착 상태에 영원히 붙어 있습니다. 무제한 채널을 사용하면 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 절대로 차단되지 않기 때문에이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61c1f9736d24eb4a5f410bfc1a0e81ddee3b2303" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; becomes associated with some cancellable work when it is used as a context manager surrounding that work:</source>
          <target state="translated">&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 는&lt;/a&gt; 그것이 그 작업을 둘러싸는 콘텍스트 관리자로서 사용되는 일부 취소 할 작업과 연관된다 :</target>
        </trans-unit>
        <trans-unit id="a0510c2529df08b033b6321c0cd65ef6eedc4913" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager to acquire the underlying lock; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 객체 기본 잠금을 획득하려고 비동기 콘텍스트 관리자로서 사용될 수있다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1612df0d1097f5f2b176bcdf71abac20673f554" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 객체는 비동기 컨텍스트 관리자로 사용할 수 있습니다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e7aa4ad7cc8923cf4918bb861708c0d650fa365" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 객체는 비동기 콘텍스트 관리자로서 사용될 수있다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2225f74cfd04c73fc7aee7e342aaa8719e9fe2d8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; interfaces, so you can both send and receive objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 객체입니다 구현 모두 &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 인터페이스, 당신이 모두 전송을 할 수와 개체를받을 수 있도록.</target>
        </trans-unit>
        <trans-unit id="d210e54abe986047092d797dd411bd7168065d1c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; for SSL/TLS-encrypted servers.</source>
          <target state="translated">SSL / TLS 암호화 서버 의 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="625e56299f375edf78936391d427832e256f3e3c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that uses a listening socket to accept incoming connections as &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 로 들어오는 연결을 허용하도록 청취 소켓을 사용 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; 이&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="c7bf989c710ce969c51f1aa9b39c8b49c0a3cd5d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 객체를 구현하는 양이다 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="258acf0a9f20fc356fa0b1a9bdbc98d32d8b2654" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object represents a concurrent &amp;ldquo;thread&amp;rdquo; of execution. It has no public constructor; Trio internally creates a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object for each call to &lt;code&gt;nursery.start(...)&lt;/code&gt; or &lt;code&gt;nursery.start_soon(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체는 실행의 동시 &quot;스레드&quot;를 나타냅니다. 공개 생성자가 없습니다. Trio 는 &lt;code&gt;nursery.start(...)&lt;/code&gt; 또는 &lt;code&gt;nursery.start_soon(...)&lt;/code&gt; 호출 할 때마다 내부적으로 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ca7636a2d3c1be65ee986f9b4d165ad21f51d1e5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; wrapper that executes blocking methods in &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 에서 블로킹 메소드를 실행 하는 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="1b73143bafd8aa0311b134e354003b25e9991581" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the return code and outputs.</source>
          <target state="translated">리턴 코드 및 출력을 설명 하는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3be56645eaeb3a24943a947fc261ff21539eecaa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;semaphore&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;세마포어&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7ca899d2980900500c0380ec6e876d53eec217" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cancellation scope&lt;/em&gt;: the link between a unit of cancellable work and Trio&amp;rsquo;s cancellation system.</source>
          <target state="translated">&lt;em&gt;취소 범위&lt;/em&gt; : 취소 해 작업 단위와 트리오의 취소 시스템 사이의 연결.</target>
        </trans-unit>
        <trans-unit id="5032c512330d88fc246829f10b8a02efcc6498a0" translate="yes" xml:space="preserve">
          <source>A brief tour of Trio&amp;rsquo;s internals</source>
          <target state="translated">Trio의 내부 둘러보기</target>
        </trans-unit>
        <trans-unit id="7d074c399cd96f916fd6ae7cb18a4c9e7ecd005a" translate="yes" xml:space="preserve">
          <source>A checkpoint is two things:</source>
          <target state="translated">체크 포인트는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="866f38d604fe1cc0aa45f8909eeb748dc3ad3412" translate="yes" xml:space="preserve">
          <source>A child process. Like &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">자식 프로세스. 마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="da50d5e4a3b8f345208749e9b95ed3c3e12c049e" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;mutex&lt;/a&gt;.</source>
          <target state="translated">고전적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;뮤텍스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9952ba6442045d780e56a579e1a2d3ed0b1e2bd5" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;condition variable&lt;/a&gt;, similar to &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt;&lt;code&gt;threading.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt; &lt;code&gt;threading.Condition&lt;/code&gt; &lt;/a&gt; 과 유사한 클래식 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;조건 변수&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67b2307e53f7065cdcc0a477bac65ac935a07e91" translate="yes" xml:space="preserve">
          <source>A common convention for Unix daemons is that they should reload their configuration when they receive a &lt;code&gt;SIGHUP&lt;/code&gt;. Here&amp;rsquo;s a sketch of what that might look like using &lt;a href=&quot;#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Unix 데몬의 일반적인 규칙은 &lt;code&gt;SIGHUP&lt;/code&gt; 을받을 때 구성을 다시로드해야한다는 것 입니다. 다음은 &lt;a href=&quot;#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt; 사용하는 모습을 보여주는 스케치입니다 .</target>
        </trans-unit>
        <trans-unit id="479b35c63d61c382de8e69c12e513c7d2895b948" translate="yes" xml:space="preserve">
          <source>A context manager for catching signals.</source>
          <target state="translated">신호를 잡기위한 컨텍스트 관리자.</target>
        </trans-unit>
        <trans-unit id="d9a5508851c7e6da4d695e1f4368dbb4ae12c3ad" translate="yes" xml:space="preserve">
          <source>A context which may be used to spawn (or cancel) child tasks.</source>
          <target state="translated">자식 작업을 생성 (또는 취소)하는 데 사용될 수있는 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="6aeeaa351c9c07a00161cba202d64ab2ab24477f" translate="yes" xml:space="preserve">
          <source>A convenience class for forcing code in different tasks to run in an explicit linear order.</source>
          <target state="translated">서로 다른 작업의 코드를 명시 적으로 선형 순서로 실행하기위한 편리한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4fd174db16d5e267b3cf62d87b5c941ad8eebc38" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="4d8aae5f3ee79493cbf98ec8a47b0dfd039c01e4" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="4c96cb1bc50af7354b9f19f6a1c590cece36bddb" translate="yes" xml:space="preserve">
          <source>A fair wait queue with cancellation and requeueing.</source>
          <target state="translated">취소 및 다시 대기열이있는 공정한 대기 대기열</target>
        </trans-unit>
        <trans-unit id="6549ee3a2faaf405d0715d67d2765d3f4964e0b1" translate="yes" xml:space="preserve">
          <source>A kinder, gentler GIL</source>
          <target state="translated">더 친절하고 부드러운 GIL</target>
        </trans-unit>
        <trans-unit id="fd218172690cec772655bedac675b0ffeb843ce6" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="5580dae5a64338462ab0b4ded8e52746c9e9530a" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="b7ab10dae01d56e576130b3136cffdd323dcafa7" translate="yes" xml:space="preserve">
          <source>A new exception object in which each component exception &lt;code&gt;exc&lt;/code&gt; has been replaced by the result of running &lt;code&gt;handler(exc)&lt;/code&gt; &amp;ndash; or, if &lt;code&gt;handler&lt;/code&gt; returned None for all the inputs, returns None.</source>
          <target state="translated">&lt;code&gt;handler(exc)&lt;/code&gt; 를 실행 한 결과로 각 구성 요소 예외 &lt;code&gt;exc&lt;/code&gt; 가 대체 된 새 예외 객체 &amp;ndash; 또는 모든 입력에 대해 &lt;code&gt;handler&lt;/code&gt; 가 None을 반환 한 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="089ece0cda1cb42c55a75d324e06b234d0a9acd8" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt;. If you have trouble remembering which order these go in, remember: data flows from left &amp;rarr; right.</source>
          <target state="translated">쌍 &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt; . 어떤 순서로 진행되는지 기억하기 어려운 경우, 데이터가 왼쪽에서 오른쪽으로 흐릅니다.</target>
        </trans-unit>
        <trans-unit id="cd247a767092b84dd5e844b058c845103caf05f4" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt;, where &lt;code&gt;transport_stream&lt;/code&gt; is the underlying transport stream, and &lt;code&gt;trailing_bytes&lt;/code&gt; is a byte string. Since &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t necessarily know where the end of the encrypted data will be, it can happen that it accidentally reads too much from the underlying stream. &lt;code&gt;trailing_bytes&lt;/code&gt; contains this extra data; you should process it as if it was returned from a call to &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt; 쌍 . 여기서 &lt;code&gt;transport_stream&lt;/code&gt; 은 기본 전송 스트림이고 &lt;code&gt;trailing_bytes&lt;/code&gt; 는 바이트 문자열입니다. 이후 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 는&lt;/a&gt; 암호화 된 데이터의 끝이 될 위치를 알 필요하지 않습니다, 실수로 기본이되는 스트림에서 너무 많이 읽 발생할 수 있습니다. &lt;code&gt;trailing_bytes&lt;/code&gt; 는이 추가 데이터를 포함합니다. &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt; 호출에서 리턴 된 것처럼 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0588df8a0bae45e29e38622a0505c5a7de73534e" translate="yes" xml:space="preserve">
          <source>A pair of &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects that are connected so that data automatically flows from one to the other in both directions.</source>
          <target state="translated">데이터가 양방향으로 자동으로 흐르도록 연결된 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 객체 쌍입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e442a4c39e80b90dffce3b49a6e8bdd58ab33b" translate="yes" xml:space="preserve">
          <source>A pure &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">순수한 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cd63d27ef50a64a84701fc8cbaeb490e2d4d44" translate="yes" xml:space="preserve">
          <source>A return statement will not cancel the nursery if it still has tasks running:</source>
          <target state="translated">반환 작업은 여전히 ​​실행중인 작업이있는 경우 보육을 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031c15f98d537a5e074447bce8e5ff119937e3b5" translate="yes" xml:space="preserve">
          <source>A return value of &lt;code&gt;b&quot;&quot;&lt;/code&gt; (an empty bytestring) indicates that the stream has reached end-of-file. Implementations should be careful that they return &lt;code&gt;b&quot;&quot;&lt;/code&gt; if, and only if, the stream has reached end-of-file!</source>
          <target state="translated">&lt;code&gt;b&quot;&quot;&lt;/code&gt; (빈 바이트 스트링) 의 리턴 값은 스트림이 파일 끝에 도달했음을 나타냅니다. 스트림이 파일 끝에 도달 한 경우에만 &lt;code&gt;b&quot;&quot;&lt;/code&gt; 를 리턴하도록 구현에주의해야 합니다!</target>
        </trans-unit>
        <trans-unit id="8bdf7ef69126ff7409e786016de2f34e5ff450c0" translate="yes" xml:space="preserve">
          <source>A semaphore holds an integer value, which can be incremented by calling &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; and decremented by calling &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; &amp;ndash; but the value is never allowed to drop below zero. If the value is zero, then &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; will block until someone calls &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어는 &lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 를 호출하여 증가시킬 수 있고 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 감소 시킬 수있는 정수 값을 보유합니다. 그러나 값은 절대 0 미만으로 떨어질 수 없습니다. 값이 0 인 경우, 누군가 &lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 가 차단됩니다 .</target>
        </trans-unit>
        <trans-unit id="bce2812b0b52deb7bf2bba57f134e10e9513a206" translate="yes" xml:space="preserve">
          <source>A silly way to make a stream that echoes back whatever you write to it:</source>
          <target state="translated">스트림을 작성하는 어리석은 방법은 스트림에 쓰는 모든 내용을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="5df2f3e939d31936762bec3597f6b2da00f2cb48" translate="yes" xml:space="preserve">
          <source>A simple channel example</source>
          <target state="translated">간단한 채널 예</target>
        </trans-unit>
        <trans-unit id="95282c07f98577f2f962ac30d0752ad31f56c132" translate="yes" xml:space="preserve">
          <source>A simple timeout example</source>
          <target state="translated">간단한 타임 아웃 예제</target>
        </trans-unit>
        <trans-unit id="6e235d2e02ac1d060d2ff3c65495448b073d204e" translate="yes" xml:space="preserve">
          <source>A slightly trickier case is a function like:</source>
          <target state="translated">약간 까다로운 경우는 다음과 같은 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5626a02a8af093a360fe62102133baa49c34f588" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional byte streams.</source>
          <target state="translated">양방향 바이트 스트림과 상호 작용하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0a1d52474b9106e18b98b94a4317b363829ea98d" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional channels.</source>
          <target state="translated">양방향 채널과 상호 작용하기위한 표준 인터페이스.</target>
        </trans-unit>
        <trans-unit id="faa046132b99538769350e2cef5d5bc2e1a88a00" translate="yes" xml:space="preserve">
          <source>A standard interface for listening for incoming connections.</source>
          <target state="translated">들어오는 연결을 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="84688c296d643fb8558b4282dbf67d4d6c682eac" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving Python objects from some sender.</source>
          <target state="translated">일부 발신자로부터 Python 객체를 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="19bdeadce2bcad6dfc143ef126e57402024bb864" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving data on a byte stream.</source>
          <target state="translated">바이트 스트림에서 데이터를 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f9ec745dcf68e43c09d13825380bfc3153b5f42a" translate="yes" xml:space="preserve">
          <source>A standard interface for resources that needs to be cleaned up, and where that cleanup may require blocking operations.</source>
          <target state="translated">정리해야하는 자원과 정리시 차단 작업이 필요한 리소스에 대한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="246a1fe88a6077a51a4b1ab320703dd1fe24b852" translate="yes" xml:space="preserve">
          <source>A standard interface for sending Python objects to some receiver.</source>
          <target state="translated">파이썬 객체를 일부 수신자에게 보내기위한 표준 인터페이스.</target>
        </trans-unit>
        <trans-unit id="6961f254e4e81df4b566ce4a2dff920fb070922a" translate="yes" xml:space="preserve">
          <source>A standard interface for sending data on a byte stream.</source>
          <target state="translated">바이트 스트림으로 데이터를 보내기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b4cf06c3ae923d1d511d1dc400d9c860ddef6e9c" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard error stream: when the child writes to standard error, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stderr=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 오류 스트림에 연결된 스트림 : 자식이 표준 오류에 쓸 때 여기에서 읽을 수있는 바이트가 작성됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stderr=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="c6f0c220a8ef83c061ac018592a158c1acea362e" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard input stream: when you write bytes here, they become available for the child to read. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdin=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 입력 스트림에 연결된 스트림 : 여기에 바이트를 쓰면 자식이 읽을 수있게됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stdin=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="84f88943d222d5c08ff49d881c72a9de6313f085" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard output stream: when the child writes to standard output, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdout=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 출력 스트림에 연결된 스트림 : 자식이 표준 출력에 쓸 때 여기에서 읽을 수있는 바이트가 제공됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stdout=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="954ca7723aafc90b8ae2473f0d14253858c192e4" translate="yes" xml:space="preserve">
          <source>A stream that sends data to the child&amp;rsquo;s standard input and receives from the child&amp;rsquo;s standard output. Only available if both &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; are available; otherwise this will be None.</source>
          <target state="translated">자식의 표준 입력으로 데이터를 보내고 자식의 표준 출력에서받는 스트림입니다. &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 을&lt;/a&gt; 모두 사용할 수있는 경우에만 사용 가능합니다. 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="4156e909e8dc71d5689a050c51a8b9b787486dce" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;), where the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; has its hooks set up so that it calls &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt; from its &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">튜플 ( &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt; 를 호출하도록 후크가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcdeb1e57aeec9fabc1211f5ee625ae661f04ca" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">튜플 ( &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="41812fde4d36fb61daec4837f44446d9e7c30dff" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">튜플 ( &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3b58de50a23919a1f3f8642bdd5fcb86f500f20f" translate="yes" xml:space="preserve">
          <source>A user-controllable clock suitable for writing tests.</source>
          <target state="translated">테스트 작성에 적합한 사용자 제어 가능 클록.</target>
        </trans-unit>
        <trans-unit id="d394b71cb15d8736cdfc1fc9fa37b4073ac2c1e7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; where tasks are guaranteed to acquire the lock in strict first-come-first-served order.</source>
          <target state="translated">작업이 엄격한 선착순으로 잠금을 획득하도록 보장되는 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="360867cd6ca0456c8287b5d11df4b1f0bd3a3ed9" translate="yes" xml:space="preserve">
          <source>A waitable boolean value useful for inter-task synchronization, inspired by &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; 에서 영감을 얻은 작업 간 동기화에 유용한 대기 가능 부울 값 입니다.</target>
        </trans-unit>
        <trans-unit id="888df3bc904f11ac7d98b120089cf5c393ec278c" translate="yes" xml:space="preserve">
          <source>API details</source>
          <target state="translated">API 세부 사항</target>
        </trans-unit>
        <trans-unit id="a135b59a972e5d51e9898c53214e86f0658cc125" translate="yes" xml:space="preserve">
          <source>API overview</source>
          <target state="translated">API 개요</target>
        </trans-unit>
        <trans-unit id="98f04167dd579d54364beef9c72aecdee3543412" translate="yes" xml:space="preserve">
          <source>Abstract base class</source>
          <target state="translated">추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="d8218637bd5929185efd6cedd428b196f3c683f3" translate="yes" xml:space="preserve">
          <source>Abstract base classes</source>
          <target state="translated">추상 기본 수업</target>
        </trans-unit>
        <trans-unit id="934a206c7fa94c5e3b940f49138774a9bc4b9522" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection.</source>
          <target state="translated">들어오는 연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="f980df6a8d9e94749c222bab10788f1acc9910d2" translate="yes" xml:space="preserve">
          <source>Accept the next connection and wrap it in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 연결을 승인하고 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로&lt;/a&gt; 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="01859c9721d844b4c97719553bfc101a5661028b" translate="yes" xml:space="preserve">
          <source>Accessing this attribute does not check for termination; use &lt;a href=&quot;#trio.Process.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">이 속성에 액세스해도 종료를 확인하지 않습니다. 사용 &lt;a href=&quot;#trio.Process.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 그것에 대해.</target>
        </trans-unit>
        <trans-unit id="a24b8c73dc58f01619f8b157ef4dbb8d1cabc7f7" translate="yes" xml:space="preserve">
          <source>Acquire the lock, blocking if necessary.</source>
          <target state="translated">잠금을 획득하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="f62f5263a0efafa3ea2f701a6b780bcf9b854b41" translate="yes" xml:space="preserve">
          <source>Acquire the underlying lock, blocking if necessary.</source>
          <target state="translated">기본 잠금을 획득하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="c33c4bb3cd6a08c2b5c643cb02e11bb07b5a62c3" translate="yes" xml:space="preserve">
          <source>Adds an end-of-file marker to the internal buffer.</source>
          <target state="translated">파일 끝 마커를 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="84752f69bde810200a7a75068013277cd2c18314" translate="yes" xml:space="preserve">
          <source>Adds these abstract methods&amp;hellip;</source>
          <target state="translated">이 추상적 인 방법을 추가합니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9ffc61eebd04b52ced9a43b69b164c475720e17f" translate="yes" xml:space="preserve">
          <source>After construction, you can interact with the child process by writing data to its &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream (a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;), reading data from its &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#trio.Process.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; streams (both &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;s), sending it signals using &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.Process.send_signal&quot;&gt;&lt;code&gt;send_signal&lt;/code&gt;&lt;/a&gt;, and waiting for it to exit using &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">건설 후에는 데이터를 작성하여 자식 프로세스와 상호 작용할 수있는 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 스트림 (A &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 의 데이터 읽기) &lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;#trio.Process.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 스트림 (모두 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 그것을 통해 신호 전송,들)을 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#trio.Process.send_signal&quot;&gt; &lt;code&gt;send_signal&lt;/code&gt; 을&lt;/a&gt; 하고, wait를 사용하여 종료 될 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda6461f3015f34ff1df74c1242f7e0c19473185" translate="yes" xml:space="preserve">
          <source>After creating a stream pair, you can send data back and forth, which is enough for simple tests:</source>
          <target state="translated">스트림 쌍을 만든 후에는 데이터를주고받을 수 있으며 간단한 테스트에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="5bdd9f5cfc1e60752e0ba39124a981ddc11ba5c6" translate="yes" xml:space="preserve">
          <source>All calls with &lt;code&gt;idempotent=False&lt;/code&gt; are processed in strict first-in first-out order.</source>
          <target state="translated">&lt;code&gt;idempotent=False&lt;/code&gt; 인 모든 통화 는 엄격한 선입 선출 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c364f3240a303cebaff74b8113e96934d193acdf" translate="yes" xml:space="preserve">
          <source>All environments provide the following functions:</source>
          <target state="translated">모든 환경은 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="516b45d89e54cbc171ce25d82e3ea1e166f44bfe" translate="yes" xml:space="preserve">
          <source>All methods and attributes &lt;em&gt;not&lt;/em&gt; mentioned above are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위에서 언급 &lt;em&gt;하지 않은&lt;/em&gt; 모든 메소드와 속성 은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9763027b87405de48bf6b0814b614c809653c3a9" translate="yes" xml:space="preserve">
          <source>All of Trio&amp;rsquo;s subprocess APIs accept the numerous keyword arguments used by the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module to control the environment in which a process starts and the mechanisms used for communicating with it. These may be passed wherever you see &lt;code&gt;**options&lt;/code&gt; in the documentation below. See the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;full list&lt;/a&gt; or just the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;frequently used ones&lt;/a&gt; in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; documentation. (You may need to &lt;code&gt;import
subprocess&lt;/code&gt; in order to access constants such as &lt;code&gt;PIPE&lt;/code&gt; or &lt;code&gt;DEVNULL&lt;/code&gt;.)</source>
          <target state="translated">모든 Trio의 서브 프로세스 API는 표준 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈에서 사용하는 수많은 키워드 인수를 수락하여 프로세스가 시작되는 환경과 통신하는 데 사용되는 메커니즘을 제어합니다. 아래 문서의 &lt;code&gt;**options&lt;/code&gt; 있는 곳이면 어디든 전달 될 수 있습니다 . &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 문서 에서 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;전체 목록&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;자주 사용되는 항목&lt;/a&gt; 을 참조하십시오 . ( &lt;code&gt;PIPE&lt;/code&gt; 또는 &lt;code&gt;DEVNULL&lt;/code&gt; 과 같은 상수에 액세스하려면 &lt;code&gt;import subprocess&lt;/code&gt; 를 가져와야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="2aa180e59f7357f8747d01d26ff0c904e97ad5cf" translate="yes" xml:space="preserve">
          <source>All of these hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">이러한 후크는 모두 객체의 속성으로 표시되며 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1538bc660a990864dbaf1ef24a3d075fd3a9b8f" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; correctly uses IDNA 2008 to process non-ASCII domain names. (&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; uses IDNA 2003, which can give the wrong result in some cases and cause you to connect to a different host than the one you intended; see &lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt;.)</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 IDNA 2008을 올바르게 사용하여 비 ASCII 도메인 이름을 처리합니다. ( &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 IDNA 2003을 사용하므로 경우에 따라 잘못된 결과가 발생하여 의도 한 것과 다른 호스트에 연결될 수 있습니다 ( &lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="83cf84f8a5bf0d4f53335a628e0369d2475a03db" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a3d704b1065f4c2eb639c6f993e214ab9654318" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt; that wraps &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt; 랩 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a802ab3679dc10b4fe79e97e5a8ff9d668b3ca83" translate="yes" xml:space="preserve">
          <source>An event object has an internal boolean flag, representing whether the event has happened yet. The flag is initially False, and the &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method waits until the flag is True. If the flag is already True, then &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; returns immediately. (If the event has already happened, there&amp;rsquo;s nothing to wait for.) The &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method sets the flag to True, and wakes up any waiters.</source>
          <target state="translated">이벤트 객체에는 이벤트가 아직 발생했는지 여부를 나타내는 내부 부울 플래그가 있습니다. 플래그는 처음에는 False이며 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드는 플래그가 True가 될 때까지 대기합니다. 플래그가 이미 True이면 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 가 즉시 리턴합니다. 이벤트가 이미 발생한 경우 기다릴 필요가 없습니다. &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메서드는 플래그를 True로 설정하고 웨이터를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="4d52ab6eac96066995c3946164709bf9e329f2bc" translate="yes" xml:space="preserve">
          <source>An example of when this is useful is if you&amp;rsquo;re implementing something like &lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; or an HTTP/2 server using &lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2&lt;/a&gt;, where you have multiple concurrent tasks that are interacting with a shared state machine, and at unpredictable moments the state machine requests that a chunk of data be sent over the network. (For example, when using h2 simply reading incoming data can occasionally &lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;create outgoing data to send&lt;/a&gt;.) The challenge is to make sure that these chunks are sent in the correct order, without being garbled.</source>
          <target state="translated">이것이 유용한 경우의 예는 공유 상태 머신과 상호 작용하고 예측할 수없는 순간에 상태 머신이 요청하는 여러 개의 동시 태스크가있는 &lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2를&lt;/a&gt; 사용하여 &lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 또는 HTTP / 2 서버 와 같은 것을 구현하는 경우 입니다. 데이터 청크가 네트워크를 통해 전송됩니다. (예를 들어, h2를 &lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;사용하는&lt;/a&gt; 경우 수신 데이터를 읽기만 하면 송신 데이터가 전송 될 수 있습니다.) 이러한 청크가 깨지지 않고 올바른 순서로 전송되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="14aa51805b5668de90eaf69ef2c36108d5a6ef09" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is in implementing something like &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt;, which uses &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; to get into the Trio thread. &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;run_sync_soon()&lt;/code&gt;&lt;/a&gt; callbacks are run with &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled, and &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; when entering the user-provided function.</source>
          <target state="translated">이것을 사용할 위치의 예 는 &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 Trio 스레드에 들어가는 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 과 같은 것을 구현하는 것 입니다. &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;run_sync_soon()&lt;/code&gt; &lt;/a&gt; 콜백은 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화 된 상태에서 실행되며 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 은이를 이용하여 응답을 원래 스레드로 다시 전송하기위한 기계를 안전하게 설정하지만 사용자가 들어갈 때 &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 을 사용합니다. 제공된 기능.</target>
        </trans-unit>
        <trans-unit id="a1f0bedbb145e5a1e2bbf357cfd642611519001c" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is on the &lt;code&gt;__exit__&lt;/code&gt; implementation for something like a &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, where a poorly-timed &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; could leave the lock in an inconsistent state and cause a deadlock.</source>
          <target state="translated">이것을 사용하는 위치의 예는 &lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 과 같은 것에 대한 &lt;code&gt;__exit__&lt;/code&gt; 구현에 있으며, 시간이 잘못 된 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 는 잠금을 일관성이없는 상태로두고 교착 상태를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d53f85c599291f0aa7ad06a498910662abac5c1" translate="yes" xml:space="preserve">
          <source>An exception that contains other exceptions; also known as an &amp;ldquo;inception&amp;rdquo;.</source>
          <target state="translated">다른 예외를 포함하는 예외. &quot;시작&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="8b5a92674abba02060ea334d3fa2bbc5aa4e8e09" translate="yes" xml:space="preserve">
          <source>An extremely elaborate way to print the numbers 0-5, in order:</source>
          <target state="translated">숫자 0-5를 순서대로 인쇄하는 매우 정교한 방법 :</target>
        </trans-unit>
        <trans-unit id="7aef88f6225e778c97ecaab42341e3b25ab9147f" translate="yes" xml:space="preserve">
          <source>An implementation of the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface based on a raw network socket.</source>
          <target state="translated">원시 네트워크 소켓을 기반으로하는 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스 구현 .</target>
        </trans-unit>
        <trans-unit id="695564b638fa254ea364510c5e05e8097f7591d5" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 내 &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2a920b465cb25d11c71e2cdaf24856da6d63c8" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 내 &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f30ba4d9f6910fed9a58bf0bd0f5800556c4cba6" translate="yes" xml:space="preserve">
          <source>An object for controlling access to a resource with limited capacity.</source>
          <target state="translated">용량이 제한된 리소스에 대한 액세스를 제어하기위한 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ba8865459d8776bfdcb6f4f08bb9a46b051e09e7" translate="yes" xml:space="preserve">
          <source>An object representing the incoming connection. In practice this is generally some kind of &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, but in principle you could also define a &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that returned, say, channel objects.</source>
          <target state="translated">들어오는 연결을 나타내는 개체입니다. 실제로 이것은 일반적으로 일종의 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 이지만 원칙적으로 채널 객체를 반환 하는 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb005736155e148aa00fb56e6e1d90e65b11f9f4" translate="yes" xml:space="preserve">
          <source>An object used to limit the number of simultaneous threads. Most commonly this will be a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, but it could be anything providing compatible &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt;&lt;code&gt;release_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods. This function will call &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; before starting the thread, and &lt;code&gt;release_on_behalf_of&lt;/code&gt; after the thread has finished.</source>
          <target state="translated">동시 스레드 수를 제한하는 데 사용되는 객체입니다. 가장 일반적으로 이것은 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 이지만 호환되는 &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt; &lt;code&gt;release_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 모든 것이 될 수 있습니다 . 이 함수는 스레드를 시작하기 전에 &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; 를 호출 하고 스레드가 완료된 후 &lt;code&gt;release_on_behalf_of&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d44602f4de12292ecf6bdcbd9eb7906b8d75b788" translate="yes" xml:space="preserve">
          <source>An opaque object representing a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 단일 호출을 나타내는 불투명 한 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="8149f28272227a8e81084653973e770e45c26b37" translate="yes" xml:space="preserve">
          <source>And both of these raise nothing at all:</source>
          <target state="translated">그리고이 두 가지 모두 전혀 아무것도 제기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83af1c669b4bec1a968e9180163f131b881c991c" translate="yes" xml:space="preserve">
          <source>And crucially, if you try to borrow a token but the sack is empty, then you have to wait for another task to finish what it&amp;rsquo;s doing and put its token back first before you can take it and continue.</source>
          <target state="translated">그리고 토큰을 빌리려고하지만 자루가 비어있는 경우 다른 작업이 완료 될 때까지 기다렸다가 토큰을 다시 가져 와서 계속 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9441ac9e6468a96d8d53ae170751b3641f022f8" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s a simple test using our modified stream objects:</source>
          <target state="translated">다음은 수정 된 스트림 객체를 사용한 간단한 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="292b64b01e8fc7f9c6c766b1d0e5576718c411ae" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s the interface to implement if you want to build your own &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;Instrument&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그리고 자신 만의 &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;Instrument&lt;/code&gt; &lt;/a&gt; 를 구축하려는 경우 구현할 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e471a70c4adc5a5fbd1f21459bce94d3eae6d3d6" translate="yes" xml:space="preserve">
          <source>And if you combine pipelines with () grouping, you can need even more levels of escaping:</source>
          <target state="translated">파이프 라인을 () 그룹화와 결합하면 더 많은 레벨의 이스케이프가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a00a0e43b4ec4919fc3243ac05e9ba6405d86a" translate="yes" xml:space="preserve">
          <source>And if you&amp;rsquo;re implementing a server, you can use &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">서버를 구현하는 경우 &lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba0a6a620759e481fb4465edb6928ab1b2715ba4" translate="yes" xml:space="preserve">
          <source>And in some very, very unusual circumstances, it even makes sense to transfer a single coroutine object back and forth between different coroutine runners. That&amp;rsquo;s what this section is about. This is an &lt;em&gt;extremely&lt;/em&gt; exotic use case, and assumes a lot of expertise in how Python async/await works internally. For motivating examples, see &lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio issue #42&lt;/a&gt;, and &lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio issue #649&lt;/a&gt;. For more details on how coroutines work, we recommend Andr&amp;eacute; Caron&amp;rsquo;s &lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;A tale of event loops&lt;/a&gt;, or going straight to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt; for the full details.</source>
          <target state="translated">그리고 매우, 매우 이례적인 상황에서는 단일 코 루틴 물체를 다른 코 루틴 러너 사이에서 앞뒤로 옮기는 것이 합리적입니다. 이것이이 섹션의 내용입니다. 이것은 &lt;em&gt;매우&lt;/em&gt; 이국적인 유스 케이스이며 Python 비동기 / 대기가 내부적으로 작동하는 방법에 대한 많은 전문 지식을 가정합니다. 동기 부여 예제는 &lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio issue # 42&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio issue # 649를 참조하십시오&lt;/a&gt; . 코 루틴의 작동 방식에 대한 자세한 내용은 Andr&amp;eacute; Caron의 &lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;이벤트 루프 이야기&lt;/a&gt; 또는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt; 로 직접 이동 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="619d03500f6db41ec6806aedd9a5bd864e1f9ac0" translate="yes" xml:space="preserve">
          <source>And of course these can be mixed and matched at will.</source>
          <target state="translated">물론 이것들은 마음대로 혼합하고 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe22b10355ca18b089c78c28baddac1ad66a2f8" translate="yes" xml:space="preserve">
          <source>And once you have a reference to a nursery object, you can start children in that nursery:</source>
          <target state="translated">보육원 객체에 대한 참조가 있으면 해당 보육원에서 자녀를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8b7b10833f094016e1717309592388a4e1b78e" translate="yes" xml:space="preserve">
          <source>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast &amp;ndash; calling &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;code&gt;read&lt;/code&gt; method on a cached file takes on the order of ~1 &amp;micro;s. But when the data isn&amp;rsquo;t cached, then accessing it is much, much slower: the average is ~100 &amp;micro;s for SSDs and ~10,000 &amp;micro;s for spinning disks, and if you look at tail latencies then for both types of storage you&amp;rsquo;ll see cases where occasionally some operation will be 10x or 100x slower than average. And that&amp;rsquo;s assuming your program is the only thing trying to use that disk &amp;ndash; if you&amp;rsquo;re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</source>
          <target state="translated">둘째, 디스크 운영 비용은 엄청나게 양봉입니다. 때로는 필요한 데이터가 이미 RAM에 캐시 된 다음 액세스하는 속도가 매우 빠릅니다 . 캐시 된 파일에서 &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;read&lt;/code&gt; 메서드 호출 은 ~ 1 &amp;micro;s 정도입니다. 그러나 데이터가 캐시되지 않으면 액세스 속도가 훨씬 느려집니다. SSD의 경우 평균은 ~ 100 &amp;micro;s, 회전 디스크의 경우 ~ 10,000 &amp;micro;s이며 꼬리 지연을 보면 두 유형의 스토리지 모두에 대해 때때로 일부 작업이 평균보다 10 배 또는 100 배 느린 경우를 참조하십시오. 그리고 그것은 당신의 프로그램이 그 디스크를 사용하려고하는 유일한 것이라고 가정합니다 &amp;ndash; 만약 당신이 다른 테넌트와 I / O를 위해 과잉 판매 된 클라우드 VM을 사용하고 있다면 어떤 일이 일어날 지 알고 있습니다. 또한 일부 작업에는 여러 디스크 액세스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feeca190f93d22f58d615ed4fd1614a4269d6897" translate="yes" xml:space="preserve">
          <source>And then it hangs forever. (Use control-C to quit.)</source>
          <target state="translated">그리고 그것은 영원히 매달려 있습니다. Ctrl-C를 사용하여 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="211d7d50556ec8f345832762c8c8fe21c2c79327" translate="yes" xml:space="preserve">
          <source>And these concrete methods.</source>
          <target state="translated">그리고 이러한 구체적인 방법.</target>
        </trans-unit>
        <trans-unit id="f27d0a8c5e5faf3e87bb41b32a3eb3c34a5ef14f" translate="yes" xml:space="preserve">
          <source>Another approach would be to attempt to connect to all of the addresses at the same time, in parallel, and then use whichever connection succeeds first, abandoning the others. This would be fast, but create a lot of unnecessary load on the network and the remote server.</source>
          <target state="translated">또 다른 방법은 모든 주소에 동시에 병렬로 연결 한 다음 먼저 성공한 연결을 사용하여 다른 연결을 포기하는 것입니다. 이 속도는 빠르지 만 네트워크와 원격 서버에 많은 불필요한로드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="540e6b0386e96589ef7bf08cc766b92ef3f1c782" translate="yes" xml:space="preserve">
          <source>Another way to think of it: a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is like a sofa with a fixed number of seats, and if they&amp;rsquo;re all taken then you have to wait for someone to get up before you can sit down.</source>
          <target state="translated">그것을 생각하는 또 다른 방법 : &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 는 고정 된 수의 좌석이있는 소파와 같으며 모두 가져 가면 앉을 수 있기 전에 누군가가 일어나기를 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="3c598eda8f7e244d58a5c6244a28edd77a41d473" translate="yes" xml:space="preserve">
          <source>Any ordering guarantees apply separately to &lt;code&gt;idempotent=False&lt;/code&gt; and &lt;code&gt;idempotent=True&lt;/code&gt; calls; there&amp;rsquo;s no rule for how calls in the different categories are ordered with respect to each other.</source>
          <target state="translated">모든 주문 보증은 &lt;code&gt;idempotent=False&lt;/code&gt; 및 &lt;code&gt;idempotent=True&lt;/code&gt; 통화에 별도로 적용됩니다 . 서로 다른 범주의 통화가 서로 관련하여 정렬되는 방법에 대한 규칙은 없습니다.</target>
        </trans-unit>
        <trans-unit id="41b988d7261002f6ebec68c073ec1cadb529e763" translate="yes" xml:space="preserve">
          <source>Any required IDNA encoding is handled before calling this function; your implementation can assume that it will never see U-labels like &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt;, and only needs to handle A-labels like &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하기 전에 필요한 모든 IDNA 인코딩이 처리됩니다. 구현에서는 &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt; 과 같은 U- 라벨을 볼 수 없으며 &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt; 과 같은 A- 라벨 만 처리 하면된다고 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb6e5d4e2297b46370edf9d7a6dce06b7d28b0e4" translate="yes" xml:space="preserve">
          <source>Any unhandled exceptions are re-raised inside the parent task. If there are multiple exceptions, then they&amp;rsquo;re collected up into a single &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">처리되지 않은 예외는 상위 작업 내에서 다시 발생합니다. 여러 예외가있는 경우 단일 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 예외 로 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="a144cdd6ad89d2a3f0faf4bb094aa9a40f041001" translate="yes" xml:space="preserve">
          <source>Appends the given data to the internal buffer.</source>
          <target state="translated">주어진 데이터를 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="41199e1703298a10d2448f0613b291ab0cfa02d6" translate="yes" xml:space="preserve">
          <source>Apply the given &lt;code&gt;handler&lt;/code&gt; to all the exceptions in &lt;code&gt;root_exc&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;handler&lt;/code&gt; 를 &lt;code&gt;root_exc&lt;/code&gt; 의 모든 예외에 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddb0e258362b5452ce82961901033b9428777b28" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">인수 및 리턴 값은 이 버전이 비동기라는 점을 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1799c1804f821db693151ce3817c600ec5a0e3f6" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">인수와 반환 값은 이 버전이 비동기라는 점을 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c2c4d14e88fd37145f6bdde6cffa4dfeb02c80f4" translate="yes" xml:space="preserve">
          <source>As a young project, Trio is currently quite aggressive about deprecating and/or removing functionality that we realize was a bad idea. If you use Trio, you should subscribe to &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;issue #1&lt;/a&gt; to get information about upcoming deprecations and other backwards compatibility breaking changes.</source>
          <target state="translated">어린 프로젝트 인 Trio는 현재 우리가 생각하지 못한 기능을 더 이상 사용하지 않거나 제거하는 데 매우 적극적입니다. Trio를 사용하는 경우, 다가오는 지원 중단 및 기타 이전 버전과의 호환성 변경에 대한 정보를 얻으려면 &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;문제 # 1&lt;/a&gt; 을 구독해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0994996832e530b1ae6097f1cb664a72a0eaff" translate="yes" xml:space="preserve">
          <source>As an example of what this means, here&amp;rsquo;s a small program in which two tasks compete for a lock. Notice that the task which releases the lock always immediately attempts to re-acquire it, before the other task has a chance to run. (And remember that we&amp;rsquo;re doing cooperative multi-tasking here, so it&amp;rsquo;s actually &lt;em&gt;deterministic&lt;/em&gt; that the task releasing the lock will call &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; before the other task wakes up; in Trio releasing a lock is not a checkpoint.) With an unfair lock, this would result in the same task holding the lock forever and the other task being starved out. But if you run this, you&amp;rsquo;ll see that the two tasks politely take turns:</source>
          <target state="translated">이것이 의미하는 바의 예로, 두 가지 작업이 잠금을 위해 경쟁하는 작은 프로그램이 있습니다. 잠금을 해제하는 작업은 다른 작업이 실행되기 전에 항상 즉시 잠금을 다시 획득하려고 시도합니다. (그리고 우리는 여기서 협업 멀티 태스킹을하고 있다는 것을 기억하십시오. 따라서 잠금을 해제하는 작업은 다른 작업이 일어나기 전에 &lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출한다는 것이 &lt;em&gt;결정적&lt;/em&gt; 입니다 . 트리오에서 잠금을 해제하는 것은 체크 포인트가 아닙니다.) 잠금을 유지하면 동일한 작업이 잠금을 영원히 유지하고 다른 작업이 굶주리게됩니다. 그러나 이것을 실행하면 두 가지 작업이 정중하게 번갈아 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4929afd212841a7b80b8527c2843abff4b732394" translate="yes" xml:space="preserve">
          <source>Async and cancellable variant of &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject&lt;/a&gt;. Windows only.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject의&lt;/a&gt; 비동기 및 취소 가능한 변형 . Windows 만 해당</target>
        </trans-unit>
        <trans-unit id="3b88c3f510d5347e19a68032dd5e36b530c8b07c" translate="yes" xml:space="preserve">
          <source>Async cleanup operations &amp;ndash; like &lt;code&gt;__aexit__&lt;/code&gt; methods or async close methods &amp;ndash; are cancellable just like anything else &lt;em&gt;except&lt;/em&gt; that if they are cancelled, they still perform a minimum level of cleanup before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;__aexit__&lt;/code&gt; 메소드 또는 비동기 닫기 메소드 와 같은 비동기 정리 조작 은 취소 된 경우 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 올리기 전에 여전히 최소 정리 레벨을 수행한다는 &lt;em&gt;점&lt;/em&gt; 을 &lt;em&gt;제외하고&lt;/em&gt; 는 다른 것과 마찬가지로 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ce82e511d085dd23f703422ef525137aa3279ed" translate="yes" xml:space="preserve">
          <source>Async file objects can be used as async iterators to iterate over the lines of the file:</source>
          <target state="translated">비동기 파일 객체는 파일의 행을 반복하는 비동기 반복자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa3c3b6b8715de81fa4c30bebbf1834d4a54fc9d" translate="yes" xml:space="preserve">
          <source>Async file objects implement Trio&amp;rsquo;s &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface: you close them by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;close&lt;/code&gt; (!!), and they can be used as async context managers. Like all &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; methods, the &lt;code&gt;aclose&lt;/code&gt; method on async file objects is guaranteed to close the file before returning, even if it is cancelled or otherwise raises an error.</source>
          <target state="translated">비동기 파일 개체는 Trio의 &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . &lt;code&gt;close&lt;/code&gt; (!!) 대신 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 닫고 비동기 컨텍스트 관리자로 사용할 수 있습니다. 모든 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드 와 마찬가지로 , 비동기 파일 객체 의 &lt;code&gt;aclose&lt;/code&gt; 메소드는 파일이 취소되거나 오류가 발생하더라도 리턴하기 전에 파일을 닫도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">비동기 기능</target>
        </trans-unit>
        <trans-unit id="ad0ef1eb3a3323f023e10b1311f762ecdd88f1d8" translate="yes" xml:space="preserve">
          <source>Async methods: if any of the following methods are present, then they&amp;rsquo;re re-exported as an async method: &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;read1&lt;/code&gt;, &lt;code&gt;readall&lt;/code&gt;, &lt;code&gt;readinto&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readlines&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;tell&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writelines&lt;/code&gt;, &lt;code&gt;readinto1&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;detach&lt;/code&gt;.</source>
          <target state="translated">비동기 메소드 : 다음 메소드 중 하나가 존재하면 비동기 메소드로 다시 내보내집니다. &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;read1&lt;/code&gt; , &lt;code&gt;readall&lt;/code&gt; , &lt;code&gt;readinto&lt;/code&gt; , &lt;code&gt;readline&lt;/code&gt; , &lt;code&gt;readlines&lt;/code&gt; , &lt;code&gt;seek&lt;/code&gt; , &lt;code&gt;tell&lt;/code&gt; , &lt;code&gt;truncate&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writelines&lt;/code&gt; , &lt;code&gt;readinto1&lt;/code&gt; , &lt;code&gt;peek&lt;/code&gt; , &lt;code&gt;detach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df5103c1d76d680bba6764bfa32d48a6b5502e54" translate="yes" xml:space="preserve">
          <source>AsyncResource</source>
          <target state="translated">AsyncResource</target>
        </trans-unit>
        <trans-unit id="334f22a36314907eaa8b814dd48f1292097dd241" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface</source>
          <target state="translated">비동기 파일 인터페이스</target>
        </trans-unit>
        <trans-unit id="56e1586c4db07663ccb34d08c64207ff46c03226" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface.wrapped</source>
          <target state="translated">비동기 파일 인터페이스</target>
        </trans-unit>
        <trans-unit id="0076fe4764abf6551bbbe5999752efce8a89e22f" translate="yes" xml:space="preserve">
          <source>Asynchronous file objects</source>
          <target state="translated">비동기 파일 객체</target>
        </trans-unit>
        <trans-unit id="667673e6e7517b69bb54c30591ebb1af1ea7f64f" translate="yes" xml:space="preserve">
          <source>Asynchronous filesystem I/O</source>
          <target state="translated">비동기 파일 시스템 I / O</target>
        </trans-unit>
        <trans-unit id="1474e40071f7e113106e68f95d2c73a27282f008" translate="yes" xml:space="preserve">
          <source>Asynchronous path objects</source>
          <target state="translated">비동기 경로 객체</target>
        </trans-unit>
        <trans-unit id="546381f9589ee22e6d37c1fe83d5cd5cbd4791b1" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비동기 버전 &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64e84334e28bf171e5da15b38a549d66423494e6" translate="yes" xml:space="preserve">
          <source>At that point there are again two possibilities. You can simply ignore the cancellation altogether: wait for the operation to complete and then reschedule and continue as normal. (For example, this is what &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; does if cancellation is disabled.) The other possibility is that the &lt;code&gt;abort_func&lt;/code&gt; does succeed in cancelling the operation, but for some reason isn&amp;rsquo;t able to report that right away. (Example: on Windows, it&amp;rsquo;s possible to request that an async (&amp;ldquo;overlapped&amp;rdquo;) I/O operation be cancelled, but this request is &lt;em&gt;also&lt;/em&gt; asynchronous &amp;ndash; you don&amp;rsquo;t find out until later whether the operation was actually cancelled or not.) To report a delayed cancellation, then you should reschedule the task yourself, and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback passed to &lt;code&gt;abort_func&lt;/code&gt; to raise a &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;) exception into this task. Either of the approaches sketched below can work:</source>
          <target state="translated">이 시점에서 다시 두 가지 가능성이 있습니다. 취소를 완전히 무시할 수 있습니다. 작업이 완료 될 때까지 기다렸다가 일정을 조정하고 정상적으로 계속하십시오. (예를 들어, 취소가 비활성화 된 경우 &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 가 수행합니다.) 다른 가능성은 &lt;code&gt;abort_func&lt;/code&gt; 가 작업 취소에 성공했지만 어떤 이유로 든이를 즉시보고 할 수 없다는 것입니다. (예 : Windows에서는 비동기 ( &quot;오버랩&quot;) I / O 작업을 취소하도록 요청할 수 있지만이 요청 &lt;em&gt;도&lt;/em&gt; 비동기 적입니다. 나중에 작업이 실제로 취소되었는지 여부를 알 수 없습니다.) 지연된 취소를보고하려면 직접 작업 일정을 조정하고 &lt;code&gt;raise_cancel&lt;/code&gt; 을 호출해야 합니다.콜백이 &lt;code&gt;abort_func&lt;/code&gt; 에 전달 되어이 작업 에 대해 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; ) 예외가 발생했습니다. 아래 스케치 된 접근법 중 하나가 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687169aaa57a138b6171d6746f9a863ca2e934f3" translate="yes" xml:space="preserve">
          <source>At the other extreme, you can make the buffer unbounded by using &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt;. In this case, &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;always&lt;/em&gt; returns immediately. Normally, this is a bad idea. To see why, consider a program where the producer runs more quickly than the consumer:</source>
          <target state="translated">다른 극단적 인 경우 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 사용하여 버퍼를 무제한으로 만들 수 있습니다 . 이 경우 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 항상&lt;/em&gt; 즉시 반환합니다. 일반적으로 이것은 나쁜 생각입니다. 이유를 알아 보려면 생산자가 소비자보다 더 빨리 실행되는 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b3c94195e485ebf930152b3b8ee9cf75902195a0" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the lock, without blocking.</source>
          <target state="translated">차단하지 않고 잠금을 획득하려고합니다.</target>
        </trans-unit>
        <trans-unit id="222d279c3d693f924ccc7de907d970a895a42260" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the underlying lock, without blocking.</source>
          <target state="translated">차단하지 않고 기본 잠금을 획득하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ef0a1a4841da5c985f3f0b3eae640e79b9971ed9" translate="yes" xml:space="preserve">
          <source>Attempt to decrement the semaphore value, without blocking.</source>
          <target state="translated">차단하지 않고 세마포어 값을 낮추십시오.</target>
        </trans-unit>
        <trans-unit id="ec34329b732495345fe5c3d52450653e57f36518" translate="yes" xml:space="preserve">
          <source>Attempt to receive an incoming object, blocking if necessary.</source>
          <target state="translated">들어오는 객체를 받으려고 시도하고 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="cf506448c157bc98fe2eec29fc3993723c6b3208" translate="yes" xml:space="preserve">
          <source>Attempt to send an object through the channel, blocking if necessary.</source>
          <target state="translated">채널을 통해 객체를 보내려고 시도하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="a4d81396d4ea19197dfceaa774ef776332674285" translate="yes" xml:space="preserve">
          <source>Attribution</source>
          <target state="translated">Attribution</target>
        </trans-unit>
        <trans-unit id="1d5232d8974b6129a9030ab048587c67ca7be343" translate="yes" xml:space="preserve">
          <source>Avoid instantiating &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; directly. A newly constructed &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; has less secure defaults than one returned by &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;, dramatically so before Python 3.6.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 를&lt;/a&gt; 직접 인스턴스화하지 마십시오 . 새로 생성 된 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 것보다 안전하지 않은 기본값을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba279a92ffbafb8cc72dbd38711f804d9d1b907b" translate="yes" xml:space="preserve">
          <source>Avoids implicitly chaining the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; with any errors raised by &lt;code&gt;attempt_operation&lt;/code&gt; or &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt;, by keeping the &lt;code&gt;while True:&lt;/code&gt; loop outside of the &lt;code&gt;except BlockingIOError:&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;while True:&lt;/code&gt; &lt;code&gt;except BlockingIOError:&lt;/code&gt; 블록 외부에 while True : 루프 를 유지하여 &lt;code&gt;attempt_operation&lt;/code&gt; 또는 &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 에 의해 발생한 오류로 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 를 암시 적으로 연결 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31c7739aa209904fd9ba8df9b1d7877f93e87a25" translate="yes" xml:space="preserve">
          <source>Background: Why is async file I/O useful? The answer may surprise you</source>
          <target state="translated">배경 : 비동기 파일 I / O가 유용한 이유는 무엇입니까? 대답은 당신을 놀라게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="db8c739d137036e869b27d3cd349fef1d54e3fdc" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e1388bfa18042159b536ccc6a59591396e82930" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt;&lt;code&gt;typing.Generic&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">기본 : &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt; , 입력. &lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt; &lt;code&gt;typing.Generic&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a07e9c5dc09b0fdf3f845a0fb5af7389bc3e353" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d77761b5945e21f05a6d9cadcfc66f09270cc4b" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;trio.abc.Listener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;trio.abc.Listener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f328a04e58d3412dae1f568fe492e46d265a0c88" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92038ea6f8a928181a4be9c9cf1e7731b00e53e5" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8714f32f570efd29c979c0a1881e76c7d8b385e4" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7267bc2117470326945d1c053489fd33d1ef228e" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">기지 : &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5134303d2391790237c513240fb89f5fad90b2ad" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13b5e07d4d8d4268f2b1632299d27a69609c9e40" translate="yes" xml:space="preserve">
          <source>Basically the idea is that if you have code or tests that use sleeps and timeouts, you can use this to make it run much faster, totally automatically. (At least, as long as those sleeps/timeouts are happening inside Trio; if your test involves talking to external service and waiting for it to timeout then obviously we can&amp;rsquo;t help you there.)</source>
          <target state="translated">기본적으로 아이디어는 휴면 및 시간 초과를 사용하는 코드 또는 테스트가있는 경우이를 사용하여 훨씬 더 빠르게 완전히 자동으로 실행할 수 있다는 것입니다. (적어도 해당 휴면 / 시간 초과가 Trio 내부에서 발생하는 한 테스트에 외부 서비스와 대화하고 시간 초과를 기다리는 경우 분명히 도움을 줄 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="4390bc06787e8e996759d199f6a1f87bed1460ad" translate="yes" xml:space="preserve">
          <source>Be very careful to only use this decorator on functions that you know will either exit in bounded time, or else pass through a checkpoint regularly. (Of course all of your functions should have this property, but if you mess it up here then you won&amp;rsquo;t even be able to use control-C to escape!)</source>
          <target state="translated">이 데코레이터는 제한된 시간 안에 종료되거나 정기적으로 체크 포인트를 통과 할 것으로 알려진 함수에만 사용하십시오. (물론 모든 함수에는이 속성이 있어야하지만 여기서 엉망으로 만들면 control-C를 사용하여 벗어날 수도 없습니다!)</target>
        </trans-unit>
        <trans-unit id="f9a3eaabb5b822719bebd3e8a1b70ac9540e12dc" translate="yes" xml:space="preserve">
          <source>Before the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s effectively run underneath the call to &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;: if it raises an exception then that exception is reported by &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;, and does &lt;em&gt;not&lt;/em&gt; propagate out of the nursery. If &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is cancelled, then the child task is also cancelled.</source>
          <target state="translated">자식이 &lt;code&gt;task_status.started()&lt;/code&gt; 호출하기 전에 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 호출 아래에서 효과적으로 실행 됩니다. 예외가 발생하면 해당 예외가 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 의해보고되고 보육원에서 전파 되지 &lt;em&gt;않습니다&lt;/em&gt; . 경우 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 취소 된 후 자식 작업은 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b4738e9dc47bf1e56e7606833bf5d66a428561b1" translate="yes" xml:space="preserve">
          <source>Before you begin</source>
          <target state="translated">시작하기 전에</target>
        </trans-unit>
        <trans-unit id="6884e4f2d15ab622c9f8cbc3212f45de64615bea" translate="yes" xml:space="preserve">
          <source>Block until it&amp;rsquo;s possible that &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; might not block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 차단 될 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="17ae3ed338c93b1631e5994bf9cacece02cc9e67" translate="yes" xml:space="preserve">
          <source>Block until the internal flag value becomes True.</source>
          <target state="translated">내부 플래그 값이 True가 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="315b58797295c4e9ab36672b064ff4cedf0b8cef" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is readable.</source>
          <target state="translated">커널이 주어진 객체를 읽을 수 있다고보고 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="c30db991fe44ffdb355948594f4b7365cf09c9d1" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is writable.</source>
          <target state="translated">커널이 주어진 객체가 쓰기 가능하다고보고 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="fdf86495cf9c07d20eda78e1274970ceb5c363a7" translate="yes" xml:space="preserve">
          <source>Block until the process exits.</source>
          <target state="translated">프로세스가 종료 될 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="6ff527ef5176f8e0ddcdc55991a82729810d38d5" translate="yes" xml:space="preserve">
          <source>Block until there are no runnable tasks.</source>
          <target state="translated">실행 가능한 작업이 없을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="caa9b1343024d62a02aab103e75d10940fa49af7" translate="yes" xml:space="preserve">
          <source>Blocking and non-blocking methods</source>
          <target state="translated">차단 및 비 차단 방법</target>
        </trans-unit>
        <trans-unit id="84ce31b1f7f4ca1f1ba81c9b7ae32f8c48ff831b" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, blocking if necessary.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에서 토큰을 빌려 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="7b27cb01fa52d37acba5b81c12f4fcd1e8bf0f72" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, without blocking.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에서 토큰을 빌리지 않고 차용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e07ec7dd71dfd4d21fe8bb1251d8339701ccce3" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, blocking if necessary.</source>
          <target state="translated">자루에서 토큰을 빌려 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f7be4a505172b9a7559a09e6a12361762ade09" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, without blocking.</source>
          <target state="translated">차단하지 않고 자루에서 토큰을 빌립니다.</target>
        </trans-unit>
        <trans-unit id="f1496c7a3db3e007c3057cc8783649b651817057" translate="yes" xml:space="preserve">
          <source>Both hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">두 후크 모두 객체의 속성으로 표시되며 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dfefbef8c6a0e9381ea95ae6338587f901c36ba" translate="yes" xml:space="preserve">
          <source>Broadcasting an event with &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트로 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="352d325bf39240b4196dfbd3a6f4f8e3e54c1c98" translate="yes" xml:space="preserve">
          <source>Buffering in channels</source>
          <target state="translated">채널 버퍼링</target>
        </trans-unit>
        <trans-unit id="5615f1a1d3e7ea5900f404cdff5bd7a1d2d99a9e" translate="yes" xml:space="preserve">
          <source>Bug tracker and source code: &lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https://github.com/python-trio/trio&lt;/a&gt;</source>
          <target state="translated">버그 추적기 및 소스 코드 : &lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https://github.com/python-trio/trio&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c85441cc2270b299d4d728765785da223b4dbba" translate="yes" xml:space="preserve">
          <source>But even more interestingly, you can set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to zero or a small value, and then it will watch the execution of the run loop, and any time things have settled down and everyone&amp;rsquo;s waiting for a timeout, it jumps the clock forward to that timeout. In many cases this allows natural-looking code involving timeouts to be automatically run at near full CPU utilization with no changes. (Thanks to &lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;fluxcapacitor&lt;/a&gt; for this awesome idea.)</source>
          <target state="translated">그러나 더 흥미롭게도 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 를 0 또는 작은 값으로 설정할 수 있습니다. 그런 다음 실행 루프의 실행을보고 모든 일이 해결되고 모든 사람이 시간 초과를 기다리는 동안 시계가 해당 시간 초과로 이동합니다. . 대부분의 경우 타임 아웃과 관련된 자연스럽게 보이는 코드를 거의 전체 CPU 사용률로 변경없이 자동으로 실행할 수 있습니다. ( 이 멋진 아이디어에 대한 &lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;플럭스 커패시터&lt;/a&gt; 덕분 입니다.)</target>
        </trans-unit>
        <trans-unit id="c336aec89fecde4ca2a292b930cbc2263a0dcb64" translate="yes" xml:space="preserve">
          <source>But here&amp;rsquo;s the problem: for any individual I/O operation, there&amp;rsquo;s no way to know in advance whether it&amp;rsquo;s going to be one of the fast ones or one of the slow ones, so you can&amp;rsquo;t pick and choose. When you switch to async file I/O, it makes all the fast operations slower, and all the slow operations faster. Is that a win? In terms of overall speed, it&amp;rsquo;s hard to say: it depends what kind of disks you&amp;rsquo;re using and your kernel&amp;rsquo;s disk cache hit rate, which in turn depends on your file access patterns, how much spare RAM you have, the load on your service, &amp;hellip; all kinds of things. If the answer is important to you, then there&amp;rsquo;s no substitute for measuring your code&amp;rsquo;s actual behavior in your actual deployment environment. But what we &lt;em&gt;can&lt;/em&gt; say is that async disk I/O makes performance much more predictable across a wider range of runtime conditions.</source>
          <target state="translated">그러나 여기에 문제가 있습니다. 개별 I / O 작업의 경우 빠른 작업 중 하나인지 느린 작업 중 하나인지 미리 알 방법이 없으므로 선택 및 선택할 수 없습니다. 비동기 파일 I / O로 전환하면 모든 빠른 작업이 느려지고 모든 느린 작업이 빨라집니다. 그게 승리입니까? 전체 속도 측면에서 말하기는 어렵습니다. 사용하는 디스크 종류와 커널의 디스크 캐시 적중률에 따라 달라집니다. 이는 파일 액세스 패턴, 사용 가능한 예비 RAM의 양, 부하에 따라 다릅니다. 서비스,&amp;hellip; 모든 종류의 것들. 답이 중요하다면 실제 배포 환경에서 코드의 실제 동작을 측정 할 수있는 방법은 없습니다. 그러나 우리가 &lt;em&gt;할 수있는 것&lt;/em&gt; 비동기 디스크 I / O는 광범위한 런타임 조건에서 성능을 훨씬 더 예측 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="673eaaa36b6ee6e4487e1b49cb9a7a9b9b02d009" translate="yes" xml:space="preserve">
          <source>But if we want to write correct code in practice, then this principle is a little too sloppy and imprecise to be useful. How do we know which functions might block? What if a function blocks sometimes, but not others, depending on the arguments passed / network speed / phase of the moon? How do we figure out where the checkpoints are when we&amp;rsquo;re stressed and sleep deprived but still want to get this code review right, and would prefer to reserve our mental energy for thinking about the actual logic instead of worrying about checkpoints?</source>
          <target state="translated">그러나 실제로 올바른 코드를 작성하려면이 원칙이 너무 부끄럽고 유용하지 않습니다. 어떤 기능이 차단 될 수 있는지 어떻게 알 수 있습니까? 전달 된 인수 / 네트워크 속도 / 달의 인수에 따라 함수가 때때로 차단하지만 다른 것은 차단하지 않으면 어떻게됩니까? 스트레스를 받고 수면이 부족하지만 여전히이 코드 검토를 제대로 받고 싶을 때 체크 포인트의 위치를 ​​어떻게 알 수 있으며 체크 포인트에 대한 걱정 대신 실제 논리에 대해 생각하기 위해 정신적 에너지를 보존하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="28b63c1792b2c52de75b3ab70de595321eeb55ea" translate="yes" xml:space="preserve">
          <source>But if you read the docs for &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, you&amp;rsquo;ll see that all the pieces involved in wiring this up are public APIs, so you can adjust to suit the requirements of your tests. For example, here&amp;rsquo;s how to tweak a stream so that data flowing from left to right trickles in one byte at a time (but data flowing from right to left proceeds at full speed):</source>
          <target state="translated">그러나 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 대한 문서를 읽으면 이 배선에 관련된 모든 부분이 공용 API이므로 테스트 요구 사항에 맞게 조정할 수 있습니다. 예를 들어, 왼쪽에서 오른쪽으로 흐르는 데이터가 한 번에 한 바이트 씩 흐르도록 스트림을 조정하는 방법은 다음과 같습니다 (그러나 오른쪽에서 왼쪽으로 흐르는 데이터는 최대 속도로 진행됨).</target>
        </trans-unit>
        <trans-unit id="f830b9d400aed457d194359f0503b1ff2760384a" translate="yes" xml:space="preserve">
          <source>But of course, Trio isn&amp;rsquo;t the only coroutine runner in Python &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; has one, other event loops have them, you can even define your own.</source>
          <target state="translated">물론 Trio는 파이썬에서 유일한 코 루틴 러너가 아닙니다. &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 에는 하나의 이벤트 루프가 있으며 다른 이벤트 루프에도 자신 만의 것을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fceeabff672914a12928d15cad77ad846e4d22d" translate="yes" xml:space="preserve">
          <source>But this can be problematic. If you&amp;rsquo;re using h2 then &lt;em&gt;usually&lt;/em&gt; reading incoming data doesn&amp;rsquo;t create the need to send any data, so we don&amp;rsquo;t want to force every task that tries to read from the network to sit and wait a potentially long time for &lt;code&gt;sendall&lt;/code&gt; to finish. And in some situations this could even potentially cause a deadlock, if the remote peer is waiting for you to read some data before it accepts the data you&amp;rsquo;re sending.</source>
          <target state="translated">그러나 이것은 문제가 될 수 있습니다. h2를 사용하는 경우 &lt;em&gt;일반적으로&lt;/em&gt; 들어오는 데이터를 읽더라도 데이터를 보낼 필요가 없으므로 네트워크에서 읽으려고 시도하는 모든 작업이 &lt;code&gt;sendall&lt;/code&gt; 을 기다리는 시간이 길고 기다리도록 강요하지 않습니다. 끝. 원격 피어가 전송중인 데이터를 수락하기 전에 일부 데이터 읽기를 기다리는 경우 상황에 따라 교착 상태가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="412c1b16e781ad814146eddc07e4fd649b546625" translate="yes" xml:space="preserve">
          <source>But this is more error-prone, especially if you use a loop to spawn the producers/consumers.</source>
          <target state="translated">그러나 루프를 사용하여 생산자 / 소비자를 생성하는 경우 특히 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="530bcde7f320efe9c1c4e3043d433d9a24c64568" translate="yes" xml:space="preserve">
          <source>But, even if that happens, we&amp;rsquo;re not out of the woods yet! After the producers exit, the two consumers race to be the first to notice that the &lt;code&gt;send_channel&lt;/code&gt; has closed. Suppose that X wins the race. It exits its &lt;code&gt;async for&lt;/code&gt; loop, then exits the &lt;code&gt;async with&lt;/code&gt; block&amp;hellip; and closes the &lt;code&gt;receive_channel&lt;/code&gt;, while Y is still using it. Again, this causes a crash.</source>
          <target state="translated">그러나 그렇게 되더라도 우리는 아직 숲에서 벗어난 것이 아닙니다! 생산자가 종료 한 후 두 소비자는 &lt;code&gt;send_channel&lt;/code&gt; 이 닫 혔음 을 가장 먼저 알립니다 . X가 경쟁에서 이긴다고 가정하십시오. 그것은 그것의 종료 &lt;code&gt;async for&lt;/code&gt; 이어서, 루프를 종료 &lt;code&gt;async with&lt;/code&gt; 블록 ... 및 폐쇄 &lt;code&gt;receive_channel&lt;/code&gt; 를 Y를 여전히 사용하는 동안. 다시 말하지만 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16f5c9c07cafa159b445098218243944b7cef14f" translate="yes" xml:space="preserve">
          <source>But, of course, the entire point of an async library is to let you do multiple things at once. The one and only way to do that in Trio is through the task spawning interface. So if you want your program to walk &lt;em&gt;and&lt;/em&gt; chew gum, this is the section for you.</source>
          <target state="translated">물론 비동기 라이브러리의 요점은 한 번에 여러 작업을 수행하는 것입니다. Trio에서이를 수행하는 유일한 방법은 작업 생성 인터페이스를 사용하는 것입니다. 그래서 당신은 당신의 프로그램이 걸어하려는 경우 &lt;em&gt;와&lt;/em&gt; 씹는 껌, 이것은 당신을위한 섹션이다.</target>
        </trans-unit>
        <trans-unit id="08e147f3bc16786707a8ac015a5f1b0329a64f59" translate="yes" xml:space="preserve">
          <source>By convention, a return code of zero indicates success. On UNIX, negative values indicate termination due to a signal, e.g., -11 if terminated by signal 11 (&lt;code&gt;SIGSEGV&lt;/code&gt;). On Windows, a process that exits due to a call to &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate()&lt;/code&gt;&lt;/a&gt; will have an exit status of 1.</source>
          <target state="translated">일반적으로 리턴 코드 0은 성공을 나타냅니다. UNIX에서 음수 값은 신호로 인한 종료를 나타냅니다 (예 : 신호 11 ( &lt;code&gt;SIGSEGV&lt;/code&gt; )로 종료 된 경우 -11 ). Windows에서 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate()&lt;/code&gt; &lt;/a&gt; 호출로 인해 종료되는 프로세스 는 종료 상태가 1입니다.</target>
        </trans-unit>
        <trans-unit id="3a7a80e6ffbfb28cc8f945974fc47d089de603d5" translate="yes" xml:space="preserve">
          <source>By default for TCP sockets, &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; enables &lt;code&gt;TCP_NODELAY&lt;/code&gt;, and (on platforms where it&amp;rsquo;s supported) enables &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; with a reasonable buffer size (currently 16 KiB) &amp;ndash; see &lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;issue #72&lt;/a&gt; for discussion. You can of course override these defaults by calling &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TCP 소켓의 경우 기본적으로 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 를 활성화 하고 지원되는 플랫폼에서 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; 를 적당한 버퍼 크기 (현재 16KiB )로 활성화 합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;문제 # 72&lt;/a&gt; 를 참조하십시오 . 물론 &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt; 를 호출하여 이러한 기본값을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60f1cefb4d269d53a93fd1da99c35ecbcaa23759" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; uses a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; to limit the number of threads running at once; see &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 를 사용하여 한 번에 실행되는 스레드 수를 제한합니다. 자세한 내용은 &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f9393fd07494846f3c9bd78e82bb2a27abf584b" translate="yes" xml:space="preserve">
          <source>By default, Trio uses an unspecified monotonic clock, but this can be changed by passing a custom clock object to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; (e.g. for testing).</source>
          <target state="translated">기본적으로 Trio는 지정되지 않은 단조로운 시계를 사용하지만 사용자 정의 시계 객체를 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 에 전달하여 (예 : 테스트) 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="479052e549b38b3cf5c8f080e4bba3e93ef2d967" translate="yes" xml:space="preserve">
          <source>By default, Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; functions use the standard system resolver functions. This function allows you to customize that behavior. The main intended use case is for testing, but it might also be useful for using third-party resolvers like &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; (though be warned that these rarely make perfect drop-in replacements for the system resolver). See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 Trio의 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 함수는 표준 시스템 확인자 함수를 사용합니다. 이 기능을 사용하면 해당 동작을 사용자 정의 할 수 있습니다. 의도 된 주요 사용 사례는 테스트 용이지만 &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; 와 같은 타사 리졸버를 사용하는 경우에도 유용 할 수 있습니다 (시스템 리졸버를 완벽하게 대체 할 수있는 경우는 거의 없음). 자세한 내용은 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5700d3cb14d3369161e0910959cf3905cb1f858" translate="yes" xml:space="preserve">
          <source>By default, it starts at time 0, and clock time only advances when you explicitly call &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt;. This provides an extremely controllable clock for testing.</source>
          <target state="translated">기본적으로 시간은 0에서 시작하며 명시 적으로 &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt; 호출 할 때만 클럭 시간이 진행됩니다 . 이것은 테스트를 위해 매우 제어 가능한 클럭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b58f2f817ed55edb23f17dd398967d3698d94d89" translate="yes" xml:space="preserve">
          <source>By default, system tasks have &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection &lt;em&gt;enabled&lt;/em&gt;. If you want your task to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly (and come up with some plan for what to do with a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, given that system tasks aren&amp;rsquo;t allowed to raise exceptions).</source>
          <target state="translated">기본적으로 시스템 작업에는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; protection이 &lt;em&gt;활성화되어&lt;/em&gt; 있습니다. control-C로 작업을 중단 할 수있게하려면 &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로 사용해야 합니다 (시스템 작업에서 예외를 발생시킬 수없는 경우 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 로 수행 할 작업에 대한 계획 이 필요함 ).</target>
        </trans-unit>
        <trans-unit id="5c5a4be5f8c5502c9f134af83e0fc52fbf1d81d1" translate="yes" xml:space="preserve">
          <source>By default, this will print &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; and then immediately exit; with our trickle stream it instead sleeps 1 second, then prints &lt;code&gt;b&quot;1&quot;&lt;/code&gt;, then sleeps 1 second, then prints &lt;code&gt;b&quot;2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">기본적으로 &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; 인쇄 한 다음 즉시 종료합니다. 우리의 물방울 스트림을 사용하면 대신 1 초 동안 잠자기 한 다음 &lt;code&gt;b&quot;1&quot;&lt;/code&gt; 을 인쇄 한 다음 1 초 동안 잠자기 한 다음 &lt;code&gt;b&quot;2&quot;&lt;/code&gt; 등 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="eadf7b64718fcecec9e169b6cd95cc0cf6518eb8" translate="yes" xml:space="preserve">
          <source>Call this before closing a file descriptor or &lt;code&gt;SOCKET&lt;/code&gt; handle that another task might be waiting on. This will cause any &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt;&lt;code&gt;wait_writable&lt;/code&gt;&lt;/a&gt; calls to immediately raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 태스크가 대기중인 파일 디스크립터 또는 &lt;code&gt;SOCKET&lt;/code&gt; 핸들을 닫기 전에이를 호출하십시오 . 이로 인해 &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt; &lt;code&gt;wait_writable&lt;/code&gt; &lt;/a&gt; 호출이 즉시 &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8bc1558d2fe1a2c54a2a164cbb59e5c8c644a3a1" translate="yes" xml:space="preserve">
          <source>Called after handling pending I/O.</source>
          <target state="translated">보류중인 I / O를 처리 한 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bfde0992ada594581390a46c166b77baca3161" translate="yes" xml:space="preserve">
          <source>Called at the beginning of &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 시작 부분에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f2793beb004add327f22b3156bfba07b27d6e11" translate="yes" xml:space="preserve">
          <source>Called at the beginning of the run.</source>
          <target state="translated">실행이 시작될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f7acf6acc0d0f3320d572dca39e7a7e07743123e" translate="yes" xml:space="preserve">
          <source>Called before blocking to wait for I/O readiness.</source>
          <target state="translated">I / O 준비를 기다리는 동안 차단하기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1f142fccb8ca1dc1831e93b467e4f3395cda028f" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c1d3563dccbfdd83877b549758692595c9c581" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="aed9b81d2c1131bfffe4d070ed0619e875566978" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d66f6f8b90776c10ddba63543e685f9f3d93f60" translate="yes" xml:space="preserve">
          <source>Called immediately before we resume running the given task.</source>
          <target state="translated">주어진 작업을 재개하기 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="261a5d5178d7387f8183212c0cd69cb1977900da" translate="yes" xml:space="preserve">
          <source>Called just before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 리턴 하기 직전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="b884c70436293eb060bb3491a325d480b9671ac9" translate="yes" xml:space="preserve">
          <source>Called when the given task becomes runnable.</source>
          <target state="translated">주어진 작업을 실행할 수있게되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="35ab13509c0b0bba5b8df114b0b980a549bd6031" translate="yes" xml:space="preserve">
          <source>Called when the given task exits.</source>
          <target state="translated">주어진 작업이 종료 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="626700fae10a1356415b4972c54ece4515e4c958" translate="yes" xml:space="preserve">
          <source>Called when the given task is created.</source>
          <target state="translated">주어진 작업이 생성 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="233443fcf281f0b8386a0968b812f850857ffd12" translate="yes" xml:space="preserve">
          <source>Called when we return to the main run loop after a task has yielded.</source>
          <target state="translated">작업이 발생한 후 기본 실행 루프로 돌아갈 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e360b3ae69814d2bc4f200eb26320d68ccd43c" translate="yes" xml:space="preserve">
          <source>Calling:</source>
          <target state="translated">Calling:</target>
        </trans-unit>
        <trans-unit id="ca6c307d3032f60efa049582739a99b205d7915a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;aclose&lt;/code&gt; on both underlying streams.</source>
          <target state="translated">기본 스트림 모두에서 통화가 &lt;code&gt;aclose&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="08c519dcd2a8fb0112b30c9b37377bc0d2e81245" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.receive_stream.receive_some&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.receive_stream.receive_some&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="8772d34b9efd174bb2bc372d12b3a9aef3fdba3c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.send_all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.send_stream.send_all&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="689c7ef3178baffe7752a81f89957ee75f40366d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="6dcbaa082561c00fc529f363d4aea0631e29f017" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; (if any), and then retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; &lt;/a&gt; (있는 경우)을 호출 한 다음 내부 버퍼에서 데이터를 검색하여 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="a6e5e384d9f188aacab0c35281723d4e24af136b" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt;&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt;&lt;/a&gt; (if any), and then returns immediately.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt; &lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &lt;/a&gt; (있는 경우)을 호출 한 다음 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f10923fa9e8e643d29ab59bd93446bf992a6d907" translate="yes" xml:space="preserve">
          <source>Cancel scopes are not reusable or reentrant; that is, each cancel scope can be used for at most one &lt;code&gt;with&lt;/code&gt; block. (You&amp;rsquo;ll get a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; if you violate this rule.)</source>
          <target state="translated">취소 범위는 재사용하거나 재진입 할 ​​수 없습니다. 즉, 각각의 범위는 최대 하나에서 사용될 수 취소 &lt;code&gt;with&lt;/code&gt; 블록. (당신은 얻을 것이다 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에가&lt;/a&gt; 이 규칙을 위반하는 경우.)</target>
        </trans-unit>
        <trans-unit id="81686d1e66168847e2ace4f30aee9372739e14a4" translate="yes" xml:space="preserve">
          <source>Cancellation API details</source>
          <target state="translated">취소 API 세부 사항</target>
        </trans-unit>
        <trans-unit id="d6d584a8ce62812cd18c2c454f3ca9d1ca893f41" translate="yes" xml:space="preserve">
          <source>Cancellation and primitive operations</source>
          <target state="translated">취소 및 원시 작업</target>
        </trans-unit>
        <trans-unit id="bef7bb5e57e5a92b8be6213bc977ef4ea4184ce0" translate="yes" xml:space="preserve">
          <source>Cancellation and timeouts</source>
          <target state="translated">취소 및 타임 아웃</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">취소 의미론</target>
        </trans-unit>
        <trans-unit id="94d6332b8909ea75970b6b4fdc80b35ecc20fba7" translate="yes" xml:space="preserve">
          <source>Cancellations in Trio are &amp;ldquo;level triggered&amp;rdquo;, meaning that once a block has been cancelled, &lt;em&gt;all&lt;/em&gt; cancellable operations in that block will keep raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This helps avoid some pitfalls around resource clean-up. For example, imagine that we have a function that connects to a remote server and sends some messages, and then cleans up on the way out:</source>
          <target state="translated">Trio의 취소는 &quot;레벨 트리거&quot;로, 일단 블록이 취소되면 해당 블록의 &lt;em&gt;모든&lt;/em&gt; 취소 가능한 작업이 계속 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 냅니다. 이렇게하면 리소스 정리와 관련된 함정을 피할 수 있습니다. 예를 들어, 원격 서버에 연결하고 일부 메시지를 보낸 다음 나가는 도중에 정리하는 기능이 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="0d2c360a80f52470e7f8b83eff4301ca10ff10b3" translate="yes" xml:space="preserve">
          <source>Cancels this scope immediately.</source>
          <target state="translated">이 범위를 즉시 취소합니다.</target>
        </trans-unit>
        <trans-unit id="31ceffa7c4fe7185611cc1eb3c159aad57550985" translate="yes" xml:space="preserve">
          <source>Channel objects can be closed by calling &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using &lt;code&gt;async with&lt;/code&gt;. They are &lt;em&gt;not&lt;/em&gt; automatically closed when garbage collected. Closing memory channels isn&amp;rsquo;t mandatory, but it is generally a good idea, because it helps avoid situations where tasks get stuck waiting on a channel when there&amp;rsquo;s no-one on the other side. See &lt;a href=&quot;#channel-shutdown&quot;&gt;Clean shutdown with channels&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 &lt;code&gt;async with&lt;/code&gt; 사용하여 채널 객체를 닫을 수 있습니다 . 그들은되어 &lt;em&gt;있지&lt;/em&gt; 쓰레기 수집 할 때 자동으로 닫힙니다. 메모리 채널을 닫는 것은 필수는 아니지만 다른쪽에 아무도 없을 때 작업이 채널에서 대기하는 상황을 피하는 데 도움이되므로 일반적으로 좋은 생각입니다. 자세한 내용 &lt;a href=&quot;#channel-shutdown&quot;&gt;은 채널&lt;/a&gt; 을 사용한 클린 셧다운을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5beb5dd56408be62815ea722ff005781ac57b3c1" translate="yes" xml:space="preserve">
          <source>Cheat sheet:</source>
          <target state="translated">컨닝 지:</target>
        </trans-unit>
        <trans-unit id="5d0402051b976bb8c461f7092dd83b539f201202" translate="yes" xml:space="preserve">
          <source>Check if the process has exited yet.</source>
          <target state="translated">프로세스가 아직 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="99dce9cfa994376c7012637e31516c6ac05c9b2e" translate="yes" xml:space="preserve">
          <source>Check that &lt;a href=&quot;reference-core#trio.sleep&quot;&gt;&lt;code&gt;trio.sleep()&lt;/code&gt;&lt;/a&gt; is a checkpoint, even if it doesn&amp;rsquo;t block:</source>
          <target state="translated">차단하지 않더라도 &lt;a href=&quot;reference-core#trio.sleep&quot;&gt; &lt;code&gt;trio.sleep()&lt;/code&gt; &lt;/a&gt; 이 체크 포인트 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dd73b1e659a659ad6d4dcaea475a5cc4de5b8c4" translate="yes" xml:space="preserve">
          <source>Check the current value of an option on the underlying socket.</source>
          <target state="translated">기본 소켓에서 옵션의 현재 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="20967b01d8903985483d3209955125b8ee51474f" translate="yes" xml:space="preserve">
          <source>Check whether the calling code has &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled.</source>
          <target state="translated">호출 코드에 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="88e1669ff508c58005f68fe9617b0958a0b4a996" translate="yes" xml:space="preserve">
          <source>Check whether the lock is currently held.</source>
          <target state="translated">잠금이 현재 보유되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5ae0d67fbacc52e0c961355167ed1dcc9fdc273e" translate="yes" xml:space="preserve">
          <source>Check whether the socket is readable or not.</source>
          <target state="translated">소켓을 읽을 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4008592f35f63d2ce5cf53beec32dcc247cc261c" translate="yes" xml:space="preserve">
          <source>Check whether the underlying lock is currently held.</source>
          <target state="translated">기본 잠금이 현재 보유되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a2b3a59adb81ffe32d8631c171b886f3d460360a" translate="yes" xml:space="preserve">
          <source>Checkpoints</source>
          <target state="translated">Checkpoints</target>
        </trans-unit>
        <trans-unit id="aad917cb07530e653ce3782a304aa67132789402" translate="yes" xml:space="preserve">
          <source>Child tasks and cancellation</source>
          <target state="translated">아동 업무 및 취소</target>
        </trans-unit>
        <trans-unit id="01c92ef80410cf8e2458b13dd6e02e97ff4b05f5" translate="yes" xml:space="preserve">
          <source>Clean shutdown with channels</source>
          <target state="translated">채널을 이용한 클린 셧다운</target>
        </trans-unit>
        <trans-unit id="784258aa3e82bf98876fffb3b3acb5f4cbe86b6c" translate="yes" xml:space="preserve">
          <source>Cleanly close down the SSL/TLS encryption layer, allowing the underlying stream to be used for unencrypted communication.</source>
          <target state="translated">SSL / TLS 암호화 계층을 완전히 닫아 암호화되지 않은 통신에 기본 스트림을 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5fa38c822c36efd1393228e6e95fbf224d0de0c2" translate="yes" xml:space="preserve">
          <source>Clone this receive channel object.</source>
          <target state="translated">이 수신 채널 오브젝트를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="26f9ba049c495ce23a501d2faccd6b6380ec2d77" translate="yes" xml:space="preserve">
          <source>Clone this send channel object.</source>
          <target state="translated">이 송신 채널 오브젝트를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="53b3076f17b316cb84b6c29640d7e43f09e5ae18" translate="yes" xml:space="preserve">
          <source>Close an async resource or async generator immediately, without blocking to do any graceful cleanup.</source>
          <target state="translated">정상적인 정리 작업을 차단하지 않고 비동기 리소스 또는 비동기 생성기를 즉시 닫습니다.</target>
        </trans-unit>
        <trans-unit id="035296db4c7f1acd83221d71dd8e4179d8a62b32" translate="yes" xml:space="preserve">
          <source>Close any pipes we have to the process (both input and output) and wait for it to exit.</source>
          <target state="translated">프로세스에 필요한 파이프 (입력 및 출력 모두)를 닫고 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="588a267fa1c5900f167e70a9805d55eb4e9fae92" translate="yes" xml:space="preserve">
          <source>Close the transport listener.</source>
          <target state="translated">전송 리스너를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="92a76bf8154c807de0dcad6ffb92786e9a377d3f" translate="yes" xml:space="preserve">
          <source>Close this listener and its underlying socket.</source>
          <target state="translated">이 리스너와 기본 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a357d054163bbdbd417f533dddc5214d41ff476e" translate="yes" xml:space="preserve">
          <source>Close this resource, possibly blocking.</source>
          <target state="translated">이 리소스를 닫으면 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="746e8bd7005ece0b3884461868490a2886db15a2" translate="yes" xml:space="preserve">
          <source>Code of conduct: Contributors are requested to follow our &lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;code of conduct&lt;/a&gt; in all project spaces.</source>
          <target state="translated">행동 강령 : 기고자는 모든 프로젝트 공간에서 &lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;행동 강령&lt;/a&gt; 을 따라야 합니다.</target>
        </trans-unit>
        <trans-unit id="d28ccf5a13cb7101b38230ecb28bea934cb4291f" translate="yes" xml:space="preserve">
          <source>Combine this path with one or several arguments, and return a new path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).</source>
          <target state="translated">이 경로를 하나 이상의 인수와 결합하고 하위 경로 (모든 인수가 상대 경로 인 경우) 또는 완전히 다른 경로 (인수 중 하나가 고정 된 경우)를 나타내는 새 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="65245cc21eba1d1c7e7fddcf1b4438e65f650376" translate="yes" xml:space="preserve">
          <source>Compute the real time until the given deadline.</source>
          <target state="translated">주어진 마감일까지 실시간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d188261dfbdc2cfd51eb5fff57de708b9c31454d" translate="yes" xml:space="preserve">
          <source>Connect the socket to a remote address.</source>
          <target state="translated">소켓을 원격 주소에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="800add8197c9d879f3f1a2c8248892a00488ba45" translate="yes" xml:space="preserve">
          <source>Connect to the given &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 에&lt;/a&gt; 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="698feffa6fbdf24c6dd24be1554ee55fedb5f42d" translate="yes" xml:space="preserve">
          <source>Connect to the given host and port over TCP.</source>
          <target state="translated">TCP를 통해 지정된 호스트 및 포트에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="dd0929c6d129ec17dfa57ea8a0921e4c15b090b4" translate="yes" xml:space="preserve">
          <source>Connecting to an in-process socket server</source>
          <target state="translated">처리중인 소켓 서버에 연결</target>
        </trans-unit>
        <trans-unit id="4b801243997b335019aa4cb1a2eda249a55d038e" translate="yes" xml:space="preserve">
          <source>Contains all the child &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects which are still running.</source>
          <target state="translated">여전히 실행중인 모든 하위 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3bddea3d2467ed7b12f0ab27cd877bc1cf844289" translate="yes" xml:space="preserve">
          <source>Contributing to Trio and related projects</source>
          <target state="translated">트리오 및 관련 프로젝트에 기여</target>
        </trans-unit>
        <trans-unit id="dd8d019f05b4b5b283596920dd515b31a77df643" translate="yes" xml:space="preserve">
          <source>Contributor guide: &lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https://trio.readthedocs.io/en/latest/contributing.html&lt;/a&gt;</source>
          <target state="translated">기고자 안내서 : &lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https://trio.readthedocs.io/en/latest/contributing.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e29f2bf28ae181dcc1f858f04d215a291dc038c" translate="yes" xml:space="preserve">
          <source>Convert a blocking operation into an async operation using a thread.</source>
          <target state="translated">스레드를 사용하여 블로킹 작업을 비동기 작업으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="276de9a62bb932e4c343f213f05d286af43a0d3e" translate="yes" xml:space="preserve">
          <source>Convert a standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt; object into a Trio socket object.</source>
          <target state="translated">표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 객체를 Trio 소켓 객체로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c024281ced10e6a1d03ece9c47de83e6ef569254" translate="yes" xml:space="preserve">
          <source>Create &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; objects to listen for TCP connections.</source>
          <target state="translated">TCP 연결을 청취 할 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e347faadc22e2b28043f6892d02ba59794212183" translate="yes" xml:space="preserve">
          <source>Create a connected, pure Python, unidirectional stream where data flows in lockstep.</source>
          <target state="translated">데이터가 잠금 단계로 흐르는 연결된 순수 Python, 단방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2be9228bbeea61d2f22276d384ece99dd757e610" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream where data flows in lockstep.</source>
          <target state="translated">데이터가 잠금 단계로 흐르는 연결된 순수 Python 양방향 스트림을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="afd5545b50d0fd9918e03f162eea8fed63bbf9a5" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">무한 버퍼링 및 유연한 구성 옵션을 사용하여 연결된 순수 Python 양방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="16fd426e055ccfde61ebd50613e240b90a4120de" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, unidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">무한 버퍼링 및 유연한 구성 옵션으로 연결된 순수 Python 단방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4c5674378b77c928b661f2f5d24e4b5af9e0efb8" translate="yes" xml:space="preserve">
          <source>Create a new Trio socket, like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 과 같은 새 Trio 소켓을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e6d00615f23bd18743bd5e4f3fbb5bf3051fd73f" translate="yes" xml:space="preserve">
          <source>Create and return a socket object.</source>
          <target state="translated">소켓 객체를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf47fcd675898eff0e3b8e79ec7d8b7bb8c7284" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given deadline, and raises an error if it is actually cancelled.</source>
          <target state="translated">주어진 최종 기한이있는 취소 범위를 작성하고 실제로 취소 된 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f93b3b45c8ea9164c989693e6fa16a0100351871" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given timeout, and raises an error if it is actually cancelled.</source>
          <target state="translated">지정된 시간 초과로 취소 범위를 만들고 실제로 취소 된 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3f897b8e6c02e94ce9b26b00cb7864784b899fb" translate="yes" xml:space="preserve">
          <source>Creates a child task, scheduling &lt;code&gt;await async_fn(*args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await async_fn(*args)&lt;/code&gt; 예약하여 하위 작업을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ee1e2c14a1406cbe854dca9278d7dd0b325b77bc" translate="yes" xml:space="preserve">
          <source>Creates and initalizes a child task.</source>
          <target state="translated">자식 작업을 생성하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b2bec567835477658a29d71119dd0209ee2ddec3" translate="yes" xml:space="preserve">
          <source>Creating a nursery also implicitly creates a cancellation scope, which is exposed as the &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt;&lt;code&gt;cancel_scope&lt;/code&gt;&lt;/a&gt; attribute. This is used internally to implement the logic where if an error occurs then &lt;code&gt;__aexit__&lt;/code&gt; cancels all children, but you can use it for other things, e.g. if you want to explicitly cancel all children in response to some external event.</source>
          <target state="translated">종묘장을 만들면 취소 범위가 암시 적으로 생성되어 &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt; &lt;code&gt;cancel_scope&lt;/code&gt; &lt;/a&gt; 속성으로 노출됩니다 . 이것은 오류가 발생하면 &lt;code&gt;__aexit__&lt;/code&gt; 가 모든 자식을 취소 하는 논리를 구현하기 위해 내부적으로 사용 되지만, 외부 이벤트에 대한 응답으로 모든 자식을 명시 적으로 취소하려는 경우와 같이 다른 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6dfd567b7a3307a537cbe53c08739b6a191602" translate="yes" xml:space="preserve">
          <source>Currently the following fields are defined:</source>
          <target state="translated">현재 다음 필드가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b917c15a50ea6342a17c9063be5bcf13e4adf47b" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; is simply an alias for &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, but (a) this may not always be true in the future, especially if Trio ever implements &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;more sophisticated scheduling policies&lt;/a&gt;, and (b) the above code is relying on a pretty subtle property of its lock. Using a &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; acts as an executable reminder that you&amp;rsquo;re relying on this property.</source>
          <target state="translated">현재 &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; 는&lt;/a&gt; 별칭 단순히 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 하지만, (a)이 항상 미래에 진실하지 않을 수 있습니다, 특히 경우 트리오 적 구현 &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;보다 정교한 스케줄링 정책&lt;/a&gt; , 그리고 (b) 위의 코드는 꽤 미묘한 특성에 의존 자사의 자물쇠. &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; 을&lt;/a&gt; 사용하면 이 속성에 의존하고 있음을 알리는 실행 가능한 알림 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="c8852ce839266b1032f3de681f74884aa8adf52b" translate="yes" xml:space="preserve">
          <source>Currently, Trio always uses unbuffered byte streams for communicating with a process, so it does not support the &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;universal_newlines&lt;/code&gt; (alias &lt;code&gt;text&lt;/code&gt; in 3.7+), and &lt;code&gt;bufsize&lt;/code&gt; options.</source>
          <target state="translated">현재 Trio는 프로세스와 통신하기 위해 항상 버퍼링되지 않은 바이트 스트림을 사용하므로 &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; , &lt;code&gt;universal_newlines&lt;/code&gt; ( 3.7 이상의 &lt;code&gt;text&lt;/code&gt; ) 및 &lt;code&gt;bufsize&lt;/code&gt; 옵션을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a22eac18305a1e1dc5892e7f5be351ae472656bb" translate="yes" xml:space="preserve">
          <source>Custom supervisors</source>
          <target state="translated">맞춤형 감독자</target>
        </trans-unit>
        <trans-unit id="37671df58880918e942ce4bc136b98bb7f52aac2" translate="yes" xml:space="preserve">
          <source>Debugging and instrumentation</source>
          <target state="translated">디버깅 및 계측</target>
        </trans-unit>
        <trans-unit id="ac0a627ff292b052255162959a08edc910141a7f" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as protected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;. (Though if it contains any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, then it can still receive &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at those. This is considered a polite interruption.)</source>
          <target state="translated">주어진 정규 함수, 생성기 함수, 비동기 함수 또는 비동기 생성기 함수를 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 보호 된 것으로 표시하는 데코레이터 . 즉,이 함수 내부의 코드 는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 에&lt;/a&gt; 의해 &lt;em&gt;거의&lt;/em&gt; 중단 &lt;em&gt;되지 않습니다&lt;/em&gt; . ( &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 가 포함되어 있어도 여전히 해당 포인트 에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 수신 할 수 있습니다 . 이는 정중 한 인터럽트로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="f21a3283f7231f03c1af0a06d7cc4980ad8fdace" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as unprotected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;can&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at any moment.</source>
          <target state="translated">주어진 정규 함수, 생성기 함수, 비동기 함수 또는 비동기 생성기 함수를 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 보호되지 않은 것으로 표시하는 데코레이터 . 즉,이 함수 내부의 코드 는 언제든지 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 의해 거의 중단 될 &lt;em&gt;수&lt;/em&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2a5cb3fa4689c389726d66d794778a89c63a2e" translate="yes" xml:space="preserve">
          <source>Decrement the semaphore value, blocking if necessary to avoid letting it drop below zero.</source>
          <target state="translated">세마포어 값을 낮추고 필요한 경우 0 미만으로 떨어지지 않도록 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="39db43b218a6486fec3ada3896d1474afb067886" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, though this can be overridden by the &lt;code&gt;shield=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">기본값은 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 이지만, 이것은 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 생성자 에 대한 &lt;code&gt;shield=&lt;/code&gt; 인수로 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcda29f4558d93a7bbbd6d484ebff9ce0dc4358d" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, which means &amp;ldquo;no deadline&amp;rdquo;, though this can be overridden by the &lt;code&gt;deadline=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; 는 &quot;마감일 없음&quot;을 의미하지만, 이는 deadScope &lt;code&gt;deadline=&lt;/code&gt; 인수로 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 생성자에 의해 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1d70f0971455d22b791a3109b5b80c647c7c40a" translate="yes" xml:space="preserve">
          <source>Design and internals</source>
          <target state="translated">디자인과 내부</target>
        </trans-unit>
        <trans-unit id="7cca6a5cf867780c8e3f34ab51803e9dfcfd0b0c" translate="yes" xml:space="preserve">
          <source>Despite the name, this class currently inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt;, because while we&amp;rsquo;re in young-and-aggressive mode we want these warnings to be visible by default. You can hide them by installing a filter or with the &lt;code&gt;-W&lt;/code&gt; switch: see the &lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">이름에도 불구하고,이 클래스는 현재 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; 이&lt;/a&gt; 아니라 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt; 에서 상속받습니다 . 젊고 공격적인 모드에있을 때 이러한 경고가 기본적으로 표시되기를 원하기 때문입니다. 필터를 설치하거나 &lt;code&gt;-W&lt;/code&gt; 스위치를 사용하여 숨길 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d07097459810ff8d556f864eef0251cbd4763961" translate="yes" xml:space="preserve">
          <source>Different environments expose different low-level APIs for performing async I/O. &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</source>
          <target state="translated">환경에 따라 비동기 I / O를 수행하기 위해 서로 다른 저수준 API가 노출됩니다. &lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 는 이러한 API를 비교적 직접적인 방식으로 노출하여 더 높은 수준의 코드를위한 최대의 성능과 유연성을 제공합니다. 그러나 이는 제공되는 정확한 API가 어떤 시스템 Trio가 실행 중인지에 따라 달라질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d53b85148fd0778fe09804c73cc97015c67517b5" translate="yes" xml:space="preserve">
          <source>Discards any pending data from the internal buffer, and marks this stream as closed.</source>
          <target state="translated">내부 버퍼에서 보류중인 데이터를 버리고이 스트림을 닫힌 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="eb69b4f0d0a5c5bb423cba52d380509e75983c19" translate="yes" xml:space="preserve">
          <source>Discussion forum: &lt;a href=&quot;https://trio.discourse.group&quot;&gt;https://trio.discourse.group&lt;/a&gt;</source>
          <target state="translated">토론 포럼 : &lt;a href=&quot;https://trio.discourse.group&quot;&gt;https://trio.discourse.group&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc6639be7bef8ebc4645daa5f535d0c081d565f7" translate="yes" xml:space="preserve">
          <source>Do any setup this clock might need.</source>
          <target state="translated">이 시계에 필요한 설정을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3746016608ec0fb055b71a5ef557a7383f775460" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse this with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&amp;ldquo;leaky bucket&amp;rdquo;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&amp;ldquo;token bucket&amp;rdquo;&lt;/a&gt; algorithms used to limit bandwidth usage on networks. The basic idea of using tokens to track a resource limit is similar, but this is a very simple sack where tokens aren&amp;rsquo;t automatically created or destroyed over time; they&amp;rsquo;re just borrowed and then put back.</source>
          <target state="translated">네트워크의 대역폭 사용을 제한하는 데 사용되는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&quot;누설 버킷&quot;&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&quot;토큰 버킷&quot;&lt;/a&gt; 알고리즘 과 혼동하지 마십시오 . 자원 제한을 추적하기 위해 토큰을 사용하는 기본 개념은 비슷하지만 시간이지나면서 토큰이 자동으로 생성되거나 파괴되지 않는 매우 간단한 자루입니다. 그들은 방금 빌린 다음 다시 넣습니다.</target>
        </trans-unit>
        <trans-unit id="49e4cf834c2c18317da25833af31c4c049a6fee9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry &amp;ndash; Trio&amp;rsquo;s got your back. Since checkpoints are important and ubiquitous, we make it as simple as possible to keep track of them. Here are the rules:</source>
          <target state="translated">걱정 마세요 &amp;ndash; 트리오가 등을 맞았습니다. 검사 점이 중요하고 어디에나 있기 때문에 가능한 한 간단하게 검사 점을 추적 할 수 있습니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="913f6fc58a1e961561938ad5dac8c30039297367" translate="yes" xml:space="preserve">
          <source>Due to limitations of the underlying operating system APIs, it is not always possible to properly cancel a connection attempt once it has begun. If &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled, and is unable to abort the connection attempt, then it will:</source>
          <target state="translated">기본 운영 체제 API의 한계로 인해 시작된 연결 시도를 항상 올바르게 취소 할 수있는 것은 아닙니다. 경우 &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 해제하고 연결 시도를 중단 할 수없는되어, 그것은 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f3a5eb11d87d8dcf932da28283e1ab1bca1ea3f4" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has exactly one associated &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; object, so you can use it to identify a particular call.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 각 호출 에는 정확히 하나의 연결된 &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 객체가 있으므로이를 사용하여 특정 호출을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e85ee667572f1c414cc77a68130d34982ee8c4" translate="yes" xml:space="preserve">
          <source>Each standard stream is only available if you specify that a pipe should be created for it. For example, if you pass &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt;, you can write to the &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream, else &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">각 표준 스트림은 파이프를 작성하도록 지정한 경우에만 사용 가능합니다. 예를 들어 통과하면 &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt; 하면 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 스트림에 쓸 수 있으며 , 그렇지 않으면 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1a68ba745dd4b45565cc59ceb8fbfb0631b79b4" translate="yes" xml:space="preserve">
          <source>Encrypt some data and then send it on the underlying transport.</source>
          <target state="translated">일부 데이터를 암호화 한 다음 기본 전송으로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4c62f9905e08096736c80be6b7ec40116ed5ed" translate="yes" xml:space="preserve">
          <source>Encrypted communication using SSL/TLS.</source>
          <target state="translated">SSL / TLS를 사용한 암호화 된 통신</target>
        </trans-unit>
        <trans-unit id="86de1bfa52c3e4766f699ef16765dbd03a3319f9" translate="yes" xml:space="preserve">
          <source>Enforcement Examples</source>
          <target state="translated">시행 예</target>
        </trans-unit>
        <trans-unit id="30ad3a9a2afb2111b7765c691e99a5da39f50d0f" translate="yes" xml:space="preserve">
          <source>Ensure that the initial handshake has completed.</source>
          <target state="translated">초기 핸드 셰이크가 완료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f2da480b2f64c9d3565292a14c9f547cfaf97f33" translate="yes" xml:space="preserve">
          <source>Entering Trio</source>
          <target state="translated">트리오 입력</target>
        </trans-unit>
        <trans-unit id="9abc3cbe1eb3dbb9c76b4daff2806c46dd7c2398" translate="yes" xml:space="preserve">
          <source>Entering the context manager is synchronous (not a checkpoint); exiting it calls &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. The default implementations of &lt;code&gt;__aenter__&lt;/code&gt; and &lt;code&gt;__aexit__&lt;/code&gt; should be adequate for all subclasses.</source>
          <target state="translated">컨텍스트 관리자 입력은 체크 포인트가 아닌 동기식입니다. 종료하면 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 호출 됩니다. 기본 구현 &lt;code&gt;__aenter__&lt;/code&gt; 및 &lt;code&gt;__aexit__&lt;/code&gt; 모든 하위 클래스에 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd77c7c89aaac60eda264bbe76c2fb3877f1bec7" translate="yes" xml:space="preserve">
          <source>Entering this context manager starts listening for the given signals and returns an async iterator; exiting the context manager stops listening.</source>
          <target state="translated">이 컨텍스트 관리자에 들어가면 주어진 신호를 수신하기 시작하고 비동기 반복기를 반환합니다. 컨텍스트 관리자를 종료하면 청취가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="577a6f5217758f5680c1ac4ab28d646c851b6515" translate="yes" xml:space="preserve">
          <source>Equivalent to (but potentially more efficient than):</source>
          <target state="translated">다음과 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ff71f1502a09a0efc6bf6b8df7b2130d8639c933" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;await trio.sleep(0)&lt;/code&gt; (which is implemented by calling &lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt;&lt;code&gt;checkpoint()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">상당 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; 호출에 의해 구현된다 (&lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt; &lt;code&gt;checkpoint()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f382ebfc0131e10b8880c5dcb889ae9616bf535a" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;await sleep(math.inf)&lt;/code&gt;.</source>
          <target state="translated">부름에 해당 &lt;code&gt;await sleep(math.inf)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f06260807eabf1e2cdab615aead6b6fb18bc907c" translate="yes" xml:space="preserve">
          <source>Error handling:</source>
          <target state="translated">오류 처리:</target>
        </trans-unit>
        <trans-unit id="5ee23a39f0b9c090f3744086941471cc71f4df96" translate="yes" xml:space="preserve">
          <source>Errors in multiple child tasks</source>
          <target state="translated">여러 하위 작업의 오류</target>
        </trans-unit>
        <trans-unit id="e0ace80de082dc37e3d719147a18d3df854a1b73" translate="yes" xml:space="preserve">
          <source>Essentially, the body of the &lt;code&gt;async with&lt;/code&gt; block acts like an initial task that&amp;rsquo;s running inside the nursery, and then each call to &lt;code&gt;nursery.start_soon&lt;/code&gt; adds another task that runs in parallel. Two crucial things to keep in mind:</source>
          <target state="translated">본질적으로, 본체 &lt;code&gt;async with&lt;/code&gt; 블록은 초기 보육 내부에서 실행중인 작업 및 호출 할 때마다 같은 역할을 &lt;code&gt;nursery.start_soon&lt;/code&gt; 대한 은 병렬로 실행되는 다른 작업을 추가합니다. 명심해야 할 두 가지 중요한 사항 :</target>
        </trans-unit>
        <trans-unit id="94511c8fe5d02860cbae8a93867794aff11407ac" translate="yes" xml:space="preserve">
          <source>Every call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; has an associated clock.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출 에는 관련 시계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da5df3c0217f2dd602bff18b094f6738fa41e40" translate="yes" xml:space="preserve">
          <source>Every successful execution path passes through a checkpoint (assuming that &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; is an unconditional checkpoint)</source>
          <target state="translated">모든 성공적인 실행 경로는 검사 점을 통과합니다 ( &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 가 무조건 검사 점 이라고 가정 )</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="950f4fc18cdc90c9c93a02882a39bdff0c115ba2" translate="yes" xml:space="preserve">
          <source>Example implementations</source>
          <target state="translated">구현 예</target>
        </trans-unit>
        <trans-unit id="65cee81e771dd281fa49a0152c7e600fa8e0a7ec" translate="yes" xml:space="preserve">
          <source>Example output (yours may differ slightly):</source>
          <target state="translated">출력 예 (약간 다를 수 있음) :</target>
        </trans-unit>
        <trans-unit id="9684bdcdfe4872be868a6df199c0d4c63ad6a6b9" translate="yes" xml:space="preserve">
          <source>Example use case: drawing a visualization of the task tree in a debugger.</source>
          <target state="translated">사용 사례 예 : 디버거에서 작업 트리의 시각화를 그립니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="ccf1573108e16e6d38ba26ddc8eacf022ebd30f9" translate="yes" xml:space="preserve">
          <source>Exceptions and warnings</source>
          <target state="translated">예외 및 경고</target>
        </trans-unit>
        <trans-unit id="a5ef272f6a2530c8104c0aa1dff5bd1ca42d05ac" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process.</source>
          <target state="translated">새 프로세스에서 하위 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="36ebc08b0a99d629a11b0e8b00f5c5994c6741e9" translate="yes" xml:space="preserve">
          <source>First we do all our interaction with the state machine in a single scheduling quantum (notice there are no &lt;code&gt;await&lt;/code&gt;s in there), so it&amp;rsquo;s automatically atomic with respect to other tasks. And then if and only if we have data to send, we get in line to send it &amp;ndash; and &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; guarantees that each task will send its data in the same order that the state machine generated it.</source>
          <target state="translated">먼저 단일 스케줄링 퀀텀에서 상태 머신과의 모든 상호 작용을 수행하므로 &lt;code&gt;await&lt;/code&gt; 이 없습니다 . 다른 작업과 관련하여 자동으로 원자 적입니다. 그리고 전송할 데이터가있는 경우에만 전송할 수 있습니다 &amp;ndash; 그리고 &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt; 은 각 작업이 상태 머신이 생성 한 순서와 동일한 순서로 데이터를 전송하도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="39aad0e951ec2a465a7527afcee9229d642c5338" translate="yes" xml:space="preserve">
          <source>First, Trio provides analogues to all the standard library functions that return socket objects; their interface is identical, except that they&amp;rsquo;re modified to return Trio socket objects instead:</source>
          <target state="translated">첫째, Trio는 소켓 객체를 반환하는 모든 표준 라이브러리 함수에 대한 아날로그를 제공합니다. 인터페이스는 동일하지만 대신 Trio 소켓 객체를 반환하도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="87b15f31f9acbf1b346b9723758dae62bdd83b37" translate="yes" xml:space="preserve">
          <source>First, and most obviously, everything is made &amp;ldquo;Trio-style&amp;rdquo;: blocking methods become async methods, and the following attributes are &lt;em&gt;not&lt;/em&gt; supported:</source>
          <target state="translated">먼저 가장 확실한 것은 모든 것이&amp;ldquo;트리오 스타일&amp;rdquo;입니다. 차단 방법은 비동기 방법이되며 다음 속성은 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0602bcf5eefcc21823064ff06ea71c922833a9" translate="yes" xml:space="preserve">
          <source>First, right now no mainstream operating system offers a generic, reliable, native API for async file or filesystem operations, so we have to fake it by using threads (specifically, &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;). This is cheap but isn&amp;rsquo;t free: on a typical PC, dispatching to a worker thread adds something like ~100 &amp;micro;s of overhead to each operation. (&amp;ldquo;&amp;micro;s&amp;rdquo; is pronounced &amp;ldquo;microseconds&amp;rdquo;, and there are 1,000,000 &amp;micro;s in a second. Note that all the numbers here are going to be rough orders of magnitude to give you a sense of scale; if you need precise numbers for your environment, measure!)</source>
          <target state="translated">첫째, 현재 어떤 주류 운영 체제도 비동기 파일 또는 파일 시스템 작업을위한 일반적이고 안정적인 기본 API를 제공하지 않으므로 스레드 (특히 &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 사용하여 위조해야합니다. ) 합니다. 이것은 저렴하지만 무료는 아닙니다. 일반적인 PC에서 작업자 스레드로 디스패치하면 각 작업에 ~ 100&amp;micro;s의 오버 헤드가 추가됩니다. ( &quot;&amp;micro;s&quot;는 &quot;마이크로 초&quot;로 표시되며 1 초에 1,000,000&amp;micro;s가 있습니다. 여기에있는 모든 숫자는 대략적인 규모로되어있어 규모를 파악할 수 있습니다. 환경에 정확한 숫자가 필요한 경우, 법안!)</target>
        </trans-unit>
        <trans-unit id="a05d658dc1c542b05e5284639df77ae27e0c00f0" translate="yes" xml:space="preserve">
          <source>For a clock using wall-time, this should be something like:</source>
          <target state="translated">벽시계를 사용하는 시계의 경우 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="48709ea5cba4eb96bb491cf99f5fd3676afdc21d" translate="yes" xml:space="preserve">
          <source>For example, closing a TLS-wrapped socket normally involves sending a notification to the remote peer, so that they can be cryptographically assured that you really meant to close the socket, and your connection wasn&amp;rsquo;t just broken by a man-in-the-middle attacker. But handling this robustly is a bit tricky. Remember our &lt;a href=&quot;#blocking-cleanup-example&quot;&gt;example&lt;/a&gt; above where the blocking &lt;code&gt;send_goodbye_msg&lt;/code&gt; caused problems? That&amp;rsquo;s exactly how closing a TLS socket works: if the remote peer has disappeared, then our code may never be able to actually send our shutdown notification, and it would be nice if it didn&amp;rsquo;t block forever trying. Therefore, the method for closing a TLS-wrapped socket will &lt;em&gt;try&lt;/em&gt; to send that notification &amp;ndash; and if it gets cancelled, then it will give up on sending the message, but &lt;em&gt;will&lt;/em&gt; still close the underlying socket before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, so at least you don&amp;rsquo;t leak that resource.</source>
          <target state="translated">예를 들어, TLS로 감싼 소켓을 닫는 것은 일반적으로 원격 피어에 알림을 보내는 것을 포함하므로 실제로 소켓을 닫으려는 의도가 있음을 암호로 보장 할 수 있으며 연결은 사람에 의해 끊어지지 않았습니다. 중간 공격자. 그러나 이것을 강력하게 처리하는 것은 약간 까다 롭습니다. &lt;code&gt;send_goodbye_msg&lt;/code&gt; 차단 문제가 발생한 위 의 &lt;a href=&quot;#blocking-cleanup-example&quot;&gt;예를&lt;/a&gt; 기억 하십니까? 원격 피어가 사라지면 코드가 실제로 종료 알림을 보낼 수 없으며 영원히 시도하지 못하게하면 좋을 것입니다. 따라서 TLS로 감싼 소켓을 닫는 방법은 해당 알림을 보내며, 취소되면 메시지 전송을 포기하지만&lt;em&gt; 시도&lt;/em&gt;&lt;em&gt;것입니다&lt;/em&gt; 여전히 가까운 올리기 기본 소켓 전에 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , 그래서 적어도 당신은 자원을 누설하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f008f9eefbcebe7ebf5b1aab36adf73fbe45fd" translate="yes" xml:space="preserve">
          <source>For example, consider this naive extension of our previous example, now with two producers and two consumers:</source>
          <target state="translated">예를 들어, 앞의 예제에서이 순진한 확장을 생각해 보자. 이제 두 명의 생산자와 두 명의 소비자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9f550fd71ac17462b4162b1e8a8748f24bd870" translate="yes" xml:space="preserve">
          <source>For example, here&amp;rsquo;s a function that takes a list of functions, runs them all concurrently, and returns the result from the one that finishes first:</source>
          <target state="translated">예를 들어, 다음은 함수 목록을 가져 와서 동시에 실행하며 먼저 완료되는 결과를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3e1b83209368f33cb57342986c90a06fb5c4a5ce" translate="yes" xml:space="preserve">
          <source>For example, if two tasks try to send data through the same socket at the same time, Trio will raise &lt;a href=&quot;#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt; instead of letting the data get scrambled.</source>
          <target state="translated">예를 들어, 두 작업이 동시에 같은 소켓을 통해 데이터를 보내려고 하면 데이터가 스크램블되는 대신 Trio는 &lt;a href=&quot;#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9203322c4e642fda52a346d7a4dd7f31f89ac48" translate="yes" xml:space="preserve">
          <source>For example, suppose we call &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on a TLS-encrypted connection. This requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if the peer has become non-responsive, then our attempt to send this message might block forever, and eventually time out and be cancelled. In this case the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will immediately close the underlying transport stream using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt; before raising &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; TLS 암호화 연결에서 를 합니다. 이를 위해서는 &quot;안녕&quot;메시지를 보내야합니다. 그러나 피어가 응답하지 않으면이 메시지를 보내려는 시도가 영원히 차단되어 결국 시간이 초과되어 취소 될 수 있습니다. 이 경우 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에있어서 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 은&lt;/a&gt; 바로 가까이 기본 전송 스트림을 사용한다 &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 올리기 전에 서버 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b30a4a3439bea3af8a737486ca4c36858c90d06" translate="yes" xml:space="preserve">
          <source>For example, you might get this if you try to send data on a stream where the remote side has already closed the connection.</source>
          <target state="translated">예를 들어, 원격 측이 이미 연결을 닫은 스트림에서 데이터를 보내려고하면이 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f909978159a531021ff533705ba1c50305ee5043" translate="yes" xml:space="preserve">
          <source>For more information, read the &lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3cbd4cf4a20b121cf25b4d8a86f46de892ed87cc" translate="yes" xml:space="preserve">
          <source>For name lookup, Trio provides the standard functions, but with some changes:</source>
          <target state="translated">이름 조회를 위해 Trio는 표준 기능을 제공하지만 몇 가지 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd4c0d3d9c603b00054846d54595ca9a7a4e9da3" translate="yes" xml:space="preserve">
          <source>For operations that have a non-blocking variant, the blocking and non-blocking variants are different methods with names like &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;X_nowait&lt;/code&gt;, respectively. (This is similar to &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt;, but unlike most of the classes in &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;.) We like this approach because it allows us to make the blocking version async and the non-blocking version sync.</source>
          <target state="translated">비 차단 변형이있는 작업의 경우 차단 및 비 차단 변형은 &lt;code&gt;X&lt;/code&gt; 와 같은 이름을 가진 다른 방법입니다. 각각 및 &lt;code&gt;X_nowait&lt;/code&gt; 와 . (이것은 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 대부분의 클래스와는 다릅니다 .) 우리는 차단 버전을 비 동기화하고 비 차단 버전을 동기화시킬 수 있기 때문에이 접근법을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="af7c11a85341c774f7f483b666e5435a2c7dc4ac" translate="yes" xml:space="preserve">
          <source>For reading and writing to files and file-like objects, Trio also provides a mechanism for wrapping any synchronous file-like object into an asynchronous interface. If you have a &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt; object you can get one of these by calling its &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; method; or if you know the file&amp;rsquo;s name you can open it directly with &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt;. Alternatively, if you already have an open file-like object, you can wrap it with &lt;a href=&quot;#trio.wrap_file&quot;&gt;&lt;code&gt;trio.wrap_file()&lt;/code&gt;&lt;/a&gt; &amp;ndash; one case where this is especially useful is to wrap &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; when writing tests.</source>
          <target state="translated">파일 및 파일과 유사한 객체를 읽고 쓸 수 있도록 Trio는 동기식 파일과 유사한 객체를 비동기 인터페이스로 래핑하는 메커니즘도 제공합니다. &lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; &lt;/a&gt; 객체 가 있다면 &lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여이 중 하나를 얻을 수 있습니다 . 또는 파일 이름을 알고 있으면 &lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt; 직접 열 수 있습니다 . 또는 열려있는 파일과 유사한 객체가 이미있는 경우&lt;a href=&quot;#trio.wrap_file&quot;&gt; &lt;code&gt;trio.wrap_file()&lt;/code&gt; &lt;/a&gt;특히 유용한경우 테스트 작성시&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 를 래핑하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="82ef028042140eef57f0f36ca8b9b254552de55e" translate="yes" xml:space="preserve">
          <source>Fortunately this isn&amp;rsquo;t as bad as it sounds, because the HTTP protocol already includes its own equivalent of &lt;code&gt;close_notify&lt;/code&gt;, so doing this again at the SSL/TLS level is redundant. But not all protocols do! Therefore, by default Trio implements the safer standard-compliant version (&lt;code&gt;https_compatible=False&lt;/code&gt;). But if you&amp;rsquo;re speaking HTTPS or some other protocol where &lt;code&gt;close_notify&lt;/code&gt;s are commonly skipped, then you should set &lt;code&gt;https_compatible=True&lt;/code&gt;; with this setting, Trio will neither expect nor send &lt;code&gt;close_notify&lt;/code&gt; messages.</source>
          <target state="translated">다행스럽게도 HTTP 프로토콜에는 이미 &lt;code&gt;close_notify&lt;/code&gt; 와 동등한 자체가 포함되어 있기 때문에 SSL / TLS 수준에서 다시 수행하는 것이 중복 되기 때문에 이것은 나쁘지 않습니다 . 그러나 모든 프로토콜이 아닙니다! 따라서 기본적으로 Trio는보다 안전한 표준 호환 버전을 구현합니다 ( &lt;code&gt;https_compatible=False&lt;/code&gt; )을 . 그러나 HTTPS 또는 &lt;code&gt;close_notify&lt;/code&gt; 가 일반적으로 건너 뛰는 다른 프로토콜을 말하는 경우 &lt;code&gt;https_compatible=True&lt;/code&gt; 를 설정해야합니다 . 이 설정을 사용하면 Trio는 &lt;code&gt;close_notify&lt;/code&gt; 메시지를 기대하거나 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d15dc5d1075d65dae25982087c3ad3acc292130c" translate="yes" xml:space="preserve">
          <source>From inside the worker thread, you can get back into Trio using the functions in &lt;a href=&quot;#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자 스레드 내부에서 &lt;a href=&quot;#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; &lt;/a&gt; 의 함수를 사용하여 Trio로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">더 읽을 거리 :</target>
        </trans-unit>
        <trans-unit id="14b4abcfb38d8e2bedf23453f682373a91ca1df3" translate="yes" xml:space="preserve">
          <source>General principles</source>
          <target state="translated">일반 원칙</target>
        </trans-unit>
        <trans-unit id="1d33591f44b73461a418fdd7300d5ea81ebd01a0" translate="yes" xml:space="preserve">
          <source>Generally the way it works is that before calling this function, you make arrangements for &amp;ldquo;someone&amp;rdquo; to call &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task at some later point.</source>
          <target state="translated">일반적으로 작동하는 방식은이 함수를 호출하기 전에 &quot;누군가&quot;가 전화를 걸도록 조정하는 것입니다. &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;나중에 현재 작업에서 reschedule () 조정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e36516ef81e825f5f1a9afc1d80d86f1816a2bbe" translate="yes" xml:space="preserve">
          <source>Generally you should call this function just once, right at the beginning of your program.</source>
          <target state="translated">일반적으로 프로그램 시작시이 함수를 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dbd080c65cdd758570339c25de579b2dd1b8134" translate="yes" xml:space="preserve">
          <source>Generally, the API exposed by &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; mirrors that of the standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module. Most constants (like &lt;code&gt;SOL_SOCKET&lt;/code&gt;) and simple utilities (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt;&lt;code&gt;inet_aton()&lt;/code&gt;&lt;/a&gt;) are simply re-exported unchanged. But there are also some differences, which are described here.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 에 의해 노출 된 API 는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 의 API를 미러링합니다 . 대부분의 상수 (예 : &lt;code&gt;SOL_SOCKET&lt;/code&gt; ) 및 간단한 유틸리티 (예 :&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt; &lt;code&gt;inet_aton()&lt;/code&gt; &lt;/a&gt; )는 그대로 그대로 다시 내보내집니다. 그러나 여기에 설명 된 차이점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df6e0ad77a1d03e22e4e78c091cdce9b18814852" translate="yes" xml:space="preserve">
          <source>Generic stream tools</source>
          <target state="translated">일반 스트림 도구</target>
        </trans-unit>
        <trans-unit id="c61ec329c35890384eca7f8141d511f90a23bba7" translate="yes" xml:space="preserve">
          <source>Get the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용되는 기본 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를 가져&lt;/a&gt; 옵니다.&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; 가 가져옵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="424f1939c9512c36dd942c09a91b79a3e7cd2f59" translate="yes" xml:space="preserve">
          <source>Getting back into the Trio thread from another thread</source>
          <target state="translated">다른 스레드에서 Trio 스레드로 돌아 가기</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="f1f01defeb8ad40ed473adada63fd85ed9fd2cce" translate="yes" xml:space="preserve">
          <source>Global state: system tasks and run-local variables</source>
          <target state="translated">글로벌 상태 : 시스템 작업 및 로컬 실행 변수</target>
        </trans-unit>
        <trans-unit id="3d2cbcea420fd9b8c76106a48d0b289d21c579de" translate="yes" xml:space="preserve">
          <source>Global statistics</source>
          <target state="translated">글로벌 통계</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="d134414d4290b4888745f30ed9ef9d0af9f97f62" translate="yes" xml:space="preserve">
          <source>Gracefully shut down this connection, and close the underlying transport.</source>
          <target state="translated">이 연결을 정상적으로 종료하고 기본 전송을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="51de6467e4ce05659d97203c6f4fe5fb2686e910" translate="yes" xml:space="preserve">
          <source>Handing off live coroutine objects between coroutine runners</source>
          <target state="translated">코 루틴 러너 사이에 라이브 코 루틴 객체를 전달</target>
        </trans-unit>
        <trans-unit id="f88d04389b281b3967803afb4eaa851b991783bb" translate="yes" xml:space="preserve">
          <source>Handling cancellation</source>
          <target state="translated">취소 처리</target>
        </trans-unit>
        <trans-unit id="cbf0820fc59d334aedf8e7fb6d8f0d097b139af9" translate="yes" xml:space="preserve">
          <source>Here if one or more of the racing functions raises an unhandled exception then Trio&amp;rsquo;s normal handling kicks in: it cancels the others and then propagates the exception. If you want different behavior, you can get that by adding a &lt;code&gt;try&lt;/code&gt; block to the &lt;code&gt;jockey&lt;/code&gt; function to catch exceptions and handle them however you like.</source>
          <target state="translated">여기서 하나 이상의 레이싱 함수가 처리되지 않은 예외를 발생 시키면 Trio의 일반 처리가 시작됩니다. 다른 동작을 원한다면 &lt;code&gt;jockey&lt;/code&gt; 함수에 &lt;code&gt;try&lt;/code&gt; 블록을 추가하여 예외를 포착하고 원하는대로 처리하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81e9adeb9b0a32b3517c84f273b1dbbc540cd6e" translate="yes" xml:space="preserve">
          <source>Here the function acts as a checkpoint if you call it with &lt;code&gt;should_sleep&lt;/code&gt; set to a true value, but not otherwise. This is why we emphasize that Trio&amp;rsquo;s own async functions are &lt;em&gt;unconditional&lt;/em&gt; checkpoints: they &lt;em&gt;always&lt;/em&gt; check for cancellation and check for scheduling, regardless of what arguments they&amp;rsquo;re passed. If you find an async function in Trio that doesn&amp;rsquo;t follow this rule, then it&amp;rsquo;s a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">여기서 함수는 &lt;code&gt;should_sleep&lt;/code&gt; 을 true 값으로 설정하고 호출 하지 않으면 검사 점 역할을합니다 . 이것이 Trio의 자체 비동기 함수가 &lt;em&gt;무조건&lt;/em&gt; 체크 포인트 임을 강조하는 이유 입니다. 전달 된 인수에 관계없이 &lt;em&gt;항상&lt;/em&gt; 취소를 확인하고 스케줄링을 확인합니다. Trio에서이 규칙을 따르지 않는 비동기 함수를 찾으면 버그이며 &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e1243ad2370c1dcec5bc84d902878d0e26a4267" translate="yes" xml:space="preserve">
          <source>Here we pass clones into the tasks, but never close the original objects. That means we have 3 send channel objects (the original + two clones), but we only close 2 of them, so the consumers will hang around forever waiting for that last one to be closed.</source>
          <target state="translated">여기서 복제본을 작업에 전달하지만 원래 객체를 닫지 마십시오. 즉, 3 개의 송신 채널 객체 (원본 + 2 개의 복제본)가 있지만 그 중 2 개만 닫으므로 소비자는 마지막 객체가 닫힐 때까지 영원히 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="5b795a1957f433bb2a1910c85c849c3c303650bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a new version that fixes this: it produces the same output as the previous version, and then exits cleanly. The only change is the addition of &lt;code&gt;async with&lt;/code&gt; blocks inside the producer and consumer:</source>
          <target state="translated">다음은이 문제를 해결하는 새 버전입니다. 이전 버전과 동일한 출력을 생성 한 다음 완전히 종료됩니다. 유일한 변경 사항은 생산자와 소비자 내부의 블록 과 &lt;code&gt;async with&lt;/code&gt; 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d543e0e7e6827ddd190eadb52f0c6857ef3a5feb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a rule of thumb for designing good Trio-style (&amp;ldquo;trionic&amp;rdquo;?) APIs: if you&amp;rsquo;re writing a reusable function, then you shouldn&amp;rsquo;t take a &lt;code&gt;timeout=&lt;/code&gt; parameter, and instead let your caller worry about it. This has several advantages. First, it leaves the caller&amp;rsquo;s options open for deciding how they prefer to handle timeouts &amp;ndash; for example, they might find it easier to work with absolute deadlines instead of relative timeouts. If they&amp;rsquo;re the ones calling into the cancellation machinery, then they get to pick, and you don&amp;rsquo;t have to worry about it. Second, and more importantly, this makes it easier for others to re-use your code. If you write a &lt;code&gt;http_get&lt;/code&gt; function, and then I come along later and write a &lt;code&gt;log_in_to_twitter&lt;/code&gt; function that needs to internally make several &lt;code&gt;http_get&lt;/code&gt; calls, I don&amp;rsquo;t want to have to figure out how to configure the individual timeouts on each of those calls &amp;ndash; and with Trio&amp;rsquo;s timeout system, it&amp;rsquo;s totally unnecessary.</source>
          <target state="translated">재사용 가능한 함수를 작성하는 경우 &lt;code&gt;timeout=&lt;/code&gt; 매개 변수를 사용하지 말고 호출자에게 걱정하지 말아야합니다. 이것은 몇 가지 장점이 있습니다. 첫째, 시간 초과 처리 방법을 결정하기 위해 발신자의 옵션을 열어 둡니다. 예를 들어 상대 시간 초과가 아닌 절대 기한을 사용하는 것이 더 쉬울 수 있습니다. 그들이 취소 기계를 호출하는 사람들이라면, 그들은 선택하게되며, 당신은 그것에 대해 걱정할 필요가 없습니다. 둘째, 더 중요한 것은 다른 사람들이 코드를 쉽게 재사용 할 수있게 해줍니다. &lt;code&gt;http_get&lt;/code&gt; 함수 를 작성한 다음 나중에 와서 내부적으로 여러 개를 만들어야 하는 &lt;code&gt;log_in_to_twitter&lt;/code&gt; 함수를 작성하면 &lt;code&gt;http_get&lt;/code&gt; 을 각 호출에 대해 개별 시간 초과를 구성하는 방법을 알아 내고 싶지 않습니다. Trio의 시간 초과 시스템을 사용하는 것은 완전히 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="601515a8d1630148f164b880c80a648ba993177c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of how to use memory channels:</source>
          <target state="translated">메모리 채널을 사용하는 방법에 대한 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f8dd0477dbd6951adf860111366384234489b4a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a toy example demonstrating how to use &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 사용 방법을 보여주는 장난감 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="0f597430db412dbd7530fb06efa92bf6cd1e97b4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example lock class implemented using &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt;, which handles some of these issues for you. But this does serve to illustrate the basic structure of the &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">다음은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 직접 사용하여 구현 된 잠금 클래스의 예 입니다. 이 구현에는 공정성 부족, O (n) 취소, 오류 검사 누락, 비 차단 경로에 체크 포인트 삽입 실패 등 여러 가지 결함이 있습니다. 실제로 자신의 잠금을 구현하려면 다음을 수행해야합니다. 의 구현 연구 &lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt; 사용 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 당신을 위해 이러한 문제의 일부를 처리합니다. 그러나 이것은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; API 의 기본 구조를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c83ac7bfeff92f8dfada15c124f96bd3c69d8174" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of one way to test that Trio&amp;rsquo;s locks are fair: we take the lock in the parent, start a child, wait for the child to be blocked waiting for the lock (!), and then check that we can&amp;rsquo;t release and immediately re-acquire the lock:</source>
          <target state="translated">다음은 Trio의 잠금이 공정한지 테스트하는 한 가지 방법의 예입니다. 부모의 잠금을 잡고, 자식을 시작하고, 자식이 잠금을 기다리는 동안 차단 될 때까지 기다렸다가 (!) 풀어 놓을 수 없는지 확인하십시오 즉시 잠금 장치를 다시 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c595ce4e33c82227dd77fbbfecca01edd89f970" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the idea: whenever you call a cancellable function like &lt;code&gt;await
trio.sleep(...)&lt;/code&gt; or &lt;code&gt;await sock.recv(...)&lt;/code&gt; &amp;ndash; see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; &amp;ndash; then the first thing that function does is to check if there&amp;rsquo;s a surrounding cancel scope whose timeout has expired, or otherwise been cancelled. If so, then instead of performing the requested operation, the function fails immediately with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. In this example, this probably happens somewhere deep inside the bowels of &lt;code&gt;do_http_get&lt;/code&gt;. The exception then propagates out like any normal exception (you could even catch it if you wanted, but that&amp;rsquo;s generally a bad idea), until it reaches the &lt;code&gt;with move_on_after(...):&lt;/code&gt;. And at this point, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception has done its job &amp;ndash; it&amp;rsquo;s successfully unwound the whole cancelled scope &amp;ndash; so &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; catches it, and execution continues as normal after the &lt;code&gt;with&lt;/code&gt; block. And this all works correctly even if you have nested cancel scopes, because every &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; object carries an invisible marker that makes sure that the cancel scope that triggered it is the only one that will catch it.</source>
          <target state="translated">아이디어는 다음과 같습니다. &lt;code&gt;await trio.sleep(...)&lt;/code&gt; 또는 &lt;code&gt;await sock.recv(...)&lt;/code&gt; 와 같은 취소 가능한 함수를 호출 할 때마다 &lt;a href=&quot;#checkpoints&quot;&gt;검사 점&lt;/a&gt; 참조 &amp;ndash; 함수가 수행하는 첫 번째 작업은 주변 취소 범위가 있는지 확인하는 것입니다. 제한 시간이 만료되었거나 취소 된 경우 그렇다면 요청 된 작업을 수행하는 대신 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 와 함께 함수가 즉시 실패합니다 . 이 예에서, 이것은 아마도 &lt;code&gt;do_http_get&lt;/code&gt; 창자 안쪽 어딘가에서 발생합니다 . 그런 다음 예외는 일반적인 예외와 같이 전파됩니다 (원하는 경우 잡을 수도 있지만 일반적으로 나쁜 생각입니다). &lt;code&gt;with move_on_after(...):&lt;/code&gt; . 그리고이 시점에서&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 작업을 완료했습니다. 전체 취소 된 범위를 성공적으로&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 따라서 move_on_after ()가이를 감지 하고 &lt;code&gt;with&lt;/code&gt; 블록이후에도 정상적으로 실행이 계속됩니다. 취소 된 범위가 중첩 된 경우에도이 모든 것이 올바르게 작동합니다. 모든&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 객체에는 보이지 않는 마커가있어이를 트리거 한 취소 범위가이를 포착 할 수있는 유일한 범위이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2aeb6b45dd0d2ee97bc472ed237a9f484260072d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the rule: if it&amp;rsquo;s in the &lt;code&gt;trio&lt;/code&gt; namespace, and you use &lt;code&gt;await&lt;/code&gt; to call it, then it&amp;rsquo;s cancellable (see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; above). Cancellable means:</source>
          <target state="translated">규칙은 다음과 같습니다. &lt;code&gt;trio&lt;/code&gt; 네임 스페이스에 있고 &lt;code&gt;await&lt;/code&gt; 를 사용 하여 호출하면 취소 할 수 있습니다 ( 위의 &lt;a href=&quot;#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 참조). 취소 가능한 수단 :</target>
        </trans-unit>
        <trans-unit id="777ee510025095ed8e8d6f657cb98b0a5e34e261" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what&amp;rsquo;s happening: suppose that producer A finishes first. It exits, and its &lt;code&gt;async with&lt;/code&gt; block closes the &lt;code&gt;send_channel&lt;/code&gt;. But wait! Producer B was still using that &lt;code&gt;send_channel&lt;/code&gt;&amp;hellip; so the next time B calls &lt;code&gt;send&lt;/code&gt;, it gets a &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">진행 상황은 다음과 같습니다. 생산자 A가 먼저 완료한다고 가정합니다. 종료 &lt;code&gt;async with&lt;/code&gt; 블록 과의 비동기 는 &lt;code&gt;send_channel&lt;/code&gt; 을 닫습니다 . 하지만 기다려! 생산자 B 아직도 사용하고 있었다 &lt;code&gt;send_channel&lt;/code&gt; 을 B 호출이 다음 번 ... 그래서 &lt;code&gt;send&lt;/code&gt; , 그것은 도착 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21160ad4219648df73489cb933286e7bc3e46257" translate="yes" xml:space="preserve">
          <source>High-level design principles</source>
          <target state="translated">높은 수준의 설계 원칙</target>
        </trans-unit>
        <trans-unit id="69ab5602e01ae3ddb7b5d822e4e060677004c139" translate="yes" xml:space="preserve">
          <source>How does this work? There&amp;rsquo;s no magic here: Trio is built using ordinary Python functionality, so we can&amp;rsquo;t just abandon the code inside the &lt;code&gt;with&lt;/code&gt; block. Instead, we take advantage of Python&amp;rsquo;s standard way of aborting a large and complex piece of code: we raise an exception.</source>
          <target state="translated">어떻게 작동합니까? 여기에는 마술이 없습니다. Trio는 일반적인 Python 기능을 사용하여 빌드되므로 &lt;code&gt;with&lt;/code&gt; 블록 내부의 코드를 버릴 수 없습니다 . 대신, 크고 복잡한 코드를 중단시키는 Python의 표준 방법을 활용합니다. 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5e1b1c64688e250f0fe5f3bee97484ef0ed62473" translate="yes" xml:space="preserve">
          <source>How many seconds of clock time pass per second of real time. Default is 0.0, i.e. the clock only advances through manuals calls to &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt; or when the &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; is triggered. You can assign to this attribute to change it.</source>
          <target state="translated">초당 실시간 클럭 시간 (초)입니다. 기본값은 0.0입니다. 즉, 시계는 &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt; 대한 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 호출을 통해서만 또는 autojump_threshold 가 트리거 될 때만 진행됩니다 . 이 속성에 할당하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33d8a0f4d3b4758420f6c0a759a3cf2ef4fe9541" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and receivers don&amp;rsquo;t get &lt;a href=&quot;#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt; until &lt;em&gt;all&lt;/em&gt; clones have been closed.</source>
          <target state="translated">그러나 개체 중 하나를 닫아도 다른 개체는 닫히지 않으며 수신기는 &lt;em&gt;모든&lt;/em&gt; 복제본이 &lt;a href=&quot;#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; &lt;/a&gt; 때까지 EndOfChannel을 얻지 못합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f56ebfbbd55d6021396bb3e5231e9f349c9e50c" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and the underlying channel is not closed until all clones are closed. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">그러나 개체 중 하나를 닫아도 다른 개체는 닫히지 않으며 모든 클론이 닫힐 때까지 기본 채널이 닫히지 않습니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; 에&lt;/a&gt; 익숙하다면 비슷한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="b8a37d3b1ef08026c956e9210fe57a016a1abeb9" translate="yes" xml:space="preserve">
          <source>However, on most runs, that&amp;rsquo;s not what happens &amp;ndash; the first part of the output is OK, and then when we get to the end the program crashes with &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;. If you run the program a few times, you&amp;rsquo;ll see that sometimes the traceback shows &lt;code&gt;send&lt;/code&gt; crashing, and other times it shows &lt;code&gt;receive&lt;/code&gt; crashing, and you might even find that on some runs it doesn&amp;rsquo;t crash at all.</source>
          <target state="translated">그러나 대부분의 실행에서 이는 발생하지 않습니다. 출력의 첫 번째 부분은 정상입니다. 그런 다음 마지막에 도달하면 프로그램은 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; 와 충돌 합니다. 프로그램을 몇 번 실행하면 때때로 트레이스 백 쇼 &lt;code&gt;send&lt;/code&gt; 충돌을 일으키고 다른 시간에 쇼 &lt;code&gt;receive&lt;/code&gt; 충돌하는 것을 볼 수 있으며 일부 실행에서는 전혀 충돌하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2312758fa0e741bf556c7094e1d6c332983a60b2" translate="yes" xml:space="preserve">
          <source>However, this part of the standard is widely ignored by real-world HTTPS implementations, which means that if you want to interoperate with them, then you NEED to ignore it too.</source>
          <target state="translated">그러나 표준의이 부분은 실제 HTTPS 구현에 의해 널리 무시됩니다. 즉, 상호 운용하려는 경우이를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="19b03b1b6c37147d5d29f006e500a4ed4c113fb9" translate="yes" xml:space="preserve">
          <source>I get:</source>
          <target state="translated">나는 얻다:</target>
        </trans-unit>
        <trans-unit id="42b70820829e53baf48333e3880927dee7edb161" translate="yes" xml:space="preserve">
          <source>I/O in Trio</source>
          <target state="translated">트리오의 I / O</target>
        </trans-unit>
        <trans-unit id="47c6b8c8f8e1a0dd24d9a8ac6524551b9a4890aa" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This method may block in order to perform a &amp;ldquo;graceful&amp;rdquo; shutdown. But, if this fails, then it still &lt;em&gt;must&lt;/em&gt; close any underlying resources before returning. An error from this method indicates a failure to achieve grace, &lt;em&gt;not&lt;/em&gt; a failure to close the connection.</source>
          <target state="translated">중요 :이 방법은 &quot;정상적인&quot;종료를 수행하기 위해 차단 될 수 있습니다. 그러나,이 실패 할 경우, 그것은 여전히 &lt;em&gt;있어야합니다&lt;/em&gt; 반환하기 전에 기본 자원을 닫습니다. 이 방법의 오류 는 연결을 닫는 데 실패 &lt;em&gt;하지 않고&lt;/em&gt; 유예를 얻지 못했음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="659eab4e70caa38a30f16d960317cd3d960b3e36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=False&lt;/code&gt;, the function ignores the cancellation and keeps going, just like if we had called &lt;code&gt;sync_fn&lt;/code&gt; synchronously. This is the default behavior.</source>
          <target state="translated">경우 &lt;code&gt;cancellable=False&lt;/code&gt; 함수는 우리가 호출 한 경우처럼, 취소를 무시하고가는 계속 &lt;code&gt;sync_fn&lt;/code&gt; 기적. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1965c60e86c5c7cf8307b3f7f4c630c274d05a7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=True&lt;/code&gt;, then this function immediately raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. In this case &lt;strong&gt;the thread keeps running in background&lt;/strong&gt; &amp;ndash; we just abandon it to do whatever it&amp;rsquo;s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; is uses a thread with &lt;code&gt;cancellable=True&lt;/code&gt;, because it doesn&amp;rsquo;t really affect anything if a stray hostname lookup keeps running in the background.)</source>
          <target state="translated">경우 &lt;code&gt;cancellable=True&lt;/code&gt; ,이 함수는 즉시 던질 수 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . 이 경우 &lt;strong&gt;스레드는 백그라운드에서 계속 실행&lt;/strong&gt; 됩니다. 수행하려는 작업을 수행하기 위해 &lt;strong&gt;스레드를&lt;/strong&gt; 포기하고 발생한 반환 값 또는 오류를 자동으로 버립니다. 작업이 안전하고 부작용이 없음을 알고있는 경우에만 사용하십시오. (예를 들어, &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;cancellable=True&lt;/code&gt; 인 스레드를 사용 합니다.이 호스트는 길 잃은 호스트 이름 조회가 백그라운드에서 계속 실행되는 경우 실제로 영향을 미치지 않기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="aba6364461f29e62fe17876f0b5c22b5417e80da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; neglects to close the &lt;code&gt;stream&lt;/code&gt;, then it will be closed using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;handler&lt;/code&gt; 무시가 종료 &lt;code&gt;stream&lt;/code&gt; , 그 때 사용 닫힐 것이다 &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1277a00b059c5d2c5ef7f7646d1c9134594a5431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; raises an exception, then this function doesn&amp;rsquo;t do anything special to catch it &amp;ndash; so by default the exception will propagate out and crash your server. If you don&amp;rsquo;t want this, then catch exceptions inside your &lt;code&gt;handler&lt;/code&gt;, or use a &lt;code&gt;handler_nursery&lt;/code&gt; object that responds to exceptions in some other way.</source>
          <target state="translated">경우 &lt;code&gt;handler&lt;/code&gt; 예외가 발생,이 함수는 그것을 잡을 아무것도 특별하지 않습니다 - 그래서 기본적으로 예외는 밖으로 전파하고 서버를 충돌합니다. 이것을 원하지 않으면 &lt;code&gt;handler&lt;/code&gt; 내부에서 예외를 포착 하거나 다른 방식으로 예외에 응답 하는 &lt;code&gt;handler_nursery&lt;/code&gt; 객체를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="16a7aaf08e8695ea95415710c3e4758bb8256152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;host&lt;/code&gt; is given as a numeric IP address, then &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; may handle the request itself rather than calling this method.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 에 숫자 IP 주소가 제공 되면 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는이 메소드를 호출하지 않고 요청 자체를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a97d3af5b4523fc19e8fe52ab6041ae3db11563e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is False (the default), then this attempts to first send a &lt;code&gt;close_notify&lt;/code&gt; and then close the underlying stream by calling its &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;code&gt;https_compatible&lt;/code&gt; 가 false (기본값), 먼저이 시도는 전송 &lt;code&gt;close_notify&lt;/code&gt; 의 호출하여 다음 가까운 기본이되는 스트림을 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="25ae479bd9da72823057df9f18d1514f989532e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is set to True, then this simply closes the underlying stream and marks this stream as closed.</source>
          <target state="translated">경우 &lt;code&gt;https_compatible&lt;/code&gt; 가 True로 설정되어 있으면이 단순히 기본 스트림과 마크 폐쇄로이 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="0f881d1427bb56edf169a6edeb8c1efed87b6b6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;idempotent=True&lt;/code&gt;, then &lt;code&gt;sync_fn&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will make an attempt to process these in first-in first-out order, but no guarantees. (Currently processing is FIFO on CPython 3.6 and PyPy, but not CPython 3.5.)</source>
          <target state="translated">경우 &lt;code&gt;idempotent=True&lt;/code&gt; , 다음 &lt;code&gt;sync_fn&lt;/code&gt; 및 &lt;code&gt;args&lt;/code&gt; 해쉬해야하며, 트리오는 이미 출원중인 통화와 동일한 모든 통화 제출을 폐기하는 것이 가장 노력을 시도합니다. Trio는 선입 선출 방식으로 처리하려고 시도하지만 보장 할 수는 없습니다. (현재 처리는 CPython 3.6 및 PyPy에서 FIFO이지만 CPython 3.5에서는 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="6640f3a40179fca8c977825590b8d93ee250b08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;instrument&lt;/code&gt; is already active, does nothing.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; 가 이미 활성화 된 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef01b2d7eadb45a6611959bf01ff860e59edfd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(exceptions) == 1&lt;/code&gt;, returns that exception. This means that a call to &lt;code&gt;MultiError(...)&lt;/code&gt; is not guaranteed to return a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object!</source>
          <target state="translated">만약 &lt;code&gt;len(exceptions) == 1&lt;/code&gt; , 반환은 그 예외입니다. 이것은 &lt;code&gt;MultiError(...)&lt;/code&gt; 호출 이 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 객체 를 반환한다고 보장하지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="5484f23b9c8687e23e7ba9482accdacff5d91e96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; exists, then calls it. Otherwise, calls &lt;code&gt;self.send_stream.aclose()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; 이 존재, 다음을 호출합니다. 그렇지 않으면 &lt;code&gt;self.send_stream.aclose()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e565b179b461394dd0ee23418e2601771bf98c83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_fn&lt;/code&gt; raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. You should be careful that &lt;code&gt;sync_fn&lt;/code&gt; doesn&amp;rsquo;t crash.</source>
          <target state="translated">경우 &lt;code&gt;sync_fn&lt;/code&gt; 는 예외를 발생, 다음은로 변환됩니다 &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; 및 &lt;em&gt;모든&lt;/em&gt; 작업이 취소됩니다. &lt;code&gt;sync_fn&lt;/code&gt; 이 충돌하지 않도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="990c927a59e2e05acc2c85e7b9eca515a354fef6" translate="yes" xml:space="preserve">
          <source>If None (the default), uses the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, as returned by &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">None (기본값) 인 경우 &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt; 반환 한 기본 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9d05809aaddc05f620de4ba89c04d5864f1d6c4f" translate="yes" xml:space="preserve">
          <source>If a cancel scope becomes cancelled before entering its &lt;code&gt;with&lt;/code&gt; block, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception will be raised at the first checkpoint inside the &lt;code&gt;with&lt;/code&gt; block. This allows a &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; to be created in one &lt;a href=&quot;#tasks&quot;&gt;task&lt;/a&gt; and passed to another, so that the first task can later cancel some work inside the second.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록으로 들어가기 전에 취소 범위가 취소되면 취소 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외는 &lt;code&gt;with&lt;/code&gt; 블록 . 이를 통해 한 &lt;a href=&quot;#tasks&quot;&gt;작업&lt;/a&gt; 에서 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 를 만들고 다른 작업 으로 전달할 수 있으므로 첫 번째 작업은 나중에 두 번째 작업의 일부 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b027817cbeed64537f5db91f3d08fdc471481eee" translate="yes" xml:space="preserve">
          <source>If a system task raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. If you write a system task, you should be careful to make sure it doesn&amp;rsquo;t crash.</source>
          <target state="translated">시스템 작업에서 예외가 발생하면 시스템 작업이 &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; 및&lt;em&gt; 모든&lt;/em&gt; 작업이 취소됩니다. 시스템 작업을 작성하는 경우 충돌하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="4571550f4a15d7bae0009643f675312fe0036d78" translate="yes" xml:space="preserve">
          <source>If an EOF has already been sent, then this method should silently succeed.</source>
          <target state="translated">EOF가 이미 전송 된 경우이 방법은 자동으로 성공합니다.</target>
        </trans-unit>
        <trans-unit id="45296ea408223fb4af1c47429fd38b83d611bdcc" translate="yes" xml:space="preserve">
          <source>If any task inside the nursery finishes with an unhandled exception, then the nursery immediately cancels all the tasks inside the nursery.</source>
          <target state="translated">보육원 내부의 작업이 처리되지 않은 예외로 완료되면 보육원은 보육원 내부의 모든 작업을 즉시 취소합니다.</target>
        </trans-unit>
        <trans-unit id="ad7600a810bc11f91c2adfea072e298afde04ee1" translate="yes" xml:space="preserve">
          <source>If called with an &lt;code&gt;nbytes&lt;/code&gt; that&amp;rsquo;s greater than zero, then it will call &lt;code&gt;sock.recv&lt;/code&gt; at least once, and &lt;code&gt;recv&lt;/code&gt; is an async Trio function, and thus an unconditional checkpoint. So in this case, &lt;code&gt;recv_exactly&lt;/code&gt; acts as a checkpoint. But if we do &lt;code&gt;await
recv_exactly(sock, 0)&lt;/code&gt;, then it will immediately return an empty buffer without executing a checkpoint. If this were a function in Trio itself, then this wouldn&amp;rsquo;t be acceptable, but you may decide you don&amp;rsquo;t want to worry about this kind of minor edge case in your own code.</source>
          <target state="translated">호출하면 &lt;code&gt;nbytes&lt;/code&gt; 0보다 큰입니다, 그것은 호출합니다 &lt;code&gt;sock.recv&lt;/code&gt; 한 번 이상, 그리고 &lt;code&gt;recv&lt;/code&gt; 비동기 트리오 기능, 따라서 무조건 체크 포인트이다. 따라서이 경우 &lt;code&gt;recv_exactly&lt;/code&gt; 는 체크 포인트 역할을합니다. 그러나 &lt;code&gt;await recv_exactly(sock, 0)&lt;/code&gt; 검사 점을 실행하지 않고 빈 버퍼를 즉시 반환합니다. 이것이 Trio 자체의 함수라면 허용되지 않지만 자신의 코드에서 이러한 종류의 사소한 경우에 대해 걱정하지 않기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f5a27e4bd7755771be91835c2cda91fa8349fe" translate="yes" xml:space="preserve">
          <source>If cancelled, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; terminates the subprocess and waits for it to exit before propagating the cancellation, like &lt;a href=&quot;#trio.Process.aclose&quot;&gt;&lt;code&gt;Process.aclose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소하면 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 하위 프로세스를 종료하고 취소를 전파하기 전에 하위 프로세스가 종료 될 때까지 기다립니다.&lt;a href=&quot;#trio.Process.aclose&quot;&gt; &lt;code&gt;Process.aclose()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="888cc7e58c3e7e821d20edf2b5cd73ba760154df" translate="yes" xml:space="preserve">
          <source>If cancelled, kills the process and waits for it to finish exiting before propagating the cancellation.</source>
          <target state="translated">취소하면 프로세스를 종료하고 취소를 전파하기 전에 프로세스가 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="cf2c140a05a78875d1f5d24dc874e16f64335dfa" translate="yes" xml:space="preserve">
          <source>If implementing this interface, you should consider whether you can go one step further and implement &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스를 구현하는 경우 한 단계 더 나아가 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있는지 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0275957337e1463961ce555770ceadbe862e0b84" translate="yes" xml:space="preserve">
          <source>If it blocks, and while it&amp;rsquo;s blocked then one of the scopes around it becomes cancelled, it will return early and raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차단되면 차단되는 동안 주변 범위 중 하나가 취소되고 일찍 반환되어 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dd4041956ee7f9741134e0f1a0b8493a10950c30" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s already True, then this method returns immediately.</source>
          <target state="translated">이미 True 인 경우이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="56f1b3116eaca611475f7b84d97f7ac70972c4ee" translate="yes" xml:space="preserve">
          <source>If the child task passes a value to &lt;code&gt;task_status.started(value)&lt;/code&gt;, then &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; returns this value. Otherwise it returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">자식 작업에 값 통과하면 &lt;code&gt;task_status.started(value)&lt;/code&gt; , 다음 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 이 값을 반환합니다. 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="37629b81efe2e8c145a2a531927b3cf8393e1bc1" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;host&lt;/code&gt; has multiple IP addresses associated with it, then we have a problem: which one do we use?</source>
          <target state="translated">주어진 &lt;code&gt;host&lt;/code&gt; 에 여러 개의 IP 주소가 연결되어 있다면 문제가있는 것입니다 : 어느 것을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="4375ef471535703a9908dadea8805978038773d1" translate="yes" xml:space="preserve">
          <source>If the initial handshake has already completed, this returns immediately without doing anything (except executing a checkpoint).</source>
          <target state="translated">초기 핸드 셰이크가 이미 완료된 경우 검사 점 실행을 제외하고 아무 작업도 수행하지 않고 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="150a98efd2d67aeeb90753e4ff853b2109055a98" translate="yes" xml:space="preserve">
          <source>If the initial handshake is already in progress in another task, this waits for it to complete and then returns.</source>
          <target state="translated">다른 작업에서 초기 핸드 셰이크가 이미 진행 중이면 완료 될 때까지 기다렸다가 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="c19f10e7d00e86fc95aa255c1ac054018dc1a174" translate="yes" xml:space="preserve">
          <source>If the resource is already closed, then this method should silently succeed.</source>
          <target state="translated">리소스가 이미 닫힌 경우이 방법은 자동으로 성공합니다.</target>
        </trans-unit>
        <trans-unit id="9062a923df80e6fab65b8657d9f6a2b9026d5861" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then reparks as many tasks as are available and then returns successfully.</source>
          <target state="translated">파킹 된 작업 수보다 적은 &lt;code&gt;count&lt;/code&gt; 작업이있는 경우 사용 가능한 작업 수를 재 파킹 한 다음 성공적으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="377149956a1262f83743260fb07d31b29a188c54" translate="yes" xml:space="preserve">
          <source>If there are multiple tasks blocked in &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;, then the one with the shortest &lt;code&gt;cushion&lt;/code&gt; is the one woken (and this task becoming unblocked resets the timers for the remaining tasks). If there are multiple tasks that have exactly the same &lt;code&gt;cushion&lt;/code&gt;, then the one with the lowest &lt;code&gt;tiebreaker&lt;/code&gt; value is woken first. And if there are multiple tasks with the same &lt;code&gt;cushion&lt;/code&gt; and the same &lt;code&gt;tiebreaker&lt;/code&gt;, then all are woken.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 에서 여러 작업이 차단 된 경우 가장 짧은 &lt;code&gt;cushion&lt;/code&gt; 이있는 작업이 깨어 난 작업입니다 (이 작업이 차단 해제되면 남은 작업에 대한 타이머가 재설정 됨). 정확히 동일한 &lt;code&gt;cushion&lt;/code&gt; 을 가진 여러 작업이있는 경우 순위 &lt;code&gt;tiebreaker&lt;/code&gt; 값이 가장 낮은 작업 이 먼저 깨어납니다. 그리고 동일한 &lt;code&gt;cushion&lt;/code&gt; 과 동일한 &lt;code&gt;tiebreaker&lt;/code&gt; 가진 여러 작업이있는 경우 모두 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="755478d189f177af5d89c78e624e31c6791f6834" translate="yes" xml:space="preserve">
          <source>If this is called in a context where a cancellation is currently active (i.e., a blocking call will immediately raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;), then returned deadline is &lt;code&gt;-inf&lt;/code&gt;. If it is called in a context where no scopes have a deadline set, it returns &lt;code&gt;inf&lt;/code&gt;.</source>
          <target state="translated">취소가 현재 활성화 된 컨텍스트에서 호출되면 (즉, 블로킹 호출은 즉시 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 발생 &lt;code&gt;-inf&lt;/code&gt; 반환 된 최종 기한은 -inf 입니다. 범위에 마감 기한이 설정되지 않은 컨텍스트에서 호출되면 &lt;code&gt;inf&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d92a60f2ce7686f3c19dfb6575e2c818916fdf31" translate="yes" xml:space="preserve">
          <source>If this method is cancelled while the initial handshake or a renegotiation are in progress, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">초기 핸드 셰이크 또는 재협상이 진행되는 동안이 메소드가 취소되면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로 남겨 둘 수 있습니다. 이 경우 나중에 개체를 사용하려고하면 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8b9129f4324a3c372997bd08724529da9bd32054" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 취소되면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로 둘 수 있습니다. 이 경우 객체를 사용하려고하면 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c31c3e3ccb4521109d40e0f73cc0c0ff055f6741" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법을 취소하면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로수 있습니다. 이 경우 나중에 개체를 사용하려고하면&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="620d8617d908554f99b026fef5e4bce4f30f46da" translate="yes" xml:space="preserve">
          <source>If this stream has been closed, an empty bytearray. Otherwise, the requested data.</source>
          <target state="translated">이 스트림이 닫히면 빈 바이트 배열입니다. 그렇지 않으면 요청 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="01544d5318e6f8b44b1d61a7fe422bbe176746e1" translate="yes" xml:space="preserve">
          <source>If we didn&amp;rsquo;t re-acquire the lock before waking up, and &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; were cancelled here, then we&amp;rsquo;d crash in &lt;code&gt;condition.__aexit__&lt;/code&gt; when we tried to release the lock we no longer held.</source>
          <target state="translated">깨어나 기 전에 자물쇠를 다시 얻지 못한 경우 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;여기에서 wait () 가 취소되면 잠금 상태를 해제하려고 할 때 &lt;code&gt;condition.__aexit__&lt;/code&gt; 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="286548126cabde1417f66f615fe9ea5965912a79" translate="yes" xml:space="preserve">
          <source>If you call an async function provided by Trio (&lt;code&gt;await
&amp;lt;something in trio&amp;gt;&lt;/code&gt;), and it doesn&amp;rsquo;t raise an exception, then it &lt;em&gt;always&lt;/em&gt; acts as a checkpoint. (If it does raise an exception, it might act as a checkpoint or might not.)</source>
          <target state="translated">Trio에서 제공 한 비동기 함수를 호출하면 ( &lt;code&gt;await &amp;lt;something in trio&amp;gt;&lt;/code&gt; ) 예외를 발생시키지 않으면 &lt;em&gt;항상&lt;/em&gt; 검사 점 역할을합니다. (예외가 발생하면 검사 점으로 작동하거나 작동하지 않을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fbdcd39191ff9bf10dd31ff815198d56d63dedd7" translate="yes" xml:space="preserve">
          <source>If you do want to be careful, or if you have some CPU-bound code that doesn&amp;rsquo;t have enough checkpoints in it, then it&amp;rsquo;s useful to know that &lt;code&gt;await trio.sleep(0)&lt;/code&gt; is an idiomatic way to execute a checkpoint without doing anything else, and that &lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt;&lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt;&lt;/a&gt; can be used to test that an arbitrary block of code contains a checkpoint.</source>
          <target state="translated">주의를 기울이고 싶거나 충분한 체크 포인트가없는 CPU 바운드 코드가있는 경우이를 아는 것이 유용합니다 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; 이 체크 포인트를 수행하지 않고 관용적 인 방법 다른 코드와 &lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt; &lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt; &lt;/a&gt; 를 사용하면 임의의 코드 블록에 검사 점이 포함되어 있는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f265254292033b2d3c37d7b404f709ecf9005d4" translate="yes" xml:space="preserve">
          <source>If you get lost or confused&amp;hellip;</source>
          <target state="translated">길을 잃거나 혼란에 빠지면</target>
        </trans-unit>
        <trans-unit id="0d5e059f915ee38aa02ece60adf78aaec1b32ce6" translate="yes" xml:space="preserve">
          <source>If you have a custom hostname resolver, then implementing &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;HostnameResolver&lt;/code&gt;&lt;/a&gt; allows you to register this to be used by Trio.</source>
          <target state="translated">사용자 정의 호스트 이름 확인자가 있으면 구현 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;HostnameResolver&lt;/code&gt; &lt;/a&gt;하면이를 Trio에서 사용하도록 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36078a151ccd458996ba1aa8099651b56e2af5bc" translate="yes" xml:space="preserve">
          <source>If you have a specific interface you want to bind to, pass its IP address or hostname here. If a hostname resolves to multiple IP addresses, this function will open one listener on each of them.</source>
          <target state="translated">바인딩하려는 특정 인터페이스가있는 경우 여기에 해당 IP 주소 또는 호스트 이름을 전달하십시오. 호스트 이름이 여러 IP 주소로 확인되면이 기능은 각각에 대해 하나의 리스너를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7591ea78cf8028ce1427e112792af18d3864711d" translate="yes" xml:space="preserve">
          <source>If you have code that was written to use &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; and now you&amp;rsquo;re porting it to Trio, then it may be useful to know that a difference between &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;https_compatible=True&lt;/code&gt; behavior by default.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt; 을 사용하도록 작성된 코드가 있고 이제이를 Trio로 포팅하는 경우 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; 의 차이점&lt;/a&gt; 은 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;https_compatible=True&lt;/code&gt; 이 기본적으로 https_compatible = True 동작을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4abae696645e70fb575d1bdc420f51262668ed04" translate="yes" xml:space="preserve">
          <source>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</source>
          <target state="translated">동일한 기능에 여러 데코레이터가있는 경우 스택의 맨 아래에 있어야합니다 (실제 기능에 가장 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="128c75659cdce10482417b79d20ee7014fe95a07" translate="yes" xml:space="preserve">
          <source>If you have two different file descriptors for sending and receiving, and want to bundle them together into a single bidirectional &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, then use &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">보내고받는 두 개의 서로 다른 파일 디스크립터가 있고이를 단일 양방향 &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; &lt;/a&gt; 려면 trio.StapledStream 을 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="01311317ab6fdc5abc001bd1faede4dd410963a9" translate="yes" xml:space="preserve">
          <source>If you only run subprocesses without &lt;code&gt;shell=True&lt;/code&gt; and on UNIX, that&amp;rsquo;s all you need to know about specifying the command. If you use &lt;code&gt;shell=True&lt;/code&gt; or run on Windows, you probably should read the rest of this section to be aware of potential pitfalls.</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 를 사용 하지 않고 UNIX에서 하위 프로세스 만 실행 하는 경우 명령 지정에 대해 알아야합니다. 당신이 사용하는 경우 &lt;code&gt;shell=True&lt;/code&gt; 하거나 Windows에서 실행하는 경우이 섹션의 나머지 부분을 읽고 잠재적 인 함정을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7360df706636e337b70ce5ebedc83a7dc602aa0" translate="yes" xml:space="preserve">
          <source>If you run this program, you&amp;rsquo;ll see output like:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="11df8229fc6ec0bf8c5039502d2ef765262f6ef2" translate="yes" xml:space="preserve">
          <source>If you run this, it prints:</source>
          <target state="translated">이것을 실행하면 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="29e33e39e5f4c64e7e7902552bf27f16a4cc81b1" translate="yes" xml:space="preserve">
          <source>If you spawn a &lt;a href=&quot;#subprocess&quot;&gt;Spawning subprocesses&lt;/a&gt;, you can get a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; that lets you write to its stdin, and a &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine its stdin/stdout into a single bidirectional &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and then wrap that in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">당신이 산란하면 &lt;a href=&quot;#subprocess&quot;&gt;산란 서브 프로세스를&lt;/a&gt; , 당신은 얻을 수 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 당신은 그것의 표준 입력에 기록 할 수 있습니다, 그리고 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 당신은 표준 출력에서 읽을 수 있습니다. 어떤 이유로 SSL을 하위 프로세스와 &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 하려는 경우 StapledStream 을 사용하여 stdin / stdout을 단일 양방향 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 다음 SSLStream으로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab3304f0b7f762b993b24e90fc2ed83703c668e7" translate="yes" xml:space="preserve">
          <source>If you try to call it when inside a cancelled scope, then it will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소 된 범위 내에서 호출하려고하면 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0cb8ad089db9738a30a52161499bfc8d1fd20710" translate="yes" xml:space="preserve">
          <source>If you use 0 as your port, then the kernel will automatically pick an arbitrary open port. But be careful: if you use this feature when binding to multiple IP addresses, then each IP address will get its own random port, and the returned listeners will probably be listening on different ports. In particular, this will happen if you use &lt;code&gt;host=None&lt;/code&gt; &amp;ndash; which is the default &amp;ndash; because in this case &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; will bind to both the IPv4 wildcard address (&lt;code&gt;0.0.0.0&lt;/code&gt;) and also the IPv6 wildcard address (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">포트로 0을 사용하면 커널은 자동으로 임의의 열린 포트를 선택합니다. 그러나 여러 IP 주소에 바인딩 할 때이 기능을 사용하는 경우 각 IP 주소는 고유 한 임의 포트를 가져 오며 리턴 된 리스너는 다른 포트에서 청취 할 수 있습니다. 특히, &lt;code&gt;host=None&lt;/code&gt; ( 기본값 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 하면 open_tcp_listeners () 가 IPv4 와일드 카드 주소 ( &lt;code&gt;0.0.0.0&lt;/code&gt; )와 IPv6 와일드 카드 주소 ( &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88ea13f3432ce0d9874ea1805ddf2510d4d0a998" translate="yes" xml:space="preserve">
          <source>If you use this method, you might also want to read up on &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt;.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; 에서 읽을 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="7f6ced9e55c1c268f602e730722b3278b20ae5e9" translate="yes" xml:space="preserve">
          <source>If you want more control than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; affords, you can use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; to spawn a subprocess, and then interact with it using the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 보다 더 많은 제어를 원한다면 &lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt; 를 사용 하여 하위 프로세스를 생성 한 다음 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; 를&lt;/a&gt; 사용하여 하위 프로세스와 상호 작용할 수 있습니다 인터페이스를 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f6793bc982be8f22f967ad6a21c35ccf9672fe" translate="yes" xml:space="preserve">
          <source>If you want to bind to the wildcard address on both IPv4 and IPv6, in order to accept connections on all available interfaces, then pass &lt;code&gt;None&lt;/code&gt;. This is the default.</source>
          <target state="translated">사용 가능한 모든 인터페이스에서 연결을 수락하려면 IPv4 및 IPv6 모두에서 와일드 카드 주소에 바인딩하려면 &lt;code&gt;None&lt;/code&gt; 을 전달하십시오. . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cc32146617cf84e9f0d7584624d5d7d483182905" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr but mixed together in the order they were printed, use: &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt;. This directs the child&amp;rsquo;s stderr into its stdout, so the combined output will be available in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">stdout과 stderr을 모두 캡처하지만 인쇄 된 순서대로 혼합하려면 &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt; . 이것은 어린이의 stderr를 stdout으로 보내므로 결합 된 출력을 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 속성 .</target>
        </trans-unit>
        <trans-unit id="af86717e438853496483f21a6a34b9a46aaba18a" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr while keeping them separate, pass &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt;.</source>
          <target state="translated">stdout과 stderr을 별도로 유지하면서 캡처하려면 &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38252b45e1e41c55aef1d759da898cbd8aba075" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then do some recovery if it timed out:</source>
          <target state="translated">함수에 시간 초과를 적용하고 시간이 초과되면 복구를 수행하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="79b96112188d56b28253e13ce6571d9e8abdac13" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then if it times out then just give up and raise an error for your caller to deal with:</source>
          <target state="translated">함수에 시간 초과를 적용하려는 경우 시간 초과되면 호출자가 처리 할 수있는 오류를 포기하고 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3f808a75d4604bc4da76b55cf7478ba608c98efb" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, but you don&amp;rsquo;t care whether it timed out or not:</source>
          <target state="translated">함수에 시간 초과를 적용하고 싶지만 시간 초과 여부는 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a1518753dc6c14afc1ab9954c1aa2f9c4537ee9" translate="yes" xml:space="preserve">
          <source>If you want to perform general filesystem operations like creating and listing directories, renaming files, or checking file metadata &amp;ndash; or if you just want a friendly way to work with filesystem paths &amp;ndash; then you want &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt;. It&amp;rsquo;s an asyncified replacement for the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt;, and provides the same comprehensive set of operations.</source>
          <target state="translated">디렉토리 생성 및 나열, 파일 이름 변경 또는 파일 메타 데이터 확인과 같은 일반적인 파일 시스템 작업을 수행하려는 경우 또는 파일 시스템 경로를 사용하는 친숙한 방법을 원한다면 &lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; 가 필요&lt;/a&gt; 합니다. 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 대체하는 비동기식입니다. 및 운영의 같은 포괄적 인 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5c2ff5e1676e07dfee499073adaeae46d1a263de" translate="yes" xml:space="preserve">
          <source>If you want to receive Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 바이트가 아닌 Python 객체를 수신하려면 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d873431abf560f99e75a2d91264bee1f1cb0ab51" translate="yes" xml:space="preserve">
          <source>If you want to receive raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 객체가 아닌 원시 바이트를 수신하려면 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58a3ef3ebf410f4e73e5e916a21fac2377aedcd3" translate="yes" xml:space="preserve">
          <source>If you want to see the effect of the consumer exiting early, try adding a &lt;code&gt;break&lt;/code&gt; statement to the &lt;code&gt;async for&lt;/code&gt; loop &amp;ndash; you should see a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; from the producer.</source>
          <target state="translated">소비자가 조기에 종료되는 효과를 보려면 &lt;code&gt;async for&lt;/code&gt; 루프에 &lt;code&gt;break&lt;/code&gt; 문을 추가 하십시오 . 제작자에서 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 가 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d4b21118989033e089c8ae10cb1be03ab62b474" translate="yes" xml:space="preserve">
          <source>If you want to send Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 바이트가 아닌 Python 객체를 보내려면 &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bfa949577a81d6ee39c408b0060d9b3a9b1359f" translate="yes" xml:space="preserve">
          <source>If you want to send raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 객체가 아닌 원시 바이트를 보내려면 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15078494d6548257baf334a23f5ce3f1047e5763" translate="yes" xml:space="preserve">
          <source>If you want to stress test a protocol implementation, one nice trick is to use the &lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module (preferably with a fixed seed) to move random numbers of bytes at a time, and insert random sleeps in between them. You can also set up a custom &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; if you want to manipulate things on the receiving side, and not just the sending side.</source>
          <target state="translated">프로토콜 구현에 대한 스트레스 테스트를 원할 경우 &lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈 (바람직하게는 고정 된 시드)을 사용하여 한 번에 임의의 바이트 수를 이동하고 그 사이에 임의의 절전 모드를 삽입하는 것이 좋습니다. 송신 측뿐만 아니라 수신 측에서 항목을 조작하려는 경우 사용자 정의 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; 을&lt;/a&gt; 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f91fa402eff1105a1adeaf1e1e3e650782929273" translate="yes" xml:space="preserve">
          <source>If you want to use Trio, then the first thing you have to do is call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Trio를 사용하려면 먼저 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="21c7da565039fca46c6760ffc74fa89fb0eba0cd" translate="yes" xml:space="preserve">
          <source>If you want to use only IPv4, or only IPv6, but want to accept on all interfaces, pass the family-specific wildcard address: &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; for IPv4-only and &lt;code&gt;&quot;::&quot;&lt;/code&gt; for IPv6-only.</source>
          <target state="translated">IPv4 만 사용하거나 IPv6 만 사용하고 모든 인터페이스에서 허용하려면 IPv4 전용의 경우 &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; 및 IPv6 전용의 경우 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 과 같은 패밀리 별 와일드 카드 주소를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="409a1ee1102eee81503ac9b40ded20152aafe6b5" translate="yes" xml:space="preserve">
          <source>If you write a custom class implementing the Trio socket interface, then you can use a &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;code&gt;SocketFactory&lt;/code&gt;&lt;/a&gt; to get Trio to use it.</source>
          <target state="translated">Trio 소켓 인터페이스를 구현하는 사용자 정의 클래스를 작성하는 경우 &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt; &lt;code&gt;SocketFactory&lt;/code&gt; &lt;/a&gt; 를 사용하여 Trio가이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6034aab77a6f216c1ab5b1d5c3f35931c5c8769" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a mad scientist or otherwise feel the need to take direct control over the PASSAGE OF TIME ITSELF, then you can implement a custom &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">미친 과학자이거나 PASSAGE OF TIME ITSELF를 직접 제어해야 할 필요가 있다고 생각되면 사용자 정의 &lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; 클래스를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce8031c58c1526815dbf37b52fa1e2d05777dd57" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with semaphores, then you can think of this as a restricted semaphore that&amp;rsquo;s specialized for one common use case, with additional error checking. For a more traditional semaphore, see &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어에 익숙한 경우이를 추가 오류 검사와 함께 하나의 일반적인 사용 사례에 특화된 제한된 세마포어로 생각할 수 있습니다. 보다 전통적인 세마포어을 참조 &lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee1d508a124c1215a7b5f07506c4f3b67f9cb32" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; to limit the number of tasks that can access some resource simultaneously, then consider using a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">일부 리소스에 동시에 액세스 할 수있는 작업 수를 제한 하는 &lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 를 찾고 있다면 대신 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를&lt;/a&gt; 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="c2ceab8baefc8898008496db6707ffc21bacfe8c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; together, then you have to be careful. Setting &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; acts like a background task calling:</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; 를&lt;/a&gt; 함께 사용 하는 경우주의해야합니다. &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; 를&lt;/a&gt; 설정 하면 백그라운드 작업을 호출하는 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="08c549cf9087de57658bffaeb40cba21be44321a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used other I/O frameworks, you may have encountered the concept of a &amp;ldquo;thread pool&amp;rdquo;, which is most commonly implemented as a fixed size collection of threads that hang around waiting for jobs to be assigned to them. These solve two different problems: First, re-using the same threads over and over is more efficient than starting and stopping a new thread for every job you need done; basically, the pool acts as a kind of cache for idle threads. And second, having a fixed size avoids getting into a situation where 100,000 jobs are submitted simultaneously, and then 100,000 threads are spawned and the system gets overloaded and crashes. Instead, the N threads start executing the first N jobs, while the other (100,000 - N) jobs sit in a queue and wait their turn. Which is generally what you want, and this is how &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; works by default.</source>
          <target state="translated">다른 I / O 프레임 워크를 사용한 경우 &quot;스레드 풀&quot;이라는 개념이있을 수 있습니다.이 스레드 풀은 작업이 할당 될 때까지 기다리는 고정 된 크기의 스레드 모음으로 가장 일반적으로 구현됩니다. 이들은 두 가지 다른 문제를 해결합니다. 첫째, 동일한 스레드를 반복해서 재사용하는 것이 필요한 모든 작업에 대해 새 스레드를 시작하고 중지하는 것보다 효율적입니다. 기본적으로 풀은 유휴 스레드에 대한 일종의 캐시 역할을합니다. 둘째, 크기가 고정되어 있으면 100,000 개의 작업이 동시에 제출 된 다음 100,000 개의 스레드가 생성되고 시스템이 오버로드되어 충돌하는 상황이 발생하지 않습니다. 대신 N 스레드가 첫 번째 N 작업을 실행하기 시작하고 다른 (100,000-N) 작업은 대기열에 앉아 차례를 기다립니다. 어느 것이 일반적으로 원하는지, 이것이 어떻게&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 는 기본적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3b707c51adeef615b8afcc1a6c139b7761d771ed" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used the &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; modules, you may be familiar with &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt;&lt;code&gt;asyncio.Queue&lt;/code&gt;&lt;/a&gt;. In Trio, &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt; is what you use when you&amp;rsquo;re looking for a queue. The main difference is that Trio splits the classic queue interface up into two objects. The advantage of this is that it makes it possible to put the two ends in different processes without rewriting your code, and that we can close the two sides separately.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 모듈을 사용한 경우 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt; &lt;code&gt;asyncio.Queue&lt;/code&gt; 에&lt;/a&gt; 익숙 할 수 있습니다 . Trio에서 &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 은 대기열을 찾을 때 사용하는 것입니다. 가장 큰 차이점은 Trio가 클래식 대기열 인터페이스를 두 개체로 분할한다는 것입니다. 이 방법의 장점은 코드를 다시 작성하지 않고도 두 프로세스를 서로 다른 프로세스에 배치 할 수 있고 두 측면을 개별적으로 닫을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b07f876adc2ea078990a31a6d6fd87e7ced229f" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;abort_func&lt;/code&gt; raises an error, or returns any value other than &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</source>
          <target state="translated">귀하의 경우 &lt;code&gt;abort_func&lt;/code&gt; 이 오류가 발생합니다, 또는 이외의 값 반환 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; 다음 트리오가 격렬하게 충돌합니다. 조심해! 마찬가지로 차단 된 작업을 다시 예약하지 않으면 Trio 프로그램을 교착 상태로 만들거나 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 너무 많이 호출하여 혼란을 일으킬 수 있습니다 . 가능한 경우 더 높은 수준의 API를 사용해야하는 방법에 대해 위에서 언급 한 내용을 기억하십니까?</target>
        </trans-unit>
        <trans-unit id="1f6649636f5ec26220a403d0be3a3dfad0c81513" translate="yes" xml:space="preserve">
          <source>Immediately terminate the process.</source>
          <target state="translated">프로세스를 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="4f6dbe18b8350bccd3b6cbe5e585a2220801dfd1" translate="yes" xml:space="preserve">
          <source>In Trio, child tasks inherit the parent nursery&amp;rsquo;s cancel scopes. So in this example, both the child tasks will be cancelled when the timeout expires:</source>
          <target state="translated">Trio에서 하위 작업은 상위 보육원의 취소 범위를 상속합니다. 따라서이 예에서 시간 초과가 만료되면 두 하위 작업이 모두 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="adca0c20a8b210b6d717b9f157a4e42c8458511e" translate="yes" xml:space="preserve">
          <source>In Trio, we standardize on the following conventions:</source>
          <target state="translated">Trio에서는 다음 규칙을 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="eba0fbe044bed37d1ee5815afce7800f998f1460" translate="yes" xml:space="preserve">
          <source>In a perfect world, all third-party libraries and low-level APIs would be natively async and integrated into Trio, and all would be happiness and rainbows.</source>
          <target state="translated">완벽한 세상에서 모든 타사 라이브러리와 저수준 API는 기본적으로 비 동기화되어 Trio에 통합되며 모두 행복과 무지개가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="af175d3a175436652574281c086a32ff0684e455" translate="yes" xml:space="preserve">
          <source>In acknowledgment of this reality, Trio provides two useful utilities for working with real, operating-system level, &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;-module-style threads. First, if you&amp;rsquo;re in Trio but need to push some blocking I/O into a thread, there&amp;rsquo;s &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. And if you&amp;rsquo;re in a thread and need to communicate back with Trio, you can use &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt;&lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 현실을 인정하기 위해 Trio는 실제 운영 체제 수준의 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈 스타일 스레드 작업에 유용한 두 가지 유틸리티를 제공 합니다. 첫째, Trio에 있지만 차단 I / O를 스레드로 푸시 해야하는 경우&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; 가&lt;/a&gt; 있습니다. 스레드에 있고 Trio와 다시 통신해야하는 경우&lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt; &lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb36f9e82fb37771a8f45c9fa49b6f8200dd4dc" translate="yes" xml:space="preserve">
          <source>In addition to fulfilling the &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces, the return objects also have a synchronous &lt;code&gt;close&lt;/code&gt; method.</source>
          <target state="translated">성취하는 것 외에도 &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 인터페이스반환 개체에는 동기 &lt;code&gt;close&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f03f50ad28c191c6b6552e298ff38d97315bda" translate="yes" xml:space="preserve">
          <source>In addition to the methods below, you can use &lt;code&gt;len(parking_lot)&lt;/code&gt; to get the number of parked tasks, and &lt;code&gt;if parking_lot: ...&lt;/code&gt; to check whether there are any parked tasks.</source>
          <target state="translated">아래 방법 외에도 &lt;code&gt;len(parking_lot)&lt;/code&gt; 을 사용 하여 주차 된 작업 수 를 확인 하고 &lt;code&gt;if parking_lot: ...&lt;/code&gt; 주차 된 작업 이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e73f7536eb9efa30a32fd713063b04bc4ef0794" translate="yes" xml:space="preserve">
          <source>In addition to the standard channel methods, all memory channel objects provide a &lt;code&gt;statistics()&lt;/code&gt; method, which returns an object with the following fields:</source>
          <target state="translated">표준 채널 메소드 외에도 모든 메모리 채널 오브젝트 는 다음 필드가있는 오브젝트를 리턴하는 &lt;code&gt;statistics()&lt;/code&gt; 메소드를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="443c7855adca91f5f4c2a290b45f592b6637683c" translate="yes" xml:space="preserve">
          <source>In addition, the following methods are similar to the equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, but have some Trio-specific quirks:</source>
          <target state="translated">또한 다음 메소드는 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 유사 하지만 일부 Trio 관련 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="413061e58789aa3ae8c0df61031c67abdb592c3a" translate="yes" xml:space="preserve">
          <source>In addition, there is a new function to directly convert a standard library socket into a Trio socket:</source>
          <target state="translated">또한 표준 라이브러리 소켓을 Trio 소켓으로 직접 변환하는 새로운 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="425030d69a5c17d60c387cfd4bccb05160ac1b64" translate="yes" xml:space="preserve">
          <source>In any case it&amp;rsquo;s guaranteed that we only call the &lt;code&gt;abort_func&lt;/code&gt; at most once per call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어쨌든 우리는 &lt;code&gt;abort_func&lt;/code&gt; 만 호출한다는 것을 보장합니다&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출마다 최대 한 번만 을 .</target>
        </trans-unit>
        <trans-unit id="ef942a0c9203fcfec85a5301b86deb82c4607851" translate="yes" xml:space="preserve">
          <source>In the US it&amp;rsquo;s also common to see this word spelled &amp;ldquo;canceled&amp;rdquo;, with only one &amp;ldquo;l&amp;rdquo;. This is a &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;recent&lt;/a&gt; and &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;US-specific&lt;/a&gt; innovation, and even in the US both forms are still commonly used. So for consistency with the rest of the world and with &amp;ldquo;cancellation&amp;rdquo; (which always has two &amp;ldquo;l&amp;rdquo;s), Trio uses the two &amp;ldquo;l&amp;rdquo; spelling everywhere.</source>
          <target state="translated">미국에서는이 단어의 철자가 &quot;l&quot;인 &quot;취소됨&quot;이 일반적입니다. 이것은&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt; 최근의 &lt;/a&gt;&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;미국 고유의&lt;/a&gt; 혁신 이며 미국 에서도 두 가지 형식이 여전히 일반적으로 사용됩니다. 따라서 세계의 다른 지역 및 &quot;취소&quot;(항상 두 개의 &quot;l&quot;)와 일관성을 유지하기 위해 Trio는 어디서나 두 개의 &quot;l&quot;철자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16efeed4257a18bc9fdc35fc0ddc91451f889cf7" translate="yes" xml:space="preserve">
          <source>In the example above, we set &lt;code&gt;__cause__&lt;/code&gt; as a form of explicit context chaining. &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;MultiError.filter()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt; also perform implicit exception chaining &amp;ndash; if you return a new exception object, then the new object&amp;rsquo;s &lt;code&gt;__context__&lt;/code&gt; attribute will automatically be set to the original exception.</source>
          <target state="translated">위의 예에서 &lt;code&gt;__cause__&lt;/code&gt; 를 명시 적 컨텍스트 체인 형태로 설정 했습니다 . &lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;MultiError.filter()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt; 도 암시 적 예외 체인을 수행합니다. 새 예외 개체를 반환하면 새 개체의 &lt;code&gt;__context__&lt;/code&gt; 특성이 자동으로 원래 예외로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ba9aa5681eb07f3f85aaca6cead6a6a75b07e2" translate="yes" xml:space="preserve">
          <source>In the previous section you learned how to use virtual in-memory streams to test protocols that are written against Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; abstraction. But what if you have more complicated networking code &amp;ndash; the kind of code that makes connections to multiple hosts, or opens a listening socket, or sends UDP packets?</source>
          <target state="translated">이전 섹션에서는 가상 인 메모리 스트림을 사용하여 Trio에 대해 작성된 프로토콜을 테스트하는 방법을 배웠습니다. &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 추상화. 그러나 더 복잡한 네트워킹 코드가 있다면 여러 호스트에 연결하거나 청취 소켓을 열거 나 UDP 패킷을 보내는 코드와 같은 것입니까?</target>
        </trans-unit>
        <trans-unit id="a0095c623d0110d9746feea443a0e6da70cddc6c" translate="yes" xml:space="preserve">
          <source>In the simplest case, you can apply a timeout to a block of code:</source>
          <target state="translated">가장 간단한 경우 코드 블록에 시간 초과를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff100c80ba5e97057de30f32a18adbad5a88b36" translate="yes" xml:space="preserve">
          <source>In this code, the outer scope will expire after 5 seconds, causing the &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; call to return early with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. Then this exception will propagate through the &lt;code&gt;with
move_on_after(10)&lt;/code&gt; line until it&amp;rsquo;s caught by the &lt;code&gt;with
move_on_after(5)&lt;/code&gt; context manager. So this code will print:</source>
          <target state="translated">이 코드에서 외부 범위는 5 초 후에 만료되어 &lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 호출이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 와 함께 일찍 반환 됩니다. 그런 다음이 예외는 &lt;code&gt;with move_on_after(5)&lt;/code&gt; 컨텍스트 관리자에 의해 포착 될 때까지 &lt;code&gt;with move_on_after(10)&lt;/code&gt; 행을 통해 전파됩니다 . 따라서이 코드는 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd39030cf0f9d49c7b4882dafc1867fcf325030" translate="yes" xml:space="preserve">
          <source>In this log, it&amp;rsquo;s hard to know which lines came from which request. (Did the request that started first also finish first, or not?) One way to solve this is to assign each request a unique identifier, and then include this identifier in each log message:</source>
          <target state="translated">이 로그에서 어떤 라인이 어떤 요청에서 왔는지 알기가 어렵습니다. (먼저 시작된 요청도 먼저 완료 되었습니까, 그렇지 않습니까?)이를 해결하는 한 가지 방법은 각 요청에 고유 한 식별자를 할당 한 다음이 식별자를 각 로그 메시지에 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c5f57d6f1f293c43f3e60c7da9a475c532f3702" translate="yes" xml:space="preserve">
          <source>Increment the semaphore value, possibly waking a task blocked in &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어 값을 늘리면 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 작업을 깨울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="5e2d7833039dc978e6eb0d1055910e03a86a4609" translate="yes" xml:space="preserve">
          <source>Indices and tables</source>
          <target state="translated">지표와 표</target>
        </trans-unit>
        <trans-unit id="039860d992ee7e77987abc3b4a132dfd8deb034e" translate="yes" xml:space="preserve">
          <source>Inherits from&amp;hellip;</source>
          <target state="translated">...에서 상속</target>
        </trans-unit>
        <trans-unit id="a760a6a6a56453764562801ae1f6e4d17df6981e" translate="yes" xml:space="preserve">
          <source>Inside Trio, we&amp;rsquo;re very picky about this, because Trio is the foundation of the whole system so we think it&amp;rsquo;s worth the extra effort to make things extra predictable. It&amp;rsquo;s up to you how picky you want to be in your code. To give you a more realistic example of what this kind of issue looks like in real life, consider this function:</source>
          <target state="translated">Trio는 전체 시스템의 기초이므로 Trio 내에서 매우 까다 롭습니다. 따라서 일을 더 예측 가능하게 만드는 추가 노력이 필요하다고 생각합니다. 코드에서 얼마나 까다롭기를 원하는지는 당신에게 달려 있습니다. 실생활에서 이런 종류의 문제가 어떻게 생겼는지에 대한보다 현실적인 예를 제공하려면 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4383f9af14e2a6238f0ca630f4abb63f780fec7f" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;with&lt;/code&gt; block, a cancellation of &lt;code&gt;cancel_scope&lt;/code&gt; (via a call to its &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; method or via the expiry of its &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt;) will immediately interrupt the &lt;code&gt;long_running_operation()&lt;/code&gt; by raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; at its next &lt;a href=&quot;#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 &lt;code&gt;cancel_scope&lt;/code&gt; 를 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 메소드 호출 또는 &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt; 만료를 통해 &lt;code&gt;long_running_operation()&lt;/code&gt; 다음에 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 높여 long_running_operation () 을 즉시 중단합니다.&lt;a href=&quot;#checkpoints&quot;&gt; 검사 점&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc578a93a7ae18b3336261ddcddb492f729be12e" translate="yes" xml:space="preserve">
          <source>Install: &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; (or on Windows, maybe &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt;). No compiler needed.</source>
          <target state="translated">설치 : &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; (또는 Windows의 경우 &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt; ). 컴파일러가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b8599d5e978753d93f75d58a522579079b5ed94" translate="yes" xml:space="preserve">
          <source>Instances of this class implement a &lt;code&gt;__call__&lt;/code&gt; method which returns an async context manager. The idea is that you pass a sequence number to &lt;code&gt;__call__&lt;/code&gt; to say where this block of code should go in the linear sequence. Block 0 starts immediately, and then block N doesn&amp;rsquo;t start until block N-1 has finished.</source>
          <target state="translated">이 클래스의 인스턴스 는 비동기 컨텍스트 관리자를 반환하는 &lt;code&gt;__call__&lt;/code&gt; 메서드를 구현합니다 . 아이디어는 시퀀스 번호를 &lt;code&gt;__call__&lt;/code&gt; 에 전달하는 것입니다. 에 하여이 코드 블록이 선형 시퀀스에서 어디로 가야하는지 말합니다. 블록 0은 즉시 시작된 다음 블록 N-1이 완료 될 때까지 블록 N이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ec5b66be254478fa22108fac8f5d2812e01372a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, you create a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 을 사용하는 대신 SSLStream 을 작성하십시오 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="627fcf03843dc8a8605eb47152a8672db7094c61" translate="yes" xml:space="preserve">
          <source>Instrument API</source>
          <target state="translated">기기 API</target>
        </trans-unit>
        <trans-unit id="05dc85f2b3ab4754451d1f9965930cf9da6a45a9" translate="yes" xml:space="preserve">
          <source>Instruments don&amp;rsquo;t have to inherit from this abstract base class, and all of these methods are optional. This class serves mostly as documentation.</source>
          <target state="translated">인스트루먼트는이 추상 기본 클래스에서 상속 할 필요가 없으며 이러한 모든 메소드는 선택 사항입니다. 이 클래스는 주로 문서화 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="eca9838aabbb78d1b5e3acdb2dd4e57649569498" translate="yes" xml:space="preserve">
          <source>Inter-task ordering</source>
          <target state="translated">작업 간 순서</target>
        </trans-unit>
        <trans-unit id="636ae634805f18ba2489e4cf0305b910ad6e1ec2" translate="yes" xml:space="preserve">
          <source>Interacting with a process as it runs</source>
          <target state="translated">프로세스가 실행될 때 상호 작용</target>
        </trans-unit>
        <trans-unit id="8d73f8d3b26a1a856cc0af59962f16a7a7926a99" translate="yes" xml:space="preserve">
          <source>Internally, Python&amp;rsquo;s async/await syntax is built around the idea of &amp;ldquo;coroutine objects&amp;rdquo; and &amp;ldquo;coroutine runners&amp;rdquo;. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;), and the Trio scheduler acts as their coroutine runner.</source>
          <target state="translated">내부적으로 파이썬의 비동기 / 대기 구문은 &quot;코 루틴 객체&quot;와 &quot;코 루틴 러너&quot;라는 아이디어를 중심으로 구축되었습니다. 코 루틴 객체는 비동기 호출 스택의 상태를 나타냅니다. 그러나 그 자체로, 이것은 단지 정적 객체입니다. 무언가를 원한다면 코 루틴 러너가 필요합니다. 모든 Trio 작업에는 관련 코 루틴 개체가 있습니다 ( &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조) . ) Trio 스케줄러는 해당 코 루틴 러너 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="211f3ecde809054095962b782038f30e2565b4f3" translate="yes" xml:space="preserve">
          <source>Internally, this class is implemented using an instance of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;, and all of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s methods and attributes are re-exported as methods and attributes on this class. However, there is one difference: &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; has several methods that return information about the encrypted connection, like &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt;&lt;code&gt;cipher()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt;&lt;code&gt;selected_alpn_protocol()&lt;/code&gt;&lt;/a&gt;. If you call them before the handshake, when they can&amp;rsquo;t possibly return useful data, then &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt; returns None, but &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로이 클래스는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 구현 되며 모든 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 의 메소드 및 속성은이 클래스의 메소드 및 속성으로 다시 내보내집니다. 그러나 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt; &lt;code&gt;cipher()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt; &lt;code&gt;selected_alpn_protocol()&lt;/code&gt; &lt;/a&gt; 과 같이 암호화 된 연결에 대한 정보를 리턴하는 몇 가지 메소드가 있습니다. 핸드 셰이크 전에 호출하면 유용한 데이터를 반환 할 수 없을 때 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 는 None을 반환하지만 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad10a74de784eb77b7994e8e3df391e71c75b48" translate="yes" xml:space="preserve">
          <source>Introduce a schedule point, but not a cancel point.</source>
          <target state="translated">취소 지점이 아닌 스케줄 지점을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="3a39def0776ba74eafe8baafe78545be2b62c2bf" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with &lt;code&gt;trio.hazmat&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.hazmat&lt;/code&gt; 로 Trio 검사 및 확장</target>
        </trans-unit>
        <trans-unit id="f875ac8ad79c6803f9483ecd07dc8b2c5c1bf08d" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with trio.hazmat</source>
          <target state="translated">trio.hazmat로 Trio 검사 및 확장</target>
        </trans-unit>
        <trans-unit id="0b7ac58e93ecd2e82e060a85238c964fc4eccff9" translate="yes" xml:space="preserve">
          <source>Issue a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt; if the calling context has been cancelled.</source>
          <target state="translated">호출 컨텍스트가 취소 된 경우 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트를&lt;/a&gt; 발행하십시오 .</target>
        </trans-unit>
        <trans-unit id="887b272faffff6c3a2885420536e51339dbc8a6a" translate="yes" xml:space="preserve">
          <source>It does not block on entry; on exit it blocks until all child tasks have exited.</source>
          <target state="translated">진입시 차단되지 않습니다. 종료시 모든 하위 작업이 종료 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="41ece27b44dd2fb5b5e3df97582a4f71e506eca1" translate="yes" xml:space="preserve">
          <source>It has no public constructor; instead, see &lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt;&lt;code&gt;current_trio_token()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공개 생성자가 없습니다. 대신 &lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt; &lt;code&gt;current_trio_token()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="447673e9dd692338c50de7bb68089f9e3af415fe" translate="yes" xml:space="preserve">
          <source>It lets the kernel pick a random open port, so your test suite doesn&amp;rsquo;t depend on any particular port being open.</source>
          <target state="translated">커널이 임의의 열린 포트를 선택할 수 있으므로 테스트 스위트는 열려있는 특정 포트에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="633fa68ba8c3421538913d615267233a7c6773ae" translate="yes" xml:space="preserve">
          <source>It lets you re-enter the Trio run loop from external threads or signal handlers. This is the low-level primitive that &lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt;&lt;code&gt;trio.to_thread()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt; use to communicate with worker threads, that &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;trio.open_signal_receiver&lt;/code&gt;&lt;/a&gt; uses to receive notifications about signals, and so forth.</source>
          <target state="translated">외부 스레드 또는 신호 처리기에서 Trio 실행 루프를 다시 입력 할 수 있습니다. 이것은 &lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt; &lt;code&gt;trio.to_thread()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; &lt;/a&gt; 가 작업자 스레드와 통신하는 &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;trio.open_signal_receiver&lt;/code&gt; &lt;/a&gt; 사용 하고 trio.open_signal_receiver 가 신호 등에 대한 알림을 수신 하는 데 사용 하는 하위 레벨 기본 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="04dd56709d7215046123e0d08943911499806dfe" translate="yes" xml:space="preserve">
          <source>It may still be some time before it actually runs, if there are other runnable tasks ahead of it.</source>
          <target state="translated">실행 가능한 다른 태스크가있는 경우 실제로 실행되기까지 어느 정도 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf4f355598208394d057b6e9e1b696ccd36f2db" translate="yes" xml:space="preserve">
          <source>It should attempt to clean up any state associated with this call, and in particular, arrange that &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; be called later. If (and only if!) it is successful, then it should return &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, in which case the task will automatically be rescheduled with an appropriate &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">이 호출과 관련된 상태를 정리하고 특히 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 이 나중에 호출 &lt;em&gt;되지 않도록&lt;/em&gt; 정렬해야합니다 . 성공한 경우 (만!) 성공한 경우 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 .이 경우 작업이 적절한 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 오류 와 함께 자동으로 다시 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="84a6d66c512d9418dc7fbafea6c57006dc4ab36a" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy&amp;hellip; and the proxy also uses HTTPS. So you end up having to do &lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL-on-top-of-SSL&lt;/a&gt;. In Trio this is trivial &amp;ndash; just wrap your first &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in a second &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">때로는 HTTPS 서버에 연결하려고하지만 웹 프록시를 거쳐야하며 프록시도 HTTPS를 사용합니다. 따라서 &lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL에서 SSL&lt;/a&gt; 을 수행해야 합니다 . Trio에서는이 작업이 간단합니다. 첫 번째 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 두 번째 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로 감싸면됩니다.&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="15180ba1a972d7f41d05f1bcb1b11159fd06fdaf" translate="yes" xml:space="preserve">
          <source>It uses the Listener object to find out which port was picked, so it can connect to the right place.</source>
          <target state="translated">리스너 객체를 사용하여 어떤 포트를 선택했는지 확인하여 올바른 위치에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f96f61f491e94e6eed579393e73c5c30394e987" translate="yes" xml:space="preserve">
          <source>It waits for the server to be accepting connections on that port before &lt;code&gt;start&lt;/code&gt; returns, so there&amp;rsquo;s no race condition where the incoming connection arrives before the server is ready.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 하기 전에 서버가 해당 포트에서 연결을 수락하기를 기다립니다 . 따라서 서버가 준비되기 전에 들어오는 연결이 도착하는 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e4aef67556653c2e10c9ddc35f43ebcf2681e23" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where Trio checks for cancellation. For example, if the code that called your function set a timeout, and that timeout has expired, then the next time your function executes a checkpoint Trio will raise a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. See &lt;a href=&quot;#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; below for more details.</source>
          <target state="translated">Trio가 취소를 확인하는 지점입니다. 예를 들어, 함수를 호출 한 코드가 시간 초과를 설정하고 해당 시간 초과가 만료 된 경우 다음에 함수가 검사 점을 실행할 때 Trio는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다. 자세한 내용은 아래 &lt;a href=&quot;#cancellation&quot;&gt;취소 및 시간 초과&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41d67c32934a3fdf70e308bc3ec0237ebb3a5908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where the Trio scheduler checks its scheduling policy to see if it&amp;rsquo;s a good time to switch to another task, and potentially does so. (Currently, this check is very simple: the scheduler always switches at every checkpoint. But &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;this might change in the future&lt;/a&gt;.)</source>
          <target state="translated">이제는 Trio 스케줄러가 예약 정책을 확인하여 다른 작업으로 전환하기에 적절한시기인지 확인해야합니다. (현재이 검사는 매우 간단합니다. 스케줄러는 항상 모든 검사 점에서 전환됩니다. 그러나 &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;이것은 향후 변경 될 수 있습니다&lt;/a&gt; . .)</target>
        </trans-unit>
        <trans-unit id="9feb70da8199f87a0468305b1613eb72121082b8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important in any long-running code to make sure that you regularly check for cancellation, because otherwise timeouts won&amp;rsquo;t work! This happens implicitly every time you call a cancellable operation; see &lt;a href=&quot;#cancellable-primitives&quot;&gt;below&lt;/a&gt; for details. If you have a task that has to do a lot of work without any I/O, then you can use &lt;code&gt;await sleep(0)&lt;/code&gt; to insert an explicit cancel+schedule point.</source>
          <target state="translated">또한 장기 실행 코드에서는 시간 초과가 작동하지 않기 때문에 정기적으로 취소를 확인하는 것이 중요합니다! 취소 할 수있는 작업을 호출 할 때마다 암시 적으로 발생합니다. 자세한 내용은 &lt;a href=&quot;#cancellable-primitives&quot;&gt;아래&lt;/a&gt; 를 참조하십시오. I / O없이 많은 작업을 수행해야하는 작업이있는 경우 &lt;code&gt;await sleep(0)&lt;/code&gt; 을 사용하여 명시적인 취소 + 일정 지점을 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3158edb2cb07aefc306e4b70006fb6942ffbee20" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to check what the current effective deadline is, which is sometimes useful:</source>
          <target state="translated">현재 유효 마감일이 무엇인지 확인할 수 있으며 때로는 유용합니다.</target>
        </trans-unit>
        <trans-unit id="028b2f8f16c5b9e63ae61fb6e6dada307141004f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s even possible for a fixed-size policy to cause unexpected &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt;. Imagine a situation where we have two different types of blocking jobs that you want to run in the thread pool, type A and type B. Type A is pretty simple: it just runs and completes pretty quickly. But type B is more complicated: it has to stop in the middle and wait for some other work to finish, and that other work includes running a type A job. Now, suppose you submit N jobs of type B to the pool. They all start running, and then eventually end up submitting one or more jobs of type A. But since every thread in our pool is already busy, the type A jobs don&amp;rsquo;t actually start running &amp;ndash; they just sit in a queue waiting for the type B jobs to finish. But the type B jobs will never finish, because they&amp;rsquo;re waiting for the type A jobs. Our system has deadlocked. The ideal solution to this problem is to avoid having type B jobs in the first place &amp;ndash; generally it&amp;rsquo;s better to keep complex synchronization logic in the main Trio thread. But if you can&amp;rsquo;t do that, then you need a custom thread allocation policy that tracks separate limits for different types of jobs, and make it impossible for type B jobs to fill up all the slots that type A jobs need to run.</source>
          <target state="translated">고정 크기 정책으로 인해 예기치 않은 결과가 발생할 수도 있습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt; 교착 상태&lt;/a&gt;. 스레드 풀에서 실행하려는 두 가지 유형의 블로킹 작업이 유형 A와 유형 B 인 상황을 상상해보십시오. 유형 A는 매우 간단합니다. 실행하고 아주 빨리 완료됩니다. 그러나 유형 B는 더 복잡합니다. 중간에서 중지하고 다른 작업이 완료 될 때까지 기다려야하며 다른 작업에는 유형 A 작업 실행이 포함됩니다. 이제 B 유형의 N 개 작업을 풀에 제출한다고 가정하십시오. 이들은 모두 실행을 시작한 다음 결국 하나 이상의 유형 A의 작업을 제출하게됩니다. 그러나 풀의 모든 스레드가 이미 사용 중이므로 유형 A 작업은 실제로 실행되지 않습니다. 대기중인 대기열에 대기하기 만합니다. 완료 할 B 유형 작업. 그러나 유형 B 작업은 유형 A 작업을 기다리고 있기 때문에 완료되지 않습니다. 우리 시스템이 교착 상태에 빠졌습니다.이 문제에 대한 이상적인 솔루션은 처음에 유형 B 작업을 피하는 것입니다. 일반적으로 기본 Trio 스레드에서 복잡한 동기화 논리를 유지하는 것이 좋습니다. 그러나이를 수행 할 수없는 경우 여러 유형의 작업에 대한 별도의 한계를 추적하고 유형 B 작업이 유형 A 작업이 실행해야하는 모든 슬롯을 채우는 것을 불가능하게하는 사용자 정의 스레드 할당 정책이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="afebfc9278bc2aa8347dcf570a97d23e86487e4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s main use is to represent the situation when multiple child tasks all raise errors &amp;ldquo;in parallel&amp;rdquo;.</source>
          <target state="translated">여러 하위 작업이 모두 &quot;병렬&quot;로 오류를 발생시키는 상황을 나타내는 것이 주된 용도입니다.</target>
        </trans-unit>
        <trans-unit id="26f9b89089d0869162c76d5126491f1513bd67d7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to pass a nursery object into another task, which allows that task to start new child tasks in the first task&amp;rsquo;s nursery.</source>
          <target state="translated">보육원 개체를 다른 작업에 전달하면 해당 작업이 첫 번째 작업 보육원에서 새 자식 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb0a395eef8d10797750c4bc8c7869ddcde8e1a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s surprisingly easy to think that one&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is enabled when it isn&amp;rsquo;t, or vice-versa. This function tells you what Trio thinks of the matter, which makes it useful for &lt;code&gt;assert&lt;/code&gt;s and unit tests.</source>
          <target state="translated">놀랍게도 사용자의 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화되어 있지 않은 경우 또는 그 반대로 할 수 있다고 생각하기 쉽습니다 . 이 기능은 Trio가 해당 사안에 대해 어떻게 생각하는지 알려주므로, &lt;code&gt;assert&lt;/code&gt; 및 단위 테스트에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0d15b7a76653351f46b83405a4b54f98735b9042" translate="yes" xml:space="preserve">
          <source>Its public members are mostly useful for introspection and debugging:</source>
          <target state="translated">공개 멤버는 주로 검사 및 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="545be0d53d794aaf39339209b55c20d210fc586f" translate="yes" xml:space="preserve">
          <source>Joining the team</source>
          <target state="translated">팀에 합류</target>
        </trans-unit>
        <trans-unit id="7673cd582fda3b7f7b13b3b20adaee67d3277fe9" translate="yes" xml:space="preserve">
          <source>Just make sure that you don&amp;rsquo;t write:</source>
          <target state="translated">다음과 같이 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a5d5b5c6bfe7553575cde5418f08d509d5536896" translate="yes" xml:space="preserve">
          <source>Kqueue-specific API</source>
          <target state="translated">큐에 특정 API</target>
        </trans-unit>
        <trans-unit id="d9fa2d2f6148e9b5ccb844620248db405f8fae9c" translate="yes" xml:space="preserve">
          <source>License: MIT or Apache 2, your choice</source>
          <target state="translated">라이센스 : MIT 또는 Apache 2, 원하는 선택</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="1c6fb693fc4f098795743e41d419b3149fbcfbfb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt;, but blocks until the new task has finished initializing itself, and optionally returns some information from it.</source>
          <target state="translated">&lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 새 작업이 자체 초기화를 완료 할 때까지 차단하고 선택적으로 일부 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d6aaff931158c5ba7e26961a9b89a7d40bfe5ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="3ba838f0e35e06c2fb726a07ae29793e339bfe10" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt;&lt;code&gt;cwd()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt; &lt;code&gt;cwd()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8c5a9d23abb5f6ad444cc24b04b27fe9e10a9442" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">exist &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="8029effe0016a68af627078e548169d8a3b664b6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt;&lt;code&gt;expanduser()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt; &lt;code&gt;expanduser()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="b0ea04f9f1e4f38a25764ce18a995446b4f28854" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt;&lt;code&gt;glob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt; &lt;code&gt;glob()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="6bd3ff84b863acbc6c9cce99ac69c33bd2909786" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt;&lt;code&gt;group()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt; &lt;code&gt;group()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="3c7cc416a3a8bb593ea6e8e88d3e887928347553" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt;&lt;code&gt;home()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt; &lt;code&gt;home()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="728cd83a8211f6734ef960185330051b8c20ab07" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt;&lt;code&gt;is_block_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt; &lt;code&gt;is_block_device()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8357198911fe8c7b4765505acc1d51e94d363fe8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt;&lt;code&gt;is_char_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt; &lt;code&gt;is_char_device()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="ed5693661e601d1afa38f136a0d4a3de1c725a7c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="6bf2ce402b5a06571ec3de8e0f0931b96a01a498" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt;&lt;code&gt;is_fifo()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt; &lt;code&gt;is_fifo()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="88810a7083f1ac5a369fdea2c965c22ad7623a35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;is_file()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt; &lt;code&gt;is_file()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="61d10cc589f2610067e2e12e0e6fb88489b0ada2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt;&lt;code&gt;is_socket()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt; &lt;code&gt;is_socket()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="ea98fc1e541c2149ddd3990468d1ad6ebb4ac1b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt;&lt;code&gt;is_symlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt; &lt;code&gt;is_symlink()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8a36e3cfed8e29bbe795e9ccce0d0fbf0b367ad5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt;&lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt; &lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="10fec790c4c6e2567f23d61565f736a38ac6732a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt;&lt;code&gt;lchmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt; &lt;code&gt;lchmod()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="27baac762d9c7f298a4f06767b1d507901aed386" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="0bd8091a0b0ceaf877772076df583a166ddd961c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="81ed714fc7a307ba54353248fdcbfcfa493b3ed0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt;&lt;code&gt;owner()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt; &lt;code&gt;owner()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9da40bbd79ff6bce0630d88aeb0d8aa86ff563c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt;&lt;code&gt;read_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt; &lt;code&gt;read_bytes()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="05643660a056d15b3298760145d0de764a98bdc4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt;&lt;code&gt;read_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt; &lt;code&gt;read_text()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="f2ccca9c18dd36f4ae76b849609b73b1f637edf9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt;&lt;code&gt;rename()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt; &lt;code&gt;rename()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="76951f8bac108e58977f3a4e8acfa6286eb8d22d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="c3055a464134a4216721f8a866ac651e4570f06f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt;&lt;code&gt;resolve()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt; &lt;code&gt;resolve()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="582d833e4f101ac47d1717f59890a75fb92e760c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt;&lt;code&gt;rglob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt; &lt;code&gt;rglob()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="fb2b385994122d22fd4d232559e18a11a60ac4e4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9f63131435769ee3fb708892ef6a3216170a46f9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt;&lt;code&gt;samefile()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt; &lt;code&gt;samefile()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="aca6058c180917f2d39ac469babfe5a04db23516" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="7c17e79bf844528efb02f89a4dda1d3db03d70d8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt;&lt;code&gt;symlink_to()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt; &lt;code&gt;symlink_to()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="f22e90e30bbe4e59bff5e37bbcb40e20951b2f52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt;&lt;code&gt;touch()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt; &lt;code&gt;touch()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="58c2987df5b3af271a9c8db4100daec2f09bc978" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="80edc61fe623d63b6acb59ba26df15585ede97f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt;&lt;code&gt;write_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt; &lt;code&gt;write_bytes()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="1a4a32aa0a4740a573dfbedc612a5d244880ac5d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt;&lt;code&gt;write_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt; &lt;code&gt;write_text()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9d2e0e0cca76297df2e87075fa4119c9402e1264" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt;&lt;code&gt;socket.fromfd()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt; &lt;code&gt;socket.fromfd()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 Trio 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="331a6322c874ec83d06c6d08fb611b5f4faa1156" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt;&lt;code&gt;socket.fromshare()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt; &lt;code&gt;socket.fromshare()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 Trio 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2dc4e28850f2e365df27694052bb1e0b1746a9c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt;&lt;code&gt;socket.getprotobyname()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt; &lt;code&gt;socket.getprotobyname()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="de36e1033225ba39f47cc4b92c54ebfc92f0e4ce" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but returns a pair of Trio socket objects.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; 하지만, 반환 트리오 소켓 객체의 쌍.</target>
        </trans-unit>
        <trans-unit id="61c8f4b41ffadae4dad59039c078152bc2597395" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt;, but if there&amp;rsquo;s nothing ready to receive, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">등은 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 있지만 수신 할 준비가 아무것도 존재하지 않는 경우는, 제기 &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; 을&lt;/a&gt; 대신 차단.</target>
        </trans-unit>
        <trans-unit id="ec539be4b605bbd35ef9da29c0dc79d1cdf0bd6e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, but if the channel&amp;rsquo;s buffer is full, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 채널의 버퍼가 가득 찬 경우, 그러나, 제기 &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; 을&lt;/a&gt; 차단하는 대신.</target>
        </trans-unit>
        <trans-unit id="243773033574d612f4454d84b3c941029d2df11a" translate="yes" xml:space="preserve">
          <source>Listen for incoming TCP connections, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">들어오는 TCP 연결을 수신하고 각 연결마다 &lt;code&gt;handler(stream)&lt;/code&gt; 실행 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d6bf85b52b590445a244abd378949eb3d59be0a" translate="yes" xml:space="preserve">
          <source>Listen for incoming connections on &lt;code&gt;listeners&lt;/code&gt;, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listeners&lt;/code&gt; 에서 들어오는 연결을 수신 하고 각 연결 마다 &lt;code&gt;handler(stream)&lt;/code&gt; 실행 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f93b003cac3bafe43f93f4a3ced9aa90bc77fce" translate="yes" xml:space="preserve">
          <source>Listeners don&amp;rsquo;t generally raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt;, because for listeners there is no general condition of &amp;ldquo;the network/remote peer broke the connection&amp;rdquo; that can be handled in a generic way, like there is for streams. Other errors &lt;em&gt;can&lt;/em&gt; occur and be raised from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; &amp;ndash; for example, if you run out of file descriptors then you might get an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with its errno set to &lt;code&gt;EMFILE&lt;/code&gt;.</source>
          <target state="translated">리스너의 경우 일반적으로 스트림과 같이 일반적인 방식으로 처리 할 수있는 &quot;네트워크 / 원격 피어가 연결을 끊었습니다&quot;라는 일반적인 조건이 없기 때문에 리스너는 일반적으로 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; 를 발생&lt;/a&gt; 시키지 않습니다 . 다른 오류 &lt;em&gt;가&lt;/em&gt; 발생할 &lt;em&gt;수&lt;/em&gt; 있으며 &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 에서 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. 예를 들어 파일 설명자가 부족하면 errno가 &lt;code&gt;EMFILE&lt;/code&gt; 로 설정된 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="3fbdd9c2573faeae1c0dfd16bc50c0374a0de2ca" translate="yes" xml:space="preserve">
          <source>Logs the error to the standard library logger &lt;code&gt;trio.serve_listeners&lt;/code&gt; (level = ERROR, with exception information included). By default this causes it to be printed to stderr.</source>
          <target state="translated">표준 라이브러리 로거 &lt;code&gt;trio.serve_listeners&lt;/code&gt; 에 오류를 기록합니다. (예외 정보가 포함 된 레벨 = ERROR). 기본적으로 이것은 stderr로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="97f4c6bc248313454e7e7ff078c667720978c27a" translate="yes" xml:space="preserve">
          <source>Look up a name given a numeric address.</source>
          <target state="translated">숫자로 된 이름을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4abb92fa47a0d5605410443253231d75eb0f04a0" translate="yes" xml:space="preserve">
          <source>Look up a numeric address given a name.</source>
          <target state="translated">이름이 주어진 숫자 주소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1259ecea5b81acd627020537220f81aca7783275" translate="yes" xml:space="preserve">
          <source>Look up a protocol number by name. (Rarely used.)</source>
          <target state="translated">이름으로 프로토콜 번호를 찾으십시오. (드물게 사용되는.)</target>
        </trans-unit>
        <trans-unit id="0392a16047d2b6a75f0f5ee3bfcd028004b4120c" translate="yes" xml:space="preserve">
          <source>Looking at this, you might wonder how you can tell whether the inner block timed out &amp;ndash; perhaps you want to do something different, like try a fallback procedure or report a failure to our caller. To make this easier, &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;&amp;acute;s &lt;code&gt;__enter__&lt;/code&gt; function returns an object representing this cancel scope, which we can use to check whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception:</source>
          <target state="translated">이를 살펴보면 내부 블록의 시간이 초과되었는지 알 수 있습니다. 대체 절차를 시도하거나 발신자에게 실패를보고하는 등 다른 방법을 원할 수도 있습니다. 이것을 더 쉽게하기 위해 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; s &lt;code&gt;__enter__&lt;/code&gt; 함수는이 취소 범위를 나타내는 객체를 반환하는데,이 범위는이 범위가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 잡았는지 여부를 확인하는 데 사용할 수 있습니다 예외를 .</target>
        </trans-unit>
        <trans-unit id="6ef282847417f9b8a3de2e592804abf1d9e73760" translate="yes" xml:space="preserve">
          <source>Low-level I/O primitives</source>
          <target state="translated">저수준 I / O 프리미티브</target>
        </trans-unit>
        <trans-unit id="9809ec59234a7fd4fad0458de06fb6ceef59377a" translate="yes" xml:space="preserve">
          <source>Low-level blocking</source>
          <target state="translated">저수준 차단</target>
        </trans-unit>
        <trans-unit id="26b0d3fb85c1a77979b58fc0dcdac52cde7cf583" translate="yes" xml:space="preserve">
          <source>Low-level checkpoint functions</source>
          <target state="translated">저수준 체크 포인트 기능</target>
        </trans-unit>
        <trans-unit id="83e3f9dcd236493cb7f1a761c41a62a9d9243115" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; 을&lt;/a&gt; 통한 저수준 네트워킹</target>
        </trans-unit>
        <trans-unit id="a9c1d4245e788744e95621301756e1256b668cc4" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;code&gt;trio.socket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.socket&lt;/code&gt; 을 통한 저수준 네트워킹</target>
        </trans-unit>
        <trans-unit id="7a7080e23ec2bf698dbac21fef72095025b7bd60" translate="yes" xml:space="preserve">
          <source>Lower-level synchronization primitives</source>
          <target state="translated">하위 레벨 동기화 기본 요소</target>
        </trans-unit>
        <trans-unit id="64c3a5b776dfc9fed8c84912a5b25137610b3851" translate="yes" xml:space="preserve">
          <source>Maintainer Enforcement Process</source>
          <target state="translated">관리자 시행 프로세스</target>
        </trans-unit>
        <trans-unit id="32ff137c78a32d8e8b4e8c2e8ca701567f8320ff" translate="yes" xml:space="preserve">
          <source>Make a TLS-encrypted Connection to the given host and port over TCP.</source>
          <target state="translated">TCP를 통해 지정된 호스트 및 포트에 대한 TLS 암호화 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6577f5e216517f3a725c9bdbffa4833cc30cdf56" translate="yes" xml:space="preserve">
          <source>Managing issues</source>
          <target state="translated">이슈 관리</target>
        </trans-unit>
        <trans-unit id="874fe6380efcf8567cd3945da6538e701efad61f" translate="yes" xml:space="preserve">
          <source>Managing multiple producers and/or multiple consumers</source>
          <target state="translated">여러 생산자 및 / 또는 여러 소비자 관리</target>
        </trans-unit>
        <trans-unit id="ce4b94ac2fcd6838a8a9dde11f20624bdeb42a0c" translate="yes" xml:space="preserve">
          <source>Manually advance the clock by the given number of seconds.</source>
          <target state="translated">주어진 시간 (초)만큼 시계를 수동으로 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="7589bf933d13f8bfdcd3193c9dc3896e3e03bbe5" translate="yes" xml:space="preserve">
          <source>Many people expect that switching to from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to &lt;strong&gt;reduce the frequency of latency glitches.&lt;/strong&gt;</source>
          <target state="translated">많은 사람들이 동기 파일 I / O에서 비동기 파일 I / O로 전환하면 항상 프로그램 속도가 빨라질 것으로 기대합니다. 이것은 사실이 아닙니다! 전체 처리량 만 살펴보면 비동기 파일 I / O가 더 빠르거나 느리거나 거의 같을 수 있으며 정확한 디스크 액세스 패턴이나 RAM 용량과 같은 방식에 따라 복잡한 방식으로 달라집니다. 비동기 파일 I / O의 주요 동기는 처리량을 개선하는 것이 아니라 &lt;strong&gt;대기 시간 글리치 빈도&lt;/strong&gt; 를 &lt;strong&gt;줄이는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14b7986ca23831901ae0b3efc4ed19e3339816a9" translate="yes" xml:space="preserve">
          <source>Marks this stream as closed, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">이 스트림을 닫힌 것으로 표시 한 다음 &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt; (있는 경우) 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="12cc69819eb175688379de996ddca98b1fee239a" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time. The first task will get the first item sent, the second task will get the second item sent, and so on.</source>
          <target state="translated">메모리 채널을 통해 여러 작업 이 동시에 &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 전화를 걸 수 있습니다. 첫 번째 작업은 첫 번째 항목이 전송되고 두 번째 작업은 두 번째 항목이 전송되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="9381ec63c31149e49413a93c0bb86c8b8276149d" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time.</source>
          <target state="translated">메모리 채널을 통해 여러 작업에서 전화를 걸 &lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 이 동시에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebacba51b60d5a007ce59beb654e883261ff033" translate="yes" xml:space="preserve">
          <source>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don&amp;rsquo;t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</source>
          <target state="translated">메모리 채널은 가볍고 할당이 저렴하며 완전히 메모리 내입니다. 여기에는 운영 체제 리소스 나 직렬화가 포함되지 않습니다. 그들은 작업 사이에 직접 파이썬 객체를 전달합니다 (내부 버퍼에서 도중에 중단 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3cb22c5e4eabc0e7d3ccf2b60e66f53421b63149" translate="yes" xml:space="preserve">
          <source>Module Index</source>
          <target state="translated">모듈 색인</target>
        </trans-unit>
        <trans-unit id="8d872704047e831df65df9aed5d46fc4c57e9bb3" translate="yes" xml:space="preserve">
          <source>Most errors coming from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; are allowed to propagate out (crashing the server in the process). However, some errors &amp;ndash; those which indicate that the server is temporarily overloaded &amp;ndash; are handled specially. These are &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;s with one of the following errnos:</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 에서 발생하는 대부분의 오류 는 전파 될 수 있습니다 (프로세스에서 서버 충돌). 그러나 서버에 일시적으로 과부하가 걸렸음을 나타내는 일부 오류는 특수하게 처리됩니다. 이들은 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 입니다&lt;/a&gt;다음 오류 중 하나 .</target>
        </trans-unit>
        <trans-unit id="a8cd11a5ccaa1971cc54179d399d4e54a3915836" translate="yes" xml:space="preserve">
          <source>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can&amp;rsquo;t start a child task unless you&amp;rsquo;re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</source>
          <target state="translated">동시 프로그래밍을위한 대부분의 라이브러리를 사용하면 언제 어디서나 새로운 자식 작업 (또는 스레드 등)을 시작할 수 있습니다. Trio는 약간 다릅니다. 책임있는 부모가 될 준비가되어 있지 않으면 하위 작업을 시작할 수 없습니다. 당신의 책임을 보여주는 방법은 보육원을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="faa7a87e100ccbf148f4d32180dde3f6a74122cc" translate="yes" xml:space="preserve">
          <source>Most low-level operations in Trio provide a guarantee: if they raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, this means that they had no effect, so the system remains in a known state. This is &lt;strong&gt;not true&lt;/strong&gt; for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. If this operation raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt; (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</source>
          <target state="translated">Trio의 대부분의 하위 수준 작업은 보증을 제공합니다. &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; 를 올리면 아무런 효과가 없으므로 시스템이 알려진 상태로 유지됩니다. 이것은 &lt;strong&gt;사실이 아니다&lt;/strong&gt; 에 대한 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; . 이 작업에서 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; (또는 해당 사안의 다른 예외)가 발생하면 요청 된 데이터 중 일부 또는 전부를 보내거나 보내지 않았을 수 있으며 어떤 방법을 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="93b72a6b4349c6293f75d57aad8d0127982f3ec5" translate="yes" xml:space="preserve">
          <source>Most users won&amp;rsquo;t need this, but it may be useful on cleanup paths where you can&amp;rsquo;t afford to block, or if you want to close a resource and don&amp;rsquo;t care about handling it gracefully. For example, if &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; encounters an error and cannot perform its own graceful close, then there&amp;rsquo;s no point in waiting to gracefully shut down the underlying transport either, so it calls &lt;code&gt;await
aclose_forcefully(self.transport_stream)&lt;/code&gt;.</source>
          <target state="translated">대부분의 사용자는 이것을 필요로하지 않지만, 차단할 여유가없는 정리 경로 나 리소스를 닫고 정상적으로 처리하는 데 신경 쓰지 않는 정리 경로에 유용 할 수 있습니다. 예를 들어, &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 오류가 발생하여 고유 한 닫기를 수행 할 수없는 경우 기본 전송을 정상적으로 종료하기를 &lt;code&gt;await aclose_forcefully(self.transport_stream)&lt;/code&gt; 호출합니다. .</target>
        </trans-unit>
        <trans-unit id="263333d23c256397b1932a66d3b96bed36f57e27" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">하나의 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 에서 모든 주차 된 작업 이동 객체에서 다른 객체로 .</target>
        </trans-unit>
        <trans-unit id="d7821f30476ccc057b781233fe6a409ab7b1f821" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">하나의 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 에서 주차 된 작업 이동 객체에서 다른 객체로 .</target>
        </trans-unit>
        <trans-unit id="8bad03d4f386e821713ff697a351c0c7fddba714" translate="yes" xml:space="preserve">
          <source>Networking with Trio</source>
          <target state="translated">Trio와의 네트워킹</target>
        </trans-unit>
        <trans-unit id="5ef93032cd6cb3e1deb49d648d00e034030e5fed" translate="yes" xml:space="preserve">
          <source>Normally, a Trio task doesn&amp;rsquo;t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</source>
          <target state="translated">일반적으로 Trio 작업은 코 루틴 개체가 종료 될 때까지 종료되지 않습니다. 이 함수를 호출하면 Trio는 방금 종료 된 코 루틴 객체처럼 작동하고 작업은 주어진 결과로 종료됩니다. 이것은 코 루틴 오브젝트를 다른 코 루틴 러너로 영구적으로 전환하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="498e98b1248914319c5ba185502949174d8f34bb" translate="yes" xml:space="preserve">
          <source>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</source>
          <target state="translated">일반적으로 Python에서는 한 번에 한 가지만 발생하므로 한 번에 한 가지만 잘못 될 수 있습니다. 트리오에는 그러한 제한이 없습니다. 다음과 같은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="83d1bdb0177297f4b3942b5656e2acef994da375" translate="yes" xml:space="preserve">
          <source>Not constructed directly, use &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">직접 구성하지 않고 대신 &lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eadd2611bf484c2f1c8acb474416269466aa9dc7" translate="yes" xml:space="preserve">
          <source>Not implemented yet!</source>
          <target state="translated">아직 구현되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c005918e9288af566376fbbfea029bf8b6679638" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;closed&amp;rdquo; here means that &lt;em&gt;your&lt;/em&gt; code closed the resource, generally by calling a method with a name like &lt;code&gt;close&lt;/code&gt; or &lt;code&gt;aclose&lt;/code&gt;, or by exiting a context manager. If a problem arises elsewhere &amp;ndash; for example, because of a network failure, or because a remote peer closed their end of a connection &amp;ndash; then that should be indicated by a different exception class, like &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">여기서 &quot;닫힘&quot;은 일반적으로 &lt;code&gt;close&lt;/code&gt; 또는 &lt;code&gt;aclose&lt;/code&gt; 와 같은 이름의 메소드를 호출 하거나 컨텍스트 관리자를 종료 &lt;em&gt;하여&lt;/em&gt; 코드가 자원을 닫았다는 것을 의미합니다 . 네트워크 장애로 인해 또는 원격 피어가 연결 종료를 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 등의 문제가 발생하면 BrokenResourceError 또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 하위 클래스와 같은 다른 예외 클래스로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4c5fde44cdcbb0229d2ec83868918f591012895" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cushion&lt;/code&gt; is measured in &lt;em&gt;real&lt;/em&gt; time, not the Trio clock time.</source>
          <target state="translated">주의 &lt;code&gt;cushion&lt;/code&gt; 측정되는 &lt;em&gt;실제&lt;/em&gt; 시간이 아닌 트리오 시계 시간.</target>
        </trans-unit>
        <trans-unit id="c2f474f246c27fafa3dfbf010e4d2f00c8ffe806" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is a very obscure corner case that you&amp;rsquo;re unlikely to notice, but we document it for completeness. (If this &lt;em&gt;does&lt;/em&gt; cause problems for you, of course, then &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;we want to know!&lt;/a&gt;)</source>
          <target state="translated">효율성을 위해 코어 실행 루프는 만료 된 마감 시간 만 가끔 확인합니다. 이것은 어떤 경우에는 시계가 마감 기한이 만료되었다고 말하는 시점과 체크 포인트가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 시작하는 시점 사이에 약간의 지연이있을 수 있음을 의미합니다 . 이것은 눈에 잘 띄지 않는 매우 모호한 경우이지만 완전성을 위해 문서화합니다. 이 경우 ( &lt;em&gt;않는&lt;/em&gt; 당신을 위해 문제를 일으킬 물론, 그때 &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;우리는 알고 싶다!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a4da239427acde2c8d842bd9203aa10f330974e5" translate="yes" xml:space="preserve">
          <source>Note that if you leave the &lt;code&gt;with&lt;/code&gt; block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python&amp;rsquo;s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the &lt;code&gt;with&lt;/code&gt; block.</source>
          <target state="translated">반복자가 추출되지 않은 신호가 여전히 보류중인 동안 &lt;code&gt;with&lt;/code&gt; 블록을 벗어나면 Python의 정규 신호 처리 로직을 사용하여 다시 전달됩니다. 이렇게하면 신호가 종료되기 직전에 신호가 도착할 때 경쟁 조건을 피할 수 &lt;code&gt;with&lt;/code&gt; 블록을 .</target>
        </trans-unit>
        <trans-unit id="712bd61d427cff2f726afa6001462d20b944b4f7" translate="yes" xml:space="preserve">
          <source>Note that it actually loads the whole directory list into memory immediately, during the initial call. (See &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;issue #501&lt;/a&gt; for discussion.)</source>
          <target state="translated">실제로는 초기 호출 중에 전체 디렉토리 목록을 메모리에 즉시로드합니다. ( 토론 은 &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;문제 # 501&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="18074fc1649e3851e18407e48fba948b511fbd36" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; &amp;ldquo;takes ownership&amp;rdquo; of the given socket; closing the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; will also close the socket.</source>
          <target state="translated">있습니다 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 가&lt;/a&gt; 주어진 소켓의 &quot;소유권을&quot;; 닫는 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 은&lt;/a&gt; 또한 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="2ad4e8916ad84553a99fb9d5ed08077c69f39ffa" translate="yes" xml:space="preserve">
          <source>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</source>
          <target state="translated">스케줄러는이를 무시하고 현재 작업이 적절하다고 판단되면 (예 : 효율성 향상) 현재 작업을 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a870766bee2cab11ad647d758a862b70449e3239" translate="yes" xml:space="preserve">
          <source>Note that these APIs are actually in &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;trio.abc&lt;/code&gt;, but we document them here because they&amp;rsquo;re primarily intended for testing.</source>
          <target state="translated">이 API는 실제로 &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;trio.abc&lt;/code&gt; 에 있지만 주로 테스트 용이므로 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6717e388dfea4f31cd0847c699c3d8b947978c" translate="yes" xml:space="preserve">
          <source>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</source>
          <target state="translated">이 함수는 비동기식이며 검사 점 역할을하지만 대부분의 비동기식 함수와 달리 무한히 차단할 수는 없습니다 (적어도 기본 리소스 개체가 올바르게 구현되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="60263bbd81e421eab5c9b77a0bb97880024cfdea" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; an async function and you don&amp;rsquo;t use await when calling it. It sets up the new task, but then returns immediately, &lt;em&gt;before&lt;/em&gt; it has a chance to run. The new task won&amp;rsquo;t actually get a chance to do anything until some later point when you execute a checkpoint and the scheduler decides to run it. If you want to run a function and immediately wait for its result, then you don&amp;rsquo;t need a nursery; just use &lt;code&gt;await async_fn(*args)&lt;/code&gt;. If you want to wait for the task to initialize itself before continuing, see &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 것을 참고 &lt;em&gt;하지&lt;/em&gt; 비동기 기능을 호출 할 때 await를 사용하지 마십시오. 새 작업을 설정 한 다음 실행 기회를 갖기 &lt;em&gt;전에&lt;/em&gt; 즉시 반환 합니다. 새 작업은 실제로 검사 점을 실행하고 스케줄러가이를 실행하기로 결정한 시점이 될 때까지 실제로 작업을 수행 할 수 없습니다. 함수를 실행하고 결과를 즉시 기다리려면 보육이 필요하지 않습니다. 단지 사용 &lt;code&gt;await async_fn(*args)&lt;/code&gt; . 계속하기 전에 작업이 초기화 될 때까지 기다리려면 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e596896727edc23e1453160d700101f2cccdb2ec" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문의 전체 본문에 대한 단일 30 초 시간 초과입니다 . 이것은 다른 파이썬 라이브러리에서 볼 수있는 것과 다릅니다. 시간 초과는 종종 &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;더 복잡한&lt;/a&gt; 것을 나타냅니다. . 우리는이 방법이 추론하기 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d90917fbab7be987474e0660b08f23d296f2c615" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;, this does not take a &lt;code&gt;fileno=&lt;/code&gt; argument. If a &lt;code&gt;fileno=&lt;/code&gt; is specified, then &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; returns a regular Trio socket object instead of calling this method.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;fileno=&lt;/code&gt; 인수를 사용 하지 않습니다 . 경우 &lt;code&gt;fileno=&lt;/code&gt; 지정하면 &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 대신이 방법을 호출하는 일반 트리오 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee9f1e467c615fa7fe75945105dc0ba02d240448" translate="yes" xml:space="preserve">
          <source>Note that what matters here is the scopes that were active when &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery()&lt;/code&gt;&lt;/a&gt; was called, &lt;em&gt;not&lt;/em&gt; the scopes active when &lt;code&gt;start_soon&lt;/code&gt; is called. So for example, the timeout block below does nothing at all:</source>
          <target state="translated">여기서 중요한 것은 &lt;code&gt;start_soon&lt;/code&gt; 이 호출 될 때 활성화 된 범위가 &lt;em&gt;아니라 &lt;/em&gt;&lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery()&lt;/code&gt; &lt;/a&gt; 가 호출 되었을 때 활성화 된 범위 입니다. 예를 들어 아래의 타임 아웃 블록은 아무 것도 수행하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0dd16afc9aa65302712b5fe96789de465a014cf" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나중에 다시 시작 하려면 현재 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 저장해야합니다 . &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; 검색 할 수 있습니다 . 이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 사용 하여 코 루틴 객체를 검색 할 수도 있습니다 ( &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="fd0ce03c8decb818ff508ff8fee1d404e44208e2" translate="yes" xml:space="preserve">
          <source>Notice a small trick we use: the code in &lt;code&gt;main&lt;/code&gt; creates clone objects to pass into all the child tasks, and then closes the original objects using &lt;code&gt;async with&lt;/code&gt;. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</source>
          <target state="translated">우리가 사용하는 작은 트릭에 주목하십시오. &lt;code&gt;main&lt;/code&gt; 의 코드는 모든 자식 작업에 전달할 복제 객체를 만든 다음 a &lt;code&gt;async with&lt;/code&gt; 사용하여 원본 객체를 닫습니다 . 또 다른 옵션은 클론을 하위 작업 중 하나에 모두 전달한 다음 다음과 같이 원본 개체를 마지막 작업에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d6fc1814d50a5f137f3e0720ddabca9f27c56cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;server&lt;/code&gt; opens a nursery and passes it to &lt;code&gt;new_connection_listener&lt;/code&gt;, and then &lt;code&gt;new_connection_listener&lt;/code&gt; is able to start new tasks as &amp;ldquo;siblings&amp;rdquo; of itself. Of course, in this case, we could just as well have written:</source>
          <target state="translated">통지 &lt;code&gt;server&lt;/code&gt; 보육을 열고에 전달 &lt;code&gt;new_connection_listener&lt;/code&gt; 다음과 &lt;code&gt;new_connection_listener&lt;/code&gt; 는 자신의 &quot;형제&quot;로 새로운 작업을 시작할 수 있습니다. 물론이 경우에도 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37b67492b27cf2315618722132887747e63dd5f" translate="yes" xml:space="preserve">
          <source>Now suppose that the remote server stops responding, so our call to &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and &lt;code&gt;send_hello_msg&lt;/code&gt; will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. But then, in the &lt;code&gt;finally&lt;/code&gt; block, we make another blocking operation, which will also hang forever! At this point, if we were using &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; or another library with &amp;ldquo;edge-triggered&amp;rdquo; cancellation, we&amp;rsquo;d be in trouble: since our timeout already fired, it wouldn&amp;rsquo;t fire again, and at this point our application would lock up forever. But in Trio, this &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; happen: the &lt;code&gt;await
conn.send_goodbye_msg()&lt;/code&gt; call is still inside the cancelled block, so it will also raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이제 원격 서버가 응답을 &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; 호출 이 영원히 중단 된다고 가정합니다 . 다행 &lt;code&gt;send_hello_msg&lt;/code&gt; 코드 주위에 시간 초과를 설정하기에 충분히 영리했기 때문에 결국 시간 초과가 만료되고 send_hello_msg 가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 시킵니다. 그러나 &lt;code&gt;finally&lt;/code&gt; 블록에서 다른 차단 작업을 수행하면 영원히 중단됩니다! 이 시점에서 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 또는&amp;ldquo;edge-triggered&amp;rdquo;취소와 함께 다른 라이브러리를 사용하는 경우 문제가 발생합니다. 이미 시간 초과가 발생했기 때문에 다시 시작되지 않으며이 시점에서 응용 프로그램이 영원히 잠기 게됩니다. . 그러나 Trio에서는 이러한 상황 이 발생 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; call은 여전히 ​​취소 된 블록 안에 있으므로 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="02c8f6d70943a7fac1506484bdd19fd986fc4dea" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;send&lt;/code&gt; calls wait for the &lt;code&gt;receive&lt;/code&gt; calls to finish, which forces the producer to slow down to match the consumer&amp;rsquo;s speed. (It might look strange that some values are reported as &amp;ldquo;Received&amp;rdquo; before they&amp;rsquo;re reported as &amp;ldquo;Sent&amp;rdquo;; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</source>
          <target state="translated">이제 &lt;code&gt;send&lt;/code&gt; 통화는 &lt;code&gt;receive&lt;/code&gt; 통화가 완료 될 때까지 기다리 므로 생산자가 소비자의 속도에 맞춰 속도를 늦 춥니 다. (일부 값이 &quot;보냄&quot;으로보고되기 전에 &quot;수신 됨&quot;으로보고되는 것은 이상하게 보일 수 있습니다. 실제 전송 / 수신이 동시에 발생하기 때문에 어떤 행이 먼저 인쇄되는지는 임의적입니다.)</target>
        </trans-unit>
        <trans-unit id="4e56b32190bfb5370d26b04e4a28ca4757d98a90" translate="yes" xml:space="preserve">
          <source>Now try replacing &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; with &lt;code&gt;open_memory_channel(0)&lt;/code&gt;, and run it again. We get output like:</source>
          <target state="translated">이제 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 을 &lt;code&gt;open_memory_channel(0)&lt;/code&gt; 바꾸고 다시 실행하십시오. 우리는 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="adc4ba48cd9ba8dfc30133e2521b610c7b62038b" translate="yes" xml:space="preserve">
          <source>Now, here&amp;rsquo;s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs&amp;hellip; but that&amp;rsquo;s basically every function, because you never know when you might need to add a &lt;code&gt;log.debug(...)&lt;/code&gt; call to some utility function buried deep in the call stack, and when you&amp;rsquo;re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except&amp;hellip; a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn&amp;rsquo;t going to work. What we need is something that&amp;rsquo;s &lt;em&gt;like&lt;/em&gt; a global variable, but that can have different values depending on which request handler is accessing it.</source>
          <target state="translated">문제는 다음과 같습니다. 로깅 코드는 요청 식별자가 무엇인지 어떻게 알 수 있습니까? 한 가지 접근 방식은 로그를 내보내려는 모든 함수에 명시 적으로 전달하는 것입니다.하지만 기본적으로 모든 함수입니다. &lt;code&gt;log.debug(...)&lt;/code&gt; 호출 스택에 깊이 묻혀있는 유틸리티 함수를 호출하십시오. 디버깅 중일 때 마지막으로 원하는 불쾌한 문제는 먼저 중지하고 요청 식별자를 통과하기 위해 모든 것을 리팩터링해야합니다! 때로는 이것이 올바른 해결책이지만 때로는 전역 변수에 식별자를 저장하여 로깅 기능이 필요할 때마다 찾아 볼 수 있으면 훨씬 편리합니다. 예외적으로 전역 변수는 한 번에 하나의 값만 가질 수 있으므로 한 번에 여러 핸들러가 실행되면 작동하지 않습니다. 우리에게 필요한 것은 무언가이다 &lt;em&gt;처럼&lt;/em&gt; 전역 변수,하지만 요청 처리기가 액세스하는에 따라 다른 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18a97ec0e1695e28d7a8fe2a6572b4583a7001e4" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try setting a small but nonzero buffer size, like &lt;code&gt;open_memory_channel(3)&lt;/code&gt;. what do you think will happen?</source>
          <target state="translated">이제 &lt;code&gt;open_memory_channel(3)&lt;/code&gt; 과 같이 작지만 0이 아닌 버퍼 크기를 설정해 봅시다 . 당신은 어떻게 될 것이라고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="fd5e18f90249b8669806f325c583b198ada3d939" translate="yes" xml:space="preserve">
          <source>Nurseries and spawning</source>
          <target state="translated">보육원 및 산란</target>
        </trans-unit>
        <trans-unit id="16d7703fe16bb0df95242d1426109cc4459c2e07" translate="yes" xml:space="preserve">
          <source>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</source>
          <target state="translated">보육원은 실행중인 모든 작업이 열린 보육원에 속하기 때문에 고아 작업이 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="20dca5710da376ad5a814a1da5182bc19a89b8b0" translate="yes" xml:space="preserve">
          <source>Objects that implement this interface can be used as async context managers, i.e., you can write:</source>
          <target state="translated">이 인터페이스를 구현하는 객체는 비동기 컨텍스트 관리자로 사용될 수 있습니다. 즉, 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b940f5465fbd6a31841a4291aeea0108a4130ad" translate="yes" xml:space="preserve">
          <source>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</source>
          <target state="translated">물론 실제 생산자와 소비자는 일반적으로 이보다 더 복잡하며 경우에 따라 약간의 버퍼링으로 인해 처리량이 향상 될 수 있습니다. 그러나 버퍼링이 너무 많으면 메모리가 낭비되고 대기 시간이 길어 지므로 응용 프로그램을 조정하려면 어떤 값이 가장 적합한 지 실험 해보아야합니다.</target>
        </trans-unit>
        <trans-unit id="e5af8fe33a8522754410781a2a311fe81b69b085" translate="yes" xml:space="preserve">
          <source>Of course we don&amp;rsquo;t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</source>
          <target state="translated">물론 우리는 프로그램이 중단 될 때 일반적으로 그것을 좋아하지 않습니다. 어떻게 된 거예요? 문제는 생산자가 3 개의 메시지를 보낸 다음 종료했지만 소비자는 생산자가 사라 졌다는 것을 알 수있는 방법이 없다는 것입니다. 그래서 네 번째 메시지를 영원히 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0326ef61ce31f93eca90a3c1fc454c143eaee8a" translate="yes" xml:space="preserve">
          <source>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it&amp;rsquo;s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least &amp;ndash; it&amp;rsquo;s not Trio&amp;rsquo;s problem). To do this, create a new scope, and set its &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attribute to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">물론 정리 처리기에서 또 다른 차단 호출을하려면 Trio가 허용합니다. 실수로 발에 총을 쏘는 것을 막으려 고합니다. 의도적으로 발을 쏘는 것은 문제가되지 않습니다 (적어도 트리오의 문제는 아닙니다). 이렇게하려면 새 범위를 만들고 &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; 속성을 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 로 설정하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3053b0a18145d078b6fd276d56918a38b129cb0" translate="yes" xml:space="preserve">
          <source>Of course, this rule doesn&amp;rsquo;t apply to APIs that need to impose internal timeouts. For example, if you write a &lt;code&gt;start_http_server&lt;/code&gt; function, then you probably should give your caller some way to configure timeouts on individual requests.</source>
          <target state="translated">물론이 규칙은 내부 시간 초과를 적용해야하는 API에는 적용되지 않습니다. 예를 들어 &lt;code&gt;start_http_server&lt;/code&gt; 함수 를 작성하면 호출자에게 개별 요청에 대한 시간 종료를 구성 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fd62c1a5622fc073c28a93c33b57b2cdd713f8e" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;code&gt;sig&lt;/code&gt; may be any signal defined in the &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, such as &lt;code&gt;signal.SIGINT&lt;/code&gt; or &lt;code&gt;signal.SIGTERM&lt;/code&gt;. On Windows, it may be anything accepted by the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt;&lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UNIX에서 &lt;code&gt;sig&lt;/code&gt; 는 &lt;code&gt;signal.SIGINT&lt;/code&gt; 또는 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 과 같이 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 모든 신호일 수 있습니다 . Windows에서는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt; &lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt; &lt;/a&gt; 에서 허용하는 것이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf6f1410af029c2960985ac658c1c9ea77c283a7" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt;. On Windows, it calls &lt;code&gt;TerminateProcess&lt;/code&gt;. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; if you want to ensure the process is actually dead before proceeding.</source>
          <target state="translated">UNIX에서 이는 &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt; 과 같습니다 . Windows에서는 &lt;code&gt;TerminateProcess&lt;/code&gt; 를 호출합니다 . 두 경우 모두 프로세스가 종료되는 것을 막을 수는 없지만 종료는 비동기 적으로 전달됩니다. 진행하기 전에 프로세스가 실제로 종료되었는지 확인 하려면 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="093bb857c24ad88054bdae99c1ac11b6ac41ad98" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt;; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; forcibly terminates the process in the same manner as &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UNIX에서 이는 &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt; 과 같습니다 . 일반적으로 이것은 정상적인 종료를 요청하지만 오작동이나 버그가있는 프로세스는이를 무시할 수 있습니다. Windows에서 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 과 동일한 방식으로 프로세스를 강제 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="63bccc32cfb24ea3be7c492da42e7d6931504b60" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer file descriptor, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won&amp;rsquo;t do anything useful for on-disk files.</source>
          <target state="translated">유닉스 시스템에서 &lt;code&gt;obj&lt;/code&gt; 는 정수 파일 디스크립터이거나 정수 파일 디스크립터 를 리턴하는 &lt;code&gt;.fileno()&lt;/code&gt; 메소드를 가진 객체 여야 합니다. 정확한 의미론은 커널에 따라 다르지만 모든 종류의 파일 디스크립터를 전달할 수 있습니다. 예를 들어, 이것은 온 디스크 파일에 유용한 기능을 수행하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a969b2d9ca8b91fa9abe22200e2f4c6b06299d74" translate="yes" xml:space="preserve">
          <source>On Windows systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer &lt;code&gt;SOCKET&lt;/code&gt; handle, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer &lt;code&gt;SOCKET&lt;/code&gt; handle. File descriptors aren&amp;rsquo;t supported, and neither are handles that refer to anything besides a &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템의 경우, &lt;code&gt;obj&lt;/code&gt; 하나의 정수이어야 &lt;code&gt;SOCKET&lt;/code&gt; A의 핸들, 또는 다른 물체 &lt;code&gt;.fileno()&lt;/code&gt; 정수 반환 방법 &lt;code&gt;SOCKET&lt;/code&gt; 핸들을. 파일 디스크립터는 지원되지 않으며 &lt;code&gt;SOCKET&lt;/code&gt; 이외의 것을 참조하는 핸들도 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="fc652985d9f1e9dde967ef006b4df5bdb1adee42" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell &lt;code&gt;CMD.EXE&lt;/code&gt; and one by the process being spawned, and they&amp;rsquo;re &lt;em&gt;different&lt;/em&gt;. (And there&amp;rsquo;s no &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; are not treated as special if the shell thinks they&amp;rsquo;re inside double quotes, but &lt;code&gt;%FOO%&lt;/code&gt; environment variable substitutions still are, and the shell doesn&amp;rsquo;t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading &lt;code&gt;^&lt;/code&gt;. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 Windows 에서는 상황이 더욱 혼란스러워집니다. 이제 Windows 명령 셸 &lt;code&gt;CMD.EXE&lt;/code&gt; 와 생성되는 프로세스에 &lt;em&gt;따라 서로 다른&lt;/em&gt; 두 가지 인용 규칙 세트가 적용됩니다 . (또한 &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 는 저장 하지 않습니다 . Windows에서도 UNIX 스타일의 인용 규칙을 사용합니다.) 쉘 &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; 쉘이 큰 따옴표 안에 있다고 생각하면 특수한 것으로 취급되지 않지만 &lt;code&gt;%FOO%&lt;/code&gt; 환경 변수 대체가 여전히 존재하고 쉘은 큰 따옴표로 묶은 문자열 안에 큰 따옴표를 쓸 수있는 방법을 제공하지 않으면 되지 않습니다. 큰 따옴표 외의 경우, 큰 따옴표를 포함하여 모든 문자를 이스케이프 처리 할 수 ​​있습니다 &lt;code&gt;^&lt;/code&gt; . 그러나 파이프 라인에서 각 명령을 서브 쉘로 실행하여 파이프 라인이 처리되므로 여러 계층의 이스케이프가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24aef8753094fb445e161838d7875f71ea24d80" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is not exported, because it&amp;rsquo;s a trap: the name is the same as Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, but the semantics are &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;different and extremely broken&lt;/a&gt;. In the very rare cases where you actually want &lt;code&gt;SO_REUSEADDR&lt;/code&gt; on Windows, then it can still be accessed from the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows에서는 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 이 트랩이기 때문에 내 보내지 않습니다. 이름은 Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 과 동일 하지만 의미가 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;다르고 크게 손상&lt;/a&gt; 됩니다. Windows에서 실제로 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 원하는 매우 드문 경우 에도 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1df29ab054edbd8897c505b18471d47700563f66" translate="yes" xml:space="preserve">
          <source>On Windows, the fundamental API for process spawning (the &lt;code&gt;CreateProcess()&lt;/code&gt; system call) takes a string, not a list, and it&amp;rsquo;s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that &lt;code&gt;main()&lt;/code&gt; should take a list of arguments, &lt;em&gt;most&lt;/em&gt; programs you encounter will follow the rules used by the Microsoft C/C++ runtime. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;documented&lt;/a&gt; alongside the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you&amp;rsquo;re spawning doesn&amp;rsquo;t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there&amp;rsquo;s simply no way to pass an argument containing a double-quote to a Windows batch file.)</source>
          <target state="translated">Windows에서 프로세스 생성을위한 기본 API ( &lt;code&gt;CreateProcess()&lt;/code&gt; 시스템 호출)는 목록이 아닌 문자열을 사용하며 실제로 해당 문자열을 개별 인수로 분할하려는 방법을 결정하는 것은 자식 프로세스에 달려 있습니다. C 언어는 &lt;code&gt;main()&lt;/code&gt; 이 인수 목록을 가져야한다고 지정하기 때문에 발생하는 &lt;em&gt;대부분의&lt;/em&gt; 프로그램은 Microsoft C / C ++ 런타임에서 사용하는 규칙을 따릅니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 및 따라서 Trio는 인수 시퀀스를 문자열로 변환 할 때 이러한 규칙을 사용 하며 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;문서화&lt;/a&gt; 됩니다.기준 치수. 해당 변환을 직접 수행 할 수있는 문서화 된 Python 표준 라이브러리 함수가 없으므로 Windows에서도 거의 항상 문자열이 아닌 인수 시퀀스를 전달하려고합니다. 그러나 생성중인 프로그램이 명령 줄을 표준 방식으로 개별 인수로 다시 분할하지 않으면이 문제를 해결하기 위해 문자열을 전달해야 할 수도 있습니다. (또는 당신은 운이 좋지 않을 수도 있습니다 : 내가 말할 수있는 한, 큰 따옴표가 포함 된 인수를 Windows 배치 파일에 전달하는 방법은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="93793d84cc2eab9e78702720d98d47b6401fa3b1" translate="yes" xml:space="preserve">
          <source>On a socket, this corresponds to &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; (&lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt;).</source>
          <target state="translated">소켓에서 이는 &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; ( &lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4577b2431790155ff289f03b1c114b916f176a26" translate="yes" xml:space="preserve">
          <source>On an SSL/TLS-encrypted connection, the protocol doesn&amp;rsquo;t provide any way to do a unidirectional shutdown without closing the connection entirely, so &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">있도록 SSL / TLS 암호화 연결에서 프로토콜은 완전히 연결을 닫지 않고 단방향 종료를 할 수있는 방법을 제공하지 않습니다 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 이&lt;/a&gt; 구현 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 하지 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d03a8ca5007fa469f6d5b1b6ccd1bc31dfaeda2f" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the producer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="translated">평균적으로 생산자는 초당 10 개의 메시지를 보내지 만 소비자 는 초당 한 번만 전화를 &lt;code&gt;receive&lt;/code&gt; . 즉, 채널의 내부 버퍼는 추가로 9 개의 항목을 보유하도록 커져야합니다. 1 분 후 버퍼에 ~ 540 개의 항목이 있습니다. 한 시간 후, ~ 32,400으로 증가합니다. 결국 프로그램의 메모리가 부족합니다. 또한 메모리가 부족하기 전에 개별 메시지를 처리하는 데 걸리는 지연 시간이 심해집니다. 예를 들어, 1 분 표시에서 생산자는 ~ 600 메시지를 보내고 있지만 생산자는 ~ 60 메시지를 처리하고 있습니다. 메시지 600은 소비자가 따라 잡고 처리하기 전에 ~ 9 분 동안 채널에 앉아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="99d0a83dc0fc994fcf4f4fc337ee0f9989b01cda" translate="yes" xml:space="preserve">
          <source>On the path where we do end up blocking, we don&amp;rsquo;t pass through any schedule points before that, which avoids some unnecessary work.</source>
          <target state="translated">우리가 블로킹을 끝내는 경로에서는 그 이전의 일정 지점을 통과하지 않으므로 불필요한 작업을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ab0a659811c28a2e762a50d54ab27494f7938a1" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; object is constructed, it implements the full &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. In addition, it provides a few extra features:</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 객체가 생성 되면 전체 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 또한 몇 가지 추가 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a64c9326dd46aad109181cb7ab1c383a9bdc1d7f" translate="yes" xml:space="preserve">
          <source>Once all the tasks have finished, then:</source>
          <target state="translated">모든 작업이 완료되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c45afa168e0caa5cc229264e1df9c6831e79c284" translate="yes" xml:space="preserve">
          <source>Once this method completes, any other pending or future operations on this resource should generally raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;, unless there&amp;rsquo;s a good reason to do otherwise.</source>
          <target state="translated">이 메소드가 완료되면 (자), 다른 이유가없는 한, 이 자원에 대한 다른 보류 중 또는 향후의 조작은 일반적으로 &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c7df89ffd2d387f5d5beed48542e820db53c87" translate="yes" xml:space="preserve">
          <source>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one &amp;hellip; until we&amp;rsquo;ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it&amp;rsquo;s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</source>
          <target state="translated">한 가지 방법은 첫 번째 방법으로 연결을 시도한 다음 실패하면 두 번째 방법으로 연결을 시도하는 것입니다. 모든 방법을 시도 할 때까지. 그러나 이것의 문제점은 첫 번째 IP 주소에 도달 할 수없는 경우 (예를 들어, IPv6 주소이고 네트워크가 IPv6 패킷을 버림), 첫 번째 연결 시도가 시간 초과 될 때까지 수십 초 동안 기다릴 수 있다는 것입니다. 두 번째 주소</target>
        </trans-unit>
        <trans-unit id="17218738b7f51d71e3bf8c24ea0d43906f5453a7" translate="yes" xml:space="preserve">
          <source>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can&amp;rsquo;t possibly complete in the available time. Another example would be if you&amp;rsquo;re using a protocol like gRPC that &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;propagates timeout information to the remote peer&lt;/a&gt;; this function gives a way to fetch that information so you can send it along.</source>
          <target state="translated">이것이 유용한 곳의 한 가지 예는 코드가 RPC 호출과 같이 값 비싼 작업을 시작할지 여부를 결정하려고하지만 사용 가능한 시간 내에 완료 할 수없는 것으로 알고 있으면 건너 뛰려는 경우입니다. 다른 예는 &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;시간 제한 정보를 원격 피어에 전파하는&lt;/a&gt; gRPC와 같은 프로토콜을 사용하는 경우입니다 . 이 함수는 정보를 가져 와서 보낼 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a0c0d7674af6ab050c1ac2ce111af25d5586750b" translate="yes" xml:space="preserve">
          <source>One of Trio&amp;rsquo;s core design principles is: &lt;em&gt;no implicit concurrency&lt;/em&gt;. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next &amp;ndash; &lt;em&gt;like Guido intended&lt;/em&gt;.</source>
          <target state="translated">Trio의 핵심 설계 원칙 중 하나는 다음과 같습니다 . &lt;em&gt;암시 적 동시성 없음&lt;/em&gt; . 모든 기능은 간단하고 위에서 아래로 실행되며 &lt;em&gt;Guido 의도와 같이&lt;/em&gt; 다음 작업으로 넘어 가기 전에 각 작업을 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="c5258410fd1961814ad646a55d204ab7988e49b2" translate="yes" xml:space="preserve">
          <source>One option would be to use a regular &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, and wrap it around every interaction with the state machine:</source>
          <target state="translated">한 가지 옵션은 일반 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 을 사용 하고 상태 시스템과의 모든 상호 작용을 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e644ae43ba1462c7a0943dedaacaa1f10e95eff" translate="yes" xml:space="preserve">
          <source>One particularly challenging problem when testing network protocols is making sure that your implementation can handle data whose flow gets broken up in weird ways and arrives with weird timings: localhost connections tend to be much better behaved than real networks, so if you only test on localhost then you might get bitten later. To help you out, Trio provides some fully in-memory implementations of the stream interfaces (see &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;The abstract Stream API&lt;/a&gt;), that let you write all kinds of interestingly evil tests.</source>
          <target state="translated">네트워크 프로토콜을 테스트 할 때 특히 어려운 문제 중 하나는 구현에서 흐름이 이상한 방식으로 분류되고 이상한 타이밍으로 도착하는 데이터를 처리 할 수 ​​있는지 확인하는 것입니다. 로컬 호스트 연결은 실제 네트워크보다 훨씬 더 나은 경향이 있으므로 로컬 호스트에서만 테스트하는 경우 나중에 물릴 수도 있습니다. 도움을주기 위해 Trio는 스트림 인터페이스의 완전히 메모리 내 구현을 제공합니다 ( &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;추상 스트림 API&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="70024abc1516890206e396c0d84ab876e9506524" translate="yes" xml:space="preserve">
          <source>One thing to remember, though: cancel scopes are inherited from the nursery, &lt;strong&gt;not&lt;/strong&gt; from the task that calls &lt;code&gt;start_soon&lt;/code&gt;. So in this example, the timeout does &lt;em&gt;not&lt;/em&gt; apply to &lt;code&gt;child&lt;/code&gt; (or to anything else):</source>
          <target state="translated">그러나 기억해야 할 것은 취소 범위는 &lt;code&gt;start_soon&lt;/code&gt; 을 호출하는 작업이 &lt;strong&gt;아니라&lt;/strong&gt; 보육원에서 상속 한다는 것 입니다. 따라서이 예에서 시간 초과는 &lt;code&gt;child&lt;/code&gt; (또는 다른 것)에 적용 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="beaeb02751f65d3130fef8613eaa9d036b7b827d" translate="yes" xml:space="preserve">
          <source>Open a channel for passing objects between tasks within a process.</source>
          <target state="translated">프로세스 내 작업간에 개체를 전달하기위한 채널을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="6c62e1a69d21a32a529448d3d8f35daada8a1b66" translate="yes" xml:space="preserve">
          <source>Open the file pointed by this path and return a file object, as the built-in open() function does.</source>
          <target state="translated">이 경로가 가리키는 파일을 열고 내장 open () 함수와 같이 파일 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5fe1c3751280d80986615a66056be1dd51489" translate="yes" xml:space="preserve">
          <source>Opens a connection to the specified &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix domain socket&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix 도메인 소켓에&lt;/a&gt; 대한 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="1901a0e40a967eefcb6e5dd3df1c5f153c15dbb3" translate="yes" xml:space="preserve">
          <source>Options for starting subprocesses</source>
          <target state="translated">서브 프로세스 시작 옵션</target>
        </trans-unit>
        <trans-unit id="efe8c1c73352ea2ed8175b8de72fc761dd83142c" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 . 이것은 현재 작업을 취소 할 수 없으며 &quot;누군가&quot;가 결국 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 호출해야한다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="456165d8c54895fc6bd4ac3bf65c943f1ea85b80" translate="yes" xml:space="preserve">
          <source>Otherwise, returns a new &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">그렇지 않으면 새로운 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; 를&lt;/a&gt; 반환합니다 객체를 합니다.</target>
        </trans-unit>
        <trans-unit id="9ee75f95c72ccfd62a03a7e39dba3cd64ff33ea2" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="translated">우리의 &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;취소 의미는&lt;/a&gt; 말 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 작업이 발생하지 않은 경우에만 제기해야합니다. 조기 종료 지점에서 &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 를 사용하면 이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db19939314aaad6d5ce1f4bdae93a6396ba0d3a" translate="yes" xml:space="preserve">
          <source>Our Pledge</source>
          <target state="translated">우리의 서약</target>
        </trans-unit>
        <trans-unit id="25e4d03f4e76d2bf2914327a45498edc72df108f" translate="yes" xml:space="preserve">
          <source>Our Standards</source>
          <target state="translated">우리의 기준</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4f2f5f60cf5ac63db9da317a29551d539455d423" translate="yes" xml:space="preserve">
          <source>Overview: abstract base classes for I/O</source>
          <target state="translated">개요 : I / O에 대한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="08f9f24653915627b70d1df0f7d09b16a85dfbbf" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt; &lt;code&gt;unpark()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt; &lt;code&gt;unpark_all()&lt;/code&gt; &lt;/a&gt; 호출로 깨어날 때까지 현재 작업을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="82d438cd7980583075141b24e8673a9713c1bf85" translate="yes" xml:space="preserve">
          <source>Partial exception for async context managers: Both the entry and exit of an &lt;code&gt;async with&lt;/code&gt; block are defined as async functions; but for a particular type of async context manager, it&amp;rsquo;s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</source>
          <target state="translated">비동기 컨텍스트 관리자에 대한 부분 예외 : 블록이 있는 &lt;code&gt;async with&lt;/code&gt; 의 시작과 종료는 모두 비동기 함수로 정의됩니다. 그러나 특정 유형의 비동기 컨텍스트 관리자의 경우 하나만 차단할 수있는 경우가 종종 있습니다. 즉, 하나만 체크 포인트로 작동합니다. 이것은 사례별로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="5a267b39a5eff3913f1dc319a58ba6d62432a28c" translate="yes" xml:space="preserve">
          <source>Pass a keyword argument, &lt;code&gt;trio_token&lt;/code&gt; specifiying a specific &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to re-enter. This is useful in case you have a &amp;ldquo;foreign&amp;rdquo; thread, spawned using some other framework, and still want to enter Trio.</source>
          <target state="translated">키워드 인수에 전달 &lt;code&gt;trio_token&lt;/code&gt; 특정의 specifiying &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 의&lt;/a&gt; 에 루프를 재 입력합니다. 이 기능은 다른 프레임 워크를 사용하여 생성 된 &quot;외부&quot;스레드가 있고 여전히 트리오를 입력하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1aa5a7ccff5d4f3757f85c40b5dbca2bf8a5358c" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task for the given number of seconds.</source>
          <target state="translated">주어진 시간 (초) 동안 현재 작업 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="792724ee650d41a2261ab590c3c964ec9b82bf03" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task forever (or until cancelled).</source>
          <target state="translated">현재 작업의 실행을 영원히 일시 중지합니다 (또는 취소 할 때까지).</target>
        </trans-unit>
        <trans-unit id="63447823632f8be015880571aa87f00f9ebeabb5" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task until the given time.</source>
          <target state="translated">주어진 시간까지 현재 작업의 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="b7f07d2b14f04bdac99308eaf26585e7e40b3547" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom half-closeable stream implementation.</source>
          <target state="translated">사용자 정의 반 폐쇄 가능 스트림 구현에 대해 여러 일반 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c295fcaa1b20aada89b1b40cd2fbdfb23ce8e370" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom one-way stream implementation.</source>
          <target state="translated">사용자 지정 단방향 스트림 구현에서 여러 가지 일반 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7a62317ddba72606ceef522c1b86d0d79ca09d82" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom two-way stream implementation.</source>
          <target state="translated">사용자 지정 양방향 스트림 구현에 대해 여러 가지 일반적인 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="42ff50b294fd4232d4b5ff341053088b57eb97c3" translate="yes" xml:space="preserve">
          <source>Permanently detach the current task from the Trio scheduler.</source>
          <target state="translated">현재 작업을 Trio 스케줄러에서 영구적으로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="f58fe36afb47440251499a789d28dbf3bd14b5c4" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="translated">개인적으로, 이벤트와 채널은 일반적으로 내가 관심을 갖는 대부분의 것을 구현하기에 충분하며이 섹션에서 논의 된 하위 레벨 프리미티브보다 코드를 더 쉽게 읽을 수 있습니다. 그러나 필요한 경우 여기에 있습니다. (새로운 상위 수준의 동기화 프리미티브를 구현하려고하기 때문에 이러한 목표에 도달하면 트리오의 기본 동기화 로직에 대한 직접적인 노출을 위해 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 의 기능을 확인할 수도 있습니다 . 이 섹션에서 논의되는 클래스는 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 의 공개 API 위에 구현 되며 Trio의 내부에 대한 특별한 액세스 권한은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="ffdc860af184791cfe1b4e1db983700a5c5843f4" translate="yes" xml:space="preserve">
          <source>Places the given data into the object&amp;rsquo;s internal buffer, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">지정된 데이터를 객체의 내부 버퍼에 넣은 다음 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; (있는 경우) 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ca1fe734f90a81230ee63ca0ea8ac678831e87" translate="yes" xml:space="preserve">
          <source>Preparing a release</source>
          <target state="translated">릴리즈 준비</target>
        </trans-unit>
        <trans-unit id="5020bb795052d80ec813c6028081ba9c1df6120b" translate="yes" xml:space="preserve">
          <source>Preparing pull requests</source>
          <target state="translated">풀 요청 준비</target>
        </trans-unit>
        <trans-unit id="f302fc4ed754d1fbfb349262f16252b92e3cc560" translate="yes" xml:space="preserve">
          <source>Pretty much any code you write using Trio needs to have some strategy to handle &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions &amp;ndash; even if you didn&amp;rsquo;t set a timeout, then your caller might (and probably will).</source>
          <target state="translated">Trio를 사용하여 작성하는 거의 모든 코드에는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 처리 할 전략이 있어야 합니다. 시간 초과를 설정하지 않더라도 호출자는 그럴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af578c673cdef9a60b45069a7ffe307c6ff638e0" translate="yes" xml:space="preserve">
          <source>Prioritization Only Works When There&amp;rsquo;s Pending Data to Prioritize</source>
          <target state="translated">우선 순위는 우선 순위를 정하기 위해 보류중인 데이터가있는 경우에만 작동합니다</target>
        </trans-unit>
        <trans-unit id="c58c7b026eae377fda9c29eb4891a26769146297" translate="yes" xml:space="preserve">
          <source>Pro-tip: you can insert sleep calls (like in our example above) to manipulate the flow of data across tasks&amp;hellip; and then use &lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;MockClock&lt;/code&gt;&lt;/a&gt; and its &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; functionality to keep your test suite running quickly.</source>
          <target state="translated">전문가 팁 : 작업 전체에서 데이터 흐름을 조작하기 위해 휴면 호출 (예 : 위의 예)을 삽입 한 다음 &lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;MockClock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 테스트 스위트를 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cd9481f2b9c8a87285e30103998d87e6b076b4" translate="yes" xml:space="preserve">
          <source>Providing support</source>
          <target state="translated">지원 제공</target>
        </trans-unit>
        <trans-unit id="c61469d5112d29c4d7b6879f0a1409fe87006118" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에 토큰을 다시 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="e2750887dc705834ea27dfee8c5fa086a70d9316" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack.</source>
          <target state="translated">자루에 토큰을 다시 넣습니다.</target>
        </trans-unit>
        <trans-unit id="a3400133bd460916e5852bc1b4deaf18a2290d3e" translate="yes" xml:space="preserve">
          <source>Put the current task to sleep, with cancellation support.</source>
          <target state="translated">취소 지원을 통해 현재 작업을 잠자기 상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ef10b7926486af74ce7f9c3ed42b7e35c433287a" translate="yes" xml:space="preserve">
          <source>Putting blocking I/O into worker threads</source>
          <target state="translated">작업자 스레드에 I / O 차단</target>
        </trans-unit>
        <trans-unit id="0e3da495154b52a5558a5ade984baaf547b2ab19" translate="yes" xml:space="preserve">
          <source>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea &amp;ndash; if you add 100 &amp;micro;s of overhead to a 1 &amp;micro;s operation, then that&amp;rsquo;s a 100x slowdown! On the other hand, if your data&amp;rsquo;s on a spinning disk, then using a thread is &lt;em&gt;great&lt;/em&gt; &amp;ndash; instead of blocking the main thread and all tasks for 10,000 &amp;micro;s, we only block them for 100 &amp;micro;s and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</source>
          <target state="translated">데이터 정리 : 데이터가 RAM에 있다면 스레드를 사용하는 것이 끔찍한 아이디어라는 것이 분명합니다. 1&amp;micro;s 연산에 100&amp;micro;s의 오버 헤드를 추가하면 100 배 속도가 느려집니다! 반면에 데이터가 회전하는 디스크에있는 경우 스레드를 사용하는 것이 &lt;em&gt;좋습니다&lt;/em&gt; . 기본 스레드와 모든 작업을 10,000 &amp;micro;s 동안 차단하는 대신 100 &amp;micro;s 동안 만 차단하고 나머지 시간을 다른 시간 동안 실행할 수 있습니다. 유용한 작업을 수행 할 수있는 작업으로 사실상 100 배 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa77250d0ce1f733a13fed899dc4e3331be06f66" translate="yes" xml:space="preserve">
          <source>Quoting: more than you wanted to know</source>
          <target state="translated">인용 : 당신이 알고 싶은 것보다 더</target>
        </trans-unit>
        <trans-unit id="31385a56c42dea75b0abfee3d065ac3faad4e1e6" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt; if the timeout expires.</source>
          <target state="translated">시간 초과가 만료되면 &lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; 의해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ec13ded90b55c99ffb9020ca292f5ffb665682a1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run&lt;/code&gt;&lt;/a&gt; and similar functions if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already finished.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 해당 호출 이 이미 완료된 경우 &lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run&lt;/code&gt; &lt;/a&gt; 및 유사한 함수에 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b9a61e9f5e58cb8abe086249f57467b310df32e1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="translated">Trio에서 버그가 발생하거나 저수준 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; API 중 하나가 잘못 사용 된 경우 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8913ddb4486c40268daf092227991759027600a9" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;X_nowait&lt;/code&gt; functions if &lt;code&gt;X&lt;/code&gt; would block.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 가 차단 되면 &lt;code&gt;X_nowait&lt;/code&gt; 함수에 의해 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="f210751ec099645a40a15f671e5b2c8300437cce" translate="yes" xml:space="preserve">
          <source>Raised by blocking calls if the surrounding scope has been cancelled.</source>
          <target state="translated">주변 범위가 취소 된 경우 통화를 차단하여 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f507b1f0875891aee3cdb80c4efd15c0b85e4cb" translate="yes" xml:space="preserve">
          <source>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</source>
          <target state="translated">작업이 다른 작업에서 이미 사용중인 리소스를 사용하려고하면 발생하며 이로 인해 버그가 발생하고 말이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8678ba88e13f646dadb26c39c02dc28761beb10" translate="yes" xml:space="preserve">
          <source>Raised when an attempt to use a resource fails due to external circumstances.</source>
          <target state="translated">외부 환경으로 인해 리소스 사용 시도가 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="812be58660608d36377923c7fc9cb3158c9268d0" translate="yes" xml:space="preserve">
          <source>Raised when attempting to use a resource after it has been closed.</source>
          <target state="translated">리소스를 닫은 후 리소스를 사용하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e09a1bdfa7a2f8848cd0c16df3025ec969cf49ad" translate="yes" xml:space="preserve">
          <source>Raised when trying to receive from a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt; that has no more data to receive.</source>
          <target state="translated">더 이상 수신 할 데이터가없는 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt; 에서 수신하려고 할 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="f3b46f6055aeafb16858767d1f89c1b6e9dfb653" translate="yes" xml:space="preserve">
          <source>Raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; means that the operation &lt;em&gt;did not happen&lt;/em&gt;. If a Trio socket&amp;rsquo;s &lt;code&gt;send&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, then no data was sent. If a Trio socket&amp;rsquo;s &lt;code&gt;recv&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; then no data was lost &amp;ndash; it&amp;rsquo;s still sitting in the socket receive buffer waiting for you to call &lt;code&gt;recv&lt;/code&gt; again. And so forth.</source>
          <target state="translated">올리기 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 작업이 있음을 의미 &lt;em&gt;일어나지 않았다을&lt;/em&gt; . Trio 소켓의 &lt;code&gt;send&lt;/code&gt; 메소드가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 데이터가 전송되지 않은 것입니다. Trio 소켓의 &lt;code&gt;recv&lt;/code&gt; 메소드가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 취소 하면 데이터가 손실되지 않습니다. 여전히 &lt;code&gt;recv&lt;/code&gt; 를 다시 호출하기를 기다리는 소켓 수신 버퍼에 있습니다 . 기타 등등.</target>
        </trans-unit>
        <trans-unit id="99957346670542dddfd38b8ffe66adc228aa621a" translate="yes" xml:space="preserve">
          <source>Read some data from the underlying transport, decrypt it, and return it.</source>
          <target state="translated">기본 전송에서 일부 데이터를 읽고 해독 한 후 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="622b17203422ddf9aae4a69b56f076465c09ce46" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, default &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. So long as this is set to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then the code inside this scope will not receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from scopes that are outside this scope. They can still receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</source>
          <target state="translated">읽기 - 쓰기, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; , 기본 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; . 이것이 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 로 설정 되어있는 한이 범위 내의 코드 는이 범위 밖의 범위에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 받지 않습니다 . (1)이 범위 또는 (2)이 범위 내의 범위에서 여전히 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 수신 할 수 있습니다 . 이 속성을 수정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="41af808d2970aab6923b6bc6b45b747b999598be" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. An absolute time on the current run&amp;rsquo;s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</source>
          <target state="translated">읽기 - 쓰기, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 이 스코프가 자동으로 취소되는 현재 런 시계의 절대 시간. 이 속성을 수정하여 최종 기한을 조정할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="458a6d137741ae6f23c3a174667c35e2505c63ff" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether cancellation has been requested for this scope, either by an explicit call to &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; or by the deadline expiring.</source>
          <target state="translated">읽기 전용 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 에 대한 명시 적 호출 또는 최종 기한 만료에 의해이 범위에 대한 취소가 요청되었는지를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="988a546c2b4be4f19c6512e225ed82a3331a45e3" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. This requires two things: (1) the &lt;code&gt;with&lt;/code&gt; block exited with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, and (2) this scope is the one that was responsible for triggering this &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">읽기 전용 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . 이 범위가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 잡았는지 여부를 기록합니다 . 이를 위해서는 (1) &lt;code&gt;with&lt;/code&gt; 블록이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외로 종료 되고 (2)이 범위가이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 트리거 한 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="7c5c60d4ed263e6221b1ceafb46f52538e92cf77" translate="yes" xml:space="preserve">
          <source>Real-time chat: &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</source>
          <target state="translated">실시간 채팅 : &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b67be12710ea8d6de91ade39424c9d45cc879ca" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt; &lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt; &lt;/a&gt; 사용하여 분리 된 코 루틴 객체를 다시 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b2f36e5ce6c6da01323540a9b37cff6c1903ffd" translate="yes" xml:space="preserve">
          <source>Regardless of these shenanigans, from &amp;ldquo;inside&amp;rdquo; Trio the passage of time still seems normal so long as you restrict yourself to Trio&amp;rsquo;s time functions (see &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Time and clocks&lt;/a&gt;). Below is an example demonstrating two different ways of making time pass quickly. Notice how in both cases, the two tasks keep a consistent view of reality and events happen in the expected order, despite being wildly divorced from real time:</source>
          <target state="translated">이러한 shenanigans에 관계없이&amp;ldquo;내부&amp;rdquo;Trio에서 시간의 흐름은 사용자가 Trio의 시간 함수 ( &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;시간 및 시계&lt;/a&gt; 참조)로 제한되는 한 여전히 정상적인 것처럼 보입니다 . 아래는 시간이 빨리 지나가는 두 가지 방법을 보여주는 예입니다. 두 경우 모두 두 가지 작업이 어떻게 현실과 일관된 시각을 유지하고 실시간에서 크게 이혼하더라도 이벤트가 예상 순서대로 발생하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="795fd0408cfdff7a235327985444734ec64c8053" translate="yes" xml:space="preserve">
          <source>Regular (synchronous) functions never contain any checkpoints.</source>
          <target state="translated">일반 (동기식) 기능에는 검사 점이 절대 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5044ba0a5cf607ebea4e58623c6417cb87f682bb" translate="yes" xml:space="preserve">
          <source>Release history</source>
          <target state="translated">출시 역사</target>
        </trans-unit>
        <trans-unit id="b5e4913e6b00fb0411556eedb8df5d4e15248e9e" translate="yes" xml:space="preserve">
          <source>Release the lock.</source>
          <target state="translated">잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="dfdddac609bc6525864a46420d173e2db58b56da" translate="yes" xml:space="preserve">
          <source>Release the underlying lock.</source>
          <target state="translated">기본 잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="7416201cbf641c4c1cce64a7552e96979b9781a3" translate="yes" xml:space="preserve">
          <source>Represents a stream given the file descriptor to a pipe, TTY, etc.</source>
          <target state="translated">파이프, TTY 등에 파일 디스크립터가 제공된 스트림을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffed6ffb11cd49ae283b146510b560db62b29b16" translate="yes" xml:space="preserve">
          <source>Reschedule the given task with the given &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진으로 주어진 작업 일정 변경 &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b80f008c17db60050b84c4982691f26b5d7ebd4" translate="yes" xml:space="preserve">
          <source>Resource handling:</source>
          <target state="translated">자원 처리 :</target>
        </trans-unit>
        <trans-unit id="f49ed1f90b5319324c89fc4cdc67d98d1d4982c1" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 대한 현재 호출에 대한 &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 을 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="36c54ed6ac80bc981ae8ce5652b7aa7a424a0fb5" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">내부 버퍼에서 데이터를 검색하여 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="080bc476ce5968af592b5c6db511e128987c5764" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, but doesn&amp;rsquo;t block.</source>
          <target state="translated">내부 버퍼에서 데이터를 검색하지만 차단하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e1a7dbd8e538a02d36f4201744cfd7c212b56c8" translate="yes" xml:space="preserve">
          <source>Return True if the path contains one of the special names reserved by the system, if any.</source>
          <target state="translated">경로에 시스템이 예약 한 특수 이름 중 하나가 있으면 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="2b7de1c01e3639d70c1301781596a03564716748" translate="yes" xml:space="preserve">
          <source>Return True if this path matches the given pattern.</source>
          <target state="translated">이 패스가 지정된 패턴과 일치하면 True를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2c683d81b2e6785afd626708cbea723554ad9f98" translate="yes" xml:space="preserve">
          <source>Return a context manager that catches and re-throws exceptions after running &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; on them.</source>
          <target state="translated">&lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 를 실행 한 후 예외를 포착하고 다시 발생시키는 컨텍스트 관리자를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="74511c6068e3de9f3c1e1c2e39a44b3f12a40aef" translate="yes" xml:space="preserve">
          <source>Return a new path with the file name changed.</source>
          <target state="translated">파일 이름이 변경된 새 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="a4759abd8edb019bf0eb31c08f831d77c495f661" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed (or added, if none).</source>
          <target state="translated">파일 접미사가 변경되었거나없는 경우 추가 된 새 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ce261ae05a052a4b5be129bb11ccb492e6a1503" translate="yes" xml:space="preserve">
          <source>Return an object containing debugging information.</source>
          <target state="translated">디버깅 정보가 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e2277903dc895b3ac624e58f32470f044f28fb7" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="translated">현재 작업을 나타내는 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="40cff98535909e183f92699de8527946109d976c" translate="yes" xml:space="preserve">
          <source>Return the current time, according to this clock.</source>
          <target state="translated">이 시계에 따라 현재 시간을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b9db5a47ba6655c11616c8e26b190ca54f43e5a1" translate="yes" xml:space="preserve">
          <source>Return the current value of the internal flag.</source>
          <target state="translated">내부 플래그의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6de731f34f98b206fa3aeb0d1060258ec569f0dd" translate="yes" xml:space="preserve">
          <source>Return the path as a &amp;lsquo;file&amp;rsquo; URI.</source>
          <target state="translated">경로를 '파일'URI로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b492c123430d5d95ccde60278f71b4c1ea4e2eec" translate="yes" xml:space="preserve">
          <source>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</source>
          <target state="translated">전달 된 인수로 식별 된 다른 경로의 상대 경로를 리턴하십시오. 작업이 불가능한 경우 (이 경로는 다른 경로의 하위 경로가 아니기 때문에) ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8aff8be4dee4d25bccba9aa66ee0802992b16399" translate="yes" xml:space="preserve">
          <source>Return the string representation of the path with forward (/) slashes.</source>
          <target state="translated">슬래시 (/)를 사용하여 경로의 문자열 표현을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">반품 유형</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="c96e2a604937c0e7bde09850d1e81c88f183872e" translate="yes" xml:space="preserve">
          <source>Returns an async context manager which must be used to create a new &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용해야하는 비동기 컨텍스트 관리자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="80c3bba28aba9ac5aa2b9e543b569c7c5f7fea4f" translate="yes" xml:space="preserve">
          <source>Returns an object containing run-loop-level debugging information.</source>
          <target state="translated">실행 루프 수준 디버깅 정보가 포함 된 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2cb60cb3bef90903444e5b5db55efe97c53982f7" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</source>
          <target state="translated">주어진 함수가 리턴하거나 올린 것을 리턴하거나 올립니다. 또한 자체 예외를 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa20168c5bc2ca247ebd21af6add01da22b9fffa" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</source>
          <target state="translated">새로운 코 루틴 러너가 코 루틴을 재개하기 위해 사용하는 모든 값 또는 예외를 반환하거나 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="20294a5b79e17adf4e2aab73007106887f91c20b" translate="yes" xml:space="preserve">
          <source>Returns the current &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="679a2125dd0230bf3c09de4ff94a0c29225879ae" translate="yes" xml:space="preserve">
          <source>Returns the current effective deadline for the current task.</source>
          <target state="translated">현재 작업에 대한 현재 유효 마감 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49f9754b2c2c4e3016fdc4a20e1aa41028fdabce" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 루트 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3612705c9bdde6883ff6d46dc9b98bfbf29c4eae" translate="yes" xml:space="preserve">
          <source>Returns the current time according to Trio&amp;rsquo;s internal clock.</source>
          <target state="translated">Trio의 내부 시계에 따라 현재 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e44dffb19df07ef8414c3c376c6a86a1a10a965c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;command&lt;/code&gt; in a subprocess, wait for it to complete, and return a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the results.</source>
          <target state="translated">서브 프로세스에서 &lt;code&gt;command&lt;/code&gt; 을 실행 하고 완료 될 때까지 기다린 후 결과를 설명 하는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b56c81b5d7d12e057ce71207675707f4d4076b3" translate="yes" xml:space="preserve">
          <source>Run a Trio-flavored async function, and return the result.</source>
          <target state="translated">Trio 풍미가있는 비동기 함수를 실행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="174632bdc2efcc209e6ec485f5e4d89bb42f99f2" translate="yes" xml:space="preserve">
          <source>Run the given async function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">부모 트리오 스레드에서 지정된 비동기 기능을 실행하여 완료 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="28b11b8b05a27dee7e81c6c4786ce2373923cc39" translate="yes" xml:space="preserve">
          <source>Run the given sync function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">주어진 동기화 기능을 상위 Trio 스레드에서 실행하고 완료 될 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="34ee226c47ee6762c22038b1355ef784957e69c9" translate="yes" xml:space="preserve">
          <source>Running a process and waiting for it to finish</source>
          <target state="translated">프로세스 실행 및 완료 대기</target>
        </trans-unit>
        <trans-unit id="28b93c4a93cb10440b0c2043a668f9b2550390d8" translate="yes" xml:space="preserve">
          <source>SSL / TLS support</source>
          <target state="translated">SSL / TLS 지원</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
