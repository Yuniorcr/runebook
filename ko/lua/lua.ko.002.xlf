<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="77c0c811e0708693f332c243247f1f4509702b82" translate="yes" xml:space="preserve">
          <source>Returns the current hook mask.</source>
          <target state="translated">현재 후크 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfa58fd57235ee80a6d63769d911723e3534cac8" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="translated">스레드의 현재 후크 설정을 현재 후크 함수, 현재 후크 마스크 및 현재 후크 수 ( &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; 함수에 의해 설정 됨)의 세 가지 값으로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a4984b9b007c5eee4f424cfbc9e8ac599f7bc3b2" translate="yes" xml:space="preserve">
          <source>Returns the current time when called without arguments, or a time representing the local date and time specified by the given table. This table must have fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;, and may have fields &lt;code&gt;hour&lt;/code&gt; (default is 12), &lt;code&gt;min&lt;/code&gt; (default is 0), &lt;code&gt;sec&lt;/code&gt; (default is 0), and &lt;code&gt;isdst&lt;/code&gt; (default is &lt;b&gt;nil&lt;/b&gt;). Other fields are ignored. For a description of these fields, see the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">인수없이 호출 된 현재 시간 또는 제공된 테이블에 지정된 현지 날짜 및 시간을 나타내는 시간을 반환합니다. 이 테이블에는 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 필드가 있어야하며 &lt;code&gt;hour&lt;/code&gt; (기본값은 12), &lt;code&gt;min&lt;/code&gt; (기본값은 0), &lt;code&gt;sec&lt;/code&gt; (기본값은 0) 및 &lt;code&gt;isdst&lt;/code&gt; (기본값은 &lt;b&gt;nil&lt;/b&gt; ) 필드가있을 수 있습니다. 다른 필드는 무시됩니다. 이 필드에 대한 설명은 &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b56d9d3e264bf539db578bb8f6317e05525f18e" translate="yes" xml:space="preserve">
          <source>Returns the destination table &lt;code&gt;a2&lt;/code&gt;.</source>
          <target state="translated">대상 테이블 &lt;code&gt;a2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4a89ca3dbaee05fa9562365bbb11bd2987b8b36f" translate="yes" xml:space="preserve">
          <source>Returns the difference, in seconds, from time &lt;code&gt;t1&lt;/code&gt; to time &lt;code&gt;t2&lt;/code&gt; (where the times are values returned by &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt;). In POSIX, Windows, and some other systems, this value is exactly &lt;code&gt;t2&lt;/code&gt;&lt;em&gt;-&lt;/em&gt;&lt;code&gt;t1&lt;/code&gt;.</source>
          <target state="translated">시간 &lt;code&gt;t1&lt;/code&gt; 에서 시간 &lt;code&gt;t2&lt;/code&gt; 까지의 차이 (초)를 리턴합니다 (여기서 시간은 &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; 에서&lt;/a&gt; 리턴 한 값임 ). POSIX, Windows 및 일부 다른 시스템에서이 값은 정확히 &lt;code&gt;t2&lt;/code&gt; &lt;em&gt;- &lt;/em&gt; &lt;code&gt;t1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74ef8f0d43907d8993cbf07845e98c64309c4c57" translate="yes" xml:space="preserve">
          <source>Returns the elements from the given list. This function is equivalent to</source>
          <target state="translated">주어진 목록에서 요소를 반환합니다. 이 기능은</target>
        </trans-unit>
        <trans-unit id="a0ecb44d1768c16defe86a7226eb7cdb677c4d76" translate="yes" xml:space="preserve">
          <source>Returns the index of the top element in the stack. Because indices start at 1, this result is equal to the number of elements in the stack; in particular, 0 means an empty stack.</source>
          <target state="translated">스택에서 최상위 요소의 인덱스를 반환합니다. 인덱스는 1부터 시작하므로이 결과는 스택의 요소 수와 같습니다. 특히 0은 빈 스택을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aae1a98a2afe7e2f6164ed56d98f2c5601c177ce" translate="yes" xml:space="preserve">
          <source>Returns the integral part of &lt;code&gt;x&lt;/code&gt; and the fractional part of &lt;code&gt;x&lt;/code&gt;. Its second result is always a float.</source>
          <target state="translated">반환의 중요한 부분 &lt;code&gt;x&lt;/code&gt; 와의 소수 부분 &lt;code&gt;x&lt;/code&gt; . 두 번째 결과는 항상 부동입니다.</target>
        </trans-unit>
        <trans-unit id="d07d66699f96edb0b840ccb7b505ca206ea713f8" translate="yes" xml:space="preserve">
          <source>Returns the internal numeric codes of the characters &lt;code&gt;s[i]&lt;/code&gt;, &lt;code&gt;s[i+1]&lt;/code&gt;, ..., &lt;code&gt;s[j]&lt;/code&gt;. The default value for &lt;code&gt;i&lt;/code&gt; is 1; the default value for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. These indices are corrected following the same rules of function &lt;a href=&quot;#pdf-string.sub&quot;&gt;&lt;code&gt;string.sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자 &lt;code&gt;s[i]&lt;/code&gt; , &lt;code&gt;s[i+1]&lt;/code&gt; , ..., &lt;code&gt;s[j]&lt;/code&gt; 의 내부 숫자 코드를 리턴합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1입니다. &lt;code&gt;j&lt;/code&gt; 의 기본값 은 &lt;code&gt;i&lt;/code&gt; 입니다. 이 색인은 &lt;a href=&quot;#pdf-string.sub&quot;&gt; &lt;code&gt;string.sub&lt;/code&gt; &lt;/a&gt; 함수의 동일한 규칙에 따라 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="37a74944cfaba1cf96089aa04c3aab36bd768194" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value smaller than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 작거나 같은 가장 큰 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a82986faba63c6df7b4a7e1f2c3e8675bebec131" translate="yes" xml:space="preserve">
          <source>Returns the length of the object &lt;code&gt;v&lt;/code&gt;, which must be a table or a string, without invoking the &lt;code&gt;__len&lt;/code&gt; metamethod. Returns an integer.</source>
          <target state="translated">&lt;code&gt;__len&lt;/code&gt; 메타 메소드 를 호출하지 않고 테이블 &lt;code&gt;v&lt;/code&gt; 또는 문자열이어야 하는 오브젝트 v 의 길이를 리턴합니다 . 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d195539511c55ff9d09810f9cb9cabd46d5d2c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the value at the given index. It is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;) and may trigger a metamethod for the &quot;length&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). The result is pushed on the stack.</source>
          <target state="translated">주어진 인덱스에서 값의 길이를 반환합니다. 이는 Lua 의 ' &lt;code&gt;#&lt;/code&gt; '연산자 와 동일하며 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ) &quot;길이&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 결과는 스택에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca18490544ebe4ab9d2b88782ccfa4bfa597d5c6" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of &lt;code&gt;x&lt;/code&gt; in the given base. The default for &lt;code&gt;base&lt;/code&gt; is &lt;em&gt;e&lt;/em&gt; (so that the function returns the natural logarithm of &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">주어진 밑에서 &lt;code&gt;x&lt;/code&gt; 의 로그를 반환합니다 . &lt;code&gt;base&lt;/code&gt; 의 기본값 은 &lt;em&gt;e입니다&lt;/em&gt; (따라서 함수는 &lt;code&gt;x&lt;/code&gt; 의 자연 로그를 리턴합니다 ).</target>
        </trans-unit>
        <trans-unit id="d3cb57918cd0fd4016648ae402c7074bcd73a43b" translate="yes" xml:space="preserve">
          <source>Returns the memory-allocation function of a given state. If &lt;code&gt;ud&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, Lua stores in &lt;code&gt;*ud&lt;/code&gt; the opaque pointer given when the memory-allocator function was set.</source>
          <target state="translated">주어진 상태의 메모리 할당 함수를 반환합니다. &lt;code&gt;ud&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , Lua는 메모리 할당 기 기능을 설정할 때 제공된 불투명 포인터 를 &lt;code&gt;*ud&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="274b26f09340089c109b77fcaa34ab85c7b27be3" translate="yes" xml:space="preserve">
          <source>Returns the metatable of the given &lt;code&gt;value&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if it does not have a metatable.</source>
          <target state="translated">반환 주어진의 메타 테이블 &lt;code&gt;value&lt;/code&gt; 또는 &lt;b&gt;전무&lt;/b&gt; 그것은 메타 테이블이없는 경우.</target>
        </trans-unit>
        <trans-unit id="f827b993d336f39e4e067ba1cd00ca433786753f" translate="yes" xml:space="preserve">
          <source>Returns the name of the type encoded by the value &lt;code&gt;tp&lt;/code&gt;, which must be one the values returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값 &lt;code&gt;tp&lt;/code&gt; 로 인코딩 된 유형의 이름을 리턴합니다 . 이는 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; 이&lt;/a&gt; 리턴 한 값 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5d2c5467f6b31c133d151a482f437390192631a" translate="yes" xml:space="preserve">
          <source>Returns the name of the type of the value at the given index.</source>
          <target state="translated">주어진 색인에서 값의 유형 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="09f17fbeecb99d8ceed703c8e378ebf644bfa53e" translate="yes" xml:space="preserve">
          <source>Returns the new state, or &lt;code&gt;NULL&lt;/code&gt; if there is a memory allocation error.</source>
          <target state="translated">새 상태를 반환하거나 메모리 할당 오류가있는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1fac8d97901da4fcfa21c51273c8ade3e30d4960" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns a false value plus the position of the first invalid byte.</source>
          <target state="translated">위치 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 사이에서 시작하는 문자열 &lt;code&gt;s&lt;/code&gt; 의 UTF-8 문자 수 (둘 다 포함)를 리턴합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이고 &lt;code&gt;j&lt;/code&gt; 의 경우 -1입니다. 유효하지 않은 바이트 시퀀스를 찾으면 잘못된 값과 첫 번째 유효하지 않은 바이트의 위치를 ​​더한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56c4cc904851482307ead3085d1ccd1030454da6" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 문자 인코딩 (위치 &lt;code&gt;i&lt;/code&gt; 에서 계산 )이 시작 되는 위치 (바이트)를 리턴 합니다. 음수 &lt;code&gt;n&lt;/code&gt; 은 위치 &lt;code&gt;i&lt;/code&gt; 전에 문자를 가져 옵니다 . &lt;code&gt;n&lt;/code&gt; 이 음이 아닌 경우 &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1 이고 , 그렇지 않으면 &lt;code&gt;#s + 1&lt;/code&gt; 이므로 &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; 은 문자열 끝에서 &lt;code&gt;n&lt;/code&gt; 번째 문자 의 오프셋을 가져옵니다 . 지정된 문자가 주제에 없거나 종료 직후에 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc45c511f20e727c297897c4a412e04b9bb492de" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">실행중인 함수 의 &lt;code&gt;i&lt;/code&gt; 번째 업 값 을 나타내는 의사 인덱스를 반환합니다 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="39d8bb977f9b8a6f1742fd3f9dc45db22e1fcb68" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0.</source>
          <target state="translated">주어진 색인에서 값의 원시 &quot;길이&quot;를 반환합니다. 문자열의 경우 문자열 길이입니다. 테이블의 경우 이것은 메타 메소드가없는 길이 연산자 ( ' &lt;code&gt;#&lt;/code&gt; ') 의 결과입니다 . 사용자 데이터의 경우, 이는 사용자 데이터에 할당 된 메모리 블록의 크기입니다. 다른 값의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="a4878c08432faeac78e45f44f0026ebddb8749ef" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">레지스트리 테이블을 반환합니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1f182d1d0910847b92e9f446a7345b1cf7e93ffa" translate="yes" xml:space="preserve">
          <source>Returns the remainder of the division of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt; that rounds the quotient towards zero. (integer/float)</source>
          <target state="translated">몫을 0으로 반올림하여 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; 로 나눈 나머지를 반환합니다 . (정수 / 부동)</target>
        </trans-unit>
        <trans-unit id="7d00adfd429e9ecb79de1d7e05907584e1f561cc" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;nil&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">파일을 읽은 후 읽기 모드에서 열 수있는 첫 번째 파일의 결과 이름을 반환하거나 성공하지 못한 경우 &lt;b&gt;nil&lt;/b&gt; 과 오류 메시지를 반환합니다. 이 오류 메시지는 열려고 시도한 모든 파일 이름을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0cafeada936b9b3c536bfda3d7c114159746bc82" translate="yes" xml:space="preserve">
          <source>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</source>
          <target state="translated">실행중인 코 루틴과 부울 값을 반환합니다. 실행중인 코 루틴이 기본 항목 인 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="f520f4734dbc499082a5c134aebb7e5257b19210" translate="yes" xml:space="preserve">
          <source>Returns the sine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사인을 반환합니다 (라디안으로 가정).</target>
        </trans-unit>
        <trans-unit id="da558ef5afc0fc9c0d21911a38e825ff24dcf0a2" translate="yes" xml:space="preserve">
          <source>Returns the size of a string resulting from &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; with the given format. The format string cannot have the variable-length options '&lt;code&gt;s&lt;/code&gt;' or '&lt;code&gt;z&lt;/code&gt;' (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">주어진 형식으로 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; 에서 나오는 문자열의 크기를 반환 합니다. 형식 문자열은 가변 길이 옵션 ' &lt;code&gt;s&lt;/code&gt; '또는 ' &lt;code&gt;z&lt;/code&gt; '를 가질 수 없습니다 ( &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="33b392e0c4352ffea2f8586f23e071e85ca1ffec" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value larger than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 크거나 같은 가장 작은 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a156517157e4cb0343c49c32e737cf3b8fa30ca3" translate="yes" xml:space="preserve">
          <source>Returns the square root of &lt;code&gt;x&lt;/code&gt;. (You can also use the expression &lt;code&gt;x^0.5&lt;/code&gt; to compute this value.)</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 제곱근을 반환합니다 . &lt;code&gt;x^0.5&lt;/code&gt; 표현식 을 사용하여이 값을 계산할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c7a785497146b5964e3cfcb16d7bf24c7763b5" translate="yes" xml:space="preserve">
          <source>Returns the status of coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 의 상태를 문자열로 리턴합니다 . 코 루틴이 실행중인 경우 (즉, &lt;code&gt;status&lt;/code&gt; 라고 함 ) &lt;code&gt;&quot;running&quot;&lt;/code&gt; . &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; ( 코 루틴이 &lt;code&gt;yield&lt;/code&gt; 호출에 일시 중단 되었거나 아직 실행을 시작하지 않은 경우) 코 루틴이 활성이지만 실행되지 않는 경우 (즉, 다른 코 루틴을 재개 한 경우) &lt;code&gt;&quot;normal&quot;&lt;/code&gt; ; 그리고 &lt;code&gt;&quot;dead&quot;&lt;/code&gt; 코 루틴은 신체 기능을 완료 한 경우, 또는이 오류와 함께 중지합니다.</target>
        </trans-unit>
        <trans-unit id="6643f34f054d2169fc15059330c9797cabe4b0f8" translate="yes" xml:space="preserve">
          <source>Returns the status of the thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">스레드 &lt;code&gt;L&lt;/code&gt; 의 상태를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ce13df23b5d839e4a1b3c62a7a51b8e7083872ff" translate="yes" xml:space="preserve">
          <source>Returns the substring of &lt;code&gt;s&lt;/code&gt; that starts at &lt;code&gt;i&lt;/code&gt; and continues until &lt;code&gt;j&lt;/code&gt;; &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; can be negative. If &lt;code&gt;j&lt;/code&gt; is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; returns a prefix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (for a positive &lt;code&gt;i&lt;/code&gt;) returns a suffix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에서 시작하여 &lt;code&gt;j&lt;/code&gt; 까지 계속되는 &lt;code&gt;s&lt;/code&gt; 의 하위 문자열을 반환합니다 . &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 는 음수 일 수 있습니다. 경우 &lt;code&gt;j&lt;/code&gt; 부재하고,이어서,이를 (문자열 길이와 동일 함) -1과 동일한 것으로 가정한다. 특히, &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; 호출 은 길이가 &lt;code&gt;j&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 의 접두사를 리턴 하고 &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (양수 &lt;code&gt;i&lt;/code&gt; 의 경우 )는 길이가 &lt;code&gt;i&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 의 접미 부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0d879230a982638cb3037d087aec816766d1bff4" translate="yes" xml:space="preserve">
          <source>Returns the tangent of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 탄젠트를 반환합니다 (라디안으로 가정).</target>
        </trans-unit>
        <trans-unit id="aeb49cdc670f656ecf94cc356e8482541619f67b" translate="yes" xml:space="preserve">
          <source>Returns the type of its only argument, coded as a string. The possible results of this function are &quot;&lt;code&gt;nil&lt;/code&gt;&quot; (a string, not the value &lt;b&gt;nil&lt;/b&gt;), &quot;&lt;code&gt;number&lt;/code&gt;&quot;, &quot;&lt;code&gt;string&lt;/code&gt;&quot;, &quot;&lt;code&gt;boolean&lt;/code&gt;&quot;, &quot;&lt;code&gt;table&lt;/code&gt;&quot;, &quot;&lt;code&gt;function&lt;/code&gt;&quot;, &quot;&lt;code&gt;thread&lt;/code&gt;&quot;, and &quot;&lt;code&gt;userdata&lt;/code&gt;&quot;.</source>
          <target state="translated">문자열로 코딩 된 유일한 인수의 유형을 리턴합니다. 이 함수의 가능한 결과는 &quot; &lt;code&gt;nil&lt;/code&gt; &quot;(값 &lt;b&gt;nil이&lt;/b&gt; 아닌 문자열 ), &quot; &lt;code&gt;number&lt;/code&gt; &quot;, &quot; &lt;code&gt;string&lt;/code&gt; &quot;, &quot; &lt;code&gt;boolean&lt;/code&gt; &quot;, &quot; &lt;code&gt;table&lt;/code&gt; &quot;, &quot; &lt;code&gt;function&lt;/code&gt; &quot;, &quot; &lt;code&gt;thread&lt;/code&gt; &quot;및 &quot; &lt;code&gt;userdata&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b7cc3af32266285b487ea68c1fc6ffc164e146f6" translate="yes" xml:space="preserve">
          <source>Returns the type of the pushed value.</source>
          <target state="translated">푸시 된 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11efeaa1a0a1dad64efc60561b86e6d305ce3e58" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid (but acceptable) index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt; (0), &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 유효한 인덱스에서 값의 유형을 반환하거나 유효하지 않은 (허용 가능한) 인덱스에 대해서는 &lt;code&gt;LUA_TNONE&lt;/code&gt; 을 반환합니다 . 유형에 의해 반환 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; 가&lt;/a&gt; 정의되고있는 정수로 부호화 &lt;code&gt;lua.h&lt;/code&gt; : &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt; (0) &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c355c772b6a7cd3959fe3ff1b22ce6913ee6b493" translate="yes" xml:space="preserve">
          <source>Returns the value &lt;em&gt;e&lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; (where &lt;code&gt;e&lt;/code&gt; is the base of natural logarithms).</source>
          <target state="translated">&lt;em&gt;e &lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; 값을 리턴합니다 (여기서 &lt;code&gt;e&lt;/code&gt; 는 자연 로그의 기초입니다).</target>
        </trans-unit>
        <trans-unit id="a1f640b6a2396fe00ff3c46e513b55ada5898623" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt;, or &lt;b&gt;nil&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">프로세스 환경 변수 &lt;code&gt;varname&lt;/code&gt; 의 값을 리턴 하거나 변수가 정의되지 않은 경우 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3b86e22b7e07287e106fe5463ecf2e5e16d5d52" translate="yes" xml:space="preserve">
          <source>Returns the values packed in string &lt;code&gt;s&lt;/code&gt; (see &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;). An optional &lt;code&gt;pos&lt;/code&gt; marks where to start reading in &lt;code&gt;s&lt;/code&gt; (default is 1). After the read values, this function also returns the index of the first unread byte in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 값이 문자열에 포장 &lt;code&gt;s&lt;/code&gt; (참조 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; 를&lt;/a&gt; ) 형식 문자열에 따라 &lt;code&gt;fmt&lt;/code&gt; (참조 &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ). 선택 사항 인 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 에서 읽기 시작 위치를 표시합니다 (기본값은 1). 읽은 값 후에이 함수는 또한 읽지 않은 첫 번째 바이트의 인덱스를 &lt;code&gt;s&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bcc3adbac55a1cae7b7dbc056f59867a7e653730" translate="yes" xml:space="preserve">
          <source>Returns three values (an iterator function, the table &lt;code&gt;t&lt;/code&gt;, and 0) so that the construction</source>
          <target state="translated">구성을 위해 세 개의 값 (반복자 함수, 테이블 &lt;code&gt;t&lt;/code&gt; 및 0)을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="7db585fd6f4edc4d15ef6261e32bad83a4e3fc94" translate="yes" xml:space="preserve">
          <source>Returns true when the running coroutine can yield.</source>
          <target state="translated">실행중인 코 루틴이 산출 할 수있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="86872d97a4648c727afb8bd8743402fb113d9d79" translate="yes" xml:space="preserve">
          <source>Returns values so that the construction</source>
          <target state="translated">구성이되도록 값을 반환</target>
        </trans-unit>
        <trans-unit id="c0dd5c1f0b221305574b2b927c5b76675e55a510" translate="yes" xml:space="preserve">
          <source>Rotates the stack elements between the valid index &lt;code&gt;idx&lt;/code&gt; and the top of the stack. The elements are rotated &lt;code&gt;n&lt;/code&gt; positions in the direction of the top, for a positive &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; positions in the direction of the bottom, for a negative &lt;code&gt;n&lt;/code&gt;. The absolute value of &lt;code&gt;n&lt;/code&gt; must not be greater than the size of the slice being rotated. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">유효한 인덱스 &lt;code&gt;idx&lt;/code&gt; 와 스택 상단 사이에서 스택 요소를 회전시킵니다 . 요소는 상단 방향으로 &lt;code&gt;n&lt;/code&gt; 위치, 양수 &lt;code&gt;n&lt;/code&gt; , 하단 방향으로 &lt;code&gt;-n&lt;/code&gt; 위치, 음수 &lt;code&gt;n&lt;/code&gt; 위치로 회전 합니다. &lt;code&gt;n&lt;/code&gt; 의 절대 값은 회전중인 슬라이스의 크기보다 크지 않아야합니다. 의사 인덱스는 실제 스택 위치가 아니기 때문에 의사 인덱스로이 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb167298f69784fe48c5d2a384e7c877c8d9492d" translate="yes" xml:space="preserve">
          <source>Saves any written data to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">쓰여진 데이터를 &lt;code&gt;file&lt;/code&gt; 저장 합니다 .</target>
        </trans-unit>
        <trans-unit id="3440752ad05f6155ff5680caecbafde2dc649d9b" translate="yes" xml:space="preserve">
          <source>Searches for the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 에서 주어진 &lt;code&gt;name&lt;/code&gt; 을 검색 합니다 .</target>
        </trans-unit>
        <trans-unit id="d2a18ffdb89ed379138be3152d18086f1d55d2a3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for more information about variable indices and names.</source>
          <target state="translated">변수 인덱스 및 이름에 대한 자세한 내용은 &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3360426ce5422bc56d751e0aa6008fce46fc70e" translate="yes" xml:space="preserve">
          <source>See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">순회 중 테이블을 수정하는 경우의 경고에 대해서는 &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19f37898f520273219e289bdee9a8581baa73269" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;x&lt;/code&gt; as the &quot;seed&quot; for the pseudo-random generator: equal seeds produce equal sequences of numbers.</source>
          <target state="translated">의사 랜덤 생성기의 &lt;code&gt;x&lt;/code&gt; 를 &quot;시드&quot;로 설정합니다 . 동일한 시드는 동일한 수의 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0b2903d5c5e2f6aac5cee42b812f29848f11b229" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;).</source>
          <target state="translated">새로운 패닉 함수를 설정하고 이전 패닉 함수를 반환합니다 ( &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="10482f8b5b12a1f1db635550932f8faad32fd81b" translate="yes" xml:space="preserve">
          <source>Sets and gets the file position, measured from the beginning of the file, to the position given by &lt;code&gt;offset&lt;/code&gt; plus a base specified by the string &lt;code&gt;whence&lt;/code&gt;, as follows:</source>
          <target state="translated">다음과 같이 파일의 시작 위치에서 &lt;code&gt;offset&lt;/code&gt; 지정된 위치 와 문자열 &lt;code&gt;whence&lt;/code&gt; 에 의해 지정된 기준까지 파일 위치를 설정하고 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c75eca40914b6c7ff395b6a435b1b2509e75386b" translate="yes" xml:space="preserve">
          <source>Sets the C function &lt;code&gt;f&lt;/code&gt; as the new value of global &lt;code&gt;name&lt;/code&gt;. It is defined as a macro:</source>
          <target state="translated">C 함수 &lt;code&gt;f&lt;/code&gt; 를 새 전역 &lt;code&gt;name&lt;/code&gt; 값으로 설정합니다 . 매크로로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="de2f1f4dd9362493d0d4861f3dfe60cc83af4578" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for an output file. There are three available modes:</source>
          <target state="translated">출력 파일의 버퍼링 모드를 설정합니다. 사용 가능한 세 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="772769933fe32ebc8452718b212f21e2ae3b3d0a" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;nil&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">프로그램의 현재 로케일을 설정합니다. &lt;code&gt;locale&lt;/code&gt; 은 로케일을 지정하는 시스템 종속 문자열입니다. &lt;code&gt;category&lt;/code&gt; 는 변경할 범주를 설명하는 선택적 문자열입니다. &lt;code&gt;&quot;all&quot;&lt;/code&gt; , &lt;code&gt;&quot;collate&quot;&lt;/code&gt; , &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; , &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; , &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;time&quot;&lt;/code&gt; ; 기본 카테고리는 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 입니다. 이 함수는 새 로캘의 이름을 반환하거나 요청을 처리 할 수없는 경우 &lt;b&gt;nil을&lt;/b&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="577d8bdc520c0556720156fb048d7cc9591b0b65" translate="yes" xml:space="preserve">
          <source>Sets the debugging hook function.</source>
          <target state="translated">디버깅 후크 기능을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="292ec4e82927af4194013aa2f75932b01e97689c" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the Lua value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 주어진 &lt;code&gt;udata&lt;/code&gt; 와 연관된 Lua 값 으로 설정합니다 . &lt;code&gt;udata&lt;/code&gt; 는 전체 사용자 데이터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0f680b53b706554348285320cb60fd7dd4bf3ce4" translate="yes" xml:space="preserve">
          <source>Sets the given function as a hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">주어진 기능을 후크로 설정합니다. 문자열 &lt;code&gt;mask&lt;/code&gt; 와 숫자 &lt;code&gt;count&lt;/code&gt; 는 후크가 호출 될시기를 나타냅니다. 문자열 마스크는 다음과 같은 문자의 조합을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b8a030605b64f54e56dc4eb6882692a1e86465" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given &lt;code&gt;value&lt;/code&gt; to the given &lt;code&gt;table&lt;/code&gt; (which can be &lt;b&gt;nil&lt;/b&gt;). Returns &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 에 대한 메타 테이블을 주어진 &lt;code&gt;table&lt;/code&gt; ( &lt;b&gt;nil 일&lt;/b&gt; 수 있음 )로 설정합니다. &lt;code&gt;value&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc55fa8aad2a6ef152d3844b1dbc7d9854df5817" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. (To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).) If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">주어진 테이블에 대한 메타 테이블을 설정합니다. (루아 코드에서 다른 유형의 메타 테이블을 변경하려면 디버그 라이브러리 (사용해야합니다 &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10을&lt;/a&gt; ).) 경우 &lt;code&gt;metatable&lt;/code&gt; 있다 &lt;b&gt;전무&lt;/b&gt; , 주어진 테이블의 메타 테이블을 제거합니다. 원래 메타 테이블에 &lt;code&gt;__metatable&lt;/code&gt; 필드가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="587b6bacfd61f3dd529496795bf4b5531bf0411f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object at the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스택의 맨 위에있는 객체의 메타 테이블을 레지스트리의 이름 &lt;code&gt;tname&lt;/code&gt; 과 연관된 메타 테이블로 설정합니다 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="980d28e7c69235ce8818955ee39047b99459cc45" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without invoking the &lt;code&gt;__newindex&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">실제의 값을 설정한다 &lt;code&gt;table[index]&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 호출하지 않고 &lt;code&gt;__newindex&lt;/code&gt; 의 메타 메소드. &lt;code&gt;table&lt;/code&gt; 은 테이블 이어야하며 &lt;b&gt;nil&lt;/b&gt; 및 NaN과 다른 값을 &lt;code&gt;index&lt;/code&gt; 하고 Lua 값을 &lt;code&gt;value&lt;/code&gt; 해야합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="64764244caf680f963cbe34576ef7f19047e51d8" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">클로저의 상한값을 설정합니다. 스택의 맨 위에있는 값을 상위 값에 할당하고 이름을 반환합니다. 또한 스택에서 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="ffba6d217c9340ff452d0b26d7bde601a75effed" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">지정된 활성화 레코드의 로컬 변수 값을 설정합니다. 스택 맨 위에있는 값을 변수에 할당하고 이름을 반환합니다. 또한 스택에서 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="13dfadc7fc1e60158ee478b1d01c15a1a262b8f8" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library are used to check C function arguments. Because the error message is formatted for arguments (e.g., &quot;&lt;code&gt;bad argument #1&lt;/code&gt;&quot;), you should not use these functions for other stack values.</source>
          <target state="translated">보조 라이브러리의 여러 함수는 C 함수 인수를 확인하는 데 사용됩니다. 오류 메시지는 인수 형식으로 지정되므로 (예 : &quot; &lt;code&gt;bad argument #1&lt;/code&gt; &quot;) 다른 스택 값에이 함수를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d26a3bd3ccc1bc11907697040007c09639a73d" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library use internally some extra stack slots. When a function in the auxiliary library uses less than five slots, it does not check the stack size; it simply assumes that there are enough slots.</source>
          <target state="translated">보조 라이브러리의 여러 기능은 내부적으로 일부 추가 스택 슬롯을 사용합니다. 보조 라이브러리의 기능이 5 개 미만의 슬롯을 사용하는 경우 스택 크기를 확인하지 않습니다. 슬롯이 충분하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4e6f5999f6739678269276a1253783f2e33caacc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_gettable&quot;&gt;&lt;code&gt;lua_gettable&lt;/code&gt;&lt;/a&gt;, but does a raw access (i.e., without metamethods).</source>
          <target state="translated">&lt;a href=&quot;#lua_gettable&quot;&gt; &lt;code&gt;lua_gettable&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 원시 액세스를 수행합니다 (예 : 메타 메소드 없음).</target>
        </trans-unit>
        <trans-unit id="98d6dc9d6d25a6a5bcf82cd4cb364da6adb19bc6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_settable&quot;&gt;&lt;code&gt;lua_settable&lt;/code&gt;&lt;/a&gt;, but does a raw assignment (i.e., without metamethods).</source>
          <target state="translated">&lt;a href=&quot;#lua_settable&quot;&gt; &lt;code&gt;lua_settable&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 원시 할당을 수행합니다 (예 : 메타 메소드 없음).</target>
        </trans-unit>
        <trans-unit id="bb8fabad1f82bd899f79eae459334cf7e778fcba" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-io.input&quot;&gt;&lt;code&gt;io.input&lt;/code&gt;&lt;/a&gt;, but operates over the default output file.</source>
          <target state="translated">&lt;a href=&quot;#pdf-io.input&quot;&gt; &lt;code&gt;io.input&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 기본 출력 파일에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be9918f302436d602e28315cc5eff3fc1e73bb44" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, but gets the chunk from file &lt;code&gt;filename&lt;/code&gt; or from the standard input, if no file name is given.</source>
          <target state="translated">유사합니다 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 하지만, 파일에서 청크를 가져옵니다 &lt;code&gt;filename&lt;/code&gt; 파일 이름을 지정하지 않은 경우, 또는 표준 입력에서.</target>
        </trans-unit>
        <trans-unit id="26f694e9b1074e2724d2aeb68c0547978de3e666" translate="yes" xml:space="preserve">
          <source>Similarly, Lua versions can always change the internal representation of precompiled chunks; precompiled chunks are not compatible between different Lua versions.</source>
          <target state="translated">마찬가지로 Lua 버전은 항상 사전 컴파일 된 청크의 내부 표현을 변경할 수 있습니다. 사전 컴파일 된 청크는 다른 Lua 버전간에 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91f7e308fa2ec755f5b9629aa68bea063366955f" translate="yes" xml:space="preserve">
          <source>Sorts list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">소정의 순서로 정렬 된 목록 엘리먼트 &lt;em&gt;의 장소&lt;/em&gt; 에서, &lt;code&gt;list[1]&lt;/code&gt; 에 &lt;code&gt;list[#list]&lt;/code&gt; . 경우 &lt;code&gt;comp&lt;/code&gt; 주어진 첫 번째 요소가되도록 정렬 후 (최종 순서에서 제 앞에 와야 때, 두 개의리스트 엘리먼트하고 true 수신 기능이어야 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 의미 &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ). 경우 &lt;code&gt;comp&lt;/code&gt; 지정되어 있지 않은 경우, 표준 루아 연산자는 &lt;code&gt;&amp;lt;&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a010f7f7cdbd4258d79a8a94cbe56bc77bf2b5e7" translate="yes" xml:space="preserve">
          <source>Square brackets are used to index a table:</source>
          <target state="translated">대괄호는 테이블을 색인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8857dbe9de4909ed5c2183cf91102dab19f054b" translate="yes" xml:space="preserve">
          <source>Standard Libraries</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="3aa420e36a031586ffcaad7595673c265cb89fc8" translate="yes" xml:space="preserve">
          <source>Starts and resumes a coroutine in the given thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">주어진 스레드 &lt;code&gt;L&lt;/code&gt; 에서 코 루틴을 시작하고 다시 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="d40756a05671d2e92d48621babd1cb1ebcde9165" translate="yes" xml:space="preserve">
          <source>Starts or continues the execution of coroutine &lt;code&gt;co&lt;/code&gt;. The first time you resume a coroutine, it starts running its body. The values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the arguments to the body function. If the coroutine has yielded, &lt;code&gt;resume&lt;/code&gt; restarts it; the values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the results from the yield.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 의 실행을 시작하거나 계속합니다 . 코 루틴을 처음으로 다시 시작하면 몸이 달리기 시작합니다. &lt;code&gt;val1&lt;/code&gt; , ... 값 은 body 함수에 인수로 전달됩니다. 코 루틴이 생성 된 경우 &lt;code&gt;resume&lt;/code&gt; 시작하면 다시 시작됩니다. &lt;code&gt;val1&lt;/code&gt; , ... 값 은 수율의 결과로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fdcf228dfc0fc5649ba85944b97fefcca7ffe43a" translate="yes" xml:space="preserve">
          <source>Starts program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">분리 된 프로세스에서 프로그램 &lt;code&gt;prog&lt;/code&gt; 을 시작 하고이 프로그램에서 데이터를 읽거나 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 인 경우 기본값)이 프로그램에 데이터를 쓰는 데 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 인 경우) 사용할 수있는 파일 핸들을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="4a3601848fbaa157ee7ad1bf17ef71628017fcdf" translate="yes" xml:space="preserve">
          <source>Suppose the running thread yields while executing the callee function. After the thread resumes, it eventually will finish running the callee function. However, the callee function cannot return to the original function, because its frame in the C stack was destroyed by the yield. Instead, Lua calls a &lt;em&gt;continuation function&lt;/em&gt;, which was given as an argument to the callee function. As the name implies, the continuation function should continue the task of the original function.</source>
          <target state="translated">호출 수신자 함수를 실행하는 동안 실행중인 스레드 수율을 가정하십시오. 스레드가 재개되면 결국 수신자 함수 실행이 완료됩니다. 그러나 C 스택의 프레임이 수율로 인해 소멸되었으므로 수신자 함수는 원래 함수로 돌아갈 수 없습니다. 대신 Lua는 호출 &lt;em&gt;함수&lt;/em&gt; 에 대한 인수로 제공된 &lt;em&gt;연속 함수&lt;/em&gt; 를 호출합니다. 이름에서 알 수 있듯이 연속 기능은 원래 기능의 작업을 계속해야합니다.</target>
        </trans-unit>
        <trans-unit id="e83b7d557c46acb05b744857e11a6cfdb7f1df00" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the calling coroutine. Any arguments to &lt;code&gt;yield&lt;/code&gt; are passed as extra results to &lt;code&gt;resume&lt;/code&gt;.</source>
          <target state="translated">발신 코 루틴 실행을 일시 중단합니다. &lt;code&gt;yield&lt;/code&gt; 할 인수 는 추가 결과로 전달되어 &lt;code&gt;resume&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf68697aa23858afae69b1650bbb5ac00b4caade" translate="yes" xml:space="preserve">
          <source>Table Constructors</source>
          <target state="translated">테이블 생성자</target>
        </trans-unit>
        <trans-unit id="ddade22015227084f0c0a4b0fb958ac23eef35ed" translate="yes" xml:space="preserve">
          <source>Table constructors are expressions that create tables. Every time a constructor is evaluated, a new table is created. A constructor can be used to create an empty table or to create a table and initialize some of its fields. The general syntax for constructors is</source>
          <target state="translated">테이블 생성자는 테이블을 생성하는 표현식입니다. 생성자가 평가 될 때마다 새 테이블이 작성됩니다. 생성자를 사용하여 빈 테이블을 만들거나 테이블을 만들고 일부 필드를 초기화 할 수 있습니다. 생성자의 일반적인 구문은</target>
        </trans-unit>
        <trans-unit id="8eb8356b5217b3ad22882eb75be685d15131abcf" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables (although multiple tables and userdata can share their metatables). Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">테이블과 전체 사용자 데이터에는 개별 메타 테이블이 있습니다 (여러 테이블과 사용자 데이터는 메타 테이블을 공유 할 수 있음). 다른 모든 유형의 값은 유형 당 하나의 단일 메타 테이블을 공유합니다. 즉, 모든 숫자에 대해 하나의 메타 테이블이 있고 모든 문자열에 대해 하나의 메타 테이블이 있습니다. 기본적으로 값에는 메타 테이블이 없지만 문자열 라이브러리는 문자열 유형에 대한 메타 테이블을 설정합니다 ( &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="790df16e07d28fbd0bc25fd6c6058d692af71b40" translate="yes" xml:space="preserve">
          <source>Tables are the sole data-structuring mechanism in Lua; they can be used to represent ordinary arrays, lists, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing &lt;code&gt;a.name&lt;/code&gt; as syntactic sugar for &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt;. There are several convenient ways to create tables in Lua (see &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;).</source>
          <target state="translated">테이블은 Lua의 유일한 데이터 구조화 메커니즘입니다. 그것들은 일반적인 배열,리스트, 심볼 테이블, 세트, ​​레코드, 그래프, 트리 등을 나타내는 데 사용될 수 있습니다. 레코드를 나타 내기 위해 Lua는 필드 이름을 인덱스로 사용합니다. 이 언어는 &lt;code&gt;a.name&lt;/code&gt; 을 &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt; 의 구문 설탕 으로 제공하여이 표현을 지원합니다 . Lua에서 테이블을 작성하는 편리한 방법이 몇 가지 있습니다 ( &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e421a06df75071a6abebc4fb3581855738824adb" translate="yes" xml:space="preserve">
          <source>Tables, functions, threads, and (full) userdata values are &lt;em&gt;objects&lt;/em&gt;: variables do not actually &lt;em&gt;contain&lt;/em&gt; these values, only &lt;em&gt;references&lt;/em&gt; to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy.</source>
          <target state="translated">테이블, 함수, 스레드 및 (전체) userdata 값은 &lt;em&gt;객체입니다&lt;/em&gt; . 변수는 실제로 이러한 값을 &lt;em&gt;포함&lt;/em&gt; 하지 않으며 해당 값만 &lt;em&gt;참조&lt;/em&gt; 합니다. 대입, 매개 변수 전달 및 함수 리턴은 항상 이러한 값에 대한 참조를 조작합니다. 이러한 작업은 어떠한 종류의 복사도 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99385b30015343b5b8e00056e58a762956df3e7d" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, or thread), this new object is different from any previously existing object. Closures with the same reference are always equal. Closures with any detectable difference (different behavior, different definition) are always different.</source>
          <target state="translated">테이블, 사용자 데이터 및 스레드는 참조로 비교됩니다. 두 객체는 ​​동일한 객체 인 경우에만 동일한 것으로 간주됩니다. 새 개체 (테이블, 사용자 데이터 또는 스레드)를 만들 때마다이 새 개체는 기존 개체와 다릅니다. 동일한 참조의 클로저는 항상 같습니다. 감지 가능한 차이 (다른 동작, 다른 정의)를 가진 클로저는 항상 다릅니다.</target>
        </trans-unit>
        <trans-unit id="446beb4016f56d03fb7aeada345cb1a7a86ea482" translate="yes" xml:space="preserve">
          <source>Terminates the last protected function called and returns &lt;code&gt;message&lt;/code&gt; as the error object. Function &lt;code&gt;error&lt;/code&gt; never returns.</source>
          <target state="translated">마지막으로 호출 된 보호 기능을 종료하고 오류 객체 로 &lt;code&gt;message&lt;/code&gt; 를 반환 합니다. 함수 &lt;code&gt;error&lt;/code&gt; 절대로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aad621a873e57ea830369714dc4bd782c2449476" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following constants (defined in &lt;code&gt;lua.h&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 의&lt;/a&gt; 기능은 다음 상수 중 하나 (정의 반환 &lt;code&gt;lua.h&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="b1d59a96e495b4ed1314e7a452acf7cf2be3dd16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pdf-ipairs&quot;&gt;&lt;code&gt;ipairs&lt;/code&gt;&lt;/a&gt; iterator now respects metamethods and its &lt;code&gt;__ipairs&lt;/code&gt; metamethod has been deprecated.</source>
          <target state="translated">&lt;a href=&quot;#pdf-ipairs&quot;&gt; &lt;code&gt;ipairs&lt;/code&gt; &lt;/a&gt; 반복자 이제 측면의 메타 메서드와 &lt;code&gt;__ipairs&lt;/code&gt; 사용되지 않습니다 메타 메소드.</target>
        </trans-unit>
        <trans-unit id="bc47dc2ae4b1f24c3a3899f4b1f9405cda8bd057" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;break&lt;/b&gt; statement terminates the execution of a &lt;b&gt;while&lt;/b&gt;, &lt;b&gt;repeat&lt;/b&gt;, or &lt;b&gt;for&lt;/b&gt; loop, skipping to the next statement after the loop:</source>
          <target state="translated">&lt;b&gt;휴식&lt;/b&gt; 문은 실행 종료 &lt;b&gt;하는 동안&lt;/b&gt; , &lt;b&gt;반복&lt;/b&gt; , 또는 &lt;b&gt;에 대한&lt;/b&gt; 루프 후 다음 명령문을 건너 뛰고, 루프 :</target>
        </trans-unit>
        <trans-unit id="be57b4db5d11ecd50b150a3c2c7baa57bca94b87" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;for&lt;/b&gt; statement has two forms: one numerical and one generic.</source>
          <target state="translated">&lt;b&gt;에 대한&lt;/b&gt; 하나 개의 숫자와 하나의 일반적인 : 문은 두 가지 형태가있다.</target>
        </trans-unit>
        <trans-unit id="b061702cc21366ebd955da1cbb0818c2844543b8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;goto&lt;/b&gt; statement transfers the program control to a label. For syntactical reasons, labels in Lua are considered statements too:</source>
          <target state="translated">&lt;b&gt;고토&lt;/b&gt; 문은 레이블 프로그램 제어를 전송합니다. 구문상의 이유로 Lua의 레이블은 다음과 같은 진술로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c9f54acbc996a7d79b7252d182ed631a6a317f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is really necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문은 블록의 마지막 문장으로 쓸 수 있습니다. 정말 필요한 경우 &lt;b&gt;반환&lt;/b&gt; 블록의 중간에 관용구처럼, 다음 명시적인 내부 블록은 사용할 수 &lt;code&gt;do return end&lt;/code&gt; 해주기 때문에, &lt;b&gt;반환&lt;/b&gt; 의 (내부) 블록의 마지막 문입니다.</target>
        </trans-unit>
        <trans-unit id="c44e88f5118a01354e009d7fa35997d3c87c7c1a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문 함수 또는 (익명 함수) 덩어리의 값을 반환하는 데 사용된다. 함수는 둘 이상의 값을 반환 할 수 있으므로 &lt;b&gt;return&lt;/b&gt; 문의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b646ffbbdcd054326d494ba2f5c649f95d36297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bit32&lt;/code&gt; library has been deprecated. It is easy to require a compatible external library or, better yet, to replace its functions with appropriate bitwise operations. (Keep in mind that &lt;code&gt;bit32&lt;/code&gt; operates on 32-bit integers, while the bitwise operators in Lua 5.3 operate on Lua integers, which by default have 64 bits.)</source>
          <target state="translated">&lt;code&gt;bit32&lt;/code&gt; 의 라이브러리는 더 이상 사용되지 않습니다. 호환되는 외부 라이브러리가 필요하거나 더 나은 기능을 적절한 비트 단위 연산으로 대체하는 것이 더 쉽습니다. ( &lt;code&gt;bit32&lt;/code&gt; 는 32 비트 정수에서 작동하지만 Lua 5.3의 비트 연산자는 기본적으로 64 비트 인 Lua 정수에서 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="3c35b56166af83b28a7e0e22c5d357b538f84788" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; 의 인수는 오류 메시지와 디버그 정보에 사용되는 덩어리에 이름을 제공합니다 ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bae62f5a0575c4f5ff2aabe5bf99d9776f3199b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lua_load&lt;/code&gt; function uses a user-supplied &lt;code&gt;reader&lt;/code&gt; function to read the chunk (see &lt;a href=&quot;#lua_Reader&quot;&gt;&lt;code&gt;lua_Reader&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;data&lt;/code&gt; argument is an opaque value passed to the reader function.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 의 기능은 사용자가 제공하는 사용 &lt;code&gt;reader&lt;/code&gt; (참조 청크를 읽는 기능 &lt;a href=&quot;#lua_Reader&quot;&gt; &lt;code&gt;lua_Reader&lt;/code&gt; 을&lt;/a&gt; ). &lt;code&gt;data&lt;/code&gt; 인자 리더 함수에 전달 된 불투명 값이다.</target>
        </trans-unit>
        <trans-unit id="85f9907ce6878c8dc7e267337764d4964c7fae3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can also have a '&lt;code&gt;b&lt;/code&gt;' at the end, which is needed in some systems to open the file in binary mode.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 문자열은 또한 '수 &lt;code&gt;b&lt;/code&gt; 바이너리 모드로 파일을 열려면 어떤 시스템에 필요한 끝에서'를.</target>
        </trans-unit>
        <trans-unit id="2688f69f4c7b22c66219e46ee16c2eac721dcdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can be any of the following:</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 문자열은 다음 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="dcce9d1975851c844f7c2f304003970e38bff938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;q&lt;/code&gt; option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 옵션은 안전하게 루아 인터프리터에 의해 읽기 돌아올 수 있도록 필요한 경우 이스케이프 시퀀스를 사용하여 따옴표 사이의 문자열을 포맷합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ab9206bbe0932c07e692d615d61a36493a13a496" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;auxiliary library&lt;/em&gt; provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks.</source>
          <target state="translated">&lt;em&gt;보조 라이브러리는&lt;/em&gt; 루아와 C를 인터페이스에 여러 가지 편리한 기능을 제공합니다. 기본 API는 C와 Lua 간의 모든 상호 작용에 대한 기본 기능을 제공하지만 보조 라이브러리는 일부 공통 작업에 대한 고급 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ab6afc13be0118f613c20671f20dcaa66bf50fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;block&lt;/em&gt; is repeated for &lt;em&gt;name&lt;/em&gt; starting at the value of the first &lt;em&gt;exp&lt;/em&gt;, until it passes the second &lt;em&gt;exp&lt;/em&gt; by steps of the third &lt;em&gt;exp&lt;/em&gt;. More precisely, a &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">&lt;em&gt;블록&lt;/em&gt; 에 대해 반복되는 &lt;em&gt;이름&lt;/em&gt; 제의 값에서 시작 &lt;em&gt;EXP&lt;/em&gt; 은 제 통과 할 때까지, &lt;em&gt;EXP&lt;/em&gt; 세번째 단계에 의해 &lt;em&gt;Exp를&lt;/em&gt; . 보다 정확하게 &lt;b&gt;는&lt;/b&gt; 다음과 같은 &lt;b&gt;for&lt;/b&gt; 문</target>
        </trans-unit>
        <trans-unit id="d3b254f35dcb5161307fc6d343f99ec868c9f36b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used for defining &lt;em&gt;methods&lt;/em&gt;, that is, functions that have an implicit extra parameter &lt;code&gt;self&lt;/code&gt;. Thus, the statement</source>
          <target state="translated">&lt;em&gt;대장&lt;/em&gt; 구문 정의하기 위해 사용되는 &lt;em&gt;방법&lt;/em&gt; 인, 암시 추가 파라미터가 기능 &lt;code&gt;self&lt;/code&gt; . 따라서 진술</target>
        </trans-unit>
        <trans-unit id="171411617a28d7de2b0226c80067f77ec30897f7" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file handles.</source>
          <target state="translated">I / O 라이브러리는 파일 조작을위한 두 가지 스타일을 제공합니다. 첫 번째는 암시 적 파일 핸들을 사용합니다. 즉, 기본 입력 파일과 기본 출력 파일을 설정하는 작업이 있으며 모든 입력 / 출력 작업이이 기본 파일을 초과합니다. 두 번째 스타일은 명시 적 파일 핸들을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe26bd92623ecffd0ef5b0b7681c64345000ef38" translate="yes" xml:space="preserve">
          <source>The Length Operator</source>
          <target state="translated">길이 연산자</target>
        </trans-unit>
        <trans-unit id="b46439f6fc2b5220d043e60a0c5b1b7e77db627e" translate="yes" xml:space="preserve">
          <source>The Lua library is fully reentrant: it has no global variables. It keeps all information it needs in a dynamic structure, called the &lt;em&gt;Lua state&lt;/em&gt;.</source>
          <target state="translated">Lua 라이브러리는 완전히 재진입됩니다. 전역 변수가 없습니다. 필요한 모든 정보를 &lt;em&gt;Lua state&lt;/em&gt; 라는 동적 구조로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="07b128e0f94f3f9a107ec1b9a4411b8083a41fce" translate="yes" xml:space="preserve">
          <source>The Table library now respects metamethods for setting and getting elements.</source>
          <target state="translated">테이블 라이브러리는 이제 요소를 설정하고 가져 오기위한 메타 메소드를 존중합니다.</target>
        </trans-unit>
        <trans-unit id="eb554fe048e1c8b347ad8a3da87d434c8b60f5db" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (note the mandatory enclosing brackets), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point.</source>
          <target state="translated">유니 코드 문자의 UTF-8 인코딩은 이스케이프 시퀀스 &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (필수로 묶는 괄호) 를 사용하여 리터럴 문자열에 삽입 할 수 있습니다 . 여기서 &lt;em&gt;XXX&lt;/em&gt; 는 문자 코드 포인트를 나타내는 하나 이상의 16 진수 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="3e71c6008a2054b02c7458c10af8db199b93e0fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">배열 &lt;code&gt;l&lt;/code&gt; 은 포인터가 아닌 실제 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec4ef8ac03868996fbe27096f10720a2a635fd47" translate="yes" xml:space="preserve">
          <source>The assignment statement first evaluates all its expressions and only then the assignments are performed. Thus the code</source>
          <target state="translated">대 입문은 먼저 모든 표현식을 평가 한 후에 만 ​​대입을 수행합니다. 따라서 코드</target>
        </trans-unit>
        <trans-unit id="63ea036976be25a6fccc44715a31648a894a2cd9" translate="yes" xml:space="preserve">
          <source>The available formats are</source>
          <target state="translated">사용 가능한 형식은</target>
        </trans-unit>
        <trans-unit id="1bf5ee36dda4ba103acec9799a8f08fe38658693" translate="yes" xml:space="preserve">
          <source>The basic expressions in Lua are the following:</source>
          <target state="translated">루아의 기본 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a90f0e6ef32f54b398b228c2483c97e99f92d4d7" translate="yes" xml:space="preserve">
          <source>The basic library provides core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities.</source>
          <target state="translated">기본 라이브러리는 Lua에 핵심 기능을 제공합니다. 응용 프로그램에이 라이브러리를 포함하지 않으면 일부 기능에 대한 구현을 제공해야하는지 신중하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a4e9c1cd28f7989f62ba005ba19f087fc3592ba" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</source>
          <target state="translated">순회 중에 테이블의 존재하지 않는 필드에 값을 지정하면 &lt;code&gt;next&lt;/code&gt; 동작 이 정의되지 않습니다. 그러나 기존 필드를 수정할 수 있습니다. 특히 기존 필드를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc90ae531b088f04f67083e165dbcb68af23283" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; now returns only one result. (You can compute that second result from the fractional part of the first result.)</source>
          <target state="translated">&lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; 호출은 이제 하나의 결과 만 리턴합니다. 첫 번째 결과의 소수 부분에서 두 번째 결과를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c68441a4203b3cd2bfe34776a10e03a400a467cb" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.</source>
          <target state="translated">&lt;code&gt;io.lines()&lt;/code&gt; 호출 ( 파일 이름 없음)은 &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt; 와 같습니다. 즉, 기본 입력 파일의 행을 반복합니다. 이 경우 루프가 종료 될 때 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef37fdd6b0b5e41eab32a9928b1d9217a2a5737b" translate="yes" xml:space="preserve">
          <source>The computation of the length of a table has a guaranteed worst time of &lt;em&gt;O(log n)&lt;/em&gt;, where &lt;em&gt;n&lt;/em&gt; is the largest natural key in the table.</source>
          <target state="translated">테이블 길이 계산시 최악의 &lt;em&gt;O (log n)&lt;/em&gt; 시간이 보장 되며, 여기서 &lt;em&gt;n&lt;/em&gt; 은 테이블에서 가장 큰 자연 키입니다.</target>
        </trans-unit>
        <trans-unit id="0b56d75e0be562bbdd8ce192220fca509ed349d6" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; are considered false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are considered true (in particular, the number 0 and the empty string are also true).</source>
          <target state="translated">제어 구조의 조건식은 모든 값을 리턴 할 수 있습니다. &lt;b&gt;false&lt;/b&gt; 와 &lt;b&gt;nil&lt;/b&gt; 은 모두 &lt;b&gt;false&lt;/b&gt; 로 간주됩니다. &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 와 다른 모든 값 은 true로 간주됩니다 (특히 숫자 0 및 빈 문자열도 true).</target>
        </trans-unit>
        <trans-unit id="c3733f14fe1543e4589c9195fb66e8ff53166d2c" translate="yes" xml:space="preserve">
          <source>The control structures &lt;b&gt;if&lt;/b&gt;, &lt;b&gt;while&lt;/b&gt;, and &lt;b&gt;repeat&lt;/b&gt; have the usual meaning and familiar syntax:</source>
          <target state="translated">제어 구조 &lt;b&gt;if&lt;/b&gt; , &lt;b&gt;while&lt;/b&gt; 및 &lt;b&gt;repeat&lt;/b&gt; 는 일반적인 의미와 익숙한 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fd0c2e7539b39e7334ffb646988e686084be276b" translate="yes" xml:space="preserve">
          <source>The conversion from float to integer checks whether the float has an exact representation as an integer (that is, the float has an integral value and it is in the range of integer representation). If it does, that representation is the result. Otherwise, the conversion fails.</source>
          <target state="translated">float에서 integer 로의 변환은 float가 정확히 정수로 표시되는지 (즉, float는 정수 값을 가지며 정수 표시 범위에 있는지)를 확인합니다. 그렇다면 그 표현이 결과입니다. 그렇지 않으면 변환이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2672e5ddb4380b4a0e9162708d0ffacc1d9552f5" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. For complete control over how numbers are converted to strings, use the &lt;code&gt;format&lt;/code&gt; function from the string library (see &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">숫자에서 문자열로의 변환은 지정되지 않은 사람이 읽을 수있는 형식을 사용합니다. 숫자를 문자열로 변환하는 방법을 완전히 제어 하려면 문자열 라이브러리에서 &lt;code&gt;format&lt;/code&gt; 함수를 사용 하십시오 ( &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e4fc8189f226b883ce5f116eb5b865021736d178" translate="yes" xml:space="preserve">
          <source>The conversion from strings to numbers goes as follows: First, the string is converted to an integer or a float, following its syntax and the rules of the Lua lexer. (The string may have also leading and trailing spaces and a sign.) Then, the resulting number (float or integer) is converted to the type (float or integer) required by the context (e.g., the operation that forced the conversion).</source>
          <target state="translated">문자열에서 숫자로의 변환은 다음과 같습니다. 첫째, 문자열은 구문과 Lua lexer 규칙에 따라 정수 또는 부동 소수점으로 변환됩니다. 문자열에는 선행 및 후행 공백과 부호가있을 수도 있습니다. 그런 다음 결과 숫자 (부동 또는 정수)가 컨텍스트에 필요한 유형 (부동 또는 정수) (예 : 변환을 강제 한 작업)으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f171e574fe61e971bf96a3990d066bb469d0ea25" translate="yes" xml:space="preserve">
          <source>The conversion of a float to a string now adds a &lt;code&gt;.0&lt;/code&gt; suffix to the result if it looks like an integer. (For instance, the float 2.0 will be printed as &lt;code&gt;2.0&lt;/code&gt;, not as &lt;code&gt;2&lt;/code&gt;.) You should always use an explicit format when you need a specific format for numbers.</source>
          <target state="translated">float를 문자열로 변환 하면 정수처럼 &lt;code&gt;.0&lt;/code&gt; 결과에 .0 접미사가 추가 됩니다. 예를 들어, float 2.0은 &lt;code&gt;2&lt;/code&gt; 가 아닌 &lt;code&gt;2.0&lt;/code&gt; 으로 인쇄됩니다 . 숫자에 특정 형식이 필요할 때는 항상 명시 적 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fde25091233105fea6baa5683b61b7b5603b3cd0" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). (The string may have leading and trailing spaces and a sign.)</source>
          <target state="translated">Lua의 어휘 규칙에 따라 문자열을 변환하면 정수 또는 부동 소수점이 발생할 수 있습니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ). (문자열에는 앞뒤 공백과 부호가있을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="4a41a1a32246a11826a5d6e075e45733f76f3306" translate="yes" xml:space="preserve">
          <source>The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer as a hexadecimal numeral), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">변환 지정자는 상당히 제한되어 있습니다. 플래그, 너비 또는 정밀도가 없습니다. 변환 지정자는 ' &lt;code&gt;%%&lt;/code&gt; '(문자 ' &lt;code&gt;%&lt;/code&gt; ' 삽입 ), ' &lt;code&gt;%s&lt;/code&gt; '(크기 제한없이 0으로 끝나는 문자열 삽입), ' &lt;code&gt;%f&lt;/code&gt; '( &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; 삽입 ), ' &lt;code&gt;%I&lt;/code&gt; '( &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 삽입 ),' &lt;code&gt;%p&lt;/code&gt; '(16 진 숫자로 포인터 삽입),' &lt;code&gt;%d&lt;/code&gt; '( &lt;code&gt;int&lt;/code&gt; 입력 ),' &lt;code&gt;%c&lt;/code&gt; '( 1 바이트 문자로 &lt;code&gt;int&lt;/code&gt; 삽입 ) 및' &lt;code&gt;%U&lt;/code&gt; '( &lt;code&gt;long int&lt;/code&gt; 를 UTF-8 바이트 시퀀스로 삽입합니다 ).</target>
        </trans-unit>
        <trans-unit id="4a2b4eab7e7e8e47540c45b140f9d1c1edf8fd79" translate="yes" xml:space="preserve">
          <source>The current parser always sees such constructions in the first way, interpreting the open parenthesis as the start of the arguments to a call. To avoid this ambiguity, it is a good practice to always precede with a semicolon statements that start with a parenthesis:</source>
          <target state="translated">현재 구문 분석기는 항상 이러한 구성을 첫 번째 방식으로보고 열린 괄호를 호출에 대한 인수의 시작으로 해석합니다. 이 모호성을 피하려면 항상 괄호로 시작하는 세미콜론 문을 먼저 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1273a024b1e39aac89ab0ab6781ebe040b7fbcc0" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list&lt;/code&gt; 이므로 call table.remove &lt;code&gt;table.remove(l)&lt;/code&gt; 은 list &lt;code&gt;l&lt;/code&gt; 의 마지막 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="13c08370b3a28f0fd5960d5a4c5c48fa16e93a96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;&quot;cur&quot;&lt;/code&gt;, and for &lt;code&gt;offset&lt;/code&gt; is 0. Therefore, the call &lt;code&gt;file:seek()&lt;/code&gt; returns the current file position, without changing it; the call &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; sets the position to the beginning of the file (and returns 0); and the call &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; sets the position to the end of the file, and returns its size.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; 의 기본값 은 &lt;code&gt;&quot;cur&quot;&lt;/code&gt; 이고 &lt;code&gt;offset&lt;/code&gt; 의 값 은 0입니다. 따라서 호출 &lt;code&gt;file:seek()&lt;/code&gt; 는 현재 파일 위치를 변경하지 않고 반환합니다. 호출 &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; 는 파일의 시작 위치를 설정하고 0을 반환합니다. &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; 호출 은 위치를 파일의 끝으로 설정하고 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc56dc8d299b9d15b00a924ab6b6763132d6c6e" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;x&lt;/code&gt; is 1, so that the call &lt;code&gt;math.atan(y)&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본값 은 1이므로 &lt;code&gt;math.atan(y)&lt;/code&gt; 호출 은 &lt;code&gt;y&lt;/code&gt; 의 아크 탄젠트를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1119d71f1c451d5f2fe0db217d85e8a5bba94c" translate="yes" xml:space="preserve">
          <source>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class &lt;code&gt;[a-z]&lt;/code&gt; may not be equivalent to &lt;code&gt;%l&lt;/code&gt;.</source>
          <target state="translated">문자, 공백 및 기타 문자 그룹의 정의는 현재 로케일에 따라 다릅니다. 특히, 클래스 &lt;code&gt;[a-z]&lt;/code&gt; 는 &lt;code&gt;%l&lt;/code&gt; 과 (와) 동일하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f71cbe788ea609ab97e549ccaa27836b38cc887d" translate="yes" xml:space="preserve">
          <source>The field list can have an optional trailing separator, as a convenience for machine-generated code.</source>
          <target state="translated">필드리스트에는 기계 생성 코드의 편의를 위해 선택적인 후행 구분 기호가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2dc2a9366caaece55ab74f5902257c1d9cc63e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; have the following meaning:</source>
          <target state="translated">&lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5cf6a1464c2f6d6211946c68accd0138255e9433" translate="yes" xml:space="preserve">
          <source>The fifth line is a mark to ignore all text after it when building the &lt;code&gt;luaopen_&lt;/code&gt; function name. Default is '&lt;code&gt;-&lt;/code&gt;'.</source>
          <target state="translated">다섯 번째 줄은 &lt;code&gt;luaopen_&lt;/code&gt; 함수 이름을 빌드 할 때 모든 텍스트를 무시하는 표시 입니다. 기본값은 ' &lt;code&gt;-&lt;/code&gt; '입니다.</target>
        </trans-unit>
        <trans-unit id="d550e1bb0cbfc7b8de8aa9f3e58a6e8b1e903f3a" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.packsize&quot;&gt;&lt;code&gt;string.packsize&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; is a format string, which describes the layout of the structure being created or read.</source>
          <target state="translated">&lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.packsize&quot;&gt; &lt;code&gt;string.packsize&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수 는 작성 또는 읽은 구조의 레이아웃을 설명하는 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="35b2be930dbf43b40449e98f73501827b087ff5f" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments (e.g., they may depend on what is on the stack). The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise out-of-memory errors and errors running a &lt;code&gt;__gc&lt;/code&gt; metamethod; '&lt;code&gt;e&lt;/code&gt;' means the function may raise any errors (it can run arbitrary Lua code, either directly or through metamethods); '&lt;code&gt;v&lt;/code&gt;' means the function may raise an error on purpose.</source>
          <target state="translated">첫 번째 필드 &lt;code&gt;o&lt;/code&gt; 는 스택에서 함수가 팝업하는 요소 수입니다. 두 번째 필드 &lt;code&gt;p&lt;/code&gt; 는 함수가 스택에 푸시하는 요소 수입니다. (모든 함수는 인수를 팝한 후 항상 결과를 푸시합니다.) &lt;code&gt;x|y&lt;/code&gt; 형식의 필드 는 함수가 상황에 따라 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 요소를 푸시 (또는 팝) 할 수 있음을 의미합니다 . 심문 마크 &lt;code&gt;?&lt;/code&gt; '는 인수 만보고 함수가 얼마나 많은 요소를 팝 / 푸시하는지 알 수 없음을 의미합니다 (예 : 스택에있는 요소에 따라 다를 수 있음). 세 번째 필드 인 &lt;code&gt;x&lt;/code&gt; 는 함수가 오류를 발생시킬 수 있는지 여부를 알려줍니다. ' &lt;code&gt;-&lt;/code&gt; '는 함수가 오류를 발생시키지 않음을 의미합니다. ' &lt;code&gt;m&lt;/code&gt; '는 함수가 메모리 부족 오류 및 &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 실행하는 오류를 일으킬 수 있음을 의미합니다 . ' &lt;code&gt;e&lt;/code&gt; '는 함수가 오류를 일으킬 수 있음을 의미합니다 (직접 또는 메타 메소드를 통해 임의의 Lua 코드를 실행할 수 있음). ' &lt;code&gt;v&lt;/code&gt; '는 함수가 의도적으로 오류를 일으킬 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="080894d3f355773389e870abdc64bf22951aa7fd" translate="yes" xml:space="preserve">
          <source>The first line is the directory separator string. Default is '&lt;code&gt;\&lt;/code&gt;' for Windows and '&lt;code&gt;/&lt;/code&gt;' for all other systems.</source>
          <target state="translated">첫 번째 줄은 디렉토리 구분자 문자열입니다. Windows의 경우 기본값은 ' &lt;code&gt;\&lt;/code&gt; '이고 다른 모든 시스템의 경우 ' &lt;code&gt;/&lt;/code&gt; '입니다.</target>
        </trans-unit>
        <trans-unit id="b927b10bd57d8d0d9d2adab8cf882393f87f3f97" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">첫 번째 매개 변수 또는 로컬 변수는 코드에서 선언 된 순서에 따라 색인 1 등을 가지며 함수의 현재 범위에서 활성 인 변수 만 계산합니다. 음의 인덱스는 vararg 매개 변수를 나타냅니다. -1은 첫 번째 vararg 매개 변수입니다. 주어진 인덱스에 변수가 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환 하고, 범위를 벗어난 레벨로 호출하면 오류가 발생합니다. 레벨이 유효한지 확인하기 위해 &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8f303d70c303dd14cac48bd1f16c3b0dcbcc40" translate="yes" xml:space="preserve">
          <source>The first searcher simply looks for a loader in the &lt;a href=&quot;#pdf-package.preload&quot;&gt;&lt;code&gt;package.preload&lt;/code&gt;&lt;/a&gt; table.</source>
          <target state="translated">첫 번째 검색자는 단순히 &lt;a href=&quot;#pdf-package.preload&quot;&gt; &lt;code&gt;package.preload&lt;/code&gt; &lt;/a&gt; 테이블 에서 로더를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d265942ec96276d66e6ab599ec30b3a3b29815fd" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value larger than any other numeric value.</source>
          <target state="translated">다른 숫자 값보다 큰 값인 float 값 &lt;code&gt;HUGE_VAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="196211405f17ee844517a47f2e8b2cb60db3f8ce" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;keywords&lt;/em&gt; are reserved and cannot be used as names:</source>
          <target state="translated">다음 &lt;em&gt;키워드&lt;/em&gt; 는 예약되어 있으며 이름으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab8a72a62eca0d1ef8ee4d0f5f153c9b1519bd5d" translate="yes" xml:space="preserve">
          <source>The following example shows how the host program can do the equivalent to this Lua code:</source>
          <target state="translated">다음 예제는 호스트 프로그램이이 Lua 코드와 동등한 기능을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="278e2855a1845e2a26526bc29fe7fac6d57babe0" translate="yes" xml:space="preserve">
          <source>The following functions were deprecated in the mathematical library: &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, and &lt;code&gt;ldexp&lt;/code&gt;. You can replace &lt;code&gt;math.pow(x,y)&lt;/code&gt; with &lt;code&gt;x^y&lt;/code&gt;; you can replace &lt;code&gt;math.atan2&lt;/code&gt; with &lt;code&gt;math.atan&lt;/code&gt;, which now accepts one or two parameters; you can replace &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; with &lt;code&gt;x * 2.0^exp&lt;/code&gt;. For the other operations, you can either use an external library or implement them in Lua.</source>
          <target state="translated">수학 라이브러리에서는 &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; 및 &lt;code&gt;ldexp&lt;/code&gt; 함수가 더 이상 사용되지 않습니다 . &lt;code&gt;math.pow(x,y)&lt;/code&gt; 를 &lt;code&gt;x^y&lt;/code&gt; 바꿀 수 있습니다 . &lt;code&gt;math.atan2&lt;/code&gt; 를 &lt;code&gt;math.atan&lt;/code&gt; 으로 바꿀 수 있으며 , 이제 하나 또는 두 개의 매개 변수를 허용합니다. &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; 를 &lt;code&gt;x * 2.0^exp&lt;/code&gt; 바꿀 수 있습니다 . 다른 작업의 경우 외부 라이브러리를 사용하거나 Lua에서 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">다음 문자열은 다른 토큰을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ba13fb8d8389b33ab088d4fc65f5ec35b8d33e18" translate="yes" xml:space="preserve">
          <source>The following syntactic sugar simplifies function definitions:</source>
          <target state="translated">다음과 같은 구문 설탕은 함수 정의를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="af2cb037b897b34b24d5a23238cf877011ea082c" translate="yes" xml:space="preserve">
          <source>The form</source>
          <target state="translated">형태</target>
        </trans-unit>
        <trans-unit id="7a0c21abdce99c6d3820ba447237185fd89bfedf" translate="yes" xml:space="preserve">
          <source>The formats &quot;&lt;code&gt;l&lt;/code&gt;&quot; and &quot;&lt;code&gt;L&lt;/code&gt;&quot; should be used only for text files.</source>
          <target state="translated">&quot; &lt;code&gt;l&lt;/code&gt; &quot;및 &quot; &lt;code&gt;L&lt;/code&gt; &quot; 형식 은 텍스트 파일에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd4c785119c8c33799dde8b20447ed83f6ee2b11" translate="yes" xml:space="preserve">
          <source>The fourth line is a string that, in a path in Windows, is replaced by the executable's directory. Default is '&lt;code&gt;!&lt;/code&gt;'.</source>
          <target state="translated">네 번째 줄은 Windows의 경로에서 실행 파일의 디렉토리로 대체되는 문자열입니다. 기본값은 ' &lt;code&gt;!&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="c4934c1b60689ce3f2c3bcb8e146450b0295d47d" translate="yes" xml:space="preserve">
          <source>The fourth searcher tries an &lt;em&gt;all-in-one loader&lt;/em&gt;. It searches the C path for a library for the root name of the given module. For instance, when requiring &lt;code&gt;a.b.c&lt;/code&gt;, it will search for a C library for &lt;code&gt;a&lt;/code&gt;. If found, it looks into it for an open function for the submodule; in our example, that would be &lt;code&gt;luaopen_a_b_c&lt;/code&gt;. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.</source>
          <target state="translated">네 번째 검색자는 &lt;em&gt;올인원 로더를&lt;/em&gt; 시도합니다 . 주어진 모듈의 루트 이름에 대한 라이브러리의 C 경로를 검색합니다. 이 필요한 경우 예를 들어, &lt;code&gt;a.b.c&lt;/code&gt; , 그것은을위한 C 라이브러리를 검색합니다 . 발견되면 하위 모듈에 대한 열린 기능을 찾습니다. 이 예에서는 &lt;code&gt;luaopen_a_b_c&lt;/code&gt; 입니다. 이 기능을 통해 패키지는 여러 개의 C 서브 모듈을 하나의 단일 라이브러리에 포장 할 수 있으며 각 서브 모듈은 원래의 열린 기능을 유지합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3fbd703ec3951b9eef95d2b7d4e3956a139b1f1" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. Larger values make the collector less aggressive. Values smaller than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle.</source>
          <target state="translated">가비지 콜렉터 일시 정지는 새주기를 시작하기 전에 콜렉터가 대기하는 시간을 제어합니다. 값이 클수록 수집기가 덜 공격적입니다. 100보다 작은 값은 수집기가 새주기를 시작하기를 기다리지 않음을 의미합니다. 값이 200이면 콜렉터는 새주기를 시작하기 전에 사용중인 총 메모리가 두 배가 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="3da0189eddd3acd188369ff8e9890d24f44cba07" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the relative speed of the collector relative to memory allocation. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values smaller than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default is 200, which means that the collector runs at &quot;twice&quot; the speed of memory allocation.</source>
          <target state="translated">가비지 수집기 단계 승수는 메모리 할당에 대한 수집기의 상대 속도를 제어합니다. 값이 클수록 콜렉터가 더 공격적이지만 각 증분 단계의 크기도 증가합니다. 콜렉터를 너무 느리게하여 콜렉터가주기를 완료하지 못하게 할 수 있으므로 100보다 작은 값을 사용하면 안됩니다. 기본값은 200이며, 이는 수집기가 메모리 할당 속도를 &quot;두 배&quot;로 실행 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9dc362bec1b0383d76bda32165a279742df9516d" translate="yes" xml:space="preserve">
          <source>The generational mode for the garbage collector was removed. (It was an experimental feature in Lua 5.2.)</source>
          <target state="translated">가비지 수집기의 생성 모드가 제거되었습니다. (루아 5.2의 실험 기능이었습니다.)</target>
        </trans-unit>
        <trans-unit id="3906554899c83e568ddf64f2f5b8f01161ffbe7d" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; statement works over functions, called &lt;em&gt;iterators&lt;/em&gt;. On each iteration, the iterator function is called to produce a new value, stopping when this new value is &lt;b&gt;nil&lt;/b&gt;. The generic &lt;b&gt;for&lt;/b&gt; loop has the following syntax:</source>
          <target state="translated">generic &lt;b&gt;for&lt;/b&gt; 문은 &lt;em&gt;iterators&lt;/em&gt; 라는 함수를 통해 작동 &lt;em&gt;합니다&lt;/em&gt; . 각 반복에서 반복자 함수가 호출되어 새 값을 생성하고이 새 값이 &lt;b&gt;nil 일&lt;/b&gt; 때 중지됩니다 . 일반 &lt;b&gt;for&lt;/b&gt; 루프는 다음과 같은 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="dd954aa3fd6697b79eaabbdef5d75d8c6c7ba3dc" translate="yes" xml:space="preserve">
          <source>The grammar could see it in two ways:</source>
          <target state="translated">문법은 두 가지 방법으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16256befb5f873dad0793713187bd7e83a270f1" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float with integral value used as a key is converted to its respective integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;. (On the other hand, 2 and &quot;&lt;code&gt;2&lt;/code&gt;&quot; are different Lua values and therefore denote different table entries.)</source>
          <target state="translated">테이블 인덱싱은 언어에서 원시 평등의 정의를 따릅니다. 표현식 &lt;code&gt;a[i]&lt;/code&gt; 및 &lt;code&gt;a[j]&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 가 원시 동등 (즉, 메타 메소드없이 동일) 인 경우에만 동일한 테이블 요소를 나타냅니다 . 특히, 정수 값을 가진 부동 소수점은 각각의 정수와 같습니다 (예 : &lt;code&gt;1.0 == 1&lt;/code&gt; ). 모호성을 피하기 위해 키로 사용되는 정수 값을 가진 모든 부동 소수점은 해당 정수로 변환됩니다. 예를 들어, &lt;code&gt;a[2.0] = true&lt;/code&gt; 를 쓰면 테이블에 삽입 된 실제 키는 정수 &lt;code&gt;2&lt;/code&gt; 가 됩니다. 반면에 2와 &quot; &lt;code&gt;2&lt;/code&gt; &quot;는 다른 Lua 값이므로 다른 테이블 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b21a8105ceb5ba09152263fc96b9536c63b0161" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys must not be used for other purposes.</source>
          <target state="translated">레지스트리의 정수 키는 참조 메커니즘 ( &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 참조 )과 일부 사전 정의 된 값에 의해 사용됩니다. 따라서 정수 키를 다른 용도로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9e586180c1379ce5751eba407cc18f08a9cdeaf0" translate="yes" xml:space="preserve">
          <source>The interaction between ranges and classes is not defined. Therefore, patterns like &lt;code&gt;[%a-z]&lt;/code&gt; or &lt;code&gt;[a-%%]&lt;/code&gt; have no meaning.</source>
          <target state="translated">범위와 클래스 간의 상호 작용은 정의되어 있지 않습니다. 따라서 &lt;code&gt;[%a-z]&lt;/code&gt; 또는 &lt;code&gt;[a-%%]&lt;/code&gt; 와 같은 패턴은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2c90b056889f7693fbb491e97825cdc7458b557" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding values are called &lt;em&gt;metamethods&lt;/em&gt;. In the previous example, the key is &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition.</source>
          <target state="translated">메타 테이블에서 각 이벤트의 키는 이벤트 이름이 두 개의 밑줄로 시작하는 문자열입니다. 해당 값을 &lt;em&gt;metamethods&lt;/em&gt; 라고 합니다. 이전 예에서 키는 &quot; &lt;code&gt;__add&lt;/code&gt; &quot;이고 메타 메소드는 추가를 수행하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a1e3c58922162233ff6ef255d5df925e8da6f663" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte).</source>
          <target state="translated">문자열의 길이는 바이트 수 (즉, 각 문자가 1 바이트 일 때 문자열 길이의 일반적인 의미)입니다.</target>
        </trans-unit>
        <trans-unit id="01dac97eea86a239bf3254b898850f4681c59248" translate="yes" xml:space="preserve">
          <source>The length operator applied on a table returns a border in that table. A &lt;em&gt;border&lt;/em&gt; in a table &lt;code&gt;t&lt;/code&gt; is any natural number that satisfies the following condition:</source>
          <target state="translated">테이블에 적용된 길이 연산자는 해당 테이블의 테두리를 반환합니다. 표 &lt;code&gt;t&lt;/code&gt; 의 &lt;em&gt;경계&lt;/em&gt; 는 다음 조건을 만족하는 자연수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0004633e5acb8c29842421799433ea833432d7" translate="yes" xml:space="preserve">
          <source>The length operator is denoted by the unary prefix operator &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">길이 연산자는 단항 접두사 연산자 &lt;code&gt;#&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="13a462f71ac26baf154dba8703e365c0df2ac20a" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;).</source>
          <target state="translated">라이브러리 함수 &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 은 주어진 값의 유형을 설명하는 문자열을 반환합니다 ( &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6144a62a4a0e6d0612f6eb91c540d8aa8bcf7d08" translate="yes" xml:space="preserve">
          <source>The logical operators in Lua are &lt;b&gt;and&lt;/b&gt;, &lt;b&gt;or&lt;/b&gt;, and &lt;b&gt;not&lt;/b&gt;. Like the control structures (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;), all logical operators consider both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; as false and anything else as true.</source>
          <target state="translated">루아에서 논리 연산자는 &lt;b&gt;와&lt;/b&gt; , &lt;b&gt;나&lt;/b&gt; , 그리고 &lt;b&gt;없습니다&lt;/b&gt; . 제어 구조 ( &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; 참조 ) 와 마찬가지로 모든 논리 연산자는 &lt;b&gt;false&lt;/b&gt; 와 &lt;b&gt;nil&lt;/b&gt; 을 모두 &lt;b&gt;false로&lt;/b&gt; 간주 하고 다른 것을 true로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="50f9701ab78d887f6625cde402aefbda0aeac6cc" translate="yes" xml:space="preserve">
          <source>The loop creates ten closures (that is, ten instances of the anonymous function). Each of these closures uses a different &lt;code&gt;y&lt;/code&gt; variable, while all of them share the same &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">루프는 10 개의 클로저 (즉, 익명 함수의 10 개의 인스턴스)를 만듭니다. 이러한 클로저는 서로 다른 &lt;code&gt;y&lt;/code&gt; 변수를 사용하지만 모두 같은 &lt;code&gt;x&lt;/code&gt; 를 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="4fdc614cc4ad6f49d0283a9ba3115c9056932e8c" translate="yes" xml:space="preserve">
          <source>The loop variable &lt;code&gt;v&lt;/code&gt; is local to the loop body. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">루프 변수 &lt;code&gt;v&lt;/code&gt; 는 루프 본문에 대해 로컬입니다. 루프 다음에 값이 필요한 경우 루프를 종료하기 전에 다른 변수에 값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="939c85d0694beae03ef42c252fc95eeaad38dd40" translate="yes" xml:space="preserve">
          <source>The loop variables &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; are local to the loop; you cannot use their values after the &lt;b&gt;for&lt;/b&gt; ends. If you need these values, then assign them to other variables before breaking or exiting the loop.</source>
          <target state="translated">루프 변수 &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; 는 루프에 대해 로컬입니다. &lt;b&gt;for&lt;/b&gt; 종료 후에는 값을 사용할 수 없습니다 . 이 값이 필요한 경우 루프를 끊거나 종료하기 전에 다른 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b244dd1c7e2205379de1905e2e723510ea200bac" translate="yes" xml:space="preserve">
          <source>The main difference between Lua 5.2 and Lua 5.3 is the introduction of an integer subtype for numbers. Although this change should not affect &quot;normal&quot; computations, some computations (mainly those that involve some kind of overflow) can give different results.</source>
          <target state="translated">Lua 5.2와 Lua 5.3의 주요 차이점은 숫자에 대한 정수 하위 유형의 도입입니다. 이 변경은 &quot;정상&quot;계산에는 영향을 미치지 않지만 일부 계산 (주로 어떤 종류의 오버플로가 포함 된 계산)은 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc3afb9da0c5e976f755e7c1da0bc9514acc6c24" translate="yes" xml:space="preserve">
          <source>The maximum value for &lt;code&gt;n&lt;/code&gt; is 255.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 최대 값 은 255입니다.</target>
        </trans-unit>
        <trans-unit id="ab795f1f93d86887860588306bf3a809576817cd" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables. An access to an indexed variable &lt;code&gt;t[i]&lt;/code&gt; is equivalent to a call &lt;code&gt;gettable_event(t,i)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;gettable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">테이블 필드에 대한 액세스의 의미는 메타 테이블을 통해 변경할 수 있습니다. 색인화 된 변수 &lt;code&gt;t[i]&lt;/code&gt; 대한 액세스 는 &lt;code&gt;gettable_event(t,i)&lt;/code&gt; 호출과 같습니다 . ( &lt;code&gt;gettable_event&lt;/code&gt; 함수에 대한 자세한 설명은 &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 를 참조하십시오 .이 함수는 Lua에서 정의하거나 호출 할 수 없습니다. 여기서는 설명 목적으로 만 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="51f3fb78699ea2b9989d6abd1980c0cbe4cf6630" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable &lt;code&gt;t[i] = val&lt;/code&gt; is equivalent to &lt;code&gt;settable_event(t,i,val)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;settable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">전역 변수 및 테이블 필드에 대한 할당의 의미는 메타 테이블을 통해 변경할 수 있습니다. 색인화 된 변수 &lt;code&gt;t[i] = val&lt;/code&gt; 대한 지정 은 &lt;code&gt;settable_event(t,i,val)&lt;/code&gt; 과 동일합니다 . ( &lt;code&gt;settable_event&lt;/code&gt; 함수에 대한 자세한 설명은 &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 를 참조하십시오 .이 함수는 Lua에서 정의하거나 호출 할 수 없습니다. 여기서는 설명 목적으로 만 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="e0fe8ffeb58ed09038372ff537610ec6335cea78" translate="yes" xml:space="preserve">
          <source>The negation operator &lt;b&gt;not&lt;/b&gt; always returns &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;. The conjunction operator &lt;b&gt;and&lt;/b&gt; returns its first argument if this value is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;; otherwise, &lt;b&gt;and&lt;/b&gt; returns its second argument. The disjunction operator &lt;b&gt;or&lt;/b&gt; returns its first argument if this value is different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;; otherwise, &lt;b&gt;or&lt;/b&gt; returns its second argument. Both &lt;b&gt;and&lt;/b&gt; and &lt;b&gt;or&lt;/b&gt; use short-circuit evaluation; that is, the second operand is evaluated only if necessary. Here are some examples:</source>
          <target state="translated">부정 연산자 &lt;b&gt;가&lt;/b&gt; 항상 &lt;b&gt;false&lt;/b&gt; 또는 &lt;b&gt;true를&lt;/b&gt; 반환 &lt;b&gt;하지는 않습니다&lt;/b&gt; . 연계 연산자 &lt;b&gt;하고&lt;/b&gt; 이 값이 경우 첫 번째 인자를 반환 &lt;b&gt;거짓&lt;/b&gt; 또는 &lt;b&gt;닐&lt;/b&gt; ; 그렇지 않으면 &lt;b&gt;및&lt;/b&gt; 반환의 두 번째 인수를. 이 값이 &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 와 다른 경우 분리 연산자 &lt;b&gt;또는&lt;/b&gt; 첫 번째 인수를 리턴합니다 . 그렇지 않은 경우, &lt;b&gt;또는&lt;/b&gt; 반환의 두 번째 인수를. 모두 &lt;b&gt;와&lt;/b&gt; 및 &lt;b&gt;또는&lt;/b&gt; 사용 단락 회로 평가; 즉, 두 번째 피연산자는 필요한 경우에만 평가됩니다. 여기 몇 가지 예가 있어요.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="38ec12da384a6d35f4d20d38b437d28efd6741c1" translate="yes" xml:space="preserve">
          <source>The next example collects all pairs &lt;code&gt;key=value&lt;/code&gt; from the given string into a table:</source>
          <target state="translated">다음 예제는 주어진 문자열에서 모든 쌍의 &lt;code&gt;key=value&lt;/code&gt; 를 테이블로 수집 합니다.</target>
        </trans-unit>
        <trans-unit id="eb025962461d05ecdc613ae74134730113e392ef" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">숫자 &lt;b&gt;for&lt;/b&gt; 루프는 제어 변수가 산술 진행을하는 동안 코드 블록을 반복합니다. 다음과 같은 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ab43bf243843bc19a105d07ba039f8f3f1779b" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~=&lt;/code&gt; is exactly the negation of equality (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">연산자 &lt;code&gt;~=&lt;/code&gt; 는 정확히 동등성 부정 ( &lt;code&gt;==&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0e99c83b2c086ff1b9d5a58745baab04d9e1b8a" translate="yes" xml:space="preserve">
          <source>The order in which the indices are enumerated is not specified, &lt;em&gt;even for numeric indices&lt;/em&gt;. (To traverse a table in numerical order, use a numerical &lt;b&gt;for&lt;/b&gt;.)</source>
          <target state="translated">&lt;em&gt;숫자 인덱스의 경우에도&lt;/em&gt; 인덱스가 열거되는 순서는 지정되지 않습니다 . (숫자 사용, 번호 순서대로 테이블을 통과하려면 &lt;b&gt;를 들어&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="30b30ff9b28bb0a62b9d5eaa0e7b9c185acec6fd" translate="yes" xml:space="preserve">
          <source>The order of the assignments in a constructor is undefined. (This order would be relevant only when there are repeated keys.)</source>
          <target state="translated">생성자에서 할당 순서는 정의되어 있지 않습니다. (이 순서는 반복되는 키가있는 경우에만 관련이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e03d986c8e2482e4650648398c1e744ca72bdc4f" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values (regardless of their subtypes). Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &quot;lt&quot; or the &quot;le&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">주문 연산자는 다음과 같이 작동합니다. 두 인수가 모두 숫자 인 경우 하위 유형에 관계없이 수학 값에 따라 비교됩니다. 그렇지 않으면 두 인수가 모두 문자열 인 경우 현재 로케일에 따라 해당 값이 비교됩니다. 그렇지 않으면 Lua는 &quot;lt&quot;또는 &quot;le&quot;메타 메소드를 호출하려고합니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 비교 용 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt; a&lt;/code&gt; 및 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt;= a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0cda038c86954689aa106e41f099cb177ac64c" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in a table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 라이브러리는 Lua에서 모듈을로드하기위한 기본 기능을 제공합니다. 전역 환경에서 하나의 함수를 직접 내 보냅니다. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; . 다른 모든 것은 테이블 &lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="31abba930e733e4da53e00b6f03a89251bd121d5" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is at the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">패닉 함수는 마치 메시지 핸들러 인 것처럼 실행됩니다 ( &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt; 참조 ). 특히 오류 개체는 스택의 맨 위에 있습니다. 그러나 스택 공간에 대한 보장은 없습니다. 스택에있는 것을 밀려면 패닉 기능이 먼저 사용 가능한 공간을 확인해야합니다 ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="248c6c24d6328dcec1eced4a5902bd1ca25c30a6" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua parameter to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">이름에서 알 수 있듯이 공황 기능은 최후의 수단입니다. 프로그램은 피해야합니다. 일반적으로 Lua 상태의 Lua에서 C 함수를 호출하면 이미 보호되어 있어야하므로 해당 Lua 상태에서 원하는 모든 작업을 수행 할 수 있습니다. 그러나 C 코드가 다른 Lua 상태 (예 : 함수에 대한 Lua 매개 변수, 레지스트리에 저장된 Lua 상태 또는 &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; 의 결과 )에서 작동하는 경우 오류를 발생시킬 수없는 API 호출에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af1c6d6c99e2e0d628fe3fc7ee1c5062d171bd6d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;f&lt;/code&gt; may also be a function. In that case, &lt;code&gt;getlocal&lt;/code&gt; returns only the name of function parameters.</source>
          <target state="translated">파라미터 &lt;code&gt;f&lt;/code&gt; 는 또한 함수일 수있다. 이 경우 &lt;code&gt;getlocal&lt;/code&gt; 은 함수 매개 변수 이름 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ee0f1d943cdb63fea614a28b80243ba707db6c6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;from&lt;/code&gt; represents the coroutine that is resuming &lt;code&gt;L&lt;/code&gt;. If there is no such coroutine, this parameter can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 매개 변수 는 &lt;code&gt;L&lt;/code&gt; 을 재개하는 코 루틴을 나타냅니다 . 그러한 코 루틴이 없으면이 매개 변수는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65650656d52c148c40e15fc089970d7544c3c111" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="translated">에서 사용하는 경로는 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 는 C 로더를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a62c3b69148e7d0643526b28757764d931f17eab" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="translated">에서 사용하는 경로는 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 루아 로더를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5695907c31c4cdbe5adbf65f538570d9f4bbc4f" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">정확히 하나의 UTF-8 바이트 시퀀스와 일치 하는 패턴 (함수가 아닌 문자열) &quot; &lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt; &quot;( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ), 주제가 유효한 UTF-8 문자열이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="94196df3b0309cd7d7af8dbae4fe9b55da3dd1ee" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time it needs another piece of the chunk, &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 가&lt;/a&gt; 사용하는 리더 기능 . 다른 청크 조각이 필요할 때마다 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;data&lt;/code&gt; 매개 변수를 전달하여 리더를 호출합니다 . 리더는 새로운 청크 조각을 가진 메모리 블록에 대한 포인터를 반환하고 &lt;code&gt;size&lt;/code&gt; 를 블록 크기로 설정 해야합니다. 리더 기능이 다시 호출 될 때까지 블록이 존재해야합니다. 청크의 끝을 알리려면 리더에서 &lt;code&gt;NULL&lt;/code&gt; 을 반환 하거나 &lt;code&gt;size&lt;/code&gt; 를 0으로 설정 해야합니다 . 리더 함수는 0보다 큰 크기의 조각을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f620be9ce9c46f8c6dc3707673277eb2ba004c" translate="yes" xml:space="preserve">
          <source>The return values of &lt;code&gt;lua_load&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 의 반환 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b6bd9b2d65f7c99bb3fd044a11a11e501baf7b6" translate="yes" xml:space="preserve">
          <source>The returned table can contain all the fields returned by &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;, with the string &lt;code&gt;what&lt;/code&gt; describing which fields to fill in. The default for &lt;code&gt;what&lt;/code&gt; is to get all information available, except the table of valid lines. If present, the option '&lt;code&gt;f&lt;/code&gt;' adds a field named &lt;code&gt;func&lt;/code&gt; with the function itself. If present, the option '&lt;code&gt;L&lt;/code&gt;' adds a field named &lt;code&gt;activelines&lt;/code&gt; with the table of valid lines.</source>
          <target state="translated">반환되는 표에 의해 반환 된 모든 필드를 포함 할 수 있습니다 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; 를&lt;/a&gt; 문자열로, &lt;code&gt;what&lt;/code&gt; 입력란에 정보를 입력 설명을. 기본 &lt;code&gt;what&lt;/code&gt; 유효 라인의 테이블을 제외한 모든 정보를 사용할 수하는 것입니다. ' &lt;code&gt;f&lt;/code&gt; ' 옵션이 있으면 함수 자체와 함께 &lt;code&gt;func&lt;/code&gt; 라는 필드를 추가 합니다. 존재하는 경우 옵션 ' &lt;code&gt;L&lt;/code&gt; ' 은 유효한 행 테이블과 함께 &lt;code&gt;activelines&lt;/code&gt; 라는 필드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f55f8b6574e5379a6bf6381df42f2bd48b5ec87a" translate="yes" xml:space="preserve">
          <source>The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the &quot;epoch&quot;). In other systems, the meaning is not specified, and the number returned by &lt;code&gt;time&lt;/code&gt; can be used only as an argument to &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-os.difftime&quot;&gt;&lt;code&gt;os.difftime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴되는 값은 숫자이며 시스템의 의미는 시스템에 따라 다릅니다. POSIX, Windows 및 일부 다른 시스템에서이 숫자는 특정 시작 시간 ( &quot;에포크 (epoch)&quot;) 이후의 시간 (초)을 계산합니다. 다른 시스템에서는 의미가 지정되어 있지 않으며 &lt;code&gt;time&lt;/code&gt; 의해 반환되는 숫자는 &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-os.difftime&quot;&gt; &lt;code&gt;os.difftime&lt;/code&gt; 에&lt;/a&gt; 대한 인수로만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfbc7fd540fdc9556b78c0aa760e8e168374c2f5" translate="yes" xml:space="preserve">
          <source>The searcher for C loaders used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; changed the way it handles versioned names. Now, the version should come after the module name (as is usual in most other tools). For compatibility, that searcher still tries the old format if it cannot find an open function according to the new style. (Lua 5.2 already worked that way, but it did not document the change.)</source>
          <target state="translated">C 로더를 사용하는 검색자는 버전이 지정된 이름을 처리하는 방식을 변경 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 합니다. 이제 버전은 모듈 이름 뒤에 와야합니다 (대부분의 다른 도구에서 일반적으로 사용됨). 호환성을 위해 검색자는 새 스타일에 따라 열린 함수를 찾을 수없는 경우 여전히 이전 형식을 시도합니다. (Lua 5.2는 이미 그렇게 작동했지만 변경 내용을 문서화하지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="d15f5fb6601ee9ab09f9a53d09100cffc80fdb3d" translate="yes" xml:space="preserve">
          <source>The second line is the character that separates templates in a path. Default is '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">두 번째 줄은 경로에서 템플릿을 구분하는 문자입니다. 기본값은 ' &lt;code&gt;;&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="98a2720d48fa26f6e8827171e22966063e194996" translate="yes" xml:space="preserve">
          <source>The second searcher looks for a loader as a Lua library, using the path stored at &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. The search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 번째 검색자는 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 에&lt;/a&gt; 저장된 경로를 사용하여 로더를 Lua 라이브러리로 찾습니다 . &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; 함수에 설명 된대로 검색이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff10cde6ef36b0ce8ea3feff1924805fea5410a7" translate="yes" xml:space="preserve">
          <source>The sort algorithm is not stable: elements considered equal by the given order may have their relative positions changed by the sort.</source>
          <target state="translated">정렬 알고리즘이 안정적이지 않습니다. 주어진 순서에 따라 동일하다고 간주되는 요소는 정렬에 의해 상대 위치가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5106e7eaf9b7ca3b362e6dc6b36e589c34ea6d05" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to &quot;outside&quot; services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">표준 Lua 라이브러리는 C API를 통해 직접 구현되는 유용한 기능을 제공합니다. 이러한 기능 중 일부는 언어에 필수적인 서비스를 제공합니다 (예 : &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; ). 다른 사람들은 &quot;외부&quot;서비스 (예 : I / O)에 대한 액세스를 제공합니다. 다른 것들도 Lua 자체로 구현 될 수 있지만 C로 구현할 가치가있는 매우 유용하거나 중요한 성능 요구 사항이 있습니다 (예 : &lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f42f392bd799378902334c3d54a3414a4cf4d102" translate="yes" xml:space="preserve">
          <source>The standard paths in the official distribution may change between versions.</source>
          <target state="translated">공식 배포판의 표준 경로는 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb7020ccdbf4af39d9ada89f1f68b18c849ca42e" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles, which is used by the standard I/O library.</source>
          <target state="translated">표준 I / O 라이브러리에서 사용되는 파일 핸들의 표준 표현입니다.</target>
        </trans-unit>
        <trans-unit id="9fd3499f821fa1f3548e8129d6b35f2161cdaff1" translate="yes" xml:space="preserve">
          <source>The statement</source>
          <target state="translated">진술</target>
        </trans-unit>
        <trans-unit id="b51c68cae2ce99f1a793fe977a6ed087cdabd1ba" translate="yes" xml:space="preserve">
          <source>The status can be 0 (&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;) for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">일반 스레드 의 경우 상태는 0 ( &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ), 스레드 가 오류와 함께 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 의 실행을 완료 한 경우 오류 코드 또는 스레드가 일시 중단 된 경우 &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; 일&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6107c417c0095d03331e66cca35b7fc41f404ee" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string &quot;&lt;code&gt;b&lt;/code&gt;&quot; (only binary chunks), &quot;&lt;code&gt;t&lt;/code&gt;&quot; (only text chunks), or &quot;&lt;code&gt;bt&lt;/code&gt;&quot; (both binary and text). The default is &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">문자열 &lt;code&gt;mode&lt;/code&gt; 는 청크가 텍스트 또는 이진일 수 있는지 (즉, 사전 컴파일 된 청크)를 제어합니다. 문자열 &quot; &lt;code&gt;b&lt;/code&gt; &quot;(이진 청크 만), &quot; &lt;code&gt;t&lt;/code&gt; &quot;(텍스트 청크 만) 또는 &quot; &lt;code&gt;bt&lt;/code&gt; &quot;(이진 및 텍스트) 일 수 있습니다. 기본값은 &quot; &lt;code&gt;bt&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="eb61b3491c7ef29459d2f5f3b4868e8b5f23f56b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8627952ee0ea9e9e84752d1eff85ae25a6b8cff5" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then they are converted to strings according to the rules described in &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;. Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">루아의 문자열 연결 연산자는 두 개의 점 ( ' &lt;code&gt;..&lt;/code&gt; ')으로 표시됩니다. 두 피연산자가 모두 문자열이거나 숫자이면 &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3에&lt;/a&gt; 설명 된 규칙에 따라 문자열로 변환됩니다 . 그렇지 않으면 &lt;code&gt;__concat&lt;/code&gt; 메타 메소드가 호출됩니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9045fd903c161a4ac7a29583b9b8dcf0e5541479" translate="yes" xml:space="preserve">
          <source>The string library assumes one-byte character encodings.</source>
          <target state="translated">문자열 라이브러리는 1 바이트 문자 인코딩을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b2b7ec0f9126a815843a8b6eedc7a7a4064d3eb8" translate="yes" xml:space="preserve">
          <source>The string library provides all its functions inside the table &lt;a id=&quot;pdf-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. It also sets a metatable for strings where the &lt;code&gt;__index&lt;/code&gt; field points to the &lt;code&gt;string&lt;/code&gt; table. Therefore, you can use the string functions in object-oriented style. For instance, &lt;code&gt;string.byte(s,i)&lt;/code&gt; can be written as &lt;code&gt;s:byte(i)&lt;/code&gt;.</source>
          <target state="translated">문자열 라이브러리는 테이블 &lt;a id=&quot;pdf-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 안에 모든 기능을 제공 합니다 . 또한 &lt;code&gt;__index&lt;/code&gt; 필드가 &lt;code&gt;string&lt;/code&gt; 테이블을 가리키는 문자열에 대한 메타 테이블을 설정 합니다. 따라서 문자열 함수를 객체 지향 스타일로 사용할 수 있습니다. 예를 들어 &lt;code&gt;string.byte(s,i)&lt;/code&gt; 는 &lt;code&gt;s:byte(i)&lt;/code&gt; 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10a50517543fae51ebb08fb2ec16c2bc73963b6e" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var.Name&lt;/code&gt; is just syntactic sugar for &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt;:</source>
          <target state="translated">구문 &lt;code&gt;var.Name&lt;/code&gt; 은 &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt; 의 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="050ff8b5782f01590c86d4091d6bf58f847c8377" translate="yes" xml:space="preserve">
          <source>The syntax for function definition is</source>
          <target state="translated">함수 정의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="632eb45dbc253afb0e4d9a6d182579e0f0a1fc32" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;io&lt;/code&gt; also provides three predefined file handles with their usual meanings from C: &lt;a id=&quot;pdf-io.stdin&quot;&gt;&lt;code&gt;io.stdin&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-io.stdout&quot;&gt;&lt;code&gt;io.stdout&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-io.stderr&quot;&gt;&lt;code&gt;io.stderr&lt;/code&gt;&lt;/a&gt;. The I/O library never closes these files.</source>
          <target state="translated">표 &lt;code&gt;io&lt;/code&gt; 는 또한 C에서 일반적으로 의미하는 &lt;a id=&quot;pdf-io.stdin&quot;&gt; &lt;code&gt;io.stdin&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-io.stdout&quot;&gt; &lt;code&gt;io.stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-io.stderr&quot;&gt; &lt;code&gt;io.stderr&lt;/code&gt; 의&lt;/a&gt; 세 가지 사전 정의 된 파일 핸들을 제공합니다 . I / O 라이브러리는 이러한 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5bb6863eedf039eb3411f3dbe0637455e54c4cb" translate="yes" xml:space="preserve">
          <source>The third line is the string that marks the substitution points in a template. Default is '&lt;code&gt;?&lt;/code&gt;'.</source>
          <target state="translated">세 번째 줄은 템플릿에서 대체 지점을 표시하는 문자열입니다. 기본값은 ' &lt;code&gt;?&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="2123107d9c2b8fa74113fcb8969ea618ea87943f" translate="yes" xml:space="preserve">
          <source>The third searcher looks for a loader as a C library, using the path given by the variable &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. Again, the search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. For instance, if the C path is the string</source>
          <target state="translated">세 번째 검색자는 변수 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; 가&lt;/a&gt; 제공 한 경로를 사용하여 로더를 C 라이브러리로 찾습니다 . 다시 &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; 함수에 설명 된대로 검색이 수행됩니다 . 예를 들어 C 경로가 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="8accc1fdc3658380909273543cc837dcd9d22775" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; uses two internal representations, or two subtypes, one called &lt;em&gt;integer&lt;/em&gt; and the other called &lt;em&gt;float&lt;/em&gt;. Lua has explicit rules about when each representation is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">유형 &lt;em&gt;번호&lt;/em&gt; 는 두 개의 내부 표현 또는 두 개의 하위 유형 (하나는 &lt;em&gt;정수&lt;/em&gt; , 다른 하나는 &lt;em&gt;float)을 사용&lt;/em&gt; 합니다. Lua에는 각 표현이 사용되는시기에 대한 명시적인 규칙이 있지만 필요에 따라 자동으로 변환합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 따라서 프로그래머는 정수와 부동 소수점의 차이를 대부분 무시하거나 각 숫자의 표현을 완전히 제어한다고 가정 할 수 있습니다. 표준 Lua는 64 비트 정수와 배정 밀도 (64 비트) 부동 소수점을 사용하지만 32 비트 정수 및 / 또는 단 정밀도 (32 비트) 부동 소수점을 사용하도록 Lua를 컴파일 할 수도 있습니다. 정수 및 부동 소수점 모두 32 비트 옵션은 특히 소형 기계 및 임베디드 시스템에 적합합니다. (매크로 참조 &lt;code&gt;LUA_32BITS&lt;/code&gt; 파일의 &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="afb6b5b3a4f6e457499e2efa89d3127e8a5239e3" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special value used to represent undefined or unrepresentable numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key with value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">유형 &lt;em&gt;테이블&lt;/em&gt; 은 연관 배열, 즉 숫자뿐 아니라 &lt;b&gt;nil&lt;/b&gt; 및 NaN을 제외한 Lua 값으로 색인을 생성 할 수있는 배열을 구현 합니다. ( &lt;em&gt;아니 번호&lt;/em&gt; 와 같은 정의하거나 표현할 수없는 수치 결과를 나타내는 데 사용되는 특수한 값 &lt;code&gt;0/0&lt;/code&gt; ). 테이블 일 수 &lt;em&gt;이종&lt;/em&gt; ; 즉, 모든 유형의 값을 포함 할 수 있습니다 ( &lt;b&gt;nil&lt;/b&gt; 제외 ). 값이 &lt;b&gt;nil 인&lt;/b&gt; 키 는 테이블의 일부로 간주되지 않습니다. 반대로, 테이블의 일부가 아닌 키는 연관된 값 &lt;b&gt;nil을&lt;/b&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4d9440269930bed052fd86cfbac01a1a963271db" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;thread&lt;/em&gt; represents independent threads of execution and it is used to implement coroutines (see &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt;). Lua threads are not related to operating-system threads. Lua supports coroutines on all systems, even those that do not support threads natively.</source>
          <target state="translated">타입 &lt;em&gt;스레드&lt;/em&gt; 는 독립적 인 실행 &lt;em&gt;스레드를&lt;/em&gt; 나타내며 코 루틴을 구현하는 데 사용됩니다 ( &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; 참조 ). Lua 스레드는 운영 체제 스레드와 관련이 없습니다. Lua는 스레드를 기본적으로 지원하지 않는 시스템을 포함하여 모든 시스템에서 코 루틴을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="549971961a231ddc4a1edb8a913953e6d0ac1c5d" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program.</source>
          <target state="translated">&lt;em&gt;userdata&lt;/em&gt; 유형 은 임의의 C 데이터를 Lua 변수에 저장할 수 있도록 제공됩니다. userdata 값은 원시 메모리 블록을 나타냅니다. : UserData를 두 종류가있다 &lt;em&gt;전체 유저 데이터&lt;/em&gt; 루아에 의해 관리되는 메모리 블록과 함께 목적, &lt;em&gt;광 UserData를&lt;/em&gt; 단순히 C 포인터 값이다. 사용자 데이터는 할당 및 신원 테스트를 제외하고 Lua에서 사전 정의 된 작업이 없습니다. &lt;em&gt;메타 테이블&lt;/em&gt; 을 사용 하여 프로그래머는 전체 사용자 데이터 값에 대한 작업을 정의 할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). C API를 통해서만 Lua에서 사용자 데이터 값을 만들거나 수정할 수 없습니다. 이것은 호스트 프로그램이 소유 한 데이터의 무결성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="cb2dae663cd0b88537f77f62b52ecd0fdceb5eb7" translate="yes" xml:space="preserve">
          <source>The type for continuation-function contexts. It must be a numeric type. This type is defined as &lt;code&gt;intptr_t&lt;/code&gt; when &lt;code&gt;intptr_t&lt;/code&gt; is available, so that it can store pointers too. Otherwise, it is defined as &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">연속 함수 컨텍스트의 유형입니다. 숫자 유형이어야합니다. 이 유형은 다음과 같이 정의된다 &lt;code&gt;intptr_t&lt;/code&gt; 때 &lt;code&gt;intptr_t&lt;/code&gt; 이 너무 포인터를 저장할 수 그래서, 사용할 수 있습니다. 그렇지 않으면 &lt;code&gt;ptrdiff_t&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b81ea3cf634f923ceea25ead913b80cfce712bbf" translate="yes" xml:space="preserve">
          <source>The type of floats in Lua.</source>
          <target state="translated">루아의 수레 유형.</target>
        </trans-unit>
        <trans-unit id="7bd0bf99561dfbd918dc1bdb99594d59c184307f" translate="yes" xml:space="preserve">
          <source>The type of integers in Lua.</source>
          <target state="translated">루아의 정수 유형.</target>
        </trans-unit>
        <trans-unit id="f3373938fcc3069867ceda08c5889260b4eb48bd" translate="yes" xml:space="preserve">
          <source>The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to &lt;code&gt;realloc&lt;/code&gt;, but not exactly the same. Its arguments are &lt;code&gt;ud&lt;/code&gt;, an opaque pointer passed to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;ptr&lt;/code&gt;, a pointer to the block being allocated/reallocated/freed; &lt;code&gt;osize&lt;/code&gt;, the original size of the block or some code about what is being allocated; and &lt;code&gt;nsize&lt;/code&gt;, the new size of the block.</source>
          <target state="translated">루아 상태에서 사용하는 메모리 할당 기능의 유형입니다. 할당 자 함수는 &lt;code&gt;realloc&lt;/code&gt; 과 유사 하지만 정확히 동일하지는 않은 기능을 제공해야합니다 . 인수는 &lt;code&gt;ud&lt;/code&gt; , &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; 에&lt;/a&gt; 전달되는 불투명 포인터입니다 . &lt;code&gt;ptr&lt;/code&gt; , 할당 / 재 할당 / 해제되는 블록에 대한 포인터; &lt;code&gt;osize&lt;/code&gt; , 블록의 원래 크기 또는 할당 대상에 대한 일부 코드; 및 &lt;code&gt;nsize&lt;/code&gt; , 블록의 새 크기를.</target>
        </trans-unit>
        <trans-unit id="ea2467b4ef42d2fed95d1a97e4a127587c63bf40" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time it produces another piece of chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;data&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 가&lt;/a&gt; 사용하는 라이터 함수의 유형입니다 . 또 다른 청크 조각을 생성 할 때마다 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 는 기록기를 버퍼 ( &lt;code&gt;p&lt;/code&gt; ), 크기 ( &lt;code&gt;sz&lt;/code&gt; ) 및 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 에&lt;/a&gt; 제공된 &lt;code&gt;data&lt;/code&gt; 매개 변수를 전달 하여 기록기 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="979b7ad2557665ac8c789bc0692eee0412bef53c" translate="yes" xml:space="preserve">
          <source>The unit of compilation of Lua is called a &lt;em&gt;chunk&lt;/em&gt;. Syntactically, a chunk is simply a block:</source>
          <target state="translated">루아의 컴파일 단위를 &lt;em&gt;청크&lt;/em&gt; 라고합니다 . 문법적으로 덩어리는 단순히 블록입니다.</target>
        </trans-unit>
        <trans-unit id="1fd90de9694cbc90328b75bdffaf97623ca0a9b7" translate="yes" xml:space="preserve">
          <source>The unsigned version of &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서명되지 않은 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="ea5edb4c646d2befa84cf3aa4de94da00e72b361" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;op&lt;/code&gt; must be one of the following constants:</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 의 값은 다음 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="afade59d4e86a697bf216612fdf19b790b49ed5e" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;&amp;pi;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&amp;pi;&lt;/em&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9dc3bab908539601286c9612ae1893b48ba8219b" translate="yes" xml:space="preserve">
          <source>The value returned is the error code returned by the last call to the writer; 0 means no errors.</source>
          <target state="translated">반환 된 값은 마지막으로 기록기를 호출하여 반환 된 오류 코드입니다. 0은 오류가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="112b2baa6655f11d826fd17791c335badbd32d34" translate="yes" xml:space="preserve">
          <source>The values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means -10 seconds from the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means +1000 hours from the time specified by the other fields.</source>
          <target state="translated">이 필드의 값이 유효한 범위 내에있을 필요는 없습니다. 예를 들어, &lt;code&gt;sec&lt;/code&gt; 가 -10이면 다른 필드에서 지정한 시간에서 -10 초를 의미합니다. 만약 &lt;code&gt;hour&lt;/code&gt; (1000)이며, 그것은 다른 필드에 의해 지정된 시간에서 1천시간을 의미한다.</target>
        </trans-unit>
        <trans-unit id="a99a66eb862f6556290fc79e5e1c7450f919252a" translate="yes" xml:space="preserve">
          <source>The visibility rules for local variables are explained in &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;.</source>
          <target state="translated">지역 변수에 대한 가시성 규칙은 &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1638bbae2e91cad1bcbf2314b579efab5e69fee7" translate="yes" xml:space="preserve">
          <source>The writer returns an error code: 0 means no errors; any other value means an error and stops &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; from calling the writer again.</source>
          <target state="translated">기록기는 오류 코드를 반환합니다. 0은 오류가 없음을 의미합니다. 다른 값은 오류를 의미하며 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 가 기록기를 다시 호출하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="e53998e37ed2ba9b38d4b4c370361cd1f8e85f86" translate="yes" xml:space="preserve">
          <source>Then add string pieces to the buffer calling any of the &lt;code&gt;luaL_add*&lt;/code&gt; functions.</source>
          <target state="translated">그런 다음 &lt;code&gt;luaL_add*&lt;/code&gt; 함수를 호출하여 문자열 조각을 버퍼에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d5ea479608da6d358fd4117e4c1650306f8953" translate="yes" xml:space="preserve">
          <source>Then copy the string into that space.</source>
          <target state="translated">그런 다음 문자열을 해당 공간에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="c38aad0ad68cbec114bc022549a75392e5ff942b" translate="yes" xml:space="preserve">
          <source>Then initialize it and preallocate a space of size &lt;code&gt;sz&lt;/code&gt; with a call &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 그것을 초기화하고 &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt; 호출로 &lt;code&gt;sz&lt;/code&gt; 크기의 공간을 미리 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fde5c748e0c5d875fb24467538da27e6356bfa2" translate="yes" xml:space="preserve">
          <source>Then initialize it with a call &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt; 호출로 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c089f6502b4ba313710d9bbf20645416ed3a409" translate="yes" xml:space="preserve">
          <source>Then, we have the following mapping from arguments to parameters and to the vararg expression:</source>
          <target state="translated">그런 다음 인수에서 매개 변수 및 vararg 표현식으로 다음과 같은 맵핑이 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f15568d44d3dd2fb189f12b0a139775af30148" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it usually represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; any other value makes it true. The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers. The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string.</source>
          <target state="translated">Lua에는 &lt;em&gt;nil&lt;/em&gt; , &lt;em&gt;boolean&lt;/em&gt; , &lt;em&gt;number&lt;/em&gt; , &lt;em&gt;string&lt;/em&gt; , &lt;em&gt;function&lt;/em&gt; , &lt;em&gt;userdata&lt;/em&gt; , &lt;em&gt;thread&lt;/em&gt; 및 &lt;em&gt;table의&lt;/em&gt; 8 가지 기본 유형이 있습니다 . 타입 &lt;em&gt;닐은&lt;/em&gt; 하나 개의 값을 갖는다 &lt;b&gt;닐&lt;/b&gt; 그의 주요 속성 다른 값을 다르게하는 것이다; 일반적으로 유용한 값이 없음을 나타냅니다. &lt;em&gt;부울&lt;/em&gt; 유형 에는 &lt;b&gt;false&lt;/b&gt; 및 &lt;b&gt;true의&lt;/b&gt; 두 값이 &lt;b&gt;있습니다&lt;/b&gt; . &lt;b&gt;nil&lt;/b&gt; 과 &lt;b&gt;false&lt;/b&gt; 모두 조건을 거짓으로 만듭니다. 다른 값은 사실입니다. 타입 &lt;em&gt;번호&lt;/em&gt;정수와 실수 (부동 소수점)를 모두 나타냅니다. 유형 &lt;em&gt;문자열&lt;/em&gt; 은 변경할 수없는 바이트 시퀀스를 나타냅니다. Lua는 8 비트입니다. 문자열에는 포함 된 0 ( ' &lt;code&gt;\0&lt;/code&gt; ')을 포함하여 8 비트 값이 포함될 수 있습니다 . 루아는 또한 인코딩에 독립적이다. 문자열의 내용에 대한 가정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="7846fd1d69e8fc588a803bcf086d6b71c1b7e6c8" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be larger than 1000.</source>
          <target state="translated">함수가 반환 할 수있는 값의 수에는 시스템에 따라 제한이 있습니다. 이 제한은 1000보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="190864f70f817fcefb7920da72729737abc80388" translate="yes" xml:space="preserve">
          <source>There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">스레드를 닫거나 파괴하는 명시적인 기능은 없습니다. 스레드는 Lua 객체와 마찬가지로 가비지 수집 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="33a5b691e1bbd0d76427c85690ea834884923c9e" translate="yes" xml:space="preserve">
          <source>These operators always result in &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">이 연산자는 항상 &lt;b&gt;false&lt;/b&gt; 또는 &lt;b&gt;true가&lt;/b&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="23af1fc0e094c2dd4a126a0afba341a0993ddceb" translate="yes" xml:space="preserve">
          <source>These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.</source>
          <target state="translated">이러한 고유 식별자를 통해 프로그램은 서로 다른 클로저가 높은 가치를 공유하는지 여부를 확인할 수 있습니다. 높은 값을 공유하는 (즉, 동일한 외부 로컬 변수에 액세스하는) 루아 클로저는 해당 높은 값 인덱스에 대해 동일한 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcf0ac285f24f41a8021faef38d1d581f4af95ef" translate="yes" xml:space="preserve">
          <source>This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. The host program can freely use this memory.</source>
          <target state="translated">이 함수는 지정된 크기의 새 메모리 블록을 할당하고 블록 주소가있는 새 전체 사용자 데이터를 스택에 푸시 한 다음이 주소를 반환합니다. 호스트 프로그램은이 메모리를 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ee19d0f7467cfbd14cfa290c226be8222d4802" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">이 함수 는 스택의 레벨 &lt;code&gt;level&lt;/code&gt; 에서 함수의 인덱스 &lt;code&gt;local&lt;/code&gt; 을 사용하여 &lt;code&gt;value&lt;/code&gt; 을 로컬 변수에 할당합니다 . 주어진 인덱스에 지역 변수가 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환 하고, 범위를 벗어난 &lt;code&gt;level&lt;/code&gt; 호출하면 오류가 발생 합니다. ( &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 레벨이 유효한지 확인할 수 있습니다 .) 그렇지 않으면 로컬 변수의 이름을 리턴합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7496e2514cb1dfc80c2cf0b9e57db48fa2c53f8" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">이 함수 는 함수 &lt;code&gt;f&lt;/code&gt; 의 인덱스 &lt;code&gt;up&lt;/code&gt; 을 사용 하여 값 &lt;code&gt;value&lt;/code&gt; 을 업값에 지정합니다 . 주어진 인덱스에 업 값이 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 . 그렇지 않으면, 업 밸류의 이름을 반환합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca95f2234def804d470e8cb89141fa32f72381d2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;s&lt;/code&gt; is a valid UTF-8 string.</source>
          <target state="translated">이 함수는 &lt;code&gt;s&lt;/code&gt; 가 유효한 UTF-8 문자열 이라고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="580c46d5d2b043293bd752a3640317342ee77988" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동 하지만 호출 된 함수가 생성되도록 허용합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="228ffaca57d64d62cbfa46f275e2308925e5e66b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동 하지만 호출 된 함수가 산출 할 수 있습니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1bff58bee943ec12e3d7290610d93d1b1f73d8e7" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function, or it is called from a thread that is not running inside a resume (e.g., the main thread).</source>
          <target state="translated">이 함수는 연속 함수가없는 보류중인 C 호출이있는 스레드에서 호출되거나 이력서 내에서 실행되지 않는 스레드 (예 : 기본 스레드)에서 호출 된 경우 오류를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54be94a59f0bc6784fed88d3a32e726d290eea51" translate="yes" xml:space="preserve">
          <source>This function does not pop the Lua function from the stack.</source>
          <target state="translated">이 함수는 스택에서 Lua 함수를 팝하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b380c64bb33a1e7916dc907712574229b22846ec" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count on the stack). When there are no errors, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 1; when called with a level greater than the stack depth, it returns 0.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 구조의 일부를 주어진 레벨에서 실행되는 함수 의 &lt;em&gt;활성화 레코드&lt;/em&gt; 식별로 채 웁니다 . 레벨 0은 현재 실행중인 기능이고, 레벨 &lt;em&gt;n + 1&lt;/em&gt; 은 레벨 &lt;em&gt;n&lt;/em&gt; 을 호출 한 기능입니다 (스택에서 계산되지 않는 테일 호출 제외). 오류가 없으면 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 은 1을 반환합니다. 스택 깊이보다 큰 레벨로 호출하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95f4de101d63040fc5211037c7343d4c56e0ad01" translate="yes" xml:space="preserve">
          <source>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, &lt;code&gt;opt&lt;/code&gt;:</source>
          <target state="translated">이 함수는 가비지 수집기에 대한 일반적인 인터페이스입니다. 첫 번째 인수 인 &lt;code&gt;opt&lt;/code&gt; 에 따라 다른 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d28a53b3b111db987336d2926f880313a09864bb" translate="yes" xml:space="preserve">
          <source>This function is an interface to the underling pseudo-random generator function provided by C.</source>
          <target state="translated">이 함수는 C에서 제공하는 기본 의사 난수 생성기 함수에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f98115d2ab8e4d7be0cefa4bae9be552429cd8c3" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 연속성이 없습니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 따라서 스레드가 재개되면 &lt;code&gt;lua_yield&lt;/code&gt; 를 호출하는 함수를 호출 한 함수가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="670f5f1a9510a05d3452d6c53437d60b035753b4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;nil&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">이 기능은 ISO C 기능 &lt;code&gt;system&lt;/code&gt; 과 동일 합니다 . 운영 체제 쉘에서 실행할 &lt;code&gt;command&lt;/code&gt; 을 전달 합니다. 명령이 성공적으로 종료되면 첫 번째 결과는 &lt;b&gt;true&lt;/b&gt; 이고 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 입니다. 이 첫 번째 결과 후에 함수는 다음과 같이 문자열과 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1a39cb0734d0402904008bd0b6e1f1f1778321f" translate="yes" xml:space="preserve">
          <source>This function is not supported by Standard C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the &lt;code&gt;dlfcn&lt;/code&gt; standard).</source>
          <target state="translated">이 기능은 Standard C에서 지원되지 않습니다. 따라서 일부 플랫폼 (Windows, Linux, Mac OS X, Solaris, BSD 및 &lt;code&gt;dlfcn&lt;/code&gt; 표준 을 지원하는 기타 Unix 시스템)에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09ff91542609c4270a5672d90a1b6660e19831ef" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt;, except that it sets a new message handler &lt;code&gt;msgh&lt;/code&gt;.</source>
          <target state="translated">이 함수는 새로운 메시지 핸들러 &lt;code&gt;msgh&lt;/code&gt; 를 설정한다는 점을 제외하고 &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="717f7af51aaada41e5e3c40f203c1a8fa9d3bad9" translate="yes" xml:space="preserve">
          <source>This function is system dependent and is not available on all platforms.</source>
          <target state="translated">이 기능은 시스템에 따라 다르며 일부 플랫폼에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f290796c947e6dfdea50bcfa8240bdb86eb8a0" translate="yes" xml:space="preserve">
          <source>This function is used to build a prefix for error messages.</source>
          <target state="translated">이 기능은 오류 메시지의 접두사를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9f48a6c272547f77904d32d9efdba0ecb10345" translate="yes" xml:space="preserve">
          <source>This function may be not thread safe because of its reliance on C function &lt;code&gt;setlocale&lt;/code&gt;.</source>
          <target state="translated">이 함수는 C 함수 &lt;code&gt;setlocale&lt;/code&gt; 에 의존하기 때문에 스레드로부터 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76e84460922436ebf110cd9c953279251f6cb0bb" translate="yes" xml:space="preserve">
          <source>This function never returns, but it is an idiom to use it in C functions as &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 절대 리턴하지 않지만 C 함수에서이를 &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 으로 사용하는 관용구 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6a8e72aaf1ce15e733e732a309d591ddf3339d" translate="yes" xml:space="preserve">
          <source>This function never returns.</source>
          <target state="translated">이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbd53ac438e83a0043cb356691fb688496f31d3d" translate="yes" xml:space="preserve">
          <source>This function opens a file, in the mode specified in the string &lt;code&gt;mode&lt;/code&gt;. In case of success, it returns a new file handle.</source>
          <target state="translated">이 함수는 문자열 &lt;code&gt;mode&lt;/code&gt; 에 지정된 모드에서 파일을 엽니 다 . 성공하면 새 파일 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1586e455af396a0193bb677436a0ad64943d1618" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;:</source>
          <target state="translated">이 기능은 매개 변수의 값에 따라, 여러 가지 작업을 수행 &lt;code&gt;what&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc205d90b6658beebf2ab75bca0642c69aa0ce84" translate="yes" xml:space="preserve">
          <source>This function pops &lt;code&gt;n&lt;/code&gt; values from the stack &lt;code&gt;from&lt;/code&gt;, and pushes them onto the stack &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">이 함수 팝 &lt;code&gt;n&lt;/code&gt; 값 스택에서 &lt;code&gt;from&lt;/code&gt; 스택 상으로 푸시하고 그들 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4693da6260e34753896c1e887316822f4ced3e1d" translate="yes" xml:space="preserve">
          <source>This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 함수는 스택에서 키와 값을 모두 팝합니다. Lua에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;newindex&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="02f15be23e4eaf0571f919cc7f7e66b956f4d346" translate="yes" xml:space="preserve">
          <source>This function pops the key from the stack, pushing the resulting value in its place. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 기능은 스택에서 키를 팝하여 결과 값을 제자리에 밀어 넣습니다. 루아에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;인덱스&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="02c44d9ce8f4d61b45f6e95f4c2615a475b30c3d" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. Lua에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;newindex&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="d650072e7d52525aa4e9529e95f455ff101b8ac7" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. 할당은 미가공 즉, &lt;code&gt;__newindex&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4dc9661dd76f18a4a7b7bac51f4e0d8886007ef1" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. 할당은 미가공 즉, &lt;code&gt;__newindex&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6ab41c2efc54cdc4ab08b428ef1fab2ac04e1717" translate="yes" xml:space="preserve">
          <source>This function produces the return values for file-related functions in the standard library (&lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-os.rename&quot;&gt;&lt;code&gt;os.rename&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:seek&quot;&gt;&lt;code&gt;file:seek&lt;/code&gt;&lt;/a&gt;, etc.).</source>
          <target state="translated">이 함수는 표준 라이브러리 ( &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-os.rename&quot;&gt; &lt;code&gt;os.rename&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:seek&quot;&gt; &lt;code&gt;file:seek&lt;/code&gt; &lt;/a&gt; 등) 에서 파일 관련 함수의 반환 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba307bd4b8d4a518ec757e560baba91e283126d" translate="yes" xml:space="preserve">
          <source>This function produces the return values for process-related functions in the standard library (&lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.close&quot;&gt;&lt;code&gt;io.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 함수는 표준 라이브러리 ( &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-io.close&quot;&gt; &lt;code&gt;io.close&lt;/code&gt; &lt;/a&gt; ) 에서 프로세스 관련 함수의 리턴 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b6746e2c8158506c924e3d9368f6e2be32b4e0d2" translate="yes" xml:space="preserve">
          <source>This function returns 0 on error (for instance, an invalid option in &lt;code&gt;what&lt;/code&gt;).</source>
          <target state="translated">이 함수는 오류시 0을 리턴합니다 (예 : &lt;code&gt;what&lt;/code&gt; 의 유효하지 않은 옵션 ).</target>
        </trans-unit>
        <trans-unit id="9a4eda5d295976dd3059ff0cebee20501ad1d66f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;table&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cbb6c1599fe3ff6cd07d37a480afe2c16e49c014" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.</source>
          <target state="translated">이 함수는 스택의 레벨 &lt;code&gt;f&lt;/code&gt; 에서 함수의 인덱스 &lt;code&gt;local&lt;/code&gt; 과 함께 로컬 변수의 이름과 값을 반환합니다 . 이 함수는 명시 적 로컬 변수뿐만 아니라 매개 변수, 임시 등에도 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="11dccabc4359a103d70b6a183c7d1b9e295f7d04" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">이 함수는 함수 &lt;code&gt;f&lt;/code&gt; 의 인덱스 업과 함께 &lt;code&gt;up&lt;/code&gt; 밸류의 이름과 값을 반환합니다 . 주어진 인덱스에 업 값이 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bebb641f92b0e70a08302c805cbf864b58b36eaf" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, but it has an extra error code &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors (e.g., it cannot open or read the file).</source>
          <target state="translated">이 기능은 같은 결과를 반환 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 를&lt;/a&gt; 하지만 추가 오류 코드가 &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt; 파일 관련 오류 (예를, 그것은 열 수 없습니다 또는 파일을 읽을).</target>
        </trans-unit>
        <trans-unit id="6596dd0254b38c840e56683db82740f29df06f33" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c0db593e94c92390f3357b35159d95eee2be2609" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 . &lt;code&gt;name&lt;/code&gt; 은 청크 이름으로 디버그 정보 및 오류 메시지에 사용됩니다. 문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5412475350d1ee79055711d0c4350d66e69ffd6d" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; to get its result, so all conversions and caveats of that function apply here.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; 을 사용 하여 결과를 얻으므로 해당 함수의 모든 변환 및 경고가 여기에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2d4ea61bcf0f5292e3f253adc7c53a2139d8438" translate="yes" xml:space="preserve">
          <source>This function works like &lt;a href=&quot;#luaL_checkudata&quot;&gt;&lt;code&gt;luaL_checkudata&lt;/code&gt;&lt;/a&gt;, except that, when the test fails, it returns &lt;code&gt;NULL&lt;/code&gt; instead of raising an error.</source>
          <target state="translated">이 함수 는 테스트가 실패 하면 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환한다는 점을 제외하고 &lt;a href=&quot;#luaL_checkudata&quot;&gt; &lt;code&gt;luaL_checkudata&lt;/code&gt; &lt;/a&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6563d8fb9cdba4b8e66ee93d7bd36fb67b77cff7" translate="yes" xml:space="preserve">
          <source>This is a low-level function. It completely bypasses the package and module system. Unlike &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, it does not perform any path searching and does not automatically adds extensions. &lt;code&gt;libname&lt;/code&gt; must be the complete file name of the C library, including if necessary a path and an extension. &lt;code&gt;funcname&lt;/code&gt; must be the exact name exported by the C library (which may depend on the C compiler and linker used).</source>
          <target state="translated">이것은 저수준 기능입니다. 패키지 및 모듈 시스템을 완전히 무시합니다. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 와 달리 경로 검색을 수행하지 않으며 확장명을 자동으로 추가하지 않습니다. &lt;code&gt;libname&lt;/code&gt; 은 필요한 경우 경로와 확장자를 포함하여 C 라이브러리의 완전한 파일 이름이어야합니다. &lt;code&gt;funcname&lt;/code&gt; 은 C 라이브러리에서 내 보낸 정확한 이름이어야합니다 (사용 된 C 컴파일러 및 링커에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="fd11429b923b744979c7d1f098bd69f96f85f6c0" translate="yes" xml:space="preserve">
          <source>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</source>
          <target state="translated">문자열을 C 열거 형에 매핑하는 데 유용한 함수입니다. Lua 라이브러리의 일반적인 규칙은 숫자 대신 문자열을 사용하여 옵션을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="753037500c4fa6eda5c0c6251d0c5a1a859a582c" translate="yes" xml:space="preserve">
          <source>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</source>
          <target state="translated">이것은 스택에 추가 요소로 호출 될 수 있고 버퍼에 추가 될 값인 문자열 버퍼에 대한 유일한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="90d6873741ea710dec0793ac5a59b32c0c418fac" translate="yes" xml:space="preserve">
          <source>This library comprises the operations to manipulate coroutines, which come inside the table &lt;a id=&quot;pdf-coroutine&quot;&gt;&lt;code&gt;coroutine&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; for a general description of coroutines.</source>
          <target state="translated">이 라이브러리는 코 루틴을 조작하는 조작으로 구성되며, &lt;a id=&quot;pdf-coroutine&quot;&gt; &lt;code&gt;coroutine&lt;/code&gt; &lt;/a&gt; 은 테이블 coroutine 안에 있습니다. 코 루틴에 대한 일반적인 설명은 &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90c1b961ab3b38c58be563362f0802d45e85c135" translate="yes" xml:space="preserve">
          <source>This library is implemented through table &lt;a id=&quot;pdf-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 테이블 &lt;a id=&quot;pdf-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; 를&lt;/a&gt; 통해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="677be47bd4a9ee27a5f7b1353939b6d0981e1e42" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for float (or mixed) arguments. Rounding functions (&lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt;) return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">이 라이브러리는 기본적인 수학 함수를 제공합니다. 테이블 &lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 내부의 모든 함수와 상수를 제공합니다 . 주석이 &quot; &lt;code&gt;integer/float&lt;/code&gt; &quot;인 함수는 정수 인수에 대한 정수 결과를 제공하고 부동 (또는 혼합) 인수에 대한 부동 결과를 제공합니다. 반올림 함수 ( &lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt; )는 결과가 정수 범위에 맞으면 정수를 반환하고, 그렇지 않으면 float을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eff61c8c99df8abb4cc617e0a788ed6e1d7a8ab8" translate="yes" xml:space="preserve">
          <source>This library provides basic support for UTF-8 encoding. It provides all its functions inside the table &lt;a id=&quot;pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;. This library does not provide any support for Unicode other than the handling of the encoding. Any operation that needs the meaning of a character, such as character classification, is outside its scope.</source>
          <target state="translated">이 라이브러리는 UTF-8 인코딩에 대한 기본 지원을 제공합니다. 테이블 &lt;a id=&quot;pdf-utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 내부의 모든 기능을 제공합니다 . 이 라이브러리는 인코딩 처리 이외의 유니 코드를 지원하지 않습니다. 문자 분류와 같이 문자의 의미가 필요한 모든 작업은 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="f54156236b7b08469a0920a829130d4325d9534b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.</source>
          <target state="translated">이 라이브러리는 하위 문자열 찾기 및 추출, 패턴 일치와 같은 문자열 조작을위한 일반 기능을 제공합니다. Lua에서 문자열을 색인 할 때 첫 번째 문자는 위치 1에 있습니다 (C에서와 같이 0이 아님). 인덱스는 음수가 될 수 있으며 문자열의 끝에서 뒤로 색인으로 해석됩니다. 따라서 마지막 문자는 위치 -1에 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaff80ded470719d876c589d5513c23d7a2d941b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for table manipulation. It provides all its functions inside the table &lt;a id=&quot;pdf-table&quot;&gt;&lt;code&gt;table&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 테이블 조작을위한 일반 기능을 제공합니다. 테이블 &lt;a id=&quot;pdf-table&quot;&gt; &lt;code&gt;table&lt;/code&gt; &lt;/a&gt; 내부의 모든 기능을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="8d51d524a82a8aae4d9f2e0292c35c2b4f100e81" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">이 라이브러리는 Lua 프로그램에 디버그 인터페이스 ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ) 의 기능을 제공합니다 . 이 라이브러리를 사용할 때는주의를 기울여야합니다. 그 기능 중 일부는 Lua 코드에 대한 기본 가정을 위반합니다 (예 : 함수의 로컬 변수에 외부에서 액세스 할 수 없음, 사용자 데이터 메타 테이블을 Lua 코드로 변경할 수 없음, Lua 프로그램이 충돌하지 않음). 그렇지 않으면 보안 코드를 손상시킬 수 있습니다. 또한이 라이브러리의 일부 기능이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa99211cd2ffc6b2b1567c3fa58975b02bdbb57d" translate="yes" xml:space="preserve">
          <source>This macro is defined as follows:</source>
          <target state="translated">이 매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c062139aee69e54bd4a269563eddaa0f4e8798af" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 &lt;code&gt;s&lt;/code&gt; 가 리터럴 문자열 인 경우에만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="73fca2eb54a811850b7ad4e17b0d35bfe7cf0032" translate="yes" xml:space="preserve">
          <source>This macro may evaluate its arguments more than once.</source>
          <target state="translated">이 매크로는 인수를 두 번 이상 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f26abbbd5d35b2d22d1c051a71569b0f900ee1" translate="yes" xml:space="preserve">
          <source>This section describes the C API for Lua, that is, the set of C functions available to the host program to communicate with Lua. All API functions and related types and constants are declared in the header file &lt;a id=&quot;pdf-lua.h&quot;&gt;&lt;code&gt;lua.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 Lua 용 C API, 즉 호스트 프로그램이 Lua와 통신하는 데 사용할 수있는 C 함수 세트에 대해 설명합니다. 모든 API 함수와 관련 유형 및 상수는 헤더 파일 &lt;a id=&quot;pdf-lua.h&quot;&gt; &lt;code&gt;lua.h&lt;/code&gt; 에&lt;/a&gt; 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="f58c3cfe49431540420c4f54cf654f80f9192fd6" translate="yes" xml:space="preserve">
          <source>This section describes the basic concepts of the language.</source>
          <target state="translated">이 섹션에서는 언어의 기본 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8fa659ee1a4beeab1fc33f883314eeb2cadc844d" translate="yes" xml:space="preserve">
          <source>This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean.</source>
          <target state="translated">이 섹션에서는 Lua의 어휘, 구문 및 의미를 설명합니다. 다시 말해서,이 섹션은 어떤 토큰이 유효한지, 어떻게 결합 할 수 있는지, 그리고 그 조합의 의미를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="278be3240fe4a7ea3d08f92baa83623d2ac8fe27" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. Field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). Field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either &lt;b&gt;true&lt;/b&gt; (in case of success) or &lt;b&gt;nil&lt;/b&gt; plus an error message (in case of error). Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">이 사용자 데이터는 &lt;code&gt;luaL_Stream&lt;/code&gt; 구조로 시작해야합니다 . 이 초기 구조 이후에 다른 데이터를 포함 할 수 있습니다. 필드 &lt;code&gt;f&lt;/code&gt; 는 해당 C 스트림을 가리 킵니다 (또는 불완전하게 생성 된 핸들을 나타 내기 위해 &lt;code&gt;NULL&lt;/code&gt; 일 수 있음). Field &lt;code&gt;closef&lt;/code&gt; 는 핸들이 닫히거나 수집 될 때 스트림을 닫도록 호출되는 Lua 함수를 가리 킵니다. 이 함수는 파일 핸들을 유일한 인수로 받고 &lt;b&gt;true&lt;/b&gt; (성공의 경우) 또는 &lt;b&gt;nil&lt;/b&gt; 과 오류 메시지 (오류의 경우)를 리턴해야합니다 . Lua가이 필드를 호출 하면 핸들이 닫 &lt;code&gt;NULL&lt;/code&gt; 을 알리기 위해 필드 값을 NULL 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="a38b5444cc9ef2204e61edb4d9f6307dc07f0ac4" translate="yes" xml:space="preserve">
          <source>This variable is only a reference to the real table; assignments to this variable do not change the table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변수는 실제 테이블에 대한 참조 일뿐입니다. 이 변수에 대한 할당은 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 에&lt;/a&gt; 의해 사용되는 테이블을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd5b59d880561eb52ba3ed52be79a6fc246200cf" translate="yes" xml:space="preserve">
          <source>To allow possible side-effects, function calls can be executed as statements:</source>
          <target state="translated">가능한 부작용을 허용하기 위해 함수 호출을 명령문으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="888be864c9c88102be3a61e9065fc124fb157083" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">Unix 시스템에서 Lua를 스크립트 인터프리터로 사용할 수 있도록 독립형 인터프리터는 청크로가 첫 번째 행이 &lt;code&gt;#&lt;/code&gt; 으로 시작하면이를 무시합니다 . 따라서 &lt;code&gt;chmod +x&lt;/code&gt; 및 &lt;code&gt;#!&lt;/code&gt; 를 사용하여 Lua 스크립트를 실행 가능 프로그램으로 만들 수 있습니다 . 에서와 같이 형태</target>
        </trans-unit>
        <trans-unit id="1e9c9099d2aea779a3a3f78d58160c9b66011127" translate="yes" xml:space="preserve">
          <source>To avoid this kind of problem, Lua raises an error whenever it tries to yield across an API call, except for three functions: &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. All those functions receive a &lt;em&gt;continuation function&lt;/em&gt; (as a parameter named &lt;code&gt;k&lt;/code&gt;) to continue execution after a yield.</source>
          <target state="translated">: 이러한 문제를 방지하기 위해, 루아는 세 가지 기능을 제외하고, API 호출을 통해 산출하려 할 때마다 오류가 발생합니다 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; 을&lt;/a&gt; . 이러한 모든 함수는 &lt;em&gt;연속 함수&lt;/em&gt; ( &lt;code&gt;k&lt;/code&gt; 라는 매개 변수 )를 수신 하여 수율 후에 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="5bb0e844a26e80a97eddacec1b0d3209d0d96606" translate="yes" xml:space="preserve">
          <source>To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">함수를 호출하려면 다음 프로토콜을 사용해야합니다. 먼저 호출 할 함수가 스택으로 푸시됩니다. 그런 다음 함수에 대한 인수는 순서대로 푸시됩니다. 즉, 첫 번째 인수가 먼저 푸시됩니다. 마지막으로 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 . &lt;code&gt;nargs&lt;/code&gt; 는 스택에 푸시 한 인수의 수입니다. 함수가 호출되면 모든 인수와 함수 값이 스택에서 팝됩니다. 함수 결과는 함수가 반환 될 때 스택으로 푸시됩니다. 결과의 수를 조정 &lt;code&gt;nresults&lt;/code&gt; 하지 않는 한, &lt;code&gt;nresults&lt;/code&gt; 가 있다 &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; 가&lt;/a&gt;. 이 경우 함수의 모든 결과가 푸시됩니다. Lua는 반환 된 값이 스택 공간에 맞도록주의하지만 스택에 추가 공간을 보장하지는 않습니다. 함수 결과는 직접 순서대로 스택에 푸시되며 (첫 번째 결과가 먼저 푸시 됨) 호출 후 마지막 결과가 스택의 맨 위에 오게됩니다.</target>
        </trans-unit>
        <trans-unit id="2e1e6304705c324bc934187373072b763f1a1066" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt; sequence. By changing this sequence, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로더를 찾으려면 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 순서에 따라 &lt;code&gt;require&lt;/code&gt; 가 안내됩니다 . 이 순서를 변경하여 &lt;code&gt;require&lt;/code&gt; 모듈을 찾는 방법을 변경할 수 있습니다 . 다음 설명은 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 의 기본 구성을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="d328425732a8a8cf219c051476f3d38be1088896" translate="yes" xml:space="preserve">
          <source>To get information about a function invocation, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수 호출에 대한 정보를 얻으려면 매개 변수 &lt;code&gt;ar&lt;/code&gt; 는 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 채워지 거나 후크에 대한 인수로 제공된 유효한 활성화 레코드 여야합니다 ( &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="259bf849c0380d37169ac9c2c5ed68eef86ed762" translate="yes" xml:space="preserve">
          <source>To get information about a function you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">함수에 대한 정보를 얻으려면 함수를 스택에 넣고 문자 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '로 &lt;code&gt;what&lt;/code&gt; 문자열을 시작하십시오 . (이 경우 &lt;code&gt;lua_getinfo&lt;/code&gt; 는 스택 맨 위에서 함수를 팝합니다.) 예를 들어 함수 &lt;code&gt;f&lt;/code&gt; 가 정의 된 행을 알기 위해 다음 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f65df24a4302e99c5805820ed2c9da17dcc1b4e" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 라이브러리에 액세스하려면 C 호스트 프로그램이 &lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt; 함수를 호출해야합니다.이 함수는 모든 표준 라이브러리를 엽니 다. 또한, 호스트 프로그램을 사용하여 개별적으로 열 수 있습니다 &lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; 를&lt;/a&gt; 호출 &lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt; (기본 라이브러리), &lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt; (패키지 라이브러리), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt; , (코 루틴 라이브러리)을 &lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt; (문자열 라이브러리) &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; 을&lt;/a&gt; 위해 ( UTF8 라이브러리), &lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt; (테이블 라이브러리), &lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt; (수학 라이브러리), &lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt; (I / O 라이브러리), &lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;(운영 체제 라이브러리의 경우) 및 &lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt; (디버그 라이브러리의 경우). 이 함수들은 &lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt; 에 선언되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7497be5097473a583f39ec52ec425732f31d8c7" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove any results from the last &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, put on its stack only the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 다시 시작하려면 마지막 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 에서 결과를 제거 하고 &lt;code&gt;yield&lt;/code&gt; 에서 결과로 전달할 값만 스택에 놓고 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5749af8d5e7fed727ed35d15b38114e430080b8" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push onto the thread stack the main function plus any arguments; then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, or all values returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">코 루틴을 시작하려면 스레드 스택에 main 함수와 인수를 넣습니다. 당신은 전화 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 을&lt;/a&gt; 함께 &lt;code&gt;nargs&lt;/code&gt; 는 인수의 수있는. 코 루틴이 일시 중단되거나 실행이 끝나면이 호출이 반환됩니다. 반환되면 스택에는 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; 에&lt;/a&gt; 전달 된 모든 값 또는 body 함수가 반환 한 모든 값이 포함됩니다. &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 반환 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; 는&lt;/a&gt; 코 루틴 수율 경우 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 는&lt;/a&gt; 코 루틴은 에러없이 실행 혹은 오류 (볼의 경우의 에러 코드를 완료한다면 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a3a0ec973c2479f00cc8910cb72beb238ed2cd" translate="yes" xml:space="preserve">
          <source>Type for C functions.</source>
          <target state="translated">C 함수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bbac79126ad582b607fa7de417480b28246073cf" translate="yes" xml:space="preserve">
          <source>Type for a &lt;em&gt;string buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;문자열 버퍼를&lt;/em&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="597df46ee98db369cefa88ec65178daff885f4c9" translate="yes" xml:space="preserve">
          <source>Type for arrays of functions to be registered by &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the function name and &lt;code&gt;func&lt;/code&gt; is a pointer to the function. Any array of &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt; must end with a sentinel entry in which both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;func&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; 에&lt;/a&gt; 의해 등록 될 함수 배열의 유형입니다 . &lt;code&gt;name&lt;/code&gt; 은 함수 이름이고 &lt;code&gt;func&lt;/code&gt; 는 함수 에 대한 포인터입니다. &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; 배열은 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;func&lt;/code&gt; 가 모두 &lt;code&gt;NULL&lt;/code&gt; 인 센티넬 항목 으로 끝나야 합니다 .</target>
        </trans-unit>
        <trans-unit id="97624a7d15b8942c923346eb9827dfe7da1b1df0" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">연속 기능 유형 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24445b5aafedd0f5dd84a959ce49844260c89cd8" translate="yes" xml:space="preserve">
          <source>Type for debugging hook functions.</source>
          <target state="translated">후크 기능 디버깅을위한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bd045f19fb648f6e2a8a5ad73d4fd1e6a85d7f43" translate="yes" xml:space="preserve">
          <source>Typically this function is used only for hashing and debug information.</source>
          <target state="translated">일반적으로이 함수는 해싱 및 디버그 정보에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82aace29da601638b56c7fcfaece961d82f801a3" translate="yes" xml:space="preserve">
          <source>Typically, the message handler is used to add more debug information to the error object, such as a stack traceback. Such information cannot be gathered after the return of &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, since by then the stack has unwound.</source>
          <target state="translated">일반적으로 메시지 핸들러는 스택 추적과 같은 오류 정보에 더 많은 디버그 정보를 추가하는 데 사용됩니다. &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 이 반환 된 후에는 스택이 풀 렸기 때문에 이러한 정보를 수집 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="31727baa3a70e03cfa1528c55a7acf86c6c0a582" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;nil&lt;/b&gt; on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from &lt;b&gt;nil&lt;/b&gt; on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">달리 명시하지 않는 한 모든 I / O 함수 는 실패시 &lt;b&gt;nil&lt;/b&gt; (두 번째 결과로 오류 메시지 및 세 번째 결과로 시스템 종속 오류 코드)과 성공시 &lt;b&gt;nil&lt;/b&gt; 과 다른 값을 반환 합니다. POSIX 이외의 시스템에서는 에러가 발생한 경우 에러 메시지와 에러 코드의 계산이 글로벌 C 변수 &lt;code&gt;errno&lt;/code&gt; 에 의존하기 때문에 스레드 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b52e7d27a22d0d612f9608bbf1f1eccee941606" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, all functions that expect a byte position as a parameter assume that the given position is either the start of a byte sequence or one plus the length of the subject string. As in the string library, negative indices count from the end of the string.</source>
          <target state="translated">달리 언급되지 않는 한, 바이트 위치를 매개 변수로 예상하는 모든 함수는 주어진 위치가 바이트 시퀀스의 시작이거나 주제 문자열의 길이에 1을 더한 것으로 가정합니다. 문자열 라이브러리에서와 같이 음수 인덱스는 문자열 끝에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="59b21f366bd62c88e740589d6190f38930d6eeac" translate="yes" xml:space="preserve">
          <source>Unlike other push functions, this function checks for the stack space it needs, including the slot for its result.</source>
          <target state="translated">다른 푸시 기능과 달리이 기능은 결과에 대한 슬롯을 포함하여 필요한 스택 공간을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2e42ec0a938ed392af0043f9b91ccccb6b8e5563" translate="yes" xml:space="preserve">
          <source>Upvalues have no particular order, as they are active through the whole function. They are numbered in an arbitrary order.</source>
          <target state="translated">업 밸류는 전체 기능을 통해 활성화되므로 특정 순서가 없습니다. 그것들은 임의의 순서로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="76f521b6a8d60e44bede4ff94d2d23d25dcfafa8" translate="yes" xml:space="preserve">
          <source>Userdata represent C values in Lua. A &lt;em&gt;light userdata&lt;/em&gt; represents a pointer, a &lt;code&gt;void*&lt;/code&gt;. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to &quot;any&quot; light userdata with the same C address.</source>
          <target state="translated">사용자 데이터는 Lua의 C 값을 나타냅니다. &lt;em&gt;광 유저 데이터는&lt;/em&gt; 포인터하는 대표 &lt;code&gt;void*&lt;/code&gt; . 값은 숫자와 같습니다. 값을 만들지 않고 개별 메타 테이블이 없으며 수집되지 않습니다 (생성되지 않았기 때문에). 일반 사용자 데이터는 동일한 C 주소를 가진 &quot;모든&quot;일반 사용자 데이터와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e39e23cf8cc12b3b818ae1cbbd67ab727cb6080a" translate="yes" xml:space="preserve">
          <source>Usually, &lt;code&gt;error&lt;/code&gt; adds some information about the error position at the beginning of the message, if the message is a string. The &lt;code&gt;level&lt;/code&gt; argument specifies how to get the error position. With level 1 (the default), the error position is where the &lt;code&gt;error&lt;/code&gt; function was called. Level 2 points the error to where the function that called &lt;code&gt;error&lt;/code&gt; was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</source>
          <target state="translated">일반적으로 &lt;code&gt;error&lt;/code&gt; 는 메시지가 문자열 인 경우 메시지 시작시 오류 위치에 대한 정보를 추가합니다. &lt;code&gt;level&lt;/code&gt; 인수를 지정하는 방법 오류 위치를 얻을 수 있습니다. 레벨 1 (기본값)에서 오류 위치는 &lt;code&gt;error&lt;/code&gt; 함수가 호출 된 위치입니다 . 레벨 2는 오류를 호출 한 함수가 호출 된 위치를 &lt;code&gt;error&lt;/code&gt; 로 지정합니다. 등등. 수준 0을 전달하면 오류 위치 정보가 메시지에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ede0ea911a1e4e16232a1c52be2e25bf93574b23" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">일반적으로이 함수는 반환되지 않습니다. 코 루틴이 결국 재개되면 계속 기능을 계속 실행합니다. 그러나 라인이나 카운트 훅 내부에서이 함수를 호출 할 때 특별한 경우가 있습니다 ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; 참조 ). 이 경우 &lt;code&gt;lua_yieldk&lt;/code&gt; 는 연속없이 (아마도 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 형식으로 ) 호출되고 결과가 없어야하며 호출 후 즉시 후크가 리턴되어야합니다. 루아는 양보하고 코 루틴이 다시 재개되면 후크를 트리거 한 (루아) 기능의 정상적인 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="14347ed892514b4d69c3b3bf601cd9c8fb3e904b" translate="yes" xml:space="preserve">
          <source>Values and Types</source>
          <target state="translated">가치와 유형</target>
        </trans-unit>
        <trans-unit id="12bad2c7ac94b1eae85bb4982ce9b8d423815b52" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information).</source>
          <target state="translated">' &lt;code&gt;(&lt;/code&gt; '(괄호 열기)로 시작하는 변수 이름 은 알려진 이름이없는 변수 (루프 제어 변수와 같은 내부 변수 및 디버그 정보없이 저장된 청크 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91ca405a6bcded978537314760080c405ac3d0b7" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">' &lt;code&gt;(&lt;/code&gt; '(괄호로 묶은 괄호)로 시작하는 변수 이름 은 알려진 이름이없는 변수를 나타냅니다 (디버그 정보없이 저장된 청크의 변수).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="be26bb31c1703ed9ce7e9ecf54d6a6a8c765c6e5" translate="yes" xml:space="preserve">
          <source>Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields.</source>
          <target state="translated">변수는 값을 저장하는 장소입니다. Lua에는 전역 변수, 로컬 변수 및 테이블 필드의 세 가지 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95e5bb697c2902b5736feab85b400b53ef72faf" translate="yes" xml:space="preserve">
          <source>Visibility Rules</source>
          <target state="translated">가시성 규칙</target>
        </trans-unit>
        <trans-unit id="e3ca3a5141d9967c701776eca46ec10c9e635787" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string by its numeric value (including embedded zeros). This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">짧은 리터럴 문자열에 숫자 값 (포함 된 0 포함)으로 바이트를 지정할 수 있습니다. 이스케이프 시퀀스 &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; 로 수행 할 수 있습니다 . 여기서 &lt;em&gt;XX&lt;/em&gt; 는 정확히 두 개의 16 진수 시퀀스이거나 이스케이프 시퀀스 &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; , &lt;em&gt;ddd&lt;/em&gt; 는 최대 세 자리까지의 시퀀스입니다. (십진수 이스케이프 시퀀스 뒤에 숫자가 오는 경우 정확히 3 자리 숫자로 표현해야합니다.)</target>
        </trans-unit>
        <trans-unit id="a75447b7504738d77e48aaf615cad9ff4faa5f14" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. (This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.)</source>
          <target state="translated">계속을 설명하기 위해 몇 가지 용어를 설정해야합니다. 우리는 &lt;em&gt;원래 함수를&lt;/em&gt; 호출 할 Lua에서 호출 된 C 함수를 가지고 &lt;em&gt;있습니다&lt;/em&gt; . 그런 다음이 원래 함수는 C API에서 세 가지 함수 중 하나를 호출합니다.이 함수는 호출 &lt;em&gt;수신자 함수&lt;/em&gt; 를 호출 하여 현재 스레드를 생성합니다. (피 호출자 함수가 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 일 때 또는 피 호출자 함수가 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 이고 호출자 가 호출 한 함수가 생성 될 때 발생할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="d41db10b358155f4f013d45b45675b34f33d9ed3" translate="yes" xml:space="preserve">
          <source>Weak Tables</source>
          <target state="translated">약한 테이블</target>
        </trans-unit>
        <trans-unit id="b484eff0d117b27e8defcec4a0326a877ca574fe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;n&lt;/code&gt; is zero, this function creates a &lt;em&gt;light C function&lt;/em&gt;, which is just a pointer to the C function. In that case, it never raises a memory error.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 은 제로이며,이 함수는, 생성 &lt;em&gt;빛 C 함수&lt;/em&gt; C 함수 단지 포인터이다. 이 경우 메모리 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="996f3bf8346e25b1239b5ab5057ae46c604d1002" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. The allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request. Lua assumes that the allocator never fails when &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 0이 아닌, 할당 자처럼 행동해야한다 &lt;code&gt;realloc&lt;/code&gt; 을 . 할당자는 요청을 이행 할 수없는 경우에만 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 합니다 . Lua는 &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt; 때 할당자가 실패하지 않는다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="be7cbd666142d4c0c3a8b1ac15f72ec90fcd56bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 제로, 할당 자처럼 행동해야한다 &lt;code&gt;free&lt;/code&gt; 및 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63de127a2c08c3b5f3fa7d7ca6251d5614a09288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created sharing &lt;code&gt;nup&lt;/code&gt; upvalues, which must be previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">때 &lt;code&gt;nup&lt;/code&gt; 0이 아닌, 모든 기능은 공유 생성 &lt;code&gt;nup&lt;/code&gt; 이전 라이브러리 테이블 위에 스택에 밀어해야 upvalues을. 이 값은 등록 후 스택에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="335a5475dbcacbd9ecdd1054fd0513668a84ec31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; encodes the kind of object that Lua is allocating. &lt;code&gt;osize&lt;/code&gt; is any of &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt; when (and only when) Lua is creating a new object of that type. When &lt;code&gt;osize&lt;/code&gt; is some other value, Lua is allocating memory for something else.</source>
          <target state="translated">때 &lt;code&gt;ptr&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;osize&lt;/code&gt; 는 루아가 할당되는 객체의 종류를 인코딩합니다. &lt;code&gt;osize&lt;/code&gt; 는 Lua가 해당 유형의 새 객체를 만들 때 &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; 중 하나입니다. 때 &lt;code&gt;osize&lt;/code&gt; 가 다른 값이, 루아는 뭔가 다른 메모리를 할당한다.</target>
        </trans-unit>
        <trans-unit id="46d45ecf04d4c4d9ebff91c3f78c309dab0e87ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; is the size of the block pointed by &lt;code&gt;ptr&lt;/code&gt;, that is, the size given when it was allocated or reallocated.</source>
          <target state="translated">때 &lt;code&gt;ptr&lt;/code&gt; 없는 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;osize&lt;/code&gt; 가 가리키는 블록의 크기 &lt;code&gt;ptr&lt;/code&gt; 이다, 그것은 할당 또는 재 할당 할 때 주어진 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0344be77d1524703e63d720dcdc36380a6d9b380" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a sequence, &lt;code&gt;#t&lt;/code&gt; returns its only border, which corresponds to the intuitive notion of the length of the sequence. When &lt;code&gt;t&lt;/code&gt; is not a sequence, &lt;code&gt;#t&lt;/code&gt; can return any of its borders. (The exact one depends on details of the internal representation of the table, which in turn can depend on how the table was populated and the memory addresses of its non-numeric keys.)</source>
          <target state="translated">때 &lt;code&gt;t&lt;/code&gt; 이 시퀀스는, &lt;code&gt;#t&lt;/code&gt; 시퀀스의 길이의 직관적 인 개념에 해당하는 유일한 경계를 반환합니다. 때 &lt;code&gt;t&lt;/code&gt; 은 순서가 아닌, &lt;code&gt;#t&lt;/code&gt; 국경 중 하나를 반환 할 수 있습니다. (정확한 것은 테이블의 내부 표현에 대한 세부 사항에 따라 달라지며, 이는 테이블이 채워진 방법 및 숫자가 아닌 키의 메모리 주소에 따라 달라질 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3c915266f11381b28c8d7b3533ebdd9fec110c77" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; upvalue is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment (and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;). Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue.)</source>
          <target state="translated">Lua가 청크를로드 할 때 &lt;code&gt;_ENV&lt;/code&gt; 최대 값의 기본값 은 글로벌 환경입니다 ( &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 기본적으로 Lua 코드에서 사용 가능한 이름은 전역 환경의 항목을 나타냅니다 (따라서 &lt;em&gt;전역 변수&lt;/em&gt; 라고도 함 ). 또한 모든 표준 라이브러리는 글로벌 환경에로드되며 일부 기능은 해당 환경에서 작동합니다. 당신이 사용할 수있는 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt; 다른 환경 덩어리를로드). (C에서는 청크를로드 한 다음 첫 번째 상한값을 변경해야합니다.)</target>
        </trans-unit>
        <trans-unit id="9bf5cddf64fd956b790dcd47186d571d0648ca7d" translate="yes" xml:space="preserve">
          <source>When a C function calls &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, the running coroutine suspends its execution, and the call to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; that started this coroutine returns. The parameter &lt;code&gt;nresults&lt;/code&gt; is the number of values from the stack that will be passed as results to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 함수가 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 를&lt;/a&gt; 호출 하면 실행중인 코 루틴이 실행을 일시 중단 하고이 코 루틴을 시작한 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 대한 호출 이 반환됩니다. &lt;code&gt;nresults&lt;/code&gt; 매개 변수 는 스택에서 결과로 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 으로 전달되는 값의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="6587795ac24fa71cf1c2a7e27096b42bc7a40713" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a &lt;em&gt;C closure&lt;/em&gt; (see &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt;); these values are called &lt;em&gt;upvalues&lt;/em&gt; and are accessible to the function whenever it is called.</source>
          <target state="translated">C 함수가 작성되면 일부 값을 해당 함수와 연관시켜 &lt;em&gt;C 클로저&lt;/em&gt; 를 작성할 수 있습니다 ( &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 참조 ). 이러한 값은 &lt;em&gt;업값&lt;/em&gt; 이라고하며 호출 될 때마다 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ab54e362e4ae46fe6b07e57d87eadd11f23cbe" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a C closure (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values must be pushed onto the stack (when there are multiple values, the first value is pushed first). Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">C 함수가 작성되면 일부 값을이 함수와 연관시켜 C 클로저를 작성할 수 있습니다 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 ). 그런 다음이 값은 호출 될 때마다 함수에 액세스 할 수 있습니다. 값을 C 함수와 연관 시키려면 먼저이 값을 스택으로 푸시해야합니다 (여러 값이있는 경우 첫 번째 값이 먼저 푸시 됨). 그런 다음 &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 가 호출되어 C 함수를 생성하고 스택에 푸시하고 인수 &lt;code&gt;n&lt;/code&gt; 은 함수와 연관되는 값의 수를 알려줍니다. &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 는이 값을 스택에서 팝합니다.</target>
        </trans-unit>
        <trans-unit id="e078eea66272045084e3f01aa8c505b53aa0ead0" translate="yes" xml:space="preserve">
          <source>When a function is called, the list of arguments is adjusted to the length of the list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">함수가 호출 될 때 함수가 &lt;em&gt;vararg 함수&lt;/em&gt; 가 아닌 한 인수 목록은 매개 변수 목록의 길이에 맞게 조정됩니다 . 매개 변수 목록 끝에 3 개의 점 ( ' &lt;code&gt;...&lt;/code&gt; ')으로 표시됩니다. vararg 함수는 인수 목록을 조정하지 않습니다. 대신 모든 추가 인수를 수집하여 &lt;em&gt;vararg 표현식을&lt;/em&gt; 통해 함수에 제공합니다.&lt;em&gt;&lt;/em&gt;또한 3 개의 점으로 작성됩니다. 이 표현식의 값은 여러 개의 결과가있는 함수와 유사한 모든 실제 추가 인수의 목록입니다. vararg 표현식이 다른 표현식 내부 또는 표현식 목록의 중간에 사용되면 리턴 목록이 한 요소로 조정됩니다. 표현식이 표현식 목록의 마지막 요소로 사용되는 경우 마지막 표현식이 괄호로 묶이지 않는 한 조정이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da6fe573488f94135e6cdc83d520dc4a94e938c8" translate="yes" xml:space="preserve">
          <source>When a marked object becomes garbage, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is a function, Lua calls it with the object as its single argument; if the metamethod is not a function, Lua simply ignores it.</source>
          <target state="translated">표시된 객체가 가비지가되면 가비지 수집기에서 즉시 수집하지 않습니다. 대신 Lua는 목록에 넣습니다. 수집 후 Lua는 해당 목록을 살펴 봅니다. 목록의 각 객체에 대해 객체의 &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 확인합니다 . 함수 인 경우 Lua는 객체를 단일 인수로 사용하여 객체를 호출합니다. 메타 메소드가 함수가 아닌 경우 루아는 단순히이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="80897f837555b95f2cb104a59226a4a40d8e481f" translate="yes" xml:space="preserve">
          <source>When called with &lt;b&gt;nil&lt;/b&gt; as the first argument, this function only returns the name of the current locale for the given category.</source>
          <target state="translated">첫 번째 인수 로 &lt;b&gt;nil&lt;/b&gt; 을 사용하여 호출하면 이 함수는 주어진 범주의 현재 로캘 이름 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="641f9e62059a652c6e39c5a7f8f27534a9246ba4" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 를 사용 하여 호출 할 경우 &lt;code&gt;e&lt;/code&gt; 는 해당 밑에서 정수로 해석되는 문자열이어야합니다. 밑은 2와 36 사이의 정수일 수 있습니다. 10을 초과하는 밑줄에서 문자 ' &lt;code&gt;A&lt;/code&gt; '(대문자 또는 소문자)는 10을 나타내고, ' &lt;code&gt;B&lt;/code&gt; '는 11을 나타내며, ' &lt;code&gt;Z&lt;/code&gt; '는 35를 나타냅니다. 문자열 &lt;code&gt;e&lt;/code&gt; 가 지정된 숫자가 아닌 경우 base에서 함수는 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ae1235a6e1b0d97767a88001b252dc354fc4428a" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.</source>
          <target state="translated">파일 이름으로 호출하면 이름이 지정된 파일 (텍스트 모드)이 열리고 핸들을 기본 입력 파일로 설정합니다. 파일 핸들과 함께 호출되면이 파일 핸들을 기본 입력 파일로 설정하기 만하면됩니다. 매개 변수없이 호출되면 현재 기본 입력 파일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0331839def59d1c279589644566be45521e46878" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">어떤 호출 할 때 &lt;code&gt;base&lt;/code&gt; , &lt;code&gt;tonumber&lt;/code&gt; 는 숫자로 인수를 변환하려고합니다. 인수가 이미 숫자이거나 숫자로 변환 가능한 문자열 인 경우 &lt;code&gt;tonumber&lt;/code&gt; 는이 숫자를 리턴합니다. 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e694403948e49c3cdfc8883a69a69e59e1e2c12c" translate="yes" xml:space="preserve">
          <source>When called with option &lt;code&gt;-E&lt;/code&gt;, besides ignoring &lt;code&gt;LUA_INIT&lt;/code&gt;, Lua also ignores the values of &lt;code&gt;LUA_PATH&lt;/code&gt; and &lt;code&gt;LUA_CPATH&lt;/code&gt;, setting the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">옵션을 호출 할 때 &lt;code&gt;-E&lt;/code&gt; , 무시 외에 &lt;code&gt;LUA_INIT&lt;/code&gt; 을 , 루아도의 값 무시 &lt;code&gt;LUA_PATH&lt;/code&gt; 및 &lt;code&gt;LUA_CPATH&lt;/code&gt; 을 의 값 설정, &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; 을&lt;/a&gt; 에 정의 된 기본 경로와 &lt;code&gt;luaconf.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de667989e59831a06657a1b7bb1953b9b2690bfc" translate="yes" xml:space="preserve">
          <source>When called without a &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;os.execute&lt;/code&gt; returns a boolean that is true if a shell is available.</source>
          <target state="translated">없이 호출 할 때 &lt;code&gt;command&lt;/code&gt; , &lt;code&gt;os.execute&lt;/code&gt; 은 쉘을 사용할 수있는 경우 true 인 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08516ebb937ecdc973de2d47f44995af938578a2" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; turns off the hook.</source>
          <target state="translated">인수없이 호출되면 &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; 이 후크를 끕니다.</target>
        </trans-unit>
        <trans-unit id="8dfc7d66f66b8d42b0606debc6628a523caba4e4" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;code&gt;date&lt;/code&gt; returns a reasonable date and time representation that depends on the host system and on the current locale. (More specifically, &lt;code&gt;os.date()&lt;/code&gt; is equivalent to &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt;.)</source>
          <target state="translated">인수없이 호출하면 &lt;code&gt;date&lt;/code&gt; 는 호스트 시스템과 현재 로케일에 따라 합리적인 날짜 및 시간 표현을 반환합니다. 보다 구체적으로 &lt;code&gt;os.date()&lt;/code&gt; 는 &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c64be510d7a1b577fd35233990dcc39ace49bc5f" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. (The value &lt;em&gt;n-m&lt;/em&gt; cannot be negative and must fit in a Lua integer.) The call &lt;code&gt;math.random(n)&lt;/code&gt; is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;.</source>
          <target state="translated">인수없이 호출되면 &lt;em&gt;[0,1)&lt;/em&gt; 범위의 균일 한 분포를 가진 의사 난수 부동 소수점을 반환합니다 . 두 정수로 불리는 경우 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;math.random&lt;/code&gt; 반환 범위의 균일 분포 의사 랜덤 정수 &lt;em&gt;[N m,]&lt;/em&gt; . &lt;em&gt;nm&lt;/em&gt; 값 은 음수 일 수 없으며 Lua 정수에 맞아야합니다. &lt;code&gt;math.random(n)&lt;/code&gt; 호출 은 &lt;code&gt;math.random(1,n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29766b7237675cb97603d39839cfd67a198b7d0e" translate="yes" xml:space="preserve">
          <source>When called without option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt;&lt;code&gt;LUA_INIT_5_3&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; 옵션없이 호출되면 인터프리터는 인수를 실행하기 전에 환경 변수 &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt; &lt;code&gt;LUA_INIT_5_3&lt;/code&gt; &lt;/a&gt; (또는 버전 이름이 정의되지 않은 경우 &lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; )를&lt;/a&gt; 확인합니다. 변수 내용의 형식이 &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; 인 경우 &lt;code&gt;lua&lt;/code&gt; 는 파일을 실행합니다. 그렇지 않으면 &lt;code&gt;lua&lt;/code&gt; 는 문자열 자체를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="30a01c66de0f50f818dc4c5eb18a31a7ce0c4e4f" translate="yes" xml:space="preserve">
          <source>When closing a file handle created with &lt;a href=&quot;#pdf-io.popen&quot;&gt;&lt;code&gt;io.popen&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:close&quot;&gt;&lt;code&gt;file:close&lt;/code&gt;&lt;/a&gt; returns the same values returned by &lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만든 파일 핸들을 닫을 때 &lt;a href=&quot;#pdf-io.popen&quot;&gt; &lt;code&gt;io.popen&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:close&quot;&gt; &lt;code&gt;file:close&lt;/code&gt; &lt;/a&gt; 수익률은 같은 값에 의해 반환 &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37e9db54045b382cd01f62245d15a65082274498" translate="yes" xml:space="preserve">
          <source>When finishing normally, the interpreter closes its main Lua state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;). The script can avoid this step by calling &lt;a href=&quot;#pdf-os.exit&quot;&gt;&lt;code&gt;os.exit&lt;/code&gt;&lt;/a&gt; to terminate.</source>
          <target state="translated">정상적으로 끝나면 인터프리터는 기본 Lua 상태를 닫습니다 ( &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; 참조 ). 스크립트는 &lt;a href=&quot;#pdf-os.exit&quot;&gt; &lt;code&gt;os.exit&lt;/code&gt; &lt;/a&gt; 를 호출 하여 종료 함으로써이 단계를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05829140d113fda20398a82789b93e3ec1b75792" translate="yes" xml:space="preserve">
          <source>When possible, you may prefer to use &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt;&lt;code&gt;io.tmpfile&lt;/code&gt;&lt;/a&gt;, which automatically removes the file when the program ends.</source>
          <target state="translated">가능한 경우 프로그램 종료시 파일을 자동으로 제거하는 &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt; &lt;code&gt;io.tmpfile&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e0d813e63ce1dec1bf88d125498265fe1c745f04" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴이 다시 재개되면 Lua는 주어진 연속 함수 &lt;code&gt;k&lt;/code&gt; 를 호출하여 생성 된 C 함수의 실행을 계속합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 이 연속 함수는 이전 함수와 동일한 스택을 수신하고 &lt;code&gt;n&lt;/code&gt; 개의 결과가 제거되고 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 전달 된 인수로 대체됩니다 . 또한 연속 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 에 전달 된 &lt;code&gt;ctx&lt;/code&gt; 값을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6a10ad01c056a56db07a26afc7431181db765d" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt; (or &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;), &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function (level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function).</source>
          <target state="translated">: 후크가 호출되면, 그 첫 번째 파라미터는 호출을 트리거 한 이벤트를 기술하는 문자열 &lt;code&gt;&quot;call&quot;&lt;/code&gt; (또는 &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; ), &lt;code&gt;&quot;return&quot;&lt;/code&gt; , &lt;code&gt;&quot;line&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;count&quot;&lt;/code&gt; . 행 이벤트의 경우 후크는 새 행 번호를 두 번째 매개 변수로 가져옵니다. 후크 내에서 레벨 2로 &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 실행중인 함수에 대한 자세한 정보를 얻을 수 있습니다 (레벨 0은 &lt;code&gt;getinfo&lt;/code&gt; 함수이고 레벨 1은 후크 함수입니다).</target>
        </trans-unit>
        <trans-unit id="eaa8e9df04a952020bd076482c3d60135f7f329c" translate="yes" xml:space="preserve">
          <source>When using implicit file handles, all operations are supplied by table &lt;a id=&quot;pdf-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. When using explicit file handles, the operation &lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; returns a file handle and then all operations are supplied as methods of the file handle.</source>
          <target state="translated">내재적 파일 핸들을 사용할 때 모든 조작은 테이블 &lt;a id=&quot;pdf-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 에 의해 제공됩니다 . 명시 적 파일 핸들을 사용하는 경우 &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; 작업 은 파일 핸들을 반환 한 다음 모든 작업이 파일 핸들의 메서드로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="66e7217ccc689c6dec071df236389bbeca36a0c9" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything in the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고정 된 수의 결과없이 Lua 함수를 호출하면 ( &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 참조 ) Lua는 스택에 모든 결과를위한 충분한 공간이 있는지 확인하지만 추가 공간을 보장하지는 않습니다. 따라서 이러한 호출 후 스택의 내용을 푸시하기 전에 &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fac89278e16d9cfb7afed920548790f04b59edb" translate="yes" xml:space="preserve">
          <source>When you close a state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;), Lua calls the finalizers of all objects marked for finalization, following the reverse order that they were marked. If any finalizer marks objects for collection during that phase, these marks have no effect.</source>
          <target state="translated">상태를 닫으면 ( &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; 참조 ) Lua는 표시된 순서의 역순에 따라 종료로 표시된 모든 객체의 종료자를 호출합니다. 해당 단계에서 종료자가 수집 할 개체를 표시하면 이러한 표시가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfa2a1bee37ec1b8b5edb99fbbb2457d178207e5" translate="yes" xml:space="preserve">
          <source>When you create a new Lua state, its registry comes with some predefined values. These predefined values are indexed with integer keys defined as constants in &lt;code&gt;lua.h&lt;/code&gt;. The following constants are defined:</source>
          <target state="translated">새 Lua 상태를 만들면 레지스트리에 미리 정의 된 값이 제공됩니다. 이러한 사전 정의 된 값은 &lt;code&gt;lua.h&lt;/code&gt; 에서 상수로 정의 된 정수 키로 색인화됩니다 . 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7355d5bd1b6984cb05bdf3acfb6f9c1a447b9f50" translate="yes" xml:space="preserve">
          <source>When you interact with the Lua API, you are responsible for ensuring consistency. In particular, &lt;em&gt;you are responsible for controlling stack overflow&lt;/em&gt;. You can use the function &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt; to ensure that the stack has enough space for pushing new elements.</source>
          <target state="translated">Lua API와 상호 작용할 때 일관성을 유지해야합니다. 특히, &lt;em&gt;스택 오버 플로우를 제어 할 책임이 있습니다&lt;/em&gt; . &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 스택에 새 요소를 푸시하기에 충분한 공간이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8b32f8352fd78bcc7ec48884a68493230c9360" translate="yes" xml:space="preserve">
          <source>When you run it, it produces the following output:</source>
          <target state="translated">실행하면 다음과 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="59fc39a27b959170f68fd36bc3ff7103614c868a" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. (The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers.)</source>
          <target state="translated">&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 을 사용 하는 경우 오류 발생시 호출 될 &lt;em&gt;메시지 핸들러&lt;/em&gt; 를 제공 할 수 있습니다. 이 함수는 원래 오류 개체와 함께 호출되어 새 오류 개체를 반환합니다. 스택을 풀기 전에 호출되므로 스택을 검사하고 스택 역 추적을 생성하여 오류에 대한 추가 정보를 수집 할 수 있습니다. 이 메시지 핸들러는 여전히 보호 된 호출에 의해 보호됩니다. 따라서 메시지 핸들러 내부의 오류는 메시지 핸들러를 다시 호출합니다. 이 루프가 너무 오래 지속되면 Lua는 루프를 끊고 적절한 메시지를 리턴합니다. 메시지 핸들러는 일반 런타임 오류에 대해서만 호출됩니다. 메모리 할당 오류나 종료자를 실행하는 동안에는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15a645bbcf65be028c994caf05ae49cc42785d58" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra slots. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">Lua가 C를 호출 할 때마다 스택에 최소 &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; &lt;/a&gt; 추가 슬롯을 위한 공간이 확보됩니다 . &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 은 20 으로 정의되므로 일반적으로 코드에 루프를 사용하여 요소를 스택으로 푸시하지 않는 한 스택 공간에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc36795858181bb669bdb65cc9b9976ecc560ce7" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, the called function gets a new stack, which is independent of previous stacks and of stacks of C functions that are still active. This stack initially contains any arguments to the C function and it is where the C function can store temporary Lua values and must push its results to be returned to the caller (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua가 C를 호출 할 때마다 호출 된 함수는 새 스택을 가져옵니다.이 스택은 이전 스택 및 여전히 활성 상태 인 C 함수의 스택과 독립적입니다. 이 스택은 처음에 C 함수에 대한 인수를 포함하며 C 함수가 임시 Lua 값을 저장할 수있는 위치이며 결과를 호출자에게 리턴하도록해야합니다 ( &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0194275f7fed5a9af0589750161f145316d9d8f8" translate="yes" xml:space="preserve">
          <source>Whenever a C function is called, its upvalues are located at specific pseudo-indices. These pseudo-indices are produced by the macro &lt;a href=&quot;#lua_upvalueindex&quot;&gt;&lt;code&gt;lua_upvalueindex&lt;/code&gt;&lt;/a&gt;. The first upvalue associated with a function is at index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt;, and so on. Any access to &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt;, where &lt;em&gt;n&lt;/em&gt; is greater than the number of upvalues of the current function (but not greater than 256, which is one plus the maximum number of upvalues in a closure), produces an acceptable but invalid index.</source>
          <target state="translated">C 함수가 호출 될 때마다 그 업 값은 특정 의사 표시에 있습니다. 이러한 의사 표시는 &lt;a href=&quot;#lua_upvalueindex&quot;&gt; &lt;code&gt;lua_upvalueindex&lt;/code&gt; &lt;/a&gt; 매크로에 의해 생성됩니다 . 함수와 관련된 첫 번째 upvalue는 index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt; 등입니다. &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt; 대한 액세스 ( 여기서, &lt;em&gt;n&lt;/em&gt; 은 현재 함수의 최대 값 수보다 크지 만 256보다 크지 않음 (클로저의 최대 값의 1을 더한 값) 임)는 허용 가능하지만 유효하지 않은 색인을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7b599885fcde567666ae50c3832fa9901f1faa95" translate="yes" xml:space="preserve">
          <source>Whenever a hook is called, its &lt;code&gt;ar&lt;/code&gt; argument has its field &lt;code&gt;event&lt;/code&gt; set to the specific event that triggered the hook. Lua identifies these events with the following constants: &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt;&lt;code&gt;LUA_HOOKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt;&lt;code&gt;LUA_HOOKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt;&lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt;&lt;code&gt;LUA_HOOKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt;&lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt;&lt;/a&gt;. Moreover, for line events, the field &lt;code&gt;currentline&lt;/code&gt; is also set. To get the value of any other field in &lt;code&gt;ar&lt;/code&gt;, the hook must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">후크가 호출 될 때마다 &lt;code&gt;ar&lt;/code&gt; 인수는 필드 &lt;code&gt;event&lt;/code&gt; 가 후크를 트리거 한 특정 이벤트로 설정됩니다. Lua는 &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt; &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt; &lt;code&gt;LUA_HOOKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt; &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt; &lt;code&gt;LUA_HOOKLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt; &lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt; &lt;/a&gt; 상수로 이러한 이벤트를 식별합니다 . 또한 회선 이벤트의 경우 필드 &lt;code&gt;currentline&lt;/code&gt; 도 설정됩니다. &lt;code&gt;ar&lt;/code&gt; 의 다른 필드 값을 얻으려면 후크가 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77a4ffdfeb7ea6979c398f6e32e8da8ff060ce91" translate="yes" xml:space="preserve">
          <source>Whenever there is a &lt;code&gt;__newindex&lt;/code&gt; metamethod, Lua does not perform the primitive assignment. (If necessary, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.)</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; 메타 메서드 가있을 때마다 Lua는 기본 할당을 수행하지 않습니다. (필요한 경우 metamethod 자체는 &lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt; 을 호출 하여 할당을 수행 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="380018403674372e84fb15d5ec3167aa3cf9c5cb" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; (also called an &lt;em&gt;error message&lt;/em&gt;) is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects.</source>
          <target state="translated">오류가있을 때마다 &lt;em&gt;오류 개체&lt;/em&gt; ( &lt;em&gt;오류 메시지&lt;/em&gt; 라고도 함)에 &lt;em&gt;오류&lt;/em&gt; 에 대한 정보가 전파됩니다. Lua 자체는 오류 개체가 문자열 인 오류 만 생성하지만 프로그램은 오류 개체로 모든 값의 오류를 생성 할 수 있습니다. 이러한 오류 개체를 처리하는 것은 Lua 프로그램 또는 호스트의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="272f9a8e241eb8a55a33970a98b804e3cbb2993b" translate="yes" xml:space="preserve">
          <source>While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks.</source>
          <target state="translated">Lua는 후크를 실행하는 동안 다른 후크 호출을 비활성화합니다. 따라서 후크가 함수 또는 청크를 실행하기 위해 Lua를 콜백하는 경우 후크 실행없이이 실행이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="768488e627b06a1ccd84c86d3762c984059da019" translate="yes" xml:space="preserve">
          <source>While traversing a table, do not call &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테이블을 순회하는 동안 키가 실제로 문자열이라는 것을 모르면 키에서 직접 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 을&lt;/a&gt; 호출하지 마십시오 . 리콜 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 가&lt;/a&gt; 지정된 인덱스 값을 변경할 수있다; 이것은 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; 에&lt;/a&gt; 대한 다음 호출을 혼란스럽게합니다 .</target>
        </trans-unit>
        <trans-unit id="518506b1bd272cc87115a976ea99ba83864b9064" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers or strings that can be converted to numbers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), then they are converted to floats, the operation is performed following the usual rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float.</source>
          <target state="translated">지수화와 부동 소수점 나누기를 제외하고 산술 연산자는 다음과 같이 작동합니다. 두 피연산자가 모두 정수이면 연산이 정수에 대해 수행되고 결과는 정수입니다. 그렇지 않으면 두 피연산자가 모두 숫자 또는 숫자로 변환 할 수있는 문자열 인 경우 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ) 부동 소수점으로 변환되면, 부동 소수점 산술에 대한 일반적인 규칙 (일반적으로 IEEE 754 표준)에 따라 연산이 수행됩니다. 결과는 float입니다.</target>
        </trans-unit>
        <trans-unit id="ef23cb793be6d01c5592ed37d41262accad311cc" translate="yes" xml:space="preserve">
          <source>Writes the value of each of its arguments to &lt;code&gt;file&lt;/code&gt;. The arguments must be strings or numbers.</source>
          <target state="translated">각 인수의 값을 &lt;code&gt;file&lt;/code&gt; 에 씁니다 . 인수는 문자열 또는 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4b2eb6ac09b984e213b2d26d7367f553447ec91c" translate="yes" xml:space="preserve">
          <source>Yields a coroutine (thread).</source>
          <target state="translated">코 루틴 (스레드)을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4c14ae77965a71399e48d53e02bcb286bb93f6f2" translate="yes" xml:space="preserve">
          <source>You can also create and manipulate coroutines through the C API: see functions &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C API를 통해 코 루틴을 생성하고 조작 할 수도 있습니다 ( &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 함수 참조) .</target>
        </trans-unit>
        <trans-unit id="b7319a84c3be9c603d878df474f45dfa44f88afd" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &quot;eq&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">&quot;eq&quot;메타 메소드를 사용하여 Lua가 테이블과 사용자 데이터를 비교하는 방식을 변경할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3102901d0caee19c958fcee9d58ed56ee554d4f9" translate="yes" xml:space="preserve">
          <source>You can change these numbers by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., stop and restart it).</source>
          <target state="translated">C에서 &lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt; 또는 Lua에서 &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; 를 호출 하여이 숫자를 변경할 수 있습니다 . 이 기능을 사용하여 수집기를 직접 제어 할 수도 있습니다 (예 : 중지 및 재시작).</target>
        </trans-unit>
        <trans-unit id="1aa1c0455b97a9145781995effbd7a91d175f4dd" translate="yes" xml:space="preserve">
          <source>You can fix these differences by forcing a number to be a float (in Lua 5.2 all numbers were float), in particular writing constants with an ending &lt;code&gt;.0&lt;/code&gt; or using &lt;code&gt;x = x + 0.0&lt;/code&gt; to convert a variable. (This recommendation is only for a quick fix for an occasional incompatibility; it is not a general guideline for good programming. For good programming, use floats where you need floats and integers where you need integers.)</source>
          <target state="translated">당신은 끝으로, 특히 쓰기 상수 (루아 5.2에서 모든 숫자가 부동이었다) 부동 소수점이 될 수있는 수를 강제로 이러한 차이를 해결할 수 있습니다 &lt;code&gt;.0&lt;/code&gt; 또는 사용하여 &lt;code&gt;x = x + 0.0&lt;/code&gt; 변수를 변환 할 수 있습니다. (이 권장 사항은 가끔 호환되지 않는 문제를 신속하게 해결하기위한 것입니다. 좋은 프로그래밍을위한 일반적인 지침은 아닙니다. 좋은 프로그래밍을 위해서는 float가 필요한 곳에 float를, 정수가 필요한 곳에 integer를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="6b9f9c8aada12f19e8959797fbd200469c989aaf" translate="yes" xml:space="preserve">
          <source>You can only call functions in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">상태가 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 인&lt;/a&gt; 스레드에서만 함수를 호출 할 수 있습니다 . &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (새 코 루틴을 시작하기 위해) 또는 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; (코 루틴을 다시 시작하기 위해 ) 상태로 스레드를 재개 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8061a68da1d074d2f5c5e92636b71ce2c9bfb53d" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put an hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">세트에서 첫 번째 문자로 배치하여 닫는 대괄호를 세트에 넣을 수 있습니다. 세트에서 첫 번째 또는 마지막 문자로 하이픈을 배치하여 세트에 하이픈을 넣을 수 있습니다. 두 경우 모두 이스케이프를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2781e61b519fd47b1d4f450639555b1c01907b6" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;). So, to retrieve the metamethod for event &lt;code&gt;ev&lt;/code&gt; in object &lt;code&gt;o&lt;/code&gt;, Lua does the equivalent to the following code:</source>
          <target state="translated">&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 모든 값의 메타 테이블을 쿼리 할 수 ​​있습니다 . Lua는 원시 액세스를 사용하여 메타 테이블에서 메타 메서드를 쿼리합니다 ( &lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 객체 &lt;code&gt;o&lt;/code&gt; 에서 &lt;code&gt;ev&lt;/code&gt; 이벤트에 대한 메타 메소드를 검색하기 위해 Lua는 다음 코드와 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d1dc46c8e9720bcf85f3abea3ac1cb55affdcb0d" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code (except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;)); you should use the C API for that.</source>
          <target state="translated">&lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 테이블의 메타 테이블을 바꿀 수 있습니다 . Lua 코드에서 다른 유형의 메타 테이블을 변경할 수 없습니다 (디버그 라이브러리 ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; ) 사용 제외 ). 이를 위해 C API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e58a48a2bbf52e5804761968441fe7ea238d5cc" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods are also called &lt;em&gt;finalizers&lt;/em&gt;. Finalizers allow you to coordinate Lua's garbage collection with external resource management (such as closing files, network or database connections, or freeing your own memory).</source>
          <target state="translated">테이블 및 C API를 사용하여 전체 사용자 데이터에 대해 가비지 수집기 메타 메서드를 설정할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 이러한 메타 메소드는 &lt;em&gt;파이널 라이저&lt;/em&gt; 라고도 합니다. Finalizer를 사용하면 외부 리소스 관리 (예 : 파일 닫기, 네트워크 또는 데이터베이스 연결 또는 자체 메모리 확보)와 함께 Lua의 가비지 수집을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1a4e1dd00034824534614f2bda7911ae8431cd" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; and &lt;b&gt;goto&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">&lt;b&gt;break&lt;/b&gt; 및 &lt;b&gt;goto&lt;/b&gt; 를 사용 하여 &lt;b&gt;for&lt;/b&gt; 루프 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b27cc8080576c27c1dd2a0afb3a34a7a52ff85b8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">&lt;b&gt;break&lt;/b&gt; 를 사용 하여 &lt;b&gt;for&lt;/b&gt; 루프 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d52df43ef083f76a03d8e01f3e9a36da3fc66f0d" translate="yes" xml:space="preserve">
          <source>You create a coroutine by calling &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;. Its sole argument is a function that is the main function of the coroutine. The &lt;code&gt;create&lt;/code&gt; function only creates a new coroutine and returns a handle to it (an object of type &lt;em&gt;thread&lt;/em&gt;); it does not start the coroutine.</source>
          <target state="translated">당신은 호출하여 코 루틴을 만들 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; 을&lt;/a&gt; . 유일한 주장은 코 루틴의 주요 기능인 기능입니다. &lt;code&gt;create&lt;/code&gt; 기능은 새로운 코 루틴을 생성하고 (유형의 객체에 대한 핸들 반환 &lt;em&gt;스레드&lt;/em&gt; ); 코 루틴을 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ef445026cd0a146e81e995bc4681bfd5e57e5c5" translate="yes" xml:space="preserve">
          <source>You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection).</source>
          <target state="translated">결과를위한 공간을 할당 할 필요는 없습니다. 결과는 Lua 문자열이며 Lua는 메모리 할당 (및 가비지 수집을 통한 할당 해제)을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="76e561e2abeb8c3fca97fd50eca052b57e9c65f8" translate="yes" xml:space="preserve">
          <source>You execute a coroutine by calling &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. When you first call &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, passing as its first argument a thread returned by &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the coroutine starts its execution by calling its main function. Extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; are passed as arguments to that function. After the coroutine starts running, it runs until it terminates or &lt;em&gt;yields&lt;/em&gt;.</source>
          <target state="translated">당신은 호출하여 코 루틴을 실행 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 을&lt;/a&gt; . 처음 호출 할 때 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 을&lt;/a&gt; , 첫 번째 인자에 의해 반환 된 스레드로 전달 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; , 코 루틴은 메인 함수를 호출하여 실행을 시작합니다. &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 에 전달 된 추가 인수는 해당 함수에 대한 인수로 전달됩니다. 코 루틴이 시작이 실행 한 후에는 종료 때까지 또는, 그것은 실행 &lt;em&gt;수익률&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f53454c1d52c8e8625f900a3b2f28a52f9ab6262" translate="yes" xml:space="preserve">
          <source>_G</source>
          <target state="translated">_G</target>
        </trans-unit>
        <trans-unit id="2f7691c85ede2ffb322e774a60315181bf799f71" translate="yes" xml:space="preserve">
          <source>_VERSION</source>
          <target state="translated">_VERSION</target>
        </trans-unit>
        <trans-unit id="88f22daca599d25013aaf6d4c6cefa12b839e072" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches zero or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;*&lt;/code&gt; '가옵니다. 이는 클래스에서 0 개 이상의 문자 반복과 일치합니다. 이 반복 항목은 항상 가장 긴 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9f3711be8dd7bfb74572554b6c7626ae533f6527" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches one or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">클래스에서 하나 이상의 문자 반복과 일치 하는 ' &lt;code&gt;+&lt;/code&gt; '가 뒤에 오는 단일 문자 클래스 이 반복 항목은 항상 가장 긴 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7c2c202847f17af45741edd719e4addc76505a81" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches zero or more repetitions of characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;-&lt;/code&gt; '가 오며, 이는 클래스에서 0 개 이상의 문자 반복과도 일치합니다. ' &lt;code&gt;*&lt;/code&gt; ' 와 달리이 반복 항목은 항상 가장 짧은 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="237b908d85fd5486211190c63284fa599c924a55" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;?&lt;/code&gt;', which matches zero or one occurrence of a character in the class. It always matches one occurrence if possible;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;?&lt;/code&gt; '는 클래스에서 0 또는 1 개의 문자 발생과 일치합니다. 가능하면 항상 한 번만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0c5e2141926ba6afbd01b9f0df61d70a7c93f57e" translate="yes" xml:space="preserve">
          <source>a single character class, which matches any single character in the class;</source>
          <target state="translated">클래스의 단일 문자와 일치하는 단일 문자 클래스;</target>
        </trans-unit>
        <trans-unit id="63ae10d79f4a0c4781e4e9b2dacd5c9896a57556" translate="yes" xml:space="preserve">
          <source>assert()</source>
          <target state="translated">assert()</target>
        </trans-unit>
        <trans-unit id="d9b7850ae45b39d5960b24328cbe68f8d5986e4d" translate="yes" xml:space="preserve">
          <source>basic UTF-8 support (&lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt;);</source>
          <target state="translated">기본 UTF-8 지원 ( &lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="fefa5c394d291465c545b09029d833606f910bf8" translate="yes" xml:space="preserve">
          <source>basic library (&lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;);</source>
          <target state="translated">기본 라이브러리 ( &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="74dcaf5215a85f0f3fdfba06d8dc2140d162bce8" translate="yes" xml:space="preserve">
          <source>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</source>
          <target state="translated">작성자 : Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</target>
        </trans-unit>
        <trans-unit id="85f91b3e97f2cf4928f588f868b5b56e41f46ac7" translate="yes" xml:space="preserve">
          <source>can be used to call &quot;methods&quot;. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">&quot;방법&quot;을 호출하는 데 사용할 수 있습니다. &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 호출 은 &lt;code&gt;v&lt;/code&gt; 가 한 번만 평가 된다는 점을 제외하고 &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="db3586e1e0bcc962d7bc2f3fead617414fb7e605" translate="yes" xml:space="preserve">
          <source>collectgarbage()</source>
          <target state="translated">collectgarbage()</target>
        </trans-unit>
        <trans-unit id="2d524624e9fa583630d5fa0595340fdebfe37ef7" translate="yes" xml:space="preserve">
          <source>coroutine library (&lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt;);</source>
          <target state="translated">코 루틴 라이브러리 ( &lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="20cd53c84ed6149d722a861cd300131fe78d55e2" translate="yes" xml:space="preserve">
          <source>coroutine.create()</source>
          <target state="translated">coroutine.create()</target>
        </trans-unit>
        <trans-unit id="6817fb4ac877543987e9d2cf2bfa960bd73b02b0" translate="yes" xml:space="preserve">
          <source>coroutine.isyieldable()</source>
          <target state="translated">coroutine.isyieldable()</target>
        </trans-unit>
        <trans-unit id="1c13fd77eddf40ec2374814bf03a272d614ac054" translate="yes" xml:space="preserve">
          <source>coroutine.resume()</source>
          <target state="translated">coroutine.resume()</target>
        </trans-unit>
        <trans-unit id="b96ab0d2970d06f0cea57e5eaa71cf5ecdd618a8" translate="yes" xml:space="preserve">
          <source>coroutine.running()</source>
          <target state="translated">coroutine.running()</target>
        </trans-unit>
        <trans-unit id="ba662b8414ef9e3a4eaa77d2c840fa4c12339222" translate="yes" xml:space="preserve">
          <source>coroutine.status()</source>
          <target state="translated">coroutine.status()</target>
        </trans-unit>
        <trans-unit id="bf3b61ea5fdfb1c6f4aa0021505b10377c2744b9" translate="yes" xml:space="preserve">
          <source>coroutine.wrap()</source>
          <target state="translated">coroutine.wrap()</target>
        </trans-unit>
        <trans-unit id="28fa9aab8f13eb98b7d555b1121c4e2f64da5b24" translate="yes" xml:space="preserve">
          <source>coroutine.yield()</source>
          <target state="translated">coroutine.yield()</target>
        </trans-unit>
        <trans-unit id="bc4250ca52c74e734bc1d8dcc7ef8d0520de4aaa" translate="yes" xml:space="preserve">
          <source>cyclically permutes the values of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 값을 주기적으로 치환합니다 .</target>
        </trans-unit>
        <trans-unit id="7fc37eb5efdf9ff1862bafe05aed17223474f19e" translate="yes" xml:space="preserve">
          <source>debug facilities (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="translated">디버그 시설 ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c1a035b9bc9a59ee427755de3995caa474bf89cc" translate="yes" xml:space="preserve">
          <source>debug.debug()</source>
          <target state="translated">debug.debug()</target>
        </trans-unit>
        <trans-unit id="c971abb1fa089b8c01b33b3e61921a80abf7c06f" translate="yes" xml:space="preserve">
          <source>debug.gethook()</source>
          <target state="translated">debug.gethook()</target>
        </trans-unit>
        <trans-unit id="93d200866b9bcba05bb2fbdb0b02c21c4fcadd36" translate="yes" xml:space="preserve">
          <source>debug.getinfo()</source>
          <target state="translated">debug.getinfo()</target>
        </trans-unit>
        <trans-unit id="9c1f49683c1f31aa48e18ec3c6e238b90d9877a6" translate="yes" xml:space="preserve">
          <source>debug.getlocal()</source>
          <target state="translated">debug.getlocal()</target>
        </trans-unit>
        <trans-unit id="89340827a359650ba96d79c885a6ca4ba9aa8aef" translate="yes" xml:space="preserve">
          <source>debug.getmetatable()</source>
          <target state="translated">debug.getmetatable()</target>
        </trans-unit>
        <trans-unit id="fffbe040208115d0321d4eeace7d38146d8b779c" translate="yes" xml:space="preserve">
          <source>debug.getregistry()</source>
          <target state="translated">debug.getregistry()</target>
        </trans-unit>
        <trans-unit id="095455b157eeda9acc90fedb4797142620c5d14f" translate="yes" xml:space="preserve">
          <source>debug.getupvalue()</source>
          <target state="translated">debug.getupvalue()</target>
        </trans-unit>
        <trans-unit id="9162f2fe620127cc4293925b2377e32607ea8dc1" translate="yes" xml:space="preserve">
          <source>debug.getuservalue()</source>
          <target state="translated">debug.getuservalue()</target>
        </trans-unit>
        <trans-unit id="5d34b4b5c93313dfde5400d9a75ed878cf0387fa" translate="yes" xml:space="preserve">
          <source>debug.sethook()</source>
          <target state="translated">debug.sethook()</target>
        </trans-unit>
        <trans-unit id="8d6540f978db914670045fee4aeab3edf193a0f7" translate="yes" xml:space="preserve">
          <source>debug.setlocal()</source>
          <target state="translated">debug.setlocal()</target>
        </trans-unit>
        <trans-unit id="1114ca4ac80d07a2dd5b825ad95efef0ef3e793e" translate="yes" xml:space="preserve">
          <source>debug.setmetatable()</source>
          <target state="translated">debug.setmetatable()</target>
        </trans-unit>
        <trans-unit id="51aa91aad9ead0a16c3b18216ab378a0c7743c8a" translate="yes" xml:space="preserve">
          <source>debug.setupvalue()</source>
          <target state="translated">debug.setupvalue()</target>
        </trans-unit>
        <trans-unit id="f2501aa1b4b928ba1fabc7b41a5fb6149ff08df1" translate="yes" xml:space="preserve">
          <source>debug.setuservalue()</source>
          <target state="translated">debug.setuservalue()</target>
        </trans-unit>
        <trans-unit id="062b699a5c8040e4380b7e57fdbdd344d80078ab" translate="yes" xml:space="preserve">
          <source>debug.traceback()</source>
          <target state="translated">debug.traceback()</target>
        </trans-unit>
        <trans-unit id="4df320c6f6fe873dd83c68f666d97892b28ec64d" translate="yes" xml:space="preserve">
          <source>debug.upvalueid()</source>
          <target state="translated">debug.upvalueid()</target>
        </trans-unit>
        <trans-unit id="5f36f6ccf1f675b9be026448d71741416a53b37b" translate="yes" xml:space="preserve">
          <source>debug.upvaluejoin()</source>
          <target state="translated">debug.upvaluejoin()</target>
        </trans-unit>
        <trans-unit id="e89edbb9c58150e26495396202b965437b3a50b7" translate="yes" xml:space="preserve">
          <source>dofile()</source>
          <target state="translated">dofile()</target>
        </trans-unit>
        <trans-unit id="aca90d914519fdb9825352bdc0befb59f7c8510f" translate="yes" xml:space="preserve">
          <source>error()</source>
          <target state="translated">error()</target>
        </trans-unit>
        <trans-unit id="7de161b32a875844eeba37dec3fece9537cba714" translate="yes" xml:space="preserve">
          <source>exchanges the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 값을 교환 하고</target>
        </trans-unit>
        <trans-unit id="8125a41f11b23917e7e65f29d3d2213542b187d6" translate="yes" xml:space="preserve">
          <source>file:close()</source>
          <target state="translated">file:close()</target>
        </trans-unit>
        <trans-unit id="7f9463f78fd5cd83c9041f64fea79cbc2be426fe" translate="yes" xml:space="preserve">
          <source>file:flush()</source>
          <target state="translated">file:flush()</target>
        </trans-unit>
        <trans-unit id="5350a8e4e9cb0246271da43a0fa066f5ae579d41" translate="yes" xml:space="preserve">
          <source>file:lines()</source>
          <target state="translated">file:lines()</target>
        </trans-unit>
        <trans-unit id="fedafec70b95fc957651a750d98a82f4f987be28" translate="yes" xml:space="preserve">
          <source>file:read()</source>
          <target state="translated">file:read()</target>
        </trans-unit>
        <trans-unit id="9f5590af86d743ff26b34c28e7536d697a016b27" translate="yes" xml:space="preserve">
          <source>file:seek()</source>
          <target state="translated">file:seek()</target>
        </trans-unit>
        <trans-unit id="4e7bf5fa403a667454318d150407999144cf27b5" translate="yes" xml:space="preserve">
          <source>file:setvbuf()</source>
          <target state="translated">file:setvbuf()</target>
        </trans-unit>
        <trans-unit id="9309e4bec0b7e7bd4928e73f4224b1260fd1601c" translate="yes" xml:space="preserve">
          <source>file:write()</source>
          <target state="translated">file:write()</target>
        </trans-unit>
        <trans-unit id="fbf75d56032c5bc04852f3d225c59fdc7c7f99d1" translate="yes" xml:space="preserve">
          <source>getmetatable()</source>
          <target state="translated">getmetatable()</target>
        </trans-unit>
        <trans-unit id="ba0178b11b8996b5f85446dda8d3e50657e671a9" translate="yes" xml:space="preserve">
          <source>input and output (&lt;a href=&quot;#6.8&quot;&gt;&amp;sect;6.8&lt;/a&gt;);</source>
          <target state="translated">입력 및 출력 ( &lt;a href=&quot;#6.8&quot;&gt;&amp;sect;6.8&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="6246bb83a026afe40f4ad10618e03e88e73e7a81" translate="yes" xml:space="preserve">
          <source>io.close()</source>
          <target state="translated">io.close()</target>
        </trans-unit>
        <trans-unit id="85d1bfb6c595e03540dff03731e49b68d1ff4a6a" translate="yes" xml:space="preserve">
          <source>io.flush()</source>
          <target state="translated">io.flush()</target>
        </trans-unit>
        <trans-unit id="e4b0b4836b0fa20db84c0844641175790a2a940e" translate="yes" xml:space="preserve">
          <source>io.input()</source>
          <target state="translated">io.input()</target>
        </trans-unit>
        <trans-unit id="02a116ac6887e9a612f57a4a78d1d9eb015ead5a" translate="yes" xml:space="preserve">
          <source>io.lines()</source>
          <target state="translated">io.lines()</target>
        </trans-unit>
        <trans-unit id="d01b5904d4df7b29d4d89db45c4049c0cad2592f" translate="yes" xml:space="preserve">
          <source>io.open()</source>
          <target state="translated">io.open()</target>
        </trans-unit>
        <trans-unit id="61fc2c48f2cfef754416be8f28365d49b792a924" translate="yes" xml:space="preserve">
          <source>io.output()</source>
          <target state="translated">io.output()</target>
        </trans-unit>
        <trans-unit id="e8ba874f180d58de6d9f409ad4e2404164b7e44d" translate="yes" xml:space="preserve">
          <source>io.popen()</source>
          <target state="translated">io.popen()</target>
        </trans-unit>
        <trans-unit id="8b2272babe05e59501ff1a6820f09f54cf16f8a2" translate="yes" xml:space="preserve">
          <source>io.read()</source>
          <target state="translated">io.read()</target>
        </trans-unit>
        <trans-unit id="a0b2a0ebdc9794b4aecbd87c2018d5ea828badea" translate="yes" xml:space="preserve">
          <source>io.tmpfile()</source>
          <target state="translated">io.tmpfile()</target>
        </trans-unit>
        <trans-unit id="b661232dc8780d573d2852bc920e9307b1388302" translate="yes" xml:space="preserve">
          <source>io.type()</source>
          <target state="translated">io.type()</target>
        </trans-unit>
        <trans-unit id="0cdd03129a4d3df494966138f684a6d1a11e522b" translate="yes" xml:space="preserve">
          <source>io.write()</source>
          <target state="translated">io.write()</target>
        </trans-unit>
        <trans-unit id="7f6ad977f87ec66b3c78d79c080664dfe651a035" translate="yes" xml:space="preserve">
          <source>ipairs()</source>
          <target state="translated">ipairs()</target>
        </trans-unit>
        <trans-unit id="88f91e6a3fad63baf72bfb22cd7f24d5b1819dea" translate="yes" xml:space="preserve">
          <source>is a more portable solution.)</source>
          <target state="translated">더 편리한 솔루션입니다.)</target>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="653a2dec8925e5c13f534c35dab8997b7d2e737f" translate="yes" xml:space="preserve">
          <source>is equivalent to the code:</source>
          <target state="translated">코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d37326644b985922e36313c41fd9c9fdfe1ac47e" translate="yes" xml:space="preserve">
          <source>is syntactic sugar for</source>
          <target state="translated">구문 설탕이다</target>
        </trans-unit>
        <trans-unit id="94ea5f589396df68c37d6c28efac0a817a2fa0ce" translate="yes" xml:space="preserve">
          <source>load()</source>
          <target state="translated">load()</target>
        </trans-unit>
        <trans-unit id="990f79bf18f8afa5aa612d846565fb5fe7335f6a" translate="yes" xml:space="preserve">
          <source>loadfile()</source>
          <target state="translated">loadfile()</target>
        </trans-unit>
        <trans-unit id="4f6f69bf994e2e3978bd85ef12a2047556de548b" translate="yes" xml:space="preserve">
          <source>luaL_Buffer</source>
          <target state="translated">luaL_Buffer</target>
        </trans-unit>
        <trans-unit id="75ae9b49b15a3c972ba27eb22d44e99456d06ff8" translate="yes" xml:space="preserve">
          <source>luaL_Reg</source>
          <target state="translated">luaL_Reg</target>
        </trans-unit>
        <trans-unit id="7bfe1c05a8eee1e600a722d0939dfb9c2de61a21" translate="yes" xml:space="preserve">
          <source>luaL_Stream</source>
          <target state="translated">luaL_Stream</target>
        </trans-unit>
        <trans-unit id="ed2d6b35ba757f2b0183a8f125b5661f452a6328" translate="yes" xml:space="preserve">
          <source>luaL_addchar</source>
          <target state="translated">luaL_addchar</target>
        </trans-unit>
        <trans-unit id="2db82af979263253280a3bfa63cc1b723f3dbe80" translate="yes" xml:space="preserve">
          <source>luaL_addlstring</source>
          <target state="translated">luaL_addlstring</target>
        </trans-unit>
        <trans-unit id="8c1a978ed4cd9294733e68521841b4c2d122b294" translate="yes" xml:space="preserve">
          <source>luaL_addsize</source>
          <target state="translated">luaL_addsize</target>
        </trans-unit>
        <trans-unit id="acc1e95003d98b9547c52fa916d201ab47f15c3f" translate="yes" xml:space="preserve">
          <source>luaL_addstring</source>
          <target state="translated">luaL_addstring</target>
        </trans-unit>
        <trans-unit id="6e676a5af76c3e907d126b0fa168103ee32f76cf" translate="yes" xml:space="preserve">
          <source>luaL_addvalue</source>
          <target state="translated">luaL_addvalue</target>
        </trans-unit>
        <trans-unit id="512da00c5c9340484c3615f17562f2ecfd7d27f6" translate="yes" xml:space="preserve">
          <source>luaL_argcheck</source>
          <target state="translated">luaL_argcheck</target>
        </trans-unit>
        <trans-unit id="070a8a12838bd8eb3c9568a3882e05b41c2624e8" translate="yes" xml:space="preserve">
          <source>luaL_argerror</source>
          <target state="translated">luaL_argerror</target>
        </trans-unit>
        <trans-unit id="4bb2adb757eaa385f040aedd58266a13eef6017c" translate="yes" xml:space="preserve">
          <source>luaL_buffinit</source>
          <target state="translated">luaL_buffinit</target>
        </trans-unit>
        <trans-unit id="739387392e927bf4c3f3f3499dcaf9fc80133eb3" translate="yes" xml:space="preserve">
          <source>luaL_buffinitsize</source>
          <target state="translated">luaL_buffinitsize</target>
        </trans-unit>
        <trans-unit id="89e1118a10018ab78f55640b01b492a6010200fb" translate="yes" xml:space="preserve">
          <source>luaL_callmeta</source>
          <target state="translated">luaL_callmeta</target>
        </trans-unit>
        <trans-unit id="2ec02e2efd59e70841953d5cb667b2eaee24842b" translate="yes" xml:space="preserve">
          <source>luaL_checkany</source>
          <target state="translated">luaL_checkany</target>
        </trans-unit>
        <trans-unit id="45a4c0deec96469470bd9f8fec1176087e941d25" translate="yes" xml:space="preserve">
          <source>luaL_checkinteger</source>
          <target state="translated">luaL_checkinteger</target>
        </trans-unit>
        <trans-unit id="6c0b94a53d19f93ab224e9d73da9a53d3b57576e" translate="yes" xml:space="preserve">
          <source>luaL_checklstring</source>
          <target state="translated">luaL_checklstring</target>
        </trans-unit>
        <trans-unit id="bdd98c1069f52cfa0a77f6f1fa1f7a381bd319c8" translate="yes" xml:space="preserve">
          <source>luaL_checknumber</source>
          <target state="translated">luaL_checknumber</target>
        </trans-unit>
        <trans-unit id="dea4149bbeb5c96ab00e56f3a40a728177561895" translate="yes" xml:space="preserve">
          <source>luaL_checkoption</source>
          <target state="translated">luaL_checkoption</target>
        </trans-unit>
        <trans-unit id="7abcd7b0f9edc82d0b162b632cb5dce59ed546e0" translate="yes" xml:space="preserve">
          <source>luaL_checkstack</source>
          <target state="translated">luaL_checkstack</target>
        </trans-unit>
        <trans-unit id="a9ffe08b4654e57193b67999e8c605a524e35282" translate="yes" xml:space="preserve">
          <source>luaL_checkstring</source>
          <target state="translated">luaL_checkstring</target>
        </trans-unit>
        <trans-unit id="3b6564b6f77cf97b83b4afde8ba55c7415013932" translate="yes" xml:space="preserve">
          <source>luaL_checktype</source>
          <target state="translated">luaL_checktype</target>
        </trans-unit>
        <trans-unit id="ebb8e7fac5d3c22414b8b697dbe9c2f6292a9697" translate="yes" xml:space="preserve">
          <source>luaL_checkudata</source>
          <target state="translated">luaL_checkudata</target>
        </trans-unit>
        <trans-unit id="15b72fde083417bd29a134aa94b71a12faec83ac" translate="yes" xml:space="preserve">
          <source>luaL_checkversion</source>
          <target state="translated">luaL_checkversion</target>
        </trans-unit>
        <trans-unit id="1b12b8a5479fd8ca4a4aebe564adf3fd2e71aaaa" translate="yes" xml:space="preserve">
          <source>luaL_dofile</source>
          <target state="translated">luaL_dofile</target>
        </trans-unit>
        <trans-unit id="8da5c015a170dfc8aabf4073c0d9667459756e49" translate="yes" xml:space="preserve">
          <source>luaL_dostring</source>
          <target state="translated">luaL_dostring</target>
        </trans-unit>
        <trans-unit id="a88285e77f359da17643c8d59a9fe51f7fc90585" translate="yes" xml:space="preserve">
          <source>luaL_error</source>
          <target state="translated">luaL_error</target>
        </trans-unit>
        <trans-unit id="ffaca3d6f7817e03618805efe35aeeaa37125197" translate="yes" xml:space="preserve">
          <source>luaL_execresult</source>
          <target state="translated">luaL_execresult</target>
        </trans-unit>
        <trans-unit id="04244b804b3942a450aeaf5416bf2f26749d4aab" translate="yes" xml:space="preserve">
          <source>luaL_fileresult</source>
          <target state="translated">luaL_fileresult</target>
        </trans-unit>
        <trans-unit id="3a509cc11fa710f4c130ecb1ee2277d7af6c71ef" translate="yes" xml:space="preserve">
          <source>luaL_getmetafield</source>
          <target state="translated">luaL_getmetafield</target>
        </trans-unit>
        <trans-unit id="c30f269a05b1548ae99d842e49a1b574d4702024" translate="yes" xml:space="preserve">
          <source>luaL_getmetatable</source>
          <target state="translated">luaL_getmetatable</target>
        </trans-unit>
        <trans-unit id="0f310a9b09f35057b9b99ce12eb67091bb6b9b9a" translate="yes" xml:space="preserve">
          <source>luaL_getsubtable</source>
          <target state="translated">luaL_getsubtable</target>
        </trans-unit>
        <trans-unit id="86f359efca07adc64c17e43dd9f93adc9bc99bbe" translate="yes" xml:space="preserve">
          <source>luaL_gsub</source>
          <target state="translated">luaL_gsub</target>
        </trans-unit>
        <trans-unit id="9dcba4501006667792c83cca8d4a0a5353247cb5" translate="yes" xml:space="preserve">
          <source>luaL_len</source>
          <target state="translated">luaL_len</target>
        </trans-unit>
        <trans-unit id="69dbf01dbfc26d3db2fdbbeaee75362fdc212064" translate="yes" xml:space="preserve">
          <source>luaL_loadbuffer</source>
          <target state="translated">luaL_loadbuffer</target>
        </trans-unit>
        <trans-unit id="a77e6e5d663e4ba3bc0f0467aa33f88bccf64bb8" translate="yes" xml:space="preserve">
          <source>luaL_loadbufferx</source>
          <target state="translated">luaL_loadbufferx</target>
        </trans-unit>
        <trans-unit id="4d6d55445f32719fc15456f49f40569b17194693" translate="yes" xml:space="preserve">
          <source>luaL_loadfile</source>
          <target state="translated">luaL_loadfile</target>
        </trans-unit>
        <trans-unit id="f59b66bd9ce418b9e9dc168007b942d3eea34813" translate="yes" xml:space="preserve">
          <source>luaL_loadfilex</source>
          <target state="translated">luaL_loadfilex</target>
        </trans-unit>
        <trans-unit id="0274c764b14424421b072d40b8275e2177249298" translate="yes" xml:space="preserve">
          <source>luaL_loadstring</source>
          <target state="translated">luaL_loadstring</target>
        </trans-unit>
        <trans-unit id="17f06f1a51044653bb3b75032d97d5dcb5adf971" translate="yes" xml:space="preserve">
          <source>luaL_newlib</source>
          <target state="translated">luaL_newlib</target>
        </trans-unit>
        <trans-unit id="f5e32ee509764c7fb0cdc5a10584a057e357aba7" translate="yes" xml:space="preserve">
          <source>luaL_newlibtable</source>
          <target state="translated">luaL_newlibtable</target>
        </trans-unit>
        <trans-unit id="01a922aaee5e280338f45eefbc692a5cabcc2cce" translate="yes" xml:space="preserve">
          <source>luaL_newmetatable</source>
          <target state="translated">luaL_newmetatable</target>
        </trans-unit>
        <trans-unit id="bcece2773966cbc86bd710100a33ce9aa639cc79" translate="yes" xml:space="preserve">
          <source>luaL_newstate</source>
          <target state="translated">luaL_newstate</target>
        </trans-unit>
        <trans-unit id="7bdf4b6ba13f21a827617edbb6681261b474ac79" translate="yes" xml:space="preserve">
          <source>luaL_openlibs</source>
          <target state="translated">luaL_openlibs</target>
        </trans-unit>
        <trans-unit id="d6f99587381414400fc1872e7e2e8bb334d16bee" translate="yes" xml:space="preserve">
          <source>luaL_opt</source>
          <target state="translated">luaL_opt</target>
        </trans-unit>
        <trans-unit id="a89674c4effce38614662b1819cc770972c2e5d6" translate="yes" xml:space="preserve">
          <source>luaL_optinteger</source>
          <target state="translated">luaL_optinteger</target>
        </trans-unit>
        <trans-unit id="2a66aceb75d6c20448b21e86a65b02cfbecd5cee" translate="yes" xml:space="preserve">
          <source>luaL_optlstring</source>
          <target state="translated">luaL_optlstring</target>
        </trans-unit>
        <trans-unit id="e073fdb26e448e09038754b9d00254f6d5677a87" translate="yes" xml:space="preserve">
          <source>luaL_optnumber</source>
          <target state="translated">luaL_optnumber</target>
        </trans-unit>
        <trans-unit id="aec8086327bf6095f6265f43973f53e24fe44a1e" translate="yes" xml:space="preserve">
          <source>luaL_optstring</source>
          <target state="translated">luaL_optstring</target>
        </trans-unit>
        <trans-unit id="7f845281846b04a34b02ca950718fe1eb8926360" translate="yes" xml:space="preserve">
          <source>luaL_prepbuffer</source>
          <target state="translated">luaL_prepbuffer</target>
        </trans-unit>
        <trans-unit id="894cf6364aba958c224dabdee91724da16326f25" translate="yes" xml:space="preserve">
          <source>luaL_prepbuffsize</source>
          <target state="translated">luaL_prepbuffsize</target>
        </trans-unit>
        <trans-unit id="4de47cf904acfa941972bc2be93fa95344aef182" translate="yes" xml:space="preserve">
          <source>luaL_pushresult</source>
          <target state="translated">luaL_pushresult</target>
        </trans-unit>
        <trans-unit id="11fa7cbcb8e0f5efb6f0184dbfa55f82d5daf047" translate="yes" xml:space="preserve">
          <source>luaL_pushresultsize</source>
          <target state="translated">luaL_pushresultsize</target>
        </trans-unit>
        <trans-unit id="ef246b1a95e2efe047ca6f703c4265e0640812c8" translate="yes" xml:space="preserve">
          <source>luaL_ref</source>
          <target state="translated">luaL_ref</target>
        </trans-unit>
        <trans-unit id="9fdf3319005fdb3b8dd4728f6d3b67be5de64822" translate="yes" xml:space="preserve">
          <source>luaL_requiref</source>
          <target state="translated">luaL_requiref</target>
        </trans-unit>
        <trans-unit id="f04e97755a338c285b5b6a8075c54bfc46b40ecb" translate="yes" xml:space="preserve">
          <source>luaL_setfuncs</source>
          <target state="translated">luaL_setfuncs</target>
        </trans-unit>
        <trans-unit id="e6cb5586819f6125f0885528a3b32da820e5299b" translate="yes" xml:space="preserve">
          <source>luaL_setmetatable</source>
          <target state="translated">luaL_setmetatable</target>
        </trans-unit>
        <trans-unit id="e40b7540d25ef0b9e98e42bd512840b6671f50dd" translate="yes" xml:space="preserve">
          <source>luaL_testudata</source>
          <target state="translated">luaL_testudata</target>
        </trans-unit>
        <trans-unit id="358dab299846ee4bcc491f460fcb0cd749362044" translate="yes" xml:space="preserve">
          <source>luaL_tolstring</source>
          <target state="translated">luaL_tolstring</target>
        </trans-unit>
        <trans-unit id="60d74d771e08b88735fb47e3666d330c359ebc49" translate="yes" xml:space="preserve">
          <source>luaL_traceback</source>
          <target state="translated">luaL_traceback</target>
        </trans-unit>
        <trans-unit id="53ea0f5d8d80f709ab9b3625cb1b435a14f5f027" translate="yes" xml:space="preserve">
          <source>luaL_typename</source>
          <target state="translated">luaL_typename</target>
        </trans-unit>
        <trans-unit id="cdce63c7576a8364dcb1bc31478cf95c52021d96" translate="yes" xml:space="preserve">
          <source>luaL_unref</source>
          <target state="translated">luaL_unref</target>
        </trans-unit>
        <trans-unit id="e514931bfb388e46e3c698546863b742464a1401" translate="yes" xml:space="preserve">
          <source>luaL_where</source>
          <target state="translated">luaL_where</target>
        </trans-unit>
        <trans-unit id="c4473cc1755a9502465a512535908b47e9d0a188" translate="yes" xml:space="preserve">
          <source>lua_Alloc</source>
          <target state="translated">lua_Alloc</target>
        </trans-unit>
        <trans-unit id="39500a9286a2bc9576b8f7417935545359da1cea" translate="yes" xml:space="preserve">
          <source>lua_CFunction</source>
          <target state="translated">lua_CFunction</target>
        </trans-unit>
        <trans-unit id="4bfa0050295184372c05272e0d30dea1f1abb29c" translate="yes" xml:space="preserve">
          <source>lua_Debug</source>
          <target state="translated">lua_Debug</target>
        </trans-unit>
        <trans-unit id="42f8976b1ed2a8f8a5828ff3bd31e9a1c4305ecd" translate="yes" xml:space="preserve">
          <source>lua_Hook</source>
          <target state="translated">lua_Hook</target>
        </trans-unit>
        <trans-unit id="dc854ab35607a3553ed16eb076b57c6f21616e8e" translate="yes" xml:space="preserve">
          <source>lua_Integer</source>
          <target state="translated">lua_Integer</target>
        </trans-unit>
        <trans-unit id="e2ca502081291f44139bd92bddedcb09b3fa4ec6" translate="yes" xml:space="preserve">
          <source>lua_KContext</source>
          <target state="translated">lua_KContext</target>
        </trans-unit>
        <trans-unit id="0827ddac4869f69ad5a0a18d4c9bec798e7f82dd" translate="yes" xml:space="preserve">
          <source>lua_KFunction</source>
          <target state="translated">lua_KFunction</target>
        </trans-unit>
        <trans-unit id="4203e6beb33699f1966b07b52a67defe54f002a9" translate="yes" xml:space="preserve">
          <source>lua_Number</source>
          <target state="translated">lua_Number</target>
        </trans-unit>
        <trans-unit id="95a6ba2cc70122c2836a9456be5baeb0bac33936" translate="yes" xml:space="preserve">
          <source>lua_Reader</source>
          <target state="translated">lua_Reader</target>
        </trans-unit>
        <trans-unit id="62ad8789db186ef0893a533396712351c8ca9fcf" translate="yes" xml:space="preserve">
          <source>lua_State</source>
          <target state="translated">lua_State</target>
        </trans-unit>
        <trans-unit id="75e0f6226b214bb142a59cfc9c1a9ba4e845b588" translate="yes" xml:space="preserve">
          <source>lua_Unsigned</source>
          <target state="translated">lua_Unsigned</target>
        </trans-unit>
        <trans-unit id="c813048b63bfd9b5dee76172f7f6c56b73319106" translate="yes" xml:space="preserve">
          <source>lua_Writer</source>
          <target state="translated">lua_Writer</target>
        </trans-unit>
        <trans-unit id="9f01a11a1d2d52d6bbc857aabfa5634dabfef38c" translate="yes" xml:space="preserve">
          <source>lua_absindex</source>
          <target state="translated">lua_absindex</target>
        </trans-unit>
        <trans-unit id="fe0338d4bac8fcb1e5d3cd2e30da6ac02518aa6b" translate="yes" xml:space="preserve">
          <source>lua_arith</source>
          <target state="translated">lua_arith</target>
        </trans-unit>
        <trans-unit id="e67eec2cfced40a8ab600fb6616ad0e9360fb98c" translate="yes" xml:space="preserve">
          <source>lua_atpanic</source>
          <target state="translated">lua_atpanic</target>
        </trans-unit>
        <trans-unit id="f632e91bf017fe483ee7d01018e8213e050e067f" translate="yes" xml:space="preserve">
          <source>lua_call</source>
          <target state="translated">lua_call</target>
        </trans-unit>
        <trans-unit id="89979d6494beff051f7fdddc4a7f45ed3801a79a" translate="yes" xml:space="preserve">
          <source>lua_callk</source>
          <target state="translated">lua_callk</target>
        </trans-unit>
        <trans-unit id="edf26f2757c85a7b53ca48a7369ca96a625793d0" translate="yes" xml:space="preserve">
          <source>lua_checkstack</source>
          <target state="translated">lua_checkstack</target>
        </trans-unit>
        <trans-unit id="3df18358e400491ac2fdfc8cc5b559c6cd296d47" translate="yes" xml:space="preserve">
          <source>lua_close</source>
          <target state="translated">lua_close</target>
        </trans-unit>
        <trans-unit id="369d9cd9612b61f30d7166fa8dff946899613016" translate="yes" xml:space="preserve">
          <source>lua_compare</source>
          <target state="translated">lua_compare</target>
        </trans-unit>
        <trans-unit id="6efef92b55078f78eae884b0a3e6dedc3dbad6fb" translate="yes" xml:space="preserve">
          <source>lua_concat</source>
          <target state="translated">lua_concat</target>
        </trans-unit>
        <trans-unit id="2fe7c7f00edf584fe856c31d2aeebc23b415302c" translate="yes" xml:space="preserve">
          <source>lua_copy</source>
          <target state="translated">lua_copy</target>
        </trans-unit>
        <trans-unit id="c58c8acd75b979f465a72c1cd0b54745b4b46863" translate="yes" xml:space="preserve">
          <source>lua_createtable</source>
          <target state="translated">lua_createtable</target>
        </trans-unit>
        <trans-unit id="bdda5008883ecef564551a365ce28f0e934ca8d9" translate="yes" xml:space="preserve">
          <source>lua_dump</source>
          <target state="translated">lua_dump</target>
        </trans-unit>
        <trans-unit id="6f6b8d5bbb52329665fa70c1bfccd43af4f503ee" translate="yes" xml:space="preserve">
          <source>lua_error</source>
          <target state="translated">lua_error</target>
        </trans-unit>
        <trans-unit id="aa6cea174d4543e62fb6b3207a440dd49b4a5028" translate="yes" xml:space="preserve">
          <source>lua_gc</source>
          <target state="translated">lua_gc</target>
        </trans-unit>
        <trans-unit id="e22c71bf1d25b6193166543e3c5ff71fa05f13a0" translate="yes" xml:space="preserve">
          <source>lua_getallocf</source>
          <target state="translated">lua_getallocf</target>
        </trans-unit>
        <trans-unit id="80ff62538313f605d0df63ed70edb39d6cf14cc7" translate="yes" xml:space="preserve">
          <source>lua_getextraspace</source>
          <target state="translated">lua_getextraspace</target>
        </trans-unit>
        <trans-unit id="2ae02b6cd0546c5a015ace2833661efb3cd39257" translate="yes" xml:space="preserve">
          <source>lua_getfield</source>
          <target state="translated">lua_getfield</target>
        </trans-unit>
        <trans-unit id="d9e42fcda472bd9615c7bdc07cbc5198d0e7d55a" translate="yes" xml:space="preserve">
          <source>lua_getglobal</source>
          <target state="translated">lua_getglobal</target>
        </trans-unit>
        <trans-unit id="7f9024948700a7ecf63e128ce83441edc2a3287a" translate="yes" xml:space="preserve">
          <source>lua_gethook</source>
          <target state="translated">lua_gethook</target>
        </trans-unit>
        <trans-unit id="2d01999b580cbcfc088e9bb76c218767adbb465a" translate="yes" xml:space="preserve">
          <source>lua_gethookcount</source>
          <target state="translated">lua_gethookcount</target>
        </trans-unit>
        <trans-unit id="1e2613910ac9d928a70d3bec0691f4b6c09b7e2d" translate="yes" xml:space="preserve">
          <source>lua_gethookmask</source>
          <target state="translated">lua_gethookmask</target>
        </trans-unit>
        <trans-unit id="5cc0efe539093f93a8a1520c378b4c7351f10812" translate="yes" xml:space="preserve">
          <source>lua_geti</source>
          <target state="translated">lua_geti</target>
        </trans-unit>
        <trans-unit id="798a12cf117b1ca3279d26f5421416c25cb5f514" translate="yes" xml:space="preserve">
          <source>lua_getinfo</source>
          <target state="translated">lua_getinfo</target>
        </trans-unit>
        <trans-unit id="709eaff2c213d5ef6187285f54ad54b8a0fc0351" translate="yes" xml:space="preserve">
          <source>lua_getlocal</source>
          <target state="translated">lua_getlocal</target>
        </trans-unit>
        <trans-unit id="621a9a90e02a612851f12fd473537473e80625c5" translate="yes" xml:space="preserve">
          <source>lua_getmetatable</source>
          <target state="translated">lua_getmetatable</target>
        </trans-unit>
        <trans-unit id="8f121752dc757b89a3f2a270a37fbf085b98d6ba" translate="yes" xml:space="preserve">
          <source>lua_getstack</source>
          <target state="translated">lua_getstack</target>
        </trans-unit>
        <trans-unit id="937eea36347440e5fcf0e3a2d49b2473af0a84b8" translate="yes" xml:space="preserve">
          <source>lua_gettable</source>
          <target state="translated">lua_gettable</target>
        </trans-unit>
        <trans-unit id="41d075f1c4d1e79b6e07a116869f81c0509a1144" translate="yes" xml:space="preserve">
          <source>lua_gettop</source>
          <target state="translated">lua_gettop</target>
        </trans-unit>
        <trans-unit id="2920394eb9bf6b236e12247e25d9a01e3bad08e4" translate="yes" xml:space="preserve">
          <source>lua_getupvalue</source>
          <target state="translated">lua_getupvalue</target>
        </trans-unit>
        <trans-unit id="f9c0c4ce5b9918bbec21cae95879e267c6b83a90" translate="yes" xml:space="preserve">
          <source>lua_getuservalue</source>
          <target state="translated">lua_getuservalue</target>
        </trans-unit>
        <trans-unit id="25c1053838514e68472390703c19668e3f0c471e" translate="yes" xml:space="preserve">
          <source>lua_insert</source>
          <target state="translated">lua_insert</target>
        </trans-unit>
        <trans-unit id="bad021c0e6b6e2f88801b358c1156c2afebd46e5" translate="yes" xml:space="preserve">
          <source>lua_isboolean</source>
          <target state="translated">lua_isboolean</target>
        </trans-unit>
        <trans-unit id="648c44c3963b806286bafc840bf5bcdf1621520d" translate="yes" xml:space="preserve">
          <source>lua_iscfunction</source>
          <target state="translated">lua_iscfunction</target>
        </trans-unit>
        <trans-unit id="1a328c044b4418685c504472ab8ae6aff3c82cea" translate="yes" xml:space="preserve">
          <source>lua_isfunction</source>
          <target state="translated">lua_isfunction</target>
        </trans-unit>
        <trans-unit id="898653bfcf10c2e5269e3a96a68ad0b0765e232e" translate="yes" xml:space="preserve">
          <source>lua_isinteger</source>
          <target state="translated">lua_isinteger</target>
        </trans-unit>
        <trans-unit id="0acbfff9a51150a8f37f0e76b8eb34df986fabbd" translate="yes" xml:space="preserve">
          <source>lua_islightuserdata</source>
          <target state="translated">lua_islightuserdata</target>
        </trans-unit>
        <trans-unit id="0026560db7f4b72c4db0a74d6bd1fe162b94e209" translate="yes" xml:space="preserve">
          <source>lua_isnil</source>
          <target state="translated">lua_isnil</target>
        </trans-unit>
        <trans-unit id="f751e557c07317ead02de78278c2b9dcde6b660d" translate="yes" xml:space="preserve">
          <source>lua_isnone</source>
          <target state="translated">lua_isnone</target>
        </trans-unit>
        <trans-unit id="0af1471f35bdb8d9050ce90c4e882146389e2392" translate="yes" xml:space="preserve">
          <source>lua_isnoneornil</source>
          <target state="translated">lua_isnoneornil</target>
        </trans-unit>
        <trans-unit id="7ba04ce1c8cc281d1dc3c6bd698b19aff622a6bd" translate="yes" xml:space="preserve">
          <source>lua_isnumber</source>
          <target state="translated">lua_isnumber</target>
        </trans-unit>
        <trans-unit id="fc73ac8399e9f1924f623fe041c87574ce06a444" translate="yes" xml:space="preserve">
          <source>lua_isstring</source>
          <target state="translated">lua_isstring</target>
        </trans-unit>
        <trans-unit id="b56fdad36d8abdd8710b8f448d398d0bcd23865d" translate="yes" xml:space="preserve">
          <source>lua_istable</source>
          <target state="translated">lua_istable</target>
        </trans-unit>
        <trans-unit id="f9ca273c32fec850460137e6fb6a48a9f9584356" translate="yes" xml:space="preserve">
          <source>lua_isthread</source>
          <target state="translated">lua_isthread</target>
        </trans-unit>
        <trans-unit id="c3c76d4b1f3291f64519beeaf88f373ed5b9c403" translate="yes" xml:space="preserve">
          <source>lua_isuserdata</source>
          <target state="translated">lua_isuserdata</target>
        </trans-unit>
        <trans-unit id="4ad16f66cf2fe79e18d2ecc1b38458904d297cf4" translate="yes" xml:space="preserve">
          <source>lua_isyieldable</source>
          <target state="translated">lua_isyieldable</target>
        </trans-unit>
        <trans-unit id="f628ba7b66768c3df8f38a3efcacd260452da5f8" translate="yes" xml:space="preserve">
          <source>lua_len</source>
          <target state="translated">lua_len</target>
        </trans-unit>
        <trans-unit id="762fc5cc9c480897e9609796be5e3e2852175cd4" translate="yes" xml:space="preserve">
          <source>lua_load</source>
          <target state="translated">lua_load</target>
        </trans-unit>
        <trans-unit id="7b3f71643ec24d0b01f14ad14f14040cf4a98a23" translate="yes" xml:space="preserve">
          <source>lua_newstate</source>
          <target state="translated">lua_newstate</target>
        </trans-unit>
        <trans-unit id="9196bd91bb7576b1be5ae997b06cab1bd82ba057" translate="yes" xml:space="preserve">
          <source>lua_newtable</source>
          <target state="translated">lua_newtable</target>
        </trans-unit>
        <trans-unit id="0adea8683d898af072b191014837fdfa41b07737" translate="yes" xml:space="preserve">
          <source>lua_newthread</source>
          <target state="translated">lua_newthread</target>
        </trans-unit>
        <trans-unit id="3641d0dc55f76e80e98aafc9425f1fc69dc9e177" translate="yes" xml:space="preserve">
          <source>lua_newuserdata</source>
          <target state="translated">lua_newuserdata</target>
        </trans-unit>
        <trans-unit id="7bd0ed035877ba04849a03d6ca08982259f57417" translate="yes" xml:space="preserve">
          <source>lua_next</source>
          <target state="translated">lua_next</target>
        </trans-unit>
        <trans-unit id="98b0b51d387fac5a676b6a7f468b704cd1b57966" translate="yes" xml:space="preserve">
          <source>lua_numbertointeger</source>
          <target state="translated">lua_numbertointeger</target>
        </trans-unit>
        <trans-unit id="6b2414cca69b6a6d7734952e4479c4c7e40bc602" translate="yes" xml:space="preserve">
          <source>lua_pcall</source>
          <target state="translated">lua_pcall</target>
        </trans-unit>
        <trans-unit id="aa38f0c9074ee533663eebe170a8e2cb7363f9e1" translate="yes" xml:space="preserve">
          <source>lua_pcallk</source>
          <target state="translated">lua_pcallk</target>
        </trans-unit>
        <trans-unit id="3a84abf2ad1bc67eb677f8b2792cbaec7ee8765c" translate="yes" xml:space="preserve">
          <source>lua_pop</source>
          <target state="translated">lua_pop</target>
        </trans-unit>
        <trans-unit id="cb9a249b1f89670444f2bf5a75f348f58c2dbe61" translate="yes" xml:space="preserve">
          <source>lua_pushboolean</source>
          <target state="translated">lua_pushboolean</target>
        </trans-unit>
        <trans-unit id="12298529697a9cf1b73fb5edbd3345bf587b0cf9" translate="yes" xml:space="preserve">
          <source>lua_pushcclosure</source>
          <target state="translated">lua_pushcclosure</target>
        </trans-unit>
        <trans-unit id="2a4f47604d202f308f0155b4d22656305ae9097d" translate="yes" xml:space="preserve">
          <source>lua_pushcfunction</source>
          <target state="translated">lua_pushcfunction</target>
        </trans-unit>
        <trans-unit id="7ef4c94cea99414e5f266156046081afe490b907" translate="yes" xml:space="preserve">
          <source>lua_pushfstring</source>
          <target state="translated">lua_pushfstring</target>
        </trans-unit>
        <trans-unit id="9be64a191c577190203966fa558ef748f8edb9f3" translate="yes" xml:space="preserve">
          <source>lua_pushglobaltable</source>
          <target state="translated">lua_pushglobaltable</target>
        </trans-unit>
        <trans-unit id="fd8d65916a1b9ee4b97daf68bd044be20fcddf91" translate="yes" xml:space="preserve">
          <source>lua_pushinteger</source>
          <target state="translated">lua_pushinteger</target>
        </trans-unit>
        <trans-unit id="1c64adcde8affc25353ab0c366f62656e208831a" translate="yes" xml:space="preserve">
          <source>lua_pushlightuserdata</source>
          <target state="translated">lua_pushlightuserdata</target>
        </trans-unit>
        <trans-unit id="1f446dab77663410f4078cc7d47ff83793919b99" translate="yes" xml:space="preserve">
          <source>lua_pushliteral</source>
          <target state="translated">lua_pushliteral</target>
        </trans-unit>
        <trans-unit id="aa1d51a65df472f915e677a604a9311fb5ccbc59" translate="yes" xml:space="preserve">
          <source>lua_pushlstring</source>
          <target state="translated">lua_pushlstring</target>
        </trans-unit>
        <trans-unit id="958e215cf7c85e0d8236a3fe61ca66d0998b32e5" translate="yes" xml:space="preserve">
          <source>lua_pushnil</source>
          <target state="translated">lua_pushnil</target>
        </trans-unit>
        <trans-unit id="7547c248fba599e1a298075a9327c7b9dfd5dcf8" translate="yes" xml:space="preserve">
          <source>lua_pushnumber</source>
          <target state="translated">lua_pushnumber</target>
        </trans-unit>
        <trans-unit id="847d0db960681b04aaa6ac56045731f9625a81fd" translate="yes" xml:space="preserve">
          <source>lua_pushstring</source>
          <target state="translated">lua_pushstring</target>
        </trans-unit>
        <trans-unit id="05bd365a73b829ff506c963e2fb262d6bf766801" translate="yes" xml:space="preserve">
          <source>lua_pushthread</source>
          <target state="translated">lua_pushthread</target>
        </trans-unit>
        <trans-unit id="33bd34e2746e2230c9cb2ac61466183cbcec65d7" translate="yes" xml:space="preserve">
          <source>lua_pushvalue</source>
          <target state="translated">lua_pushvalue</target>
        </trans-unit>
        <trans-unit id="e7f23c1ece3f24ee0063d0f48cdcc58e318a1e2d" translate="yes" xml:space="preserve">
          <source>lua_pushvfstring</source>
          <target state="translated">lua_pushvfstring</target>
        </trans-unit>
        <trans-unit id="641f0227d3a74a7ef965ee2f203b7ff977af54f5" translate="yes" xml:space="preserve">
          <source>lua_rawequal</source>
          <target state="translated">lua_rawequal</target>
        </trans-unit>
        <trans-unit id="453f3ff0805e03b9ca41ac071befa0c7401b3faf" translate="yes" xml:space="preserve">
          <source>lua_rawget</source>
          <target state="translated">lua_rawget</target>
        </trans-unit>
        <trans-unit id="6eb9f34ff0adc44f1734710122b81835a7a8597a" translate="yes" xml:space="preserve">
          <source>lua_rawgeti</source>
          <target state="translated">lua_rawgeti</target>
        </trans-unit>
        <trans-unit id="18e85b55e231b061e530723fa859a5bd5c3ee89e" translate="yes" xml:space="preserve">
          <source>lua_rawgetp</source>
          <target state="translated">lua_rawgetp</target>
        </trans-unit>
        <trans-unit id="da764aabbe3f3dee6ef8ad2a36b87852858568a5" translate="yes" xml:space="preserve">
          <source>lua_rawlen</source>
          <target state="translated">lua_rawlen</target>
        </trans-unit>
        <trans-unit id="cedb8fcb8980649442a0db7ce7ee9782b6383f3d" translate="yes" xml:space="preserve">
          <source>lua_rawset</source>
          <target state="translated">lua_rawset</target>
        </trans-unit>
        <trans-unit id="b167e99d5d6fb14b20b29a8cca5c5a245ddd352b" translate="yes" xml:space="preserve">
          <source>lua_rawseti</source>
          <target state="translated">lua_rawseti</target>
        </trans-unit>
        <trans-unit id="67ef01d278aa93baf067ae755835477b884a2d3e" translate="yes" xml:space="preserve">
          <source>lua_rawsetp</source>
          <target state="translated">lua_rawsetp</target>
        </trans-unit>
        <trans-unit id="8bda295d3da259b29595490e8a0ef1cba21585b4" translate="yes" xml:space="preserve">
          <source>lua_register</source>
          <target state="translated">lua_register</target>
        </trans-unit>
        <trans-unit id="96f6042d1e7aa1eaf1c4e46041e7c1dbfc5b39c9" translate="yes" xml:space="preserve">
          <source>lua_remove</source>
          <target state="translated">lua_remove</target>
        </trans-unit>
        <trans-unit id="bb99b00e30d0d0a98386e36b47d7c59e7a744440" translate="yes" xml:space="preserve">
          <source>lua_replace</source>
          <target state="translated">lua_replace</target>
        </trans-unit>
        <trans-unit id="6ee981055f5b3f5f3041a901e01cde2c283034a4" translate="yes" xml:space="preserve">
          <source>lua_resume</source>
          <target state="translated">lua_resume</target>
        </trans-unit>
        <trans-unit id="29ac840486273b0afb3ba91ecd4c86e8f3274b17" translate="yes" xml:space="preserve">
          <source>lua_rotate</source>
          <target state="translated">lua_rotate</target>
        </trans-unit>
        <trans-unit id="cbab7789ef8ed6914f52f165b799dd0f7f8cff83" translate="yes" xml:space="preserve">
          <source>lua_setallocf</source>
          <target state="translated">lua_setallocf</target>
        </trans-unit>
        <trans-unit id="a1885bcf365afa45dd7febcbd3849eccb9f0843f" translate="yes" xml:space="preserve">
          <source>lua_setfield</source>
          <target state="translated">lua_setfield</target>
        </trans-unit>
        <trans-unit id="fe9de583661bda12e7ff6580cc849cd7fd34484f" translate="yes" xml:space="preserve">
          <source>lua_setglobal</source>
          <target state="translated">lua_setglobal</target>
        </trans-unit>
        <trans-unit id="9f30d215e6f35e37ce8d947456e4225c2b6d98b7" translate="yes" xml:space="preserve">
          <source>lua_sethook</source>
          <target state="translated">lua_sethook</target>
        </trans-unit>
        <trans-unit id="f296b63fe69308c3233765b6213252534378363b" translate="yes" xml:space="preserve">
          <source>lua_seti</source>
          <target state="translated">lua_seti</target>
        </trans-unit>
        <trans-unit id="1eb75f91df63aed7adb55474f73c3ee6456ff649" translate="yes" xml:space="preserve">
          <source>lua_setlocal</source>
          <target state="translated">lua_setlocal</target>
        </trans-unit>
        <trans-unit id="30090be00782afa9fca6b89da01c624eef7c9153" translate="yes" xml:space="preserve">
          <source>lua_setmetatable</source>
          <target state="translated">lua_setmetatable</target>
        </trans-unit>
        <trans-unit id="ed12596bd702bbef0d60edeed3c1c0512606b7a7" translate="yes" xml:space="preserve">
          <source>lua_settable</source>
          <target state="translated">lua_settable</target>
        </trans-unit>
        <trans-unit id="fd95b29fdac9ae3a5f2f9ff1e180bf4a20288f10" translate="yes" xml:space="preserve">
          <source>lua_settop</source>
          <target state="translated">lua_settop</target>
        </trans-unit>
        <trans-unit id="1aeb6c9d489afcc8f777f824740ff83ece953995" translate="yes" xml:space="preserve">
          <source>lua_setupvalue</source>
          <target state="translated">lua_setupvalue</target>
        </trans-unit>
        <trans-unit id="89a4359ca1eda521874b893162dacf89a2d0f2df" translate="yes" xml:space="preserve">
          <source>lua_setuservalue</source>
          <target state="translated">lua_setuservalue</target>
        </trans-unit>
        <trans-unit id="d928728ad66e6a2873a38809bb2c135976ad9d05" translate="yes" xml:space="preserve">
          <source>lua_status</source>
          <target state="translated">lua_status</target>
        </trans-unit>
        <trans-unit id="e45794edba5dc813600e7c9000c4ee9028f1b359" translate="yes" xml:space="preserve">
          <source>lua_stringtonumber</source>
          <target state="translated">lua_stringtonumber</target>
        </trans-unit>
        <trans-unit id="6fcb8673b5734e44237a477ecc4a0686703c74bc" translate="yes" xml:space="preserve">
          <source>lua_toboolean</source>
          <target state="translated">lua_toboolean</target>
        </trans-unit>
        <trans-unit id="d10d84a8b8241a1f651df55b5d0d6332dd770716" translate="yes" xml:space="preserve">
          <source>lua_tocfunction</source>
          <target state="translated">lua_tocfunction</target>
        </trans-unit>
        <trans-unit id="efb5245021aa7ca7ac3b8c0ee89ba9df1607b637" translate="yes" xml:space="preserve">
          <source>lua_tointeger</source>
          <target state="translated">lua_tointeger</target>
        </trans-unit>
        <trans-unit id="b82854896f984bbe40fe0c442fd6c0fe912900a8" translate="yes" xml:space="preserve">
          <source>lua_tointegerx</source>
          <target state="translated">lua_tointegerx</target>
        </trans-unit>
        <trans-unit id="a92cd3b92c41d137064f53409cced9f59c8fd2cb" translate="yes" xml:space="preserve">
          <source>lua_tolstring</source>
          <target state="translated">lua_tolstring</target>
        </trans-unit>
        <trans-unit id="d778b38e96455e8c69c322b30a66a5f671d303b0" translate="yes" xml:space="preserve">
          <source>lua_tonumber</source>
          <target state="translated">lua_tonumber</target>
        </trans-unit>
        <trans-unit id="6cf42ffc44e23891cefc974057e90bfa9239e3cf" translate="yes" xml:space="preserve">
          <source>lua_tonumberx</source>
          <target state="translated">lua_tonumberx</target>
        </trans-unit>
        <trans-unit id="95c8672f426f34974458893768a9e552e6d7f15b" translate="yes" xml:space="preserve">
          <source>lua_topointer</source>
          <target state="translated">lua_topointer</target>
        </trans-unit>
        <trans-unit id="2985285b05e8fad33f14c145232f9d2b47b2907d" translate="yes" xml:space="preserve">
          <source>lua_tostring</source>
          <target state="translated">lua_tostring</target>
        </trans-unit>
        <trans-unit id="bf0a37b4b8de81dfacb9205be5c207c9a3cd6aef" translate="yes" xml:space="preserve">
          <source>lua_tothread</source>
          <target state="translated">lua_tothread</target>
        </trans-unit>
        <trans-unit id="4fca87a78b0d16f1d9efad32a4ae73995549c9c6" translate="yes" xml:space="preserve">
          <source>lua_touserdata</source>
          <target state="translated">lua_touserdata</target>
        </trans-unit>
        <trans-unit id="9f7e019adf4e9ca6d493a2cabae66253575e86e5" translate="yes" xml:space="preserve">
          <source>lua_type</source>
          <target state="translated">lua_type</target>
        </trans-unit>
        <trans-unit id="eb78378595576e6f2ea13fdee5dff47a9344a2a1" translate="yes" xml:space="preserve">
          <source>lua_typename</source>
          <target state="translated">lua_typename</target>
        </trans-unit>
        <trans-unit id="2ab9634111a4c2ba9a3f5c1d74db411a1ce4bd7e" translate="yes" xml:space="preserve">
          <source>lua_upvalueid</source>
          <target state="translated">lua_upvalueid</target>
        </trans-unit>
        <trans-unit id="295089ec3ea29a8d0f77e07782c8001053ec22f2" translate="yes" xml:space="preserve">
          <source>lua_upvalueindex</source>
          <target state="translated">lua_upvalueindex</target>
        </trans-unit>
        <trans-unit id="8c73b78660948a6d0f9392e7fe37b457c1ba2da8" translate="yes" xml:space="preserve">
          <source>lua_upvaluejoin</source>
          <target state="translated">lua_upvaluejoin</target>
        </trans-unit>
        <trans-unit id="4b1d3a92c16f0634e767f3a54264a9def4baf851" translate="yes" xml:space="preserve">
          <source>lua_version</source>
          <target state="translated">lua_version</target>
        </trans-unit>
        <trans-unit id="ac5b545468d936827425d2d9dc84f367e265c9bb" translate="yes" xml:space="preserve">
          <source>lua_xmove</source>
          <target state="translated">lua_xmove</target>
        </trans-unit>
        <trans-unit id="2106e86be2c5b7c32b4d2830790a9690ac3def7b" translate="yes" xml:space="preserve">
          <source>lua_yield</source>
          <target state="translated">lua_yield</target>
        </trans-unit>
        <trans-unit id="67d82c098dd8204a77701c803938d2a842709c3c" translate="yes" xml:space="preserve">
          <source>lua_yieldk</source>
          <target state="translated">lua_yieldk</target>
        </trans-unit>
        <trans-unit id="14486fda1e254a8db9b3b855f4452a70146a8915" translate="yes" xml:space="preserve">
          <source>math.abs()</source>
          <target state="translated">math.abs()</target>
        </trans-unit>
        <trans-unit id="06627e4da56211ae35f7229b1edce7be9105ac96" translate="yes" xml:space="preserve">
          <source>math.acos()</source>
          <target state="translated">math.acos()</target>
        </trans-unit>
        <trans-unit id="0304e54b36652de26660e58896d1fe1f8672c293" translate="yes" xml:space="preserve">
          <source>math.asin()</source>
          <target state="translated">math.asin()</target>
        </trans-unit>
        <trans-unit id="19a39764f54e3e5a7f292316199235934849bb8b" translate="yes" xml:space="preserve">
          <source>math.atan()</source>
          <target state="translated">math.atan()</target>
        </trans-unit>
        <trans-unit id="565046f5373f5304d0a0946f2c2782a522e90251" translate="yes" xml:space="preserve">
          <source>math.ceil()</source>
          <target state="translated">math.ceil()</target>
        </trans-unit>
        <trans-unit id="a27ccff89f1a2c88cf91fb8f2fdfbeefa6591c9d" translate="yes" xml:space="preserve">
          <source>math.cos()</source>
          <target state="translated">math.cos()</target>
        </trans-unit>
        <trans-unit id="e453a2142dc0475524a8e1b87c4ae233e56b9480" translate="yes" xml:space="preserve">
          <source>math.deg()</source>
          <target state="translated">math.deg()</target>
        </trans-unit>
        <trans-unit id="aeb4334e3bda0aca62a45ddb17e3937bc409937c" translate="yes" xml:space="preserve">
          <source>math.exp()</source>
          <target state="translated">math.exp()</target>
        </trans-unit>
        <trans-unit id="fe1de4e4d94fb7b9924b1f9c64b94cdbe688ec9e" translate="yes" xml:space="preserve">
          <source>math.floor()</source>
          <target state="translated">math.floor()</target>
        </trans-unit>
        <trans-unit id="f9915470946a7c958df4d6ac8d92eeaf818d12b9" translate="yes" xml:space="preserve">
          <source>math.fmod()</source>
          <target state="translated">math.fmod()</target>
        </trans-unit>
        <trans-unit id="160afe7d95ea90ce8e90e603f6493a769e922ea9" translate="yes" xml:space="preserve">
          <source>math.huge</source>
          <target state="translated">math.huge</target>
        </trans-unit>
        <trans-unit id="5c5d9b74a0806c4357bc6c85738b618342b998ea" translate="yes" xml:space="preserve">
          <source>math.log()</source>
          <target state="translated">math.log()</target>
        </trans-unit>
        <trans-unit id="d6857224fcee08574793bb82cd4dca59c1d3fb49" translate="yes" xml:space="preserve">
          <source>math.max()</source>
          <target state="translated">math.max()</target>
        </trans-unit>
        <trans-unit id="8677ae38d193c4087a18fc39d21505892e60d0e0" translate="yes" xml:space="preserve">
          <source>math.maxinteger</source>
          <target state="translated">math.maxinteger</target>
        </trans-unit>
        <trans-unit id="c0fedb9a59de2aa4a979a6d37232d95dba37e71b" translate="yes" xml:space="preserve">
          <source>math.min()</source>
          <target state="translated">math.min()</target>
        </trans-unit>
        <trans-unit id="9e9798d323bf91facc80e74c9b1d6fb0fae242cc" translate="yes" xml:space="preserve">
          <source>math.mininteger</source>
          <target state="translated">math.mininteger</target>
        </trans-unit>
        <trans-unit id="be915d5557bc2382b715b722ba34a8afc18c0f62" translate="yes" xml:space="preserve">
          <source>math.modf()</source>
          <target state="translated">math.modf()</target>
        </trans-unit>
        <trans-unit id="e52478d6c76b149d1798c1b8ea53f24e9a9e07b0" translate="yes" xml:space="preserve">
          <source>math.pi</source>
          <target state="translated">math.pi</target>
        </trans-unit>
        <trans-unit id="55a739cb4d10e13c42de4cf57e6b19c01c7da201" translate="yes" xml:space="preserve">
          <source>math.rad()</source>
          <target state="translated">math.rad()</target>
        </trans-unit>
        <trans-unit id="b1121e1ef316fc6c09dc53b3bf6a8b378ef4156a" translate="yes" xml:space="preserve">
          <source>math.random()</source>
          <target state="translated">math.random()</target>
        </trans-unit>
        <trans-unit id="6bd6400623e09987abdb24b82d64d67a81e99462" translate="yes" xml:space="preserve">
          <source>math.randomseed()</source>
          <target state="translated">math.randomseed()</target>
        </trans-unit>
        <trans-unit id="7910d71eca1c8dbc95e1bdcb7451d104ca55acf6" translate="yes" xml:space="preserve">
          <source>math.sin()</source>
          <target state="translated">math.sin()</target>
        </trans-unit>
        <trans-unit id="6862a2055e6d6e4f44427537e335413b9ecf2c19" translate="yes" xml:space="preserve">
          <source>math.sqrt()</source>
          <target state="translated">math.sqrt()</target>
        </trans-unit>
        <trans-unit id="c87729e68db07bbbb1a584f15ddae0f905524d6d" translate="yes" xml:space="preserve">
          <source>math.tan()</source>
          <target state="translated">math.tan()</target>
        </trans-unit>
        <trans-unit id="da4d9f9c916d2c50238c34c35b3d91a5f40edb8a" translate="yes" xml:space="preserve">
          <source>math.tointeger()</source>
          <target state="translated">math.tointeger()</target>
        </trans-unit>
        <trans-unit id="c9c53608768ee3b617c39c88de6b18eed4396bb0" translate="yes" xml:space="preserve">
          <source>math.type()</source>
          <target state="translated">math.type()</target>
        </trans-unit>
        <trans-unit id="24e0a52473f397f581e3970eab8e0d4788658dd6" translate="yes" xml:space="preserve">
          <source>math.ult()</source>
          <target state="translated">math.ult()</target>
        </trans-unit>
        <trans-unit id="906a5a7917e6cb3a16060fec8a91746af3c5cf16" translate="yes" xml:space="preserve">
          <source>mathematical functions (&lt;a href=&quot;#6.7&quot;&gt;&amp;sect;6.7&lt;/a&gt;) (sin, log, etc.);</source>
          <target state="translated">수학 함수 ( &lt;a href=&quot;#6.7&quot;&gt;&amp;sect;6.7&lt;/a&gt; ) (sin, log 등);</target>
        </trans-unit>
        <trans-unit id="b9f82bf32f4d577ef9caa50dfb51236f3e54e946" translate="yes" xml:space="preserve">
          <source>may produce the string:</source>
          <target state="translated">문자열을 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="06c08f5fdce220335949982b45b0ee4c4b371027" translate="yes" xml:space="preserve">
          <source>next()</source>
          <target state="translated">next()</target>
        </trans-unit>
        <trans-unit id="e4fbf9e57086f58566afc3e17f28484c8c98343b" translate="yes" xml:space="preserve">
          <source>not to</source>
          <target state="translated">하지 않기</target>
        </trans-unit>
        <trans-unit id="e382417e6422c7d2298f063ba1e16a76f01ca9a7" translate="yes" xml:space="preserve">
          <source>operating system facilities (&lt;a href=&quot;#6.9&quot;&gt;&amp;sect;6.9&lt;/a&gt;);</source>
          <target state="translated">운영 체제 시설 ( &lt;a href=&quot;#6.9&quot;&gt;&amp;sect;6.9&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="d0a2757924fd51520fc0527e76bfadf6be64427c" translate="yes" xml:space="preserve">
          <source>os.clock()</source>
          <target state="translated">os.clock()</target>
        </trans-unit>
        <trans-unit id="48a3cb0425ba00c4a0b0d7caef71b6a6c9d67cdd" translate="yes" xml:space="preserve">
          <source>os.date()</source>
          <target state="translated">os.date()</target>
        </trans-unit>
        <trans-unit id="5a0bf3e9ccd3c8b542f106afff3630910d85cea4" translate="yes" xml:space="preserve">
          <source>os.difftime()</source>
          <target state="translated">os.difftime()</target>
        </trans-unit>
        <trans-unit id="6bd8eebf8d03fcf0c07bc1388fcc7ee3e8424e18" translate="yes" xml:space="preserve">
          <source>os.execute()</source>
          <target state="translated">os.execute()</target>
        </trans-unit>
        <trans-unit id="cfee573beed45589563480460931ee2e6ab1a8ab" translate="yes" xml:space="preserve">
          <source>os.exit()</source>
          <target state="translated">os.exit()</target>
        </trans-unit>
        <trans-unit id="ab9bed2c9f45e6eaeb11b167e98d934079f30cce" translate="yes" xml:space="preserve">
          <source>os.getenv()</source>
          <target state="translated">os.getenv()</target>
        </trans-unit>
        <trans-unit id="72e23ce1ad420442e45d15a20bd5a0dfaeabc47b" translate="yes" xml:space="preserve">
          <source>os.remove()</source>
          <target state="translated">os.remove()</target>
        </trans-unit>
        <trans-unit id="a33d78af9ece7b6a8ad04c4ed2f647a0745b0c03" translate="yes" xml:space="preserve">
          <source>os.rename()</source>
          <target state="translated">os.rename()</target>
        </trans-unit>
        <trans-unit id="50f0f100bcbadc08f6c9864231da32ac8f499dc8" translate="yes" xml:space="preserve">
          <source>os.setlocale()</source>
          <target state="translated">os.setlocale()</target>
        </trans-unit>
        <trans-unit id="9f948446e3b970a65820369794a9da702c540c79" translate="yes" xml:space="preserve">
          <source>os.time()</source>
          <target state="translated">os.time()</target>
        </trans-unit>
        <trans-unit id="0ea17682c41cfc4b79e1b1d330c5f5befce1ac54" translate="yes" xml:space="preserve">
          <source>os.tmpname()</source>
          <target state="translated">os.tmpname()</target>
        </trans-unit>
        <trans-unit id="9f110c9faec960f23cc7e53e43a013287e262b3e" translate="yes" xml:space="preserve">
          <source>package library (&lt;a href=&quot;#6.3&quot;&gt;&amp;sect;6.3&lt;/a&gt;);</source>
          <target state="translated">패키지 라이브러리 ( &lt;a href=&quot;#6.3&quot;&gt;&amp;sect;6.3&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="b06a02c26d0c7e5715b2071a862e9e3c234af10f" translate="yes" xml:space="preserve">
          <source>package.config</source>
          <target state="translated">package.config</target>
        </trans-unit>
        <trans-unit id="73cb1b10a9d5a43c96d3d2e4310ce4a524872dc6" translate="yes" xml:space="preserve">
          <source>package.cpath</source>
          <target state="translated">package.cpath</target>
        </trans-unit>
        <trans-unit id="ee265be558864ad7c6bb5f9860cb64ce17385554" translate="yes" xml:space="preserve">
          <source>package.loaded</source>
          <target state="translated">package.loaded</target>
        </trans-unit>
        <trans-unit id="c1dc67f26616f2fa44f17e58e5da2301a2923702" translate="yes" xml:space="preserve">
          <source>package.loadlib()</source>
          <target state="translated">package.loadlib()</target>
        </trans-unit>
        <trans-unit id="1349864236ab16652119d2fef7ed43677f48784a" translate="yes" xml:space="preserve">
          <source>package.path</source>
          <target state="translated">package.path</target>
        </trans-unit>
        <trans-unit id="0882187dd54510318a9374d5113c2474804b3788" translate="yes" xml:space="preserve">
          <source>package.preload</source>
          <target state="translated">package.preload</target>
        </trans-unit>
        <trans-unit id="dbfadc246d177bd440f2643e0c075ac27c51181d" translate="yes" xml:space="preserve">
          <source>package.searchers</source>
          <target state="translated">package.searchers</target>
        </trans-unit>
        <trans-unit id="48eaaccb2403257b5b03d32d6e1f489b1d7b5831" translate="yes" xml:space="preserve">
          <source>package.searchpath()</source>
          <target state="translated">package.searchpath()</target>
        </trans-unit>
        <trans-unit id="b9b4cc59dc3aeca62636a97763e2b62a1e1f5ac3" translate="yes" xml:space="preserve">
          <source>pairs()</source>
          <target state="translated">pairs()</target>
        </trans-unit>
        <trans-unit id="692aa3043d7ee19f6646b6dfad28c3090d74d69f" translate="yes" xml:space="preserve">
          <source>pcall()</source>
          <target state="translated">pcall()</target>
        </trans-unit>
        <trans-unit id="19c8a5cdef0f37df1bfbc1c66d27412754169588" translate="yes" xml:space="preserve">
          <source>print()</source>
          <target state="translated">print()</target>
        </trans-unit>
        <trans-unit id="0784215a7320685f5a14ac0fd0a7bb4c19955411" translate="yes" xml:space="preserve">
          <source>rawequal()</source>
          <target state="translated">rawequal()</target>
        </trans-unit>
        <trans-unit id="3ff486c6b0a9e73d3d9261a55ea563f5e12e84a8" translate="yes" xml:space="preserve">
          <source>rawget()</source>
          <target state="translated">rawget()</target>
        </trans-unit>
        <trans-unit id="676ffdd4d4658463b2a939e9515863d44f978477" translate="yes" xml:space="preserve">
          <source>rawlen()</source>
          <target state="translated">rawlen()</target>
        </trans-unit>
        <trans-unit id="7cf553b2b0fb777074b6ebecc9f2bbf81e459a8f" translate="yes" xml:space="preserve">
          <source>rawset()</source>
          <target state="translated">rawset()</target>
        </trans-unit>
        <trans-unit id="634b96c5c5c53297222823e53e126b5e4b24f441" translate="yes" xml:space="preserve">
          <source>require()</source>
          <target state="translated">require()</target>
        </trans-unit>
        <trans-unit id="44a272234265dca81cc29e0c2d97e7acb3e269b6" translate="yes" xml:space="preserve">
          <source>select()</source>
          <target state="translated">select()</target>
        </trans-unit>
        <trans-unit id="4baba792843a0740cbe688a3ffcd5961bdab0046" translate="yes" xml:space="preserve">
          <source>setmetatable()</source>
          <target state="translated">setmetatable()</target>
        </trans-unit>
        <trans-unit id="26d1c2c2daa3c2841780240be22241b86b9dbe66" translate="yes" xml:space="preserve">
          <source>sets &lt;code&gt;a[3]&lt;/code&gt; to 20, without affecting &lt;code&gt;a[4]&lt;/code&gt; because the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;a[i]&lt;/code&gt; is evaluated (to 3) before it is assigned 4. Similarly, the line</source>
          <target state="translated">세트 &lt;code&gt;a[3]&lt;/code&gt; (20),에 영향을 미치지 않고 &lt;code&gt;a[4]&lt;/code&gt; 때문에 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;a[i]&lt;/code&gt; 이 마찬가지로 제 할당되기 전에 (3) 평가 라인</target>
        </trans-unit>
        <trans-unit id="d3a766269877c040a2ead968293f8bc6e3f151b9" translate="yes" xml:space="preserve">
          <source>string manipulation (&lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;);</source>
          <target state="translated">문자열 조작 ( &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="b7f6bb7c213c7e98914cad20477f12d3613a73e9" translate="yes" xml:space="preserve">
          <source>string.byte()</source>
          <target state="translated">string.byte()</target>
        </trans-unit>
        <trans-unit id="5eceb5e5192bec9538171a97c245dfe0e7a1e594" translate="yes" xml:space="preserve">
          <source>string.char()</source>
          <target state="translated">string.char()</target>
        </trans-unit>
        <trans-unit id="4e61c3d558da0bc29f7f78edc9affce794ec84e8" translate="yes" xml:space="preserve">
          <source>string.dump()</source>
          <target state="translated">string.dump()</target>
        </trans-unit>
        <trans-unit id="ab9bf2e48a7976b30b5974dcffb2c8ef7f261a8b" translate="yes" xml:space="preserve">
          <source>string.find()</source>
          <target state="translated">string.find()</target>
        </trans-unit>
        <trans-unit id="12fa4981058afc485e397e753c48afe88f2128f8" translate="yes" xml:space="preserve">
          <source>string.format()</source>
          <target state="translated">string.format()</target>
        </trans-unit>
        <trans-unit id="601ef3da5fa5325f46c53fbec4ffbb2c9ce7a2c3" translate="yes" xml:space="preserve">
          <source>string.gmatch()</source>
          <target state="translated">string.gmatch()</target>
        </trans-unit>
        <trans-unit id="63d794f0b7c156d2857cb138fbb13b0749025ead" translate="yes" xml:space="preserve">
          <source>string.gsub()</source>
          <target state="translated">string.gsub()</target>
        </trans-unit>
        <trans-unit id="45b35f30169155139a8db6adb5e5e6eb0d61d130" translate="yes" xml:space="preserve">
          <source>string.len()</source>
          <target state="translated">string.len()</target>
        </trans-unit>
        <trans-unit id="1c5c02653b245a5172435c8a954bdc1ccf070382" translate="yes" xml:space="preserve">
          <source>string.lower()</source>
          <target state="translated">string.lower()</target>
        </trans-unit>
        <trans-unit id="2d993d0d8cc8cf3f3171c6b0ba0b672c3c2f0fc0" translate="yes" xml:space="preserve">
          <source>string.match()</source>
          <target state="translated">string.match()</target>
        </trans-unit>
        <trans-unit id="aa5f760b2d79baa9b0f99be23beaec96a2914af1" translate="yes" xml:space="preserve">
          <source>string.pack()</source>
          <target state="translated">string.pack()</target>
        </trans-unit>
        <trans-unit id="74141e15ca4ee3ed63e233e3deda16e2b774fb3c" translate="yes" xml:space="preserve">
          <source>string.packsize()</source>
          <target state="translated">string.packsize()</target>
        </trans-unit>
        <trans-unit id="2ec92a5bc2be10279b788c84861101755037b120" translate="yes" xml:space="preserve">
          <source>string.rep()</source>
          <target state="translated">string.rep()</target>
        </trans-unit>
        <trans-unit id="e81691b567327dc79d0d23a3582b81e4d7ecd290" translate="yes" xml:space="preserve">
          <source>string.reverse()</source>
          <target state="translated">string.reverse()</target>
        </trans-unit>
        <trans-unit id="a4709ad56ef65904ebed2cc4bec787da53b4dcf6" translate="yes" xml:space="preserve">
          <source>string.sub()</source>
          <target state="translated">string.sub()</target>
        </trans-unit>
        <trans-unit id="e31e915460d94df27e3acedc85c303bf2710215a" translate="yes" xml:space="preserve">
          <source>string.unpack()</source>
          <target state="translated">string.unpack()</target>
        </trans-unit>
        <trans-unit id="0c2e5bedb9a6440d1326a97364898bbeb9eb43e8" translate="yes" xml:space="preserve">
          <source>string.upper()</source>
          <target state="translated">string.upper()</target>
        </trans-unit>
        <trans-unit id="02ff9dbfcb40bbc1b8445ad5c11305688e30ad91" translate="yes" xml:space="preserve">
          <source>table manipulation (&lt;a href=&quot;#6.6&quot;&gt;&amp;sect;6.6&lt;/a&gt;);</source>
          <target state="translated">테이블 조작 ( &lt;a href=&quot;#6.6&quot;&gt;&amp;sect;6.6&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="61de801001f5d93ad59eab26e6b9de2a1779736b" translate="yes" xml:space="preserve">
          <source>table.concat()</source>
          <target state="translated">table.concat()</target>
        </trans-unit>
        <trans-unit id="0cf019b96c5b8b72c699692b2bd3d68ca90ad93f" translate="yes" xml:space="preserve">
          <source>table.insert()</source>
          <target state="translated">table.insert()</target>
        </trans-unit>
        <trans-unit id="41b8285b4e1b4e62b85ad8ff13128d5f5ca525b9" translate="yes" xml:space="preserve">
          <source>table.move()</source>
          <target state="translated">table.move()</target>
        </trans-unit>
        <trans-unit id="5ea9f24cca19d9a9ea8aa4c0ceeba4b8e5430938" translate="yes" xml:space="preserve">
          <source>table.pack()</source>
          <target state="translated">table.pack()</target>
        </trans-unit>
        <trans-unit id="53043acdf5dab106c810c59521cf27c739011b7f" translate="yes" xml:space="preserve">
          <source>table.remove()</source>
          <target state="translated">table.remove()</target>
        </trans-unit>
        <trans-unit id="7495a3cbe6034ff7d64d7bdf8d4a079316fe7073" translate="yes" xml:space="preserve">
          <source>table.sort()</source>
          <target state="translated">table.sort()</target>
        </trans-unit>
        <trans-unit id="60c2f65945a245cf41457db9052a01faf198866c" translate="yes" xml:space="preserve">
          <source>table.unpack()</source>
          <target state="translated">table.unpack()</target>
        </trans-unit>
        <trans-unit id="e5b647df43d09c8e42c5a1d5d582d03e96d3f43c" translate="yes" xml:space="preserve">
          <source>the search for the name &lt;code&gt;foo.a&lt;/code&gt; will try to open the files &lt;code&gt;./foo/a.lua&lt;/code&gt;, &lt;code&gt;./foo/a.lc&lt;/code&gt;, and &lt;code&gt;/usr/local/foo/a/init.lua&lt;/code&gt;, in that order.</source>
          <target state="translated">&lt;code&gt;foo.a&lt;/code&gt; 라는 이름을 검색하면 &lt;code&gt;./foo/a.lua&lt;/code&gt; , &lt;code&gt;./foo/a.lc&lt;/code&gt; 및 &lt;code&gt;/usr/local/foo/a/init.lua&lt;/code&gt; 파일 을 순서대로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="b580997dc742b0cb5cd1fc6a70bcdbac2b4eaba1" translate="yes" xml:space="preserve">
          <source>the searcher for module &lt;code&gt;foo&lt;/code&gt; will try to open the files &lt;code&gt;./foo.so&lt;/code&gt;, &lt;code&gt;./foo.dll&lt;/code&gt;, and &lt;code&gt;/usr/local/foo/init.so&lt;/code&gt;, in that order. Once it finds a C library, this searcher first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside the library to be used as the loader. The name of this C function is the string &quot;&lt;code&gt;luaopen_&lt;/code&gt;&quot; concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its suffix after (and including) the first hyphen is removed. For instance, if the module name is &lt;code&gt;a.b.c-v2.1&lt;/code&gt;, the function name will be &lt;code&gt;luaopen_a_b_c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 모듈의 검색자는 &lt;code&gt;./foo.so&lt;/code&gt; , &lt;code&gt;./foo.dll&lt;/code&gt; 및 &lt;code&gt;/usr/local/foo/init.so&lt;/code&gt; 파일 을 순서대로 열려고 시도합니다 . C 라이브러리를 찾으면이 검색기는 먼저 동적 링크 기능을 사용하여 애플리케이션을 라이브러리와 링크합니다. 그런 다음 라이브러리에서 로더로 사용할 C 함수를 찾습니다. 이 C 함수의 이름은 문자열 &quot; &lt;code&gt;luaopen_&lt;/code&gt; &quot;이며 각 점이 밑줄로 대체되는 모듈 이름의 사본과 연결됩니다. 또한 모듈 이름에 하이픈이 있으면 첫 번째 하이픈 이후 (및 포함)의 접미사가 제거됩니다. 예를 들어, 모듈 이름이 &lt;code&gt;a.b.c-v2.1&lt;/code&gt; 인 경우 함수 이름은 &lt;code&gt;luaopen_a_b_c&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c977bccc91f0e0624ac1c030913a23c4d5a2cdd5" translate="yes" xml:space="preserve">
          <source>the table is like this:</source>
          <target state="translated">테이블은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="a5b582d5f4321bbc7606967d5525c7421e77a5ae" translate="yes" xml:space="preserve">
          <source>tonumber()</source>
          <target state="translated">tonumber()</target>
        </trans-unit>
        <trans-unit id="67335d97891434d9b2fc13c58d72fc58ea4a3509" translate="yes" xml:space="preserve">
          <source>tostring()</source>
          <target state="translated">tostring()</target>
        </trans-unit>
        <trans-unit id="a09ffb5c93c324094fe97d43e475793e48cd9cc2" translate="yes" xml:space="preserve">
          <source>translates to</source>
          <target state="translated">로 번역</target>
        </trans-unit>
        <trans-unit id="2f746d02fe588180e5eec4bbf6e7e14f76d8a306" translate="yes" xml:space="preserve">
          <source>type()</source>
          <target state="translated">type()</target>
        </trans-unit>
        <trans-unit id="01e58a219a3776ebc9720c996a37ce7aa1182c88" translate="yes" xml:space="preserve">
          <source>utf8.char()</source>
          <target state="translated">utf8.char()</target>
        </trans-unit>
        <trans-unit id="59eb83945a4772d78478b485d6f72d7fb152778c" translate="yes" xml:space="preserve">
          <source>utf8.charpattern</source>
          <target state="translated">utf8.charpattern</target>
        </trans-unit>
        <trans-unit id="78b16272b329d4f911b63850d6d379237d30869d" translate="yes" xml:space="preserve">
          <source>utf8.codepoint()</source>
          <target state="translated">utf8.codepoint()</target>
        </trans-unit>
        <trans-unit id="5ec7b2931dfb7c2e48b29f067f12b470a8e1c105" translate="yes" xml:space="preserve">
          <source>utf8.codes()</source>
          <target state="translated">utf8.codes()</target>
        </trans-unit>
        <trans-unit id="85188b5823c4024baf3316fc9d1b29a3870502ea" translate="yes" xml:space="preserve">
          <source>utf8.len()</source>
          <target state="translated">utf8.len()</target>
        </trans-unit>
        <trans-unit id="c8edb0148f3b9fc23c6177c7baee26c255d81017" translate="yes" xml:space="preserve">
          <source>utf8.offset()</source>
          <target state="translated">utf8.offset()</target>
        </trans-unit>
        <trans-unit id="ee87c12edd8318f8f8c6bbb87517c957c579e04c" translate="yes" xml:space="preserve">
          <source>will first set &lt;code&gt;a&lt;/code&gt; to 1, then print the value of &lt;code&gt;a&lt;/code&gt;, and finally run the file &lt;code&gt;script.lua&lt;/code&gt; with no arguments. (Here &lt;code&gt;$&lt;/code&gt; is the shell prompt. Your prompt may be different.)</source>
          <target state="translated">먼저 &lt;code&gt;a&lt;/code&gt; 를 1로 설정 한 다음 &lt;code&gt;a&lt;/code&gt; 값을 인쇄 한 다음 마지막으로 인수없이 &lt;code&gt;script.lua&lt;/code&gt; 파일을 실행합니다 . (여기서 &lt;code&gt;$&lt;/code&gt; 는 쉘 프롬프트입니다. 프롬프트가 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="35c27b27a72e08637d00678476cc92429077bf95" translate="yes" xml:space="preserve">
          <source>will iterate over all characters in string &lt;code&gt;s&lt;/code&gt;, with &lt;code&gt;p&lt;/code&gt; being the position (in bytes) and &lt;code&gt;c&lt;/code&gt; the code point of each character. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">는 문자열 &lt;code&gt;s&lt;/code&gt; 의 모든 문자를 반복하며 , &lt;code&gt;p&lt;/code&gt; 는 위치 (바이트)이고 &lt;code&gt;c&lt;/code&gt; 는 각 문자의 코드 포인트입니다. 유효하지 않은 바이트 시퀀스를 만족하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1a06017b80342950867e029e780f34bc70b489b" translate="yes" xml:space="preserve">
          <source>will iterate over all characters of the file, starting at the current position. Unlike &lt;a href=&quot;#pdf-io.lines&quot;&gt;&lt;code&gt;io.lines&lt;/code&gt;&lt;/a&gt;, this function does not close the file when the loop ends.</source>
          <target state="translated">현재 위치에서 시작하여 파일의 모든 문자를 반복합니다. &lt;a href=&quot;#pdf-io.lines&quot;&gt; &lt;code&gt;io.lines&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 루프가 종료 될 때 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fff660b968f8fba0978e397e45f5bc32d0d92e3d" translate="yes" xml:space="preserve">
          <source>will iterate over all key&amp;ndash;value pairs of table &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;t&lt;/code&gt; 의 모든 키-값 쌍을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="2a1161751483cdc4039d463b29fdee6ddf66811a" translate="yes" xml:space="preserve">
          <source>will iterate over the key&amp;ndash;value pairs (&lt;code&gt;1,t[1]&lt;/code&gt;), (&lt;code&gt;2,t[2]&lt;/code&gt;), ..., up to the first nil value.</source>
          <target state="translated">키-값 쌍 ( &lt;code&gt;1,t[1]&lt;/code&gt; ), ( &lt;code&gt;2,t[2]&lt;/code&gt; ), ...을 통해 첫 번째 nil 값까지 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="fed099758520aeb285c31c75d6579ec9d9a6d66c" translate="yes" xml:space="preserve">
          <source>will print &quot;&lt;code&gt;-e&lt;/code&gt;&quot;. If there is a script, the script is called with parameters &lt;code&gt;arg[1]&lt;/code&gt;, &amp;middot;&amp;middot;&amp;middot;, &lt;code&gt;arg[#arg]&lt;/code&gt;. (Like all chunks in Lua, the script is compiled as a vararg function.)</source>
          <target state="translated">&quot; &lt;code&gt;-e&lt;/code&gt; &quot; 를 인쇄 합니다. 스크립트가있는 경우, 스크립트는 &lt;code&gt;arg[1]&lt;/code&gt; , &amp;middot;&amp;middot;&amp;middot;, &lt;code&gt;arg[#arg]&lt;/code&gt; 매개 변수와 함께 호출됩니다 . (루아의 모든 청크와 마찬가지로 스크립트는 vararg 함수로 컴파일됩니다.)</target>
        </trans-unit>
        <trans-unit id="4d5e3f44759c3410c81b3e34a722844bcd97a0a8" translate="yes" xml:space="preserve">
          <source>xpcall()</source>
          <target state="translated">xpcall()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
