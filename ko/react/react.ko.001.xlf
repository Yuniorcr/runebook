<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013&amp;ndash; 현재 Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="127b65641fa47a43d190a53aa1819065ddbc9d8b" translate="yes" xml:space="preserve">
          <source>&amp;hellip;could be rewritten using a React component:</source>
          <target state="translated">&amp;hellip; React 컴포넌트를 사용하여 다시 작성할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="411af19f51081800932d697191d96f1ba6662478" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;CSS-in-JS&amp;rdquo; refers to a pattern where CSS is composed using JavaScript instead of defined in external files. Read a comparison of CSS-in-JS libraries &lt;a href=&quot;https://github.com/MicheleBertoli/css-in-js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&quot;CSS-in-JS&quot;는 CSS가 외부 파일에 정의되지 않고 JavaScript를 사용하여 구성되는 패턴을 나타냅니다. CSS-in-JS 라이브러리 비교를 &lt;a href=&quot;https://github.com/MicheleBertoli/css-in-js&quot;&gt;여기&lt;/a&gt; 에서 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="474f555551dc0ace2b8ee29980fc27176a860957" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Create&amp;rdquo; wouldn&amp;rsquo;t be quite accurate because the state is only created the first time our component renders. During the next renders, &lt;code&gt;useState&lt;/code&gt; gives us the current state. Otherwise it wouldn&amp;rsquo;t be &amp;ldquo;state&amp;rdquo; at all! There&amp;rsquo;s also a reason why Hook names &lt;em&gt;always&lt;/em&gt; start with &lt;code&gt;use&lt;/code&gt;. We&amp;rsquo;ll learn why later in the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;만들기&amp;rdquo;는 상태가 컴포넌트가 처음 렌더링 될 때만 만들어지기 때문에 정확하지 않습니다. 다음 렌더링 중에 &lt;code&gt;useState&lt;/code&gt; 는 현재 상태를 제공합니다. 그렇지 않으면 전혀 &quot;상태&quot;가 아닙니다! 후크 이름이 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;use&lt;/code&gt; 로 시작 하는 이유도 있습니다 . 우리는 나중에 &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙&lt;/a&gt; 에서 이유를 배울 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5f451b7c89dd904f3aef210c86d4117268ade522" translate="yes" xml:space="preserve">
          <source>&amp;lt;SuspenseList&amp;gt;</source>
          <target state="translated">&amp;lt;SuspenseList&amp;gt;</target>
        </trans-unit>
        <trans-unit id="003bacc820ad6ed64a7150ba533c1f205d753675" translate="yes" xml:space="preserve">
          <source>(The identity of the &lt;code&gt;setCount&lt;/code&gt; function is guaranteed to be stable so it&amp;rsquo;s safe to omit.)</source>
          <target state="translated">&lt;code&gt;setCount&lt;/code&gt; 함수 의 ID는 안정적으로 보장되므로 생략해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5537feccba2706d8c7567ba108d3ea81718c256a" translate="yes" xml:space="preserve">
          <source>(This same property also allows &lt;code&gt;connect&lt;/code&gt; and other enhancer-style HOCs to be used as decorators, an experimental JavaScript proposal.)</source>
          <target state="translated">(이와 동일한 특성으로 &lt;code&gt;connect&lt;/code&gt; 및 기타 인핸서 스타일 HOC를 실험용 JavaScript 제안으로 데코레이터로 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="eec0311501a4dc653fb7b1449410f6e5df587029" translate="yes" xml:space="preserve">
          <source>**: Warns in development.</source>
          <target state="translated">** : 개발 경고.</target>
        </trans-unit>
        <trans-unit id="0b7fd61b5cc7e86f044d5b2120a1f2f5e7dd0bde" translate="yes" xml:space="preserve">
          <source>*: Legacy mode has automatic batching in React-managed events but it&amp;rsquo;s limited to one browser task. Non-React events must opt-in using &lt;code&gt;unstable_batchedUpdates&lt;/code&gt;. In Blocking Mode and Concurrent Mode, all &lt;code&gt;setState&lt;/code&gt;s are batched by default.</source>
          <target state="translated">* : 레거시 모드에는 React 관리 이벤트에서 자동 일괄 처리 기능이 있지만 하나의 브라우저 작업으로 제한됩니다. 비 반응 이벤트는 &lt;code&gt;unstable_batchedUpdates&lt;/code&gt; 를 사용하여 옵트 인해야 합니다. 차단 모드 및 동시 모드에서 모든 &lt;code&gt;setState&lt;/code&gt; 는 기본적으로 일괄 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b349d3c84eca2532fac6087f7427aeb1fb288d12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#example-using-classes-1&quot;&gt;Earlier on this page&lt;/a&gt;, we introduced an example &lt;code&gt;FriendStatus&lt;/code&gt; component that displays whether a friend is online or not. Our class reads &lt;code&gt;friend.id&lt;/code&gt; from &lt;code&gt;this.props&lt;/code&gt;, subscribes to the friend status after the component mounts, and unsubscribes during unmounting:</source>
          <target state="translated">&lt;a href=&quot;#example-using-classes-1&quot;&gt;이 페이지 초반에&lt;/a&gt; 친구가 온라인 상태인지 여부를 표시하는 &lt;code&gt;FriendStatus&lt;/code&gt; 구성 요소 의 예를 소개했습니다 . 우리 클래스 는 &lt;code&gt;this.props&lt;/code&gt; 에서 &lt;code&gt;friend.id&lt;/code&gt; 를 읽고 컴포넌트가 마운트 된 후 친구 상태를 구독하고 마운트 해제 중 구독을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a7d0e66fe3bcbaf7fb71d7c9c7ced93e8dcd7d2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#experimental-channel&quot;&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/a&gt; includes experimental APIs and features that aren&amp;rsquo;t available in the stable releases. These also track the master branch, but with additional feature flags turned on. Use this to try out upcoming features before they are released.</source>
          <target state="translated">&lt;a href=&quot;#experimental-channel&quot;&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/a&gt; 에는 안정 릴리스에서 사용할 수없는 실험용 API 및 기능이 포함됩니다. 또한 마스터 분기를 추적하지만 추가 기능 플래그가 설정되어 있습니다. 이 기능을 사용하여 예정된 기능이 출시되기 전에 시험해보십시오.</target>
        </trans-unit>
        <trans-unit id="9b8acd483f2b7766c5939834892982283be276ca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#latest-channel&quot;&gt;&lt;strong&gt;Latest&lt;/strong&gt;&lt;/a&gt; is for stable, semver React releases. It&amp;rsquo;s what you get when you install React from npm. This is the channel you&amp;rsquo;re already using today. &lt;strong&gt;Use this for all user-facing React applications.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;#latest-channel&quot;&gt;&lt;strong&gt;최신&lt;/strong&gt;&lt;/a&gt; 은 안정적인 semver React 릴리즈입니다. npm에서 React를 설치할 때 얻는 것입니다. 이 채널은 오늘 이미 사용중인 채널입니다. &lt;strong&gt;사용자가 직면 한 모든 React 애플리케이션에이를 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f331b32dba01c22c3f9ee9dcd30160741976454" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#next-channel&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;&lt;/a&gt; tracks the master branch of the React source code repository. Think of these as release candidates for the next minor semver release. Use this for integration testing between React and third party projects.</source>
          <target state="translated">&lt;a href=&quot;#next-channel&quot;&gt;&lt;strong&gt;다음&lt;/strong&gt;&lt;/a&gt; 은 React 소스 코드 저장소의 마스터 분기를 추적합니다. 이것을 다음 마이너 semver 릴리스의 릴리스 후보로 생각하십시오. React와 타사 프로젝트 간의 통합 테스트에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1626442757705f12d753a3a5d0a59017c028e31a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#optional-try-react-with-jsx&quot;&gt;Optional: Try React with JSX&lt;/a&gt; (no bundler necessary!)</source>
          <target state="translated">&lt;a href=&quot;#optional-try-react-with-jsx&quot;&gt;선택 사항 : JSX로 반응을 시도하십시오&lt;/a&gt; ( 번들 필요 없음).</target>
        </trans-unit>
        <trans-unit id="659e2140b913cf60f03be174b35c605c49e283a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;components-and-props&quot;&gt;&lt;code&gt;props&lt;/code&gt;&lt;/a&gt; (short for &amp;ldquo;properties&amp;rdquo;) and &lt;a href=&quot;state-and-lifecycle&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt; are both plain JavaScript objects. While both hold information that influences the output of render, they are different in one important way: &lt;code&gt;props&lt;/code&gt; get passed &lt;em&gt;to&lt;/em&gt; the component (similar to function parameters) whereas &lt;code&gt;state&lt;/code&gt; is managed &lt;em&gt;within&lt;/em&gt; the component (similar to variables declared within a function).</source>
          <target state="translated">&lt;a href=&quot;components-and-props&quot;&gt; &lt;code&gt;props&lt;/code&gt; &lt;/a&gt; ( &quot;속성&quot;의 약자)와&lt;a href=&quot;state-and-lifecycle&quot;&gt; &lt;code&gt;state&lt;/code&gt; &lt;/a&gt; 는 일반 JavaScript 객체입니다. 둘 다 렌더의 출력에 영향을 미치는 정보를 보유하고 있지만 한 가지 중요한 방식으로 다릅니다. &lt;code&gt;props&lt;/code&gt; 은 구성 요소에전달&lt;em&gt; 되고&lt;/em&gt; (함수 매개 변수와 유사) &lt;code&gt;state&lt;/code&gt; 는구성 요소&lt;em&gt; 내&lt;/em&gt; 에서관리&lt;em&gt; 됩니다&lt;/em&gt; (함수 내에 선언 된 변수와 유사).</target>
        </trans-unit>
        <trans-unit id="c11587663134187b0dab35da7c0f9449ba536da9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;Adopting Concurrent Mode&lt;/a&gt; explains how you can try Concurrent Mode in your project.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;동시 모드 채택&lt;/a&gt; 은 프로젝트에서 동시 모드를 시도하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="92d6142e8402580e0bbbd015a289393a5ab03417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt; shows some UI patterns made possible by Concurrent Mode and Suspense.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;동시 UI 패턴&lt;/a&gt; 은 동시 모드 및 서스펜스에 의해 가능한 일부 UI 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d13c6c20a36b89ed034032b2df5848a62e0eae1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-reference&quot;&gt;Concurrent Mode API Reference&lt;/a&gt; documents the new APIs available in experimental builds.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-reference&quot;&gt;동시 모드 API 참조&lt;/a&gt; 는 실험 빌드에서 사용 가능한 새로운 API를 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="4b8b0168cc4bbf653a7b87a3e660739cc7e23de3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt; describes a new mechanism for fetching data in React components.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;데이터 가져 오기에 대한 서스펜스&lt;/a&gt; 는 React 컴포넌트에서 데이터를 가져 오는 새로운 메커니즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e7b3a6755e2482086d497d80dc7b04fda7312afb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;error-boundaries&quot;&gt;Error boundaries&lt;/a&gt; are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="translated">&lt;a href=&quot;error-boundaries&quot;&gt;오류 경계&lt;/a&gt; 는 하위 구성 요소 트리의 어느 곳에서나 JavaScript 오류를 포착하고 오류를 기록하며 충돌 한 구성 요소 트리 대신 대체 UI를 표시하는 React 구성 요소입니다. 오류 경계는 렌더링 중, 수명주기 메소드 및 그 아래에있는 전체 트리의 생성자에서 오류를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="50dd970eac1bdc84a77e8463664190c3a8e7086a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;forms#controlled-components&quot;&gt;Controlled&lt;/a&gt; vs. &lt;a href=&quot;uncontrolled-components&quot;&gt;Uncontrolled Components&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;forms#controlled-components&quot;&gt;제어&lt;/a&gt; 대 &lt;a href=&quot;uncontrolled-components&quot;&gt;제어되지 않은 구성 요소&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9deaea842b2a2025b0d2c4183deba20a474ebb43" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hooks-overview&quot;&gt;Hooks at a Glance&lt;/a&gt; is a good place to start learning Hooks.</source>
          <target state="translated">&lt;a href=&quot;hooks-overview&quot;&gt;Hooks at a Glance&lt;/a&gt; 는 Hooks 학습을 시작하기에 좋은 곳입니다.</target>
        </trans-unit>
        <trans-unit id="dbff4fdc2fc809052b076958d62db8674fc3040e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html&quot;&gt;Subscriptions&lt;/a&gt; in Rx.</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html&quot;&gt;&lt;/a&gt;Rx 구독 .</target>
        </trans-unit>
        <trans-unit id="abd0571199be7c81b3ae4cbaac1e3b4ad6076fd6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; views typically use HTML strings, or string-producing template functions, to create the content for their DOM elements. This process, too, can be replaced with rendering a React component.</source>
          <target state="translated">&lt;a href=&quot;https://backbonejs.org/&quot;&gt;백본&lt;/a&gt; 보기는 일반적으로 HTML 문자열 또는 문자열 생성 템플릿 함수를 사용하여 DOM 요소의 컨텐츠를 작성합니다. 이 프로세스도 React 컴포넌트 렌더링으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af6fbc549852becb801f8d5e2e60f7a599b43ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; is a way of queuing a function to be executed in the browser at the optimal time for rendering performance. A function that is queued with &lt;code&gt;requestAnimationFrame&lt;/code&gt; will fire in the next frame. The browser will work hard to ensure that there are 60 frames per second (60 fps). However, if the browser is unable to it will naturally &lt;em&gt;limit&lt;/em&gt; the amount of frames in a second. For example, a device might only be able to handle 30 fps and so you will only get 30 frames in that second. Using &lt;code&gt;requestAnimationFrame&lt;/code&gt; for throttling is a useful technique in that it prevents you from doing more than 60 updates in a second. If you are doing 100 updates in a second this creates additional work for the browser that the user will not see anyway.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; &lt;/a&gt; 은 렌더링 성능을 위해 최적의 시간에 브라우저에서 실행될 함수를 큐잉하는 방법입니다. &lt;code&gt;requestAnimationFrame&lt;/code&gt; 으로 대기중인 함수는 다음 프레임에서 실행됩니다. 브라우저는 초당 60 프레임 (60fps)이되도록 열심히 작동합니다. 그러나 브라우저를 사용할 수없는 경우 자연스럽게1 초에 프레임수를&lt;em&gt; 제한&lt;/em&gt; 합니다. 예를 들어 장치는 30fps 만 처리 할 수 ​​있으므로 해당 초에 30 프레임 만 얻을 수 있습니다.제한에 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 을사용하면 초당 60 회 이상의 업데이트를 수행 할 수 없다는 점에서 유용한 기술입니다. 1 초에 100 번의 업데이트를 수행하는 경우 사용자가 볼 수없는 추가 작업이 브라우저에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cc593d53096ee1019613a19d2c3be835f80be32a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt; and above support Hooks.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;네이티브 0.59&lt;/a&gt; 이상은 후크를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7761f99601bdbfa373520f6ad6ca588b809637c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; is a static type checker for your JavaScript code. It is developed at Facebook and is often used with React. It lets you annotate the variables, functions, and React components with a special type syntax, and catch mistakes early. You can read an &lt;a href=&quot;https://flow.org/en/docs/getting-started/&quot;&gt;introduction to Flow&lt;/a&gt; to learn its basics.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; 는 JavaScript 코드의 정적 유형 검사기입니다. Facebook에서 개발되었으며 종종 React와 함께 사용됩니다. 변수, 함수 및 React 구성 요소에 특수 유형 구문으로 주석을 달고 실수를 조기에 발견 할 수 있습니다. &lt;a href=&quot;https://flow.org/en/docs/getting-started/&quot;&gt;Flow&lt;/a&gt; 에 대한 소개를 읽고 기본 사항을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbc4ff25c8b08bae8e391179afdb401d0925dc91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an &lt;code&gt;.eslintrc&lt;/code&gt; file in the root of your project with this content:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; 에는 규칙의 하위 세트가 활성화 된이 플러그인이 있습니다. 더 많은 접근성 규칙을 사용하려면 다음 내용으로 프로젝트 루트에 &lt;code&gt;.eslintrc&lt;/code&gt; 파일을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fce689a30d167b5be218e539f61cb024a4501e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; is a comfortable environment for &lt;strong&gt;learning React&lt;/strong&gt;, and is the best way to start building &lt;strong&gt;a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; application&lt;/strong&gt; in React.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React 앱 만들기는 React &lt;/a&gt;&lt;strong&gt;학습을&lt;/strong&gt; 위한 편안한 환경이며 &lt;strong&gt;React&lt;/strong&gt; 에서 &lt;strong&gt;새로운 &lt;a href=&quot;glossary#single-page-application&quot;&gt;단일 페이지&lt;/a&gt; 응용 프로그램&lt;/strong&gt; 을 구축 &lt;strong&gt;하는&lt;/strong&gt; 가장 좋은 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="89b261ad394a28f97a4ba639292739131c48b332" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting&quot;&gt;Algebraic effects&lt;/a&gt; in Multicore OCaml.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting&quot;&gt;&lt;/a&gt;Multicore OCaml의 대수 효과 .</target>
        </trans-unit>
        <trans-unit id="1beba2269c05a33decc78c25f4769e740904efe9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/sebmarkbage&quot;&gt;Sebastian Markb&amp;aring;ge&lt;/a&gt; came up with the original design for Hooks, later refined by &lt;a href=&quot;https://github.com/acdlite&quot;&gt;Andrew Clark&lt;/a&gt;, &lt;a href=&quot;https://github.com/sophiebits&quot;&gt;Sophie Alpert&lt;/a&gt;, &lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;, and other members of the React team.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sebmarkbage&quot;&gt;Sebastian Markb&amp;aring;ge&lt;/a&gt; 는 Hooks를위한 독창적 인 디자인을 제안했으며, 나중에 &lt;a href=&quot;https://github.com/acdlite&quot;&gt;Andrew Clark&lt;/a&gt; , &lt;a href=&quot;https://github.com/sophiebits&quot;&gt;Sophie Alpert&lt;/a&gt; , &lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt; 및 React 팀의 다른 사람들이 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="a028d74af46c420b5cfb12fdc16fbb5b92d0f34c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067&quot;&gt;&lt;code&gt;adopt&lt;/code&gt; keyword&lt;/a&gt; proposal as a sugar syntax for render props.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/trueadm&quot;&gt;도미닉 Gannaway&lt;/a&gt; 의이 &lt;a href=&quot;https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067&quot;&gt; &lt;code&gt;adopt&lt;/code&gt; 키워드&lt;/a&gt; 소품 렌더링을위한 설탕 구문과 같은 제안을.</target>
        </trans-unit>
        <trans-unit id="ea2a5cf38e105f920474aadb97cc98a8fb17e6a5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin&lt;/a&gt; is a statically typed language developed by JetBrains. Its target platforms include the JVM, Android, LLVM, and &lt;a href=&quot;https://kotlinlang.org/docs/reference/js-overview.html&quot;&gt;JavaScript&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;코 틀린는&lt;/a&gt; JetBrains의에 의해 개발 된 정적으로 입력 된 언어입니다. 대상 플랫폼에는 JVM, Android, LLVM 및 &lt;a href=&quot;https://kotlinlang.org/docs/reference/js-overview.html&quot;&gt;JavaScript가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="92b406c5a7ef4d2530bdb4fca8799640b156ac54" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt; is a popular and lightweight framework for &lt;strong&gt;static and server‑rendered applications&lt;/strong&gt; built with React. It includes &lt;strong&gt;styling and routing solutions&lt;/strong&gt; out of the box, and assumes that you&amp;rsquo;re using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; as the server environment.</source>
          <target state="translated">&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt; 는 React로 구축 &lt;strong&gt;된 정적 및 서버 렌더링 응용 프로그램을&lt;/strong&gt; 위한 대중적이고 가벼운 프레임 워크입니다 . &lt;strong&gt;기본적으로 스타일링 및 라우팅 솔루션&lt;/strong&gt; 이 포함되어 &lt;strong&gt;있으며 &lt;/strong&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 를 서버 환경으로 사용한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="ee851673be2d30ea8c8f63acabb6e99b5c8864b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://react-window.now.sh/&quot;&gt;react-window&lt;/a&gt; and &lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;react-virtualized&lt;/a&gt; are popular windowing libraries. They provide several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like &lt;a href=&quot;https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3&quot;&gt;Twitter did&lt;/a&gt;, if you want something more tailored to your application&amp;rsquo;s specific use case.</source>
          <target state="translated">&lt;a href=&quot;https://react-window.now.sh/&quot;&gt;반응 창&lt;/a&gt; 및 &lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;반응 가상화&lt;/a&gt; 는 널리 사용되는 창 라이브러리입니다. 이들은 목록, 그리드 및 테이블 형식 데이터를 표시하기 위해 재사용 가능한 여러 구성 요소를 제공합니다. 응용 프로그램의 특정 사용 사례에 더 적합한 것을 원한다면 &lt;a href=&quot;https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3&quot;&gt;Twitter&lt;/a&gt; 처럼 자체 창 구성 요소를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cec74ab70c3c50d041a9625d49999fc73d2b52df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;Here&lt;/a&gt; is an example of the issues that can be caused by using indexes as keys on CodePen, and &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;here&lt;/a&gt; is an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;여기&lt;/a&gt; CodePen에 키로 인덱스를 사용하여 발생 될 수있는 문제의 예입니다 &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;이곳은&lt;/a&gt; 키가이 재정렬를 해결하므로, 인덱스를 사용하여 정렬 및 문제를 붙이는하지 방법을 보여 같은 예제의 업데이트 버전입니다.</target>
        </trans-unit>
        <trans-unit id="60eebbd123cdc3177bbe55d829eb6495eb0a2456" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/&quot;&gt;Reason&lt;/a&gt; is not a new language; it&amp;rsquo;s a new syntax and toolchain powered by the battle-tested language, &lt;a href=&quot;https://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;. Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.</source>
          <target state="translated">&lt;a href=&quot;https://reasonml.github.io/&quot;&gt;이유&lt;/a&gt; 는 새로운 언어가 아닙니다. 이 언어는 전투 테스트 언어 인 &lt;a href=&quot;https://ocaml.org/&quot;&gt;OCaml에&lt;/a&gt; 의해 구동되는 새로운 구문 및 툴체인 입니다. 이유는 OCaml에 JavaScript 프로그래머를 대상으로하는 익숙한 구문을 제공하고 이미 알고있는 기존 NPM / Yarn 워크 플로우 사용자에게 적합합니다.</target>
        </trans-unit>
        <trans-unit id="51704da4ca578722a2b6aecca6033abc42fafc9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html&quot;&gt;Reducer components&lt;/a&gt; in ReasonReact.</source>
          <target state="translated">&lt;a href=&quot;https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html&quot;&gt;&lt;/a&gt;ReasonReact의 감속기 구성 요소 .</target>
        </trans-unit>
        <trans-unit id="507c854bed88971402cdd4e75eb17ff213b9f9a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.chromevox.com/&quot;&gt;ChromeVox&lt;/a&gt; is an integrated screen reader on Chromebooks and is available &lt;a href=&quot;https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;as an extension&lt;/a&gt; for Google Chrome.</source>
          <target state="translated">&lt;a href=&quot;https://www.chromevox.com/&quot;&gt;ChromeVox&lt;/a&gt; 는 Chromebook의 통합 스크린 리더이며 Chrome &lt;a href=&quot;https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;확장 프로그램으로&lt;/a&gt; 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f95e67778c2804202a6bfb18c1978277a39275e9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.deque.com/products/axe/&quot;&gt;The Accessibility Engine&lt;/a&gt; or aXe, is an accessibility inspector browser extension built on &lt;code&gt;aXe-core&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.deque.com/products/axe/&quot;&gt;접근성 엔진&lt;/a&gt; 또는 aXe는 &lt;code&gt;aXe-core&lt;/code&gt; 기반의 접근성 검사기 브라우저 확장 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="58f8e9ad7eafaa77baf2a863ca7a0a7708237a83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.freedomscientific.com/Products/software/JAWS/&quot;&gt;Job Access With Speech&lt;/a&gt; or JAWS, is a prolifically used screen reader on Windows.</source>
          <target state="translated">&lt;a href=&quot;https://www.freedomscientific.com/Products/software/JAWS/&quot;&gt;Speech&lt;/a&gt; 또는 JAWS를 사용한 작업 액세스 는 Windows에서 널리 사용되는 스크린 리더입니다.</target>
        </trans-unit>
        <trans-unit id="3c59281500e4647172f2bc7d1c2d241f8533e108" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; is the best way to create &lt;strong&gt;static websites&lt;/strong&gt; with React. It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; 는 React 를 사용하여 &lt;strong&gt;정적 웹 사이트&lt;/strong&gt; 를 만드는 가장 좋은 방법 입니다. React 컴포넌트를 사용할 수 있지만, 가장 빠른로드 시간을 보장하기 위해 사전 렌더링 된 HTML 및 CSS를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="e111bc5c6ed31a7244c06ecd3a45a04232ee6e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NonVisual Desktop Access&lt;/a&gt; or NVDA is an open source Windows screen reader that is widely used.</source>
          <target state="translated">&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NonVisual Desktop Access&lt;/a&gt; 또는 NVDA는 널리 사용되는 오픈 소스 Windows 스크린 리더입니다.</target>
        </trans-unit>
        <trans-unit id="df1c72f7a39fed3103f79e6934d680b5f8640aa0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/&quot;&gt;The Accessibility Tree&lt;/a&gt; is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers.</source>
          <target state="translated">&lt;a href=&quot;https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/&quot;&gt;접근성 트리는&lt;/a&gt; 화면 판독기와 같은 보조 기술에 노출되어야하는 모든 DOM 요소에 대한 접근 가능한 객체를 포함하는 DOM 트리의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="0b37c8997661be6f87f540ff73ff4239f26b970f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; is a programming language developed by Microsoft. It is a typed superset of JavaScript, and includes its own compiler. Being a typed language, TypeScript can catch errors and bugs at build time, long before your app goes live. You can learn more about using TypeScript with React &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 는 Microsoft에서 개발 한 프로그래밍 언어입니다. 형식화 된 JavaScript의 슈퍼 세트이며 자체 컴파일러를 포함합니다. TypeScript는 유형이 지정된 언어이기 때문에 앱이 출시되기 훨씬 전에 빌드 타임에 오류와 버그를 포착 할 수 있습니다. React와 함께 TypeScript를 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0a68c5959b325979016d4ef5818f5d3835df00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;This post by Yehuda Katz&lt;/a&gt; explains what binding is, and how functions work in JavaScript, in detail.</source>
          <target state="translated">&lt;a href=&quot;https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Yehuda Katz의이 게시물은&lt;/a&gt; 바인딩이 무엇인지, JavaScript에서 함수가 작동하는 방식을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5df88d6cbd086d1137e1b90460b2ae5daeb6e02d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-environments&quot;&gt;Environments&lt;/a&gt;: What to consider when setting up a testing environment for React components.</source>
          <target state="translated">&lt;a href=&quot;testing-environments&quot;&gt;환경&lt;/a&gt; : React 구성 요소에 대한 테스트 환경을 설정할 때 고려할 사항.</target>
        </trans-unit>
        <trans-unit id="63a050b272e7248967a84a74e4e4bd2b6ba64fa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Recipes&lt;/a&gt;: Common patterns when writing tests for React components.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt;레시피&lt;/a&gt; : React 컴포넌트에 대한 테스트 작성시 공통 패턴</target>
        </trans-unit>
        <trans-unit id="0b486e3fcc27a7fb19f9db032b3f4035175b1759" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt; include many examples that you can copy and paste.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt;레시피 테스트&lt;/a&gt; 에는 복사하여 붙여 넣을 수있는 많은 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="899e47cb75bdfa2c9463f015b04ba588ae7307f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Try it on CodePen&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;CodePen에서 사용해보십시오&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2668baa3995626a387d9d0db8c0e74c80d30c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; would need to return multiple &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; elements in order for the rendered HTML to be valid. If a parent div was used inside the &lt;code&gt;render()&lt;/code&gt; of &lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt;, then the resulting HTML will be invalid.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; 렌더링 된 HTML이 유효하려면 &amp;lt;Columns /&amp;gt; 가 여러 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 요소 를 리턴해야 합니다. 부모 사업부가 내부에 사용 된 경우는 &lt;code&gt;render()&lt;/code&gt; 의를 &lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; , 그 결과 HTML이 유효 할 것이다.</target>
        </trans-unit>
        <trans-unit id="2c48f4f018d496ec7a9fc3610cfc090f4535bedd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; coordinates the &amp;ldquo;reveal order&amp;rdquo; of the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes below it:</source>
          <target state="translated">&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 는 그 아래에 가장 가까운 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 노드 의&amp;ldquo;공개 순서&amp;rdquo;를 조정 합니다.</target>
        </trans-unit>
        <trans-unit id="16be52f847db59c8b851d5a60c48482650c507e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is the last pattern that&amp;rsquo;s related to orchestrating loading states.</source>
          <target state="translated">&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 는로드 상태 조정과 관련된 마지막 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="b873bb3d00c9528b75a68b611f719965252de42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.ts&lt;/code&gt; is the default file extension while &lt;code&gt;.tsx&lt;/code&gt; is a special extension used for files which contain &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 는 기본 파일 확장자이며 &lt;code&gt;.tsx&lt;/code&gt; 는 &lt;code&gt;JSX&lt;/code&gt; 를 포함하는 파일에 사용되는 특수 확장자 입니다.</target>
        </trans-unit>
        <trans-unit id="0cce24d484768d091fea665846435e70110e03e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Clock&lt;/code&gt; is now defined as a class rather than a function.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 는 이제 함수가 아닌 클래스로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d97fbce190263926ad39364b0f1f1231de906168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; aren&amp;rsquo;t identical &amp;mdash; they call different methods on &lt;code&gt;DataSource&lt;/code&gt;, and they render different output. But much of their implementation is the same:</source>
          <target state="translated">&lt;code&gt;CommentList&lt;/code&gt; 와 &lt;code&gt;BlogPost&lt;/code&gt; 는 동일하지 않습니다. &lt;code&gt;DataSource&lt;/code&gt; 에서 다른 메소드를 호출 하고 다른 출력을 렌더링합니다. 그러나 대부분의 구현은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9c9dc387b207d4eba8712af5ec2de3b114017f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProductTable&lt;/code&gt; needs to filter the product list based on state and &lt;code&gt;SearchBar&lt;/code&gt; needs to display the search text and checked state.</source>
          <target state="translated">&lt;code&gt;ProductTable&lt;/code&gt; 은 상태를 기준으로 제품 목록을 필터링해야하며 &lt;code&gt;SearchBar&lt;/code&gt; 는 검색 텍스트 및 확인 된 상태를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a3ab449a39f9f5441443dff9073f64b0a14d353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Profiler&lt;/code&gt; components can also be nested to measure different components within the same subtree:</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 구성 요소를 중첩하여 동일한 하위 트리 내에서 다른 구성 요소를 측정 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc64e9219fbd2d98085de711a35c090291ff1ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PropTypes&lt;/code&gt; exports a range of validators that can be used to make sure the data you receive is valid. In this example, we&amp;rsquo;re using &lt;code&gt;PropTypes.string&lt;/code&gt;. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. For performance reasons, &lt;code&gt;propTypes&lt;/code&gt; is only checked in development mode.</source>
          <target state="translated">&lt;code&gt;PropTypes&lt;/code&gt; 는 수신 한 데이터가 유효한지 확인하는 데 사용할 수있는 다양한 유효성 검사기를 내 보냅니다. 이 예에서는 &lt;code&gt;PropTypes.string&lt;/code&gt; 을 사용하고 있습니다. prop에 유효하지 않은 값이 제공되면 JavaScript 콘솔에 경고가 표시됩니다. 성능상의 이유로 &lt;code&gt;propTypes&lt;/code&gt; 는 개발 모드에서만 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="d7433c619e1feef93841473f073fe57946d546b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.only()&lt;/code&gt; does not accept the return value of &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; because it is an array rather than a React element.</source>
          <target state="translated">&lt;code&gt;React.Children.only()&lt;/code&gt; 의 리턴 값에 동의하지 않는 &lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; &lt;/a&gt; 그것이 소자 반응보다는 배열이기 때문이다.</target>
        </trans-unit>
        <trans-unit id="f8f33ecc6e1fa8a4fb53220f221a88fd97f9222c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.toArray()&lt;/code&gt; changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, &lt;code&gt;toArray&lt;/code&gt; prefixes each key in the returned array so that each element&amp;rsquo;s key is scoped to the input array containing it.</source>
          <target state="translated">&lt;code&gt;React.Children.toArray()&lt;/code&gt; 는 자식 목록을 병합 할 때 중첩 배열의 의미를 유지하도록 키를 변경합니다. 즉, &lt;code&gt;toArray&lt;/code&gt; 는 반환 된 배열의 각 키 앞에 접두사를 붙여 각 요소의 키가 해당 배열을 포함하는 입력 배열로 범위를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c08083eb996286312bfeec14c446492e6409fb5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children&lt;/code&gt; provides utilities for dealing with the &lt;code&gt;this.props.children&lt;/code&gt; opaque data structure.</source>
          <target state="translated">&lt;code&gt;React.Children&lt;/code&gt; 은 &lt;code&gt;this.props.children&lt;/code&gt; 불투명 데이터 구조 를 처리하기위한 유틸리티를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="018109caa5a7750f42f534d290130aa5ba7f1575" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&lt;/code&gt; is the base class for React components when they are defined using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 classes&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.Component&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스를&lt;/a&gt; 사용하여 정의 된 React 컴포넌트의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="d1cd67a9840c43ed56a80ec7fe993b83656c3558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt; to define &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.PropTypes&lt;/code&gt; 는 React v15.5 이후 다른 패키지로 옮겨졌습니다. &lt;code&gt;contextTypes&lt;/code&gt; 를 정의하려면 &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;대신 &lt;/a&gt; &lt;code&gt;prop-types&lt;/code&gt; 라이브러리를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="17765e95c09179d1a95a33445f4c103ce3e81d08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.PropTypes&lt;/code&gt; 는 React v15.5 이후 다른 패키지로 옮겨졌습니다. 사용하십시오 &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt; &lt;code&gt;prop-types&lt;/code&gt; &lt;/a&gt; 대신 라이브러리를 .</target>
        </trans-unit>
        <trans-unit id="0e47fb792a667b98cb29e172a0434b512bebe3c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt; is similar to &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt;. The difference between them is that &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t implement &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;React.PureComponent&lt;/code&gt; implements it with a shallow prop and state comparison.</source>
          <target state="translated">&lt;code&gt;React.PureComponent&lt;/code&gt; 은 비슷합니다 &lt;a href=&quot;#reactcomponent&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; &lt;/a&gt; . 차이점은 &lt;a href=&quot;#reactcomponent&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; 구현하지 않지만 &lt;code&gt;React.PureComponent&lt;/code&gt; 는 얕은 prop 및 state 비교로 구현한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5830b5c8c2f558edfa97e94aca64c2af14fc9e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend &lt;code&gt;PureComponent&lt;/code&gt; when you expect to have simple props and state, or use &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;forceUpdate()&lt;/code&gt;&lt;/a&gt; when you know deep data structures have changed. Or, consider using &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;immutable objects&lt;/a&gt; to facilitate fast comparisons of nested data.</source>
          <target state="translated">&lt;code&gt;React.PureComponent&lt;/code&gt; 의 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 는 객체를 얕게 비교합니다. 여기에 복잡한 데이터 구조가 포함되어 있으면 더 큰 차이를 위해 잘못된 음수를 생성 할 수 있습니다. 간단한 props 및 state가 &lt;code&gt;PureComponent&lt;/code&gt; 때만 PureComponent를 확장 하거나 심층적 인 데이터 구조가 변경된 것을 알고있는 경우 &lt;a href=&quot;react-component#forceupdate&quot;&gt; &lt;code&gt;forceUpdate()&lt;/code&gt; &lt;/a&gt; 사용하십시오 . 또는 중첩 된 데이터를 빠르게 비교할 수 있도록 &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;불변 개체&lt;/a&gt; 를 사용 하는 것도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="23ae44fbe5544ebea07424d1801e6b09421fc455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Suspense&lt;/code&gt; lets you specify the loading indicator in case some components in the tree below it are not yet ready to render. Today, lazy loading components is the &lt;strong&gt;only&lt;/strong&gt; use case supported by &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;React.Suspense&lt;/code&gt; 를 사용하면 아래 트리의 일부 구성 요소가 아직 렌더링 할 준비가되지 않은 경우로드 표시기를 지정할 수 있습니다. 오늘날 게으른 로딩 컴포넌트는 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 에서 지원 하는 &lt;strong&gt;유일한&lt;/strong&gt; 유스 케이스입니다 .</target>
        </trans-unit>
        <trans-unit id="bbf12260a4d1986fe548b7810036d6f89476f037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.cloneElement()&lt;/code&gt; is almost equivalent to:</source>
          <target state="translated">&lt;code&gt;React.cloneElement()&lt;/code&gt; 는 다음과 거의 같습니다 :</target>
        </trans-unit>
        <trans-unit id="df454f22d5923251d189f07fbd28b56e61571dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createElement()&lt;/code&gt; performs a few checks to help you write bug-free code but essentially it creates an object like this:</source>
          <target state="translated">&lt;code&gt;React.createElement()&lt;/code&gt; 는 버그가없는 코드를 작성하는 데 도움이되는 몇 가지 검사를 수행하지만 본질적으로 다음과 같은 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a541b1aa2e0e5adb6bae8f98abbd479633f37ffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createRef&lt;/code&gt; creates a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; that can be attached to React elements via the ref attribute.</source>
          <target state="translated">&lt;code&gt;React.createRef&lt;/code&gt; 는 ref 속성을 통해 React 요소에 첨부 할 수 있는 &lt;a href=&quot;refs-and-the-dom&quot;&gt;참조&lt;/a&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="bc9470bd7cce89bd9b552d1800bb64522b645d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function. React DevTools uses this function to determine what to display for the ref forwarding component.</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 는 렌더링 기능을 받아들입니다. React DevTools는이 기능을 사용하여 참조 전달 컴포넌트에 표시 할 내용을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b4b305dfd057aa13a5b67ab3715db62a57fee6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a rendering function as an argument. React will call this function with &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; as two arguments. This function should return a React node.</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 는 렌더링 함수를 인수로 받아들입니다. React는 &lt;code&gt;props&lt;/code&gt; 와 함께이 함수를 호출 하고 두 개의 인수로 &lt;code&gt;ref&lt;/code&gt; 합니다. 이 함수는 React 노드를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba5cdd473870d55755460b2032f82f8197284441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; creates a React component that forwards the &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; attribute it receives to another component below in the tree. This technique is not very common but is particularly useful in two scenarios:</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 는 수신 한 &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; 속성을 트리의 다른 구성 요소로 전달하는 React 구성 요소를 작성합니다 . 이 기술은 흔하지는 않지만 두 가지 시나리오에서 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d938930a6dc525df60638ade414c3cc420a5e7a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; and &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; are not yet supported by &lt;code&gt;ReactDOMServer&lt;/code&gt;. This is a known limitation that will be resolved in the future.</source>
          <target state="translated">&lt;code&gt;React.lazy()&lt;/code&gt; 및 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 은 아직 지원하지 않는 &lt;code&gt;ReactDOMServer&lt;/code&gt; . 이것은 향후 해결 될 알려진 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3bc934f42399b1985220d1173b8db1839de195a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; lets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren&amp;rsquo;t used during the initial render.</source>
          <target state="translated">&lt;code&gt;React.lazy()&lt;/code&gt; 사용하면 동적으로로드되는 구성 요소를 정의 할 수 있습니다. 이렇게하면 번들 크기를 줄여 초기 렌더링 중에 사용되지 않은 구성 요소의 로딩을 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5578f0ee78405460ecdf6cc8a4e6b079c3e56038" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; and Suspense are not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend &lt;a href=&quot;https://github.com/gregberge/loadable-components&quot;&gt;Loadable Components&lt;/a&gt;. It has a nice &lt;a href=&quot;https://loadable-components.com/docs/server-side-rendering/&quot;&gt;guide for bundle splitting with server-side rendering&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 서버 측 렌더링에는 React.lazy 및 Suspense를 아직 사용할 수 없습니다. 서버 렌더링 앱에서 코드 분할을 수행하려면 &lt;a href=&quot;https://github.com/gregberge/loadable-components&quot;&gt;Loadable Components를&lt;/a&gt; 권장 합니다. &lt;a href=&quot;https://loadable-components.com/docs/server-side-rendering/&quot;&gt;서버 측 렌더링을 사용한 번들 분할에 대한&lt;/a&gt; 유용한 안내서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e2cad079d46e6ccdc27029a5fb3af33ccc454b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; currently only supports default exports. If the module you want to import uses named exports, you can create an intermediate module that reexports it as the default. This ensures that tree shaking keeps working and that you don&amp;rsquo;t pull in unused components.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 는 현재 기본 내보내기 만 지원합니다. 가져 오려는 모듈이 명명 된 내보내기를 사용하는 경우이를 기본값으로 다시 내보내는 중간 모듈을 작성할 수 있습니다. 이렇게하면 나무 흔들림이 계속 작동하고 사용하지 않는 구성 요소를 잡아 당기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4700ecfe3a1cff452d92f397192e719da048b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; takes a function that must call a dynamic &lt;code&gt;import()&lt;/code&gt;. This must return a &lt;code&gt;Promise&lt;/code&gt; which resolves to a module with a &lt;code&gt;default&lt;/code&gt; export containing a React component.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 는 동적 &lt;code&gt;import()&lt;/code&gt; 호출해야하는 함수를 사용합니다 . 이것은 React 컴포넌트를 포함하는 &lt;code&gt;default&lt;/code&gt; 내보내기가있는 모듈로 해석 되는 &lt;code&gt;Promise&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d1290b39eae5fe11f9950b57588fb97ad5431dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; doesn&amp;rsquo;t compare state because there is no single state object to compare. But you can make children pure too, or even &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimize individual children with &lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 비교할 단일 상태 객체가 없으므로 React.memo 는 상태를 비교하지 않습니다. 그러나 어린이를 순수하게 만들거나 &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; 로&lt;/a&gt; 개별 어린이를 최적화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66970190886b14b2c94f1ed78940166904931843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; is a &lt;a href=&quot;higher-order-components&quot;&gt;higher order component&lt;/a&gt;. It&amp;rsquo;s similar to &lt;a href=&quot;#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; but for function components instead of classes.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 는 &lt;a href=&quot;higher-order-components&quot;&gt;고차 컴포넌트&lt;/a&gt; 입니다. &lt;a href=&quot;#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 클래스 대신 함수 구성 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ccf91e6ecdbd40744e7e90f5f7170b3011bafa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; only affects props changes. If your function component wrapped in &lt;code&gt;React.memo&lt;/code&gt; has a &lt;a href=&quot;hooks-state&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; Hook in its implementation, it will still rerender when state or context change.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 는 소품 변경에만 영향을 미칩니다. 에 싸여 함수 구성 요소 경우 &lt;code&gt;React.memo&lt;/code&gt; 는 가 &lt;a href=&quot;hooks-state&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; 의&lt;/a&gt; 구현, 그것은 것입니다 여전히 다시 쓰게 상태 또는 상황 변화에 후크.</target>
        </trans-unit>
        <trans-unit id="d91643c882bd9cf17080a88dd543c08f704be877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; also provides a component for rendering multiple elements without a wrapper.</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 또한 React 는 래퍼없이 여러 요소를 렌더링하기위한 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dae43399d30647f75931bc2d52220896440d778a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; is the entry point to the React library. If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;React&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import React from 'react'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var React = require('react')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 는 React 라이브러리의 진입 점입니다. &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 에서 React를로드 하면 &lt;code&gt;React&lt;/code&gt; 전역 에서 이러한 최상위 API를 사용할 수 있습니다 . npm과 함께 ES6을 사용하는 경우 &lt;code&gt;import React from 'react'&lt;/code&gt; 쓸 수 있습니다 . npm과 함께 ES5를 사용하는 경우 &lt;code&gt;var React = require('react')&lt;/code&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3615ce490a38501b5360b29feca2783c841a8758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; provides several APIs for manipulating elements:</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 는 요소 조작을위한 몇 가지 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ca7e3ecfcf94508081f0ca1cf574d0e0e6d68290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React&amp;rsquo;s DOM diffing algorithm for efficient updates.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 는 전달한 컨테이너 노드의 내용을 제어합니다. 기존의 모든 DOM 요소는 처음 호출 될 때 교체됩니다. 이후의 호출은 효율적인 업데이트를 위해 React의 DOM diffing 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="30f4db9c76d599ded6bfea76a35e0173f2582126" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; currently returns a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance, the preferred solution is to attach a &lt;a href=&quot;refs-and-the-dom#the-ref-callback-attribute&quot;&gt;callback ref&lt;/a&gt; to the root element.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 현재 루트 &lt;code&gt;ReactComponent&lt;/code&gt; 인스턴스에 대한 참조를 리턴 합니다. 그러나이 반환 값을 사용하는 것은 레거시이므로 향후 React 버전에서는 구성 요소를 비동기식으로 렌더링 할 수 있으므로 피해야합니다. 루트 &lt;code&gt;ReactComponent&lt;/code&gt; 인스턴스에 대한 참조가 필요한 경우 선호되는 솔루션은 루트 요소에 &lt;a href=&quot;refs-and-the-dom#the-ref-callback-attribute&quot;&gt;콜백 참조&lt;/a&gt; 를 첨부하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e83e4204803e18af5dd3272048dc8dba0c732a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 는 컨테이너 노드를 수정하지 않습니다 (컨테이너의 하위 만 수정). 기존 자식을 덮어 쓰지 않고 기존 DOM 노드에 구성 요소를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f7dde00d003271a0091e8b41dbc64eae6d5e284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactTestUtils&lt;/code&gt; makes it easy to test React components in the testing framework of your choice. At Facebook we use &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; for painless JavaScript testing. Learn how to get started with Jest through the Jest website&amp;rsquo;s &lt;a href=&quot;https://jestjs.io/docs/tutorial-react&quot;&gt;React Tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReactTestUtils&lt;/code&gt; 를 사용하면 선택한 테스트 프레임 워크에서 React 구성 요소를 쉽게 테스트 할 수 있습니다. Facebook에서는 고통없는 JavaScript 테스트를 위해 &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; 를 사용 합니다. Jest 웹 사이트의 &lt;a href=&quot;https://jestjs.io/docs/tutorial-react&quot;&gt;React Tutorial을&lt;/a&gt; 통해 Jest를 시작하는 방법에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="cd2b659f315e86293bf644a22ac16f387ac0277f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Simulate&lt;/code&gt; has a method for &lt;a href=&quot;events#supported-events&quot;&gt;every event that React understands&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Simulate&lt;/code&gt; 에는 &lt;a href=&quot;events#supported-events&quot;&gt;React가 이해하는 모든 이벤트에&lt;/a&gt; 대한 방법 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9b366d2fde5d1534fe678bffb7dc6cbc1913da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; currently helps with:</source>
          <target state="translated">&lt;code&gt;StrictMode&lt;/code&gt; 는 현재 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="85b45b72193b0a444ab87433ca3e645c1e2c176e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; is a tool for highlighting potential problems in an application. Like &lt;code&gt;Fragment&lt;/code&gt;, &lt;code&gt;StrictMode&lt;/code&gt; does not render any visible UI. It activates additional checks and warnings for its descendants.</source>
          <target state="translated">&lt;code&gt;StrictMode&lt;/code&gt; 는 응용 프로그램의 잠재적 문제를 강조하기위한 도구입니다. 마찬가지로 &lt;code&gt;Fragment&lt;/code&gt; , &lt;code&gt;StrictMode&lt;/code&gt; 는 눈에 보이는 UI를 렌더링하지 않습니다. 하위 항목에 대한 추가 확인 및 경고를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="69072622222cfc87d353eb0706836314f01d7e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render, showing a fallback while waiting.</source>
          <target state="translated">&lt;code&gt;Suspense&lt;/code&gt; 를 사용하면 구성 요소가 렌더링하기 전에 무언가를 &quot;대기&quot;하여 대기하는 동안 폴 백이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2f13097fb272439581958cc937f5a594b5ae6f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; takes two props:</source>
          <target state="translated">&lt;code&gt;Suspense&lt;/code&gt; 에는 두 가지 소품이 있습니다.</target>
        </trans-unit>
        <trans-unit id="18b3b188f6719c719354021035ef95073139c0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; helps coordinate many components that can suspend by orchestrating the order in which these components are revealed to the user.</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; 는 이러한 구성 요소가 사용자에게 표시되는 순서를 조정하여 일시 중단 할 수있는 많은 구성 요소를 조정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdc3ef578f32bfcee8d8a256db89f9b702e93d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; takes two props:</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; 에는 두 가지 소품이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2909efd08bf4d421275bca9913266c684a9919bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt; is invoked just before mounting occurs. It is called before &lt;code&gt;render()&lt;/code&gt;, therefore calling &lt;code&gt;setState()&lt;/code&gt; synchronously in this method will not trigger an extra rendering. Generally, we recommend using the &lt;code&gt;constructor()&lt;/code&gt; instead for initializing state.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt; 는 마운트 직전에 호출됩니다. &lt;code&gt;render()&lt;/code&gt; 전에 호출 &lt;code&gt;setState()&lt;/code&gt; 메소드에서 setState ()를 동 기적으로 호출 하면 추가 렌더링이 트리거되지 않습니다. 일반적으로 state를 초기화하기 위해 &lt;code&gt;constructor()&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d6fac26e669294deda8052265a59dbbd3e0d2d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; is invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;nextProps&lt;/code&gt; and perform state transitions using &lt;code&gt;this.setState()&lt;/code&gt; in this method.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 는 마운트 된 구성 요소가 새 소품을 수신하기 전에 호출됩니다. prop 변경에 응답하여 상태를 업데이트해야하는 경우 (예 : 재설정) &lt;code&gt;this.props&lt;/code&gt; 및 &lt;code&gt;nextProps&lt;/code&gt; 를 비교 하고이 메소드에서 &lt;code&gt;this.setState()&lt;/code&gt; 를 사용하여 상태 전이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24708bd58e5d92536bc16cf465af7ca7d3258012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; is invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 는 새로운 props 또는 state가 수신 될 때 렌더링 직전에 호출됩니다. 이것을 업데이트하기 전에 준비를 수행 할 수있는 기회로 사용하십시오. 이 메소드는 초기 렌더링에는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9053039459a28cc028d2bd242aa4a8da6683d06b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 가 false를 리턴 하면 &lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3db107fda1b4fb89320d3e59daead35226448eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_.debounce&lt;/code&gt;, &lt;code&gt;_.throttle&lt;/code&gt; and &lt;code&gt;raf-schd&lt;/code&gt; provide a &lt;code&gt;cancel&lt;/code&gt; method to cancel delayed callbacks. You should either call this method from &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; check to ensure that the component is still mounted within the delayed function.</source>
          <target state="translated">&lt;code&gt;_.debounce&lt;/code&gt; , &lt;code&gt;_.throttle&lt;/code&gt; 및 &lt;code&gt;raf-schd&lt;/code&gt; 는 지연된 콜백을 취소 하는 &lt;code&gt;cancel&lt;/code&gt; 방법을 제공합니다 . &lt;code&gt;componentWillUnmount&lt;/code&gt; 에서이 메소드를 호출 &lt;em&gt;하거나&lt;/em&gt; 구성 요소가 여전히 지연된 함수 내에 마운트되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b02b4a29b18cb40844cb7baeef47a37a699a301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collapsed&lt;/code&gt; shows only the next fallback in the list.</source>
          <target state="translated">&lt;code&gt;collapsed&lt;/code&gt; 는 목록에서 다음 폴 백만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9fa3bf49a9ddfa68a52bb154390b6f8a8c59db92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch()&lt;/code&gt; is called during the &amp;ldquo;commit&amp;rdquo; phase, so side-effects are permitted. It should be used for things like logging errors:</source>
          <target state="translated">&lt;code&gt;componentDidCatch()&lt;/code&gt; &quot;commit&quot;단계에서 componentDidCatch () 가 호출되므로 부작용이 허용됩니다. 로깅 오류와 같은 것들에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5902bc84c401394fad8d18dcfdf9467b9ed46981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch&lt;/code&gt; and &lt;code&gt;getDerivedStateFromError&lt;/code&gt;: There are no Hook equivalents for these methods yet, but they will be added soon.</source>
          <target state="translated">&lt;code&gt;componentDidCatch&lt;/code&gt; 및 &lt;code&gt;getDerivedStateFromError&lt;/code&gt; :이 메소드에 해당하는 후크는 아직 없지만 곧 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f9026acf47b96f019c2e814ca4ee8b05ee56c356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount()&lt;/code&gt; is invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.</source>
          <target state="translated">&lt;code&gt;componentDidMount()&lt;/code&gt; 는 컴포넌트가 마운트 된 직후 (트리에 삽입 ) 호출됩니다. DOM 노드가 필요한 초기화는 여기로 가야합니다. 원격 엔드 포인트에서 데이터를로드해야하는 경우 네트워크 요청을 인스턴스화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8013ba07d24f78b57a23033656a37bdb683b608c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, &lt;code&gt;componentWillUnmount&lt;/code&gt;: The &lt;a href=&quot;hooks-reference#useeffect&quot;&gt;&lt;code&gt;useEffect&lt;/code&gt; Hook&lt;/a&gt; can express all combinations of these (including &lt;a href=&quot;#can-i-skip-an-effect-on-updates&quot;&gt;less&lt;/a&gt;&lt;a href=&quot;#can-i-run-an-effect-only-on-updates&quot;&gt;common&lt;/a&gt; cases).</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; , &lt;code&gt;componentDidUpdate&lt;/code&gt; , &lt;code&gt;componentWillUnmount&lt;/code&gt; 다음 &lt;a href=&quot;hooks-reference#useeffect&quot;&gt; &lt;code&gt;useEffect&lt;/code&gt; 의 후크&lt;/a&gt; (를 포함하여 모든 이들의 조합을 표현할 수있는 &lt;a href=&quot;#can-i-skip-an-effect-on-updates&quot;&gt;덜 &lt;/a&gt;&lt;a href=&quot;#can-i-run-an-effect-only-on-updates&quot;&gt;일반적인&lt;/a&gt; 사례).</target>
        </trans-unit>
        <trans-unit id="2e953f1e280950f4dff6ff23d43d803da07aae1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; is invoked immediately after updating occurs. This method is not called for the initial render.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate()&lt;/code&gt; 는 업데이트가 발생한 직후에 호출됩니다. 이 메소드는 초기 렌더링에는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f1021b8fbfb1f2dfff035033fe2ef06292f3a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate()&lt;/code&gt; 경우 호출되지 않습니다 &lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0b6a217fa03e2afc4c419430cc58c93197eef2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillMount&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillMount&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillMount&lt;/code&gt; (또는 &lt;code&gt;UNSAFE_componentWillMount&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7468a85c1a852ccb4f5225df141dbe0cd5ab4dd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillReceiveProps&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillReceiveProps&lt;/code&gt; (또는 &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a0c01ec29848b94c784bbae7ff49b6a351fedc4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUnmount()&lt;/code&gt; is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in &lt;code&gt;componentDidMount()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;componentWillUnmount()&lt;/code&gt; 는 구성 요소를 마운트 해제하고 제거하기 직전에 호출됩니다. 타이머 무효화, 네트워크 요청 취소 또는 &lt;code&gt;componentDidMount()&lt;/code&gt; 에서 작성된 구독 정리와 같이이 메소드에서 필요한 정리를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e47f2b0f2fa0b85ff172c0843f6c6150e121e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUpdate&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillUpdate&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillUpdate&lt;/code&gt; (또는 &lt;code&gt;UNSAFE_componentWillUpdate&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aefd85a43dcaec0da5d78e959fcc0b9a9aa260a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constructor&lt;/code&gt;: Function components don&amp;rsquo;t need a constructor. You can initialize the state in the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; call. If computing the initial state is expensive, you can pass a function to &lt;code&gt;useState&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; : 함수 구성 요소에는 생성자가 필요하지 않습니다. &lt;a href=&quot;hooks-reference#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt; 호출 에서 상태를 초기화 할 수 있습니다 . 초기 상태를 계산하는 것이 &lt;code&gt;useState&lt;/code&gt; 함수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45deb296fef4519fcc0542b074d18d944e4180d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; is React&amp;rsquo;s replacement for using &lt;code&gt;innerHTML&lt;/code&gt; in the browser DOM. In general, setting HTML from code is risky because it&amp;rsquo;s easy to inadvertently expose your users to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;cross-site scripting (XSS)&lt;/a&gt; attack. So, you can set HTML directly from React, but you have to type out &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; and pass an object with a &lt;code&gt;__html&lt;/code&gt; key, to remind yourself that it&amp;rsquo;s dangerous. For example:</source>
          <target state="translated">&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 은 브라우저 DOM에서 &lt;code&gt;innerHTML&lt;/code&gt; 을 사용하는 React의 대체품입니다 . 일반적으로 코드에서 HTML을 설정하면 사용자가 실수로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS (Cross-Site Scripting)&lt;/a&gt; 공격에 노출되기 때문에 위험 합니다. 따라서 React에서 직접 HTML을 설정할 수는 있지만, &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 것을 상기시키기 위해 dangerouslySetInnerHTML 을 입력하고 &lt;code&gt;__html&lt;/code&gt; 키로 객체를 전달해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="430c1db279092a6ceec141825e72881e9801f973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultProps&lt;/code&gt; can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props. For example:</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 는 컴포넌트 클래스 자체의 특성으로 정의되어 클래스의 기본 소품을 설정할 수 있습니다. 이것은 정의되지 않은 prop에 사용되지만 null prop에는 사용되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="baaec778616719a973e43c85a2f93b67ab0ec035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; - The error that was thrown.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; - 발생 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="4a29285db43f7e7b976068b67906d8783d2803d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; are valid children. They simply don&amp;rsquo;t render. These JSX expressions will all render to the same thing:</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 는 유효한 자식입니다. 그들은 단순히 렌더링하지 않습니다. 이 JSX 표현식은 모두 같은 것으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="4bc0689b7d39b7f885a456fa37204e2e07d66eaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; can also be used on class components but this was breaking abstraction levels by allowing a parent to demand that certain children was rendered. It creates a refactoring hazard where you can&amp;rsquo;t change the implementation details of a component because a parent might be reaching into its DOM node. &lt;code&gt;findDOMNode&lt;/code&gt; only returns the first child, but with the use of Fragments, it is possible for a component to render multiple DOM nodes. &lt;code&gt;findDOMNode&lt;/code&gt; is a one time read API. It only gave you an answer when you asked for it. If a child component renders a different node, there is no way to handle this change. Therefore &lt;code&gt;findDOMNode&lt;/code&gt; only worked if components always return a single DOM node that never changes.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 는 클래스 구성 요소에서도 사용할 수 있지만 부모가 특정 자식을 렌더링하도록 요구함으로써 추상화 수준을 깨뜨리고있었습니다. 부모가 DOM 노드에 도달했을 수 있으므로 구성 요소의 구현 세부 정보를 변경할 수없는 리팩토링 위험이 발생합니다. &lt;code&gt;findDOMNode&lt;/code&gt; 는 첫 번째 하위 만 리턴하지만 Fragments를 사용하면 컴포넌트가 여러 DOM 노드를 렌더링 할 수 있습니다. &lt;code&gt;findDOMNode&lt;/code&gt; 는 일회성 읽기 API입니다. 당신이 그것을 요청할 때만 당신에게 대답을 주었다. 자식 구성 요소가 다른 노드를 렌더링하는 경우이 변경을 처리 할 방법이 없습니다. 따라서 구성 요소가 항상 변경되지 않는 단일 DOM 노드를 반환하는 경우에만 &lt;code&gt;findDOMNode&lt;/code&gt; 가 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="7c18ed32176ecaf70319c68a1b1509b378bab1d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; cannot be used on function components.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 는 기능 구성 요소에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="31959247d4b241bc62fdc356b0b41fcb230a4ce0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; is an escape hatch used to access the underlying DOM node. In most cases, use of this escape hatch is discouraged because it pierces the component abstraction. &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;It has been deprecated in &lt;code&gt;StrictMode&lt;/code&gt;.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 는 기본 DOM 노드에 액세스하는 데 사용되는 이스케이프 해치입니다. 대부분의 경우이 탈출 해치는 구성 요소 추상화를 뚫기 때문에 사용하지 않는 것이 좋습니다. &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt; &lt;code&gt;StrictMode&lt;/code&gt; &lt;/a&gt; 에서 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ad0438abf0344830b83e67adfda87c9220640615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling &lt;code&gt;findDOMNode()&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt; on a component that has yet to be created) an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 는 마운트 된 구성 요소 (DOM에 배치 된 구성 요소)에서만 작동합니다. 아직 마운트되지 않은 컴포넌트 (이미 작성되지 않은 컴포넌트의 &lt;code&gt;render()&lt;/code&gt; 에서 &lt;code&gt;findDOMNode()&lt;/code&gt; 호출 ) 에서이를 호출 하려고 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="510bd08ba17ba9f9ccbd8c7c0709f1c0cd79ad6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromError()&lt;/code&gt; is called during the &amp;ldquo;render&amp;rdquo; phase, so side-effects are not permitted. For those use cases, use &lt;code&gt;componentDidCatch()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromError()&lt;/code&gt; &quot;렌더링&quot;단계에서 getDerivedStateFromError () 가 호출되므로 부작용이 허용되지 않습니다. 이러한 사용 사례에서는 &lt;code&gt;componentDidCatch()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="910e1f30e33802fcc6bf71e017f3abfa8bddc166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 는 초기 마운트 및 후속 업데이트 모두에서 render 메소드를 호출하기 직전에 호출됩니다. 상태를 업데이트하려면 객체를 반환하고 아무것도 업데이트하지 않으려면 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15a7ee6f8147159dabadfc4df519d03042e8b215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt;: Schedule an update &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;while rendering&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; : 대신 &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;렌더링&lt;/a&gt; 하는 동안 업데이트 를 예약하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fee8f10f7ad4d0d11f67d09d125311a4fc53fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle will be passed as a parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; 는 가장 최근에 렌더링 된 출력이 DOM과 같은 커밋되기 직전에 호출됩니다. 구성 요소가 잠재적으로 변경되기 전에 DOM에서 일부 정보 (예 : 스크롤 위치)를 캡처 할 수 있습니다. 이 수명주기에 의해 반환 된 값은 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 매개 변수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb01ea8f67b656757e4c3ff85c79d0e4a1e35264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hidden&lt;/code&gt; doesn&amp;rsquo;t show any unloaded items.</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 은 언로드 된 항목을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31610744ea2dac7d5f0f6319b25a18fe35b35153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops are not expressions in JavaScript, so they can&amp;rsquo;t be used in JSX directly. Instead, you can put these in the surrounding code. For example:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문과 &lt;code&gt;for&lt;/code&gt; 루프는 JavaScript에서 표현식이 아니므로 JSX에서 직접 사용할 수 없습니다. 대신,이를 주변 코드에 넣을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fce6bd3f9452511f9ae589ccbb20dfb78385fba7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;info&lt;/code&gt; - An object with a &lt;code&gt;componentStack&lt;/code&gt; key containing &lt;a href=&quot;error-boundaries#component-stack-traces&quot;&gt;information about which component threw the error&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; - A의 객체 &lt;code&gt;componentStack&lt;/code&gt; 에 포함 된 키 &lt;a href=&quot;error-boundaries#component-stack-traces&quot;&gt;오류 줬어요 구성 요소에 대한 정보&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1551fdcffd2297ae4cbb5750a781ab5971e41725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React telling us whether that transition is ongoing at the moment.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; 은 부울입니다. 현재 전환이 진행 중인지 여부를 알려주는 것이 React입니다.</target>
        </trans-unit>
        <trans-unit id="7456c23ecf41341dc15c4ef99e0dd0c03049a234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React&amp;rsquo;s way of informing us whether we&amp;rsquo;re waiting for the transition to finish.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; 은 부울입니다. 전환이 끝나기를 기다리고 있는지 알려주는 React의 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1fede57a744a8aa811decdcac1eaedf9d4039297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; is the only attribute that can be passed to &lt;code&gt;Fragment&lt;/code&gt;. In the future, we may add support for additional attributes, such as event handlers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 는 &lt;code&gt;Fragment&lt;/code&gt; 에 전달할 수있는 유일한 속성입니다 . 앞으로는 이벤트 핸들러와 같은 추가 속성에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc74e733d90a9b1105f5a84d7df17789075e7de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockComponent()&lt;/code&gt; is a legacy API. We recommend using &lt;a href=&quot;https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;mockComponent()&lt;/code&gt; 는 레거시 API입니다. 대신 &lt;a href=&quot;https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7a00f6e0c85948cf8b75fbf2486fb9d35f5ecb1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;npx&lt;/code&gt; 는 오타가 아닙니다 . &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;npm 5.2+와 함께 제공&lt;/a&gt; 되는 패키지 러너 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="4bb448c06ef207192f6960e58083b2f60ad706ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; on the first line is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;npx&lt;/code&gt; 첫 번째 줄의 npx 는 오타가 아닙니다 . &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;npm 5.2+와 함께 제공&lt;/a&gt; 되는 패키지 러너 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="b629a67eb08da14b4cfec6bc10dfa3539aec592a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onRender&lt;/code&gt; Callback</source>
          <target state="translated">&lt;code&gt;onRender&lt;/code&gt; 콜백</target>
        </trans-unit>
        <trans-unit id="e6833d94c5fdd052aae681c7af8babb363ae7dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props.children&lt;/code&gt; is available on every component. It contains the content between the opening and closing tags of a component. For example:</source>
          <target state="translated">&lt;code&gt;props.children&lt;/code&gt; 은 모든 구성 요소에서 사용할 수 있습니다. 구성 요소의 여는 태그와 닫는 태그 사이의 내용을 포함합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3a6d4bfe3d0a553f9a325a8d8d7895eb240fba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; are inputs to a React component. They are data passed down from a parent component to a child component.</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 는 React 컴포넌트에 대한 입력입니다. 부모 구성 요소에서 자식 구성 요소로 전달되는 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="e8276da0d1612607c2cc59c2ee7061fdd95306d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-dom&lt;/code&gt; 16.5+ and &lt;code&gt;react-native&lt;/code&gt; 0.57+ provide enhanced profiling capabilities in DEV mode with the React DevTools Profiler. An overview of the Profiler can be found in the blog post &lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;&amp;ldquo;Introducing the React Profiler&amp;rdquo;&lt;/a&gt;. A video walkthrough of the profiler is also &lt;a href=&quot;https://www.youtube.com/watch?v=nySib7ipZdk&quot;&gt;available on YouTube&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;react-dom&lt;/code&gt; 16.5+ 및 &lt;code&gt;react-native&lt;/code&gt; 0.57+는 React DevTools Profiler를 사용하여 DEV 모드에서 향상된 프로파일 링 기능을 제공합니다. 프로파일 러에 대한 개요는 블로그 게시물 &lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;&quot;React Profiler 소개&quot;&lt;/a&gt; 에서 찾을 수 있습니다 . 프로파일 러의 비디오 연습은 &lt;a href=&quot;https://www.youtube.com/watch?v=nySib7ipZdk&quot;&gt;YouTube&lt;/a&gt; 에서도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f2a0dc772da5e7cdc0f38957f9993d3616b5a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; &lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; 가 false를 리턴 하면 render () 가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f4f56d7302d0967a7240bb18080cef54c794107" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: This is the function component body itself.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; : 함수 구성 요소 본체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="d50d17a24cb4b08149dc01cd820c7781be44969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling</source>
          <target state="translated">&lt;code&gt;requestAnimationFrame&lt;/code&gt; 조절</target>
        </trans-unit>
        <trans-unit id="c25ec040456e9920edfe2988e28f1b81d3beb06c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; does not always immediately update the component. It may batch or defer the update until later. This makes reading &lt;code&gt;this.state&lt;/code&gt; right after calling &lt;code&gt;setState()&lt;/code&gt; a potential pitfall. Instead, use &lt;code&gt;componentDidUpdate&lt;/code&gt; or a &lt;code&gt;setState&lt;/code&gt; callback (&lt;code&gt;setState(updater, callback)&lt;/code&gt;), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the &lt;code&gt;updater&lt;/code&gt; argument below.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 가 항상 컴포넌트를 즉시 업데이트하지는 않습니다. 나중에 업데이트를 일괄 처리하거나 연기 할 수 있습니다. 이것은 &lt;code&gt;setState()&lt;/code&gt; 를 잠재적 함정으로 호출 한 직후 &lt;code&gt;this.state&lt;/code&gt; 를 읽습니다 . 대신 &lt;code&gt;componentDidUpdate&lt;/code&gt; 또는 &lt;code&gt;setState&lt;/code&gt; 콜백 ( &lt;code&gt;setState(updater, callback)&lt;/code&gt; )을 사용하십시오. 업데이트는 적용된 후에 실행됩니다. 이전 상태를 기반으로 상태를 설정해야하는 경우 아래 의 &lt;code&gt;updater&lt;/code&gt; 인수 에 대해 읽으 십시오.</target>
        </trans-unit>
        <trans-unit id="890278a6f325117472c160479b342fb7dd806205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 변경 사항을 구성 요소 상태로 대기열에 넣고이 구성 요소와 해당 자식을 업데이트 된 상태로 다시 렌더링해야한다고 React에 알립니다. 이벤트 핸들러 및 서버 응답에 대한 응답으로 사용자 인터페이스를 업데이트하는 데 사용하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="49f4ea7b18a07d4971cdabfc70d9ff5a0f5cfb0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; schedules an update to a component&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; object. When state changes, the component responds by re-rendering.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 는 구성 요소의 &lt;code&gt;state&lt;/code&gt; 객체에 대한 업데이트를 예약 합니다. 상태가 변경되면 컴포넌트는 다시 렌더링하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="78edf8a5be7cd4938da4a8930c26b921ca6ea710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; will always lead to a re-render unless &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If mutable objects are being used and conditional rendering logic cannot be implemented in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;, calling &lt;code&gt;setState()&lt;/code&gt; only when the new state differs from the previous state will avoid unnecessary re-renders.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 돌려 주지 않는 한, setState () 는 항상 다시 렌더링 합니다 . 가변 객체를 사용하고 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 에서 조건부 렌더링 로직을 구현할 수없는 경우 새 상태가 이전 상태와 다른 경우에만 &lt;code&gt;setState()&lt;/code&gt; 호출 하면 불필요한 다시 렌더링을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd73fd61fb3b7bdbb5b066ca0f0dac0e6ba13ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState&lt;/code&gt; updater functions (the first argument)</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 업데이터 함수 (첫 번째 인수)</target>
        </trans-unit>
        <trans-unit id="a68a2611b9905d44a6f35aa9f1a6cfae46d103e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shallowRenderer.render()&lt;/code&gt; is similar to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; but it doesn&amp;rsquo;t require DOM and only renders a single level deep. This means you can test components isolated from how their children are implemented.</source>
          <target state="translated">&lt;code&gt;shallowRenderer.render()&lt;/code&gt; 와 유사하다 &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; 하지만 DOM을 필요로 만 깊은 하나의 레벨을 렌더링하지 않습니다. 즉, 하위 구현 방식과 분리 된 구성 요소를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d56fb96a210704f6b7e526afe89f7d4ad2516a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; is invoked before rendering when new props or state are being received. Defaults to &lt;code&gt;true&lt;/code&gt;. This method is not called for the initial render or when &lt;code&gt;forceUpdate()&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 새 props 또는 상태가 수신 될 때 렌더링 전에 shouldComponentUpdate () 가 호출됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 이 메소드는 초기 렌더링 또는 &lt;code&gt;forceUpdate()&lt;/code&gt; 사용시 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="814748f3c2c1758f2ff0aca465c42a2dc55dcfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt;: See &lt;code&gt;React.memo&lt;/code&gt;&lt;a href=&quot;#how-do-i-implement-shouldcomponentupdate&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; : 참조 &lt;code&gt;React.memo&lt;/code&gt; &lt;a href=&quot;#how-do-i-implement-shouldcomponentupdate&quot;&gt;아래&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66bddd2497b3b200c22e5281d6e552a7e20a6da9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function that takes a callback. We can use it to tell React which state we want to defer.</source>
          <target state="translated">&lt;code&gt;startTransition&lt;/code&gt; 은 콜백을 수행하는 함수입니다. 이것을 사용하여 React에게 우리가 연기하고 싶은 상태를 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34051d51bc03f3b73ca1f25cdb8ab0dda54436eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function. We&amp;rsquo;ll use it to tell React &lt;em&gt;which&lt;/em&gt; state update we want to defer.</source>
          <target state="translated">&lt;code&gt;startTransition&lt;/code&gt; 은 함수입니다. 우리는 이것을 사용하여 React에게 &lt;em&gt;어떤&lt;/em&gt; 상태 업데이트를 연기하고 있는지 알려줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7e8ddfb17b43b6d22d0295ba402dabbf671d09bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;. For instance, suppose we wanted to increment a value in state by &lt;code&gt;props.step&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 는 변경 사항이 적용되는 시점의 구성 요소 상태에 대한 참조입니다. 직접 돌연변이해서는 안됩니다. 대신 &lt;code&gt;state&lt;/code&gt; 와 &lt;code&gt;props&lt;/code&gt; 의 입력을 기반으로 새 객체를 작성하여 변경 사항을 표현해야합니다 . 예를 들어 &lt;code&gt;props.step&lt;/code&gt; 으로 상태의 값을 늘리고 싶다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="f536549f1bb22cb3c08a39e8b050827fd1a8b128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props&lt;/code&gt; contains the props that were defined by the caller of this component. See &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt; for an introduction to props.</source>
          <target state="translated">&lt;code&gt;this.props&lt;/code&gt; 는이 컴포넌트의 호출자가 정의한 prop을 포함합니다. &lt;a href=&quot;components-and-props&quot;&gt;소품&lt;/a&gt; 에 대한 소개는 구성 요소 및 소품 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a63898df1efb2729c524b163f95229e38f97f586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;together&lt;/code&gt; reveals &lt;em&gt;all&lt;/em&gt; of them when they&amp;rsquo;re ready instead of one by one.</source>
          <target state="translated">&lt;code&gt;together&lt;/code&gt; 준비하는 것이 아니라 &lt;em&gt;모두&lt;/em&gt; 를 공개 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1505b4fe4f872f374d4ceb82f8e0d44ecbce73a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; is great but it only works for imperative code:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 는 훌륭하지만 명령 코드에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="042cebd03ee57a7edf6c149d64815a55aa39ccbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateColorMap&lt;/code&gt; now returns a new object, rather than mutating the old one. &lt;code&gt;Object.assign&lt;/code&gt; is in ES6 and requires a polyfill.</source>
          <target state="translated">&lt;code&gt;updateColorMap&lt;/code&gt; 은 이제 이전 오브젝트를 변경하지 않고 새 오브젝트를 리턴합니다. &lt;code&gt;Object.assign&lt;/code&gt; 은 ES6에 있으며 폴리 필이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="667e5f15380b289f60e9fc5beed758d4b2d95df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; is equivalent to &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; 은 &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b729b36b0c56e0724013363ba045f69a97ca22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useContext(MyContext)&lt;/code&gt; only lets you &lt;em&gt;read&lt;/em&gt; the context and subscribe to its changes. You still need a &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above in the tree to &lt;em&gt;provide&lt;/em&gt; the value for this context.</source>
          <target state="translated">&lt;code&gt;useContext(MyContext)&lt;/code&gt; 사용하면 컨텍스트 를 &lt;em&gt;읽고&lt;/em&gt; 해당 변경 사항을 구독 할 수 있습니다 . 이 컨텍스트에 대한 값 을 &lt;em&gt;제공&lt;/em&gt; 하려면 트리에서 여전히 위 의 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 가 필요합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b0ce9627a3e8428d2ed75cf429dda0b5cf0efc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDebugValue&lt;/code&gt; can be used to display a label for custom hooks in React DevTools.</source>
          <target state="translated">&lt;code&gt;useDebugValue&lt;/code&gt; 를 사용하여 React DevTools에서 사용자 정의 후크에 대한 레이블을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f01ff030e160362e003ee4592bd149e10adf2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDeferredValue&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long the deferred value is allowed to lag behind.</source>
          <target state="translated">&lt;code&gt;useDeferredValue&lt;/code&gt; 는 허용 &lt;strong&gt;옵션 서스펜스 구성을&lt;/strong&gt; 와 &lt;code&gt;timeoutMs&lt;/code&gt; . 이 시간 초과 (밀리 초)는 지연된 값이 얼마나 오래 지연 될 수 있는지 React에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cd43fc126f648e879919e1de0da7c29467f3009f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useImperativeHandle&lt;/code&gt; customizes the instance value that is exposed to parent components when using &lt;code&gt;ref&lt;/code&gt;. As always, imperative code using refs should be avoided in most cases. &lt;code&gt;useImperativeHandle&lt;/code&gt; should be used with &lt;code&gt;forwardRef&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;useImperativeHandle&lt;/code&gt; 은 &lt;code&gt;ref&lt;/code&gt; 사용시 상위 컴포넌트에 노출되는 인스턴스 값을 사용자 정의합니다 . 항상 그렇듯이 ref를 사용하는 명령형 코드는 대부분 피해야합니다. &lt;code&gt;useImperativeHandle&lt;/code&gt; 은 forwardRef 와 함께 &lt;code&gt;forwardRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c75640695dabcf32a2fdcd720b4d4ec21abee912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useMemo&lt;/code&gt; lets you &lt;a href=&quot;#how-to-memoize-calculations&quot;&gt;memoize an expensive calculation&lt;/a&gt; if the dependencies are the same. However, it only serves as a hint, and doesn&amp;rsquo;t &lt;em&gt;guarantee&lt;/em&gt; the computation won&amp;rsquo;t re-run. But sometimes you need to be sure an object is only created once.</source>
          <target state="translated">&lt;code&gt;useMemo&lt;/code&gt; 의존성이 동일한 경우 useMemo를 사용하면 &lt;a href=&quot;#how-to-memoize-calculations&quot;&gt;비싼 계산을 &lt;/a&gt;기억할 수 있습니다 . 그러나 그것은 단지 힌트 역할을하지 않는 &lt;em&gt;보장&lt;/em&gt; 계산이 다시 실행되지 않습니다. 그러나 때로는 객체가 한 번만 생성되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="e21395d3ffac3dda05d22d2fc2a8cc5403f396bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useReducer&lt;/code&gt; is usually preferable to &lt;code&gt;useState&lt;/code&gt; when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. &lt;code&gt;useReducer&lt;/code&gt; also lets you optimize performance for components that trigger deep updates because &lt;a href=&quot;hooks-faq#how-to-avoid-passing-callbacks-down&quot;&gt;you can pass &lt;code&gt;dispatch&lt;/code&gt; down instead of callbacks&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;useReducer&lt;/code&gt; 는 일반적으로 여러 하위 값을 포함하는 복잡한 상태 논리가 있거나 다음 상태가 이전 상태에 종속되는 경우 &lt;code&gt;useState&lt;/code&gt; 보다 선호됩니다 . 또한 &lt;code&gt;useReducer&lt;/code&gt; 를 사용하면 &lt;a href=&quot;hooks-faq#how-to-avoid-passing-callbacks-down&quot;&gt;콜백 대신 &lt;/a&gt; &lt;code&gt;dispatch&lt;/code&gt; 를 전달할 수 있으므로 딥 업데이트를 트리거하는 구성 요소의 성능을 최적화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a6f646cfddeee6391c8a8ad43840ba9e4d83e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt; returns a mutable ref object whose &lt;code&gt;.current&lt;/code&gt; property is initialized to the passed argument (&lt;code&gt;initialValue&lt;/code&gt;). The returned object will persist for the full lifetime of the component.</source>
          <target state="translated">&lt;code&gt;useRef&lt;/code&gt; 는 &lt;code&gt;.current&lt;/code&gt; 속성이 전달 된 인수 ( &lt;code&gt;initialValue&lt;/code&gt; )로 초기화 된 가변 참조 객체를 반환합니다 . 반환 된 객체는 구성 요소의 전체 수명 동안 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="d05a76668c8cfeec08e22711a9f90eaf01569527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt;&lt;strong&gt;does not&lt;/strong&gt; accept a special function overload like &lt;code&gt;useState&lt;/code&gt;. Instead, you can write your own function that creates and sets it lazily:</source>
          <target state="translated">&lt;code&gt;useRef&lt;/code&gt; 은&lt;strong&gt;하지 않습니다&lt;/strong&gt; 같은 특수 기능 과부하 동의 &lt;code&gt;useState&lt;/code&gt; 을 . 대신, 느리게 작성하고 설정하는 고유 한 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d4904731beb3c9febbd66670ff49cd7239a70c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long to wait before showing the next state (the new Profile Page in the above example).</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 는 허용 &lt;strong&gt;옵션 서스펜스 구성을&lt;/strong&gt; 와 &lt;code&gt;timeoutMs&lt;/code&gt; . 이 시간 초과 (밀리 초)는 다음 상태 (위의 예에서 새 프로필 페이지)를 표시하기 전에 대기 시간을 React에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c39bc8d81d24ae97c5c3b83282412fd1cb3865a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; allows components to avoid undesirable loading states by waiting for content to load before &lt;strong&gt;transitioning to the next screen&lt;/strong&gt;. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 을 사용하면 구성 요소가 &lt;strong&gt;다음 화면으로 전환하기&lt;/strong&gt; 전에 내용이로드 될 때까지 대기함으로써 원하지 않는 로딩 상태를 피할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 또한 구성 요소가 후속 렌더링까지 더 느린 데이터 페치 업데이트를 지연시켜보다 중요한 업데이트를 즉시 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d33ad06c93f0f029735d7bb14e5c7b373077b091" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class.</source>
          <target state="translated">&lt;em&gt;후크&lt;/em&gt; 는 React 16.8의 새로운 추가 기능입니다. 클래스를 작성하지 않고도 상태 및 기타 React 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace15fac5994029e1bcc72e771948fe804db95ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class. Hooks have a &lt;a href=&quot;hooks-intro&quot;&gt;dedicated docs section&lt;/a&gt; and a separate API reference:</source>
          <target state="translated">&lt;em&gt;후크&lt;/em&gt; 는 React 16.8의 새로운 추가 기능입니다. 클래스를 작성하지 않고도 상태 및 기타 React 기능을 사용할 수 있습니다. 후크에는 &lt;a href=&quot;hooks-intro&quot;&gt;전용 문서 섹션&lt;/a&gt; 과 별도의 API 참조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b83b7254bd7bfd5409460ac4494fa9808b9ebd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that this functionality is not a part of React, but provided by third-party libraries.&lt;/em&gt; React does not have an opinion about how styles are defined; if in doubt, a good starting point is to define your styles in a separate &lt;code&gt;*.css&lt;/code&gt; file as usual and refer to them using &lt;a href=&quot;dom-elements#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이 기능은 React의 일부가 아니라 타사 라이브러리에서 제공합니다. &lt;/em&gt;React는 스타일 정의 방법에 대한 의견이 없습니다. 확실하지 않은 경우 시작점은 평소와 같이 별도의 &lt;code&gt;*.css&lt;/code&gt; 파일에 스타일을 정의 하고 &lt;a href=&quot;dom-elements#classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; 을&lt;/a&gt; 사용하여 참조하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="828dff12c9f333e498d192f940f8b0eb28323123" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What?!&lt;/em&gt; If you break it apart, it&amp;rsquo;s easier to see what&amp;rsquo;s going on.</source>
          <target state="translated">&lt;em&gt;뭐?! &lt;/em&gt;분리하면 어떤 일이 일어나고 있는지 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ec2e59f42ad4113b0701443f929bb729a9f39b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;uarr;&amp;uarr;&amp;uarr; Each section ends with a yellow box like this.&lt;/strong&gt; They link to detailed explanations.</source>
          <target state="translated">&lt;strong&gt;&amp;uarr;&amp;uarr;&amp;uarr; 각 섹션은 이와 같은 노란색 상자로 끝납니다. &lt;/strong&gt;자세한 설명과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="6058bfb8c2501dc09f533cb2be1f11424e6fa6ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;100% backwards-compatible.&lt;/strong&gt; Hooks don&amp;rsquo;t contain any breaking changes.</source>
          <target state="translated">&lt;strong&gt;100 % 이전 버전과 호환됩니다. &lt;/strong&gt;후크에는 주요 변경 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d653e9534724609f30ed266eec251a4fe8bfbe5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#adoption-strategy&quot;&gt;Adoption Strategy&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#adoption-strategy&quot;&gt;채택 전략&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e1ea47830ec1b43539be85bbdbf82f2c6ee8e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#from-classes-to-hooks&quot;&gt;From Classes to Hooks&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#from-classes-to-hooks&quot;&gt;수업에서 후크까지&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b436fdc2511c163c3273395084964e4d03501da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#performance-optimizations&quot;&gt;Performance Optimizations&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#performance-optimizations&quot;&gt;성능 최적화&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c21e7807e574623dbbadef2f70311d29959382f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#under-the-hood&quot;&gt;Under the Hood&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#under-the-hood&quot;&gt;후드&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9eb654d35da7c6a936b5cf39e562ac926e13ca93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codepen.io/gaearon/pen/ozqNOV?editors=0010&quot;&gt;Try it on CodePen&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codepen.io/gaearon/pen/ozqNOV?editors=0010&quot;&gt;CodePen에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0595fbb3b923b63dd343c6c487f004d0dbfc3506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/adoring-goodall-8wbn7&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/adoring-goodall-8wbn7&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329decde42bb77dc0aae1fcec57bb050fb807cc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/black-wind-byilt&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/black-wind-byilt&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01b4eecff73da876324208868ee639fd6117e97d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f1a26535dcdb04c4f5421047cbda7504a77fef6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/brave-villani-ypxvf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/brave-villani-ypxvf&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8490c7804a31bef203e102c3ac25a6e48cba2d5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/condescending-shape-s6694&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/condescending-shape-s6694&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a98911496de2c11fb59ee0de57606b03b010d0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/currying-violet-5jsiy&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/currying-violet-5jsiy&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d744e65c52fc16ba9669af6e8d07aa1b1756282" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/floral-thunder-iy826&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/floral-thunder-iy826&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c8b1763e5fa89194b3eb2dc4597ac0861cc4ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/focused-mountain-uhkzg&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/focused-mountain-uhkzg&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c392c02183e5fbc5bbca731955b286f4e7976de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/fragrant-glade-8huj6&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/fragrant-glade-8huj6&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4941c0c6861dbc52540681ff425e2e53c977742" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f563e8f5edba2a989496a45b5a274a82553a5905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/gallant-spence-l6wbk&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/gallant-spence-l6wbk&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d2bea63b2bb76db4afe3cf5d2217f8cc9e9c79a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-dewdney-9fkv9&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-dewdney-9fkv9&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091eda1000749c6dfb3e82a144500745b0a90feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d14d74d223723c252aefae84799136180eddbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637995a9c0c8459f49104bf507f43701e9464ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/lively-smoke-fdf93&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/lively-smoke-fdf93&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e719ca37c04b81dbb27b7f6d477c89d07a7b725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/modest-ritchie-iufrh&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/modest-ritchie-iufrh&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aeecf2df582bbc41f958e939795d22ce6f082bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c5fe033d012b748ca1ec08d81aec177e6e64dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/nervous-glade-b5sel&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/nervous-glade-b5sel&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97e6f9b60d7ed92e746159eda59cd8f053370e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/pensive-shirley-wkp46&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/pensive-shirley-wkp46&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9c4c35182e0486398109c99693cb980f8a4320b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/proud-tree-exg5t&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/proud-tree-exg5t&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd41d12444d64b9f2867f260beeb8ea9b17e58af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/sleepy-field-mohzb&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/sleepy-field-mohzb&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a97ab6d64c40ba1724f28cf13f4e9399eeb97f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/trusting-clarke-8twuq&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/trusting-clarke-8twuq&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="075c6dbd104d3818936cfa43cc825d4a5758c0c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/vigorous-keller-3ed2b&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/vigorous-keller-3ed2b&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="232874044ef8bc2516d2563ef607a5f8d6242c42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/wandering-morning-ev6r0&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/wandering-morning-ev6r0&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b349e00ae7d86801b5b37e836ec25981964a4ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/zen-keldysh-rifos&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/zen-keldysh-rifos&quot;&gt;CodeSandbox에서 사용해보십시오&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58219f56881b30fdf5d4564dbe6229eab4fbbb3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;&lt;/strong&gt; is a JavaScript test runner that lets you access the DOM via &lt;a href=&quot;testing-environments#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;. While jsdom is only an approximation of how the browser works, it is often good enough for testing React components. Jest provides a great iteration speed combined with powerful features like mocking &lt;a href=&quot;testing-environments#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;testing-environments#mocking-timers&quot;&gt;timers&lt;/a&gt; so you can have more control over how the code executes.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;&lt;/strong&gt; 는&lt;a href=&quot;testing-environments#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; 을&lt;/a&gt; 통해 DOM에 액세스 할 수있는 JavaScript 테스트 러너입니다. jsdom은 브라우저 작동 방식에 대한 근사치 일 뿐이지 만 React 구성 요소를 테스트하기에 충분합니다. Jest는 모의&lt;a href=&quot;testing-environments#mocking-modules&quot;&gt; 모듈&lt;/a&gt; 및&lt;a href=&quot;testing-environments#mocking-timers&quot;&gt; 타이머&lt;/a&gt; 와같은 강력한 기능과 결합 된 뛰어난 반복 속도를 제공하므로 코드 실행 방법을보다효과적으로제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99a5e69cee64ce8afda69e9a00e86814ef1d876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605&quot;&gt;View the full example source code&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605&quot;&gt;전체 예제 소스 코드보기&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a908caf9cc6624102d1a77f24ae42e9bc9b21828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;전체 예제 다운로드 (2KB 압축)&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="993a7c72473bd27f839485ede4b2ce6e44dcbdfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;&lt;/strong&gt; - DefinitelyTyped is a huge repository of declarations for libraries that don&amp;rsquo;t bundle a declaration file. The declarations are crowd-sourced and managed by Microsoft and open source contributors. React for example doesn&amp;rsquo;t bundle its own declaration file. Instead we can get it from DefinitelyTyped. To do so enter this command in your terminal.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;&lt;/strong&gt; -DefinitelyTyped는 선언 파일을 번들로 제공하지 않는 라이브러리에 대한 거대한 선언 저장소입니다. 이 선언은 Microsoft 및 공개 소스 기고자들이 크라우드 소싱하고 관리합니다. 예를 들어 반응은 자체 선언 파일을 번들로 묶지 않습니다. 대신 DefinitelyTyped에서 가져올 수 있습니다. 그렇게하려면 터미널에이 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d3fd7d9bed7d33685c6833c223188f4224ff4def" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;Razzle&lt;/a&gt;&lt;/strong&gt; is a server-rendering framework that doesn&amp;rsquo;t require any configuration, but offers more flexibility than Next.js.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;Razzle&lt;/a&gt;&lt;/strong&gt; 은 서버 렌더링 프레임 워크로 구성이 필요하지 않지만 Next.js보다 유연성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="b56e9cf8532603158b73eeb2fc003ab13c7e9437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://neutrinojs.org/&quot;&gt;Neutrino&lt;/a&gt;&lt;/strong&gt; combines the power of &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; with the simplicity of presets, and includes a preset for &lt;a href=&quot;https://neutrinojs.org/packages/react/&quot;&gt;React apps&lt;/a&gt; and &lt;a href=&quot;https://neutrinojs.org/packages/react-components/&quot;&gt;React components&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://neutrinojs.org/&quot;&gt;Neutrino&lt;/a&gt;&lt;/strong&gt; 는&lt;a href=&quot;https://webpack.js.org/&quot;&gt; 웹팩&lt;/a&gt; 의 강력한 기능 과 사전 설정의 단순성을결합하고&lt;a href=&quot;https://neutrinojs.org/packages/react/&quot;&gt; React 앱&lt;/a&gt; 및&lt;a href=&quot;https://neutrinojs.org/packages/react-components/&quot;&gt; React 구성 요소에&lt;/a&gt; 대한 사전 설정을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="39c35e787c3cbc73032d50cb4528984ae519f235" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;&lt;/strong&gt; is a fast, zero configuration web application bundler that &lt;a href=&quot;https://parceljs.org/recipes.html#react&quot;&gt;works with React&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;&lt;/strong&gt; 은&lt;a href=&quot;https://parceljs.org/recipes.html#react&quot;&gt; React와 함께 작동&lt;/a&gt; 하는 빠른 제로 구성 웹 애플리케이션 번 들러입니다.</target>
        </trans-unit>
        <trans-unit id="d60d72c48cae6c4966b5f08f6b2a563b5217b568" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;&lt;/strong&gt; is a set of helpers that let you test React components without relying on their implementation details. This approach makes refactoring a breeze and also nudges you towards best practices for accessibility. Although it doesn&amp;rsquo;t provide a way to &amp;ldquo;shallowly&amp;rdquo; render a component without its children, a test runner like Jest lets you do this by &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;mocking&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;&lt;/strong&gt; 는 구현 세부 사항에 의존하지 않고 React 구성 요소를 테스트 할 수있는 헬퍼 세트입니다. 이 접근 방식은 리팩토링을 쉽게하고 접근성에 대한 모범 사례를 제공합니다. 자식없이 구성 요소를 &quot;얕게&quot;렌더링하는 방법을 제공하지는 않지만 Jest와 같은 테스트 실행기를 사용하면&lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt; mocking을&lt;/a&gt; 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2eefe2167a5535f7edb84693440268a866537b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterableProductTable&lt;/code&gt; (orange):&lt;/strong&gt; contains the entirety of the example</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FilterableProductTable&lt;/code&gt; (주황색) :&lt;/strong&gt; 예제 전체를 포함</target>
        </trans-unit>
        <trans-unit id="c6740581ede97860916dd8404f3c10005704058d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductCategoryRow&lt;/code&gt; (turquoise):&lt;/strong&gt; displays a heading for each &lt;em&gt;category&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductCategoryRow&lt;/code&gt; (청록색) :&lt;/strong&gt; 각&lt;em&gt; 범주에&lt;/em&gt; 대한 제목을 표시합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28e457034b9e3d496464cda366c118141b017a04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductRow&lt;/code&gt; (red):&lt;/strong&gt; displays a row for each &lt;em&gt;product&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductRow&lt;/code&gt; (빨간색) :&lt;/strong&gt; 각&lt;em&gt; 제품에&lt;/em&gt; 대한 행을 표시합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9b4f2e8e25a7232d34a52a0e7e3bc9a214dad62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductTable&lt;/code&gt; (green):&lt;/strong&gt; displays and filters the &lt;em&gt;data collection&lt;/em&gt; based on &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductTable&lt;/code&gt; (녹색) : &lt;/strong&gt;&lt;em&gt;사용자 입력을&lt;/em&gt; 기반으로&lt;em&gt; 데이터 수집을&lt;/em&gt; 표시하고 필터링합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2dabde044e0d7f4af6b8b8921b77160774ee57c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;SearchBar&lt;/code&gt; (blue):&lt;/strong&gt; receives all &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;SearchBar&lt;/code&gt; (파란색) :&lt;/strong&gt; 모든&lt;em&gt; 사용자 입력을&lt;/em&gt; 받습니다&lt;strong&gt; .&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d83cdff912b9e15f8b1e0d697a44e96c59fb175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;actualDuration: number&lt;/code&gt;&lt;/strong&gt; - Time spent rendering the &lt;code&gt;Profiler&lt;/code&gt; and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-faq#how-do-i-implement-shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;actualDuration: number&lt;/code&gt; &lt;/strong&gt; 현재 업데이트에 대한 &lt;code&gt;Profiler&lt;/code&gt; 및 해당 하위 항목을렌더링하는 데 소요 된 시간입니다. 이것은 서브 트리가 메모를 얼마나 잘 사용하는지 나타냅니다 (예 :&lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;hooks-reference#usememo&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;hooks-faq#how-do-i-implement-shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; &lt;/a&gt; ). 이상적으로는이 값이 초기 마운트 후에 크게 감소해야합니다. 많은 하위 항목은 특정 소품이 변경되는 경우에만 다시 렌더링해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c220a4c8bfdd12160e6afea8488b326d96cde385" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;baseDuration: number&lt;/code&gt;&lt;/strong&gt; - Duration of the most recent &lt;code&gt;render&lt;/code&gt; time for each individual component within the &lt;code&gt;Profiler&lt;/code&gt; tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;baseDuration: number&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;Profiler&lt;/code&gt; 트리내의 각 개별 구성 요소에 대한가장 최근의 &lt;code&gt;render&lt;/code&gt; 시간입니다. 이 값은 최악의 렌더링 비용을 추정합니다 (예 : 초기 마운트 또는 메모가없는 트리).</target>
        </trans-unit>
        <trans-unit id="97cccde8bcd492d0664a6e9b93ed149497f0ad18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;commitTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;commitTime: number&lt;/code&gt; &lt;/strong&gt; -React가 현재 업데이트를 커밋 한 타임 스탬프입니다. 이 값은 커밋의 모든 프로파일 러간에 공유되므로 원하는 경우 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f19be3985cb5babcd265822a9667d2170dee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a508f9a3232de158e10b1e3c1772259a5ac1977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8bbd97e3f4e32bd784498eb21c219e93b36c747" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aacf0222e59d57af4a111eb929c26406c66048aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c2e3b29217438c02bda61a9de8a154d47db8351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;id: string&lt;/code&gt;&lt;/strong&gt; - The &lt;code&gt;id&lt;/code&gt; prop of the &lt;code&gt;Profiler&lt;/code&gt; tree that has just committed. This can be used to identify which part of the tree was committed if you are using multiple profilers.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;id: string&lt;/code&gt; &lt;/strong&gt; string-방금 커밋한 &lt;code&gt;Profiler&lt;/code&gt; 트리의 &lt;code&gt;id&lt;/code&gt; prop입니다. 여러 프로파일 러를 사용하는 경우 커밋 된 트리 부분을 식별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ce4c1d4832bb0e43d034cbaa0662eefda596ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;interactions: Set&lt;/code&gt;&lt;/strong&gt; - Set of &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;&amp;ldquo;interactions&amp;rdquo;&lt;/a&gt; that were being traced the update was scheduled (e.g. when &lt;code&gt;render&lt;/code&gt; or &lt;code&gt;setState&lt;/code&gt; were called).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;interactions: Set&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;setState&lt;/code&gt; 업데이트가 예정된 추적중인&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt; &quot;상호 작용&quot;&lt;/a&gt; 세트(예 : &lt;code&gt;render&lt;/code&gt; 또는 setState 가 호출 된 경우)</target>
        </trans-unit>
        <trans-unit id="045d410e2d948cdb96f4239b6311b1d732f52f31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;phase: &quot;mount&quot; | &quot;update&quot;&lt;/code&gt;&lt;/strong&gt; - Identifies whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;phase: &quot;mount&quot; | &quot;update&quot;&lt;/code&gt; &lt;/strong&gt; -소품, 상태 또는 후크의 변경으로 인해 트리가 처음으로 마운트되었거나 다시 렌더링되었는지 식별합니다.</target>
        </trans-unit>
        <trans-unit id="571cedd0a0dc5c8805c27c4c6caaf4bb4c1e12d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b0fd3e9bec3e312d2cb1960e60192785f42cc2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling&lt;/strong&gt;: sample changes based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; (eg &lt;a href=&quot;https://github.com/alexreardon/raf-schd&quot;&gt;&lt;code&gt;raf-schd&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; 조절&lt;/strong&gt; :&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; &lt;/a&gt; (예 :&lt;a href=&quot;https://github.com/alexreardon/raf-schd&quot;&gt; &lt;code&gt;raf-schd&lt;/code&gt; &lt;/a&gt; )에 따라 샘플 변경</target>
        </trans-unit>
        <trans-unit id="76173ffd5f59ad48d911dbf15184f902718fa903" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;startTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React began rendering the current update.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;startTime: number&lt;/code&gt; &lt;/strong&gt; -React가 현재 업데이트를 렌더링하기 시작한 타임 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="8734e53ac0cf459890de4ee35290687bc530b58d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A custom Hook is a JavaScript function whose name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and that may call other Hooks.&lt;/strong&gt; For example, &lt;code&gt;useFriendStatus&lt;/code&gt; below is our first custom Hook:</source>
          <target state="translated">&lt;strong&gt;사용자 정의 후크는 이름이 &quot; &lt;code&gt;use&lt;/code&gt; &quot;로 시작하고 다른 후크를 호출 할 수 있는 JavaScript 함수입니다 . &lt;/strong&gt;예를 들어 아래의 &lt;code&gt;useFriendStatus&lt;/code&gt; 는 첫 번째 사용자 정의 후크입니다.</target>
        </trans-unit>
        <trans-unit id="2b4cdb60967a51938f2f25c9f126e16acf3aad29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APIs starting with &lt;code&gt;unstable_&lt;/code&gt;.&lt;/strong&gt; These are provided as experimental features whose APIs we are not yet confident in. By releasing these with an &lt;code&gt;unstable_&lt;/code&gt; prefix, we can iterate faster and get to a stable API sooner.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;unstable_&lt;/code&gt; 로 시작하는 API . &lt;/strong&gt;이것들은 우리가 아직 확신하지 못하는 API를 가진 실험적인 기능으로 제공됩니다. &lt;code&gt;unstable_&lt;/code&gt; 접두사를 사용하여 이러한 기능을 해제하면 더 빠르게 반복하고 안정적인 API를 더 빨리 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27b0bcf635fa2c2f9c4e5f35ea52c9731dba3fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;After:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c78cb87233869c91e558e7c266ddcae814f875e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All React components must act like pure functions with respect to their props.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모든 React 구성 요소는 소품과 관련하여 순수한 기능처럼 작동해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef7b86d446e9bf407e47a462807b03c155a6c2f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alpha and canary versions of React.&lt;/strong&gt; We provide alpha versions of React as a way to test new features early, but we need the flexibility to make changes based on what we learn in the alpha period. If you use these versions, note that APIs may change before the stable release.</source>
          <target state="translated">&lt;strong&gt;알파 및 카나리아 버전의 React. &lt;/strong&gt;새로운 기능을 조기에 테스트 할 수있는 방법으로 알파 버전의 React를 제공하지만 알파 기간에 배운 내용을 기반으로 변경하려면 유연성이 필요합니다. 이 버전을 사용하는 경우 안정 릴리스 전에 API가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0528360d2c4b02352330a33a1653ceb3d395264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;App:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;App:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c144641667df7bb33364c9017474aea77fbba896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays and fragments.&lt;/strong&gt; Let you return multiple elements from render. See the documentation on &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;배열과 조각. &lt;/strong&gt;렌더에서 여러 요소를 반환 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;fragments&quot;&gt;조각에&lt;/a&gt; 대한 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fa6bc0a302e6610000befe2d96dad38929fde7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As more data streams in, React will retry rendering, and each time it might be able to progress &amp;ldquo;deeper&amp;rdquo;.&lt;/strong&gt; When &lt;code&gt;resource.user&lt;/code&gt; is fetched, the &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; component will render successfully and we&amp;rsquo;ll no longer need the &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback. Eventually, we&amp;rsquo;ll get all the data, and there will be no fallbacks on the screen.</source>
          <target state="translated">&lt;strong&gt;더 많은 데이터가 스트리밍되면 React는 렌더링을 다시 시도하며 매번&amp;ldquo;더 깊이&amp;rdquo;진행될 수 있습니다. &lt;/strong&gt; &lt;code&gt;resource.user&lt;/code&gt; 를 가져 오면 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 구성 요소가 성공적으로 렌더링되며 더 이상 &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; 폴 백이 필요하지 않습니다 . 결국, 우리는 모든 데이터를 얻을 것이며 화면에 폴 백이 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9954cf985840ab38b252982d386ed46ce940abce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available now.&lt;/strong&gt; Hooks are now available with the release of v16.8.0.</source>
          <target state="translated">&lt;strong&gt;지금 이용 가능합니다. &lt;/strong&gt;v16.8.0 릴리스에서 후크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2595afb4d0118de17abae3f582f8bf9e4a43ca84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid copying props into state! This is a common mistake:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;소품을 상태로 복사하지 마십시오! 이것은 일반적인 실수입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d96324ef9248f7dc600e7558815b0ce0707fd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Before:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="118cd2ca1ad0a4ea488c9cd88cacff2eedc873fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocking Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createBlockingRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. It is intended as a first migration step for apps that want to get a subset of Concurrent Mode features.</source>
          <target state="translated">&lt;strong&gt;차단 모드 : &lt;/strong&gt; &lt;code&gt;ReactDOM.createBlockingRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt; . 현재 실험 중입니다. 동시 모드 기능의 하위 세트를 얻으려는 앱의 첫 번째 마이그레이션 단계입니다.</target>
        </trans-unit>
        <trans-unit id="418a9a858502073bdd408d533c2dcd9fc1ea650e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Booleans or &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt;. Render nothing. (Mostly exists to support &lt;code&gt;return test &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; pattern, where &lt;code&gt;test&lt;/code&gt; is boolean.)</source>
          <target state="translated">&lt;strong&gt;부울 또는 &lt;code&gt;null&lt;/code&gt; &lt;/strong&gt; 입니다. 아무것도 렌더링하지 않습니다. ( &lt;code&gt;return test &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; 패턴 을 지원하기 위해 존재하며 , &lt;code&gt;test&lt;/code&gt; 는 부울입니다.)</target>
        </trans-unit>
        <trans-unit id="b14feed13e2d6b88199143da24c9f63c351a347e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundle:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Bundle:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c39f68088cc6ea0f96f4c6bf7b6102044e4e4fd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundled&lt;/strong&gt; - The library bundles its own declaration file. This is great for us, since all we need to do is install the library, and we can use it right away. To check if a library has bundled types, look for an &lt;code&gt;index.d.ts&lt;/code&gt; file in the project. Some libraries will have it specified in their &lt;code&gt;package.json&lt;/code&gt; under the &lt;code&gt;typings&lt;/code&gt; or &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">&lt;strong&gt;묶음&lt;/strong&gt; -라이브러리가 자체 선언 파일을 묶습니다. 라이브러리를 설치하기 만하면 바로 사용할 수 있기 때문에 이것은 우리에게 좋습니다. 라이브러리에 번들 유형이 있는지 확인하려면 프로젝트에서 &lt;code&gt;index.d.ts&lt;/code&gt; 파일을 찾으십시오 . 일부 라이브러리는 &lt;code&gt;typings&lt;/code&gt; 또는 &lt;code&gt;types&lt;/code&gt; 필드 아래 &lt;code&gt;package.json&lt;/code&gt; 에 지정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11d0f72b90ece3ead56ba6ecac303bbd8a5ee230" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But how can two versions of the same component exist at the same time?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그러나 어떻게 같은 구성 요소의 두 가지 버전이 동시에 존재할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcc8763b490e6bfaa3caa0e4aaf22dee67e939a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But what happens if the &lt;code&gt;friend&lt;/code&gt; prop changes&lt;/strong&gt; while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.</source>
          <target state="translated">&lt;strong&gt;그러나 &lt;code&gt;friend&lt;/code&gt; &lt;/strong&gt; 구성 요소가 화면에있는 동안 &lt;strong&gt;친구&lt;/strong&gt;&lt;strong&gt; 소품이 바뀌면 &lt;/strong&gt;&lt;strong&gt;어떻게됩니까&lt;/strong&gt; ? 우리의 구성 요소는 다른 친구의 온라인 상태를 계속 표시합니다. 이것은 버그입니다. 수신 거부 통화에서 잘못된 친구 ID를 사용하므로 마운트 해제시 메모리 누수 또는 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a0c08721b7a9c57e2fe6c6f0fa5e81549efe634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By itself, this code doesn&amp;rsquo;t do anything yet.&lt;/strong&gt; We will need to use this Hook&amp;rsquo;s return values to set up our state transition. There are two values returned from &lt;code&gt;useTransition&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;이 코드 자체는 아직 아무것도하지 않습니다. &lt;/strong&gt;상태 전환을 설정하려면이 후크의 반환 값을 사용해야합니다. &lt;code&gt;useTransition&lt;/code&gt; 에서 반환 된 값은 두 가지입니다 .</target>
        </trans-unit>
        <trans-unit id="9caf5fa30d746db8e19d1be289bffadc70552f0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Changing the value of an input field and then pressing ENTER.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;입력 필드의 값을 변경 한 다음 Enter 키를 누릅니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f922480363722c3d315fe73dc6146bcb65ff0f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clicking an element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;요소를 클릭&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="664d55b0b70eda79fe17e0e576dbb285c10897d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with no fallbacks inside. Everything was fetched.</source>
          <target state="translated">&lt;strong&gt;전체 :&lt;/strong&gt; 당신은 볼 것이다 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 내부에 어떤 폴백 (fallback)와 구성 요소를. 모든 것을 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="431d7e11a94ec8347fc0d53336c7d13234d7a0f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Completely opt-in.&lt;/strong&gt; You can try Hooks in a few components without rewriting any existing code. But you don&amp;rsquo;t have to learn or use Hooks right now if you don&amp;rsquo;t want to.</source>
          <target state="translated">&lt;strong&gt;완전히 옵트 인 &lt;/strong&gt;기존 코드를 다시 작성하지 않고도 일부 구성 요소에서 후크를 시도 할 수 있습니다. 그러나 원하지 않으면 지금 후크를 배우거나 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b61b75094f835769117a08ebb5de039406be1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode fixes this fundamental limitation by making rendering interruptible.&lt;/strong&gt; This means when the user presses another key, React doesn&amp;rsquo;t need to block the browser from updating the text input. Instead, it can let the browser paint an update to the input, and then continue rendering the updated list &lt;em&gt;in memory&lt;/em&gt;. When the rendering is finished, React updates the DOM, and changes are reflected on the screen.</source>
          <target state="translated">&lt;strong&gt;동시 모드는 렌더링을 인터럽트 가능하게하여이 기본 제한을 수정합니다. &lt;/strong&gt;이는 사용자가 다른 키를 누를 때 React가 브라우저가 텍스트 입력을 업데이트하지 못하도록 차단할 필요가 없음을 의미합니다. 대신, 브라우저가 입력에 대한 업데이트를 페인트 한 다음 업데이트 된 목록 &lt;em&gt;을 메모리에&lt;/em&gt; 계속 렌더링 할 수 있습니다. 렌더링이 완료되면 React가 DOM을 업데이트하고 변경 사항이 화면에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="c7530a2da53c5c616bbb7d31b3305f43795be943" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. In the future, after it stabilizes, we intend to make it the default React mode. This mode enables &lt;em&gt;all&lt;/em&gt; the new features.</source>
          <target state="translated">&lt;strong&gt;동시 모드 : &lt;/strong&gt; &lt;code&gt;ReactDOM.createRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt; . 현재 실험 중입니다. 앞으로는 안정화 된 후에 기본 React 모드로 만들려고합니다. 이 모드는 &lt;em&gt;모든&lt;/em&gt; 새로운 기능을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="a9aec2ee7c42a70823e6f966d4b552beac2d79ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0629c87821b72707236c22ec926f99e314eaad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crucially, Hooks work side-by-side with existing code so you can adopt them gradually.&lt;/strong&gt; There is no rush to migrate to Hooks. We recommend avoiding any &amp;ldquo;big rewrites&amp;rdquo;, especially for existing, complex class components. It takes a bit of a mindshift to start &amp;ldquo;thinking in Hooks&amp;rdquo;. In our experience, it&amp;rsquo;s best to practice using Hooks in new and non-critical components first, and ensure that everybody on your team feels comfortable with them. After you give Hooks a try, please feel free to &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;send us feedback&lt;/a&gt;, positive or negative.</source>
          <target state="translated">&lt;strong&gt;결정적으로 후크는 기존 코드와 나란히 작동하므로 점차적으로 코드를 채택 할 수 있습니다. &lt;/strong&gt;후크로 마이그레이션하는 서두가 없습니다. 특히 기존의 복잡한 클래스 구성 요소에 대해서는 &quot;큰 재 작성&quot;을 피하는 것이 좋습니다. &quot;후크에서 생각하기&quot;를 시작하려면 약간의 사고가 필요합니다. 경험상 새롭고 중요하지 않은 구성 요소에서 후크 사용을 먼저 연습하고 팀의 모든 사람들이 편안하게 느끼도록하는 것이 가장 좋습니다. 당신이 후크 시도 후, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;우리에게&lt;/a&gt; 긍정적 또는 부정 의견 을 보내 주시기 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="0ca1a3dfa4c9d12963ce5931770052fd5b8dae25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Development warnings.&lt;/strong&gt; Since these don&amp;rsquo;t affect production behavior, we may add new warnings or modify existing warnings in between major versions. In fact, this is what allows us to reliably warn about upcoming breaking changes.</source>
          <target state="translated">&lt;strong&gt;개발 경고. &lt;/strong&gt;이것들은 생산 행동에 영향을 미치지 않기 때문에, 주요 버전간에 새로운 경고를 추가하거나 기존 경고를 수정할 수 있습니다. 실제로 이것이 곧 변경 될 주요 변경 사항에 대해 확실하게 경고 할 수있게 해줍니다.</target>
        </trans-unit>
        <trans-unit id="be365c38740fc02085ea0c7b28b61ebbe29465cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do I have to name my custom Hooks starting with &amp;ldquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo;?&lt;/strong&gt; Please do. This convention is very important. Without it, we wouldn&amp;rsquo;t be able to automatically check for violations of &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; because we couldn&amp;rsquo;t tell if a certain function contains calls to Hooks inside of it.</source>
          <target state="translated">&lt;strong&gt;&quot; &lt;code&gt;use&lt;/code&gt; &quot;로 시작하는 사용자 정의 후크의 이름을 지정해야 합니까? &lt;/strong&gt;제발. 이 규칙은 매우 중요합니다. 이것이 없으면 특정 함수에 후크 호출이 포함되어 있는지 여부를 알 수 없으므로 &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙&lt;/a&gt; 위반을 자동으로 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="840f3f4e52f32ec07ea665effb626bd2bae907bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use prereleases in user-facing applications.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용자 용 응용 프로그램에서는 시험판을 사용하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02042712a60d18416fd5dbb8583b8cccba7ac107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do two components using the same Hook share state?&lt;/strong&gt; No. Custom Hooks are a mechanism to reuse &lt;em&gt;stateful logic&lt;/em&gt; (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are fully isolated.</source>
          <target state="translated">&lt;strong&gt;동일한 후크 공유 상태를 사용하는 두 구성 요소가 있습니까? &lt;/strong&gt;사용자 정의 후크는 &lt;em&gt;상태&lt;/em&gt; 설정 &lt;em&gt;논리&lt;/em&gt; (예 : 구독 설정 및 현재 값 기억) 를 재사용하는 메커니즘 이지만 사용자 정의 후크를 사용할 때마다 그 안에있는 모든 상태와 효과는 완전히 격리됩니다.</target>
        </trans-unit>
        <trans-unit id="5fbcd181433e3ca93055c4d885d5d7e398339a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Does &lt;code&gt;useEffect&lt;/code&gt; run after every render?&lt;/strong&gt; Yes! By default, it runs both after the first render &lt;em&gt;and&lt;/em&gt; after every update. (We will later talk about &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to customize this&lt;/a&gt;.) Instead of thinking in terms of &amp;ldquo;mounting&amp;rdquo; and &amp;ldquo;updating&amp;rdquo;, you might find it easier to think that effects happen &amp;ldquo;after render&amp;rdquo;. React guarantees the DOM has been updated by the time it runs the effects.</source>
          <target state="translated">&lt;strong&gt;매 렌더링마다 &lt;code&gt;useEffect&lt;/code&gt; 가 실행 됩니까 ? &lt;/strong&gt;예! 기본적으로 첫 번째 렌더링 후 &lt;em&gt;와&lt;/em&gt; 모든 업데이트 후에 실행됩니다 . (나중에 &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;이것을 사용자 정의하는 방법에&lt;/a&gt; 대해 이야기 할 것입니다 .) &quot;마운팅&quot;및 &quot;업데이트&quot;라는 관점에서 생각하는 대신 &quot;렌더링 후&quot;효과가 발생한다고 생각하기가 더 쉬울 수 있습니다. React는 DOM이 효과를 실행할 때 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea922f8145451905b9a5d999e9a337afcfb4d6cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks from regular JavaScript functions.&lt;/strong&gt; Instead, you can:</source>
          <target state="translated">&lt;strong&gt;일반 JavaScript 함수에서 후크를 호출하지 마십시오. &lt;/strong&gt;대신 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fadbf266b12dada567bc226186d3f5cc315d669c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.&lt;/strong&gt; Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That&amp;rsquo;s what allows React to correctly preserve the state of Hooks between multiple &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; calls. (If you&amp;rsquo;re curious, we&amp;rsquo;ll explain this in depth &lt;a href=&quot;#explanation&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">&lt;strong&gt;루프, 조건 또는 중첩 함수 내부에서 후크를 호출하지 마십시오. &lt;/strong&gt;대신, 항상 React 기능의 최상위 레벨에서 후크를 사용하십시오. 이 규칙을 따르면 구성 요소가 렌더링 될 때마다 후크가 동일한 순서로 호출됩니다. 이것이 React가 여러 &lt;code&gt;useState&lt;/code&gt; 와 &lt;code&gt;useEffect&lt;/code&gt; 호출 사이의 후크 상태를 올바르게 보존 할 수있게하는 것 입니다. 궁금한 점이 있으면 &lt;a href=&quot;#explanation&quot;&gt;아래&lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bd9092daac9a6a45cd5c86bb1fb41b93498ec98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Correct Key Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 : 올바른 키 사용법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8021b79242adc1726ab15211d7b813debb54040" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Incorrect Key Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 : 잘못된 키 사용법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5652355f3887cb50adc3da97751628a89b3ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Experimental releases will have frequent breaking changes.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실험용 릴리스에는 주요 변경 사항이 자주 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cebb6589caedc0e9cc806fb2dc5c7c45386f412" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-on-render (for example, &lt;code&gt;fetch&lt;/code&gt; in &lt;code&gt;useEffect&lt;/code&gt;):&lt;/strong&gt; Start rendering components. Each of these components may trigger data fetching in their effects and lifecycle methods. This approach often leads to &amp;ldquo;waterfalls&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;렌더링시 &lt;code&gt;fetch&lt;/code&gt; (예 : fetch in &lt;code&gt;useEffect&lt;/code&gt; ) :&lt;/strong&gt; 컴포넌트 렌더링을 시작하십시오. 이러한 각 구성 요소는 효과 및 수명주기 방법에서 데이터 가져 오기를 트리거 할 수 있습니다. 이 접근 방식은 종종 &quot;폭포&quot;로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="74dec7e02dc04a3faaa06cd94aa96d34daafe356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-then-render (for example, Relay without Suspense):&lt;/strong&gt; Start fetching all the data for the next screen as early as possible. When the data is ready, render the new screen. We can&amp;rsquo;t do anything until the data arrives.</source>
          <target state="translated">&lt;strong&gt;렌더링 후 페치 (예 : 서스펜스없는 릴레이) :&lt;/strong&gt; 가능한 빨리 다음 화면에 대한 모든 데이터를 가져 오기 시작합니다. 데이터가 준비되면 새 화면을 렌더링하십시오. 데이터가 도착할 때까지는 아무것도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="585dde52ce326d7e2bc859a3fa881f00e44a228e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finish fetching&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가져 오기 완료&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6940807aaa96966443fccbfb4d6ae087c006f191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at deferring values, you can read &lt;a href=&quot;concurrent-mode-patterns#deferring-a-value&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지연 값에 대해 자세히 알아 보려면 &lt;a href=&quot;concurrent-mode-patterns#deferring-a-value&quot;&gt;Concurrent UI Patterns를&lt;/a&gt; 읽을 수 있습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81e9e1fc0a7430e63de513e52d657e3039c0f737" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at transitions, you can read &lt;a href=&quot;concurrent-mode-patterns#transitions&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전환에 대한 자세한 내용은 &lt;a href=&quot;concurrent-mode-patterns#transitions&quot;&gt;Concurrent UI Patterns를 참조하십시오&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba2571822852d3a9ebbbaa834420b3872f3e2ce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks don&amp;rsquo;t replace your knowledge of React concepts.&lt;/strong&gt; Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.</source>
          <target state="translated">&lt;strong&gt;후크는 React 개념에 대한 지식을 대체하지 않습니다. &lt;/strong&gt;대신 Hooks는 이미 알고있는 React 개념 (props, state, context, refs 및 lifecycle)에보다 직접적인 API를 제공합니다. 나중에 보여 주겠지 만, Hooks는 새로운 강력한 결합 방법도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d0d1277bf6af10d314a996d3f9d38556128194b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks let us split the code based on what it is doing&lt;/strong&gt; rather than a lifecycle method name. React will apply &lt;em&gt;every&lt;/em&gt; effect used by the component, in the order they were specified.</source>
          <target state="translated">&lt;strong&gt;후크를 사용&lt;/strong&gt; 하면 수명주기 메소드 이름이 아니라 &lt;strong&gt;수행중인 작업을 기반으로 코드를 분할 할 수 있습니다&lt;/strong&gt; . React는 컴포넌트가 사용하는 &lt;em&gt;모든&lt;/em&gt; 효과를 지정된 순서대로 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="549222869a6579d68c4394b9ddc13d3055187ac5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a custom Hook get isolated state?&lt;/strong&gt; Each &lt;em&gt;call&lt;/em&gt; to a Hook gets isolated state. Because we call &lt;code&gt;useFriendStatus&lt;/code&gt; directly, from React&amp;rsquo;s point of view our component just calls &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt;. And as we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned&lt;/a&gt;&lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;earlier&lt;/a&gt;, we can call &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; many times in one component, and they will be completely independent.</source>
          <target state="translated">&lt;strong&gt;커스텀 훅은 어떻게 격리 상태를 얻습니까? &lt;/strong&gt;후크에 대한 각 &lt;em&gt;호출&lt;/em&gt; 은 격리 된 상태가됩니다. 우리는 &lt;code&gt;useFriendStatus&lt;/code&gt; 를 직접 호출하기 때문에 React의 관점에서 컴포넌트는 &lt;code&gt;useState&lt;/code&gt; 와 &lt;code&gt;useEffect&lt;/code&gt; 를 호출합니다 . &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;앞에서 &lt;/a&gt;&lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;배운&lt;/a&gt; 대로 하나의 구성 요소에서 &lt;code&gt;useState&lt;/code&gt; 및 &lt;code&gt;useEffect&lt;/code&gt; 를 여러 번 호출 할 수 있으며 완전히 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="97feece5ad10ef5e36e71d8a8b7a15c910ed1d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How much to mock:&lt;/strong&gt; With components, the distinction between a &amp;ldquo;unit&amp;rdquo; and &amp;ldquo;integration&amp;rdquo; test can be blurry. If you&amp;rsquo;re testing a form, should its test also test the buttons inside of it? Or should a button component have its own test suite? Should refactoring a button ever break the form test?</source>
          <target state="translated">&lt;strong&gt;조롱 할 정도 :&lt;/strong&gt; 구성 요소를 사용하면 &quot;단위&quot;와 &quot;통합&quot;테스트의 구분이 모호해질 수 있습니다. 양식을 테스트하는 경우 해당 양식의 버튼도 테스트해야합니까? 아니면 버튼 구성 요소에 자체 테스트 스위트가 있어야합니까? 버튼을 리팩터링하면 폼 테스트가 중단되어야합니까?</target>
        </trans-unit>
        <trans-unit id="2a8752a3833c91c9228ddd47ee17949d93770114" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idiomatic code using Hooks doesn&amp;rsquo;t need the deep component tree nesting&lt;/strong&gt; that is prevalent in codebases that use higher-order components, render props, and context. With smaller component trees, React has less work to do.</source>
          <target state="translated">&lt;strong&gt;후크를 사용하는 관용적 코드&lt;/strong&gt; 에는 상위 컴포넌트, 렌더 소품 및 컨텍스트를 사용하는 코드베이스에서 널리 사용 &lt;strong&gt;되는 딥 컴포넌트 트리 중첩&lt;/strong&gt; 이 &lt;strong&gt;필요하지 않습니다&lt;/strong&gt; . 컴포넌트 트리가 작을수록 React는 할 일이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fe82d913b37ed43a6c3776e244ba7ee19a96d552" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If for some reason you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; move a function inside an effect, there are a few more options:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떤 이유로 효과 내에서 함수를 옮길 &lt;em&gt;수없는&lt;/em&gt; 경우 몇 가지 추가 옵션이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f91ee3f1da4fcb123fe1add1e900abb64b204513" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some feature isn&amp;rsquo;t a vital part of the next screen, wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; and let it load lazily.&lt;/strong&gt; This ensures we can show the rest of the content as soon as possible. Conversely, if a screen is &lt;em&gt;not worth showing&lt;/em&gt; without some component, such as &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; in our example, do &lt;em&gt;not&lt;/em&gt; wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;. Then the transitions will &amp;ldquo;wait&amp;rdquo; for it to be ready.</source>
          <target state="translated">&lt;strong&gt;일부 기능이 다음 화면에서 중요한 부분이 아닌 경우 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 로 감싸서 느리게로드하십시오. &lt;/strong&gt;이를 통해 가능한 한 빨리 나머지 컨텐츠를 표시 할 수 있습니다. 화면이 반대로, &lt;em&gt;가치가 게재되지 않는&lt;/em&gt; 등 몇 가지 구성 요소없이 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 우리의 예에서 않습니다 &lt;em&gt;하지&lt;/em&gt; 에 포장 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; . 그런 다음 전환이 준비 될 때까지 &quot;대기&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="87d17462d8c3ce399e59474b343b454f198283b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some state update causes a component to suspend, that state update should be wrapped in a transition.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일부 상태 업데이트로 인해 구성 요소가 일시 중단되면 해당 상태 업데이트는 전환으로 래핑되어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="743d61fffa9c9762bcfdbc0ba719dc7d754a16c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you don&amp;rsquo;t initialize state and you don&amp;rsquo;t bind methods, you don&amp;rsquo;t need to implement a constructor for your React component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상태를 초기화하지 않고 메소드를 바인드하지 않으면 React 컴포넌트의 생성자를 구현할 필요가 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="010e5a638b8e2853191ee4c9f9a95021e00f0621" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the &lt;a href=&quot;hooks-rules&quot;&gt;next page about Rules of Hooks&lt;/a&gt; now.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;효과 후크의 작동 방식에 대해 잘 알고 있거나 압도적이라고 생각되면 지금 &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙에 대한 다음 페이지로 넘어갈 수&lt;/a&gt; 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="199cd21f9753c5e277848634a7461c4cdf76fb99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you just want to start learning Hooks, feel free to &lt;a href=&quot;hooks-overview&quot;&gt;jump directly to the next page!&lt;/a&gt;&lt;/strong&gt; You can also keep reading this page to learn more about why we&amp;rsquo;re adding Hooks, and how we&amp;rsquo;re going to start using them without rewriting our applications.</source>
          <target state="translated">&lt;strong&gt;Hooks를 배우고 싶다면 &lt;a href=&quot;hooks-overview&quot;&gt;다음 페이지로 바로 넘어가십시오! &lt;/a&gt;&lt;/strong&gt;후크를 추가하는 이유와 애플리케이션을 다시 작성하지 않고 후크를 사용하는 방법에 대해 자세히 알아 보려면이 페이지를 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="93b3458601d6435e4a97c86c14b547e64c6f09e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you only want to avoid passing some props through many levels, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;component composition&lt;/a&gt; is often a simpler solution than context.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일부 소품을 여러 수준으로 전달하지 않으려 는 경우 &lt;a href=&quot;composition-vs-inheritance&quot;&gt;구성 요소 구성&lt;/a&gt; 은 종종 문맥보다 간단한 솔루션입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0339780254d445749b17fc47c897244b665cc6ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure which channel you should use, it&amp;rsquo;s Latest.&lt;/strong&gt; If you&amp;rsquo;re a React developer, this is what you&amp;rsquo;re already using.</source>
          <target state="translated">&lt;strong&gt;어떤 채널을 사용해야할지 확실하지 않은 경우 최신 채널입니다. &lt;/strong&gt;React 개발자라면 이미 사용하고있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="19499e8a5ad3525f0986cfd12f3f1c87b2c9ac0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Importing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4519202455f803715d2c9c3afdc889b2e6855dac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06e6e8a38c6b7b9f76acbde123862702d9f0c4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ca533f91c4be178a816d4659286281e4dfaef37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Is this code equivalent to the original examples?&lt;/strong&gt; Yes, it works in exactly the same way. If you look closely, you&amp;rsquo;ll notice we didn&amp;rsquo;t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function. &lt;strong&gt;Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 코드는 원래 예제와 동일합니까? &lt;/strong&gt;예, 정확히 같은 방식으로 작동합니다. 자세히 살펴보면, 우리는 행동을 변경하지 않았다는 것을 알 수 있습니다. 두 함수 사이의 공통 코드를 별도의 함수로 추출하는 것이 전부였습니다. &lt;strong&gt;사용자 정의 후크는 React 기능이 아닌 후크 디자인에서 자연스럽게 따르는 규칙입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1c4fce55098e2a2ebd95626d9fa1bb7e1c2898e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It does not couple data fetching to the view layer.&lt;/strong&gt; It helps orchestrate displaying the loading states in your UI, but it doesn&amp;rsquo;t tie your network logic to React components.</source>
          <target state="translated">&lt;strong&gt;데이터 페칭을 뷰 레이어에 연결하지 않습니다. &lt;/strong&gt;UI에서 로딩 상태 표시를 조율하는 데 도움이되지만 네트워크 로직을 React 구성 요소에 연결하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf0fe04b299a5f88513f5a561bfab0e4736efecd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It helps you avoid race conditions.&lt;/strong&gt; Even with &lt;code&gt;await&lt;/code&gt;, asynchronous code is often error-prone. Suspense feels more like reading data &lt;em&gt;synchronously&lt;/em&gt; &amp;mdash; as if it was already loaded.</source>
          <target state="translated">&lt;strong&gt;경쟁 조건을 피하는 데 도움이됩니다. &lt;/strong&gt;심지어와 &lt;code&gt;await&lt;/code&gt; 를 , 비동기 코드는 종종 오류가 발생하기 쉬운입니다. 서스펜스는 마치 데이터 가 이미로드되어있는 것처럼 &lt;em&gt;동 기적&lt;/em&gt; 으로 데이터를 읽는 것처럼 느껴집니다 .</target>
        </trans-unit>
        <trans-unit id="55d518f34e17861e9ce1674fe13c1ad692812b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a data fetching implementation.&lt;/strong&gt; It does not assume that you use GraphQL, REST, or any other particular data format, library, transport, or protocol.</source>
          <target state="translated">&lt;strong&gt;데이터 페치 구현이 아닙니다. &lt;/strong&gt;GraphQL, REST 또는 기타 특정 데이터 형식, 라이브러리, 전송 또는 프로토콜을 사용한다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81110995ca89b565002106a4272820cb696b44a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a ready-to-use client.&lt;/strong&gt; You can&amp;rsquo;t &amp;ldquo;replace&amp;rdquo; &lt;code&gt;fetch&lt;/code&gt; or Relay with Suspense. But you can use a library that&amp;rsquo;s integrated with Suspense (for example, &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference&quot;&gt;new Relay APIs&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;바로 사용할 수있는 클라이언트가 아닙니다. &lt;/strong&gt; &lt;code&gt;fetch&lt;/code&gt; 또는 릴레이를 서스펜스로 &quot;대체&quot;할 수 없습니다 . 그러나 Suspense와 통합 된 라이브러리 (예 : &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference&quot;&gt;새 릴레이 API&lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b19fe11cf700d76b6edd744f65d9b1eaa1700eab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets data fetching libraries deeply integrate with React.&lt;/strong&gt; If a data fetching library implements Suspense support, using it from React components feels very natural.</source>
          <target state="translated">&lt;strong&gt;데이터 페치 라이브러리는 React와 긴밀하게 통합됩니다. &lt;/strong&gt;데이터 페치 라이브러리가 Suspense 지원을 구현하는 경우 React 컴포넌트에서이를 사용하면 매우 자연스럽게 느껴집니다.</target>
        </trans-unit>
        <trans-unit id="90b929484e402b7aff9864ea9f233f51dddd6c80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets you orchestrate intentionally designed loading states.&lt;/strong&gt; It doesn&amp;rsquo;t say &lt;em&gt;how&lt;/em&gt; the data is fetched, but it lets you closely control the visual loading sequence of your app.</source>
          <target state="translated">&lt;strong&gt;의도적으로 설계된로드 상태를 조정합니다. &lt;/strong&gt;데이터가 &lt;em&gt;어떻게&lt;/em&gt; 인출 &lt;em&gt;되는지&lt;/em&gt; 는 말하지 않지만 앱의 시각적 로딩 순서를 면밀히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f3fa111b3d223edc7fd94673d0beee8feb9c94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iteration speed vs Realistic environment:&lt;/strong&gt; Some tools offer a very quick feedback loop between making a change and seeing the result, but don&amp;rsquo;t model the browser behavior precisely. Other tools might use a real browser environment, but reduce the iteration speed and are flakier on a continuous integration server.</source>
          <target state="translated">&lt;strong&gt;반복 속도와 실제 환경 비교 :&lt;/strong&gt; 일부 도구는 변경과 결과 확인 사이에 매우 빠른 피드백 루프를 제공하지만 브라우저 동작을 정확하게 모델링하지는 않습니다. 다른 도구는 실제 브라우저 환경을 사용할 수 있지만 반복 속도를 낮추고 지속적인 통합 서버에서는 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="50a65bff48ac7042efb756481adec3a54e902c07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Legacy Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt;. This is what React apps use today. There are no plans to remove the legacy mode in the observable future &amp;mdash; but it won&amp;rsquo;t be able to support these new features.</source>
          <target state="translated">&lt;strong&gt;레거시 모드 : &lt;/strong&gt; &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; . 이것이 오늘날 React 앱이 사용하는 것입니다. 향후에는 레거시 모드를 제거 할 계획이 없지만 이러한 새로운 기능을 지원할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0dd6bf0667b49653f91c6663edcfebbb17079dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 1:&lt;/strong&gt; We import the &lt;code&gt;useState&lt;/code&gt; Hook from React. It lets us keep local state in a function component.</source>
          <target state="translated">&lt;strong&gt;1 행 :&lt;/strong&gt; React 에서 &lt;code&gt;useState&lt;/code&gt; Hook를 가져옵니다 . 함수 컴포넌트에서 로컬 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7270df719cea370558248bcad77f01151d78491a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 4:&lt;/strong&gt; Inside the &lt;code&gt;Example&lt;/code&gt; component, we declare a new state variable by calling the &lt;code&gt;useState&lt;/code&gt; Hook. It returns a pair of values, to which we give names. We&amp;rsquo;re calling our variable &lt;code&gt;count&lt;/code&gt; because it holds the number of button clicks. We initialize it to zero by passing &lt;code&gt;0&lt;/code&gt; as the only &lt;code&gt;useState&lt;/code&gt; argument. The second returned item is itself a function. It lets us update the &lt;code&gt;count&lt;/code&gt; so we&amp;rsquo;ll name it &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;4 행 : &lt;/strong&gt; &lt;code&gt;Example&lt;/code&gt; 컴포넌트 내 에서 &lt;code&gt;useState&lt;/code&gt; Hook 를 호출하여 새 상태 변수를 선언합니다 . 이름을 지정하는 값 쌍을 반환합니다. 버튼 클릭 수를 보유하고 있기 때문에 변수 &lt;code&gt;count&lt;/code&gt; 호출 합니다. 우리는 전달하여 0으로 초기화 &lt;code&gt;0&lt;/code&gt; 유일으로 &lt;code&gt;useState&lt;/code&gt; 인수입니다. 두 번째로 반환 된 항목은 그 자체가 함수입니다. &lt;code&gt;count&lt;/code&gt; 업데이트 할 수 있도록 이름을 &lt;code&gt;setCount&lt;/code&gt; 로 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7a7a3cc60d64235f4e5261dec996d75336798f05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 9:&lt;/strong&gt; When the user clicks, we call &lt;code&gt;setCount&lt;/code&gt; with a new value. React will then re-render the &lt;code&gt;Example&lt;/code&gt; component, passing the new &lt;code&gt;count&lt;/code&gt; value to it.</source>
          <target state="translated">&lt;strong&gt;9 행 :&lt;/strong&gt; 사용자가 클릭 하면 새로운 값으로 &lt;code&gt;setCount&lt;/code&gt; 를 호출 합니다. 그런 다음 React는 새 &lt;code&gt;count&lt;/code&gt; 값을 전달하여 &lt;code&gt;Example&lt;/code&gt; 컴포넌트 를 다시 렌더링 합니다.</target>
        </trans-unit>
        <trans-unit id="c6b8b1b4f4a5584b72a18b8e95852b80cc54dae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local Declarations&lt;/strong&gt; Sometimes the package that you want to use doesn&amp;rsquo;t bundle declarations nor is it available on DefinitelyTyped. In that case, we can have a local declaration file. To do this, create a &lt;code&gt;declarations.d.ts&lt;/code&gt; file in the root of your source directory. A simple declaration could look like this:</source>
          <target state="translated">&lt;strong&gt;로컬 선언&lt;/strong&gt; 때로는 사용하려는 패키지가 선언을 번들로 제공하지 않거나 DefinitelyTyped에서 사용할 수 없습니다. 이 경우 로컬 선언 파일을 가질 수 있습니다. 이렇게하려면 소스 디렉토리의 루트에 &lt;code&gt;declarations.d.ts&lt;/code&gt; 파일을 만듭니다 . 간단한 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f793f7bc3a3b26158670d850e29dc82da802b138" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that you don&amp;rsquo;t need to worry about this problem if you use the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;provided lint rule&lt;/a&gt;.&lt;/strong&gt; But now you also know &lt;em&gt;why&lt;/em&gt; Hooks work this way, and which issues the rule is preventing.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;제공된 보푸라기 규칙&lt;/a&gt; 을 사용하는 경우이 문제에 대해 걱정할 필요가 없습니다 . &lt;/strong&gt;그러나 이제 후크가 이런 식으로 작동하는 &lt;em&gt;이유&lt;/em&gt; 와 규칙이 방해하는 문제를 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e8b0d2688bd8d9824e88dddab53f35391775595" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This is a Community Preview and not the final stable version. There will likely be future changes to these APIs. Use at your own risk!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 이것은 커뮤니티 미리보기이며 최종 안정 버전이 아닙니다. 향후 이러한 API가 변경 될 수 있습니다. 자신의 책임하에 사용하십시오!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="593aeb4f3f89c3bf5c24e17ee45fd1910b17c41a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: We recommend that you share Suspense Config between different modules.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 여러 모듈간에 Suspense Config를 공유하는 것이 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7040828fb921d37b8a31bfaf2e1a2f9a6c1276dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Always start component names with a capital letter.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 항상 구성 요소 이름은 대문자로 시작 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42e7216099fe728d8bbe239adf85181892c6883" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let&amp;rsquo;s continue by &lt;a href=&quot;hooks-effect&quot;&gt;learning the next Hook: &lt;code&gt;useEffect&lt;/code&gt;.&lt;/a&gt;&lt;/strong&gt; It lets you perform side effects in components, and is similar to lifecycle methods in classes.</source>
          <target state="translated">&lt;strong&gt;이제 &lt;a href=&quot;hooks-effect&quot;&gt;다음 Hook : &lt;code&gt;useEffect&lt;/code&gt; 를 배우면서&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 계속 &lt;/strong&gt;&lt;strong&gt;합시다&lt;/strong&gt;&lt;strong&gt; . &lt;/strong&gt;구성 요소에서 부작용을 수행 할 수 있으며 클래스의 수명주기 메소드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bcd938635ddd8b87a65f9ab1b71b41e5ec17b909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only use this pattern if you intentionally want to ignore prop updates.&lt;/strong&gt; In that case, it makes sense to rename the prop to be called &lt;code&gt;initialColor&lt;/code&gt; or &lt;code&gt;defaultColor&lt;/code&gt;. You can then force a component to &amp;ldquo;reset&amp;rdquo; its internal state by &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;changing its &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="translated">&lt;strong&gt;소품 업데이트를 고의로 무시하려는 경우에만이 패턴을 사용하십시오. &lt;/strong&gt;이 경우 prop의 이름을 &lt;code&gt;initialColor&lt;/code&gt; 또는 &lt;code&gt;defaultColor&lt;/code&gt; 로 바꾸는 것이 좋습니다 . 그런 다음 필요할 때 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 를 변경 하여 구성 요소가 내부 상태를 &quot;재설정&quot;하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9d5100e65eb19f31c6edf66c706e6d482f60c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Portals&lt;/strong&gt;. Let you render children into a different DOM subtree. See the documentation on &lt;a href=&quot;portals&quot;&gt;portals&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;포털&lt;/strong&gt; . 자식을 다른 DOM 하위 트리로 렌더링 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;portals&quot;&gt;포털&lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55c15d6ed99d7816203985bf165b9f9821f25c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred: &lt;a href=&quot;https://codesandbox.io/s/focused-snow-xbkvl&quot;&gt;Pending &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선호 : &lt;a href=&quot;https://codesandbox.io/s/focused-snow-xbkvl&quot;&gt;보류 중 &amp;rarr; 스켈레톤 &amp;rarr; 완료&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9839ea062ed4fa5a43488dd71d11ee1954444366" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Putting it together with Context.Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Context.Provider와 함께 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3138e5aa6164999b8c6225f3fdf7820352fe882" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React elements.&lt;/strong&gt; Typically created via &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; are React elements that instruct React to render a DOM node, or another user-defined component, respectively.</source>
          <target state="translated">&lt;strong&gt;반응 요소. &lt;/strong&gt;일반적으로 &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; 를 통해 생성됩니다 . 예를 들어, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; 는 React가 DOM 노드 또는 다른 사용자 정의 컴포넌트를 각각 렌더링하도록 지시하는 React 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2006364502f1d68dcba23768a1e62a0554187259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React&lt;/strong&gt; is a JavaScript library for building user interfaces. Learn what React is all about on &lt;a href=&quot;https://reactjs.org/&quot;&gt;our homepage&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;in the tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;React&lt;/strong&gt; 는 사용자 인터페이스를 구축하기위한 JavaScript 라이브러리입니다. &lt;a href=&quot;https://reactjs.org/&quot;&gt;홈페이지&lt;/a&gt; 나 &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;튜토리얼에서&lt;/a&gt; React가 무엇인지 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="c899298f272c1fdfbeb117f62d7e014d25aa5a16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Receded&lt;/strong&gt;: For a second, you will see the &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback.</source>
          <target state="translated">&lt;strong&gt;Receded&lt;/strong&gt; : &lt;strong&gt;잠시&lt;/strong&gt; 동안 &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; &lt;strong&gt;폴&lt;/strong&gt; 백이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd10ab8f0a3c7b84b26dd6034b22ed4a81bbc1c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ref forwarding is an opt-in feature that lets some components take a &lt;code&gt;ref&lt;/code&gt; they receive, and pass it further down (in other words, &amp;ldquo;forward&amp;rdquo; it) to a child.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ref forwarding은 옵트 인 (opt-in) 기능으로 일부 구성 요소는 수신 한 &lt;code&gt;ref&lt;/code&gt; 을 가져 와서 하위로 전달합니다 (즉, &quot;전달&quot;).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06c51dd38b8fbdcddbfb44c5d79e9cc74de7e4e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Render-as-you-fetch (for example, Relay with Suspense):&lt;/strong&gt; Start fetching all the required data for the next screen as early as possible, and start rendering the new screen &lt;em&gt;immediately &amp;mdash; before we get a network response&lt;/em&gt;. As data streams in, React retries rendering components that still need data until they&amp;rsquo;re all ready.</source>
          <target state="translated">&lt;strong&gt;가져 오기로 렌더링 (예 : 서스펜스로 릴레이) :&lt;/strong&gt; 가능한 빨리 다음 화면에 필요한 모든 데이터를 가져 오기 시작 &lt;em&gt;하고 네트워크 응답을 받기 전에&lt;/em&gt; 새 화면을 &lt;em&gt;즉시&lt;/em&gt; 렌더링하기 시작합니다 . 데이터가 스트리밍되면 React는 준비가 될 때까지 여전히 데이터가 필요한 구성 요소 렌더링을 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="59875a596212e2630b1312f26132c57404e3b897" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rendering component trees&lt;/strong&gt; in a simplified test environment and asserting on their output.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;단순화 된 테스트 환경에서 &lt;strong&gt;컴포넌트 트리 렌더링&lt;/strong&gt; 및 출력에 대한 주장.</target>
        </trans-unit>
        <trans-unit id="ef8e6a01172699bc5f0e6bf87921f99d01a5d5b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running a complete app&lt;/strong&gt; in a realistic browser environment (also known as &amp;ldquo;end-to-end&amp;rdquo; tests).</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;현실적인 브라우저 환경에서 &lt;strong&gt;완벽한 앱 실행&lt;/strong&gt; (&amp;ldquo;엔드 투 엔드&amp;rdquo;테스트라고도 함).</target>
        </trans-unit>
        <trans-unit id="dd1d7f873fc7d86183877a294288c695908975d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Skeleton:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; inside.</source>
          <target state="translated">&lt;strong&gt;스켈레톤 : &lt;/strong&gt; &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; 있는 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 구성 요소 가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf6928b68eec4860f3c701c962c2c5c91504b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Start rendering&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;렌더링 시작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0371cc9bcdb0694f3886267bfe248a16d117874e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1:&lt;/strong&gt; Run &lt;code&gt;npm init -y&lt;/code&gt; (if it fails, &lt;a href=&quot;https://gist.github.com/gaearon/246f6380610e262f8a648e3e51cad40d&quot;&gt;here&amp;rsquo;s a fix&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;1 단계 : &lt;/strong&gt; &lt;code&gt;npm init -y&lt;/code&gt; 실행 (실패한 경우 &lt;a href=&quot;https://gist.github.com/gaearon/246f6380610e262f8a648e3e51cad40d&quot;&gt;수정 사항이 있습니다&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8f716f702f35af4f753d17675302facfc3c2cc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2:&lt;/strong&gt; Run &lt;code&gt;npm install babel-cli@6 babel-preset-react-app@3&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;2 단계 :&lt;/strong&gt; 실행 &lt;code&gt;npm install babel-cli@6 babel-preset-react-app@3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5517d6c3afae89c3d0e1c021b59dbb96b412cbe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String and numbers.&lt;/strong&gt; These are rendered as text nodes in the DOM.</source>
          <target state="translated">&lt;strong&gt;문자열과 숫자. &lt;/strong&gt;이들은 DOM에서 텍스트 노드로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d81c33b7be05b010f25ae0f331129783763b119d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR: There are no plans to remove classes from React.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR : React에서 클래스를 제거 할 계획이 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e63816b1ae56ff8db5359421b2c8504cffc8456" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The code demos on this page use a &amp;ldquo;fake&amp;rdquo; API implementation rather than Relay.&lt;/strong&gt; This makes them easier to understand if you&amp;rsquo;re not familiar with GraphQL, but they won&amp;rsquo;t tell you the &amp;ldquo;right way&amp;rdquo; to build an app with Suspense. This page is more conceptual and is intended to help you see &lt;em&gt;why&lt;/em&gt; Suspense works in a certain way, and which problems it solves.</source>
          <target state="translated">&lt;strong&gt;이 페이지의 코드 데모는 Relay 대신 &quot;가짜&quot;API 구현을 사용합니다. &lt;/strong&gt;그래야 GraphQL에 익숙하지 않은 경우 이해하기 쉬워 지지만 Suspense를 사용하여 앱을 구축하는&amp;ldquo;올바른 방법&amp;rdquo;을 알려주지는 않습니다. 이 페이지는보다 개념적이고 Suspense가 특정 방식으로 작동하는 &lt;em&gt;이유&lt;/em&gt; 와 해결되는 문제 를 확인하는 데 도움이 됩니다.</target>
        </trans-unit>
        <trans-unit id="0b1010c4b7176541b267d2c7954f323616622e2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The first common use case is when creating the initial state is expensive:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;첫 번째 일반적인 사용 사례는 초기 상태를 만드는 데 비용이 많이 드는 경우입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e675dad06f70c50575272302659644553554d66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only officially supported release channel for user-facing applications is Latest&lt;/strong&gt;. Next and Experimental releases are provided for testing purposes only, and we provide no guarantees that behavior won&amp;rsquo;t change between releases. They do not follow the semver protocol that we use for releases from Latest.</source>
          <target state="translated">&lt;strong&gt;사용자 용 응용 프로그램에 대해 공식적으로 지원되는 유일한 릴리스 채널은 최신&lt;/strong&gt; 입니다. 다음 및 실험용 릴리스는 테스트 목적으로 만 제공되며 릴리스간에 동작이 변경되지 않는다는 보장은 없습니다. 최신 버전의 릴리스에 사용하는 semver 프로토콜을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="833be86e96773e99b79bcbd6beed6db864061c08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The recommended fix is to move that function &lt;em&gt;inside&lt;/em&gt; of your effect&lt;/strong&gt;. That makes it easy to see which props or state your effect uses, and to ensure they&amp;rsquo;re all declared:</source>
          <target state="translated">&lt;strong&gt;권장되는 수정은 해당 기능을 효과 &lt;em&gt;내부&lt;/em&gt; 로 옮기는 것입니다&lt;/strong&gt; . 이를 통해 효과가 어떤 소품이나 상태를 사용하는지 쉽게 확인하고 모두 선언되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ec0e2e1f610466ed7ccdbe7507befa86725218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no plans to remove classes from React.&lt;/strong&gt; You can read more about the gradual adoption strategy for Hooks in the &lt;a href=&quot;#gradual-adoption-strategy&quot;&gt;bottom section&lt;/a&gt; of this page.</source>
          <target state="translated">&lt;strong&gt;React에서 클래스를 제거 할 계획이 없습니다. &lt;/strong&gt;이 페이지 의 &lt;a href=&quot;#gradual-adoption-strategy&quot;&gt;하단 섹션&lt;/a&gt; 에서 후크에 대한 점진적 채택 전략에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d948783029575274087a10b2b166d5f5e2e50fbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no semantic versioning guarantees for the experimental builds.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실험 빌드에 대한 시맨틱 버전 관리 보장은 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22c80b00bd6df490cfa29bc2d05f84fb6423f5bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is why Hooks must be called on the top level of our components.&lt;/strong&gt; If we want to run an effect conditionally, we can put that condition &lt;em&gt;inside&lt;/em&gt; our Hook:</source>
          <target state="translated">&lt;strong&gt;이것이 바로 컴포넌트의 최상위 레벨에서 후크를 호출해야하는 이유입니다. &lt;/strong&gt;조건부로 효과를 실행하려면 해당 조건을 후크 &lt;em&gt;안에&lt;/em&gt; 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="457992c4bac0fe2813cedca6bef0b7429569609e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will enable Concurrent Mode for the whole &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; tree:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전체 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 트리에 대해 동시 모드를 활성화 합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41f76348ba946b3228eb0c7261268bf29f416bb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tip:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf7022720600576290837b09f637a4cbc813dc32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To explain Concurrent Mode, we&amp;rsquo;ll use version control as a metaphor.&lt;/strong&gt; If you work on a team, you probably use a version control system like Git and work on branches. When a branch is ready, you can merge your work into master so that other people can pull it.</source>
          <target state="translated">&lt;strong&gt;동시 모드를 설명하기 위해 버전 제어를 은유로 사용합니다. &lt;/strong&gt;팀에서 일한다면 아마도 Git과 같은 버전 관리 시스템을 사용하고 지점에서 일할 것입니다. 지점이 준비되면 다른 사람이 가져올 수 있도록 작업을 마스터로 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab520ae66b9b186e3a45be812567a1f64882757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try it on CodePen&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CodePen에서 사용해보십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bbb893f7bb44a32f19ac7257b622e9045611025" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undocumented APIs and internal data structures.&lt;/strong&gt; If you access internal property names like &lt;code&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt; or &lt;code&gt;__reactInternalInstance$uk43rzhitjg&lt;/code&gt;, there is no warranty. You are on your own.</source>
          <target state="translated">&lt;strong&gt;문서화되지 않은 API 및 내부 데이터 구조 &lt;/strong&gt; &lt;code&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt; 또는 &lt;code&gt;__reactInternalInstance$uk43rzhitjg&lt;/code&gt; 와 같은 내부 속성 이름에 액세스하는 경우 보증이 없습니다. 당신은 당신의 자신에 있습니다.</target>
        </trans-unit>
        <trans-unit id="251436bcf1a85c83d8711b39296fe259fc9d0256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3315a151135342e4109a199297933204d1615fae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We also found numerous issues in codebases using mixins, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;and don&amp;rsquo;t recommend using them in the new code&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;우리는 또한 mixin을 사용하는 코드베이스에서 많은 문제를 발견했으며 &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;새로운 코드에서는 사용하지 않는 것이 좋습니다&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fe850f519c6af191610d343cf20a694dc8e3c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We strongly recommend against creating your own base component classes.&lt;/strong&gt; In React components, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;code reuse is primarily achieved through composition rather than inheritance&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;자체 기본 컴포넌트 클래스를 작성하지 않는 것이 좋습니다. &lt;/strong&gt;React 컴포넌트에서 &lt;a href=&quot;composition-vs-inheritance&quot;&gt;코드 재사용은 주로 상속이 아닌 컴포지션을 통해 달성됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb8066b79ef2fb681d3c517cb7fabd60caf3330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What do we pass to &lt;code&gt;useState&lt;/code&gt; as an argument?&lt;/strong&gt; The only argument to the &lt;code&gt;useState()&lt;/code&gt; Hook is the initial state. Unlike with classes, the state doesn&amp;rsquo;t have to be an object. We can keep a number or a string if that&amp;rsquo;s all we need. In our example, we just want a number for how many times the user clicked, so pass &lt;code&gt;0&lt;/code&gt; as initial state for our variable. (If we wanted to store two different values in state, we would call &lt;code&gt;useState()&lt;/code&gt; twice.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useState&lt;/code&gt; 를 인수로 전달할 내용은 무엇입니까 ? &lt;/strong&gt; &lt;code&gt;useState()&lt;/code&gt; 후크에 대한 유일한 인수 는 초기 상태입니다. 클래스와 달리 상태는 객체 일 필요는 없습니다. 필요한 경우 숫자 나 문자열을 유지할 수 있습니다. 이 예에서는 사용자가 몇 번 클릭했는지 숫자를 원하므로 &lt;code&gt;0&lt;/code&gt; 을 변수의 초기 상태로 전달 하십시오. (상태에 두 개의 다른 값을 저장하려면 &lt;code&gt;useState()&lt;/code&gt; 두 번 호출 합니다.)</target>
        </trans-unit>
        <trans-unit id="08cc1b1443b10924f9c311035a0c2b2fbd0c6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useEffect&lt;/code&gt; do?&lt;/strong&gt; By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we&amp;rsquo;ll refer to it as our &amp;ldquo;effect&amp;rdquo;), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useEffect&lt;/code&gt; 의 기능 은 무엇입니까 ?&lt;/strong&gt; 이 후크를 사용하면 렌더링 후 컴포넌트가 무언가를 수행해야한다고 React에 알립니다. React는 전달한 함수를 기억하고 (이를 &quot;효과&quot;라고 ​​함) DOM 업데이트를 수행 한 후 나중에 호출합니다. 이로 인해 문서 제목을 설정했지만 데이터 가져 오기를 수행하거나 다른 명령형 API를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3cf393c888af0299ee4ba4fa1c61899ebde2820" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useState&lt;/code&gt; return?&lt;/strong&gt; It returns a pair of values: the current state and a function that updates it. This is why we write &lt;code&gt;const [count, setCount] = useState()&lt;/code&gt;. This is similar to &lt;code&gt;this.state.count&lt;/code&gt; and &lt;code&gt;this.setState&lt;/code&gt; in a class, except you get them in a pair. If you&amp;rsquo;re not familiar with the syntax we used, we&amp;rsquo;ll come back to it &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;at the bottom of this page&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useState&lt;/code&gt; 는 무엇을 반환합니까?&lt;/strong&gt; 현재 상태와이를 업데이트하는 함수의 값 쌍을 반환합니다. 이것이 &lt;code&gt;const [count, setCount] = useState()&lt;/code&gt; 작성하는 이유 입니다. 이것은 클래스에서 &lt;code&gt;this.state.count&lt;/code&gt; 및 &lt;code&gt;this.setState&lt;/code&gt; 와 유사하지만 한 쌍으로 가져옵니다. 우리가 사용한 구문에 익숙하지 않다면 &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;이 페이지의 하단에&lt;/a&gt; 있는 구문으로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="354dbe01dc555e8df6bfd26b70a9485c432f5145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does calling &lt;code&gt;useState&lt;/code&gt; do?&lt;/strong&gt; It declares a &amp;ldquo;state variable&amp;rdquo;. Our variable is called &lt;code&gt;count&lt;/code&gt; but we could call it anything else, like &lt;code&gt;banana&lt;/code&gt;. This is a way to &amp;ldquo;preserve&amp;rdquo; some values between the function calls &amp;mdash; &lt;code&gt;useState&lt;/code&gt; is a new way to use the exact same capabilities that &lt;code&gt;this.state&lt;/code&gt; provides in a class. Normally, variables &amp;ldquo;disappear&amp;rdquo; when the function exits but state variables are preserved by React.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useState&lt;/code&gt; 호출은 무엇을 합니까? &lt;/strong&gt;&quot;상태 변수&quot;를 선언합니다. 변수는 &lt;code&gt;count&lt;/code&gt; 라고 하지만 &lt;code&gt;banana&lt;/code&gt; 와 같은 다른 이름으로 부를 수 있습니다. -이 함수 호출 사이에 값 &quot;보존&quot;하는 방법입니다 &lt;code&gt;useState&lt;/code&gt; 이 있는 동일한 기능을 사용하는 새로운 방법입니다 &lt;code&gt;this.state&lt;/code&gt; 이 클래스에서 제공합니다. 일반적으로, 함수가 종료되지만 상태 변수는 React에 의해 유지 될 때 변수가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="72b30a539485d9441d425ec2b3084bed953a6014" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Hook?&lt;/strong&gt; A Hook is a special function that lets you &amp;ldquo;hook into&amp;rdquo; React features. For example, &lt;code&gt;useState&lt;/code&gt; is a Hook that lets you add React state to function components. We&amp;rsquo;ll learn other Hooks later.</source>
          <target state="translated">&lt;strong&gt;후크 란? &lt;/strong&gt;후크는 React 기능을 &quot;후크&quot;할 수있는 특수 기능입니다. 예를 들어, &lt;code&gt;useState&lt;/code&gt; 는 함수 구성 요소에 반응 상태를 추가 할 수있는 후크입니다. 우리는 나중에 다른 갈고리를 배울 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d1323a7f8fa9d21c7047d996ddcd7eff22d6128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When exactly does React clean up an effect?&lt;/strong&gt; React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React &lt;em&gt;also&lt;/em&gt; cleans up effects from the previous render before running the effects next time. We&amp;rsquo;ll discuss &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;why this helps avoid bugs&lt;/a&gt; and &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to opt out of this behavior in case it creates performance issues&lt;/a&gt; later below.</source>
          <target state="translated">&lt;strong&gt;React는 언제 효과를 정리합니까? &lt;/strong&gt;구성 요소를 마운트 해제하면 React가 정리를 수행합니다. 그러나 앞에서 배운 것처럼 효과는 한 번이 아니라 모든 렌더링에 대해 실행됩니다. 반작용이 이유입니다 &lt;em&gt;또한&lt;/em&gt; 효과 다음 번에 실행하기 전에 렌더링 이전에서 효과를 정리합니다. 우리는 논의 할 것이다 &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;이 피 버그를하는 데 도움이 왜&lt;/a&gt; 그리고 &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;어떻게 성능 문제를 생성하는 경우에 이러한 동작 옵트 아웃&lt;/a&gt; 나중에 아래.</target>
        </trans-unit>
        <trans-unit id="fde62d7c7740df72ba1511cc47dfdde7083bb226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When would I use a Hook?&lt;/strong&gt; If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We&amp;rsquo;re going to do that right now!</source>
          <target state="translated">&lt;strong&gt;언제 후크를 사용합니까? &lt;/strong&gt;함수 구성 요소를 작성하고 상태를 추가해야한다는 것을 인식 한 경우 이전에이를 클래스로 변환해야했습니다. 이제 기존 함수 구성 요소 내에서 후크를 사용할 수 있습니다. 우리는 지금 그렇게 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="d77e9a40ceae40917829155eaf3e70dcfc6d5018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When you start using &lt;code&gt;forwardRef&lt;/code&gt; in a component library, you should treat it as a breaking change and release a new major version of your library.&lt;/strong&gt; This is because your library likely has an observably different behavior (such as what refs get assigned to, and what types are exported), and this can break apps and other libraries that depend on the old behavior.</source>
          <target state="translated">&lt;strong&gt;구성 요소 라이브러리에서 &lt;code&gt;forwardRef&lt;/code&gt; 를 사용하기 시작하면이를 주요 변경 사항으로 취급하고 라이브러리의 새 주요 버전을 릴리스해야합니다. &lt;/strong&gt;이는 라이브러리에 ref가 할당되는 유형 및 내보내는 유형과 같이 동작이 눈에 띄게 다르기 때문에 이전 동작에 의존하는 앱 및 기타 라이브러리가 손상 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3b061fc322314c21cd70363d5878e9efe3d1bc85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why did we return a function from our effect?&lt;/strong&gt; This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They&amp;rsquo;re part of the same effect!</source>
          <target state="translated">&lt;strong&gt;효과에서 함수를 반환 한 이유는 무엇입니까? &lt;/strong&gt;이것은 효과에 대한 선택적 정리 메커니즘입니다. 모든 효과는 그 후 정리되는 함수를 반환 할 수 있습니다. 이를 통해 구독 추가 및 제거에 대한 논리를 서로 가깝게 유지할 수 있습니다. 그들은 같은 효과의 일부입니다!</target>
        </trans-unit>
        <trans-unit id="69ee54aaf8bb63d623d0a66010f960ccc989763a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is &lt;code&gt;useEffect&lt;/code&gt; called inside a component?&lt;/strong&gt; Placing &lt;code&gt;useEffect&lt;/code&gt; inside the component lets us access the &lt;code&gt;count&lt;/code&gt; state variable (or any props) right from the effect. We don&amp;rsquo;t need a special API to read it &amp;mdash; it&amp;rsquo;s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.</source>
          <target state="translated">&lt;strong&gt;컴포넌트 내에서 &lt;code&gt;useEffect&lt;/code&gt; 가 호출되는 이유는 무엇 입니까? &lt;/strong&gt;배치 &lt;code&gt;useEffect&lt;/code&gt; 를 구성 요소의 내부 것은 우리가 액세스 할 수 있습니다 &lt;code&gt;count&lt;/code&gt; 바로 효과에서 상태 변수 (또는 소품). 우리는 그것을 읽기 위해 특별한 API가 필요하지 않습니다 &amp;ndash; 이미 함수 범위 안에 있습니다. 후크는 JavaScript 클로저를 수용하고 JavaScript가 이미 솔루션을 제공하는 React 관련 API를 도입하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="55112c588a6b25d6c0aac03c1dacd1196aed574f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With Suspense, we don&amp;rsquo;t wait for the response to come back before we start rendering.&lt;/strong&gt; In fact, we start rendering &lt;em&gt;pretty much immediately&lt;/em&gt; after kicking off the network request:</source>
          <target state="translated">&lt;strong&gt;Suspense를 사용하면 렌더링을 시작하기 전에 응답이 다시 올 때까지 기다리지 않습니다. &lt;/strong&gt;실제로 네트워크 요청을 시작한 &lt;em&gt;직후에 거의&lt;/em&gt; 렌더링을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="4117ea3d6710579e11068515fbe72df2387680c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can skip to the next page explaining how to write &lt;a href=&quot;hooks-custom&quot;&gt;your own Hooks&lt;/a&gt; now.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining the reasoning behind these rules.</source>
          <target state="translated">&lt;strong&gt;지금 &lt;a href=&quot;hooks-custom&quot;&gt;자신의 후크&lt;/a&gt; 를 작성하는 방법을 설명하는 다음 페이지로 건너 뛸 수 있습니다 . &lt;/strong&gt;이 페이지에서는 이러한 규칙의 이유를 계속 설명합니다.</target>
        </trans-unit>
        <trans-unit id="db0df7a56cf2c82421e1d3a1858affb8c698d3d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can start learning Hooks &lt;a href=&quot;hooks-overview&quot;&gt;on the next page&lt;/a&gt;.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining why we&amp;rsquo;re adding Hooks to React and how they can help you write great applications.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;hooks-overview&quot;&gt;다음 페이지에서&lt;/a&gt; 후크 학습을 시작할 수 있습니다 . &lt;/strong&gt;이 페이지에서는 후크에 React에 추가하는 이유와 훌륭한 응용 프로그램 작성에 도움이되는 방법에 대해 계속 설명합니다.</target>
        </trans-unit>
        <trans-unit id="27b3a573e5be9d1bc32968e23c562ddb2f82c8cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can try moving that function outside of your component&lt;/strong&gt;. In that case, the function is guaranteed to not reference any props or state, and also doesn&amp;rsquo;t need to be in the list of dependencies.</source>
          <target state="translated">&lt;strong&gt;해당 기능을 컴포넌트 외부로 이동해 볼 수 있습니다&lt;/strong&gt; . 이 경우 함수는 props 또는 state를 참조하지 않으며, 종속성 목록에있을 필요도 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a932ee6c57456f06d1bc9f032661d04172ebf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances.</source>
          <target state="translated">&lt;strong&gt;함수 컴포넌트 &lt;code&gt;ref&lt;/code&gt; &lt;/strong&gt; 에는 인스턴스가 없기 때문에 &lt;strong&gt;ref&lt;/strong&gt;&lt;strong&gt; 속성을 &lt;/strong&gt;&lt;strong&gt;사용할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bac60cacb0879e4c86951058b8760f2aae663d1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance.</source>
          <target state="translated">&lt;strong&gt;의미 보장이 아닌 성능 최적화로 &lt;code&gt;useMemo&lt;/code&gt; 를 사용할 수 있습니다 .&lt;/strong&gt; 향후 React는 이전에 메모 한 일부 값을 &quot;잊어 버리고&quot;다음 렌더링시이를 다시 계산하도록 선택할 수 있습니다 (예 : 오프 스크린 구성 요소에 대한 메모리 확보). &lt;code&gt;useMemo&lt;/code&gt; 없이도 작동하도록 코드를 작성한 다음 추가하여 성능을 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="05b66c43e435b31f16f17afdeb55bafbbc36cbfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance. (For rare cases when a value must &lt;em&gt;never&lt;/em&gt; be recomputed, you can &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazily initialize&lt;/a&gt; a ref.)</source>
          <target state="translated">&lt;strong&gt;의미 보장이 아닌 성능 최적화로 &lt;code&gt;useMemo&lt;/code&gt; 를 사용할 수 있습니다 . &lt;/strong&gt;향후 React는 이전에 메모 한 일부 값을 &quot;잊어 버리고&quot;다음 번 렌더링시 다시 계산하도록 선택할 수 있습니다 (예 : 오프 스크린 구성 요소에 대한 메모리 확보). &lt;code&gt;useMemo&lt;/code&gt; 없이도 작동하도록 코드를 작성한 다음 추가하여 성능을 최적화하십시오. (값을 다시 계산 &lt;em&gt;하지&lt;/em&gt; 않아야 하는 드문 경우에 , 참조를 &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;느리게 초기화&lt;/a&gt; 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="37fbfbf8015919f25ca15b9ef6450f01458edeeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You might also occasionally want to avoid re-creating the &lt;code&gt;useRef()&lt;/code&gt; initial value.&lt;/strong&gt; For example, maybe you want to ensure some imperative class instance only gets created once:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useRef()&lt;/code&gt; 초기 값을 다시 작성하지 않으려는 경우가 있습니다 . &lt;/strong&gt;예를 들어, 명령형 클래스 인스턴스가 한 번만 작성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df3c1d271fd9a73acaa1ffa338f3130b66489579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;debouncing&lt;/strong&gt;: publish changes after a period of inactivity (eg &lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt;&lt;code&gt;_.debounce&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;디 바운싱&lt;/strong&gt; : 일정 기간 동안 변경 사항을 공개 (예 : &lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt; &lt;code&gt;_.debounce&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="04a50caee20c00784555dd9a1adc5ebe8b987a31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fallback&lt;/strong&gt; takes a loading indicator. The fallback is shown until all of the children of the &lt;code&gt;Suspense&lt;/code&gt; component have finished rendering.</source>
          <target state="translated">&lt;strong&gt;대체&lt;/strong&gt; 는로드 표시기를 사용합니다. 대체는 &lt;code&gt;Suspense&lt;/code&gt; 구성 요소 의 모든 하위 렌더링이 완료 될 때까지 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="c2daf8e726ce9e46ec9eba873d089bc1299edffa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revealOrder (forwards, backwards, together)&lt;/strong&gt; defines the order in which the &lt;code&gt;SuspenseList&lt;/code&gt; children should be revealed.</source>
          <target state="translated">&lt;strong&gt;revealOrder (앞뒤로)&lt;/strong&gt; 는 &lt;code&gt;SuspenseList&lt;/code&gt; 하위 항목을 공개해야하는 순서를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a94bf5c1efb78639d8a6038fccdfa0588e24e404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tail (collapsed, hidden)&lt;/strong&gt; dictates how unloaded items in a &lt;code&gt;SuspenseList&lt;/code&gt; is shown.</source>
          <target state="translated">&lt;strong&gt;tail (축소, 숨김)&lt;/strong&gt; 은 &lt;code&gt;SuspenseList&lt;/code&gt; 에서 언로드 된 항목 이 표시 되는 방법을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fd849d720c770d8612b3f4538015dad929400340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-context.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-context.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a02cb450d909fd579e5b2ae0fd1763e854cafb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a52ff82a2242c204ebc842f2305e63bb53f8de27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;themed-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;themed-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f4a9ea77788f2d5ab469332cdd45c9f826549b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;throttling&lt;/strong&gt;: sample changes based on a time based frequency (eg &lt;a href=&quot;https://lodash.com/docs#throttle&quot;&gt;&lt;code&gt;_.throttle&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;조절&lt;/strong&gt; : 시간 기반 빈도 (예 : &lt;a href=&quot;https://lodash.com/docs#throttle&quot;&gt; &lt;code&gt;_.throttle&lt;/code&gt; &lt;/a&gt; )에 따라 샘플 변경</target>
        </trans-unit>
        <trans-unit id="03b9f4e1bd226ee0dfc7502a4ce092999cc7357e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unstable_avoidThisFallback&lt;/strong&gt; takes a boolean. It tells React whether to &amp;ldquo;skip&amp;rdquo; revealing this boundary during the initial load. This API will likely be removed in a future release.</source>
          <target state="translated">&lt;strong&gt;unstable_avoidThisFallback&lt;/strong&gt; 은 부울을 사용합니다. React에 초기로드 중에이 경계를 &quot;스킵&quot;해야하는지 여부를 알려줍니다. 이 API는 향후 릴리스에서 제거 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4396e0866aedabc957f13f58ab2a121c46fb5df" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating arrays of elements. Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside an array to give the elements a stable identity.</source>
          <target state="translated">&amp;ldquo;키&amp;rdquo;는 요소 배열을 만들 때 포함해야하는 특수 문자열 속성입니다. 키는 React가 어떤 항목이 변경, 추가 또는 제거되었는지 식별하는 데 도움이됩니다. 배열 내부의 요소에 키를 지정하여 요소를 안정적으로 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d5507391adb53c909f54923d498a12d34d2604e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Parent&lt;/code&gt; component in &lt;code&gt;#app-root&lt;/code&gt; would be able to catch an uncaught, bubbling event from the sibling node &lt;code&gt;#modal-root&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#app-root&lt;/code&gt; 의 &lt;code&gt;Parent&lt;/code&gt; 구성 요소 는 형제 노드 &lt;code&gt;#modal-root&lt;/code&gt; 에서 포착되지 않은 버블 링 이벤트를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a4c644e46603eb49da231fabb3aba4672633975" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Profiler&lt;/code&gt; can be added anywhere in a React tree to measure the cost of rendering that part of the tree. It requires two props: an &lt;code&gt;id&lt;/code&gt; (string) and an &lt;code&gt;onRender&lt;/code&gt; callback (function) which React calls any time a component within the tree &amp;ldquo;commits&amp;rdquo; an update.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; a는 나무의 일부 렌더링의 비용을 측정하기 위해 트리 반응 어디서나 추가 할 수 있습니다. 두 가지 소품이 필요합니다. &lt;code&gt;id&lt;/code&gt; (문자열)와 &lt;code&gt;onRender&lt;/code&gt; 콜백 (함수)은 트리 내의 구성 요소가 업데이트를 &quot;커밋&quot;할 때마다 React가 호출합니다.</target>
        </trans-unit>
        <trans-unit id="68c1768f3dce908aee0bd93c6ee78eb216e2dd9d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bundler&lt;/strong&gt;, such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; or &lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;. It lets you write modular code and bundle it together into small packages to optimize load time.</source>
          <target state="translated">&lt;strong&gt;들러&lt;/strong&gt; 같은, &lt;a href=&quot;https://webpack.js.org/&quot;&gt;웹팩&lt;/a&gt; 또는 &lt;a href=&quot;https://parceljs.org/&quot;&gt;소포&lt;/a&gt; . 모듈 식 코드를 작성하고 작은 패키지로 묶어로드 시간을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cf7b6e755026fcd351344960113414c207b074" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;compiler&lt;/strong&gt; such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;. It lets you write modern JavaScript code that still works in older browsers.</source>
          <target state="translated">&lt;strong&gt;컴파일러&lt;/strong&gt; 와 같은 &lt;a href=&quot;https://babeljs.io/&quot;&gt;바벨&lt;/a&gt; . 이전 브라우저에서도 여전히 작동하는 최신 JavaScript 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19def0eea706ffad262477b4a7266b48bc58b1f7" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;package manager&lt;/strong&gt;, such as &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</source>
          <target state="translated">&lt;strong&gt;패키지 관리자&lt;/strong&gt; 등, &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;실&lt;/a&gt; 또는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;NPM&lt;/a&gt; . 광범위한 타사 패키지 에코 시스템을 활용하고 쉽게 설치 또는 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96235b0ccc55b6e0f1b884d0362152d81c4afc7c" translate="yes" xml:space="preserve">
          <source>A Brief Interlude: Props vs State</source>
          <target state="translated">간단한 막간 : 소품 대 상태</target>
        </trans-unit>
        <trans-unit id="64f56c1cd7ae520f69ddd496d0b3b3f84a4ce199" translate="yes" xml:space="preserve">
          <source>A JavaScript build toolchain typically consists of:</source>
          <target state="translated">JavaScript 빌드 툴체인은 일반적으로 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0a2ff8c4a07995be5a094f31a6fa10ae8186c90c" translate="yes" xml:space="preserve">
          <source>A JavaScript compiler takes JavaScript code, transforms it and returns JavaScript code in a different format. The most common use case is to take ES6 syntax and transform it into syntax that older browsers are capable of interpreting. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; is the compiler most commonly used with React.</source>
          <target state="translated">JavaScript 컴파일러는 JavaScript 코드를 가져 와서 변환하고 다른 형식으로 JavaScript 코드를 반환합니다. 가장 일반적인 사용 사례는 ES6 구문을 사용하여 이전 브라우저가 해석 할 수있는 구문으로 변환하는 것입니다. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 은 React에서 가장 일반적으로 사용되는 컴파일러입니다.</target>
        </trans-unit>
        <trans-unit id="5ba094cb88b0d39ff6d72e4edcee7588dec33ab9" translate="yes" xml:space="preserve">
          <source>A JavaScript error in a part of the UI shouldn&amp;rsquo;t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an &amp;ldquo;error boundary&amp;rdquo;.</source>
          <target state="translated">UI의 일부에서 JavaScript 오류가 전체 앱을 중단하지 않아야합니다. React 사용자를위한이 문제를 해결하기 위해 React 16에는 새로운&amp;ldquo;오류 경계&amp;rdquo;개념이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b3b93719c6a8e6d9963a816d3528e59fa4d5652" translate="yes" xml:space="preserve">
          <source>A React component can also return an array of elements:</source>
          <target state="translated">React 컴포넌트는 또한 요소의 배열을 반환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e891be46d04c0877782b77916e5618821ec4a760" translate="yes" xml:space="preserve">
          <source>A React component that subscribes to context changes. This lets you subscribe to a context within a &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;function component&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 변경을 구독하는 React 컴포넌트. 이를 통해 &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;함수 구성 요소&lt;/a&gt; 내의 컨텍스트를 구독 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9982b82aa59906a97608a00f88f8eee9e247b7fb" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;a href=&quot;react-component#static-getderivedstatefromerror&quot;&gt;&lt;code&gt;static getDerivedStateFromError()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#componentdidcatch&quot;&gt;&lt;code&gt;componentDidCatch()&lt;/code&gt;&lt;/a&gt;. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to render a fallback UI after an error has been thrown. Use &lt;code&gt;componentDidCatch()&lt;/code&gt; to log error information.</source>
          <target state="translated">라이프 사이클 메소드 &lt;a href=&quot;react-component#static-getderivedstatefromerror&quot;&gt; &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;react-component#componentdidcatch&quot;&gt; &lt;code&gt;componentDidCatch()&lt;/code&gt; &lt;/a&gt; 중 하나 (또는 ​​둘 다)를 정의하는 경우 클래스 컴포넌트는 오류 경계가됩니다 . 사용 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 오류가 발생 된 후 대체 UI를 렌더링합니다. &lt;code&gt;componentDidCatch()&lt;/code&gt; 를 사용 하여 오류 정보를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="85946ad755462c6c51d3003b0b5ca19b87d38d55" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; or &lt;code&gt;componentDidCatch()&lt;/code&gt;. Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.</source>
          <target state="translated">라이프 사이클 메소드 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 또는 &lt;code&gt;componentDidCatch()&lt;/code&gt; 중 하나 (또는 ​​둘 다)를 정의하는 경우 클래스 컴포넌트는 오류 경계가됩니다 . 이러한 수명주기에서 상태를 업데이트하면 아래 트리에서 처리되지 않은 JavaScript 오류를 캡처하고 대체 UI를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52d7fd44264f048dd94bcae57b891f7bc6c4c24c" translate="yes" xml:space="preserve">
          <source>A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.</source>
          <target state="translated">React의 일반적인 패턴은 구성 요소가 여러 요소를 반환하는 것입니다. 단편을 사용하면 DOM에 추가 노드를 추가하지 않고 하위 목록을 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3fb50c201a6d66a5fcbfd9121e149c289c8e81" translate="yes" xml:space="preserve">
          <source>A common pattern in older web applications is to describe chunks of the DOM as a string and insert it into the DOM like so: &lt;code&gt;$el.html(htmlString)&lt;/code&gt;. These points in a codebase are perfect for introducing React. Just rewrite the string based rendering as a React component.</source>
          <target state="translated">이전 웹 애플리케이션에서 공통적 인 패턴은 DOM 청크를 문자열로 설명하고 &lt;code&gt;$el.html(htmlString)&lt;/code&gt; 과 같이 DOM에 삽입하는 것 입니다. 코드베이스의 이러한 점은 React를 소개하는 데 적합합니다. 문자열 기반 렌더링을 React 컴포넌트로 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6050d5add6fcce04dd500fe62b6c7f840b515f88" translate="yes" xml:space="preserve">
          <source>A common pattern is for a component to return a list of children. Take this example React snippet:</source>
          <target state="translated">일반적인 패턴은 구성 요소가 하위 목록을 반환하는 것입니다. 이 예제를 사용하십시오 .React snippet :</target>
        </trans-unit>
        <trans-unit id="65d043fa25657a2dd048fe1f4a69d7cea6fdb937" translate="yes" xml:space="preserve">
          <source>A common use case is to access a child imperatively:</source>
          <target state="translated">일반적인 사용 사례는 자녀에게 반드시 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ac97e10cda00357023f8dac7efaa9d43739b09" translate="yes" xml:space="preserve">
          <source>A common way to do it is to use a pair of &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; blocks so that they&amp;rsquo;ll always run and isolate the effects of a test to itself:</source>
          <target state="translated">이를 수행하는 일반적인 방법은 &lt;code&gt;beforeEach&lt;/code&gt; 및 &lt;code&gt;afterEach&lt;/code&gt; 블록 쌍을 사용하여 항상 테스트 효과를 자체적으로 실행하고 격리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1463f438d6ad9ac7e893664c5d8497426b352e6d" translate="yes" xml:space="preserve">
          <source>A common way to fetch data in React apps today is to use an effect:</source>
          <target state="translated">오늘날 React 앱에서 데이터를 가져 오는 일반적인 방법은 다음과 같은 효과를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa1123c7526ebd12d2e2469e1d65f5bf044f401d" translate="yes" xml:space="preserve">
          <source>A common way to work around the stutter is to &amp;ldquo;debounce&amp;rdquo; the input. When debouncing, we only update the list &lt;em&gt;after&lt;/em&gt; the user stops typing. However, it can be frustrating that the UI doesn&amp;rsquo;t update while we&amp;rsquo;re typing. As an alternative, we could &amp;ldquo;throttle&amp;rdquo; the input, and update the list with a certain maximum frequency. But then on lower-powered devices we&amp;rsquo;d still end up with stutter. Both debouncing and throttling create a suboptimal user experience.</source>
          <target state="translated">말더듬을 해결하는 일반적인 방법은 입력을 &quot;공지&quot;하는 것입니다. 수신 거부시 사용자가 입력을 중지 &lt;em&gt;한 후에&lt;/em&gt; 만 목록 &lt;em&gt;을&lt;/em&gt; 업데이트합니다 . 그러나 입력하는 동안 UI가 업데이트되지 않는 것은 실망 스러울 수 있습니다. 대안으로, 입력을 &quot;스로틀&quot;하고 특정 최대 주파수로 목록을 업데이트 할 수 있습니다. 그러나 저전력 장치에서 우리는 여전히 말더듬으로 끝납니다. 디 바운싱 및 스로틀 링 모두 최적의 사용자 환경을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="37ef2bdd655361b4730c3f316a3739e3cdb6810b" translate="yes" xml:space="preserve">
          <source>A component calling &lt;code&gt;useContext&lt;/code&gt; will always re-render when the context value changes. If re-rendering the component is expensive, you can &lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot;&gt;optimize it by using memoization&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 값이 변경되면 &lt;code&gt;useContext&lt;/code&gt; 를 호출하는 컴포넌트 는 항상 다시 렌더링됩니다. 구성 요소를 다시 렌더링하는 데 비용이 많이 드는 경우 &lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot;&gt;memoization을 사용하여&lt;/a&gt; 구성 요소를 최적화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="670684fa7013fe74073182e631f8d2bda028e63c" translate="yes" xml:space="preserve">
          <source>A component may choose to pass its state down as props to its child components:</source>
          <target state="translated">구성 요소는 하위 구성 요소에 대한 소품으로 상태를 전달하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de4d88745cc6194329485bff9e02c89f8a50c7dc" translate="yes" xml:space="preserve">
          <source>A component needs &lt;code&gt;state&lt;/code&gt; when some data associated with it changes over time. For example, a &lt;code&gt;Checkbox&lt;/code&gt; component might need &lt;code&gt;isChecked&lt;/code&gt; in its state, and a &lt;code&gt;NewsFeed&lt;/code&gt; component might want to keep track of &lt;code&gt;fetchedPosts&lt;/code&gt; in its state.</source>
          <target state="translated">구성 요소는 시간이 지남에 따라 연관된 일부 데이터가 변경 될 때 &lt;code&gt;state&lt;/code&gt; 가 필요합니다 . 예를 들어 &lt;code&gt;Checkbox&lt;/code&gt; 구성 요소 는 상태에서 &lt;code&gt;isChecked&lt;/code&gt; 가 필요할 수 있으며 &lt;code&gt;NewsFeed&lt;/code&gt; 구성 요소 는 상태에서 &lt;code&gt;fetchedPosts&lt;/code&gt; 를 추적하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5680a8ed7702957f0d8c7a32c2820f18801e887" translate="yes" xml:space="preserve">
          <source>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</source>
          <target state="translated">렌더링 소품이있는 구성 요소는 React 요소를 반환하고 자체 렌더링 논리를 구현하는 대신 호출하는 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="46d339685bcb53b536cbeb52aaf1e134ce78fd82" translate="yes" xml:space="preserve">
          <source>A good example of this is a text input.</source>
          <target state="translated">이에 대한 좋은 예는 텍스트 입력입니다.</target>
        </trans-unit>
        <trans-unit id="ad565e1d57c268501a85ceb82a25578cbd7079c2" translate="yes" xml:space="preserve">
          <source>A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.</source>
          <target state="translated">시작하기 좋은 곳은 경로입니다. 웹 사용자는 대부분로드하는 데 시간이 걸리는 전환 페이지를 만드는 데 사용됩니다. 또한 전체 페이지를 한 번에 다시 렌더링하는 경향이 있으므로 사용자가 페이지의 다른 요소와 동시에 상호 작용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53fc89c86f8b8cd8ae7b62e2eecafed4be041ae4" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is that elements inside the &lt;code&gt;map()&lt;/code&gt; call need keys.</source>
          <target state="translated">일반적으로 &lt;code&gt;map()&lt;/code&gt; 호출 내부의 요소에는 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c920ca7b5409f13069c873e9b3dbdd7e928674aa" translate="yes" xml:space="preserve">
          <source>A great focus management example is the &lt;a href=&quot;https://github.com/davidtheclark/react-aria-modal&quot;&gt;react-aria-modal&lt;/a&gt;. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal.</source>
          <target state="translated">초점 관리의 좋은 예는 &lt;a href=&quot;https://github.com/davidtheclark/react-aria-modal&quot;&gt;react-aria-modal&lt;/a&gt; 입니다. 이것은 완전히 액세스 가능한 모달 창의 비교적 드문 예입니다. 키보드 사용자가 실수로 성공 조치를 활성화하지 못하도록 취소 버튼에 초기 초점을 설정하고 모달 내부에 키보드 초점을 잡을뿐만 아니라 처음에 모달을 트리거 한 요소로 초점을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="16d4c651998deba160cdf7ab4093d2cc3465f8b4" translate="yes" xml:space="preserve">
          <source>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React&amp;rsquo;s compositional nature.</source>
          <target state="translated">고차 컴포넌트 (HOC)는 컴포넌트 로직 재사용을위한 React의 고급 기술입니다. HOC는 그 자체로 React API의 일부가 아닙니다. 그것들은 React의 구성 적 본성에서 나오는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="ef9eb78cca71516797afe39b05e7c09ace93db87" translate="yes" xml:space="preserve">
          <source>A large portion of UI tests can be written with the above setup: using Jest as a test runner, rendered to jsdom, with user interactions specified as sequences of browser events, powered by the &lt;code&gt;act()&lt;/code&gt; helper &lt;a href=&quot;testing-recipes&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. For example, a lot of React&amp;rsquo;s own tests are written with this combination.</source>
          <target state="translated">위의 설정으로 UI 테스트의 많은 부분을 작성할 수 있습니다 .Jest를 테스트 러너로 사용하고 jsdom으로 렌더링하며 사용자 상호 작용은 브라우저 이벤트 시퀀스로 지정되며 &lt;code&gt;act()&lt;/code&gt; 도우미 &lt;a href=&quot;testing-recipes&quot;&gt;&lt;small&gt;(example)에&lt;/small&gt;&lt;/a&gt; 의해 구동됩니다 . 예를 들어,이 조합으로 많은 React의 자체 테스트가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9828e8b0570a46bbb628eb1843e24e00e08488cc" translate="yes" xml:space="preserve">
          <source>A more complex example with dynamic values for the theme:</source>
          <target state="translated">테마에 대한 동적 값이있는보다 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="5050724b4013a51ee3210911524a3fbc93ef6d92" translate="yes" xml:space="preserve">
          <source>A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly.</source>
          <target state="translated">더 복잡한 사용자 경험이 접근하기 어려운 환경을 의미해서는 안됩니다. 접근성은 HTML에 최대한 가깝게 코딩하여 가장 쉽게 접근 할 수있는 반면, 가장 복잡한 위젯이라도 액세스 가능하게 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd665d7b5af176ea3255d7fb95c76e58c2f84dc" translate="yes" xml:space="preserve">
          <source>A note on cross-browser support:</source>
          <target state="translated">브라우저 간 지원에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="1bd2634152fa67a25351b7d726c729a45da4f302" translate="yes" xml:space="preserve">
          <source>A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML.</source>
          <target state="translated">브라우저의 웹 페이지에서 내게 필요한 옵션 감사를 실행할 수있는 여러 도구가 있습니다. 여기에 언급 된 다른 접근성 검사와 함께 사용하면 HTML의 기술적 접근성 만 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0244350f6de38a5bb3e053c6127bf4b17603558d" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for React 16 using core-js to support older browsers might look like:</source>
          <target state="translated">이전 브라우저를 지원하기 위해 core-js를 사용하는 React 16의 폴리 필 환경은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a50abdf7665198c561d0675f2148253aad1a8c9c" translate="yes" xml:space="preserve">
          <source>A production profiling bundle of &lt;code&gt;react-dom&lt;/code&gt; is also available as &lt;code&gt;react-dom/profiling&lt;/code&gt;. Read more about how to use this bundle at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;react-dom&lt;/code&gt; 의 프로덕션 프로파일 번들은 &lt;code&gt;react-dom/profiling&lt;/code&gt; 로도 제공됩니다 . &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiles&lt;/a&gt; 에서이 번들을 사용하는 방법에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="8dc07c0b0ea027a3e2155dfb9949fef8dfe3aa7e" translate="yes" xml:space="preserve">
          <source>A project that uses this workflow is Next.js. (No pun intended! Seriously!) You can refer to their &lt;a href=&quot;https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml&quot;&gt;CircleCI configuration&lt;/a&gt; as an example.</source>
          <target state="translated">이 워크 플로를 사용하는 프로젝트는 Next.js입니다. (말장난 의도는 없습니다! 진지하게!) &lt;a href=&quot;https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml&quot;&gt;CircleCI 구성&lt;/a&gt; 을 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ca2093a95d59cfef3f519caef447c5f809ef57" translate="yes" xml:space="preserve">
          <source>A single-page application is an application that loads a single HTML page and all the necessary assets (such as JavaScript and CSS) required for the application to run. Any interactions with the page or subsequent pages do not require a round trip to the server which means the page is not reloaded.</source>
          <target state="translated">단일 페이지 응용 프로그램은 단일 HTML 페이지와 응용 프로그램을 실행하는 데 필요한 모든 필수 자산 (예 : JavaScript 및 CSS)을로드하는 응용 프로그램입니다. 페이지 또는 후속 페이지와의 상호 작용에는 서버로의 왕복이 필요하지 않으므로 페이지가 다시로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4745128a18352cf4e73b00ea8cdbbe7e834740bc" translate="yes" xml:space="preserve">
          <source>A snapshot value (or &lt;code&gt;null&lt;/code&gt;) should be returned.</source>
          <target state="translated">스냅 샷 값 (또는 &lt;code&gt;null&lt;/code&gt; )이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc736c6f1365f15c2d720e8ca595629db1d676a" translate="yes" xml:space="preserve">
          <source>A typical use case for portals is when a parent component has an &lt;code&gt;overflow: hidden&lt;/code&gt; or &lt;code&gt;z-index&lt;/code&gt; style, but you need the child to visually &amp;ldquo;break out&amp;rdquo; of its container. For example, dialogs, hovercards, and tooltips.</source>
          <target state="translated">포털의 일반적인 사용 사례는 상위 구성 요소에 &lt;code&gt;overflow: hidden&lt;/code&gt; 또는 &lt;code&gt;z-index&lt;/code&gt; 스타일)가 있지만 컨테이너를 시각적으로 &quot;분리&quot;해야하는 경우입니다. 예를 들어, 대화 상자, 호버 카드 및 툴팁입니다.</target>
        </trans-unit>
        <trans-unit id="aac896ed983bf97bf8e6cfe4fffcba80cd461b7c" translate="yes" xml:space="preserve">
          <source>A11yProject - What is Color Contrast</source>
          <target state="translated">A11yProject-색상 대비 란?</target>
        </trans-unit>
        <trans-unit id="ec50041532b6a570e0d54267dbf63dccf5fcedac" translate="yes" xml:space="preserve">
          <source>AJAX and APIs</source>
          <target state="translated">AJAX 및 API</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="d06b24442f3c9004ce865f2104ae68d66222a2a3" translate="yes" xml:space="preserve">
          <source>APIs may be added, changed, or removed with any &lt;code&gt;@experimental&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;@experimental&lt;/code&gt; 릴리스에서 API를 추가, 변경 또는 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e59a72fe177aa09a24bcbd1834483a033559649" translate="yes" xml:space="preserve">
          <source>Accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="translated">이 프로 바이더의 후손 인 소비 컴포넌트에 &lt;code&gt;value&lt;/code&gt; prop을 전달하도록 허용합니다 . 하나의 공급자를 여러 소비자에게 연결할 수 있습니다. 공급자는 트리 내에서 더 깊은 값을 재정의하기 위해 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="809825dbb77b26dacea934e8e859ee68b7aaa208" translate="yes" xml:space="preserve">
          <source>Accepts a context object (the value returned from &lt;code&gt;React.createContext&lt;/code&gt;) and returns the current context value for that context. The current context value is determined by the &lt;code&gt;value&lt;/code&gt; prop of the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the calling component in the tree.</source>
          <target state="translated">컨텍스트 오브젝트 ( &lt;code&gt;React.createContext&lt;/code&gt; 에서 리턴 된 값)를 승인하고 해당 컨텍스트 의 현재 컨텍스트 값을 리턴합니다. 현재 컨텍스트 값은 트리에서 호출 구성 요소 위에 가장 가까운 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 의 &lt;code&gt;value&lt;/code&gt; prop에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddd58f0030532c86f9b111bbb1e2cefd63bc42fb" translate="yes" xml:space="preserve">
          <source>Accepts a function that contains imperative, possibly effectful code.</source>
          <target state="translated">명령적이고 효과적인 코드가 포함 된 함수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="d660049bc1f2f54fc0e3f4ace6fa5eb205f2f1e0" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibility</target>
        </trans-unit>
        <trans-unit id="4d1b559d0d1263d16fa61d462038757b2e5ce98b" translate="yes" xml:space="preserve">
          <source>Accessibility inspectors and the Accessibility Tree</source>
          <target state="translated">접근성 관리자 및 접근성 트리</target>
        </trans-unit>
        <trans-unit id="e2d8de3d81a99aab854c5a4634ff2db60206331c" translate="yes" xml:space="preserve">
          <source>Accessible Forms</source>
          <target state="translated">접근 가능한 양식</target>
        </trans-unit>
        <trans-unit id="fc6ddd1e049241e0a3eda93f2e449bea87390614" translate="yes" xml:space="preserve">
          <source>Accessible Landmarks</source>
          <target state="translated">접근 가능한 랜드 마크</target>
        </trans-unit>
        <trans-unit id="42784ddbf707ebeafc069514648e2a2236dbf6ba" translate="yes" xml:space="preserve">
          <source>Accessing Refs</source>
          <target state="translated">참조에 액세스</target>
        </trans-unit>
        <trans-unit id="e7b4fc7744dc987988ba047f2f64f8573ee1f968" translate="yes" xml:space="preserve">
          <source>Add Flow to your project as a dependency.</source>
          <target state="translated">종속성을 프로젝트에 흐름을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0c991518e214addabd69c929b69c15f5ffa78384" translate="yes" xml:space="preserve">
          <source>Add JSX to a Project</source>
          <target state="translated">프로젝트에 JSX 추가</target>
        </trans-unit>
        <trans-unit id="086d017a0d48c2e97016b21c91028b329027d930" translate="yes" xml:space="preserve">
          <source>Add React in One Minute</source>
          <target state="translated">1 분 안에 반응 추가</target>
        </trans-unit>
        <trans-unit id="eb35e825a1124c1b826eac67bd47b533d7350da0" translate="yes" xml:space="preserve">
          <source>Add React to a Website</source>
          <target state="translated">웹 사이트에 반응 추가</target>
        </trans-unit>
        <trans-unit id="809cad31dc04417ec8929388ee064bf53fbe23d9" translate="yes" xml:space="preserve">
          <source>Add TypeScript as a dependency to your project</source>
          <target state="translated">프로젝트에 대한 종속성으로 TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="25346a9b833f19f08e98c87e8bd05d06f4819742" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor&quot;&gt;class constructor&lt;/a&gt; that assigns the initial &lt;code&gt;this.state&lt;/code&gt;:</source>
          <target state="translated">초기 &lt;code&gt;this.state&lt;/code&gt; 를 할당 하는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor&quot;&gt;클래스 생성자&lt;/a&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ed3ba4ae4e3ada698740a033115bb4fdc3841f1" translate="yes" xml:space="preserve">
          <source>Add a single empty method to it called &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 라는 빈 메소드 하나를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="547d9540d79afaae7eb80ed44e3ca7fea58f3419" translate="yes" xml:space="preserve">
          <source>Add definitions for libraries you use</source>
          <target state="translated">사용하는 라이브러리에 대한 정의 추가</target>
        </trans-unit>
        <trans-unit id="cc65929a02821d71ec2e2df3b6a57e8e6f0cfd17" translate="yes" xml:space="preserve">
          <source>Add type annotations and run Flow to check them.</source>
          <target state="translated">유형 주석을 추가하고 Flow를 실행하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a550467b7342d7bbe3954c6ad4e1e9089274ef12" translate="yes" xml:space="preserve">
          <source>Adding Flow Type Annotations</source>
          <target state="translated">흐름 유형 주석 추가</target>
        </trans-unit>
        <trans-unit id="587d11acd4c747cc91558c0741bc1f8fece6e060" translate="yes" xml:space="preserve">
          <source>Adding Flow to a Project</source>
          <target state="translated">프로젝트에 흐름 추가</target>
        </trans-unit>
        <trans-unit id="c18aadea57b9df0a2d9c35cf35667510817c802a" translate="yes" xml:space="preserve">
          <source>Adding JSX to a project doesn&amp;rsquo;t require complicated tools like a bundler or a development server. Essentially, adding JSX &lt;strong&gt;is a lot like adding a CSS preprocessor.&lt;/strong&gt; The only requirement is to have &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; installed on your computer.</source>
          <target state="translated">프로젝트에 JSX를 추가하기 위해 번 들러 나 개발 서버와 같은 복잡한 도구가 필요하지 않습니다. 기본적으로 JSX를 &lt;strong&gt;추가하는 것은 CSS 프리 프로세서를 추가하는 것과 비슷합니다. &lt;/strong&gt;유일한 요구 사항은 컴퓨터에 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js를&lt;/a&gt; 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ccc3606ed0935928cc00e815d1ab4ed09206bd4" translate="yes" xml:space="preserve">
          <source>Adding Lifecycle Methods to a Class</source>
          <target state="translated">클래스에 수명주기 메소드 추가</target>
        </trans-unit>
        <trans-unit id="575c269353f1f093313046756c09d3f3fae275b7" translate="yes" xml:space="preserve">
          <source>Adding Local State to a Class</source>
          <target state="translated">클래스에 로컬 상태 추가</target>
        </trans-unit>
        <trans-unit id="4864a2e1ec0ba08f3b6af6c32e74a09d035420cc" translate="yes" xml:space="preserve">
          <source>Adding TypeScript to a Project</source>
          <target state="translated">프로젝트에 TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="91087561482eeaaac2d6c9f8be7d0f3e02611c1b" translate="yes" xml:space="preserve">
          <source>Adding a Pending Indicator</source>
          <target state="translated">보류 표시기 추가</target>
        </trans-unit>
        <trans-unit id="c2767d8da201f51979a038ce62beeb570e562f6a" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a Class Component</source>
          <target state="translated">클래스 컴포넌트에 참조 추가</target>
        </trans-unit>
        <trans-unit id="4717a3f0cfb3f09b7e4a1e21b3a4c4d185091936" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a DOM Element</source>
          <target state="translated">DOM 요소에 참조 추가</target>
        </trans-unit>
        <trans-unit id="6b255da4a4843e46bc1afb50e64e3897e12611a4" translate="yes" xml:space="preserve">
          <source>Adding a Second Input</source>
          <target state="translated">두 번째 입력 추가</target>
        </trans-unit>
        <trans-unit id="b6a4c7231b2d630925037cb061d866d786c9d008" translate="yes" xml:space="preserve">
          <source>Additional Hooks</source>
          <target state="translated">추가 후크</target>
        </trans-unit>
        <trans-unit id="7e246a0bab77ff9b9d3f757e4016354d8a0e9c21" translate="yes" xml:space="preserve">
          <source>Additional functionality will be added with future releases of React.</source>
          <target state="translated">향후 React 릴리스에는 추가 기능이 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="e467b2b452848db9e10c52adb4d9a045097dc1cf" translate="yes" xml:space="preserve">
          <source>Additionally, React has been out for about five years, and we want to make sure it stays relevant in the next five years. As &lt;a href=&quot;https://svelte.dev/&quot;&gt;Svelte&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://glimmerjs.com/&quot;&gt;Glimmer&lt;/a&gt;, and others show, &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;ahead-of-time compilation&lt;/a&gt; of components has a lot of future potential. Especially if it&amp;rsquo;s not limited to templates. Recently, we&amp;rsquo;ve been experimenting with &lt;a href=&quot;https://github.com/facebook/react/issues/7323&quot;&gt;component folding&lt;/a&gt; using &lt;a href=&quot;https://prepack.io/&quot;&gt;Prepack&lt;/a&gt;, and we&amp;rsquo;ve seen promising early results. However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path. Classes present issues for today&amp;rsquo;s tools, too. For example, classes don&amp;rsquo;t minify very well, and they make hot reloading flaky and unreliable. We want to present an API that makes it more likely for code to stay on the optimizable path.</source>
          <target state="translated">또한 React는 약 5 년 동안 사용되었으며 향후 5 년 동안 관련성을 유지하고자합니다. 으로 &lt;a href=&quot;https://svelte.dev/&quot;&gt;호리 호리&lt;/a&gt; , &lt;a href=&quot;https://angular.io/&quot;&gt;각도&lt;/a&gt; , &lt;a href=&quot;https://glimmerjs.com/&quot;&gt;희미한 빛&lt;/a&gt; , 그리고 다른 사람 보여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;컴파일 앞서-의 시간&lt;/a&gt; 구성 요소의 미래 잠재력을 많이 가지고 있습니다. 특히 템플릿에만 국한되지 않는 경우. 최근에 우리는 &lt;a href=&quot;https://prepack.io/&quot;&gt;Prepack을&lt;/a&gt; 사용하여 &lt;a href=&quot;https://github.com/facebook/react/issues/7323&quot;&gt;컴포넌트 폴딩&lt;/a&gt; 을 실험 해 왔습니다우리는 유망한 초기 결과를 보았습니다. 그러나 클래스 구성 요소는 의도하지 않은 패턴을 사용하여 이러한 최적화를 더 느리게 진행할 수 있음을 발견했습니다. 수업은 오늘날 도구에 대한 문제도 제시합니다. 예를 들어, 클래스는 잘 축소되지 않으며 핫 리로딩이 비정상적이고 신뢰할 수 없게 만듭니다. 우리는 코드가 최적화 가능한 경로를 유지할 가능성을 높이는 API를 제시하고자합니다.</target>
        </trans-unit>
        <trans-unit id="e528bf2d8f58658ae937110a5ddeddfe98188b0f" translate="yes" xml:space="preserve">
          <source>Additionally, it renders the &lt;code&gt;BoilingVerdict&lt;/code&gt; for the current input value.</source>
          <target state="translated">또한 현재 입력 값에 대해 &lt;code&gt;BoilingVerdict&lt;/code&gt; 를 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="26d8af2ce2c7a89382928343c6066e863feed9a5" translate="yes" xml:space="preserve">
          <source>Addressing the issues identified by strict mode &lt;em&gt;now&lt;/em&gt; will make it easier for you to take advantage of async rendering in future releases of React.</source>
          <target state="translated">엄격 모드로 식별되는 문제 해결 &lt;em&gt;지금은&lt;/em&gt; 보다 쉽게 반응의 향후 릴리스에서 비동기 렌더링을 활용 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="22954472d775b0b1be14e3fcc04208797ed42abf" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode</source>
          <target state="translated">동시 모드 채택</target>
        </trans-unit>
        <trans-unit id="962c4a36d76f10153e37a64bc3586ceaab6fcab5" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode (Experimental)</source>
          <target state="translated">동시 모드 채택 (실험적)</target>
        </trans-unit>
        <trans-unit id="b27bd5da322edd19f0435864f00932a75456ddca" translate="yes" xml:space="preserve">
          <source>Adoption Strategy</source>
          <target state="translated">채택 전략</target>
        </trans-unit>
        <trans-unit id="5fa07c56f702314b63d39c0b7e492104e367c9eb" translate="yes" xml:space="preserve">
          <source>Advanced Concepts</source>
          <target state="translated">고급 개념</target>
        </trans-unit>
        <trans-unit id="5218ce8b68960a0c1d0ca0b0cb45a6b0b89b75de" translate="yes" xml:space="preserve">
          <source>Advanced Guides</source>
          <target state="translated">고급 가이드</target>
        </trans-unit>
        <trans-unit id="bc61b397b6be13c2ea83cc7838ff1f6e887b7709" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;shallowRenderer.render()&lt;/code&gt; has been called, you can use &lt;code&gt;shallowRenderer.getRenderOutput()&lt;/code&gt; to get the shallowly rendered output.</source>
          <target state="translated">후 &lt;code&gt;shallowRenderer.render()&lt;/code&gt; 호출 된, 당신은 사용할 수 있습니다 &lt;code&gt;shallowRenderer.getRenderOutput()&lt;/code&gt; 얕게 렌더링 된 출력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="634b8416814c1a4eebfe7f04d710ecbda6b5fcce" translate="yes" xml:space="preserve">
          <source>After &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;the starter code&lt;/a&gt;&lt;/strong&gt;, add two lines to the bottom of &lt;code&gt;like_button.js&lt;/code&gt;:</source>
          <target state="translated">후 &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;시동 코드&lt;/a&gt;&lt;/strong&gt; , 하단에 두 줄을 추가 &lt;code&gt;like_button.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7eb9663be8297e0f777fa61a8597c8a63787b7a1" translate="yes" xml:space="preserve">
          <source>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</source>
          <target state="translated">컴파일 후 JSX 표현식은 일반적인 JavaScript 함수 호출이되고 JavaScript 객체로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6377d667974c26a5fe1b3c181bb04235faf147a9" translate="yes" xml:space="preserve">
          <source>After handling the DOM node, React then recurses on the children.</source>
          <target state="translated">DOM 노드를 처리 한 후 React는 하위 노드에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="3704d1e6e1604e443e390d03ccd77e9457ac24a3" translate="yes" xml:space="preserve">
          <source>After the click, React started rendering the next screen:</source>
          <target state="translated">클릭 후 React는 다음 화면 렌더링을 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="899a132c7131f8da48059337d05ef25041d4c75e" translate="yes" xml:space="preserve">
          <source>Again, notice that &lt;strong&gt;we&amp;rsquo;re not waiting for the response to set the state. It&amp;rsquo;s the other way around: we set the state (and start rendering) immediately after kicking off a request&lt;/strong&gt;. As soon as we have more data, React &amp;ldquo;fills in&amp;rdquo; the content inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; components.</source>
          <target state="translated">다시 한 번, &lt;strong&gt;응답이 상태를 설정하기를 기다리지 않습니다. 다른 방법으로 요청을 시작한 직후 상태를 설정하고 렌더링을 시작&lt;/strong&gt; 합니다. 더 많은 데이터를 얻 자마자 React는 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 구성 요소 내부의 내용을 &quot;채 웁니다&quot; .</target>
        </trans-unit>
        <trans-unit id="c01d83d5f47cb6f8ccd677b6c6bb8955308e6113" translate="yes" xml:space="preserve">
          <source>All Supported HTML Attributes</source>
          <target state="translated">지원되는 모든 HTML 속성</target>
        </trans-unit>
        <trans-unit id="576e625f6a5bb19b6dc10a4685b4b3c255437e88" translate="yes" xml:space="preserve">
          <source>All changes to React go through extensive internal testing before they are released to the public. However, there are a myriad of environments and configurations used throughout the React ecosystem, and it&amp;rsquo;s not possible for us to test against every single one.</source>
          <target state="translated">React의 모든 변경 사항은 공개하기 전에 광범위한 내부 테스트를 거칩니다. 그러나 React 생태계 전체에서 사용되는 무수한 환경과 구성이 있으므로 모든 환경에 대해 테스트 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4cc3903d35e829b702ef8fd5ee160caf3e73123c" translate="yes" xml:space="preserve">
          <source>All consumers that are descendants of a Provider will re-render whenever the Provider&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; prop changes. The propagation from Provider to its descendant consumers (including &lt;a href=&quot;#classcontexttype&quot;&gt;&lt;code&gt;.contextType&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt;) is not subject to the &lt;code&gt;shouldComponentUpdate&lt;/code&gt; method, so the consumer is updated even when an ancestor component skips an update.</source>
          <target state="translated">제공자의 후손 인 모든 소비자는 제공자의 &lt;code&gt;value&lt;/code&gt; 제안이 변경 될 때마다 다시 렌더링 됩니다. Provider에서 하위 소비자 ( &lt;a href=&quot;#classcontexttype&quot;&gt; &lt;code&gt;.contextType&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; &lt;/a&gt; 포함) 로의 전파 에는 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 메소드가 적용되지 않으므로 상위 컴포넌트가 업데이트를 건너 뛰더라도 소비자가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e24a43b87d7f7bc0f02a784b5dc9b38b5a810c" translate="yes" xml:space="preserve">
          <source>All releases are published to npm, but only Latest uses &lt;a href=&quot;faq-versioning&quot;&gt;semantic versioning&lt;/a&gt;. Prereleases (those in the Next and Experimental channels) have versions generated from a hash of their contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; for Next and &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; for Experimental.</source>
          <target state="translated">모든 릴리즈는 npm에 게시되지만 최신 &lt;a href=&quot;faq-versioning&quot;&gt;버전&lt;/a&gt; 에서만 의미 버전 관리가 사용 됩니다. 시험판 (다음 및 실험 채널에있는)은 컨텐츠의 해시에서 생성 된 버전을 포함합니다 (예 : 다음에 &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; 및 &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c6cd0a0f578763ad3da70088a5eca15dd6f467" translate="yes" xml:space="preserve">
          <source>Also note that this pattern might cause problems in the &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;concurrent mode&lt;/a&gt;. We plan to provide more ergonomic alternatives in the future, but the safest solution right now is to always invalidate the callback if some value it depends on changes.</source>
          <target state="translated">또한이 패턴은 &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;동시 모드&lt;/a&gt; 에서 문제를 일으킬 수 있습니다 . 향후 더 인체 공학적인 대안을 제공 할 계획이지만 현재 가장 안전한 해결책은 콜백이 변경에 따라 가치가있는 경우 항상 무효화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe0881d750700961baeb728e809bf3abda69b5b1" translate="yes" xml:space="preserve">
          <source>Also use landmark elements and roles, such as &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;, to demarcate page regions as assistive technology allow the user to quickly navigate to these sections.</source>
          <target state="translated">또한 보조 기술을 통해 사용자가 이러한 섹션으로 빠르게 이동할 수 있으므로 &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; &amp;gt; 와 같은 랜드 마크 요소 및 역할을 사용 하여 페이지 영역을 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="2fa429502a4c88c485e04e07f1fc75825c4110db" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;setState()&lt;/code&gt; automatically &lt;a href=&quot;state-and-lifecycle#state-updates-are-merged&quot;&gt;merges a partial state into the current state&lt;/a&gt;, we only needed to call it with the changed parts.</source>
          <target state="translated">또한 &lt;code&gt;setState()&lt;/code&gt; &lt;a href=&quot;state-and-lifecycle#state-updates-are-merged&quot;&gt;는 부분 상태를 현재 상태에&lt;/a&gt; 자동으로 병합 하므로 변경된 부분으로 호출하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e283c1957a3a5f491d12bdc54dc942cfec4b5eac" translate="yes" xml:space="preserve">
          <source>Alternately, you can use DOM APIs to store data needed for event handlers. Consider this approach if you need to optimize a large number of elements or have a render tree that relies on React.PureComponent equality checks.</source>
          <target state="translated">또는 DOM API를 사용하여 이벤트 핸들러에 필요한 데이터를 저장할 수 있습니다. 많은 수의 요소를 최적화하거나 React.PureComponent 동등성 검사에 의존하는 렌더 트리가 필요한 경우이 방법을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f04eaa8332063237a2339350c634f6fd5fc3a9b6" translate="yes" xml:space="preserve">
          <source>Alternatively, Airbnb has released a testing utility called &lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, which makes it easy to assert, manipulate, and traverse your React Components&amp;rsquo; output.</source>
          <target state="translated">또한 에어 비앤비는 &lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt; 이라는 테스트 유틸리티를 출시 했습니다.이를 통해 React Components의 출력을 쉽게 주장하고 조작하고 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546503387b42bc8b3ddf6e6f4ff8abd001a0e9b7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can refer to community projects such as &lt;a href=&quot;https://github.com/mlmorg/react-hyperscript&quot;&gt;&lt;code&gt;react-hyperscript&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/ohanhi/hyperscript-helpers&quot;&gt;&lt;code&gt;hyperscript-helpers&lt;/code&gt;&lt;/a&gt; which offer a terser syntax.</source>
          <target state="translated">또는 더 &lt;a href=&quot;https://github.com/ohanhi/hyperscript-helpers&quot;&gt; &lt;code&gt;hyperscript-helpers&lt;/code&gt; &lt;/a&gt; 구문을 제공하는 &lt;a href=&quot;https://github.com/mlmorg/react-hyperscript&quot;&gt; &lt;code&gt;react-hyperscript&lt;/code&gt; &lt;/a&gt; 및 hyperscript-helpers 와 같은 커뮤니티 프로젝트를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12c6438cd5d3f55950518120d03416c1ee83616f" translate="yes" xml:space="preserve">
          <source>Alternatives to Controlled Components</source>
          <target state="translated">제어 구성 요소에 대한 대안</target>
        </trans-unit>
        <trans-unit id="241369d96a24458352ce7d2c48c3c51b72b2b9a0" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Profiler&lt;/code&gt; is a light-weight component, it should be used only when necessary; each use adds some CPU and memory overhead to an application.</source>
          <target state="translated">비록 &lt;code&gt;Profiler&lt;/code&gt; 경량 성분은, 그것이 필요할 때만 사용한다; 각각의 사용은 일부 CPU 및 메모리 오버 헤드를 응용 프로그램에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4fd44ae5ccfed12b1c010994f28d7531e039e164" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;useEffect&lt;/code&gt; is deferred until after the browser has painted, it&amp;rsquo;s guaranteed to fire before any new renders. React will always flush a previous render&amp;rsquo;s effects before starting a new update.</source>
          <target state="translated">브라우저가 페인트 될 때까지 &lt;code&gt;useEffect&lt;/code&gt; 가 지연 되지만 새로운 렌더링 전에 실행됩니다. React는 새로운 업데이트를 시작하기 전에 항상 이전 렌더의 효과를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="b7532ae36812091fdbaff1778d045a73e3cf53a3" translate="yes" xml:space="preserve">
          <source>Although React is commonly used at startup to load a single root React component into the DOM, &lt;code&gt;ReactDOM.render()&lt;/code&gt; can also be called multiple times for independent parts of the UI which can be as small as a button, or as large as an app.</source>
          <target state="translated">React가 시작시 단일 루트 React 구성 요소를 DOM에로드하기 위해 일반적으로 사용되지만, &lt;code&gt;ReactDOM.render()&lt;/code&gt; 는 UI의 독립적 인 부분에 대해 여러 번 호출 될 수 있습니다 (버튼처럼 작거나 앱만큼 클 수 있음) .</target>
        </trans-unit>
        <trans-unit id="4423d4d7befa33ec5f29f735ed0d62afa44ee6e2" translate="yes" xml:space="preserve">
          <source>Although it&amp;rsquo;s technically doable, Suspense is &lt;strong&gt;not&lt;/strong&gt; currently intended as a way to start fetching data when a component renders. Rather, it lets components express that they&amp;rsquo;re &amp;ldquo;waiting&amp;rdquo; for data that is &lt;em&gt;already being fetched&lt;/em&gt;. &lt;strong&gt;&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; describes why this matters and how to implement this pattern in practice.&lt;/strong&gt;</source>
          <target state="translated">기술적으로는 가능 &lt;strong&gt;하지만&lt;/strong&gt; 현재 Suspense는 구성 요소가 렌더링 될 때 데이터 가져 오기를 시작하기위한 방법 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 오히려 컴포넌트가 &lt;em&gt;이미 페치중인&lt;/em&gt; 데이터를 &quot;대기 중&quot;이라고 표시 할 수 있습니다 . &lt;strong&gt;&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;동시 모드 및 서스펜스로 훌륭한 사용자 경험 구축&lt;/a&gt; 이 중요한 이유 와 실제로이 패턴을 구현하는 방법을 설명합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd17f9d9908f716e52a6bed18c0ec0f584b692a5" translate="yes" xml:space="preserve">
          <source>Although such encapsulation is desirable for application-level components like &lt;code&gt;FeedStory&lt;/code&gt; or &lt;code&gt;Comment&lt;/code&gt;, it can be inconvenient for highly reusable &amp;ldquo;leaf&amp;rdquo; components like &lt;code&gt;FancyButton&lt;/code&gt; or &lt;code&gt;MyTextInput&lt;/code&gt;. These components tend to be used throughout the application in a similar manner as a regular DOM &lt;code&gt;button&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt;, and accessing their DOM nodes may be unavoidable for managing focus, selection, or animations.</source>
          <target state="translated">이러한 캡슐화는 &lt;code&gt;FeedStory&lt;/code&gt; 또는 &lt;code&gt;Comment&lt;/code&gt; 와 같은 응용 프로그램 레벨 구성 요소에 바람직하지만 &lt;code&gt;FancyButton&lt;/code&gt; 또는 &lt;code&gt;MyTextInput&lt;/code&gt; 과 같은 재사용 성이 높은 &quot;리프&quot;구성 요소에는 불편할 수 있습니다 . 이러한 구성 요소는 일반 DOM &lt;code&gt;button&lt;/code&gt; 및 &lt;code&gt;input&lt;/code&gt; 과 비슷한 방식으로 응용 프로그램 전체에서 사용되는 경향이 있으며 , 포커스, 선택 또는 애니메이션 관리를 위해 DOM 노드에 액세스하는 것이 불가피 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b87fc4ac59367232ee26438ecc79c94e4a3e5b" translate="yes" xml:space="preserve">
          <source>Although the examples above use &lt;code&gt;render&lt;/code&gt;, we could just as easily use the &lt;code&gt;children&lt;/code&gt; prop!</source>
          <target state="translated">위의 예제에서는 &lt;code&gt;render&lt;/code&gt; 를 사용하지만 &lt;code&gt;children&lt;/code&gt; prop 을 쉽게 사용할 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="f80247c2365054862000d6aeb603ca72df0fe159" translate="yes" xml:space="preserve">
          <source>Although these standard HTML practices can be directly used in React, note that the &lt;code&gt;for&lt;/code&gt; attribute is written as &lt;code&gt;htmlFor&lt;/code&gt; in JSX:</source>
          <target state="translated">이러한 표준 HTML 사례를 React에서 직접 사용할 수 있지만 &lt;code&gt;for&lt;/code&gt; 속성은 &lt;code&gt;htmlFor&lt;/code&gt; 에서 htmlFor 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="868104f6e8953f806f4afbb3a838af8b565d552f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;uncontrolled component&lt;/em&gt; works like form elements do outside of React. When a user inputs data into a form field (an input box, dropdown, etc) the updated information is reflected without React needing to do anything. However, this also means that you can&amp;rsquo;t force the field to have a certain value.</source>
          <target state="translated">&lt;em&gt;통제되지 않은 구성 요소&lt;/em&gt; 폼 요소와 같은 작품 반작용의 외부을한다. 사용자가 데이터를 양식 필드 (입력 상자, 드롭 다운 등)에 입력하면 업데이트 된 정보가 React에서 별도의 조치를 취할 필요없이 반영됩니다. 그러나 이는 또한 필드가 특정 값을 갖도록 강요 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a57cc8c9dc9df0ab903aaab7f338a14894c9aab" translate="yes" xml:space="preserve">
          <source>An API like &lt;code&gt;useTransition&lt;/code&gt; lets you focus on the desired user experience, and not think about the mechanics of how it&amp;rsquo;s implemented. Still, it can be a helpful metaphor to imagine that updates wrapped in &lt;code&gt;startTransition&lt;/code&gt; happen &amp;ldquo;on a branch&amp;rdquo; or &amp;ldquo;in a different world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 과 같은 API를 사용하면 원하는 사용자 경험에 집중할 수 있으며 구현 방식에 대해서는 생각하지 않아도됩니다. 그러나 &lt;code&gt;startTransition&lt;/code&gt; 에 래핑 된 업데이트가 &quot;지점&quot;또는 &quot;다른 세계&quot; 에 있다고 생각하면 유용한 은유가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68140fb4e688bc64196283497d2bdb8b7794a042" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt;. Accepts a reducer of type &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and returns the current state paired with a &lt;code&gt;dispatch&lt;/code&gt; method. (If you&amp;rsquo;re familiar with Redux, you already know how this works.)</source>
          <target state="translated">&lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt; 의 대안 입니다. 유형 &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 의 감속기를 받아들이고 &lt;code&gt;dispatch&lt;/code&gt; 메소드 와 쌍을 이루는 현재 상태를 리턴합니다 . Redux에 익숙한 경우 이미 작동 방식을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="34de2ea3a7b2ff60cffeaba53955ef350c113c02" translate="yes" xml:space="preserve">
          <source>An element describes what you want to see on the screen:</source>
          <target state="translated">요소는 화면에서보고 싶은 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="332df723151107dc7a32c730fbc52b2b3b2e4d33" translate="yes" xml:space="preserve">
          <source>An input form element whose value is controlled by React is called a &lt;em&gt;controlled component&lt;/em&gt;. When a user enters data into a controlled component a change event handler is triggered and your code decides whether the input is valid (by re-rendering with the updated value). If you do not re-render then the form element will remain unchanged.</source>
          <target state="translated">값이 React에 의해 제어되는 입력 양식 요소를 제어되는 &lt;em&gt;구성 요소&lt;/em&gt; 라고합니다 . 사용자가 제어 된 구성 요소에 데이터를 입력하면 변경 이벤트 핸들러가 트리거되고 코드는 입력이 유효한지 여부를 판별합니다 (업데이트 된 값으로 다시 렌더링하여). 다시 렌더링하지 않으면 양식 요소가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2996e0fe23009f56c38d7488a07be4ff07b9dfa" translate="yes" xml:space="preserve">
          <source>An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:</source>
          <target state="translated">소품 또는 상태 변경으로 인해 업데이트가 발생할 수 있습니다. 이러한 메소드는 컴포넌트를 다시 렌더링 할 때 다음 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7df4d5ef123c895ff771594316c92afb17ff67a0" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; lets you manage local state of complex components with a reducer:</source>
          <target state="translated">그리고 &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; 은&lt;/a&gt; 당신이 감속기 복잡한 구성 요소의 로컬 상태를 관리 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="988a0414af267dcb188783148f4aa2483606d30e" translate="yes" xml:space="preserve">
          <source>And That&amp;rsquo;s It</source>
          <target state="translated">그리고 그게 다야</target>
        </trans-unit>
        <trans-unit id="4cf3a1adfcc066838ee4661dcceb95d7378bb404" translate="yes" xml:space="preserve">
          <source>And remember, the &lt;code&gt;children&lt;/code&gt; prop doesn&amp;rsquo;t actually need to be named in the list of &amp;ldquo;attributes&amp;rdquo; in your JSX element. Instead, you can put it directly &lt;em&gt;inside&lt;/em&gt; the element!</source>
          <target state="translated">그리고 &lt;code&gt;children&lt;/code&gt; 소품은 실제로 JSX 요소의 &quot;속성&quot;목록에서 이름을 지정할 필요가 없습니다. 대신 요소 &lt;em&gt;내부&lt;/em&gt; 에 직접 넣을 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="81c34616e84009712cba18fa581c98ede1b9aafd" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s it! The wrapped component receives all the props of the container, along with a new prop, &lt;code&gt;data&lt;/code&gt;, which it uses to render its output. The HOC isn&amp;rsquo;t concerned with how or why the data is used, and the wrapped component isn&amp;rsquo;t concerned with where the data came from.</source>
          <target state="translated">그리고 그게 다야! 래핑 된 구성 요소는 컨테이너의 모든 소품과 함께 새로운 소품 인 &lt;code&gt;data&lt;/code&gt; 를 받아 출력을 렌더링하는 데 사용합니다. HOC는 데이터가 어떻게 또는 왜 사용되는지에 관심이없고 랩핑 된 구성 요소는 데이터가 어디에서 왔는지에 대해서는 관심이 없다.</target>
        </trans-unit>
        <trans-unit id="ee7f513a00353c61bc6f044dde142a57fe3f51b1" translate="yes" xml:space="preserve">
          <source>And then we can put it anywhere in the tree to catch errors:</source>
          <target state="translated">그런 다음 오류를 포착하기 위해 트리의 아무 곳에 나 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093dae0b59674686c00fe05ce3246b47a82b8ed8" translate="yes" xml:space="preserve">
          <source>Animation Events</source>
          <target state="translated">애니메이션 이벤트</target>
        </trans-unit>
        <trans-unit id="f4a1bc05c0329ca7661aa6145724626817c52e4c" translate="yes" xml:space="preserve">
          <source>Another difference is that you cannot return &lt;code&gt;false&lt;/code&gt; to prevent default behavior in React. You must call &lt;code&gt;preventDefault&lt;/code&gt; explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</source>
          <target state="translated">또 다른 차이점은 React에서 기본 동작을 방지하기 위해 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 없다는 것 입니다. &lt;code&gt;preventDefault&lt;/code&gt; 를 명시 적으로 호출해야합니다 . 예를 들어 일반 HTML을 사용하면 새 페이지를 여는 기본 링크 동작을 방지하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e1e6e124b4dd25605ccf99d61371ca60ae4a4d" translate="yes" xml:space="preserve">
          <source>Another method for conditionally rendering elements inline is to use the JavaScript conditional operator &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;&lt;code&gt;condition ? true : false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조건부로 요소를 인라인으로 렌더링하는 또 다른 방법은 JavaScript 조건부 연산자 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt; &lt;code&gt;condition ? true : false&lt;/code&gt; &lt;/a&gt; 을 사용하는 것입니다. true : 거짓 .</target>
        </trans-unit>
        <trans-unit id="61e45886ae3796dc23d86371bad5e1054b434557" translate="yes" xml:space="preserve">
          <source>Another option is &lt;code&gt;useReducer&lt;/code&gt;, which is more suited for managing state objects that contain multiple sub-values.</source>
          <target state="translated">또 다른 옵션은 &lt;code&gt;useReducer&lt;/code&gt; 입니다 . 이는 여러 하위 값이 포함 된 상태 객체를 관리하는 데 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c47edf6d669b78899eccfabccdd7096df09b3073" translate="yes" xml:space="preserve">
          <source>Another popular way to structure projects is to group similar files together, for example:</source>
          <target state="translated">프로젝트를 구성하는 또 다른 일반적인 방법은 유사한 파일을 그룹화하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fc7dff748d08032efe0c8a8ab8b07a5cd5920fb" translate="yes" xml:space="preserve">
          <source>Another possible solution is to export the static method separately from the component itself.</source>
          <target state="translated">또 다른 가능한 해결책은 정적 메소드를 구성 요소 자체와 별도로 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="50f4bbcd06c44cfc2ee6c4cc092fadfdc2aca1bf" translate="yes" xml:space="preserve">
          <source>Any child in the tree inside &lt;code&gt;TodosApp&lt;/code&gt; can use the &lt;code&gt;dispatch&lt;/code&gt; function to pass actions up to &lt;code&gt;TodosApp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;TodosApp&lt;/code&gt; 내부의 트리에있는 모든 자식 은 &lt;code&gt;dispatch&lt;/code&gt; 함수를 사용하여 &lt;code&gt;TodosApp&lt;/code&gt; 까지 조치를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a522a53bfc9303f9b72ce1b553651f8aca9c580" translate="yes" xml:space="preserve">
          <source>Any components below the root will also get unmounted and have their state destroyed. For example, when diffing:</source>
          <target state="translated">루트 아래의 모든 구성 요소도 마운트 해제되어 상태가 손상됩니다. 예를 들어 diffing 할 때 :</target>
        </trans-unit>
        <trans-unit id="aedd7b8dff3cf1f14d47f7c7329445ee2f4b2d58" translate="yes" xml:space="preserve">
          <source>Any function inside a component, including event handlers and effects, &amp;ldquo;sees&amp;rdquo; the props and state from the render it was created in. For example, consider code like this:</source>
          <target state="translated">이벤트 처리기 및 효과를 포함하여 구성 요소 내부의 모든 함수는 소품을 만든 렌더링에서 소품과 상태를 &quot;인식&quot;합니다. 예를 들어 다음과 같은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2f49546959e051bb64df05e2a2293656f5786f3f" translate="yes" xml:space="preserve">
          <source>Anything inside the &lt;code&gt;&amp;lt;FancyBorder&amp;gt;&lt;/code&gt; JSX tag gets passed into the &lt;code&gt;FancyBorder&lt;/code&gt; component as a &lt;code&gt;children&lt;/code&gt; prop. Since &lt;code&gt;FancyBorder&lt;/code&gt; renders &lt;code&gt;{props.children}&lt;/code&gt; inside a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, the passed elements appear in the final output.</source>
          <target state="translated">&lt;code&gt;&amp;lt;FancyBorder&amp;gt;&lt;/code&gt; JSX 태그 내의 모든 항목 은 &lt;code&gt;children&lt;/code&gt; 소품 으로 &lt;code&gt;FancyBorder&lt;/code&gt; 구성 요소에 전달됩니다 . &lt;code&gt;FancyBorder&lt;/code&gt; 는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 안에 &lt;code&gt;{props.children}&lt;/code&gt; 을 렌더링 하므로 전달 된 요소는 최종 출력에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8aa299e264f5e76931f8cb209b83fffb45816f24" translate="yes" xml:space="preserve">
          <source>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</source>
          <target state="translated">React만으로 빌드 된 애플리케이션에는 일반적으로 단일 루트 DOM 노드가 있습니다. React를 기존 앱에 통합하는 경우 원하는 수의 격리 된 루트 DOM 노드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e6fb77ae739da9f6502ec7db3988c4619fa8bd" translate="yes" xml:space="preserve">
          <source>Approach 1: Fetch-on-Render (not using Suspense)</source>
          <target state="translated">접근법 1 : Fetch-on-Render (서스펜스를 사용하지 않음)</target>
        </trans-unit>
        <trans-unit id="f9feb99ab74114b1088328de56c35767ffbd3cd9" translate="yes" xml:space="preserve">
          <source>Approach 2: Fetch-Then-Render (not using Suspense)</source>
          <target state="translated">접근법 2 : Fetch-Then-Render (서스펜스를 사용하지 않음)</target>
        </trans-unit>
        <trans-unit id="55c57781f77789ad80982aaf7935538da556bc2f" translate="yes" xml:space="preserve">
          <source>Approach 3: Render-as-You-Fetch (using Suspense)</source>
          <target state="translated">접근법 3 : 렌더로 가져 오기 (서스펜스 사용)</target>
        </trans-unit>
        <trans-unit id="34def147d0a0b705dc77cd5a742d57d852d3d9a5" translate="yes" xml:space="preserve">
          <source>Are Hooks slow because of creating functions in render?</source>
          <target state="translated">렌더링에서 함수를 생성하여 후크가 느려 집니까?</target>
        </trans-unit>
        <trans-unit id="cafcd4680a5bb029c409d8d4661e70bb2bd0f99f" translate="yes" xml:space="preserve">
          <source>Are inline styles bad?</source>
          <target state="translated">인라인 스타일이 좋지 않습니까?</target>
        </trans-unit>
        <trans-unit id="157b87629fda27d802b1137877c75e1f56290070" translate="yes" xml:space="preserve">
          <source>Arrow Function in Render</source>
          <target state="translated">렌더의 화살표 기능</target>
        </trans-unit>
        <trans-unit id="111abfdd524656d236b279d85e69e3213edf5777" translate="yes" xml:space="preserve">
          <source>As a bonus, this also lets you use modern JavaScript syntax features like classes without worrying about breaking older browsers. The tool we just used is called Babel, and you can learn more about it from &lt;a href=&quot;https://babeljs.io/docs/en/babel-cli/&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">또한이 기능을 사용하면 오래된 브라우저를 손상시키지 않고도 클래스와 같은 최신 JavaScript 구문 기능을 사용할 수 있습니다. 방금 사용한 도구를 Babel이라고 &lt;a href=&quot;https://babeljs.io/docs/en/babel-cli/&quot;&gt;하며 설명서&lt;/a&gt; 에서 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72221537c40418d03696ee3da06de3c59bffbfb" translate="yes" xml:space="preserve">
          <source>As a first pass, you might try rendering the &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;inside &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt;&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method&lt;/em&gt;, like this:</source>
          <target state="translated">첫 번째 단계로 &lt;em&gt; &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 의 &lt;/em&gt;&lt;em&gt; &lt;code&gt;render&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 메소드 &lt;/em&gt;&lt;em&gt;내&lt;/em&gt; 에서 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 을 다음과 같이 &lt;em&gt;렌더링&lt;/em&gt; 하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3480fd67c41d681c4c73b565f4148607a8cf72ab" translate="yes" xml:space="preserve">
          <source>As a last resort, if you want something like &lt;code&gt;this&lt;/code&gt; in a class, you can &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;use a ref&lt;/a&gt; to hold a mutable variable. Then you can write and read to it. For example:</source>
          <target state="translated">당신은 같은 것을 원하는 경우 최후의 수단으로, &lt;code&gt;this&lt;/code&gt; 클래스에서, 당신은 할 수 &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;의 Ref를 사용하여&lt;/a&gt; 변경 가능한 변수를 개최. 그러면 글을 읽고 읽을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab419ab7a7f9da60b42781bc4f2d7c44971ae520" translate="yes" xml:space="preserve">
          <source>As a last resort, you can &lt;strong&gt;add a function to effect dependencies but &lt;em&gt;wrap its definition&lt;/em&gt;&lt;/strong&gt; into the &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook. This ensures it doesn&amp;rsquo;t change on every render unless &lt;em&gt;its own&lt;/em&gt; dependencies also change:</source>
          <target state="translated">최후의 수단으로, &lt;strong&gt;종속성에 영향을주는 함수를 추가&lt;em&gt;&lt;/em&gt;&lt;/strong&gt; 할 수 &lt;strong&gt;있지만 &lt;/strong&gt;&lt;strong&gt;&lt;em&gt;그 정의&lt;/em&gt;&lt;/strong&gt; 를 &lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt; Hook에 &lt;strong&gt;&lt;em&gt;래핑&lt;/em&gt;&lt;/strong&gt; 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 이렇게하면 &lt;em&gt;자체&lt;/em&gt; 종속성도 변경 되지 않는 한 모든 렌더링에서 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1c5485bb52f0ad6f3a9fdf0a95e59fa17727d5e7" translate="yes" xml:space="preserve">
          <source>As a last resort, you can pass an item&amp;rsquo;s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.</source>
          <target state="translated">최후의 수단으로 배열의 항목 색인을 키로 전달할 수 있습니다. 항목이 다시 정렬되지 않으면 제대로 작동하지만 다시 정렬이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="e8ce72b0e79de038d3533652e10d45dd26b90126" translate="yes" xml:space="preserve">
          <source>As a reminder, function components in React look like this:</source>
          <target state="translated">React의 함수 구성 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f7100670830cae6e122121b9df4b95c4bad9043" translate="yes" xml:space="preserve">
          <source>As a result, after React attaches the ref, &lt;code&gt;ref.current&lt;/code&gt; will point directly to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM element instance.</source>
          <target state="translated">결과적으로 React가 ref를 첨부 한 후 &lt;code&gt;ref.current&lt;/code&gt; 는 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM 요소 인스턴스를 직접 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="fe17b7bf9e2fae7dcd0fad9fb69936347ae61374" translate="yes" xml:space="preserve">
          <source>As a result, clicking &amp;ldquo;Next&amp;rdquo; doesn&amp;rsquo;t perform an immediate state transition to an &amp;ldquo;undesirable&amp;rdquo; loading state, but instead stays on the previous screen and communicates progress there.</source>
          <target state="translated">결과적으로&amp;ldquo;Next (다음)&amp;rdquo;를 클릭하면&amp;ldquo;바람직하지 않은&amp;rdquo;로딩 상태로 즉시 상태 전환이 수행되지 않고 대신 이전 화면에 머물러 진행 상태를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="dc5b42d938372321ac9f225b3a2bb1df4ed68810" translate="yes" xml:space="preserve">
          <source>As defined in the &lt;a href=&quot;https://www.w3.org/TR/pointerevents/&quot;&gt;W3 spec&lt;/a&gt;, pointer events extend &lt;a href=&quot;#mouse-events&quot;&gt;Mouse Events&lt;/a&gt; with the following properties:</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/pointerevents/&quot;&gt;W3 spec에&lt;/a&gt; 정의 된대로 포인터 이벤트 는 다음 특성으로 &lt;a href=&quot;#mouse-events&quot;&gt;마우스 이벤트&lt;/a&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="818f1373ccb0dd1f7001d028a458845e63ef8b97" translate="yes" xml:space="preserve">
          <source>As explained &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;in this blog post&lt;/a&gt;, certain legacy lifecycle methods are unsafe for use in async React applications. However, if your application uses third party libraries, it can be difficult to ensure that these lifecycles aren&amp;rsquo;t being used. Fortunately, strict mode can help with this!</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;이 블로그 게시물에서&lt;/a&gt; 설명한 것처럼 특정 레거시 라이프 사이클 방법은 비동기 React 애플리케이션에서 사용하기에 안전하지 않습니다. 그러나 응용 프로그램에서 타사 라이브러리를 사용하는 경우 이러한 수명주기가 사용되지 않는 것이 어려울 수 있습니다. 다행히도 엄격 모드가 도움이 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="618759a907e7cf1f51fefba731539d10be79d41a" translate="yes" xml:space="preserve">
          <source>As explained in the previous section, React intentionally &amp;ldquo;waits&amp;rdquo; until all components call &lt;code&gt;setState()&lt;/code&gt; in their event handlers before starting to re-render. This boosts performance by avoiding unnecessary re-renders.</source>
          <target state="translated">이전 섹션에서 설명한대로 React는 모든 컴포넌트 가 재 렌더링을 시작하기 전에 이벤트 핸들러에서 &lt;code&gt;setState()&lt;/code&gt; 를 호출 할 때까지 의도적으로&amp;ldquo;대기&amp;rdquo; 합니다. 불필요한 렌더링을 피함으로써 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="cd9c9857788846b2c841d045df4cafad143d07d6" translate="yes" xml:space="preserve">
          <source>As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the &lt;code&gt;persistForm&lt;/code&gt; effect) inside a condition?</source>
          <target state="translated">후크 호출 순서가 렌더간에 동일하면 React는 일부 로컬 상태를 각각의 로컬 상태와 연관시킬 수 있습니다. 그러나 조건 내에 Hook 호출 (예 : &lt;code&gt;persistForm&lt;/code&gt; 효과) 을 넣으면 어떻게됩니까 ?</target>
        </trans-unit>
        <trans-unit id="b31c654a2d76de2824154c42119bc22661141b6e" translate="yes" xml:space="preserve">
          <source>As of React 16, &lt;code&gt;componentDidUpdate&lt;/code&gt; no longer receives &lt;code&gt;prevContext&lt;/code&gt;.</source>
          <target state="translated">React 16부터 &lt;code&gt;componentDidUpdate&lt;/code&gt; 는 더 이상 &lt;code&gt;prevContext&lt;/code&gt; 를 받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="033173c312336a96f266a1dac29b328cbd27cc83" translate="yes" xml:space="preserve">
          <source>As of React 16, any standard &lt;a href=&quot;https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html&quot;&gt;or custom&lt;/a&gt; DOM attributes are fully supported.</source>
          <target state="translated">React 16부터 모든 표준 &lt;a href=&quot;https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html&quot;&gt;또는 사용자 정의&lt;/a&gt; DOM 속성이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="403350f5a4f73b11b9b9e7843a5d0bc9230d2ed0" translate="yes" xml:space="preserve">
          <source>As of v0.14, returning &lt;code&gt;false&lt;/code&gt; from an event handler will no longer stop event propagation. Instead, &lt;code&gt;e.stopPropagation()&lt;/code&gt; or &lt;code&gt;e.preventDefault()&lt;/code&gt; should be triggered manually, as appropriate.</source>
          <target state="translated">v0.14부터는 이벤트 핸들러에서 &lt;code&gt;false&lt;/code&gt; 를 반환 해도 더 이상 이벤트 전파가 중지되지 않습니다. 대신, &lt;code&gt;e.stopPropagation()&lt;/code&gt; 또는 &lt;code&gt;e.preventDefault()&lt;/code&gt; 를 적절하게 수동으로 트리거해야합니다.</target>
        </trans-unit>
        <trans-unit id="13ad1d16798f383be75cfa787bea2e38fd43fe07" translate="yes" xml:space="preserve">
          <source>As projects grow larger, they often use a mix of both of the above approaches in practice. So choosing the &amp;ldquo;right&amp;rdquo; one in the beginning isn&amp;rsquo;t very important.</source>
          <target state="translated">프로젝트가 커질수록 실제로 위의 두 가지 접근 방식을 혼합하여 사용하는 경우가 많습니다. 따라서 처음에 &quot;올바른&quot;것을 선택하는 것은 그리 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00113438ae91984d6aba1a6753e5b2b4f2f519a1" translate="yes" xml:space="preserve">
          <source>As the cursor moves around the screen, the component displays its (x, y) coordinates in a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">커서가 화면 주위를 이동함에 따라 구성 요소는 (x, y) 좌표를 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 에 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="8366d6776409ee82e022219e951f753575da678f" translate="yes" xml:space="preserve">
          <source>As we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned earlier&lt;/a&gt;, we can use multiple State or Effect Hooks in a single component:</source>
          <target state="translated">앞에서 &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;배운&lt;/a&gt; 대로 단일 구성 요소에 여러 상태 또는 효과 후크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="764b7a52100f17ee3b43966a190ebeb6ecb97870" translate="yes" xml:space="preserve">
          <source>As we change React over time, we try to minimize the effort required to take advantage of new features. When possible, we&amp;rsquo;ll keep an older API working, even if that means putting it in a separate package. For example, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;mixins have been discouraged for years&lt;/a&gt; but they&amp;rsquo;re supported to this day &lt;a href=&quot;react-without-es6#mixins&quot;&gt;via create-react-class&lt;/a&gt; and many codebases continue to use them in stable, legacy code.</source>
          <target state="translated">시간이 지남에 따라 React를 변경함에 따라 새로운 기능을 활용하는 데 필요한 노력을 최소화하려고합니다. 가능하면 별도의 패키지에 넣어도 이전 API는 계속 작동합니다. 예를 들어, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;믹스 인은 몇 년 동안 권장&lt;/a&gt; 되지 않았지만 오늘날까지는 &lt;a href=&quot;react-without-es6#mixins&quot;&gt;반응 형 클래스를 통해&lt;/a&gt; 지원 되며 많은 코드베이스가 안정적인 레거시 코드에서 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e4d83cd2ccd3ae3931db4245677908d70eb63547" translate="yes" xml:space="preserve">
          <source>As we learned from the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense walkthrough&lt;/a&gt;, any component can &amp;ldquo;suspend&amp;rdquo; any time if some data it needs is not ready yet. We can strategically place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries in different parts of the tree to handle this, but it won&amp;rsquo;t always be enough.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense 연습&lt;/a&gt; 을 통해 알 수 있듯이 필요한 일부 데이터가 아직 준비되지 않은 경우 언제든지 모든 구성 요소가&amp;ldquo;일시 중단&amp;rdquo;될 수 있습니다. 이를 처리하기 위해 전략적으로 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계를 트리의 다른 부분에 배치 할 수 있지만 항상 충분하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0c1ee1f2dae62b2799c090905f42ef24209ca8" translate="yes" xml:space="preserve">
          <source>As we load more data, React will retry rendering, and &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; can render successfully. Finally, we&amp;rsquo;re in the &lt;strong&gt;Skeleton&lt;/strong&gt; state. We see the new page with missing parts:</source>
          <target state="translated">더 많은 데이터를로드하면 React가 렌더링을 다시 시도하고 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 가 성공적으로 렌더링 될 수 있습니다. 마지막으로, 우리는 &lt;strong&gt;Skeleton&lt;/strong&gt; 상태입니다. 부품이 누락 된 새 페이지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="832019f9a5b2be6cc5ba14b337bebb38d050ddb6" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, if some state update causes a component to suspend, that state update should be wrapped in a transition. Let&amp;rsquo;s add &lt;code&gt;useTransition&lt;/code&gt; to our component:</source>
          <target state="translated">앞에서 언급했듯이 일부 상태 업데이트로 인해 구성 요소가 일시 중단되면 해당 상태 업데이트는 전환으로 래핑되어야합니다. 컴포넌트 에 &lt;code&gt;useTransition&lt;/code&gt; 을 추가하자 :</target>
        </trans-unit>
        <trans-unit id="dfc9c124f33b4d8a034d36e6d329f82371149ffa" translate="yes" xml:space="preserve">
          <source>As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; or &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; to typecheck your whole application. But even if you don&amp;rsquo;t use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special &lt;code&gt;propTypes&lt;/code&gt; property:</source>
          <target state="translated">앱이 성장함에 따라 유형 검사를 통해 많은 버그를 발견 할 수 있습니다. 일부 응용 프로그램의 경우 &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; 또는 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 와 같은 JavaScript 확장을 사용 하여 전체 응용 프로그램의 유형 을 확인할 수 있습니다 . 그러나 이것을 사용하지 않더라도 React에는 내장 유형 검사 기능이 있습니다. 구성 요소의 props에 대한 유형 검사를 실행하기 위해 특별한 &lt;code&gt;propTypes&lt;/code&gt; 특성을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39df56b20aa1f511f60e5016cdd8dacda9f05264" translate="yes" xml:space="preserve">
          <source>As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich React ecosystem. &lt;a href=&quot;create-a-new-react-app&quot;&gt;Learn how.&lt;/a&gt;</source>
          <target state="translated">응용 프로그램이 커질수록 더 통합 된 설정을 고려할 수 있습니다. 더 큰 응용 프로그램에 권장되는 몇 가지 JavaScript 툴체인이 있습니다. 각 구성은 거의 또는 전혀 구성없이 작동 할 수 있으며 풍부한 React 에코 시스템을 최대한 활용할 수 있습니다. &lt;a href=&quot;create-a-new-react-app&quot;&gt;어떻게하는지 배우다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d1c125db60a3ed69387c5dd6f32c2090c8a05" translate="yes" xml:space="preserve">
          <source>Asynchronous code (e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; callbacks)</source>
          <target state="translated">비동기 코드 (예 : &lt;code&gt;setTimeout&lt;/code&gt; 또는 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 콜백)</target>
        </trans-unit>
        <trans-unit id="1dc5bf90f358060e968febaa39d904a8cfea7f0c" translate="yes" xml:space="preserve">
          <source>At Facebook, so far we have only used the Relay integration with Suspense in production. &lt;strong&gt;If you&amp;rsquo;re looking for a practical guide to get started today, &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;check out the Relay Guide&lt;/a&gt;!&lt;/strong&gt; It demonstrates patterns that have already worked well for us in production.</source>
          <target state="translated">Facebook에서는 지금까지 프로덕션 환경에서 Suspense와의 Relay 통합 만 사용했습니다. &lt;strong&gt;오늘 시작하기위한 실용적인 가이드를 찾고 있다면 &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;Relay Guide를 확인하십시오&lt;/a&gt; ! &lt;/strong&gt;프로덕션 환경에서 이미 잘 작동 한 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2f6d9081fe7eb7ee0d370f5453d055df7593e98f" translate="yes" xml:space="preserve">
          <source>At Facebook, we use React in thousands of components, and we haven&amp;rsquo;t found any use cases where we would recommend creating component inheritance hierarchies.</source>
          <target state="translated">Facebook에서는 수천 개의 구성 요소에서 React를 사용하며 구성 요소 상속 계층을 만드는 것이 권장되는 사용 사례를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="7302e3429aa52da228df9adeaf52381981fec228" translate="yes" xml:space="preserve">
          <source>At React Conf 2018, Sophie Alpert and Dan Abramov introduced Hooks, followed by Ryan Florence demonstrating how to refactor an application to use them. Watch the video here:</source>
          <target state="translated">React Conf 2018에서 Sophie Alpert와 Dan Abramov는 Hooks를 소개 한 다음 Ryan Florence가 애플리케이션을 리팩터링하여 사용하는 방법을 시연했습니다. 여기 비디오를보십시오 :</target>
        </trans-unit>
        <trans-unit id="562ffc6d5d4c2b54a60539bae99dd32ecf6ac12b" translate="yes" xml:space="preserve">
          <source>At first glance, this code might not seem problematic. But if &lt;code&gt;SharedApplicationState.recordEvent&lt;/code&gt; is not &lt;a href=&quot;https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning&quot;&gt;idempotent&lt;/a&gt;, then instantiating this component multiple times could lead to invalid application state. This sort of subtle bug might not manifest during development, or it might do so inconsistently and so be overlooked.</source>
          <target state="translated">언뜻보기 에이 코드는 문제가되지 않을 수 있습니다. 그러나 &lt;code&gt;SharedApplicationState.recordEvent&lt;/code&gt; 가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning&quot;&gt;idempotent&lt;/a&gt; 가 아닌 경우이 컴포넌트를 여러 번 인스턴스화하면 애플리케이션 상태가 올바르지 않을 수 있습니다. 이러한 종류의 미묘한 버그는 개발 중에 나타나지 않거나 일관성이 없어 간과 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26383eadb177782413aa518c405bb97fbb4ce3d4" translate="yes" xml:space="preserve">
          <source>At the end of this step, you&amp;rsquo;ll have a library of reusable components that render your data model. The components will only have &lt;code&gt;render()&lt;/code&gt; methods since this is a static version of your app. The component at the top of the hierarchy (&lt;code&gt;FilterableProductTable&lt;/code&gt;) will take your data model as a prop. If you make a change to your underlying data model and call &lt;code&gt;ReactDOM.render()&lt;/code&gt; again, the UI will be updated. You can see how your UI is updated and where to make changes. React&amp;rsquo;s &lt;strong&gt;one-way data flow&lt;/strong&gt; (also called &lt;em&gt;one-way binding&lt;/em&gt;) keeps everything modular and fast.</source>
          <target state="translated">이 단계가 끝나면 데이터 모델을 렌더링하는 재사용 가능한 구성 요소 라이브러리가 제공됩니다. 구성 요소는 &lt;code&gt;render()&lt;/code&gt; 메서드 만 갖습니다. 이는 정적 버전의 앱이기 때문입니다. 계층 구조 맨 위에있는 컴포넌트 ( &lt;code&gt;FilterableProductTable&lt;/code&gt; )는 데이터 모델을 소품으로 사용합니다. 기본 데이터 모델을 변경하고 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 다시 호출 하면 UI가 업데이트됩니다. UI 업데이트 방법과 변경 위치를 확인할 수 있습니다. React의 &lt;strong&gt;단방향 데이터 흐름&lt;/strong&gt; ( &lt;em&gt;단방향 바인딩&lt;/em&gt; 이라고도 함 )은 모든 것을 모듈 식으로 빠르게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="74e0bba770e87968ab26b848711abfb803e1c0f7" translate="yes" xml:space="preserve">
          <source>At the very end, we have the &lt;strong&gt;Complete&lt;/strong&gt; state. That&amp;rsquo;s where we want to eventually get to. It represents the moment when the next screen is fully rendered and isn&amp;rsquo;t loading more data.</source>
          <target state="translated">마지막에 &lt;strong&gt;Complete&lt;/strong&gt; 상태가됩니다. 그것이 우리가 결국 가고 싶은 곳입니다. 다음 화면이 완전히 렌더링되고 더 많은 데이터를로드하지 않는 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5105254b950ac5e7e4446016356e7930719e71d9" translate="yes" xml:space="preserve">
          <source>At this point you might be questioning how Hooks work. How can React know which &lt;code&gt;useState&lt;/code&gt; call corresponds to which state variable between re-renders? How does React &amp;ldquo;match up&amp;rdquo; previous and next effects on every update? &lt;strong&gt;On the next page we will learn about the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt; &amp;mdash; they&amp;rsquo;re essential to making Hooks work.&lt;/strong&gt;</source>
          <target state="translated">이 시점에서 후크의 작동 방식에 의문이 생길 수 있습니다. React는 어떤 &lt;code&gt;useState&lt;/code&gt; 호출이 다시 렌더링 사이의 상태 변수에 해당 하는지 어떻게 알 수 있습니까? React는 모든 업데이트에서 이전 및 다음 효과를 어떻게 &quot;매치&quot;합니까? &lt;strong&gt;다음 페이지 &lt;a href=&quot;hooks-rules&quot;&gt;에서 후크 규칙에&lt;/a&gt; 대해 배울 것 입니다. 후크 규칙이 작동하는 데 필수적입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80e39c486abc649f7d406023b110351f1fdad529" translate="yes" xml:space="preserve">
          <source>Autobinding</source>
          <target state="translated">Autobinding</target>
        </trans-unit>
        <trans-unit id="7b94f520dbb3d9f5f6fda5d519ac3d2d646365b5" translate="yes" xml:space="preserve">
          <source>Automatic batching of multiple setStates</source>
          <target state="translated">여러 setState의 자동 일괄 처리</target>
        </trans-unit>
        <trans-unit id="e7991af76c55eda34a6c01f9d6c116afce98b121" translate="yes" xml:space="preserve">
          <source>Avoid Reconciliation</source>
          <target state="translated">화해를 피하십시오</target>
        </trans-unit>
        <trans-unit id="c4e69b1251a4645e4fe693144ad0d39b96d5a86e" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="translated">생성자에 부작용이나 구독을 도입하지 마십시오. 이러한 사용 사례에서는 &lt;code&gt;componentDidMount()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d24bc0df81c7d22eed18963eb1d9624a35b8cb7" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in this method. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="translated">이 방법으로 부작용이나 가입을 피하십시오. 이러한 사용 사례에서는 &lt;code&gt;componentDidMount()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4fca525db1716e6a4bcd310f1d426c924d3708ce" translate="yes" xml:space="preserve">
          <source>Avoid too much nesting</source>
          <target state="translated">너무 많은 중첩을 피하십시오</target>
        </trans-unit>
        <trans-unit id="ee809aaec4799cc78442a3c9e58c07254689d1a6" translate="yes" xml:space="preserve">
          <source>Avoid using refs for anything that can be done declaratively.</source>
          <target state="translated">선언적으로 수행 할 수있는 작업에 대해서는 심판을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="68719a521ce64ee99b472a32090730e97b03a0bd" translate="yes" xml:space="preserve">
          <source>Babel compiles JSX down to &lt;code&gt;React.createElement()&lt;/code&gt; calls.</source>
          <target state="translated">Babel은 JSX를 &lt;code&gt;React.createElement()&lt;/code&gt; 호출 로 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="914c83643b2be4f506bd8959464e1bd675ef315d" translate="yes" xml:space="preserve">
          <source>Babel, JSX, and Build Steps</source>
          <target state="translated">바벨, JSX 및 빌드 단계</target>
        </trans-unit>
        <trans-unit id="bc7b7da33082bcecbc995c1e674c7c8aa270d35b" translate="yes" xml:space="preserve">
          <source>Bailing out of a dispatch</source>
          <target state="translated">파견에서 베일 링</target>
        </trans-unit>
        <trans-unit id="135d9cb156a9487640dc85edc375539a96f482ba" translate="yes" xml:space="preserve">
          <source>Bailing out of a state update</source>
          <target state="translated">상태 업데이트 중단</target>
        </trans-unit>
        <trans-unit id="a8fd52172de461f29c3a89d176e6d0e6ed5d6119" translate="yes" xml:space="preserve">
          <source>Baking Transitions Into the Design System</source>
          <target state="translated">디자인 시스템으로의 전환</target>
        </trans-unit>
        <trans-unit id="2a0ce5afffc4308d702fd2d099aaafaa74b72325" translate="yes" xml:space="preserve">
          <source>Basic Hooks</source>
          <target state="translated">기본 후크</target>
        </trans-unit>
        <trans-unit id="99942a359054b0aad74f6a2e0e9656460e19cbb3" translate="yes" xml:space="preserve">
          <source>Basic List Component</source>
          <target state="translated">기본 목록 구성 요소</target>
        </trans-unit>
        <trans-unit id="536f63c62210e606c0473c51969c2b54474aeeef" translate="yes" xml:space="preserve">
          <source>Be careful when using Render Props with React.PureComponent</source>
          <target state="translated">React.PureComponent와 함께 렌더 소품을 사용할 때주의하십시오</target>
        </trans-unit>
        <trans-unit id="952ce7ad0378eb55b86bd553bf802d759d4491d0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; may be updated asynchronously, you should not rely on their values for calculating the next state.</source>
          <target state="translated">때문에 &lt;code&gt;this.props&lt;/code&gt; 가 와 &lt;code&gt;this.state&lt;/code&gt; 가 비동기 적으로 업데이트 될 수 있습니다, 당신은 다음 상태를 계산하기 위해 그 값에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0514856166ee495c557a4ac04e3b999ac49d2fcf" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;withSubscription&lt;/code&gt; is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the &lt;code&gt;data&lt;/code&gt; prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.</source>
          <target state="translated">&lt;code&gt;withSubscription&lt;/code&gt; 은 일반적인 함수 이므로 원하는 만큼 인수를 추가 할 수 있습니다. 예를 들어, HOC를 랩핑 된 구성 요소에서 추가로 분리하기 위해 &lt;code&gt;data&lt;/code&gt; 소품 의 이름을 구성 가능 하게 만들 수 있습니다 . 또는 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 구성하는 인수 또는 데이터 소스를 구성 하는 인수를 승인 할 수 있습니다. HOC가 구성 요소를 정의하는 방법을 완전히 제어 할 수 있기 때문에이 모든 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d3fcd85e0dbb2ed68b4581e1ffe0327ac0f12f77" translate="yes" xml:space="preserve">
          <source>Because React relies on heuristics, if the assumptions behind them are not met, performance will suffer.</source>
          <target state="translated">React는 휴리스틱에 의존하기 때문에 배후의 가정이 충족되지 않으면 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="1695654a25412ec23a92b4da904f1d5da03ee426" translate="yes" xml:space="preserve">
          <source>Because context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider&amp;rsquo;s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">컨텍스트는 참조 ID를 사용하여 다시 렌더링 할시기를 결정하므로 공급자의 부모가 다시 렌더링 할 때 소비자에서 의도하지 않은 렌더링을 트리거 할 수있는 문제가 있습니다. 예를 들어 아래 코드는 항상 &lt;code&gt;value&lt;/code&gt; 위해 새 객체가 생성되므로 공급자가 다시 렌더링 할 때마다 모든 소비자를 다시 렌더링 합니다 .</target>
        </trans-unit>
        <trans-unit id="783b65ac0879142e03482c962fd5b17c0404d5e7" translate="yes" xml:space="preserve">
          <source>Because its value is read-only, it is an &lt;strong&gt;uncontrolled&lt;/strong&gt; component in React. It is discussed together with other uncontrolled components &lt;a href=&quot;uncontrolled-components#the-file-input-tag&quot;&gt;later in the documentation&lt;/a&gt;.</source>
          <target state="translated">값은 읽기 전용이므로 React에서 &lt;strong&gt;제어되지 않는&lt;/strong&gt; 구성 요소입니다. 이 &lt;a href=&quot;uncontrolled-components#the-file-input-tag&quot;&gt;문서의 뒷부분에서&lt;/a&gt; 제어되지 않는 다른 구성 요소와 함께 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6834a012393a7506dbe08e3c25a07f88133bd28e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;useState&lt;/code&gt; Hook call gives us the latest value of the &lt;code&gt;recipientID&lt;/code&gt; state variable, we can pass it to our custom &lt;code&gt;useFriendStatus&lt;/code&gt; Hook as an argument:</source>
          <target state="translated">때문에 &lt;code&gt;useState&lt;/code&gt; 의 후크 호출이 우리에게 최신 값을 제공 &lt;code&gt;recipientID&lt;/code&gt; 의 상태 변수를, 우리는 우리의 정의에 전달할 수 &lt;code&gt;useFriendStatus&lt;/code&gt; 의 인수로 후크 :</target>
        </trans-unit>
        <trans-unit id="d4ff48f11dbd74f3d79aff032eb482ce7d1b7fe8" translate="yes" xml:space="preserve">
          <source>Because the above methods might be called more than once, it&amp;rsquo;s important that they do not contain side-effects. Ignoring this rule can lead to a variety of problems, including memory leaks and invalid application state. Unfortunately, it can be difficult to detect these problems as they can often be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;non-deterministic&lt;/a&gt;.</source>
          <target state="translated">위의 메소드는 두 번 이상 호출 될 수 있으므로 부작용을 포함하지 않는 것이 중요합니다. 이 규칙을 무시하면 메모리 누수 및 유효하지 않은 응용 프로그램 상태를 비롯한 다양한 문제가 발생할 수 있습니다. 불행히도, 이러한 문제는 종종 &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;비 결정적&lt;/a&gt; 일 수 있으므로 이러한 문제를 감지하기가 어려울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3571671a5e1639faebc1c823c32a5cadb3bcaafb" translate="yes" xml:space="preserve">
          <source>Before You Use Context</source>
          <target state="translated">컨텍스트를 사용하기 전에</target>
        </trans-unit>
        <trans-unit id="a8cfd2c717528576c9d11598e3196f395280cbed" translate="yes" xml:space="preserve">
          <source>Before deploying your website to production, be mindful that unminified JavaScript can significantly slow down the page for your users.</source>
          <target state="translated">웹 사이트를 프로덕션 환경에 배포하기 전에 축소되지 않은 JavaScript로 인해 사용자의 페이지 속도가 크게 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040170e2405edee8c93a45941ebf02a1c10a5f1c" translate="yes" xml:space="preserve">
          <source>Before diving into the changes in the &lt;code&gt;Calculator&lt;/code&gt;, let&amp;rsquo;s recap our changes to the &lt;code&gt;TemperatureInput&lt;/code&gt; component. We have removed the local state from it, and instead of reading &lt;code&gt;this.state.temperature&lt;/code&gt;, we now read &lt;code&gt;this.props.temperature&lt;/code&gt;. Instead of calling &lt;code&gt;this.setState()&lt;/code&gt; when we want to make a change, we now call &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt;, which will be provided by the &lt;code&gt;Calculator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Calculator&lt;/code&gt; 의 변경 사항을 살펴보기 전에 &lt;code&gt;TemperatureInput&lt;/code&gt; 구성 요소 의 변경 사항을 다시 살펴 보겠습니다 . 로컬 상태를 제거했으며 &lt;code&gt;this.state.temperature&lt;/code&gt; 를 읽는 대신 &lt;code&gt;this.props.temperature&lt;/code&gt; 를 읽습니다 . 대신 호출 &lt;code&gt;this.setState()&lt;/code&gt; 우리가 변경하고자 할 때, 우리가 지금 전화 &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; 에 의해 제공됩니다, &lt;code&gt;Calculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaf57eb0650f409bbc5c970415d2cfcbb8a2a10f" translate="yes" xml:space="preserve">
          <source>Before version control existed, the development workflow was very different. There was no concept of branches. If you wanted to edit some files, you had to tell everyone not to touch those files until you&amp;rsquo;ve finished your work. You couldn&amp;rsquo;t even start working on them concurrently with that person &amp;mdash; you were literally &lt;em&gt;blocked&lt;/em&gt; by them.</source>
          <target state="translated">버전 제어가 존재하기 전에 개발 워크 플로우는 매우 달랐습니다. 가지에 대한 개념은 없었습니다. 일부 파일을 편집하려면 작업이 완료 될 때까지 모든 사람이 해당 파일을 건드리지 말라고 지시해야합니다. 당신은 그 사람과 동시에 작업을 시작할 수 없었 &lt;em&gt;습니다&lt;/em&gt; &amp;ndash; 당신은 그들에 의해 문자 적으로 &lt;em&gt;막혔&lt;/em&gt; 습니다.</target>
        </trans-unit>
        <trans-unit id="18a8dd8247a7da7ad888e1dbb5ad92ff53dcdd84" translate="yes" xml:space="preserve">
          <source>Before we continue, note that Hooks are:</source>
          <target state="translated">계속하기 전에 후크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e5c13cd58e6b7adc6f8db48c50ae3b58895a388" translate="yes" xml:space="preserve">
          <source>Before you build components with an API similar to this, consider if there are cleaner alternatives. For example, you can pass entire React components as props if you&amp;rsquo;d like to.</source>
          <target state="translated">이와 비슷한 API로 구성 요소를 작성하기 전에 더 확실한 대안이 있는지 고려하십시오. 예를 들어 원하는 경우 전체 React 구성 요소를 소품으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81ad8d9cf9cfee67865d8f6f11aeb7feedca5fd" translate="yes" xml:space="preserve">
          <source>Below, we loop through the &lt;code&gt;numbers&lt;/code&gt; array using the JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function. We return a &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element for each item. Finally, we assign the resulting array of elements to &lt;code&gt;listItems&lt;/code&gt;:</source>
          <target state="translated">아래에서는 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 &lt;code&gt;numbers&lt;/code&gt; 배열을 반복 합니다. 각 항목에 대해 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 반환합니다 . 마지막으로 요소의 결과 배열을 &lt;code&gt;listItems&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="600febdf3065222e268db7a6433b505e78f78df3" translate="yes" xml:space="preserve">
          <source>Below, we will create a Backbone view called &lt;code&gt;ParagraphView&lt;/code&gt;. It will override Backbone&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function to render a React &lt;code&gt;&amp;lt;Paragraph&amp;gt;&lt;/code&gt; component into the DOM element provided by Backbone (&lt;code&gt;this.el&lt;/code&gt;). Here, too, we are using &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">아래에서는 &lt;code&gt;ParagraphView&lt;/code&gt; 라는 Backbone 뷰를 만듭니다 . Backbone의 &lt;code&gt;render()&lt;/code&gt; 함수를 재정 의하여 React &lt;code&gt;&amp;lt;Paragraph&amp;gt;&lt;/code&gt; 컴포넌트를 Backbone에서 제공하는 DOM 요소 ( &lt;code&gt;this.el&lt;/code&gt; ) 로 렌더링합니다 . 여기에서도 &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="547e99fc0bf895cd16cd891408908780f2697664" translate="yes" xml:space="preserve">
          <source>Bind in Constructor (ES2015)</source>
          <target state="translated">생성자에 바인딩 (ES2015)</target>
        </trans-unit>
        <trans-unit id="915ea487cc3b39a7adc8a9e625171040ae3bf235" translate="yes" xml:space="preserve">
          <source>Bind in Render</source>
          <target state="translated">렌더에 바인딩</target>
        </trans-unit>
        <trans-unit id="24e569b3d8c05d2c4868ac39c7f6ad05cecc38bc" translate="yes" xml:space="preserve">
          <source>Bind methods in the constructor.</source>
          <target state="translated">생성자에 메소드를 바인드하십시오.</target>
        </trans-unit>
        <trans-unit id="bd51dbb8bb35b2a59d6adbf6c050dc5843aa17f1" translate="yes" xml:space="preserve">
          <source>Binding &lt;a href=&quot;handling-events&quot;&gt;event handler&lt;/a&gt; methods to an instance.</source>
          <target state="translated">&lt;a href=&quot;handling-events&quot;&gt;이벤트 핸들러&lt;/a&gt; 메소드를 인스턴스에 바인딩</target>
        </trans-unit>
        <trans-unit id="31510573bcbe544079b9ddf410c0de8e9afe5ec8" translate="yes" xml:space="preserve">
          <source>Binding methods helps ensure that the second snippet works the same way as the first one.</source>
          <target state="translated">바인딩 방법은 두 번째 스 니펫이 첫 번째 스 니펫과 동일한 방식으로 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="21f2ebc2d6a92580d8b1336c1e75a33c854dce24" translate="yes" xml:space="preserve">
          <source>Blocking Mode</source>
          <target state="translated">차단 모드</target>
        </trans-unit>
        <trans-unit id="db618e237590bc242942196c81d7170abbb33772" translate="yes" xml:space="preserve">
          <source>Blocking Mode only contains a small subset of Concurrent Mode features and is intended as an intermediary migration step for apps that are unable to migrate directly.</source>
          <target state="translated">차단 모드에는 동시 모드 기능 중 일부만 포함되며 직접 마이그레이션 할 수없는 앱의 중간 마이그레이션 단계로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ed57d00f5e5dced888a9218f9ad79a68850bd18" translate="yes" xml:space="preserve">
          <source>Blocking vs Interruptible Rendering</source>
          <target state="translated">차단 및 인터럽트 가능한 렌더링</target>
        </trans-unit>
        <trans-unit id="593cf8333034572ec33f064b1bc2b4ffe160093e" translate="yes" xml:space="preserve">
          <source>Booleans, Null, and Undefined Are Ignored</source>
          <target state="translated">부울, 널 및 정의되지 않음은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a70c82e35eccc055c5ed05e9e43b64b55ddaacea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; need data to render, so they suspend:</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 모두 렌더링 할 데이터가 필요하므로 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c3135a23f4c6c803e268b564382bb3f6d56077" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">업데이터 기능이 수신 한 &lt;code&gt;state&lt;/code&gt; 와 &lt;code&gt;props&lt;/code&gt; 은 모두 최신 상태입니다. 업데이터의 출력은 &lt;code&gt;state&lt;/code&gt; 와 얕게 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="99f8d1fc7b82e36a68e9d0047d23afa00eafc0ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useReducer&lt;/code&gt; Hooks &lt;a href=&quot;hooks-reference#bailing-out-of-a-state-update&quot;&gt;bail out of updates&lt;/a&gt; if the next value is the same as the previous one. Mutating state in place and calling &lt;code&gt;setState&lt;/code&gt; will not cause a re-render.</source>
          <target state="translated">두 &lt;code&gt;useState&lt;/code&gt; 및 &lt;code&gt;useReducer&lt;/code&gt; 후크 &lt;a href=&quot;hooks-reference#bailing-out-of-a-state-update&quot;&gt;업데이트의 구제&lt;/a&gt; 다음 값은 이전과 동일합니다. 상태를 변경하고 &lt;code&gt;setState&lt;/code&gt; 를 호출 해도 다시 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8363bce31adc44778f01714744541a7deed996" translate="yes" xml:space="preserve">
          <source>Both React and ReactDOM are available over a CDN.</source>
          <target state="translated">React 및 ReactDOM은 모두 CDN을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2330211501f9f5b88000d1ad778e502a3efda72f" translate="yes" xml:space="preserve">
          <source>Both putting all state in a single &lt;code&gt;useState&lt;/code&gt; call, and having a &lt;code&gt;useState&lt;/code&gt; call per each field can work. Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables. If the state logic becomes complex, we recommend &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;managing it with a reducer&lt;/a&gt; or a custom Hook.</source>
          <target state="translated">모든 상태를 단일 &lt;code&gt;useState&lt;/code&gt; 호출에 배치하고 각 필드 당 &lt;code&gt;useState&lt;/code&gt; 호출을 수행 할 수 있습니다. 구성 요소는이 두 극단 사이의 균형을 찾을 때 가장 읽기 쉬운 경향이 있으며 관련 상태를 몇 개의 독립적 인 상태 변수로 그룹화합니다. 상태 논리가 복잡해지면 &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;감속기&lt;/a&gt; 또는 사용자 정의 후크로 관리하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b1266309444291ef2747fd8db6fb75c9fa22d40d" translate="yes" xml:space="preserve">
          <source>Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors.</source>
          <target state="translated">아래에 언급 된 도끼 및 WAVE 도구는 모두 색상 대비 테스트를 포함하며 대비 오류에 대해보고합니다.</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="29604ed4c392a3cd09654b8ef0d3dc61f5d45c88" translate="yes" xml:space="preserve">
          <source>Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases &amp;ndash; for example, React 15 was released in April 2016 and React 16 was released in September 2017; React 17 isn&amp;rsquo;t expected until 2019.</source>
          <target state="translated">주요 변경 사항은 모든 사람에게 불편하므로 우리는 주요 릴리스 수를 최소화하려고합니다. 예를 들어 2016 년 4 월에 React 15가 릴리스되었고 2017 년 9 월에 React 16이 릴리스되었습니다. 반응 17은 2019 년까지는 예상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02a8c960030f2f9457b2f49cecd3b0e346163641" translate="yes" xml:space="preserve">
          <source>Browser Support</source>
          <target state="translated">브라우저 지원</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="2cd0b835cf9277cb4f1eeb472cef193a26204fa8" translate="yes" xml:space="preserve">
          <source>Brunch</source>
          <target state="translated">Brunch</target>
        </trans-unit>
        <trans-unit id="252a02556e2e6dfccb3d4546230735cc62300a37" translate="yes" xml:space="preserve">
          <source>Building Your Own Hooks</source>
          <target state="translated">자신 만의 고리 만들기</target>
        </trans-unit>
        <trans-unit id="801624525b70cf0c1e363814c966a45e726332b7" translate="yes" xml:space="preserve">
          <source>Building your own Hooks lets you extract component logic into reusable functions.</source>
          <target state="translated">자신 만의 후크를 만들면 컴포넌트 로직을 재사용 가능한 함수로 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b95c67ea8c62ea338acaa3ab52d037eed3d3d37" translate="yes" xml:space="preserve">
          <source>Bundlers</source>
          <target state="translated">Bundlers</target>
        </trans-unit>
        <trans-unit id="61c4e91324c0e358214e2aefb4dcb8f12b9c66b7" translate="yes" xml:space="preserve">
          <source>Bundlers take JavaScript and CSS code written as separate modules (often hundreds of them), and combine them together into a few files better optimized for the browsers. Some bundlers commonly used in React applications include &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;.</source>
          <target state="translated">번 들러는 별도의 모듈 (일반적으로 수백 개)로 작성된 JavaScript 및 CSS 코드를 가져 와서 브라우저에 최적화 된 몇 개의 파일로 결합합니다. React 애플리케이션에서 일반적으로 사용되는 일부 번 &lt;a href=&quot;http://browserify.org/&quot;&gt;들러&lt;/a&gt; 에는 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; 및 Browserify가 있습니다.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="95bc601b586c2c7743bfe7dc0ae3037683e3f885" translate="yes" xml:space="preserve">
          <source>Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don&amp;rsquo;t accidentally make it so large that your app takes a long time to load.</source>
          <target state="translated">번들링은 훌륭하지만 앱이 커지면 번들도 커집니다. 특히 큰 타사 라이브러리를 포함하는 경우. 번들에 포함 된 코드를 주시하여 실수로 앱을로드하는 데 시간이 오래 걸리도록 크게 만들지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="340e52d34ce7741273105f426520d1a718cdd2d4" translate="yes" xml:space="preserve">
          <source>But before our screen can be Complete, we might need to load some data or code. When we&amp;rsquo;re on the next screen, but some parts of it are still loading, we call that a &lt;strong&gt;Skeleton&lt;/strong&gt; state.</source>
          <target state="translated">그러나 화면이 완성되기 전에 데이터 나 코드를로드해야 할 수도 있습니다. 다음 화면에 있지만 일부 화면이 계속로드되는 경우이를 &lt;strong&gt;스켈레톤&lt;/strong&gt; 상태라고합니다.</target>
        </trans-unit>
        <trans-unit id="fe393ab8011453c8fff65077d0e7c7a078bbbef6" translate="yes" xml:space="preserve">
          <source>But how do you know what should be its own component? Use the same techniques for deciding if you should create a new function or object. One such technique is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;single responsibility principle&lt;/a&gt;, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</source>
          <target state="translated">그러나 자체 구성 요소가 무엇인지 어떻게 알 수 있습니까? 새로운 함수 나 객체를 생성해야하는지 결정하는 데 동일한 기술을 사용하십시오. 그러한 기술 중 하나는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;단일 책임 원칙입니다&lt;/a&gt; . 즉, 구성 요소는 이상적으로 한 가지만 수행해야합니다. 결국 자라면 더 작은 하위 구성 요소로 분해되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4002e235631449f2ad3ed8865ba272950edad071" translate="yes" xml:space="preserve">
          <source>But what is a Hook?</source>
          <target state="translated">그러나 후크 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d63aebb97dd257c4ba024f7f8d622fd2f3c2ead2" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;childContextTypes&lt;/code&gt; and &lt;code&gt;getChildContext&lt;/code&gt; to &lt;code&gt;MessageList&lt;/code&gt; (the context provider), React passes the information down automatically and any component in the subtree (in this case, &lt;code&gt;Button&lt;/code&gt;) can access it by defining &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="translated">추가함으로써 &lt;code&gt;childContextTypes&lt;/code&gt; 및 &lt;code&gt;getChildContext&lt;/code&gt; 을 에 &lt;code&gt;MessageList&lt;/code&gt; 의 (문맥 제공자) 반작용 아래로 자동으로 정보와 서브 트리의 임의의 성분 (이 경우에, 전달 &lt;code&gt;Button&lt;/code&gt; 정의하는 액세스 가능) &lt;code&gt;contextTypes&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="93a38ad0a770cf395a928bd96b4b28770666edf3" translate="yes" xml:space="preserve">
          <source>By comparing these two elements, React knows to only modify the &lt;code&gt;className&lt;/code&gt; on the underlying DOM node.</source>
          <target state="translated">이 두 요소를 비교함으로써 React는 기본 DOM 노드 에서 &lt;code&gt;className&lt;/code&gt; 만 수정한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2a2d61ba0b6800612c77121ae46d0499703856" translate="yes" xml:space="preserve">
          <source>By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument.</source>
          <target state="translated">기본적으로 props 객체의 복잡한 객체 만 얕게 비교합니다. 비교를 제어하려면 두 번째 인수로 사용자 정의 비교 함수를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1ac0f6c8b53390d8382186e5c3b232ba4fda16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;SuspenseList&lt;/code&gt; will show all fallbacks in the list.</source>
          <target state="translated">기본적으로 &lt;code&gt;SuspenseList&lt;/code&gt; 는 목록의 모든 대체를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4153024f7b260481eccaf5b1c744b88ec28ecd31" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;you may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances:</source>
          <target state="translated">기본적 &lt;strong&gt;으로 함수 구성 요소&lt;/strong&gt; 에는 인스턴스가 없으므로 &lt;strong&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 속성을 &lt;/strong&gt;&lt;strong&gt;사용할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a3928b9ef8d6d202d79b0190a10bc6653b909e33" translate="yes" xml:space="preserve">
          <source>By default, Flow only checks the files that include this annotation:</source>
          <target state="translated">기본적으로 Flow는이 주석이 포함 된 파일 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d5be072c86160481c917656cc53270b05bd27346" translate="yes" xml:space="preserve">
          <source>By default, React DOM &lt;a href=&quot;https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html&quot;&gt;escapes&lt;/a&gt; any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that&amp;rsquo;s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS (cross-site-scripting)&lt;/a&gt; attacks.</source>
          <target state="translated">기본적으로 React DOM 은 JSX에 포함 된 값을 렌더링하기 전에 &lt;a href=&quot;https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html&quot;&gt;이스케이프&lt;/a&gt; 합니다. 따라서 응용 프로그램에 명시 적으로 작성되지 않은 것은 주입 할 수 없습니다. 모든 것이 렌더링되기 전에 문자열로 변환됩니다. 이를 통해 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS (교차 사이트 스크립팅)&lt;/a&gt; 공격을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14e2022d31bee1bdbaf6abdb0b23ef50d12acc56" translate="yes" xml:space="preserve">
          <source>By default, React always renders a consistent UI. Consider code like this:</source>
          <target state="translated">기본적으로 React는 항상 일관된 UI를 렌더링합니다. 다음과 같은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="449fb3e80b766c4a1a364e3d0dfbcf560387a6b4" translate="yes" xml:space="preserve">
          <source>By default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app.</source>
          <target state="translated">기본적으로 React에는 많은 유용한 경고가 포함되어 있습니다. 이러한 경고는 개발에 매우 ​​유용합니다. 그러나 React는 더 크고 느리게 만들므로 앱을 배포 할 때 프로덕션 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48bb58e45e1f538d4137553558f70ce76bbfed18" translate="yes" xml:space="preserve">
          <source>By default, effects run after every completed render, but you can choose to fire them &lt;a href=&quot;#conditionally-firing-an-effect&quot;&gt;only when certain values have changed&lt;/a&gt;.</source>
          <target state="translated">기본적으로 효과는 렌더링이 완료 될 때마다 실행되지만 &lt;a href=&quot;#conditionally-firing-an-effect&quot;&gt;특정 값이 변경된 경우에만 효과&lt;/a&gt; 를 발생하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c423b89d02a892510754488b2f34e98c538c1e8d" translate="yes" xml:space="preserve">
          <source>By default, our loading sequence is Receded &amp;rarr; Skeleton &amp;rarr; Complete.</source>
          <target state="translated">기본적으로 로딩 순서는 Receded &amp;rarr; Skeleton &amp;rarr; Complete입니다.</target>
        </trans-unit>
        <trans-unit id="d7b45cc73c2029a9cd6bb59406302967cf1876ef" translate="yes" xml:space="preserve">
          <source>By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there&amp;rsquo;s a difference.</source>
          <target state="translated">기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하여 차이가있을 때마다 돌연변이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7254bbb62790d0326da6f1e08d05223e3e28bcd4" translate="yes" xml:space="preserve">
          <source>By default, when your component&amp;rsquo;s state or props change, your component will re-render. If your &lt;code&gt;render()&lt;/code&gt; method depends on some other data, you can tell React that the component needs re-rendering by calling &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="translated">기본적으로 구성 요소의 상태 또는 소품이 변경되면 구성 요소가 다시 렌더링됩니다. 귀하의 경우 &lt;code&gt;render()&lt;/code&gt; 메소드가 다른 데이터에 의존, 당신은 구성 요소를 필요 호출하여 렌더링을 다시 것을 반작용 알 수 있습니다 &lt;code&gt;forceUpdate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbabc1da5915813efd358a159900222057c873db" translate="yes" xml:space="preserve">
          <source>By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by:</source>
          <target state="translated">지금까지 가장 쉽고 가장 중요한 검사 중 하나는 전체 웹 사이트에 도달하여 키보드만으로 사용할 수 있는지 테스트하는 것입니다. 이를 통해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a2a10d22e535e79dc550a3e6a110a7d6e3d60d34" translate="yes" xml:space="preserve">
          <source>By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.</source>
          <target state="translated">이 규칙을 따르면 구성 요소의 모든 상태 저장 논리를 소스 코드에서 명확하게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3501f060fe67386a08f58c0aa7df54c202ed340f" translate="yes" xml:space="preserve">
          <source>By intentionally double-invoking methods like the component constructor, strict mode makes patterns like this easier to spot.</source>
          <target state="translated">엄격 모드는 구성 요소 생성자와 같은 메서드를 의도적으로 이중 호출함으로써 이와 같은 패턴을 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e70659365a618fa5e538cab7a7ed3a779ea0f2ed" translate="yes" xml:space="preserve">
          <source>By now we have discussed all of the different visual states that an update may go through. In this section, we will give them names and talk about the progression between them.</source>
          <target state="translated">지금까지 업데이트가 진행될 수있는 다양한 시각적 상태를 모두 살펴 보았습니다. 이 섹션에서 우리는 그들에게 이름을 부여하고 그들 사이의 진행에 대해 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8849355bd377f311a68b820b724041ac13174588" translate="yes" xml:space="preserve">
          <source>By passing down some information from the &lt;code&gt;Router&lt;/code&gt; component, each &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Route&lt;/code&gt; can communicate back to the containing &lt;code&gt;Router&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Router&lt;/code&gt; 구성 요소 에서 일부 정보를 전달하면 각 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;Route&lt;/code&gt; 가 포함 &lt;code&gt;Router&lt;/code&gt; 와 다시 통신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6543d3a2a9fdfe69d3907c809e5fe72730cb6152" translate="yes" xml:space="preserve">
          <source>By publishing prereleases to the same registry that we use for stable releases, we are able to take advantage of the many tools that support the npm workflow, like &lt;a href=&quot;https://unpkg.com&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;.</source>
          <target state="translated">안정적인 릴리스에 사용하는 것과 동일한 레지스트리에 시험판을 게시함으로써 &lt;a href=&quot;https://unpkg.com&quot;&gt;unpkg&lt;/a&gt; 및 &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt; 와 같은 npm 워크 플로우를 지원하는 많은 도구를 활용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b9c90ff13fa64fdfb73b185d7c4f7467924e61" translate="yes" xml:space="preserve">
          <source>By the end of this page, you should have a rough idea of what problems Hooks are solving, but many details are probably unclear. Don&amp;rsquo;t worry! &lt;strong&gt;Let&amp;rsquo;s now go to &lt;a href=&quot;hooks-overview&quot;&gt;the next page&lt;/a&gt; where we start learning about Hooks by example.&lt;/strong&gt;</source>
          <target state="translated">이 페이지의 끝에서 후크가 해결하는 문제에 대한 대략적인 아이디어가 있지만 많은 세부 사항이 명확하지 않을 수 있습니다. 걱정 마세요! &lt;strong&gt;이제 &lt;a href=&quot;hooks-overview&quot;&gt;다음 페이지&lt;/a&gt; 로 이동하여 후크에 대해 배우기 시작합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="0cb89bdc76c5795134a2459b160420669da6ffee" translate="yes" xml:space="preserve">
          <source>CDN Links</source>
          <target state="translated">CDN 링크</target>
        </trans-unit>
        <trans-unit id="473aefd14700a14991eab282d99beba7a986855b" translate="yes" xml:space="preserve">
          <source>CDN stands for Content Delivery Network. CDNs deliver cached, static content from a network of servers across the globe.</source>
          <target state="translated">CDN은 Content Delivery Network의 약어입니다. CDN은 전세계 서버 네트워크에서 캐시 된 정적 컨텐츠를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7025e6eaddc16640f999ef6fa8996ea4bc1f03fd" translate="yes" xml:space="preserve">
          <source>CSS classes are generally better for performance than inline styles.</source>
          <target state="translated">CSS 클래스는 일반적으로 인라인 스타일보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="f08332dc09d930e7bbd5e60a0ce85c9b8c230b52" translate="yes" xml:space="preserve">
          <source>Callback Refs</source>
          <target state="translated">콜백 참조</target>
        </trans-unit>
        <trans-unit id="56f561c648f624045fd004dc5b4b78923e5e8ddc" translate="yes" xml:space="preserve">
          <source>Callback refs will continue to be supported in addition to the new &lt;code&gt;createRef&lt;/code&gt; API.</source>
          <target state="translated">새로운 &lt;code&gt;createRef&lt;/code&gt; API 외에도 콜백 참조가 계속 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6b324bae986165b1cd5e20961c947433abdcaa8" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;forceUpdate()&lt;/code&gt; will cause &lt;code&gt;render()&lt;/code&gt; to be called on the component, skipping &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. This will trigger the normal lifecycle methods for child components, including the &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; method of each child. React will still only update the DOM if the markup changes.</source>
          <target state="translated">호출 &lt;code&gt;forceUpdate()&lt;/code&gt; 의 원인이됩니다 &lt;code&gt;render()&lt;/code&gt; 건너 뛰는, 구성 요소에 호출 할 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; . 그러면 각 하위 의 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 메소드를 포함하여 하위 컴포넌트의 일반 라이프 사이클 메소드가 트리거됩니다 . 마크 업이 변경된 경우에도 React는 여전히 DOM 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="db2d5d9b462bef88cc3e6ecec70f1f6eb5fdac81" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;setState&lt;/code&gt; are asynchronous - don&amp;rsquo;t rely on &lt;code&gt;this.state&lt;/code&gt; to reflect the new value immediately after calling &lt;code&gt;setState&lt;/code&gt;. Pass an updater function instead of an object if you need to compute values based on the current state (see below for details).</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 에 대한 호출 은 비동기 적 입니다. &lt;code&gt;setState&lt;/code&gt; 를 호출 한 직후에 새 값을 반영하기 위해 &lt;code&gt;this.state&lt;/code&gt; 에 의존하지 마십시오 . 현재 상태를 기준으로 값을 계산해야하는 경우 객체 대신 업데이트 프로그램 함수를 전달하십시오 (자세한 내용은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="c41d5ffe9daa0185ffc53035fc127e196975da11" translate="yes" xml:space="preserve">
          <source>Calls to Hooks are either inside a &lt;code&gt;PascalCase&lt;/code&gt; function (assumed to be a component) or another &lt;code&gt;useSomething&lt;/code&gt; function (assumed to be a custom Hook).</source>
          <target state="translated">후크 호출은 &lt;code&gt;PascalCase&lt;/code&gt; 함수 (구성 요소로 가정) 또는 다른 &lt;code&gt;useSomething&lt;/code&gt; 함수 (사용자 정의 후크로 가정) 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca0fb965bf90315219e83def6638a42c25d67bb9" translate="yes" xml:space="preserve">
          <source>Can I do animations in React?</source>
          <target state="translated">React에서 애니메이션을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="592eed8e66509a1a99a368df6d3300451076b895" translate="yes" xml:space="preserve">
          <source>Can I make a ref to a function component?</source>
          <target state="translated">함수 구성 요소를 참조 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="99a0edbd02b3f7f4f83753bc16933ee61ae6323d" translate="yes" xml:space="preserve">
          <source>Can I run an effect only on updates?</source>
          <target state="translated">업데이트에서만 효과를 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="efa41f6b0727bc187c1b93b3700c7aa5f30c011d" translate="yes" xml:space="preserve">
          <source>Can I skip an effect on updates?</source>
          <target state="translated">업데이트에 대한 영향을 건너 뛸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1e7c8e9b874b8d15ca221b52d750e20fac44ca71" translate="yes" xml:space="preserve">
          <source>Can I use inline styles?</source>
          <target state="translated">인라인 스타일을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1bc1494bdebde800b93a7e1e6398d587710939fe" translate="yes" xml:space="preserve">
          <source>Can Proxies help express lazy-loaded APIs without inserting &lt;code&gt;read()&lt;/code&gt; calls everywhere?</source>
          <target state="translated">프록시 가 어디서나 &lt;code&gt;read()&lt;/code&gt; 호출 을 삽입하지 않고도 지연로드 된 API를 표현할 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="c5d5be07f96ef2179314db3e0573821bfd2d2fa9" translate="yes" xml:space="preserve">
          <source>Can you compute it based on any other state or props in your component? If so, it isn&amp;rsquo;t state.</source>
          <target state="translated">컴포넌트의 다른 상태 또는 소품을 기반으로 계산할 수 있습니까? 그렇다면 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4cfac05bf4b7fb87c23c141fcc58c48668bb07b" translate="yes" xml:space="preserve">
          <source>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; expression, &lt;code&gt;Foo&lt;/code&gt; must be in scope.</source>
          <target state="translated">대문자 유형은 JSX 태그가 React 구성 요소를 참조하고 있음을 나타냅니다. 이 태그는 명명 된 변수에 대한 직접 참조로 컴파일되므로 JSX &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 표현식 을 사용하는 경우 &lt;code&gt;Foo&lt;/code&gt; 가 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee3e2f961f45bb1a06529f15bbd3ad553ff58fba" translate="yes" xml:space="preserve">
          <source>Catching an event bubbling up from a portal in a parent component allows the development of more flexible abstractions that are not inherently reliant on portals. For example, if you render a &lt;code&gt;&amp;lt;Modal /&amp;gt;&lt;/code&gt; component, the parent can capture its events regardless of whether it&amp;rsquo;s implemented using portals.</source>
          <target state="translated">상위 컴포넌트의 포털에서 발생하는 이벤트를 포착하면 본질적으로 포털에 의존하지 않는보다 유연한 추상화를 개발할 수 있습니다. 예를 들어 &lt;code&gt;&amp;lt;Modal /&amp;gt;&lt;/code&gt; 구성 요소 를 렌더링 하면 부모는 포털을 사용하여 구현되었는지 여부에 관계없이 해당 이벤트를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b399bd413c8dfe8688f37d0df1a1c1d399fe2a" translate="yes" xml:space="preserve">
          <source>Caution:</source>
          <target state="translated">Caution:</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="c31196d8e650a9b9fc79de9f3fa43c1c31cecaf3" translate="yes" xml:space="preserve">
          <source>Caveats with callback refs</source>
          <target state="translated">콜백 참조가있는주의 사항</target>
        </trans-unit>
        <trans-unit id="6e5097b05dacd2aac1b01af27496feca5ace3900" translate="yes" xml:space="preserve">
          <source>Changes are determined by comparing the new and old values using the same algorithm as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">변경 사항은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; &lt;/a&gt; 와 동일한 알고리즘을 사용하여 새 값과 기존 값을 비교하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="948a11fe049667413c1ebccf85193e5ad0c865a0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;this example of declaring and using an error boundary&lt;/a&gt; with &lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;React 16&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;React 16&lt;/a&gt; 과 함께 &lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;오류 경계&lt;/a&gt; 를 선언하고 사용하는이 예제를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="514d3cf1f7b7bd35468b03e35f683e983fece33f" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;this small demo&lt;/a&gt; and &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; to learn more about data fetching with Hooks.</source>
          <target state="translated">확인 &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;이 작은 데모&lt;/a&gt; 및 &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;이 문서&lt;/a&gt; 후크로 가져 오는 데이터에 대해 더 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb20a1f16d9d9e886462739015ded52cceb62c1" translate="yes" xml:space="preserve">
          <source>Check out the next sections for more tips on integrating React.</source>
          <target state="translated">React 통합에 대한 추가 정보는 다음 섹션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c3c356556be82839c784cc294b64ca1776f78a50" translate="yes" xml:space="preserve">
          <source>Checklist from The A11Y Project</source>
          <target state="translated">A11Y 프로젝트 점검표</target>
        </trans-unit>
        <trans-unit id="788ea0524b831f8a725084df293beea295bdc0cb" translate="yes" xml:space="preserve">
          <source>Children in JSX</source>
          <target state="translated">JSX의 어린이</target>
        </trans-unit>
        <trans-unit id="7833c9a80ea34dfa62e1fc00ddfe3ca1f24f8846" translate="yes" xml:space="preserve">
          <source>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</source>
          <target state="translated">사용자 컴포넌트로 전달 된 자식은 컴포넌트가 렌더링 전에 React가 이해할 수있는 것으로 변환하는 한 아무 것도 될 수 있습니다. 이 사용법은 일반적이지 않지만 JSX의 기능을 확장하려는 경우 작동합니다.</target>
        </trans-unit>
        <trans-unit id="524053a45c83a82145b2826ea841021f62f2eca9" translate="yes" xml:space="preserve">
          <source>Choosing the Type at Runtime</source>
          <target state="translated">런타임시 유형 선택</target>
        </trans-unit>
        <trans-unit id="9ed520503e6b810c6b447d0d61fb33cc587bd886" translate="yes" xml:space="preserve">
          <source>Chosen&amp;rsquo;s documentation suggests that we can use jQuery &lt;code&gt;trigger()&lt;/code&gt; API to notify it about changes to the original DOM element. We will let React take care of updating &lt;code&gt;this.props.children&lt;/code&gt; inside &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, but we will also add a &lt;code&gt;componentDidUpdate()&lt;/code&gt; lifecycle method that notifies Chosen about changes in the children list:</source>
          <target state="translated">Chosen의 문서는 jQuery &lt;code&gt;trigger()&lt;/code&gt; API를 사용 하여 원래 DOM 요소의 변경 사항에 대해 알릴 수 있다고 제안합니다 . React가 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 내부에서 &lt;code&gt;this.props.children&lt;/code&gt; 을 업데이트하도록 할 것입니다. 또한 선택된 하위 목록의 변경 사항을 Chosen에 알리는 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 라이프 사이클 메소드 도 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="8da54e825685d4347402587467044fe401034bb0" translate="yes" xml:space="preserve">
          <source>Chrome Browser Extension</source>
          <target state="translated">크롬 브라우저 확장</target>
        </trans-unit>
        <trans-unit id="62e721a027f935b8971974b1c6919474075787ba" translate="yes" xml:space="preserve">
          <source>ChromeVox Classic Keyboard Shortcuts Reference</source>
          <target state="translated">ChromeVox 클래식 키보드 단축키 참조</target>
        </trans-unit>
        <trans-unit id="fa2ef5e0cd8877a9fd5fb814d30d6b360f56b5ce" translate="yes" xml:space="preserve">
          <source>ChromeVox in Google Chrome</source>
          <target state="translated">Chrome의 ChromeVox</target>
        </trans-unit>
        <trans-unit id="bce80736a23f07ec5379dd12c4e62a76fe4c9654" translate="yes" xml:space="preserve">
          <source>Class Properties</source>
          <target state="translated">클래스 속성</target>
        </trans-unit>
        <trans-unit id="1e056366f04de2cab39d2cee2ccd99cf321dc0d1" translate="yes" xml:space="preserve">
          <source>Class Properties (Stage 3 Proposal)</source>
          <target state="translated">클래스 속성 (3 단계 제안)</target>
        </trans-unit>
        <trans-unit id="26feb612e21f929366469e12ea57924bf0e68946" translate="yes" xml:space="preserve">
          <source>Class component &lt;code&gt;constructor&lt;/code&gt; method</source>
          <target state="translated">클래스 컴포넌트 &lt;code&gt;constructor&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="35adea707ef390317beb571e365f0c45b1558a38" translate="yes" xml:space="preserve">
          <source>Class components should always call the base constructor with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">클래스 컴포넌트는 항상 &lt;code&gt;props&lt;/code&gt; 로 기본 생성자를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf28dbaca27f177b67bd4d8c242c6ba8196c774" translate="yes" xml:space="preserve">
          <source>Class.contextType</source>
          <target state="translated">Class.contextType</target>
        </trans-unit>
        <trans-unit id="317a231b0609e8171e8ccd831d16d1f01d3e282b" translate="yes" xml:space="preserve">
          <source>Classes confuse both people and machines</source>
          <target state="translated">클래스는 사람과 기계를 혼동합니다</target>
        </trans-unit>
        <trans-unit id="6df956550f910b614ba52561dd8a120763eead57" translate="yes" xml:space="preserve">
          <source>Classes have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;. Until then, we will use function components for their conciseness.</source>
          <target state="translated">클래스에는 &lt;a href=&quot;state-and-lifecycle&quot;&gt;다음 섹션&lt;/a&gt; 에서 설명 할 몇 가지 추가 기능이 있습니다 . 그때까지 함수 구성 요소를 간결하게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c3dd60e3aff73678cd482872275e8a9396606b21" translate="yes" xml:space="preserve">
          <source>Cleaning up an effect</source>
          <target state="translated">효과 정리</target>
        </trans-unit>
        <trans-unit id="4f4758520a494d2064d93ffa9165dd034d4d6fdc" translate="yes" xml:space="preserve">
          <source>Clearly, both &amp;ldquo;versions&amp;rdquo; of &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; exist at the same time. We know the old one exists because we see it on the screen and even display a progress indicator on it. And we know the new version also exists &lt;em&gt;somewhere&lt;/em&gt;, because it&amp;rsquo;s the one that we&amp;rsquo;re waiting for!</source>
          <target state="translated">분명히 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 의 두&amp;ldquo;버전&amp;rdquo;은 동시에 존재합니다. 우리는 오래된 것이 화면에 표시되고 진행 표시기가 나타나기 때문에 존재한다는 것을 알고 있습니다. 그리고 우리는 새로운 버전도 &lt;em&gt;어딘가에&lt;/em&gt; 존재한다는 것을 알고 있습니다 . 왜냐하면 그것이 우리가 기다리고있는 버전 이기 때문입니다!</target>
        </trans-unit>
        <trans-unit id="7da2856d241d6b8e03d34e8bd789ba5cc2d485c8" translate="yes" xml:space="preserve">
          <source>Click the link above to open an online editor. Feel free to make some changes, and see how they affect the output. Most pages in this guide will have editable examples like this one.</source>
          <target state="translated">온라인 편집기를 열려면 위의 링크를 클릭하십시오. 자유롭게 변경하고 출력에 어떤 영향을 미치는지 확인하십시오. 이 안내서의 대부분의 페이지에는 이와 같은 편집 가능한 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b365b3f0f1a9ce1f1f16399418c096e7b8a503bc" translate="yes" xml:space="preserve">
          <source>Clipboard Events</source>
          <target state="translated">클립 보드 이벤트</target>
        </trans-unit>
        <trans-unit id="b3b54baa5ba7bdc6fb8f058345854fc083692bdf" translate="yes" xml:space="preserve">
          <source>Clone and return a new React element using &lt;code&gt;element&lt;/code&gt; as the starting point. The resulting element will have the original element&amp;rsquo;s props with the new props merged in shallowly. New children will replace existing children. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; from the original element will be preserved.</source>
          <target state="translated">복제와 새로운 사용 요소 반응 반환 &lt;code&gt;element&lt;/code&gt; 시작 지점으로. 결과 요소는 원래 요소의 소품을 새 소품과 얕게 병합합니다. 새 어린이는 기존 어린이를 대체합니다. 원래 요소의 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;ref&lt;/code&gt; 는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d4a989ae1369e4b664454339de990449f6d5be39" translate="yes" xml:space="preserve">
          <source>Code Splitting</source>
          <target state="translated">코드 분할</target>
        </trans-unit>
        <trans-unit id="452894bc81807d851d45c6cab4b7a49a9952b836" translate="yes" xml:space="preserve">
          <source>Code written with &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; will be converted to use &lt;code&gt;React.createElement()&lt;/code&gt;. You will not typically invoke &lt;code&gt;React.createElement()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;a href=&quot;introducing-jsx&quot;&gt;JSX로&lt;/a&gt; 작성된 코드 는 &lt;code&gt;React.createElement()&lt;/code&gt; 를 사용하도록 변환됩니다 . &lt;code&gt;React.createElement()&lt;/code&gt; 를 사용하는 경우 일반적으로 React.createElement ()를 직접 호출하지 않습니다 . 자세한 내용은 &lt;a href=&quot;react-without-jsx&quot;&gt;JSX없이 반응을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21d830d4bd5b85e6cbc7cadd95b182af8a0782d0" translate="yes" xml:space="preserve">
          <source>Code-Splitting</source>
          <target state="translated">Code-Splitting</target>
        </trans-unit>
        <trans-unit id="4288c2984091655ae5fc926db1f916d24686a3fd" translate="yes" xml:space="preserve">
          <source>Code-splitting your app can help you &amp;ldquo;lazy-load&amp;rdquo; just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven&amp;rsquo;t reduced the overall amount of code in your app, you&amp;rsquo;ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</source>
          <target state="translated">앱을 코드 분할하면 현재 사용자가 필요로하는 것만 &quot;게으른&quot;로드하여 앱 성능을 크게 향상시킬 수 있습니다. 앱에서 전체 코드 양을 줄이지 않았지만 사용자가 절대 필요하지 않은 코드를로드하지 않고 초기로드 중에 필요한 코드 양을 줄였습니다.</target>
        </trans-unit>
        <trans-unit id="ed6a4ad5c28d4237a3c9fce8881b1854847ef4dd" translate="yes" xml:space="preserve">
          <source>Color contrast</source>
          <target state="translated">색상 대비</target>
        </trans-unit>
        <trans-unit id="ccdabf4161bdc7de274f4b5b5280d0885aab475f" translate="yes" xml:space="preserve">
          <source>Commitment to Stability</source>
          <target state="translated">안정성에 대한 헌신</target>
        </trans-unit>
        <trans-unit id="445032c4df4e7271e1f347bbc2ba4f9b91fac35c" translate="yes" xml:space="preserve">
          <source>Common testing patterns for React components.</source>
          <target state="translated">React 구성 요소에 대한 공통 테스트 패턴.</target>
        </trans-unit>
        <trans-unit id="0ba992810876b27f169da76d8892757d1ac6c389" translate="yes" xml:space="preserve">
          <source>Commonly Used Lifecycle Methods</source>
          <target state="translated">일반적으로 사용되는 수명주기 방법</target>
        </trans-unit>
        <trans-unit id="47ab08f55f92afe16678b0d26789b0f9db88a542" translate="yes" xml:space="preserve">
          <source>Commonly Used Screen Readers</source>
          <target state="translated">일반적으로 사용되는 스크린 리더</target>
        </trans-unit>
        <trans-unit id="ab67e4584d46107bd80ff84184a6ba14b35583dc" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to display React components in multiple places on the HTML page. Here is an example that displays the &amp;ldquo;Like&amp;rdquo; button three times and passes some data to it:</source>
          <target state="translated">일반적으로 HTML 페이지의 여러 위치에 React 컴포넌트를 표시 할 수 있습니다. 다음은 &quot;좋아요&quot;버튼을 세 번 표시하고 일부 데이터를 전달하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="1db7f0906384a202b07a0ed5f149a2ff7cd64627" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to test whether a component renders correctly for given props. Consider a simple component that renders a message based on a prop:</source>
          <target state="translated">일반적으로 주어진 소품에 대해 컴포넌트가 올바르게 렌더링되는지 테스트 할 수 있습니다. 소품을 기반으로 메시지를 렌더링하는 간단한 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e1be83a7756a5bb6c9b11d838efbdc2b010f2edd" translate="yes" xml:space="preserve">
          <source>Compilers</source>
          <target state="translated">Compilers</target>
        </trans-unit>
        <trans-unit id="ecb8003c55e2a97e8832e9daab973ed2bb0b4c30" translate="yes" xml:space="preserve">
          <source>Complex components become hard to understand</source>
          <target state="translated">복잡한 구성 요소를 이해하기 어렵습니다</target>
        </trans-unit>
        <trans-unit id="a0667e102ccc5eb4b77124d0b6e69cb444fd7d8a" translate="yes" xml:space="preserve">
          <source>Component Elements Of The Same Type</source>
          <target state="translated">동일한 유형의 구성 요소</target>
        </trans-unit>
        <trans-unit id="8c982cf9a76b7b4a01c2933400406bc78bbefad7" translate="yes" xml:space="preserve">
          <source>Component Stack Traces</source>
          <target state="translated">구성 요소 스택 추적</target>
        </trans-unit>
        <trans-unit id="1f9dab4c62b723eaa7141297314b9677796ffeea" translate="yes" xml:space="preserve">
          <source>Component State</source>
          <target state="translated">구성 요소 상태</target>
        </trans-unit>
        <trans-unit id="83d8963e298236728ce3600faad72c67a3779b02" translate="yes" xml:space="preserve">
          <source>Component names displayed in the stack traces depend on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;&lt;code&gt;Function.name&lt;/code&gt;&lt;/a&gt; property. If you support older browsers and devices which may not yet provide this natively (e.g. IE 11), consider including a &lt;code&gt;Function.name&lt;/code&gt; polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/JamesMGreene/Function.name&quot;&gt;&lt;code&gt;function.name-polyfill&lt;/code&gt;&lt;/a&gt;. Alternatively, you may explicitly set the &lt;a href=&quot;react-component#displayname&quot;&gt;&lt;code&gt;displayName&lt;/code&gt;&lt;/a&gt; property on all your components.</source>
          <target state="translated">스택 추적에 표시되는 구성 요소 이름은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt; &lt;code&gt;Function.name&lt;/code&gt; &lt;/a&gt; 속성 에 따라 다릅니다 . IE11과 같이 아직 기본적으로 제공하지 않는 구형 브라우저 및 장치를 지원하는 경우 번들 응용 프로그램에 &lt;a href=&quot;https://github.com/JamesMGreene/Function.name&quot;&gt; &lt;code&gt;function.name-polyfill&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;code&gt;Function.name&lt;/code&gt; polyfill을 포함시키는 것을 고려 하십시오 . 또는 모든 구성 요소 에서 &lt;a href=&quot;react-component#displayname&quot;&gt; &lt;code&gt;displayName&lt;/code&gt; &lt;/a&gt; 속성을 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="5b900f3314804ddfe0c68be1b21bafcf15049dec" translate="yes" xml:space="preserve">
          <source>Components and Props</source>
          <target state="translated">구성 요소 및 소품</target>
        </trans-unit>
        <trans-unit id="ea42a84e60a676f2853bf66aa9e71316099a0d2d" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React, but it&amp;rsquo;s not always obvious how to share the state or behavior that one component encapsulates to other components that need that same state.</source>
          <target state="translated">컴포넌트는 React에서 코드 재사용의 기본 단위이지만, 하나의 컴포넌트가 동일한 상태를 필요로하는 다른 컴포넌트와 캡슐화하는 상태 또는 동작을 공유하는 방법이 항상 명확한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bf21630472b655008598f546f0ae8540e9eb363" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React. However, you&amp;rsquo;ll find that some patterns aren&amp;rsquo;t a straightforward fit for traditional components.</source>
          <target state="translated">컴포넌트는 React에서 코드 재사용의 기본 단위입니다. 그러나 일부 패턴은 기존 구성 요소에 적합하지 않다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9eda6a288584eb3b7660e0273162ffe2fbd651" translate="yes" xml:space="preserve">
          <source>Components can also be ES6 classes:</source>
          <target state="translated">구성 요소는 ES6 클래스 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b98ff4285b5af72ab07a10e59ca94da7eccff155" translate="yes" xml:space="preserve">
          <source>Components can be broken down into distinct pieces of functionality and used within other components. Components can return other components, arrays, strings and numbers. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. Component names should also always start with a capital letter (&lt;code&gt;&amp;lt;Wrapper/&amp;gt;&lt;/code&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&amp;lt;wrapper/&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;components-and-props#rendering-a-component&quot;&gt;this documentation&lt;/a&gt; for more information on rendering components.</source>
          <target state="translated">구성 요소는 서로 다른 기능으로 분리되어 다른 구성 요소 내에서 사용될 수 있습니다. 구성 요소는 다른 구성 요소, 배열, 문자열 및 숫자를 반환 할 수 있습니다. 경험상 UI의 일부가 여러 번 (Button, Panel, Avatar) 사용되거나 자체적으로 (App, FeedStory, Comment) 복잡 할 경우 재사용 가능한 구성 요소가 될 수 있습니다. . 구성 요소 이름은 항상 대문자로 시작해야합니다 ( &lt;code&gt;&amp;lt;Wrapper/&amp;gt;&lt;/code&gt; &lt;strong&gt;아닌 &lt;/strong&gt; &lt;code&gt;&amp;lt;wrapper/&amp;gt;&lt;/code&gt; ). 구성 요소 렌더링에 대한 자세한 내용 은 &lt;a href=&quot;components-and-props#rendering-a-component&quot;&gt;이 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8ce35b76721e042b6254071ed1780b1b067f70" translate="yes" xml:space="preserve">
          <source>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</source>
          <target state="translated">컴포넌트는 출력에서 ​​다른 컴포넌트를 참조 할 수 있습니다. 이를 통해 모든 세부 수준에 동일한 구성 요소 추상화를 사용할 수 있습니다. 버튼, 양식, 대화 상자, 화면 : React 앱에서 모든 항목은 일반적으로 컴포넌트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9548fb4b1e7326eeb04d1fb7f4871d039f635a4f" translate="yes" xml:space="preserve">
          <source>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="translated">구성 요소를 사용하면 UI를 독립적 인 재사용 가능한 조각으로 분할하고 각 조각을 분리하여 생각할 수 있습니다. 이 페이지는 컴포넌트 아이디어에 대한 소개를 제공합니다. &lt;a href=&quot;react-component&quot;&gt;자세한 구성 요소 API 참조는 여기에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="003062ae0cc8b0b04c1a544a38c743d90aa46c94" translate="yes" xml:space="preserve">
          <source>Components might be using time-based functions like &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, or &lt;code&gt;Date.now&lt;/code&gt;. In testing environments, it can be helpful to mock these functions out with replacements that let you manually &amp;ldquo;advance&amp;rdquo; time. This is great for making sure your tests run fast! Tests that are dependent on timers would still resolve in order, but quicker &lt;a href=&quot;testing-recipes#timers&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. Most frameworks, including &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://sinonjs.org/releases/v7.3.2/fake-timers/&quot;&gt;sinon&lt;/a&gt; and &lt;a href=&quot;https://github.com/sinonjs/lolex&quot;&gt;lolex&lt;/a&gt;, let you mock timers in your tests.</source>
          <target state="translated">컴포넌트는 &lt;code&gt;setTimeout&lt;/code&gt; , &lt;code&gt;setInterval&lt;/code&gt; 또는 &lt;code&gt;Date.now&lt;/code&gt; 와 같은 시간 기반 함수를 사용 중일 수 있습니다 . 테스트 환경에서는 수동으로 &quot;진행&quot;할 수있는 대체 기능으로 이러한 기능을 조롱하는 것이 도움이 될 수 있습니다. 테스트가 빠르게 실행되도록하는 데 유용합니다! 타이머에 의존하는 테스트는 여전히 순서대로 해결되지만 더 빠릅니다 &lt;a href=&quot;testing-recipes#timers&quot;&gt;&lt;small&gt;(예)&lt;/small&gt;&lt;/a&gt; . &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&lt;/a&gt; , &lt;a href=&quot;https://sinonjs.org/releases/v7.3.2/fake-timers/&quot;&gt;sinon&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/sinonjs/lolex&quot;&gt;lolex를&lt;/a&gt; 포함한 대부분의 프레임 워크를 사용 하면 테스트에서 타이머를 조롱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5bd7c2e2f2da7429280ddf7205af915e3844671" translate="yes" xml:space="preserve">
          <source>Components responsible for rendering models would listen to &lt;code&gt;'change'&lt;/code&gt; events, while components responsible for rendering collections would listen for &lt;code&gt;'add'&lt;/code&gt; and &lt;code&gt;'remove'&lt;/code&gt; events. In both cases, call &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;this.forceUpdate()&lt;/code&gt;&lt;/a&gt; to rerender the component with the new data.</source>
          <target state="translated">모델 렌더링을 담당하는 구성 요소는 &lt;code&gt;'change'&lt;/code&gt; 이벤트를 수신하고 컬렉션을 렌더링하는 구성 요소는 &lt;code&gt;'add'&lt;/code&gt; 및 &lt;code&gt;'remove'&lt;/code&gt; 이벤트를 수신합니다. 두 경우 모두 &lt;a href=&quot;react-component#forceupdate&quot;&gt; &lt;code&gt;this.forceUpdate()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 새 데이터로 구성 요소를 다시 렌더링하십시오.</target>
        </trans-unit>
        <trans-unit id="701adbc3566e773a7ef736ead752213877c9e24a" translate="yes" xml:space="preserve">
          <source>Composing Components</source>
          <target state="translated">구성 요소</target>
        </trans-unit>
        <trans-unit id="1a6e1b699d64dbae00096ea5053b1e52924dbf2a" translate="yes" xml:space="preserve">
          <source>Composition Events</source>
          <target state="translated">작곡 이벤트</target>
        </trans-unit>
        <trans-unit id="9d3bb3f5861eb173e759c1e484131da5669201dc" translate="yes" xml:space="preserve">
          <source>Composition vs Inheritance</source>
          <target state="translated">구성 대 상속</target>
        </trans-unit>
        <trans-unit id="6b341fa71196d99f719bfddbccd90c93c12138eb" translate="yes" xml:space="preserve">
          <source>Composition works equally well for components defined as classes:</source>
          <target state="translated">컴포지션은 클래스로 정의 된 구성 요소에 대해 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aaea795653ffb1f62d576e1558d5bec326d7d883" translate="yes" xml:space="preserve">
          <source>Conceptually, React does work in two phases:</source>
          <target state="translated">개념적으로 React는 두 단계로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2d6f098afd8b98b26fd7a56a1017d47f83ce5847" translate="yes" xml:space="preserve">
          <source>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return React elements describing what should appear on the screen.</source>
          <target state="translated">개념적으로 컴포넌트는 JavaScript 함수와 같습니다. 이들은 임의의 입력 ( &quot;props&quot;라고 함)을 받아들이고 화면에 나타나는 것을 설명하는 React 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1694788f449187fffb09e184087fbad62e9f353" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of refs as similar to instance variables in a class. Unless you&amp;rsquo;re doing &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazy initialization&lt;/a&gt;, avoid setting refs during rendering &amp;mdash; this can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.</source>
          <target state="translated">개념적으로 클래스의 인스턴스 변수와 유사한 참조를 생각할 수 있습니다. &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;게으른 초기화를&lt;/a&gt; 수행하지 않는 한 렌더링 중에 참조 설정을 피하십시오. 놀라운 동작이 발생할 수 있습니다. 대신, 일반적으로 이벤트 핸들러 및 효과에서 참조를 수정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c57505dca41b5f346bafb38cef7d36319b3ff259" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of this as React preparing every update &amp;ldquo;on a branch&amp;rdquo;. Just like you can abandon work in branches or switch between them, React in Concurrent Mode can interrupt an ongoing update to do something more important, and then come back to what it was doing earlier. This technique might also remind you of &lt;a href=&quot;https://wiki.osdev.org/Double_Buffering&quot;&gt;double buffering&lt;/a&gt; in video games.</source>
          <target state="translated">개념적으로이를 &quot;지점&quot;마다 모든 업데이트를 준비하는 반응이라고 생각할 수 있습니다. 브랜치에서 작업을 포기하거나 그 사이를 전환 할 수있는 것처럼, 동시 모드의 리 액트는 진행중인 업데이트를 중단하여보다 중요한 작업을 수행 한 다음 이전 작업으로 돌아갈 수 있습니다. 이 기술은 비디오 게임에서 &lt;a href=&quot;https://wiki.osdev.org/Double_Buffering&quot;&gt;이중 버퍼링&lt;/a&gt; 을 상기시킬 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f22fda27ebc954f7f4402caca1cf5289d586e251" translate="yes" xml:space="preserve">
          <source>Concretely, &lt;strong&gt;a higher-order component is a function that takes a component and returns a new component.&lt;/strong&gt;</source>
          <target state="translated">구체적으로, &lt;strong&gt;고차 컴포넌트는 컴포넌트를 가져 와서 새로운 컴포넌트를 리턴하는 함수입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec390bfae82ff5b921e55c4ae832ef41eb12f05" translate="yes" xml:space="preserve">
          <source>Concurrency</source>
          <target state="translated">Concurrency</target>
        </trans-unit>
        <trans-unit id="ca01db7215deb4076fca62d84daf3eae9616a7af" translate="yes" xml:space="preserve">
          <source>Concurrent Mode</source>
          <target state="translated">동시 모드</target>
        </trans-unit>
        <trans-unit id="6b96093c95b817298d9cb20e5b0bce04174743e2" translate="yes" xml:space="preserve">
          <source>Concurrent Mode (Experimental)</source>
          <target state="translated">동시 모드 (실험)</target>
        </trans-unit>
        <trans-unit id="e4081b3599040f8aaebf073472ee211558b7387b" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference</source>
          <target state="translated">동시 모드 API 참조</target>
        </trans-unit>
        <trans-unit id="878fcbe7d5ea50af7b133ed62070a99136683731" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference (Experimental)</source>
          <target state="translated">동시 모드 API 참조 (실험)</target>
        </trans-unit>
        <trans-unit id="3edae5795f747881fc262da51c417bf58f166fd1" translate="yes" xml:space="preserve">
          <source>Concurrent Mode APIs such as &lt;code&gt;createRoot&lt;/code&gt; only exist in the experimental builds of React.</source>
          <target state="translated">&lt;code&gt;createRoot&lt;/code&gt; 와 같은 동시 모드 API 는 실험적인 React 빌드에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a6ab22e83b598a8ed18897acc3509011b895edf9" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is a set of new features that help React apps stay responsive and gracefully adjust to the user&amp;rsquo;s device capabilities and network speed.</source>
          <target state="translated">동시 모드는 React 앱이 응답 속도를 유지하고 사용자의 장치 기능 및 네트워크 속도에 맞게 적절히 조정하는 데 도움이되는 일련의 새로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="742bebde7560a77faee1a9bd110debab7248dcca" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is different. It introduces semantic changes to how React works. Otherwise, the &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;new features&lt;/a&gt; enabled by it &lt;em&gt;wouldn&amp;rsquo;t be possible&lt;/em&gt;. This is why they&amp;rsquo;re grouped into a new &amp;ldquo;mode&amp;rdquo; rather than released one by one in isolation.</source>
          <target state="translated">동시 모드가 다릅니다. React의 작동 방식에 대한 의미 적 변경을 소개합니다. 그렇지 않으면, 그것에 의해 활성화 된 &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;새로운 기능 &lt;/a&gt;&lt;em&gt;은 불가능합니다&lt;/em&gt; . 이것이 개별적으로 하나씩 릴리스되지 않고 새로운 &quot;모드&quot;로 그룹화되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="c585cad9f5f72f26033dfd27b6afae87de9fa710" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is only available in the &lt;a href=&quot;https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel&quot;&gt;experimental builds&lt;/a&gt; of React. To install them, run:</source>
          <target state="translated">동시 모드는 &lt;a href=&quot;https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel&quot;&gt;실험&lt;/a&gt; 의 React 빌드 에서만 사용할 수 있습니다 . 설치하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6c377403fcf4a1e570b1ab1632cc59da79933283" translate="yes" xml:space="preserve">
          <source>Concurrent Mode offers a powerful UI programming model and a set of new composable primitives to help you orchestrate delightful user experiences.</source>
          <target state="translated">Concurrent Mode (콘 커런트 모드)는 강력한 UI 프로그래밍 모델과 새로운 컴포저 블 프리미티브 세트를 제공하여 쾌적한 사용자 경험을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="cac41fa82ad1eaecb7d0f14d53085140b1d9b1bb" translate="yes" xml:space="preserve">
          <source>Concurrent Mode techniques reduce the need for debouncing and throttling in UI. Because rendering is interruptible, React doesn&amp;rsquo;t need to artificially &lt;em&gt;delay&lt;/em&gt; work to avoid stutter. It can start rendering right away, but interrupt this work when needed to keep the app responsive.</source>
          <target state="translated">동시 모드 기술은 UI에서 제거 및 조절의 필요성을 줄입니다. 렌더링은 중단 가능하므로 React는 말더듬을 피하기 위해 인위적으로 작업을 &lt;em&gt;지연시킬&lt;/em&gt; 필요가 없습니다 . 렌더링을 즉시 시작할 수 있지만 앱의 응답 성을 유지해야하는 경우에는이 작업을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="53417584d59bf95fc7febd4b8d8f415dca7cce44" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns</source>
          <target state="translated">동시 UI 패턴</target>
        </trans-unit>
        <trans-unit id="02d4fdda5f562ed8698f706655ed62e3ce272950" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns (Experimental)</source>
          <target state="translated">동시 UI 패턴 (실험)</target>
        </trans-unit>
        <trans-unit id="ea9a4bba446372af01e0eb85f26e0ec3d5f7469e" translate="yes" xml:space="preserve">
          <source>Conditional Rendering</source>
          <target state="translated">조건부 렌더링</target>
        </trans-unit>
        <trans-unit id="f84a8b581ff1d2c10bdf276f2b7406dcdfbe471a" translate="yes" xml:space="preserve">
          <source>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;conditional operator&lt;/a&gt; to create elements representing the current state, and let React update the UI to match them.</source>
          <target state="translated">React의 조건부 렌더링은 JavaScript에서 조건이 작동하는 것과 같은 방식으로 작동합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;조건부&lt;/a&gt; 연산자와 같은 JavaScript 연산자를 사용 하여 현재 상태를 나타내는 요소를 작성하고 React가 UI를 업데이트하여 일치하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="199403f202001274d577cd822710fe3cc32c4b8a" translate="yes" xml:space="preserve">
          <source>Conditionally applying &lt;code&gt;React.forwardRef&lt;/code&gt; when it exists is also not recommended for the same reasons: it changes how your library behaves and can break your users&amp;rsquo; apps when they upgrade React itself.</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 가 존재할 때 조건부로 적용하는 것도 같은 이유로 권장되지 않습니다. React.forwardRef 는 라이브러리 작동 방식을 변경하고 React 자체를 업그레이드 할 때 사용자의 앱을 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48508561fdd435136ec1d37487fd8f61312286d4" translate="yes" xml:space="preserve">
          <source>Conditionally firing an effect</source>
          <target state="translated">조건부 효과 실행</target>
        </trans-unit>
        <trans-unit id="4ae13d3daebd49b458224df13eda9d0943a64d8b" translate="yes" xml:space="preserve">
          <source>Configure the TypeScript compiler options</source>
          <target state="translated">TypeScript 컴파일러 옵션 구성</target>
        </trans-unit>
        <trans-unit id="504272518eee464b9351a8f9dfa5318f53b167f7" translate="yes" xml:space="preserve">
          <source>Configuring the TypeScript Compiler</source>
          <target state="translated">TypeScript 컴파일러 구성</target>
        </trans-unit>
        <trans-unit id="3e0cd36dad9889e7827176814d13b8658d3652a6" translate="yes" xml:space="preserve">
          <source>Congrats! You&amp;rsquo;ve installed the latest version of TypeScript into your project. Installing TypeScript gives us access to the &lt;code&gt;tsc&lt;/code&gt; command. Before configuration, let&amp;rsquo;s add &lt;code&gt;tsc&lt;/code&gt; to the &amp;ldquo;scripts&amp;rdquo; section in our &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">축하합니다! 프로젝트에 최신 버전의 TypeScript를 설치했습니다. TypeScript를 설치하면 &lt;code&gt;tsc&lt;/code&gt; 명령에 액세스 할 수 있습니다. 구성하기 전에 &lt;code&gt;package.json&lt;/code&gt; 의&amp;ldquo;scripts&amp;rdquo;섹션에 &lt;code&gt;tsc&lt;/code&gt; 를 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="dc73f73a6669c50d8572f5f02e2446e75c6d9af5" translate="yes" xml:space="preserve">
          <source>Congratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You&amp;rsquo;ve learned both the State Hook and the Effect Hook, and there is a &lt;em&gt;lot&lt;/em&gt; you can do with both of them combined. They cover most of the use cases for classes &amp;mdash; and where they don&amp;rsquo;t, you might find the &lt;a href=&quot;hooks-reference&quot;&gt;additional Hooks&lt;/a&gt; helpful.</source>
          <target state="translated">축하합니다! 이 내용은 긴 페이지 였지만 결국 효과에 대한 대부분의 질문에 대한 답변이 되었기를 바랍니다. State Hook와 Effect Hook를 모두 배웠으며 두 가지를 결합하여 할 수있는 일이 &lt;em&gt;많이&lt;/em&gt; 있습니다. 클래스의 대부분의 유스 케이스를 다루며 그렇지 않은 경우 &lt;a href=&quot;hooks-reference&quot;&gt;추가 후크가&lt;/a&gt; 도움 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52d9a753b489028ce282c353568f3094da12baff" translate="yes" xml:space="preserve">
          <source>Congratulations! You just added a &lt;strong&gt;production-ready JSX setup&lt;/strong&gt; to your project.</source>
          <target state="translated">축하합니다! 방금 &lt;strong&gt;프로덕션에 준비된 JSX 설정&lt;/strong&gt; 을 프로젝트에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="220d6f56856674c1b7704909679e2651f54143de" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;Contact&lt;/code&gt; component that embeds a third-party &lt;code&gt;GoogleMap&lt;/code&gt; component:</source>
          <target state="translated">타사 &lt;code&gt;GoogleMap&lt;/code&gt; 구성 요소를 포함 하는 &lt;code&gt;Contact&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ed702f8a4cb8d8616a59f948b0139cdd0797b5f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;FancyButton&lt;/code&gt; component that renders the native &lt;code&gt;button&lt;/code&gt; DOM element:</source>
          <target state="translated">기본 &lt;code&gt;button&lt;/code&gt; DOM 요소 를 렌더링 하는 &lt;code&gt;FancyButton&lt;/code&gt; 컴포넌트를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad84e0a45cb8ebe1269d7786a21f6a962f13e1ac" translate="yes" xml:space="preserve">
          <source>Consider a filterable product list. Have you ever typed into a list filter and felt that it stutters on every key press? Some of the work to update the product list might be unavoidable, such as creating new DOM nodes or the browser performing layout. However, &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; we perform that work plays a big role.</source>
          <target state="translated">필터링 가능한 제품 목록을 고려하십시오. 목록 필터에 입력 한 후 키를 누를 때마다 끊김이 느껴지는 적이 있습니까? 제품 목록을 업데이트하는 일부 작업 (예 : 새 DOM 노드 작성 또는 레이아웃을 수행하는 브라우저)이 불가피 할 수 있습니다. 그러나 &lt;em&gt;때&lt;/em&gt; 와 &lt;em&gt;어떻게&lt;/em&gt; 우리가 일이 큰 역할을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cb7ff8a56cce6aaa1998237c428102a30a0e6d16" translate="yes" xml:space="preserve">
          <source>Consider the ticking clock example from &lt;a href=&quot;rendering-elements#updating-the-rendered-element&quot;&gt;one of the previous sections&lt;/a&gt;. In &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;Rendering Elements&lt;/a&gt;, we have only learned one way to update the UI. We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; to change the rendered output:</source>
          <target state="translated">&lt;a href=&quot;rendering-elements#updating-the-rendered-element&quot;&gt;이전 섹션 중 하나의&lt;/a&gt; 티킹 클럭 예제를 고려하십시오 . &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;렌더링 요소&lt;/a&gt; 에서는 UI를 업데이트하는 한 가지 방법 만 배웠습니다. 렌더링 된 출력을 변경하기 위해 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5c9fe294908a1f3d183b9663d08d2005bf90c1cd" translate="yes" xml:space="preserve">
          <source>Consider these &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components:</source>
          <target state="translated">다음 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="926638824610c5e33a93e368f63b4675cf27e758" translate="yes" xml:space="preserve">
          <source>Consider these two components:</source>
          <target state="translated">다음 두 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8e524f8ce0b534b04dc257b42d4b2e50934d485b" translate="yes" xml:space="preserve">
          <source>Consider these two new components representing Logout and Login buttons:</source>
          <target state="translated">로그 아웃 및 로그인 버튼을 나타내는 다음 두 가지 새로운 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="translated">이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="33b2068f767223efe926590be9badd2493687a5a" translate="yes" xml:space="preserve">
          <source>Consider this ticking clock example:</source>
          <target state="translated">이 똑딱 시계 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9a3372e992297117ea2f39b7ce44914f204c2e54" translate="yes" xml:space="preserve">
          <source>Consider this variable declaration:</source>
          <target state="translated">이 변수 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ddeae47880c23e5adfbcbcbdba23da6d1e1666cb" translate="yes" xml:space="preserve">
          <source>Constructor is the only place where you should assign &lt;code&gt;this.state&lt;/code&gt; directly. In all other methods, you need to use &lt;code&gt;this.setState()&lt;/code&gt; instead.</source>
          <target state="translated">생성자는 &lt;code&gt;this.state&lt;/code&gt; 를 직접 할당해야하는 유일한 장소 입니다. 다른 모든 방법에서는 &lt;code&gt;this.setState()&lt;/code&gt; 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e06f3595df6e25bc9e778e558d8c46f700f16ccd" translate="yes" xml:space="preserve">
          <source>Consuming Multiple Contexts</source>
          <target state="translated">여러 문맥 소비</target>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="e17a7e250baad687ac6e52558b3e61ed3c83723c" translate="yes" xml:space="preserve">
          <source>Context can also let you build an API where parents and children communicate. For example, one library that works this way is &lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;React Router V4&lt;/a&gt;:</source>
          <target state="translated">컨텍스트를 사용하면 부모와 자녀가 통신하는 API를 작성할 수도 있습니다. 예를 들어, 이런 방식으로 작동하는 라이브러리는 &lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;React Router V4입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20ca1e00af75ef3a845f699d61f100ec13a84366" translate="yes" xml:space="preserve">
          <source>Context is designed to share data that can be considered &amp;ldquo;global&amp;rdquo; for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a &amp;ldquo;theme&amp;rdquo; prop in order to style the Button component:</source>
          <target state="translated">컨텍스트는 현재 인증 된 사용자, 테마 또는 선호 언어와 같은 React 컴포넌트 트리에 대해 &quot;전역&quot;으로 간주 될 수있는 데이터를 공유하도록 설계되었습니다. 예를 들어 아래 코드에서 Button 구성 요소의 스타일을 지정하기 위해&amp;ldquo;테마&amp;rdquo;소품을 수동으로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b21071418c4fc7c14e094a551aed1dea86ba6cb7" translate="yes" xml:space="preserve">
          <source>Context is primarily used when some data needs to be accessible by &lt;em&gt;many&lt;/em&gt; components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.</source>
          <target state="translated">컨텍스트는 주로 다른 중첩 레벨의 &lt;em&gt;많은&lt;/em&gt; 구성 요소 가 일부 데이터에 액세스해야 할 때 사용됩니다 . 구성 요소 재사용이 더 어려워 지므로 조금만 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="1117c27d0f8aaf201a96126a238a39ef170325f0" translate="yes" xml:space="preserve">
          <source>Context object accepts a &lt;code&gt;displayName&lt;/code&gt; string property. React DevTools uses this string to determine what to display for the context.</source>
          <target state="translated">컨텍스트 객체는 &lt;code&gt;displayName&lt;/code&gt; 문자열 속성을 허용 합니다. React DevTools는이 문자열을 사용하여 컨텍스트에 표시 할 내용을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="62a9e57ea34d268d9527e923e5e2b6dee640de64" translate="yes" xml:space="preserve">
          <source>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</source>
          <target state="translated">컨텍스트는 모든 레벨에서 소품을 수동으로 전달하지 않고 컴포넌트 트리를 통해 데이터를 전달하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="139697d486fc71e559fa9593fcefa43c9121c6a1" translate="yes" xml:space="preserve">
          <source>Context.Consumer</source>
          <target state="translated">Context.Consumer</target>
        </trans-unit>
        <trans-unit id="c6c4c029104cc05bbdc71541dd9edcaca30bed6f" translate="yes" xml:space="preserve">
          <source>Context.Provider</source>
          <target state="translated">Context.Provider</target>
        </trans-unit>
        <trans-unit id="4e4bac3657dd000930aa8125059a7cbf3e87d121" translate="yes" xml:space="preserve">
          <source>Context.displayName</source>
          <target state="translated">Context.displayName</target>
        </trans-unit>
        <trans-unit id="dface495c8ecca08b41dfd753afcb70644dfe335" translate="yes" xml:space="preserve">
          <source>Controlled Components</source>
          <target state="translated">제어 부품</target>
        </trans-unit>
        <trans-unit id="d4cfe4d40b8af3759ad07934d0e0feb2d6452f32" translate="yes" xml:space="preserve">
          <source>Controlled Input Null Value</source>
          <target state="translated">제어 된 입력 널값</target>
        </trans-unit>
        <trans-unit id="4872f4ca134b21b78a1039f88f5f5646a7140446" translate="yes" xml:space="preserve">
          <source>Controlled vs. Uncontrolled Components</source>
          <target state="translated">제어 대상 구성 요소와 제어되지 않는 구성 요소</target>
        </trans-unit>
        <trans-unit id="62399a9d6e56980ca713041c283d89bfe9a83db7" translate="yes" xml:space="preserve">
          <source>Conveniently, &lt;code&gt;useMemo&lt;/code&gt; also lets you skip an expensive re-render of a child:</source>
          <target state="translated">편리하게도 &lt;code&gt;useMemo&lt;/code&gt; 를 사용하면 값 비싼 어린이의 다시 렌더링을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e33dd502823238199f7e3a997f49b17dab06cb9" translate="yes" xml:space="preserve">
          <source>Convention: Maximizing Composability</source>
          <target state="translated">컨벤션 : 구성 성 최대화</target>
        </trans-unit>
        <trans-unit id="cfcb9e71a4081a5cff37e37aed3a64842b154ee2" translate="yes" xml:space="preserve">
          <source>Convention: Pass Unrelated Props Through to the Wrapped Component</source>
          <target state="translated">컨벤션 : 관련이없는 소품을 래핑 된 구성 요소로 전달</target>
        </trans-unit>
        <trans-unit id="841ebb2907df3a45769552f67c617a219b677a7d" translate="yes" xml:space="preserve">
          <source>Convention: Wrap the Display Name for Easy Debugging</source>
          <target state="translated">컨벤션 : 쉬운 디버깅을 위해 표시 이름 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="0869a72ac23582f5ce01a5b79d647020a1817b5f" translate="yes" xml:space="preserve">
          <source>Conversely, if you want a value like &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; to appear in the output, you have to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion&quot;&gt;convert it to a string&lt;/a&gt; first:</source>
          <target state="translated">반대로, &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 와 같은 값을 출력에 표시하려면 먼저 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion&quot;&gt;문자열로 변환해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2250c6dfbb932a62df15caf0ed27800db97ccebc" translate="yes" xml:space="preserve">
          <source>Converting a Function to a Class</source>
          <target state="translated">함수를 클래스로 변환</target>
        </trans-unit>
        <trans-unit id="e0c37808516fd7d3f500437fa5c7a806dd41a7d4" translate="yes" xml:space="preserve">
          <source>Cool, so we&amp;rsquo;ve decided that our state lives in &lt;code&gt;FilterableProductTable&lt;/code&gt;. First, add an instance property &lt;code&gt;this.state = {filterText: '', inStockOnly: false}&lt;/code&gt; to &lt;code&gt;FilterableProductTable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;constructor&lt;/code&gt; to reflect the initial state of your application. Then, pass &lt;code&gt;filterText&lt;/code&gt; and &lt;code&gt;inStockOnly&lt;/code&gt; to &lt;code&gt;ProductTable&lt;/code&gt; and &lt;code&gt;SearchBar&lt;/code&gt; as a prop. Finally, use these props to filter the rows in &lt;code&gt;ProductTable&lt;/code&gt; and set the values of the form fields in &lt;code&gt;SearchBar&lt;/code&gt;.</source>
          <target state="translated">Cool이므로 상태가 &lt;code&gt;FilterableProductTable&lt;/code&gt; 에 있다고 결정했습니다 . 먼저, 인스턴스 속성 추가 &lt;code&gt;this.state = {filterText: '', inStockOnly: false}&lt;/code&gt; 에 &lt;code&gt;FilterableProductTable&lt;/code&gt; 의 &lt;code&gt;constructor&lt;/code&gt; 응용 프로그램의 초기 상태를 반영합니다. 그런 다음 &lt;code&gt;filterText&lt;/code&gt; 및 &lt;code&gt;inStockOnly&lt;/code&gt; 를 &lt;code&gt;ProductTable&lt;/code&gt; 및 &lt;code&gt;SearchBar&lt;/code&gt; 에 소품으로 전달하십시오. 마지막으로이 소품을 사용하여 &lt;code&gt;ProductTable&lt;/code&gt; 의 행을 필터링하고 &lt;code&gt;SearchBar&lt;/code&gt; 의 양식 필드 값을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2118ffbd3d6a89bb3b29c916ac2cbe2fe26af7c9" translate="yes" xml:space="preserve">
          <source>Cooperative Multitasking</source>
          <target state="translated">협동 멀티 태스킹</target>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="translated">리 액트 앱 만들기</target>
        </trans-unit>
        <trans-unit id="c024f9a49db2f62e45ea51a2a8667dbe0d51bef4" translate="yes" xml:space="preserve">
          <source>Create React App doesn&amp;rsquo;t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. Under the hood, it uses &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;, but you don&amp;rsquo;t need to know anything about them.</source>
          <target state="translated">React 앱 생성은 백엔드 논리 또는 데이터베이스를 처리하지 않습니다. 프런트 엔드 빌드 파이프 라인 만 생성하므로 원하는 모든 백엔드와 함께 사용할 수 있습니다. 후드 아래에서 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 과 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack을&lt;/a&gt; 사용 하지만 그것에 대해 아무것도 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5d73eab1062bc3b789613ff260ffbb6f0e6f0c2" translate="yes" xml:space="preserve">
          <source>Create React App supports TypeScript out of the box.</source>
          <target state="translated">React 앱 만들기는 기본적으로 TypeScript를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="588a6c3de29f085354e63ba8a8734778892f1b67" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TestRenderer&lt;/code&gt; instance with the passed React element. It doesn&amp;rsquo;t use the real DOM, but it still fully renders the component tree into memory so you can make assertions about it. Returns a &lt;a href=&quot;#testrenderer-instance&quot;&gt;TestRenderer instance&lt;/a&gt;.</source>
          <target state="translated">전달 된 React 요소를 사용하여 &lt;code&gt;TestRenderer&lt;/code&gt; 인스턴스를 작성하십시오 . 실제 DOM을 사용하지는 않지만 여전히 구성 요소 트리를 메모리로 완전히 렌더링하므로 이에 대한 주장을 할 수 있습니다. &lt;a href=&quot;#testrenderer-instance&quot;&gt;TestRenderer 인스턴스를&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="64c411124515381d7ff723f5204c8cfba7c7ccb7" translate="yes" xml:space="preserve">
          <source>Create a New React App</source>
          <target state="translated">새로운 React 앱 만들기</target>
        </trans-unit>
        <trans-unit id="0daa02edf781723c84899e7b1361e0026d75adaf" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;like_button.js&lt;/code&gt; next to your HTML page.</source>
          <target state="translated">HTML 페이지 옆에 &lt;code&gt;like_button.js&lt;/code&gt; 라는 파일을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="318a0c4ebb95d0a043c4e3bf1428eba585376291" translate="yes" xml:space="preserve">
          <source>Create a folder called &lt;code&gt;src&lt;/code&gt; and run this terminal command:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 라는 폴더를 작성하고 다음 터미널 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="af66300c87946b474f051e5d7eff067c9d2b871d" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, with the same name, that extends &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.Component&lt;/code&gt; 를 확장하는 동일한 이름으로 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스를&lt;/a&gt; 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="23818a295d7f6c07e63b708758b36fa1190384fe" translate="yes" xml:space="preserve">
          <source>Create and return a new &lt;a href=&quot;rendering-elements&quot;&gt;React element&lt;/a&gt; of the given type. The type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="translated">주어진 유형의 새로운 &lt;a href=&quot;rendering-elements&quot;&gt;React 요소&lt;/a&gt; 를 생성하고 반환합니다 . type 인수는 태그 이름 문자열 (예 : &lt;code&gt;'div'&lt;/code&gt; 또는 &lt;code&gt;'span'&lt;/code&gt; ), &lt;a href=&quot;components-and-props&quot;&gt;React 구성 요소&lt;/a&gt; 유형 (클래스 또는 함수) 또는 &lt;a href=&quot;#reactfragment&quot;&gt;React 프래그먼트&lt;/a&gt; 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162f5baa73eecaebf75f161ba1ad46cb2e80e270" translate="yes" xml:space="preserve">
          <source>Creates a Context object. When React renders a component that subscribes to this Context object it will read the current context value from the closest matching &lt;code&gt;Provider&lt;/code&gt; above it in the tree.</source>
          <target state="translated">Context 객체를 만듭니다. React가이 Context 객체를 구독하는 구성 요소를 렌더링 하면 트리에서 그 위에 가장 일치하는 &lt;code&gt;Provider&lt;/code&gt; 로부터 현재 컨텍스트 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="968171522707ca5ac4670b7701c8384829388dca" translate="yes" xml:space="preserve">
          <source>Creates a portal. Portals provide a way to &lt;a href=&quot;portals&quot;&gt;render children into a DOM node that exists outside the hierarchy of the DOM component&lt;/a&gt;.</source>
          <target state="translated">포털을 만듭니다. 포털은 &lt;a href=&quot;portals&quot;&gt;자식을 DOM 구성 요소의 계층 외부에있는 DOM 노드로 렌더링&lt;/a&gt; 하는 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e3c5afa7af329e017f3fc8bded91f50997ffaa42" translate="yes" xml:space="preserve">
          <source>Creating React Elements</source>
          <target state="translated">반응 요소 생성</target>
        </trans-unit>
        <trans-unit id="cd13970869588e53abc8f1259c28e723accf22bf" translate="yes" xml:space="preserve">
          <source>Creating Refs</source>
          <target state="translated">심판 만들기</target>
        </trans-unit>
        <trans-unit id="af6445a9716e552ab696b8d76403765cdf028ab8" translate="yes" xml:space="preserve">
          <source>Creating a Toolchain from Scratch</source>
          <target state="translated">스크래치에서 툴체인 생성</target>
        </trans-unit>
        <trans-unit id="524625f5c3038581049d9461158c1bc8b36669eb" translate="yes" xml:space="preserve">
          <source>Currently Chrome, Edge, and IE are the only browsers supporting this feature, but we use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&quot;&gt;User Timing API&lt;/a&gt; so we expect more browsers to add support for it.</source>
          <target state="translated">현재 Chrome, Edge 및 IE가이 기능을 지원하는 유일한 브라우저이지만 표준 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&quot;&gt;사용자 타이밍 API를 사용&lt;/a&gt; 하므로 더 많은 브라우저에서 지원을 추가 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="81747a03ff6dbb3bebdf52d7cd7d4a6873dc9363" translate="yes" xml:space="preserve">
          <source>Currently, &lt;code&gt;setState&lt;/code&gt; is asynchronous inside event handlers.</source>
          <target state="translated">현재 &lt;code&gt;setState&lt;/code&gt; 는 이벤트 핸들러 내에서 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="894cc533c835e2352748fd904216939ee8e04201" translate="yes" xml:space="preserve">
          <source>Currently, both &lt;code&gt;TemperatureInput&lt;/code&gt; components independently keep their values in the local state:</source>
          <target state="translated">현재 두 &lt;code&gt;TemperatureInput&lt;/code&gt; 구성 요소는 독립적으로 해당 값을 로컬 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="30ee82909063d4ec2cbdd6059cdffa12c000df92" translate="yes" xml:space="preserve">
          <source>Currently, if &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then &lt;a href=&quot;#unsafe_componentwillupdate&quot;&gt;&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/a&gt; will not be invoked. In the future React may treat &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; as a hint rather than a strict directive, and returning &lt;code&gt;false&lt;/code&gt; may still result in a re-rendering of the component.</source>
          <target state="translated">현재 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;a href=&quot;#unsafe_componentwillupdate&quot;&gt; &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다. 향후 React는 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 를 엄격한 지시문이 아닌 힌트로 취급 할 수 있으며 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 여전히 컴포넌트가 다시 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf281e2f643467c2ac1872e15c49c4c6401ca6e" translate="yes" xml:space="preserve">
          <source>Currently, you can do it manually &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;with a ref&lt;/a&gt;:</source>
          <target state="translated">현재 &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref로&lt;/a&gt; 수동으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca0ad5578c57029da6b1cabae76f360b29b0cf4e" translate="yes" xml:space="preserve">
          <source>Custom Hooks are more of a convention than a feature. If a function&amp;rsquo;s name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and it calls other Hooks, we say it is a custom Hook. The &lt;code&gt;useSomething&lt;/code&gt; naming convention is how our linter plugin is able to find bugs in the code using Hooks.</source>
          <target state="translated">사용자 정의 후크는 기능보다 더 많은 규칙입니다. 함수의 이름이 &quot; &lt;code&gt;use&lt;/code&gt; &quot;로 시작하고 다른 후크를 호출하면 사용자 정의 후크라고합니다. &lt;code&gt;useSomething&lt;/code&gt; 명명 규칙은 우리 린터 플러그인 후크를 사용하여 코드에서 버그를 발견 할 수있는 방법이다.</target>
        </trans-unit>
        <trans-unit id="889b2d1572ec5a606ea5829eed1474ec8e9eefc3" translate="yes" xml:space="preserve">
          <source>Custom Hooks offer the flexibility of sharing logic that wasn&amp;rsquo;t possible in React components before. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. What&amp;rsquo;s more, you can build Hooks that are just as easy to use as React&amp;rsquo;s built-in features.</source>
          <target state="translated">커스텀 훅은 React 컴포넌트에서 불가능했던 로직 공유의 유연성을 제공합니다. 양식 처리, 애니메이션, 선언적 구독, 타이머 및 고려하지 않은 훨씬 더 많은 사용 사례를 포괄하는 사용자 정의 후크를 작성할 수 있습니다. 또한 React의 내장 기능만큼 사용하기 쉬운 후크를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="806b2ff53cd2bfa7527e0fceb87c041ecaccb1f3" translate="yes" xml:space="preserve">
          <source>DOM Elements</source>
          <target state="translated">DOM 요소</target>
        </trans-unit>
        <trans-unit id="d2a7bdfdc71786e8ffa96fbd33bfaaf81c8d3211" translate="yes" xml:space="preserve">
          <source>DOM Elements Of The Same Type</source>
          <target state="translated">동일한 유형의 DOM 요소</target>
        </trans-unit>
        <trans-unit id="890e1257a40dfb0f216d69df75d9cda18023d0bb" translate="yes" xml:space="preserve">
          <source>Data Fetching</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="68110e796c1686a52b96a567a54626fca49dcd8f" translate="yes" xml:space="preserve">
          <source>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you&amp;rsquo;re used to calling these operations &amp;ldquo;side effects&amp;rdquo; (or just &amp;ldquo;effects&amp;rdquo;), you&amp;rsquo;ve likely performed them in your components before.</source>
          <target state="translated">데이터 반입, 구독 설정 및 React 컴포넌트에서 DOM 수동 변경은 모두 부작용의 예입니다. 이러한 작업을 &quot;부작용&quot;(또는 &quot;효과&quot;)이라고 부르는 데 익숙하지 않더라도 이전에는 구성 요소에서 수행했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="975961a279b1dd24f6702faebb928875d7ef593f" translate="yes" xml:space="preserve">
          <source>Debouncing ensures that a function will not be executed until after a certain amount of time has passed since it was last called. This can be useful when you have to perform some expensive calculation in response to an event that might dispatch rapidly (eg scroll or keyboard events). The example below debounces text input with a 250ms delay.</source>
          <target state="translated">디 바운싱은 함수가 마지막으로 호출 된 후 일정 시간이 지난 후에야 함수가 실행되지 않도록합니다. 이 기능은 빠르게 전달 될 수있는 이벤트 (예 : 스크롤 또는 키보드 이벤트)에 대한 응답으로 값 비싼 계산을 수행해야 할 때 유용 할 수 있습니다. 아래 예제는 250ms 지연으로 텍스트 입력을 디 바운스합니다.</target>
        </trans-unit>
        <trans-unit id="146ed1da84909e0ea7f2d57fc232a7cbe7f4120b" translate="yes" xml:space="preserve">
          <source>Deciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won&amp;rsquo;t disrupt the user experience.</source>
          <target state="translated">앱에서 코드 분할을 도입 할 위치를 결정하는 것은 약간 까다로울 수 있습니다. 번들을 균등하게 분할하지만 사용자 경험을 방해하지 않는 장소를 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a1a03c6db2907a02d02ac307742b16337e3ff60e" translate="yes" xml:space="preserve">
          <source>Declaring Default Props</source>
          <target state="translated">기본 소품 선언</target>
        </trans-unit>
        <trans-unit id="1c0395678e0e22a6dfbc50b32cd02fcc261ee323" translate="yes" xml:space="preserve">
          <source>Declaring a State Variable</source>
          <target state="translated">상태 변수 선언</target>
        </trans-unit>
        <trans-unit id="91cdd342581e6300cc5e618f8e8cd327ddd9921e" translate="yes" xml:space="preserve">
          <source>Declaring multiple state variables</source>
          <target state="translated">여러 상태 변수 선언</target>
        </trans-unit>
        <trans-unit id="9058ac69fc8a219b519e2124a921de745c1a0be1" translate="yes" xml:space="preserve">
          <source>Declaring state variables as a pair of &lt;code&gt;[something, setSomething]&lt;/code&gt; is also handy because it lets us give &lt;em&gt;different&lt;/em&gt; names to different state variables if we want to use more than one:</source>
          <target state="translated">상태 변수를 &lt;code&gt;[something, setSomething]&lt;/code&gt; 쌍으로 선언 하면 하나 이상의 상태를 사용하려는 경우 다른 상태 변수에 &lt;em&gt;다른&lt;/em&gt; 이름을 지정할 수 있으므로 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="b234421a34f058ad2f90d3be643d5a186deef121" translate="yes" xml:space="preserve">
          <source>Default Prop Values</source>
          <target state="translated">기본 소품 값</target>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="68796229e1e55180b39f38c9f451eec72c979663" translate="yes" xml:space="preserve">
          <source>Default: &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;Receded &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;</source>
          <target state="translated">기본값 : &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;Receded &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5efe2d80cf803387680dd016966ba97cdf2d9337" translate="yes" xml:space="preserve">
          <source>Default: Receded &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">기본값 : Receded &amp;rarr; Skeleton &amp;rarr; Complete</target>
        </trans-unit>
        <trans-unit id="3f732e68208a84ef73cfc0f28ac3eb5f0731e140" translate="yes" xml:space="preserve">
          <source>Defer formatting debug values</source>
          <target state="translated">형식화 디버그 값 지연</target>
        </trans-unit>
        <trans-unit id="7ed983b9d4ba5f079bb82c431e13ac78f1dba5df" translate="yes" xml:space="preserve">
          <source>Deferring a Value</source>
          <target state="translated">가치 연기</target>
        </trans-unit>
        <trans-unit id="01f41de7d2358c19aa7ef2a1f2eb537bdc4b3aee" translate="yes" xml:space="preserve">
          <source>Delaying a Pending Indicator</source>
          <target state="translated">보류 표시기 지연</target>
        </trans-unit>
        <trans-unit id="f432560febd7a6cfa286da25ce642df6ffc81c56" translate="yes" xml:space="preserve">
          <source>Delete the remaining empty function declaration.</source>
          <target state="translated">나머지 빈 함수 선언을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="aee6d94594da4652399765313750e40cd7546349" translate="yes" xml:space="preserve">
          <source>Depending on your use case, there are a few more options described below.</source>
          <target state="translated">사용 사례에 따라 아래에 설명 된 몇 가지 옵션이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8fd990fa21b2940e7bad622902554f04b6cce1a" translate="yes" xml:space="preserve">
          <source>Deque - JAWS Keyboard Shortcuts</source>
          <target state="translated">데크-JAWS 키보드 단축키</target>
        </trans-unit>
        <trans-unit id="bff29b77b17a5e1b7f16179d7e152cb915e6fb8d" translate="yes" xml:space="preserve">
          <source>Deque - NVDA Keyboard Shortcuts</source>
          <target state="translated">Deque-NVDA 키보드 단축키</target>
        </trans-unit>
        <trans-unit id="3feae5e9f2aea785939f2ec478ba637643b658b0" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for OS X Keyboard Shortcuts</source>
          <target state="translated">Deque-OS X 키보드 단축키에 대한 VoiceOver</target>
        </trans-unit>
        <trans-unit id="98426dc2662537644ef697f9c4ef75147194e6dc" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for iOS Shortcuts</source>
          <target state="translated">Deque-iOS 용 VoiceOver 단축키</target>
        </trans-unit>
        <trans-unit id="00b0305f7edcae9d72e4e52c23585f04c171dad9" translate="yes" xml:space="preserve">
          <source>Deque Systems offers &lt;a href=&quot;https://github.com/dequelabs/axe-core&quot;&gt;aXe-core&lt;/a&gt; for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium.</source>
          <target state="translated">Deque Systems는 어플리케이션의 자동화 된 엔드-투-엔드 접근성 테스트를위한 &lt;a href=&quot;https://github.com/dequelabs/axe-core&quot;&gt;axe-core&lt;/a&gt; 를 제공 합니다. 이 모듈에는 Selenium 통합이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eac6f20f6e437032f7fa8d1419781d59e9c49f94" translate="yes" xml:space="preserve">
          <source>Deriving state leads to verbose code and makes your components difficult to think about.</source>
          <target state="translated">상태를 파생하면 자세한 코드가 생성되고 구성 요소를 생각하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="7ca6b2f29bf0e683cffc5bfdaa2638ab6df0be0b" translate="yes" xml:space="preserve">
          <source>Detailed Explanation</source>
          <target state="translated">상해</target>
        </trans-unit>
        <trans-unit id="c7c440623df9231008fa4aec05857622d76ad2dc" translate="yes" xml:space="preserve">
          <source>Detecting common mistakes early.</source>
          <target state="translated">일반적인 실수를 조기에 감지합니다.</target>
        </trans-unit>
        <trans-unit id="002d16a2c26ad8258dc7aa2e6dbbd126a2131438" translate="yes" xml:space="preserve">
          <source>Detecting legacy context API</source>
          <target state="translated">레거시 컨텍스트 API 감지</target>
        </trans-unit>
        <trans-unit id="ccc603c2cdbb04454bb06990e1bb1ab194e369eb" translate="yes" xml:space="preserve">
          <source>Detecting unexpected side effects</source>
          <target state="translated">예상치 못한 부작용 감지</target>
        </trans-unit>
        <trans-unit id="80bb7ae4a9c5b6cdd027c90cafab3084c75da073" translate="yes" xml:space="preserve">
          <source>Development and Testing Tools</source>
          <target state="translated">개발 및 테스트 도구</target>
        </trans-unit>
        <trans-unit id="b129fde3a74d991036c7795e38a42e732b1f1540" translate="yes" xml:space="preserve">
          <source>Development assistance</source>
          <target state="translated">개발 지원</target>
        </trans-unit>
        <trans-unit id="608815b4fabeb7ef2bd85ed5eee44fb34c710644" translate="yes" xml:space="preserve">
          <source>Development builds of React include many helpful warnings. Whenever possible, we add warnings in preparation for future breaking changes. That way, if your app has no warnings on the latest release, it will be compatible with the next major release. This allows you to upgrade your apps one component at a time.</source>
          <target state="translated">React의 개발 빌드에는 많은 유용한 경고가 포함됩니다. 가능할 때마다 향후 주요 변경 사항에 대비하여 경고를 추가합니다. 이렇게하면 앱에 최신 릴리스에 대한 경고가 없으면 다음 주요 릴리스와 호환됩니다. 이를 통해 한 번에 하나의 구성 요소로 앱을 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a450d63f7b35b9bbe04b8cc991bfbd556077e4d" translate="yes" xml:space="preserve">
          <source>Development warnings won&amp;rsquo;t affect the runtime behavior of your app. That way, you can feel confident that your app will behave the same way between the development and production builds &amp;mdash; the only differences are that the production build won&amp;rsquo;t log the warnings and that it is more efficient. (If you ever notice otherwise, please file an issue.)</source>
          <target state="translated">개발 경고는 앱의 런타임 동작에 영향을 미치지 않습니다. 이렇게하면 개발과 프로덕션 빌드간에 앱이 동일한 방식으로 작동한다는 확신을 가질 수 있습니다. 유일한 차이점은 프로덕션 빌드가 경고를 기록하지 않고 더욱 효율적이라는 것입니다. (다른 방식으로 통지 한 경우 문제를 제기하십시오.)</target>
        </trans-unit>
        <trans-unit id="b43b5cb3e5aa836cc97a21472f20853a66861f12" translate="yes" xml:space="preserve">
          <source>Differences In Attributes</source>
          <target state="translated">특성의 차이</target>
        </trans-unit>
        <trans-unit id="da4780d7e67194e9f01b5b4900cc7a7ae5aa8624" translate="yes" xml:space="preserve">
          <source>Different DOM events and their properties are described in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;. Note that you need to pass &lt;code&gt;{ bubbles: true }&lt;/code&gt; in each event you create for it to reach the React listener because React automatically delegates events to the document.</source>
          <target state="translated">다양한 DOM 이벤트 및 해당 속성은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN에&lt;/a&gt; 설명되어 있습니다. React는 자동으로 이벤트를 문서에 위임하기 때문에 React 리스너에 도달하기 위해 생성 할 때마다 &lt;code&gt;{ bubbles: true }&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a59ef28ca43dd885ebc992e2f08d12a8a570ac26" translate="yes" xml:space="preserve">
          <source>Different answers may work for different teams and products.</source>
          <target state="translated">팀과 제품마다 다른 답변이 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e84cce8c01530948fa5956c83d6e4827a31df0b" translate="yes" xml:space="preserve">
          <source>Disconnecting your mouse.</source>
          <target state="translated">마우스 연결을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="b0e7d50c6a577134133dd3d463145950993f1200" translate="yes" xml:space="preserve">
          <source>Displaying a custom name in DevTools</source>
          <target state="translated">DevTools에서 사용자 정의 이름 표시</target>
        </trans-unit>
        <trans-unit id="44a86777fdb8e09a6f2376de469c51cc7cd3d091" translate="yes" xml:space="preserve">
          <source>Do Hooks cover all use cases for classes?</source>
          <target state="translated">후크는 수업의 모든 사용 사례를 다루나요?</target>
        </trans-unit>
        <trans-unit id="ae1c8f25cb8a3e0e3f5a04c09f0970001f331d60" translate="yes" xml:space="preserve">
          <source>Do Hooks replace render props and higher-order components?</source>
          <target state="translated">후크가 렌더 소품 및 고차 부품을 대체합니까?</target>
        </trans-unit>
        <trans-unit id="c919201b016ef81644c8f878d23f772ba373c1e0" translate="yes" xml:space="preserve">
          <source>Do Hooks work with static typing?</source>
          <target state="translated">후크는 정적 입력과 함께 작동합니까?</target>
        </trans-unit>
        <trans-unit id="87b6f82ff66e0cbd4e8061b2598cb67ae0d1d9ee" translate="yes" xml:space="preserve">
          <source>Do I need to rewrite all my class components?</source>
          <target state="translated">모든 클래스 구성 요소를 다시 작성해야합니까?</target>
        </trans-unit>
        <trans-unit id="67c589c15fec428e101dd14c9e090c76f321dbce" translate="yes" xml:space="preserve">
          <source>Do I need to use ES6 (+) with React?</source>
          <target state="translated">React와 함께 ES6 (+)를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="034f4c97581ab0eac5aa7ae45a3b714d8a461e85" translate="yes" xml:space="preserve">
          <source>Do I need to use JSX with React?</source>
          <target state="translated">React와 함께 JSX를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="8aef54c26cc1b5ae4c6b4cca79bc678f64db5d2f" translate="yes" xml:space="preserve">
          <source>Do Not Modify State Directly</source>
          <target state="translated">상태를 직접 수정하지 마십시오</target>
        </trans-unit>
        <trans-unit id="f05f09c2bb5d6ffbc40e21d1d4c099d8c14f3da1" translate="yes" xml:space="preserve">
          <source>Does it remain unchanged over time? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">시간이 지나도 변경되지 않습니까? 그렇다면 아마도 상태가 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="d7fc32cc155bdd52c62d75009e1d7dd18126b172" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Mutate the Original Component. Use Composition.</source>
          <target state="translated">원본 구성 요소를 변경하지 마십시오. 구성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e478a98f6ff6cce2b292836e72c385afa0b9b73d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Overuse Refs</source>
          <target state="translated">참조를 과도하게 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="73a270ea743c78a97d5c1f6ae9ca996de5c74e53" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Use HOCs Inside the render Method</source>
          <target state="translated">render 메소드 안에서 HOC를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="02b1cca8627a4cbb02d1603d085e83041d60189d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be afraid to split components into smaller components.</source>
          <target state="translated">구성 요소를 더 작은 구성 요소로 나누는 것을 두려워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3fb0bb795b27da6d04288eaf3f089a6a6a68afdd" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t do it.</source>
          <target state="translated">하지마</target>
        </trans-unit>
        <trans-unit id="3f98fbcb97546add9b1f8fce5b03b25dce6bd0b1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that dispatching DOM events only works when the DOM container is added to the &lt;code&gt;document&lt;/code&gt;. You can use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; to reduce the boilerplate code.</source>
          <target state="translated">DOM 이벤트 전달은 DOM 컨테이너가 &lt;code&gt;document&lt;/code&gt; 추가 될 때만 작동한다는 것을 잊지 마십시오 . &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; 와 같은 라이브러리 를 사용하여 상용구 코드를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e26224844080a9b572cfd5fd397e5b1b87f5c85b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that the argument to &lt;code&gt;useContext&lt;/code&gt; must be the &lt;em&gt;context object itself&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;useContext&lt;/code&gt; 에 대한 인수 는 &lt;em&gt;컨텍스트 객체 자체&lt;/em&gt; 여야 한다는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="dd6f6fde291af71d3a9dee9d6672044fcc6b1fc3" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget to ensure your custom toolchain &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;is correctly set up for production&lt;/a&gt;.</source>
          <target state="translated">맞춤형 툴체인 &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;이 생산을 위해 올바르게 설정&lt;/a&gt; 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="064df9c71e29f2a4d64cc895e0516ae37dd7064c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t overthink it</source>
          <target state="translated">너무 생각하지 마</target>
        </trans-unit>
        <trans-unit id="ad6d64cafa513443888db568d47ebbcd225ba78a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t pass something like &lt;code&gt;Math.random()&lt;/code&gt; to keys. It is important that keys have a &amp;ldquo;stable identity&amp;rdquo; across re-renders so that React can determine when items are added, removed, or re-ordered. Ideally, keys should correspond to unique and stable identifiers coming from your data, such as &lt;code&gt;post.id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random()&lt;/code&gt; 과 같은 것을 키에 전달하지 마십시오 . React가 항목을 추가, 제거 또는 재정렬하는시기를 결정할 수 있도록 키는 재 렌더러간에 &quot;안정적인 ID&quot;를 갖는 것이 중요합니다. 이상적으로 키는 &lt;code&gt;post.id&lt;/code&gt; 와 같이 데이터에서 나오는 고유하고 안정적인 식별자와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="029d0bffb207ca201dbd99502815b3fffb1ac0d0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</source>
          <target state="translated">속성에 JavaScript 표현식을 임베드 할 때 중괄호를 따옴표로 묶지 마십시오. 따옴표 (문자열 값) 또는 중괄호 (표현식)를 사용해야하지만 동일한 속성에서 둘 다 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="616191245cc3b00cac1020020fee84e2a825242d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t wait for it to finish &amp;mdash; this command starts an automated watcher for JSX.</source>
          <target state="translated">완료 될 때까지 기다리지 마십시오.이 명령은 JSX의 자동 감시자를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e92e3588b7283d2cdfb591d81364cb5b78c52b54" translate="yes" xml:space="preserve">
          <source>Download the full example (2KB zipped)</source>
          <target state="translated">전체 예제 다운로드 (2KB 압축)</target>
        </trans-unit>
        <trans-unit id="434d5f91d6854e7dd8d91ecc3709ed83558566c9" translate="yes" xml:space="preserve">
          <source>During subsequent re-renders, the first value returned by &lt;code&gt;useState&lt;/code&gt; will always be the most recent state after applying updates.</source>
          <target state="translated">후속 재 렌더링 동안 &lt;code&gt;useState&lt;/code&gt; 에서 반환 한 첫 번째 값 은 항상 업데이트를 적용한 후 가장 최근 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e95f9e3b12e8c050ccfcb91be022da7394d6e807" translate="yes" xml:space="preserve">
          <source>During the initial render, the returned state (&lt;code&gt;state&lt;/code&gt;) is the same as the value passed as the first argument (&lt;code&gt;initialState&lt;/code&gt;).</source>
          <target state="translated">초기 렌더링 중에 반환 된 상태 ( &lt;code&gt;state&lt;/code&gt; )는 첫 번째 인수 ( &lt;code&gt;initialState&lt;/code&gt; ) 로 전달 된 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6d5f30b1a67d05410070e44d9f02ac7015b9824e" translate="yes" xml:space="preserve">
          <source>Dynamic Context</source>
          <target state="translated">동적 상황</target>
        </trans-unit>
        <trans-unit id="46fa969ce45771386032b3a5d64cd9f951a77ee4" translate="yes" xml:space="preserve">
          <source>ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.</source>
          <target state="translated">ES6은 믹스 인 지원없이 시작되었습니다. 따라서 ES6 클래스와 함께 React를 사용할 때 믹스 인을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae826ab563f75944404f34eae00d4d7c8c62f10c" translate="yes" xml:space="preserve">
          <source>ES6 supports a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt; for arrays which can make this easier. If you&amp;rsquo;re using Create React App, this syntax is available by default.</source>
          <target state="translated">ES6는 배열을위한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;확장 구문&lt;/a&gt; 을 지원하므로 이를 쉽게 할 수 있습니다. React 앱 작성을 사용하는 경우이 구문은 기본적으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="67810097a566468ba0a428297e19c0305506c6f5" translate="yes" xml:space="preserve">
          <source>ES6, ES2015, ES2016, etc</source>
          <target state="translated">ES6, ES2015, ES2016 등</target>
        </trans-unit>
        <trans-unit id="6026fcf7eb58fe23b617131c7f37496a090383ce" translate="yes" xml:space="preserve">
          <source>ESLint Plugin</source>
          <target state="translated">ESLint 플러그인</target>
        </trans-unit>
        <trans-unit id="2c9698e9ce5aaa0c0aae4725e256404ade5ccc99" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Clock&lt;/code&gt; sets up its own timer and updates independently.</source>
          <target state="translated">각 &lt;code&gt;Clock&lt;/code&gt; 는 자체 타이머를 설정하고 독립적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="41d152cdb59389824fd5396d8d5d6cdf14575f6b" translate="yes" xml:space="preserve">
          <source>Each JSX element is just syntactic sugar for calling &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt;. So, anything you can do with JSX can also be done with just plain JavaScript.</source>
          <target state="translated">각 JSX 요소는 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 을 호출하기위한 구문 설탕입니다 . 따라서 JSX로 할 수있는 모든 작업은 일반 JavaScript만으로도 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7b886ed2f99f6eee6ecf2bac5b9c869982764a" translate="yes" xml:space="preserve">
          <source>Each component also provides some other APIs:</source>
          <target state="translated">각 구성 요소는 다른 API도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7e1f5c645de170e0672c34df4eaa7d02ffc47c28" translate="yes" xml:space="preserve">
          <source>Each component has several &amp;ldquo;lifecycle methods&amp;rdquo; that you can override to run code at particular times in the process. &lt;strong&gt;You can use &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; as a cheat sheet.&lt;/strong&gt; In the list below, commonly used lifecycle methods are marked as &lt;strong&gt;bold&lt;/strong&gt;. The rest of them exist for relatively rare use cases.</source>
          <target state="translated">각 구성 요소에는 프로세스에서 특정 시간에 코드를 실행하기 위해 재정의 할 수있는 몇 가지 &quot;라이프 사이클 방법&quot;이 있습니다. &lt;strong&gt;&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;이 라이프 사이클 다이어그램&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 을 치트 시트로 &lt;/strong&gt;&lt;strong&gt;사용할 수 있습니다 . &lt;/strong&gt;아래 목록에서 일반적으로 사용되는 수명주기 방법은 &lt;strong&gt;굵게&lt;/strong&gt; 표시되어 있습니다. 나머지는 비교적 드문 사용 사례에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="0176ed7424152ff8ab0392dc7dd67eec9651185e" translate="yes" xml:space="preserve">
          <source>Each of React&amp;rsquo;s release channels is designed for a distinct use case:</source>
          <target state="translated">React의 각 릴리스 채널은 다음과 같은 고유 한 사용 사례를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3304595495de8d302d926a41fd1baa5284df6967" translate="yes" xml:space="preserve">
          <source>Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike:</source>
          <target state="translated">각 유형의 위젯은 특정 디자인 패턴을 가지며 사용자와 사용자 에이전트가 특정 방식으로 작동 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8a4b173e6d772999aba238dbbf21e762264e11e3" translate="yes" xml:space="preserve">
          <source>Eagle-eyed readers may notice that this example also needs a &lt;code&gt;componentDidUpdate&lt;/code&gt; method to be fully correct. We&amp;rsquo;ll ignore this for now but will come back to it in a &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later section&lt;/a&gt; of this page.</source>
          <target state="translated">Eagle-eyed 독자는이 예제에서도 완전히 올바른 &lt;code&gt;componentDidUpdate&lt;/code&gt; 메소드가 필요하다는 것을 알 수 있습니다. 우리는 지금 이것을 무시할 것이지만 이 페이지 의 &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;후반부&lt;/a&gt; 에 다시 올 것이다 .</target>
        </trans-unit>
        <trans-unit id="2df144c1f5470b38dbff15fd68b81897120c2fdd" translate="yes" xml:space="preserve">
          <source>Earlier on this page, we introduced a &lt;code&gt;FriendStatus&lt;/code&gt; component that calls the &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; Hooks to subscribe to a friend&amp;rsquo;s online status. Let&amp;rsquo;s say we also want to reuse this subscription logic in another component.</source>
          <target state="translated">이 페이지의 앞부분에서 &lt;code&gt;useState&lt;/code&gt; 및 &lt;code&gt;useEffect&lt;/code&gt; Hooks를 호출하여 친구의 온라인 상태를 구독 하는 &lt;code&gt;FriendStatus&lt;/code&gt; 구성 요소를 소개했습니다 . 이 구독 논리를 다른 구성 요소에서 재사용하고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ce320e4c6ff9a6a9b9a62001b3d3f5a450f5418d" translate="yes" xml:space="preserve">
          <source>Earlier, we looked at how to express side effects that don&amp;rsquo;t require any cleanup. However, some effects do. For example, &lt;strong&gt;we might want to set up a subscription&lt;/strong&gt; to some external data source. In that case, it is important to clean up so that we don&amp;rsquo;t introduce a memory leak! Let&amp;rsquo;s compare how we can do it with classes and with Hooks.</source>
          <target state="translated">이전에는 정리할 필요가없는 부작용을 표현하는 방법을 살펴 보았습니다. 그러나 일부 효과가 있습니다. 예를 들어 일부 외부 데이터 소스에 &lt;strong&gt;대한 구독&lt;/strong&gt; 을 &lt;strong&gt;설정하려고 할 수 있습니다&lt;/strong&gt; . 이 경우 메모리 누수가 발생하지 않도록 정리하는 것이 중요합니다! 클래스와 후크로 어떻게 할 수 있는지 비교해 봅시다.</target>
        </trans-unit>
        <trans-unit id="e0db10be720c4542dc812212fd4b92347db83913" translate="yes" xml:space="preserve">
          <source>Effects Without Cleanup</source>
          <target state="translated">정리없는 효과</target>
        </trans-unit>
        <trans-unit id="57804dbde08f38b28a414aabc784a7e90ffe5a58" translate="yes" xml:space="preserve">
          <source>Effects may also optionally specify how to &amp;ldquo;clean up&amp;rdquo; after them by returning a function. For example, this component uses an effect to subscribe to a friend&amp;rsquo;s online status, and cleans up by unsubscribing from it:</source>
          <target state="translated">효과는 선택적으로 함수를 반환하여 결과를 &quot;정리&quot;하는 방법을 지정할 수도 있습니다. 예를 들어이 구성 요소는 효과를 사용하여 친구의 온라인 상태를 구독하고 구독을 취소하여 정리합니다.</target>
        </trans-unit>
        <trans-unit id="067af3767b2d83fcee477226ef073ed88d3308ef" translate="yes" xml:space="preserve">
          <source>Effects with Cleanup</source>
          <target state="translated">정리 효과</target>
        </trans-unit>
        <trans-unit id="bbe263051dda9256ae9ab5d63ace0547c7ae0286" translate="yes" xml:space="preserve">
          <source>Either the common owner or another component higher up in the hierarchy should own the state.</source>
          <target state="translated">공통 소유자 또는 계층 구조에서 상위에있는 다른 구성 요소가 상태를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="f12618059a59ed49359f6cb25531e3ed82d82948" translate="yes" xml:space="preserve">
          <source>Element Variables</source>
          <target state="translated">요소 변수</target>
        </trans-unit>
        <trans-unit id="a563972e807d43617dfb0a4b0398984476c03544" translate="yes" xml:space="preserve">
          <source>Elements</source>
          <target state="translated">Elements</target>
        </trans-unit>
        <trans-unit id="dd7c7a5711e5252900f3896e5898b67e774127ee" translate="yes" xml:space="preserve">
          <source>Elements Of Different Types</source>
          <target state="translated">다른 유형의 요소</target>
        </trans-unit>
        <trans-unit id="9fad1ea61da1a1549221602c09dee579a5c3b9f8" translate="yes" xml:space="preserve">
          <source>Elements are the smallest building blocks of React apps.</source>
          <target state="translated">요소는 React 앱의 가장 작은 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="8a984f808a95efb06c05b0ad060717183d6f03a5" translate="yes" xml:space="preserve">
          <source>Embedding Expressions in JSX</source>
          <target state="translated">JSX에 식 임베딩</target>
        </trans-unit>
        <trans-unit id="a3fa1768c7e543a2e6ed6c6cc94c404ff2f04bd5" translate="yes" xml:space="preserve">
          <source>Embedding React in a Backbone View</source>
          <target state="translated">백본 뷰에서 반응 삽입</target>
        </trans-unit>
        <trans-unit id="aacb1baf7df238a26a446d18f763426c30713b51" translate="yes" xml:space="preserve">
          <source>Embedding map() in JSX</source>
          <target state="translated">JSX에 map () 임베드</target>
        </trans-unit>
        <trans-unit id="ef9fdec9eb68d951dfbaff3b0bc88dfafff1b31b" translate="yes" xml:space="preserve">
          <source>Enabling Concurrent Mode</source>
          <target state="translated">동시 모드 활성화</target>
        </trans-unit>
        <trans-unit id="e6f6463c153c032ec57c13a6815c6707e987c657" translate="yes" xml:space="preserve">
          <source>End-to-end tests</source>
          <target state="translated">엔드 투 엔드 테스트</target>
        </trans-unit>
        <trans-unit id="618d5c30b42f17cd59a0b44bf98961d419481e3c" translate="yes" xml:space="preserve">
          <source>End-to-end tests are used for testing longer flows across multiple pages, and require a &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;different setup&lt;/a&gt;.</source>
          <target state="translated">엔드 투 엔드 테스트는 여러 페이지에서 더 긴 흐름을 테스트하는 데 사용되며 &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;다른 설정이&lt;/a&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="44ff0e989a1887a8b6193684dcee81bdb671d4fb" translate="yes" xml:space="preserve">
          <source>End-to-end tests are useful for testing longer workflows, especially when they&amp;rsquo;re critical to your business (such as payments or signups). For these tests, you&amp;rsquo;d probably want to test how a real browser renders the whole app, fetches data from the real API endpoints, uses sessions and cookies, navigates between different links. You might also likely want to make assertions not just on the DOM state, but on the backing data as well (e.g. to verify whether the updates have been persisted to the database).</source>
          <target state="translated">엔드-투-엔드 테스트는 특히 비즈니스에 중요한 경우 (예 : 지불 또는 가입) 더 긴 워크 플로우를 테스트하는 데 유용합니다. 이러한 테스트의 경우 실제 브라우저가 전체 앱을 렌더링하고 실제 API 끝점에서 데이터를 가져오고 세션과 쿠키를 사용하고 다른 링크를 탐색하는 방법을 테스트하고 싶을 것입니다. DOM 상태뿐만 아니라 백업 데이터에서도 어설 션을 작성하고 싶을 수도 있습니다 (예 : 업데이트가 데이터베이스에 유지되었는지 확인).</target>
        </trans-unit>
        <trans-unit id="a5843a84a4b8862585b36101bef81f0d8280f045" translate="yes" xml:space="preserve">
          <source>Ensure that Flow syntax is stripped from the compiled code.</source>
          <target state="translated">컴파일 된 코드에서 Flow 구문이 제거되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="51cf02d9d35abf8266d4450b71ee590a50a53972" translate="yes" xml:space="preserve">
          <source>Ensure that all functionality exposed through a mouse or pointer event can also be accessed using the keyboard alone. Depending only on the pointer device will lead to many cases where keyboard users cannot use your application.</source>
          <target state="translated">마우스 또는 포인터 이벤트를 통해 노출 된 모든 기능에 키보드 만 사용하여 액세스 할 수 있는지 확인하십시오. 포인터 장치에만 의존하면 키보드 사용자가 응용 프로그램을 사용할 수없는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="88fdec0dd152000afa7d243170296b25bac2fcd3" translate="yes" xml:space="preserve">
          <source>Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision:</source>
          <target state="translated">웹 사이트에서 읽을 수있는 모든 텍스트가 시력이 좋지 않은 사용자가 최대한 읽을 수 있도록 색상 대비가 충분한 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="72e14358a65b55cdbc91557cae723551902738cd" translate="yes" xml:space="preserve">
          <source>Ensure that your web application can be fully operated with the keyboard only:</source>
          <target state="translated">키보드로만 웹 애플리케이션을 완벽하게 조작 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="c27b6077f641637b35de9622914726dc00b525d8" translate="yes" xml:space="preserve">
          <source>Equivalent Class Example</source>
          <target state="translated">동등한 클래스 예</target>
        </trans-unit>
        <trans-unit id="e313459b257b5def2c0095882b1a2ca4c257446e" translate="yes" xml:space="preserve">
          <source>Error Boundaries</source>
          <target state="translated">오류 경계</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="da2e786d909fab53638b47aa2712c732c26c75ee" translate="yes" xml:space="preserve">
          <source>Error boundaries</source>
          <target state="translated">오류 경계</target>
        </trans-unit>
        <trans-unit id="03152f355d4a7b27375ca08203950d26f97e75f9" translate="yes" xml:space="preserve">
          <source>Error boundaries &lt;strong&gt;do not&lt;/strong&gt; catch errors inside event handlers.</source>
          <target state="translated">오류 경계 &lt;strong&gt;는&lt;/strong&gt; 이벤트 핸들러 내에서 오류를 포착 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6af7f5bac8d79dc1bd8bd3b1474a63f22115b8fa" translate="yes" xml:space="preserve">
          <source>Error boundaries are React components that &lt;strong&gt;catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI&lt;/strong&gt; instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="translated">오류 경계는 &lt;strong&gt;하위 구성 요소 트리의 어느 곳에서나 JavaScript 오류&lt;/strong&gt; 를 &lt;strong&gt;포착하고 해당 오류를 기록&lt;/strong&gt; 하며 충돌 한 구성 요소 트리 대신 &lt;strong&gt;대체 UI&lt;/strong&gt; 를 &lt;strong&gt;표시하는&lt;/strong&gt; React 구성 요소입니다 . 오류 경계는 렌더링 중, 수명주기 메소드 및 그 아래에있는 전체 트리의 생성자에서 오류를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="39dd3e6e86473b72348512586d611a8ba2b1e4a8" translate="yes" xml:space="preserve">
          <source>Error boundaries do &lt;strong&gt;not&lt;/strong&gt; catch errors for:</source>
          <target state="translated">오류 경계는 다음에 대한 오류를 포착 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8da91143355e2bfa5c28fa5a3e89aaf38272149c" translate="yes" xml:space="preserve">
          <source>Error boundaries only catch errors in the components &lt;strong&gt;below&lt;/strong&gt; them in the tree. An error boundary can&amp;rsquo;t catch an error within itself.</source>
          <target state="translated">오류 경계 는 트리에서 그 &lt;strong&gt;아래&lt;/strong&gt; 구성 요소의 오류 만 포착합니다 . 오류 경계는 자체적으로 오류를 포착 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="248b6ba22edd7984eab15c29276a446063ab0aff" translate="yes" xml:space="preserve">
          <source>Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a &lt;code&gt;componentDidUpdate&lt;/code&gt; method caused by a &lt;code&gt;setState&lt;/code&gt; somewhere deep in the tree, it will still correctly propagate to the closest error boundary.</source>
          <target state="translated">오류 경계는 React의 선언적 특성을 유지하고 예상대로 작동합니다. 예를 들어, 트리의 어딘가에 있는 &lt;code&gt;setState&lt;/code&gt; 로 인해 &lt;code&gt;componentDidUpdate&lt;/code&gt; 메소드 에서 오류가 발생하더라도 여전히 가장 가까운 오류 경계에 올바르게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="411c6161162d374478de2da829feb52753d31c43" translate="yes" xml:space="preserve">
          <source>Error boundaries work like a JavaScript &lt;code&gt;catch {}&lt;/code&gt; block, but for components. Only class components can be error boundaries. In practice, most of the time you&amp;rsquo;ll want to declare an error boundary component once and use it throughout your application.</source>
          <target state="translated">오류 경계는 JavaScript &lt;code&gt;catch {}&lt;/code&gt; 블록 처럼 작동 하지만 구성 요소에는 적용됩니다. 클래스 구성 요소 만 오류 경계가 될 수 있습니다. 실제로 대부분의 경우 오류 경계 구성 요소를 한 번 선언하여 응용 프로그램 전체에서 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cd059244f14954e007f3b6cfacf808b82d7ce7d4" translate="yes" xml:space="preserve">
          <source>Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well:</source>
          <target state="translated">모든 사용자가 오류 상황을 이해해야합니다. 다음 링크는 오류 텍스트를 화면 판독기에 표시하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="35443072fb1b4b2e5833169fce316e0027876ff0" translate="yes" xml:space="preserve">
          <source>Errors thrown in the error boundary itself (rather than its children)</source>
          <target state="translated">오류 경계 자체에서 발생하는 오류 (자식이 아닌)</target>
        </trans-unit>
        <trans-unit id="f674a480e681e853c6cf688edcbab6c3feddf9d0" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;useRef&lt;/code&gt; is like a &amp;ldquo;box&amp;rdquo; that can hold a mutable value in its &lt;code&gt;.current&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 &lt;code&gt;useRef&lt;/code&gt; 는 &lt;code&gt;.current&lt;/code&gt; 속성 에서 변경 가능한 값을 보유 할 수있는&amp;ldquo;상자&amp;rdquo;와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed8ea1020f1d75f7199278f4580a82b25ad798a7" translate="yes" xml:space="preserve">
          <source>Essentially, this package makes it easy to grab a snapshot of the platform view hierarchy (similar to a DOM tree) rendered by a React DOM or React Native component without using a browser or &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;.</source>
          <target state="translated">기본적으로이 패키지를 사용하면 브라우저 또는 &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; 을 사용하지 않고도 React DOM 또는 React Native 구성 요소로 렌더링 된 플랫폼보기 계층 (DOM 트리와 유사)의 스냅 샷을 쉽게 확보 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92165cf4b8634704f3dd64e1f8f473a86a3dfc88" translate="yes" xml:space="preserve">
          <source>Even though React only updates the changed DOM nodes, re-rendering still takes some time. In many cases it&amp;rsquo;s not a problem, but if the slowdown is noticeable, you can speed all of this up by overriding the lifecycle function &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, which is triggered before the re-rendering process starts. The default implementation of this function returns &lt;code&gt;true&lt;/code&gt;, leaving React to perform the update:</source>
          <target state="translated">React가 변경된 DOM 노드 만 업데이트하더라도 다시 렌더링하는 데 여전히 시간이 걸립니다. 대부분의 경우 문제가되지 않지만 속도 저하가 눈에 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 다시 렌더링 프로세스가 시작되기 전에 트리거되는 수명주기 함수 shouldComponentUpdate 를 재정 의하여이 모든 속도를 높일 수 있습니다 . 이 함수의 기본 구현은 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 React는 업데이트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="924f0e891475199a8affc9523b77fbd74b8922e4" translate="yes" xml:space="preserve">
          <source>Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the &lt;em&gt;React tree&lt;/em&gt; regardless of position in the &lt;em&gt;DOM tree&lt;/em&gt;.</source>
          <target state="translated">포털은 DOM 트리의 어느 위치 에나있을 수 있지만 다른 모든 방식에서 일반 React 하위처럼 작동합니다. 문맥과 같은 기능은 포털 이 &lt;em&gt;DOM 트리&lt;/em&gt; 의 위치에 관계없이 &lt;em&gt;반응 트리&lt;/em&gt; 에 여전히 존재하기 때문에 자식이 포털인지 여부에 관계없이 정확히 동일하게 작동합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c234d806af4f9b93ae1c3343e0c37520ad7b27b8" translate="yes" xml:space="preserve">
          <source>Even though there is an improvement in responsiveness, this example isn&amp;rsquo;t as compelling yet because Concurrent Mode is missing some crucial optimizations for this use case. Still, it is interesting to see that features like &lt;code&gt;useDeferredValue&lt;/code&gt; (or &lt;code&gt;useTransition&lt;/code&gt;) are useful regardless of whether we&amp;rsquo;re waiting for network or for computational work to finish.</source>
          <target state="translated">응답 성이 향상 되었음에도 불구하고이 예는 Concurrent Mode에이 사용 사례에 대한 몇 가지 중요한 최적화가 없기 때문에 아직 설득력이 없습니다. 그럼에도 불구하고 &lt;code&gt;useDeferredValue&lt;/code&gt; (또는 &lt;code&gt;useTransition&lt;/code&gt; ) 와 같은 기능 이 네트워크를 기다리고 있는지 또는 계산 작업이 완료되는지에 관계없이 유용하다는 것을 알면 흥미 롭습니다 .</target>
        </trans-unit>
        <trans-unit id="7f0feec935c5e1e4103deb1b038015f52b4ea92e" translate="yes" xml:space="preserve">
          <source>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</source>
          <target state="translated">모든 눈금에서 전체 UI 트리를 설명하는 요소를 작성하더라도 내용이 변경된 텍스트 노드 만 React DOM에 의해 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4df1474813d930819981e65a532a43e94f18614f" translate="yes" xml:space="preserve">
          <source>Event Bubbling Through Portals</source>
          <target state="translated">포털을 통한 이벤트 버블 링</target>
        </trans-unit>
        <trans-unit id="0b8ceaea6e54f53ca7606e2b231356ee7e352e59" translate="yes" xml:space="preserve">
          <source>Event Pooling</source>
          <target state="translated">이벤트 풀링</target>
        </trans-unit>
        <trans-unit id="e4f93781ab58d940daeeab4fa2ec6ce635c2bb68" translate="yes" xml:space="preserve">
          <source>Event handlers (&lt;a href=&quot;#how-about-event-handlers&quot;&gt;learn more&lt;/a&gt;)</source>
          <target state="translated">이벤트 핸들러 ( &lt;a href=&quot;#how-about-event-handlers&quot;&gt;자세한 내용&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b61d8939222566ff94f9b0d2a3a735bb6bb39811" translate="yes" xml:space="preserve">
          <source>Event names:</source>
          <target state="translated">이벤트 이름 :</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="c868e98d442bceb6d6a31a9193b8883b3cf64c2c" translate="yes" xml:space="preserve">
          <source>Events emitted by a Web Component may not properly propagate through a React render tree. You will need to manually attach event handlers to handle these events within your React components.</source>
          <target state="translated">웹 컴포넌트에서 생성 된 이벤트는 React 렌더 트리를 통해 제대로 전파되지 않을 수 있습니다. React 컴포넌트 내에서 이러한 이벤트를 처리하려면 이벤트 핸들러를 수동으로 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fe83c627adaf007c6dfbb261d61277ba4166113" translate="yes" xml:space="preserve">
          <source>Eventually, they load too, and we get to the &lt;strong&gt;Complete&lt;/strong&gt; state.</source>
          <target state="translated">결국로드도 &lt;strong&gt;완료&lt;/strong&gt; 되고 &lt;strong&gt;완료&lt;/strong&gt; 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e1bc576ea3a8cb04a164577963ea58a853e3afac" translate="yes" xml:space="preserve">
          <source>Every Context object comes with a Provider React component that allows consuming components to subscribe to context changes.</source>
          <target state="translated">모든 컨텍스트 개체에는 소비하는 구성 요소가 컨텍스트 변경에 가입 할 수있는 공급자 리 액트 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a709b81de0a69becea1cb5a5514e9bdc3d2b1412" translate="yes" xml:space="preserve">
          <source>Every HTML form control, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.</source>
          <target state="translated">&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 와 같은 모든 HTML 양식 컨트롤에는 액세스 가능하게 레이블이 지정되어야합니다. 화면 판독기에 노출되는 설명 레이블을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc3a16f46419ddc7fc52c28781265c7d2e286f41" translate="yes" xml:space="preserve">
          <source>Every chapter in this guide builds on the knowledge introduced in earlier chapters. &lt;strong&gt;You can learn most of React by reading the &amp;ldquo;Main Concepts&amp;rdquo; guide chapters in the order they appear in the sidebar.&lt;/strong&gt; For example, &lt;a href=&quot;introducing-jsx&quot;&gt;&amp;ldquo;Introducing JSX&amp;rdquo;&lt;/a&gt; is the next chapter after this one.</source>
          <target state="translated">이 안내서의 모든 장은 이전 장에서 소개 된 지식을 바탕으로합니다. &lt;strong&gt;사이드 바에 나타나는 순서대로 &quot;주요 개념&quot;안내서 장을 읽으면 React의 대부분을 배울 수 있습니다. &lt;/strong&gt;예를 들어, &lt;a href=&quot;introducing-jsx&quot;&gt;&amp;ldquo;JSX 소개&amp;rdquo;&lt;/a&gt; 는이 장의 다음 장입니다.</target>
        </trans-unit>
        <trans-unit id="22e16346b19291f6f8c5eadf2f6c0c265401d9a1" translate="yes" xml:space="preserve">
          <source>Every second the browser calls the &lt;code&gt;tick()&lt;/code&gt; method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component schedules a UI update by calling &lt;code&gt;setState()&lt;/code&gt; with an object containing the current time. Thanks to the &lt;code&gt;setState()&lt;/code&gt; call, React knows the state has changed, and calls the &lt;code&gt;render()&lt;/code&gt; method again to learn what should be on the screen. This time, &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</source>
          <target state="translated">브라우저는 매초 &lt;code&gt;tick()&lt;/code&gt; 메소드를 호출합니다 . 그 안에있는 &lt;code&gt;Clock&lt;/code&gt; 구성 요소 는 현재 시간이 포함 된 객체로 &lt;code&gt;setState()&lt;/code&gt; 를 호출하여 UI 업데이트를 예약합니다 . &lt;code&gt;setState()&lt;/code&gt; 호출 덕분에 React는 상태가 변경되었음을 알고 화면에 무엇이 있는지 알아 내기 위해 다시 &lt;code&gt;render()&lt;/code&gt; 메소드를 호출합니다 . 이번에 는 &lt;code&gt;render()&lt;/code&gt; 메서드 의 &lt;code&gt;this.state.date&lt;/code&gt; 가 달라 지므로 렌더링 출력에 업데이트 된 시간이 포함됩니다. 반응은 DOM을 적절히 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ca789e554144152f7db135502a37ee6272fdac89" translate="yes" xml:space="preserve">
          <source>Every update goes through the same steps so the inputs stay in sync.</source>
          <target state="translated">모든 업데이트는 동일한 단계를 거치므로 입력이 동기화 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9f10b7b1d08963082b3b0438a8cee95484cda1b0" translate="yes" xml:space="preserve">
          <source>Everything About Color Contrast And Why You Should Rethink It</source>
          <target state="translated">색상 대비에 대한 모든 것 그리고 다시 생각해야하는 이유</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a7a6308ad44891ddf6909929d40496f9e973e4d3" translate="yes" xml:space="preserve">
          <source>Example Using Classes</source>
          <target state="translated">클래스를 사용한 예제</target>
        </trans-unit>
        <trans-unit id="544356c9967d3974c81e67f45b423c412bb7d269" translate="yes" xml:space="preserve">
          <source>Example Using Hooks</source>
          <target state="translated">후크 사용 예</target>
        </trans-unit>
        <trans-unit id="a34b5aab0e2defa2c691dfe943707a88581e4bc4" translate="yes" xml:space="preserve">
          <source>Example of code that will &lt;em&gt;not&lt;/em&gt; behave as expected:</source>
          <target state="translated">예상대로 작동 &lt;em&gt;하지 않는&lt;/em&gt; 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ac26e2fb063dce87621ddf37c84bee42bd05cd61" translate="yes" xml:space="preserve">
          <source>Example: Passing params using arrow functions</source>
          <target state="translated">예 : 화살표 함수를 사용하여 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="1534aebdb3554e45f79006431dd0cdaca898df7b" translate="yes" xml:space="preserve">
          <source>Example: Passing params using data-attributes</source>
          <target state="translated">예 : 데이터 속성을 사용하여 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="a4dfb53af8b594cf4d30b3c3be001d98033a8e66" translate="yes" xml:space="preserve">
          <source>Example: Using AJAX results to set local state</source>
          <target state="translated">예 : AJAX 결과를 사용하여 로컬 상태 설정</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="6a7545676e7ab4f24a631ecbbad43ce7fccaad5c" translate="yes" xml:space="preserve">
          <source>Experienced JavaScript developers might notice that the function passed to &lt;code&gt;useEffect&lt;/code&gt; is going to be different on every render. This is intentional. In fact, this is what lets us read the &lt;code&gt;count&lt;/code&gt; value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a &lt;em&gt;different&lt;/em&gt; effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result &amp;mdash; each effect &amp;ldquo;belongs&amp;rdquo; to a particular render. We will see more clearly why this is useful &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later on this page&lt;/a&gt;.</source>
          <target state="translated">숙련 된 JavaScript 개발자는 &lt;code&gt;useEffect&lt;/code&gt; 에 전달 된 함수가 렌더링마다 다를 수 있음을 알 수 있습니다. 이것은 의도적 인 것입니다. 사실, 이것이 효과가 없어지는 것을 걱정하지 않고 이펙트 내부에서 &lt;code&gt;count&lt;/code&gt; 값을 읽을 수있게 해줍니다 . 다시 렌더링 할 때마다 이전 효과를 대체하여 &lt;em&gt;다른&lt;/em&gt; 효과를 예약합니다 . 어떤 식 으로든, 효과는 렌더링 결과의 일부처럼 효과를냅니다. 각 효과는 특정 렌더에 포함됩니다. &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;이 페이지 뒷부분에서 이것이&lt;/a&gt; 왜 유용한 지 더 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2831ba29ffe2492200b0f4890460a562dd66bd6b" translate="yes" xml:space="preserve">
          <source>Experimental Channel</source>
          <target state="translated">실험 채널</target>
        </trans-unit>
        <trans-unit id="1691fa49296bc2c4bc77c3e42c64fba2a29ea9fb" translate="yes" xml:space="preserve">
          <source>Experimental features are ones that are not ready to be released to the wider public, and may change drastically before they are finalized. Some experiments may never be finalized &amp;mdash; the reason we have experiments is to test the viability of proposed changes.</source>
          <target state="translated">실험적인 기능은 더 많은 사람들에게 공개 할 준비가되지 않은 기능이며 최종 기능이 완성되기 전에 크게 변경 될 수 있습니다. 일부 실험은 완료되지 않을 수 있습니다. 실험이 필요한 이유는 제안 된 변경 사항의 실행 가능성을 테스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="16bbe54f4338869e513550bc6e7bec3deb89f284" translate="yes" xml:space="preserve">
          <source>Experimental features may or may not be documented. Usually, experiments aren&amp;rsquo;t documented until they are close to shipping in Next or Stable.</source>
          <target state="translated">실험적인 특징은 문서화되거나 문서화되지 않을 수 있습니다. 일반적으로 실험은 다음 또는 안정적으로 배송 될 때까지 문서화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7419ab25c67c5d7fdae34ae9794a8a69a072dfb1" translate="yes" xml:space="preserve">
          <source>Experimental releases may be significantly different than releases to Next and Latest. &lt;strong&gt;Do not use Experimental releases in user-facing applications.&lt;/strong&gt; You should expect frequent breaking changes between releases in the Experimental channel.</source>
          <target state="translated">실험 릴리스는 다음 및 최신 릴리스와 크게 다를 수 있습니다. &lt;strong&gt;사용자 용 응용 프로그램에서 실험용 릴리스를 사용하지 마십시오. &lt;/strong&gt;실험 채널의 릴리스간에 자주 변경되는 변경 사항이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="55a90e8035a82de0d93f1c9a3c7f341af3106c00" translate="yes" xml:space="preserve">
          <source>Explanation: Why Effects Run on Each Update</source>
          <target state="translated">설명 : 각 업데이트에서 효과가 실행되는 이유</target>
        </trans-unit>
        <trans-unit id="262ee9d29af39ff552e4c59e7fda03780ccb25a1" translate="yes" xml:space="preserve">
          <source>Exposing DOM Refs to Parent Components</source>
          <target state="translated">부모 구성 요소에 DOM 참조 노출</target>
        </trans-unit>
        <trans-unit id="79e3b02c6073db5722a2445db289eed3bc30f1df" translate="yes" xml:space="preserve">
          <source>Extracting Components</source>
          <target state="translated">성분 추출</target>
        </trans-unit>
        <trans-unit id="9b3ad8ee661c9841c42e93cfe58a6f4283443a37" translate="yes" xml:space="preserve">
          <source>Extracting Components with Keys</source>
          <target state="translated">키를 사용하여 구성 요소 추출</target>
        </trans-unit>
        <trans-unit id="b6a7f2eb5a5056a20dc5cf476d802afcad85ef47" translate="yes" xml:space="preserve">
          <source>Extracting Data from Backbone Models</source>
          <target state="translated">백본 모델에서 데이터 추출</target>
        </trans-unit>
        <trans-unit id="2ddc74504155a0221350a8de09769a873178d902" translate="yes" xml:space="preserve">
          <source>Extracting a Custom Hook</source>
          <target state="translated">사용자 정의 후크 추출</target>
        </trans-unit>
        <trans-unit id="238fe11258ea53623c0e9f18b2d4fa180b9ce41e" translate="yes" xml:space="preserve">
          <source>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (&lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Panel&lt;/code&gt;, &lt;code&gt;Avatar&lt;/code&gt;), or is complex enough on its own (&lt;code&gt;App&lt;/code&gt;, &lt;code&gt;FeedStory&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;), it is a good candidate to be a reusable component.</source>
          <target state="translated">컴포넌트 추출은 처음에는 거친 작업처럼 보일 수 있지만 재사용 가능한 컴포넌트 팔레트를 사용하면 더 큰 앱에서 효과를 볼 수 있습니다. 경험상 UI의 일부가 여러 번 사용 되거나 ( &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Panel&lt;/code&gt; , &lt;code&gt;Avatar&lt;/code&gt; ) 자체적으로 복잡 할 경우 ( &lt;code&gt;App&lt;/code&gt; , &lt;code&gt;FeedStory&lt;/code&gt; , &lt;code&gt;Comment&lt;/code&gt; ) 재사용 가능한 구성 요소가 될 수있는 좋은 후보입니다 .</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="d7ca52e8a67912bc341fe3a3cf2185f9f12fe00b" translate="yes" xml:space="preserve">
          <source>Feature Comparison</source>
          <target state="translated">기능 비교</target>
        </trans-unit>
        <trans-unit id="d31683b71129689222166ae6fa094345d3274ca8" translate="yes" xml:space="preserve">
          <source>Fetching early can be cumbersome to express. How do we make it easier to avoid waterfalls?</source>
          <target state="translated">일찍 가져 오는 것은 번거로울 수 있습니다. 폭포를 피하기 쉽게 만드는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d0de66d5acebdbcad2664d79de96d44cd22b0450" translate="yes" xml:space="preserve">
          <source>Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM. &lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;Read more&lt;/a&gt;.</source>
          <target state="translated">Fiber는 React 16의 새로운 조정 엔진입니다. 주요 목표는 가상 DOM의 증분 렌더링을 가능하게하는 것입니다. &lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;더 읽어보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f29e7621a1a9119ef236e19e00448244df7422" translate="yes" xml:space="preserve">
          <source>File Structure</source>
          <target state="translated">파일 구조</target>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">파일 확장자</target>
        </trans-unit>
        <trans-unit id="a78e8a4f64ac4a4b1fabdf7e14799f6b58765746" translate="yes" xml:space="preserve">
          <source>Finally, another possible reason you&amp;rsquo;re seeing stale props or state is if you use the &amp;ldquo;dependency array&amp;rdquo; optimization but didn&amp;rsquo;t correctly specify all the dependencies. For example, if an effect specifies &lt;code&gt;[]&lt;/code&gt; as the second argument but reads &lt;code&gt;someProp&lt;/code&gt; inside, it will keep &amp;ldquo;seeing&amp;rdquo; the initial value of &lt;code&gt;someProp&lt;/code&gt;. The solution is to either remove the dependency array, or to fix it. Here&amp;rsquo;s &lt;a href=&quot;#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how you can deal with functions&lt;/a&gt;, and here&amp;rsquo;s &lt;a href=&quot;#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;other common strategies&lt;/a&gt; to run effects less often without incorrectly skipping dependencies.</source>
          <target state="translated">마지막으로, 오래된 소품 또는 상태가 표시되는 또 다른 이유는 &quot;종속성 배열&quot;최적화를 사용하지만 모든 종속성을 올바르게 지정하지 않았기 때문입니다. 효과 지정하는 경우, 예를 들어, &lt;code&gt;[]&lt;/code&gt; 번째 인수하지만 읽기 &lt;code&gt;someProp&lt;/code&gt; 의 내부를, 그것의 &quot;볼&quot;초기 값 유지할 &lt;code&gt;someProp&lt;/code&gt; 를 . 해결책은 종속성 배열을 제거하거나 수정하는 것입니다. 다음 &lt;a href=&quot;#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;은 함수를 다루는 방법&lt;/a&gt; 이며, 종속성을 잘못 건너 뛰지 않고 효과를 덜 자주 실행하는 &lt;a href=&quot;#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;다른 일반적인 전략&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ba0489d65d2d3fc21a360081711a99ffee70891" translate="yes" xml:space="preserve">
          <source>Finally, don&amp;rsquo;t miss the &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; which explains &lt;em&gt;why&lt;/em&gt; we&amp;rsquo;re adding Hooks and how we&amp;rsquo;ll start using them side by side with classes &amp;mdash; without rewriting our apps.</source>
          <target state="translated">마지막으로, 후크를 추가하는 &lt;em&gt;이유&lt;/em&gt; 와 앱을 다시 작성하지 않고 클래스와 함께 후크를 사용하는 방법 을 설명 하는 &lt;a href=&quot;hooks-intro&quot;&gt;소개 페이지&lt;/a&gt; 를 놓치지 마십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8438bc41cca4e743aa12124ae77341500cac594" translate="yes" xml:space="preserve">
          <source>Finally, run one of the following commands:</source>
          <target state="translated">마지막으로 다음 명령 중 하나를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1c2aa8b54c68956359dcc663aff9d9037284022e" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; Hook reduces the need to pass callbacks deeply, as explained below.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt; Hook는 아래 설명과 같이 콜백을 깊게 전달할 필요성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="570ce262c8a7066abc6b8bb5f403e6fb557d261e" translate="yes" xml:space="preserve">
          <source>Finally, the resulting bundle is piped to &lt;a href=&quot;https://github.com/terser-js/terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; for mangling (&lt;a href=&quot;https://github.com/hughsk/uglifyify#motivationusage&quot;&gt;read why&lt;/a&gt;).</source>
          <target state="translated">마지막으로, 결과 번들은 파이프됩니다 &lt;a href=&quot;https://github.com/terser-js/terser&quot;&gt; &lt;code&gt;terser&lt;/code&gt; &lt;/a&gt; (맹 글링에 대한 &lt;a href=&quot;https://github.com/hughsk/uglifyify#motivationusage&quot;&gt;이유를 읽어&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ccd077e06c84210a2fb3afbe0a686af0ac5ca973" translate="yes" xml:space="preserve">
          <source>Finally, there are two primary ways that lead us to the Skeleton state. We will illustrate the difference between them with a concrete example.</source>
          <target state="translated">마지막으로, 우리를 골격 상태로 이끄는 두 가지 주요 방법이 있습니다. 구체적인 예를 통해 차이점을 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9a0fdc61c51d5713eda8f9ef73a39353026b49e9" translate="yes" xml:space="preserve">
          <source>Finally, there is one more thing left to do. In React, props can change over time. For example, the &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; component can get different children if parent component&amp;rsquo;s state changes. This means that at integration points it is important that we manually update the DOM in response to prop updates, since we no longer let React manage the DOM for us.</source>
          <target state="translated">마지막으로해야 할 일이 하나 더 남아 있습니다. React에서 소품은 시간이 지남에 따라 바뀔 수 있습니다. 예를 들어 부모 구성 요소의 상태가 변경되면 &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; 구성 요소가 다른 자식을 가질 수 있습니다. 이는 통합 지점에서 prop 업데이트에 대한 응답으로 DOM을 수동으로 업데이트하는 것이 중요하다는 것을 의미합니다. 더 이상 React가 DOM을 관리하지 못하게하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f30e9cf8ac0b76207bda3245cb2182efdc414b1f" translate="yes" xml:space="preserve">
          <source>Finally, we will implement a method called &lt;code&gt;tick()&lt;/code&gt; that the &lt;code&gt;Clock&lt;/code&gt; component will run every second.</source>
          <target state="translated">마지막으로 &lt;code&gt;Clock&lt;/code&gt; 구성 요소가 1 초마다 실행 하는 &lt;code&gt;tick()&lt;/code&gt; 이라는 메서드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ce6bdf360c9cdf4666af396e6a18cf67ced3bdb2" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll use it inside the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">마지막으로 &lt;code&gt;App&lt;/code&gt; 구성 요소 내에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0fb106579ba6a556d0a0faef0bd385b5a54b87e0" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;re ready to learn about &lt;a href=&quot;hooks-custom&quot;&gt;writing your own Hooks&lt;/a&gt;! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;hooks-custom&quot;&gt;나만의 후크 작성&lt;/a&gt; 에 대해 배울 준비가되었습니다 ! 사용자 정의 후크를 사용하면 React에서 제공 한 후크를 자체 추상화에 결합하고 다른 구성 요소간에 공통적 인 상태 저장 논리를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75a0e987111ecd887671fc8a3f5587a3940db9a" translate="yes" xml:space="preserve">
          <source>Find a common owner component (a single component above all the components that need the state in the hierarchy).</source>
          <target state="translated">공통 소유자 구성 요소 (계층 구조의 상태가 필요한 모든 구성 요소의 단일 구성 요소)를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="cd10529f86faad367b294935f883fa7a473c8344" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;test(testInstance)&lt;/code&gt; does not return &lt;code&gt;true&lt;/code&gt; for exactly one test instance, it will throw an error.</source>
          <target state="translated">&lt;code&gt;test(testInstance)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 단일 하위 테스트 인스턴스를 찾으십시오 . 경우 &lt;code&gt;test(testInstance)&lt;/code&gt; 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 정확히 하나의 테스트 예를 들어, 그것은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56ac958640059feca8470fa66a87c6d3058fbecd" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;props&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;props&lt;/code&gt;, it will throw an error.</source>
          <target state="translated">제공된 &lt;code&gt;props&lt;/code&gt; 으로 단일 자손 테스트 인스턴스를 찾으십시오 . 제공된 &lt;code&gt;props&lt;/code&gt; 가있는 테스트 인스턴스가 정확히 하나도 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6291a33bd325f2205732a5ed9112fb0250cc2b5f" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;type&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;type&lt;/code&gt;, it will throw an error.</source>
          <target state="translated">제공된 &lt;code&gt;type&lt;/code&gt; 의 단일 하위 테스트 인스턴스를 찾으십시오 . 제공된 &lt;code&gt;type&lt;/code&gt; 의 테스트 인스턴스가 정확히 하나도 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b9dd365ea82c943b75891a6b85a9d37f3912fb9" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;test(testInstance)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 하위 테스트 인스턴스를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="21b1b8ea5fee48f3e121adffde346749520e47d8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;props&lt;/code&gt; 모든 하위 테스트 인스턴스를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="d82fa4047ac4e7196ebe8d99bde1ec943590d7a8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;type&lt;/code&gt; 모든 하위 테스트 인스턴스를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="ba889b4c3d1075d33e079e5839e918035baac30a" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the class name matching &lt;code&gt;className&lt;/code&gt;.</source>
          <target state="translated">렌더링 된 트리에서 클래스 이름이 &lt;code&gt;className&lt;/code&gt; 과 일치하는 DOM 구성 요소 인 구성 요소의 모든 DOM 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4a2d40e5f01e49ec1f9ca6614adadd74d8e448f3" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the tag name matching &lt;code&gt;tagName&lt;/code&gt;.</source>
          <target state="translated">렌더링 된 트리에서 태그 이름이 &lt;code&gt;tagName&lt;/code&gt; 과 일치하는 DOM 구성 요소 인 구성 요소의 모든 DOM 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="139948e94d3c318e819b31e3e063cdea8779f65d" translate="yes" xml:space="preserve">
          <source>Finds all instances of components with type equal to &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">유형 구성 요소의 모든 인스턴스가 동일 찾습니다 &lt;code&gt;componentClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="002074b73eeeb01130c3e9603a19fd6ea3c3b0a9" translate="yes" xml:space="preserve">
          <source>Finish fetching</source>
          <target state="translated">가져 오기 완료</target>
        </trans-unit>
        <trans-unit id="5279683987b6110a5f734ea482017a9f1707bf60" translate="yes" xml:space="preserve">
          <source>Firefox Browser Extension</source>
          <target state="translated">Firefox 브라우저 확장</target>
        </trans-unit>
        <trans-unit id="f22dd4f6d06a701148f78aeafd7d59690258e6f2" translate="yes" xml:space="preserve">
          <source>First Examples</source>
          <target state="translated">첫 번째 예</target>
        </trans-unit>
        <trans-unit id="b31edf6c539183fae836c95a3e043736312850de" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s look at what Chosen does to the DOM.</source>
          <target state="translated">먼저 Chosen이 DOM에 대해 수행하는 작업을 살펴 ​​보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4734953a720148d9b4e3f52cf3651d1bbef61893" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s review how you transform lists in JavaScript.</source>
          <target state="translated">먼저 JavaScript에서 목록을 변환하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f571561a4179c80fd11057f8db1c01d30c7afe66" translate="yes" xml:space="preserve">
          <source>First, navigate to your project directory in the terminal. You will need to run the following command:</source>
          <target state="translated">먼저 터미널에서 프로젝트 디렉토리로 이동하십시오. 다음 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="69d50e931cf3ca82296d09451cd9e2a2c6a5f606" translate="yes" xml:space="preserve">
          <source>First, open the HTML page you want to edit. Add an empty &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tag to mark the spot where you want to display something with React. For example:</source>
          <target state="translated">먼저 편집하려는 HTML 페이지를 엽니 다. 빈 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 태그를 추가하여 React로 무언가를 표시하려는 지점을 표시하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbbb2b7c606daedd24bb97a26330b095e5c91a30" translate="yes" xml:space="preserve">
          <source>First, we will create an empty component with a &lt;code&gt;render()&lt;/code&gt; method where we return &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; wrapped in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">먼저, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 싸인 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 를 반환 하는 &lt;code&gt;render()&lt;/code&gt; 메서드 를 사용하여 빈 구성 요소를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="850899e6c789ecbc9390ccff1b8f1d62d2eb090c" translate="yes" xml:space="preserve">
          <source>First, we will extract &lt;code&gt;Avatar&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;Avatar&lt;/code&gt; 를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="dd17a20ab6e5091412cc2bc0981f871fb3aad8d5" translate="yes" xml:space="preserve">
          <source>First, we will replace &lt;code&gt;this.state.temperature&lt;/code&gt; with &lt;code&gt;this.props.temperature&lt;/code&gt; in the &lt;code&gt;TemperatureInput&lt;/code&gt; component. For now, let&amp;rsquo;s pretend &lt;code&gt;this.props.temperature&lt;/code&gt; already exists, although we will need to pass it from the &lt;code&gt;Calculator&lt;/code&gt; in the future:</source>
          <target state="translated">먼저 &lt;code&gt;TemperatureInput&lt;/code&gt; 구성 요소 에서 &lt;code&gt;this.state.temperature&lt;/code&gt; 를 &lt;code&gt;this.props.temperature&lt;/code&gt; 로 바꿉니다 . 지금은 &lt;code&gt;this.props.temperature&lt;/code&gt; 가 이미 존재한다고 가정 해 봅시다 .하지만 나중에 &lt;code&gt;Calculator&lt;/code&gt; 에서 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f38547d143eab30914dc1542d30d6ffa38489126" translate="yes" xml:space="preserve">
          <source>First, we will write two functions to convert from Celsius to Fahrenheit and back:</source>
          <target state="translated">먼저 섭씨에서 화씨로 변환하는 함수 두 가지를 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0546090bdf17503734b68ca5ca7f42c8f59803ba" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll define an error boundary component to use across our project:</source>
          <target state="translated">먼저 프로젝트 전체에서 사용할 오류 경계 구성 요소를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="78d1c98f23da83b26247d219f11d4dcf023bfb97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll extract this logic into a custom Hook called &lt;code&gt;useFriendStatus&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;useFriendStatus&lt;/code&gt; 논리를 useFriendStatus 라는 사용자 정의 후크로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="1d75bcb6ad1a92ca508ad7a4f4e1f23b6c2a443d" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll make sure that we&amp;rsquo;re actually using Concurrent Mode. We&amp;rsquo;ll talk more about &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt; later, but for now it&amp;rsquo;s sufficient to know that we need to use &lt;code&gt;ReactDOM.createRoot()&lt;/code&gt; rather than &lt;code&gt;ReactDOM.render()&lt;/code&gt; for this feature to work:</source>
          <target state="translated">먼저 실제로 동시 모드를 사용하고 있는지 확인합니다. 우리에 대해 더 얘기하자 &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;동시 모드를 채택&lt;/a&gt; 이후,하지만 지금 우리가 사용할 필요가 있음을 알고 충분한입니다 &lt;code&gt;ReactDOM.createRoot()&lt;/code&gt; 보다는 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 이 기능을 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="7995484b8387f581a4be55b38ff4d9e3aca31d06" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll try a version of our original &amp;ldquo;fetch in effect&amp;rdquo; example. We&amp;rsquo;ll modify it to pass an &lt;code&gt;id&lt;/code&gt; parameter from the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; props to &lt;code&gt;fetchUser(id)&lt;/code&gt; and &lt;code&gt;fetchPosts(id)&lt;/code&gt;:</source>
          <target state="translated">먼저, 원래의 &quot;페치 이펙트 (fetch in effect)&quot;예제 버전을 시도해 보겠습니다. &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; props 에서 &lt;code&gt;id&lt;/code&gt; 매개 변수 를 &lt;code&gt;fetchUser(id)&lt;/code&gt; 및 &lt;code&gt;fetchPosts(id)&lt;/code&gt; 로 전달하도록 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="74806b2e8c725d56528386985317d5d032f055a2" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s arrange our project structure like this. We&amp;rsquo;ll place all our source code in the &lt;code&gt;src&lt;/code&gt; directory.</source>
          <target state="translated">먼저 프로젝트 구조를 이와 같이 정리해 봅시다. 모든 소스 코드를 &lt;code&gt;src&lt;/code&gt; 디렉토리에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="e2ce5d47a8c1aa7433f3dabcacbd9eba1847b52a" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Editors</source>
          <target state="translated">흐름 문서 : 편집자</target>
        </trans-unit>
        <trans-unit id="8a935a1a622003f2b9a59950756441e7a987c0aa" translate="yes" xml:space="preserve">
          <source>Flow Documentation: React</source>
          <target state="translated">흐름 문서 : 반응</target>
        </trans-unit>
        <trans-unit id="388960a5ef923123e15f51a7c912a585a0d7bab9" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Type Annotations</source>
          <target state="translated">흐름 설명서 : 유형 주석</target>
        </trans-unit>
        <trans-unit id="3cb5e0b12f5cf50d3b0f98f6128b892d7e35d600" translate="yes" xml:space="preserve">
          <source>Flow does not require the &lt;code&gt;react&lt;/code&gt; preset, but they are often used together. Flow itself understands JSX syntax out of the box.</source>
          <target state="translated">흐름에는 &lt;code&gt;react&lt;/code&gt; 사전 설정이 필요하지 않지만 종종 함께 사용됩니다. Flow 자체는 기본적으로 JSX 구문을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="b011dafddca02cf4d31d7f3eed20fb2a60901be6" translate="yes" xml:space="preserve">
          <source>Flow extends the JavaScript language with a special syntax for type annotations. However, browsers aren&amp;rsquo;t aware of this syntax, so we need to make sure it doesn&amp;rsquo;t end up in the compiled JavaScript bundle that is sent to the browser.</source>
          <target state="translated">Flow는 형식 주석에 대한 특수 구문으로 JavaScript 언어를 확장합니다. 그러나 브라우저는이 구문을 인식하지 못하므로 브라우저로 전송되는 컴파일 된 JavaScript 번들로 끝나지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dd15cc47d7683e059370f427aad3fd5f6a94f39" translate="yes" xml:space="preserve">
          <source>Focus Control</source>
          <target state="translated">포커스 컨트롤</target>
        </trans-unit>
        <trans-unit id="81c6e47ced4689fc9b50ffb6c5d899c6c3458d6a" translate="yes" xml:space="preserve">
          <source>Focus Events</source>
          <target state="translated">포커스 이벤트</target>
        </trans-unit>
        <trans-unit id="186d8edb88541264714b7fdfd864c5d337ce64bf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MyComponent&lt;/code&gt;, the value of &lt;code&gt;props.foo&lt;/code&gt; will be &lt;code&gt;10&lt;/code&gt; because the expression &lt;code&gt;1 + 2 + 3 + 4&lt;/code&gt; gets evaluated.</source>
          <target state="translated">내용 &lt;code&gt;MyComponent&lt;/code&gt; 의 값 &lt;code&gt;props.foo&lt;/code&gt; 는 것 &lt;code&gt;10&lt;/code&gt; 발현하기 때문에 &lt;code&gt;1 + 2 + 3 + 4&lt;/code&gt; 평가 얻는다.</target>
        </trans-unit>
        <trans-unit id="d43a105c56e84bdfc291537517481c1e8fc3a3cd" translate="yes" xml:space="preserve">
          <source>For C1 and C3, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, so React had to go down to the leaves and check them. For C6 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, and since the rendered elements weren&amp;rsquo;t equivalent React had to update the DOM.</source>
          <target state="translated">C1 및 C3의 경우 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 하므로 React는 잎으로 내려 가서 확인해야했습니다. C6의 경우 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 했으며 렌더링 된 요소가 같지 않기 때문에 React는 DOM을 업데이트해야했습니다.</target>
        </trans-unit>
        <trans-unit id="a5d4978ec88fcf2eae32559987a0c7fe9031866b" translate="yes" xml:space="preserve">
          <source>For CPU-bound updates (such as creating DOM nodes and running component code), concurrency means that a more urgent update can &amp;ldquo;interrupt&amp;rdquo; rendering that has already started.</source>
          <target state="translated">CPU 바인딩 업데이트 (예 : DOM 노드 만들기 및 구성 요소 코드 실행)의 동시성은보다 긴급한 업데이트가 이미 시작된 렌더링을 &quot;중단&quot;할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="456da7f75c50e18b116caf077221012f7b10d367" translate="yes" xml:space="preserve">
          <source>For IO-bound updates (such as fetching code or data from the network), concurrency means that React can start rendering in memory even before all the data arrives, and skip showing jarring empty loading states.</source>
          <target state="translated">IO 바운드 업데이트 (예 : 네트워크에서 코드 또는 데이터 가져 오기)의 동시성은 모든 데이터가 도착하기 전에 React가 메모리에서 렌더링을 시작할 수 있고 빈로드 상태가 표시되는 것을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="52411992a5ea90e7a22ab937f331633f14633056" translate="yes" xml:space="preserve">
          <source>For Library Authors</source>
          <target state="translated">도서관 저자</target>
        </trans-unit>
        <trans-unit id="295506224e5dfd3bc5a2f5a949671a335a57d51c" translate="yes" xml:space="preserve">
          <source>For a complete setup example &lt;a href=&quot;https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0&quot;&gt;see this gist&lt;/a&gt;.</source>
          <target state="translated">전체 설정 예제 &lt;a href=&quot;https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0&quot;&gt;는이 요점을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="679fe92462c39504c9ff9773ae608eb7389ffc9e" translate="yes" xml:space="preserve">
          <source>For a more concrete example of these concepts, let&amp;rsquo;s write a minimal wrapper for the plugin &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen&lt;/a&gt;, which augments &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; inputs.</source>
          <target state="translated">이러한 개념에 대한보다 구체적인 예를 들어, 플러그인 &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen에&lt;/a&gt; 대한 최소 래퍼를 작성하여 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 입력 을 보강 합니다.</target>
        </trans-unit>
        <trans-unit id="e02416dec32f4ac14f5c635f846c95b0b1f3e149" translate="yes" xml:space="preserve">
          <source>For a more detailed walkthrough, check out &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;this article by Ben Schwarz&lt;/a&gt;.</source>
          <target state="translated">자세한 연습 &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;은 Ben Schwarz의이 기사를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6742712e3a4c00cde6cec63fd4e900f882182503" translate="yes" xml:space="preserve">
          <source>For components defined as classes, use &lt;code&gt;this.props.children&lt;/code&gt;:</source>
          <target state="translated">클래스로 정의 된 컴포넌트의 경우 &lt;code&gt;this.props.children&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="df0460aa967c08b3c0359b521985038ac48561d5" translate="yes" xml:space="preserve">
          <source>For each particular piece of changing data, there should be just one component that &amp;ldquo;owns&amp;rdquo; it in its state. Don&amp;rsquo;t try to synchronize states of two different components. Instead, &lt;a href=&quot;lifting-state-up&quot;&gt;lift it up&lt;/a&gt; to their closest shared ancestor, and pass it down as props to both of them.</source>
          <target state="translated">각각의 특정 변경 데이터에 대해 해당 상태에서 데이터를 &quot;소유&quot;하는 구성 요소는 하나만 있어야합니다. 서로 다른 두 구성 요소의 상태를 동기화하려고하지 마십시오. 대신, 가장 가까운 조상 &lt;a href=&quot;lifting-state-up&quot;&gt;까지 들어 올려&lt;/a&gt; 두 사람에게 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="647bc53c804dc25be5b4801130ef3922760422b8" translate="yes" xml:space="preserve">
          <source>For each piece of state in your application:</source>
          <target state="translated">응용 프로그램의 각 상태에 대해 :</target>
        </trans-unit>
        <trans-unit id="4657ab12168f0360582ae377c9a3fb4c69201085" translate="yes" xml:space="preserve">
          <source>For each test, we usually want to render our React tree to a DOM element that&amp;rsquo;s attached to &lt;code&gt;document&lt;/code&gt;. This is important so that it can receive DOM events. When the test ends, we want to &amp;ldquo;clean up&amp;rdquo; and unmount the tree from the &lt;code&gt;document&lt;/code&gt;.</source>
          <target state="translated">각 테스트마다 일반적으로 React 트리를 &lt;code&gt;document&lt;/code&gt; 에 첨부 된 DOM 요소로 렌더링하려고합니다 . DOM 이벤트를 수신 할 수 있도록하는 것이 중요합니다. 테스트가 끝나면 &quot;정리&quot;하고 &lt;code&gt;document&lt;/code&gt; 에서 트리를 마운트 해제하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="9d2f11c83d765d839676e4e232e576ddbe2a1a64" translate="yes" xml:space="preserve">
          <source>For example a custom Hook that returned a &lt;code&gt;Date&lt;/code&gt; value could avoid calling the &lt;code&gt;toDateString&lt;/code&gt; function unnecessarily by passing the following formatter:</source>
          <target state="translated">예를 들어, &lt;code&gt;Date&lt;/code&gt; 값 을 리턴 한 사용자 정의 후크 는 다음 형식 &lt;code&gt;toDateString&lt;/code&gt; 전달하여 불필요하게 toDateString 함수를 호출 하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6ccd00019fe7c93727e1ee7af34a30096debfa1c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;class&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; in JSX, and &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt;&lt;code&gt;tabIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 JSX에서 &lt;code&gt;class&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt; 이되고 &lt;code&gt;tabindex&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt; &lt;code&gt;tabIndex&lt;/code&gt; &lt;/a&gt; 가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="257bf267f4accf76b8a71c8a6fc907d879bb3b3b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; returns an empty string, and &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; returns &lt;code&gt;'50.396'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; 는 빈 문자열을 반환하고 &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; 는 &lt;code&gt;'50.396'&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="86da3811ff28fce969e656a6a27c26d72c389972" translate="yes" xml:space="preserve">
          <source>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</source>
          <target state="translated">예를 들어 Facebook Messenger는 사이드 바의 내용, 정보 패널, 대화 로그 및 메시지 입력을 별도의 오류 경계로 래핑합니다. 이러한 UI 영역 중 하나의 일부 구성 요소가 충돌하면 나머지 구성 요소는 대화식으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d8139b3a5725d0dbe39a1d636583f71febc457" translate="yes" xml:space="preserve">
          <source>For example, both of the imports are necessary in this code, even though &lt;code&gt;React&lt;/code&gt; and &lt;code&gt;CustomButton&lt;/code&gt; are not directly referenced from JavaScript:</source>
          <target state="translated">예를 들어 &lt;code&gt;React&lt;/code&gt; 및 &lt;code&gt;CustomButton&lt;/code&gt; 이 JavaScript에서 직접 참조되지 않더라도이 코드에서 두 가져 오기가 모두 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="390fb39992645b6398deff562b8f840081098a97" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Page&lt;/code&gt; component that passes a &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; prop several levels down so that deeply nested &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components can read it:</source>
          <target state="translated">예를 들어, 중첩 된 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소가 읽을 수 있도록 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;avatarSize&lt;/code&gt; prop를 여러 수준 아래로 전달 하는 &lt;code&gt;Page&lt;/code&gt; 구성 요소를 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="3a0f37544377fd4ba88f4814137f0c59e828e67d" translate="yes" xml:space="preserve">
          <source>For example, consider a filterable list like this:</source>
          <target state="translated">예를 들어 다음과 같이 필터링 가능한 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="672d122436eb70d444bbe9b6d5a7454eb80d94df" translate="yes" xml:space="preserve">
          <source>For example, consider the &lt;code&gt;useFriendStatus&lt;/code&gt; custom Hook described in &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;자신의 후크 만들기&amp;rdquo;에&lt;/a&gt; 설명 된 &lt;code&gt;useFriendStatus&lt;/code&gt; 사용자 정의 후크를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="translated">예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9050062cc798394f53d6e8b1ff9014a2612f33bb" translate="yes" xml:space="preserve">
          <source>For example, consider this &lt;code&gt;Comment&lt;/code&gt; component:</source>
          <target state="translated">예를 들어, 다음 &lt;code&gt;Comment&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="17c300f11b425a9fc05f0c1272d1583ab4603762" translate="yes" xml:space="preserve">
          <source>For example, continuing with our &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component from above, if &lt;code&gt;Mouse&lt;/code&gt; were to extend &lt;code&gt;React.PureComponent&lt;/code&gt; instead of &lt;code&gt;React.Component&lt;/code&gt;, our example would look like this:</source>
          <target state="translated">예를 들어, 위에서 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 컴포넌트를 계속해서 &lt;code&gt;Mouse&lt;/code&gt; 가 &lt;code&gt;React.PureComponent&lt;/code&gt; 대신 React.PureComponent 를 확장 &lt;code&gt;React.Component&lt;/code&gt; , 예제는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="20ed488706a8a3ad440cf53c3eca5d4c4ed1ad07" translate="yes" xml:space="preserve">
          <source>For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.</source>
          <target state="translated">예를 들어, 후크를 발표 할 때 실험 채널이 존재했다면 실험 채널이 후크에서 최신으로 제공되기 몇 주 전에 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="72386049d7fd0a4d1be43f2f6774c74af5948367" translate="yes" xml:space="preserve">
          <source>For example, if we enter 37 into the Celsius input, the state of the &lt;code&gt;Calculator&lt;/code&gt; component will be:</source>
          <target state="translated">예를 들어 Celsius 입력에 37을 입력하면 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소 의 상태 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9993ee38514320027480d338484992ca1feb5c6" translate="yes" xml:space="preserve">
          <source>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator. We might prefer to stay longer on the previous screen. Implementing this pattern has historically been difficult in React. Concurrent Mode offers a new set of tools to do that.</source>
          <target state="translated">예를 들어, 한 페이지에서 다른 페이지로 전환했는데 다음 화면의 코드 나 데이터가 아직로드되지 않은 경우로드 표시기가있는 빈 페이지가 즉시 표시되지 않으면 실망 할 수 있습니다. 이전 화면에서 더 오래 머무르기를 선호 할 수 있습니다. 이 패턴을 구현하는 것은 역사적으로 React에서 어려웠습니다. 동시 모드는이를위한 새로운 도구 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65295b13b97c2a6ed8a939287bfe094925fc31cc" translate="yes" xml:space="preserve">
          <source>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</source>
          <target state="translated">예를 들어, 이전 예제 로그를 제출할 때 이름을 로그로 만들려면 양식을 제어 된 구성 요소로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90b29303f730a5e659074ca0cb511ba946d5117" translate="yes" xml:space="preserve">
          <source>For example, if you &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract&lt;/a&gt; a &lt;code&gt;ListItem&lt;/code&gt; component, you should keep the key on the &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; elements in the array rather than on the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element in the &lt;code&gt;ListItem&lt;/code&gt; itself.</source>
          <target state="translated">예를 들어 &lt;code&gt;ListItem&lt;/code&gt; 구성 요소 를 &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;추출&lt;/a&gt; 하는 경우 &lt;code&gt;ListItem&lt;/code&gt; 자체 의 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소가 아닌 배열 의 &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; 요소에 키를 보관해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4f472461a434d14b304ba318506b6c2b7dd4f729" translate="yes" xml:space="preserve">
          <source>For example, if you have the following component:</source>
          <target state="translated">예를 들어 다음 구성 요소가있는 경우</target>
        </trans-unit>
        <trans-unit id="cf9af7a91451dd9ae9a9996fb7f391bbc16ec6a4" translate="yes" xml:space="preserve">
          <source>For example, instead of exposing &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; methods on a &lt;code&gt;Dialog&lt;/code&gt; component, pass an &lt;code&gt;isOpen&lt;/code&gt; prop to it.</source>
          <target state="translated">예를 들어 &lt;code&gt;Dialog&lt;/code&gt; 구성 요소 에 &lt;code&gt;open()&lt;/code&gt; 및 &lt;code&gt;close()&lt;/code&gt; 메서드를 노출시키는 대신 &lt;code&gt;isOpen&lt;/code&gt; 소품을 전달 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
