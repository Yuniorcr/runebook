<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="django_rest_framework">
    <body>
      <group id="django_rest_framework">
        <trans-unit id="bb2ba8253372da481cdb5b523c720811bc3cfe9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;action&lt;/code&gt; decorator will route &lt;code&gt;GET&lt;/code&gt; requests by default, but may also accept other HTTP methods by setting the &lt;code&gt;methods&lt;/code&gt; argument. For example:</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; 장식의 의지 경로가 &lt;code&gt;GET&lt;/code&gt; 기본적으로 요청을뿐만 아니라 설정하여 다른 HTTP 방법을 수용 할 수있다 &lt;code&gt;methods&lt;/code&gt; 인수를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe94ddb9e07b3a59d9518c0de7cb7189e76f1b8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allow_null&lt;/code&gt; option is also available for string fields, although its usage is discouraged in favor of &lt;code&gt;allow_blank&lt;/code&gt;. It is valid to set both &lt;code&gt;allow_blank=True&lt;/code&gt; and &lt;code&gt;allow_null=True&lt;/code&gt;, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.</source>
          <target state="translated">&lt;code&gt;allow_null&lt;/code&gt; 의 그것의 사용을 찬성 권장하지 않습니다 있지만 옵션은 또한 문자열 필드에 사용할 수 &lt;code&gt;allow_blank&lt;/code&gt; . &lt;code&gt;allow_blank=True&lt;/code&gt; 및 &lt;code&gt;allow_null=True&lt;/code&gt; 를 모두 설정하는 것이 유효 하지만 그렇게하면 문자열 표현에 허용되는 두 가지 유형의 빈 값이 허용되어 데이터 불일치와 미묘한 응용 프로그램 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa10cfb1ebc829eb9ae522653f596edbb31925af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;api_settings&lt;/code&gt; object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.</source>
          <target state="translated">&lt;code&gt;api_settings&lt;/code&gt; 의 객체는 사용자 정의 설정을 확인하고, 그렇지 않으면 기본값으로 다시 떨어질 것이다. 문자열 가져 오기 경로를 사용하여 클래스를 참조하는 모든 설정은 문자열 리터럴 대신 참조 된 클래스를 자동으로 가져 와서 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc6ffc9103f332ace78588312aa122ddd4c2b5fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method of our serializer will now be passed an additional &lt;code&gt;'owner'&lt;/code&gt; field, along with the validated data from the request.</source>
          <target state="translated">시리얼 라이저 의 &lt;code&gt;create()&lt;/code&gt; 메소드 는 요청의 검증 된 데이터와 함께 추가 &lt;code&gt;'owner'&lt;/code&gt; 필드에 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="0ccbe2d13ab9cc8ce8c37baf1fa10717b9b3b358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;credentials&lt;/code&gt; method can be used to set headers that will then be included on all subsequent requests by the test client.</source>
          <target state="translated">&lt;code&gt;credentials&lt;/code&gt; 방법은 다음 테스트 클라이언트의 모든 후속 요청에 포함됩니다 세트 헤더로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c76fefea74e446b57feb50cd06a10a39a31612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;credentials&lt;/code&gt; method is appropriate for testing APIs that require authentication headers, such as basic authentication, OAuth1a and OAuth2 authentication, and simple token authentication schemes.</source>
          <target state="translated">&lt;code&gt;credentials&lt;/code&gt; 방법은 기본 인증 OAuth1a 및 OAuth2를 인증하고 인증 토큰 간단한 방식으로서 인증 헤더를 필요로하는 API를 테스트하는 데에 적합하다.</target>
        </trans-unit>
        <trans-unit id="bd5357cb06549ac9629548377fd7c6490009901c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;curl&lt;/code&gt; command line tool may be useful for testing token authenticated APIs. For example:</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 명령 줄 도구는 인증 API를 토큰을 테스트하기 위해 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28a2965650936800f9c20b7d80b91a7768ea61e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; argument passed to this method will normally be the value of &lt;code&gt;request.data&lt;/code&gt;, so the datatype it provides will depend on the parser classes you have configured for your API.</source>
          <target state="translated">이 메소드에 전달 된 &lt;code&gt;data&lt;/code&gt; 인수는 일반적으로 &lt;code&gt;request.data&lt;/code&gt; 의 값이 되므로 제공하는 데이터 유형은 API에 대해 구성한 구문 분석기 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0760dd58c48972028ba31fc89aa0974ce31a2bc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;default&lt;/code&gt; is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 부분 업데이트 작업을 수행하는 동안 적용되지 않습니다. 부분 업데이트의 경우 들어오는 데이터에 제공된 필드 만 유효성 검사 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b9a2a6479705a9a093d3f2b040db5063208a4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;depth&lt;/code&gt; option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.</source>
          <target state="translated">&lt;code&gt;depth&lt;/code&gt; 옵션은 평면 표현에 복귀하기 전에 통과해야 관계의 깊이를 나타내는 정수 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6d240054d0038729d91fe368e741e2fa1715f69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detail&lt;/code&gt; argument is mandatory, not optional.</source>
          <target state="translated">&lt;code&gt;detail&lt;/code&gt; 인수는 선택 사항, 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2e32df6c5baf5eb3b4db997a8c637507370180a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detail&lt;/code&gt; argument may be a list or dictionary of error details, and may also be a nested data structure.</source>
          <target state="translated">&lt;code&gt;detail&lt;/code&gt; 인수 오류 정보의리스트 또는 사전 일 수도 있고, 또한 중첩 된 데이터 구조 일 수있다.</target>
        </trans-unit>
        <trans-unit id="426fbd28030fadc7c1b7ff38bf6d6001ac963ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_paginated_response&lt;/code&gt; method is passed the serialized page data and should return a &lt;code&gt;Response&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;get_paginated_response&lt;/code&gt; 의 방법은 직렬화 페이지 데이터를 전달하고 반환해야 &lt;code&gt;Response&lt;/code&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="807f1c304d585728d4eeacfc942f1ce08d3fe535" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_schema_view()&lt;/code&gt; helper takes the following keyword arguments:</source>
          <target state="translated">&lt;code&gt;get_schema_view()&lt;/code&gt; 도우미는 다음과 같은 키워드 인수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="7eae8244d267633646214d199e878334d1f535b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_url&lt;/code&gt; method is used to map the object instance to its URL representation.</source>
          <target state="translated">&lt;code&gt;get_url&lt;/code&gt; 방법은 URL 표현으로 개체 인스턴스를 매핑하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8dbd19d588fd73d6c94e7cabfcd26e04a1683e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonp&lt;/code&gt; approach is essentially a browser hack, and is &lt;a href=&quot;https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use&quot;&gt;only appropriate for globally readable API endpoints&lt;/a&gt;, where &lt;code&gt;GET&lt;/code&gt; requests are unauthenticated and do not require any user permissions.</source>
          <target state="translated">&lt;code&gt;jsonp&lt;/code&gt; 접근 방식은 기본적으로 브라우저 해킹하고, &lt;a href=&quot;https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use&quot;&gt;전역으로 만 읽을 수있는 API 엔드 포인트에 대한 적절한&lt;/a&gt; , &lt;code&gt;GET&lt;/code&gt; 의 요청이 인증되지 않은 있고 모든 사용자 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0fd2eea552e7fcf65fe6c8300a8f0cbf78625c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;login&lt;/code&gt; method functions exactly as it does with Django's regular &lt;code&gt;Client&lt;/code&gt; class. This allows you to authenticate requests against any views which include &lt;code&gt;SessionAuthentication&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;login&lt;/code&gt; 방법 기능은 장고의 정기적으로 수행 정확하게 &lt;code&gt;Client&lt;/code&gt; 클래스입니다. 이를 통해 &lt;code&gt;SessionAuthentication&lt;/code&gt; 을 포함하는 모든 뷰에 대해 요청을 인증 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f33f9f466d3205d415f05d156db64f92eaccd1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;login&lt;/code&gt; method is appropriate for testing APIs that use session authentication, for example web sites which include AJAX interaction with the API.</source>
          <target state="translated">&lt;code&gt;login&lt;/code&gt; 방법은 API를 테스트하기위한 적절한 그 API와 AJAX 상호 작용을 포함 예를 들어 웹 사이트에 대한 사용 세션 인증.</target>
        </trans-unit>
        <trans-unit id="683db7f0c89d8b1d53240c38cf0831238b947fed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nested_depth&lt;/code&gt; will be the value of the &lt;code&gt;depth&lt;/code&gt; option, minus one.</source>
          <target state="translated">&lt;code&gt;nested_depth&lt;/code&gt; 은 의 값이됩니다 &lt;code&gt;depth&lt;/code&gt; 옵션을 뺀.</target>
        </trans-unit>
        <trans-unit id="ba002dda331b9622d0f730340c8d487b010c691e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obtain_auth_token&lt;/code&gt; view will return a JSON response when valid &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; fields are POSTed to the view using form data or JSON:</source>
          <target state="translated">&lt;code&gt;obtain_auth_token&lt;/code&gt; 유효한 경우보기는 JSON 응답을 반환 &lt;code&gt;username&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 필드가 폼 데이터 또는 JSON을 사용하여 뷰에 게시됩니다 :</target>
        </trans-unit>
        <trans-unit id="9c453b530b1b8a9bbb49876dab8584c0e59be5d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordering&lt;/code&gt; attribute may be either a string or a list/tuple of strings.</source>
          <target state="translated">&lt;code&gt;ordering&lt;/code&gt; 속성은 문자열이나 문자열 목록 / 튜플 중 하나가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b75223e2561a8d2977bd9f94a3149a52a6f2c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paginate_queryset&lt;/code&gt; method is passed the initial queryset and should return an iterable object that contains only the data in the requested page.</source>
          <target state="translated">&lt;code&gt;paginate_queryset&lt;/code&gt; 에 있어서 초기의 검색어를 전달하고, 요청 된 페이지의 데이터만을 포함하는 반복 가능한 객체를 반환한다.</target>
        </trans-unit>
        <trans-unit id="cff47d33ce9405fa7d9b302e1ab518cd757caac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryset&lt;/code&gt; argument is only ever required for &lt;em&gt;writable&lt;/em&gt; relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.</source>
          <target state="translated">&lt;code&gt;queryset&lt;/code&gt; 인수는 오직 필요 &lt;em&gt;쓰기&lt;/em&gt; 가 모델 인스턴스로 프리미티브 사용자 입력에서지도 모델 인스턴스 검색을 수행하기 위해 사용되는 경우에 관계 필드.</target>
        </trans-unit>
        <trans-unit id="c8b1225689c08c18a7d006312df399123618c01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rate&lt;/code&gt; property on the class, which may be provided by overriding &lt;code&gt;AnonRateThrottle&lt;/code&gt; and setting the property.</source>
          <target state="translated">클래스 의 &lt;code&gt;rate&lt;/code&gt; 속성은 &lt;code&gt;AnonRateThrottle&lt;/code&gt; 을 재정의 하고 속성을 설정하여 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03ff7361e4ff42dc599c9c2b61cd8cf8429a63de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rate&lt;/code&gt; property on the class, which may be provided by overriding &lt;code&gt;UserRateThrottle&lt;/code&gt; and setting the property.</source>
          <target state="translated">클래스 의 &lt;code&gt;rate&lt;/code&gt; 속성은 &lt;code&gt;UserRateThrottle&lt;/code&gt; 을 재정의 하고 속성을 설정하여 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d35c83b61175e6d1cf32cdf8895850e64e0f376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relation_info&lt;/code&gt; argument is a named tuple, that contains &lt;code&gt;model_field&lt;/code&gt;, &lt;code&gt;related_model&lt;/code&gt;, &lt;code&gt;to_many&lt;/code&gt; and &lt;code&gt;has_through_model&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;relation_info&lt;/code&gt; 의 인수는 포함 명명 된 튜플이다 &lt;code&gt;model_field&lt;/code&gt; , &lt;code&gt;related_model&lt;/code&gt; , &lt;code&gt;to_many&lt;/code&gt; 및 &lt;code&gt;has_through_model&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="28d3b266e7cde053f1bbe0628130131a2b312e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request.auth&lt;/code&gt; property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.</source>
          <target state="translated">&lt;code&gt;request.auth&lt;/code&gt; 의 속성은, 예를 들어,이 요청은 서명되었음을 인증 토큰을 나타내는 데 사용될 수 있고, 추가 인증 정보를 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="21315bc42b16d2db2c32944757de09b59c793cf3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request.user&lt;/code&gt; property will typically be set to an instance of the &lt;code&gt;contrib.auth&lt;/code&gt; package's &lt;code&gt;User&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;request.user&lt;/code&gt; 의 속성은 보통의 인스턴스로 설정됩니다 &lt;code&gt;contrib.auth&lt;/code&gt; 의 패키지의 &lt;code&gt;User&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b3f84a6d3c7fb65c7b117087afd5922399b23293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; argument is optional, and may be used if you want to apply per-user permissions to the resulting schema generation.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 인수는 선택 사항입니다, 당신은 결과 스키마 생성에 사용자 별 권한을 적용 할 경우에 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="407ca1b40cc08d0bfd8fc6cce76814e60c616a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reverse&lt;/code&gt; function included by REST framework ties in with the versioning scheme. You need to make sure to include the current &lt;code&gt;request&lt;/code&gt; as a keyword argument, like so.</source>
          <target state="translated">&lt;code&gt;reverse&lt;/code&gt; 버전 관리 체계와의 REST 프레임 워크의 관계에 의해 포함 기능. 현재 &lt;code&gt;request&lt;/code&gt; 을 키워드 인수로 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="a93606fd60b9f66d81d386887b2cdcbbc8ad3622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_parser()&lt;/code&gt; method should return one of the parser instances from the list of available parsers, or &lt;code&gt;None&lt;/code&gt; if none of the parsers can handle the incoming request.</source>
          <target state="translated">&lt;code&gt;select_parser()&lt;/code&gt; 메소드는 사용할 수 파서의 목록 또는에서 파서 인스턴스 중 하나를 반환해야 &lt;code&gt;None&lt;/code&gt; 파서 아무도 들어오는 요청을 처리 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="a2dee07141def165a235de8ef5ee468828a21785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_renderer()&lt;/code&gt; method should return a two-tuple of (renderer instance, media type), or raise a &lt;code&gt;NotAcceptable&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;select_renderer()&lt;/code&gt; 메소드는 두 튜플 (렌더러 경우, 용지 종류)에 돌아가거나 인상한다 &lt;code&gt;NotAcceptable&lt;/code&gt; 예외.</target>
        </trans-unit>
        <trans-unit id="8f2ea87993cb5f4919ecdf09fbcc2d7692f80532" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template_name&lt;/code&gt;, if supplied. Only required if &lt;code&gt;HTMLRenderer&lt;/code&gt; or some other custom template renderer is the accepted renderer for the response.</source>
          <target state="translated">&lt;code&gt;template_name&lt;/code&gt; , 경우는 공급했다. &lt;code&gt;HTMLRenderer&lt;/code&gt; 또는 다른 사용자 정의 템플릿 렌더러가 응답에 허용되는 렌더러 인 경우에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a7519bd9dc1c2319be56914b1d1d7e88e09ba432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_internal_value()&lt;/code&gt; method is called to restore a primitive datatype into its internal python representation. This method should raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt; if the data is invalid.</source>
          <target state="translated">&lt;code&gt;to_internal_value()&lt;/code&gt; 메소드는 내부 파이썬 표현으로 원시적 인 데이터 형식을 복원하기 위해 호출된다. 이 메소드는 데이터가 유효하지 않은 경우 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 를 발생 시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="1282914ef13f3c8bcd21a56935abb4023f9dc407" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;url_name&lt;/code&gt; argument for &lt;code&gt;.reverse_action()&lt;/code&gt; should match the same argument to the &lt;code&gt;@action&lt;/code&gt; decorator. Additionally, this method can be used to reverse the default actions, such as &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.reverse_action()&lt;/code&gt; 의 &lt;code&gt;url_name&lt;/code&gt; 인수 는 &lt;code&gt;@action&lt;/code&gt; 데코레이터 와 동일한 인수와 일치해야합니다 . 또한이 메소드를 사용하여 &lt;code&gt;list&lt;/code&gt; 및 &lt;code&gt;create&lt;/code&gt; 와 같은 기본 조치를 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05d5353de5e5d97a9d0cf23f1806e28625d3d683" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;validated_data&lt;/code&gt; for these fields will contain a &lt;code&gt;datetime.timedelta&lt;/code&gt; instance. The representation is a string following this format &lt;code&gt;'[DD] [HH:[MM:]]ss[.uuuuuu]'&lt;/code&gt;.</source>
          <target state="translated">이러한 필드 의 &lt;code&gt;validated_data&lt;/code&gt; 에는 &lt;code&gt;datetime.timedelta&lt;/code&gt; 인스턴스 가 포함됩니다 . 이 형식은 &lt;code&gt;'[DD] [HH:[MM:]]ss[.uuuuuu]'&lt;/code&gt; 형식을 따르는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="a6fe6bdf600c7d842ac214a0f061a7588288a216" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;base class&lt;/strong&gt; for all exceptions raised inside an &lt;code&gt;APIView&lt;/code&gt; class or &lt;code&gt;@api_view&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 또는 &lt;code&gt;@api_view&lt;/code&gt; 내에서 발생한 모든 예외 의 &lt;strong&gt;기본 클래스&lt;/strong&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="088111972068cc437cece35c3216c2fbc1a0b622" translate="yes" xml:space="preserve">
          <source>The CoreAPIClient allows you to interact with your API using the Python &lt;code&gt;coreapi&lt;/code&gt; client library.</source>
          <target state="translated">CoreAPIClient를 사용하면 Python &lt;code&gt;coreapi&lt;/code&gt; 클라이언트 라이브러리를 사용하여 API와 상호 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0da0a58d4bb396692390cb410d8e95cb384defae" translate="yes" xml:space="preserve">
          <source>The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.</source>
          <target state="translated">ModelSerializer 클래스는 serializer를 인스턴스화 할 때 serializer 필드가 자동으로 결정되는 방식을 변경하기 위해 재정의 할 수있는 API도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7294fa80be8ab014805b085318511d10cc3db402" translate="yes" xml:space="preserve">
          <source>The REST framework package only includes a single metadata class implementation, named &lt;code&gt;SimpleMetadata&lt;/code&gt;. If you want to use an alternative style you'll need to implement a custom metadata class.</source>
          <target state="translated">REST 프레임 워크 패키지에는 &lt;code&gt;SimpleMetadata&lt;/code&gt; 라는 단일 메타 데이터 클래스 구현 만 포함됩니다 . 다른 스타일을 사용하려면 사용자 지정 메타 데이터 클래스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf67be798310de83ae57c7ee590edd418b2fb29a" translate="yes" xml:space="preserve">
          <source>The TemplateHTMLRenderer will create a &lt;code&gt;RequestContext&lt;/code&gt;, using the &lt;code&gt;response.data&lt;/code&gt; as the context dict, and determine a template name to use to render the context.</source>
          <target state="translated">TemplateHTMLRenderer는 &lt;code&gt;response.data&lt;/code&gt; 를 컨텍스트 dict로 사용하여 &lt;code&gt;RequestContext&lt;/code&gt; 를 작성 하고 컨텍스트를 렌더링하는 데 사용할 템플리트 이름을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0dc9772f355b69c7a9ffb76d15651433699bf58f" translate="yes" xml:space="preserve">
          <source>The URLs for custom actions by default depend on the method name itself. If you want to change the way url should be constructed, you can include &lt;code&gt;url_path&lt;/code&gt; as a decorator keyword argument.</source>
          <target state="translated">기본적으로 사용자 정의 조치의 URL은 메소드 이름 자체에 따라 다릅니다. url을 구성하는 방법을 변경하려면 &lt;code&gt;url_path&lt;/code&gt; 를 데코레이터 키워드 인수로 포함 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca9ced2c984e8306498e633aa0928011fcb8602e" translate="yes" xml:space="preserve">
          <source>The above example would now generate the following URL pattern:</source>
          <target state="translated">위의 예는 이제 다음 URL 패턴을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c5f8fefa22ddfbb3f5d0affebd6b186967d1464f" translate="yes" xml:space="preserve">
          <source>The above function will apply any URL transformations appropriate to the request version. For example:</source>
          <target state="translated">위 함수는 요청 버전에 적합한 URL 변환을 적용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b77364d40e6e08aa7335dc58cce54d12eac35fde" translate="yes" xml:space="preserve">
          <source>The actions provided by the &lt;code&gt;ModelViewSet&lt;/code&gt; class are &lt;code&gt;.list()&lt;/code&gt;, &lt;code&gt;.retrieve()&lt;/code&gt;, &lt;code&gt;.create()&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, &lt;code&gt;.partial_update()&lt;/code&gt;, and &lt;code&gt;.destroy()&lt;/code&gt;.</source>
          <target state="translated">에 의해 제공하는 행위 &lt;code&gt;ModelViewSet&lt;/code&gt; 의 클래스는 &lt;code&gt;.list()&lt;/code&gt; , &lt;code&gt;.retrieve()&lt;/code&gt; , &lt;code&gt;.create()&lt;/code&gt; , &lt;code&gt;.update()&lt;/code&gt; , &lt;code&gt;.partial_update()&lt;/code&gt; , 및 &lt;code&gt;.destroy()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="107b779d427af36930ef96bece2d70a2b42c4908" translate="yes" xml:space="preserve">
          <source>The advantages of doing so are:</source>
          <target state="translated">그렇게하는 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9bdce6fc64cd1682513409f8641899c129840ee" translate="yes" xml:space="preserve">
          <source>The allowed request rate is determined by the &lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; setting using a key from the request &quot;scope&quot;.</source>
          <target state="translated">허용 된 요청 비율은 요청 &quot;scope&quot;의 키를 사용하여 &lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; 설정에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="44516572c93855f8534456d7bf2f71b5c52ce346" translate="yes" xml:space="preserve">
          <source>The allowed request rate is determined from one of the following (in order of preference).</source>
          <target state="translated">허용 된 요청 비율은 다음 중 하나에서 우선 순위에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ca715f2ba76cd9f0203983ef1123bef75f9dfdaf" translate="yes" xml:space="preserve">
          <source>The arguments passed to &lt;code&gt;.parse()&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;.parse()&lt;/code&gt; 전달 된 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b8d05eaf468a247cb98f6c2df35192f92313d1c" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &lt;code&gt;.render()&lt;/code&gt; method are:</source>
          <target state="translated">&lt;code&gt;.render()&lt;/code&gt; 메소드에 전달 된 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd862556538d60ba5a58dd4cf0aad3590f948c5f" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;Route&lt;/code&gt; named tuple are:</source>
          <target state="translated">받는 인수 &lt;code&gt;Route&lt;/code&gt; 라는 이름의 튜플은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="ae979cc26860b6a79d0f55eb2ee22dacc3a26167" translate="yes" xml:space="preserve">
          <source>The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set &lt;code&gt;request.user&lt;/code&gt; and &lt;code&gt;request.auth&lt;/code&gt; using the return value of the first class that successfully authenticates.</source>
          <target state="translated">인증 체계는 항상 클래스 목록으로 정의됩니다. REST 프레임 워크는 목록의 각 클래스로 인증을 시도 하고 성공적으로 인증 된 첫 번째 클래스의 리턴 값을 사용하여 &lt;code&gt;request.user&lt;/code&gt; 및 &lt;code&gt;request.auth&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="8bfed02ead6c0e427e51fad30af836a2bbdc5501" translate="yes" xml:space="preserve">
          <source>The automatic &lt;code&gt;view_name&lt;/code&gt; generation uses a pattern like &lt;code&gt;%(model_name)-detail&lt;/code&gt;. Unless your models names actually clash you may be better off &lt;strong&gt;not&lt;/strong&gt; namespacing your Django REST Framework views when using hyperlinked serializers.</source>
          <target state="translated">자동 &lt;code&gt;view_name&lt;/code&gt; 생성은 &lt;code&gt;%(model_name)-detail&lt;/code&gt; 과 같은 패턴을 사용합니다 . 당신의 모델 이름이 실제로 충돌하지 않는 한 당신은 더 좋을 수 &lt;strong&gt;없는&lt;/strong&gt; 하이퍼 링크 시리얼 라이저를 사용할 때 장고 REST 프레임 워크 뷰의 네임.</target>
        </trans-unit>
        <trans-unit id="cdafde8cdd46fd51b8820663771e98988ff344e7" translate="yes" xml:space="preserve">
          <source>The available attributes and methods are:</source>
          <target state="translated">사용 가능한 속성 및 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="441cd6d7f19bff768ad6a7727fd5da76fcb1161e" translate="yes" xml:space="preserve">
          <source>The available decorators are:</source>
          <target state="translated">사용 가능한 데코레이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce540cf8f0081cd0c0fa5aef014a1b4fa6c8bbff" translate="yes" xml:space="preserve">
          <source>The base class provides the core functionality, and the mixin classes provide the &lt;code&gt;.list()&lt;/code&gt; and &lt;code&gt;.create()&lt;/code&gt; actions. We're then explicitly binding the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;post&lt;/code&gt; methods to the appropriate actions. Simple enough stuff so far.</source>
          <target state="translated">기본 클래스는 핵심 기능을 제공하고 mixin 클래스는 &lt;code&gt;.list()&lt;/code&gt; 및 &lt;code&gt;.create()&lt;/code&gt; 작업을 제공합니다. 그런 다음 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;post&lt;/code&gt; 메소드를 적절한 조치에 명시 적으로 바인딩합니다 . 지금까지 간단합니다.</target>
        </trans-unit>
        <trans-unit id="eeeb1f6555da07879aba2d40591530d762931cd7" translate="yes" xml:space="preserve">
          <source>The basic process of content negotiation involves examining the request's &lt;code&gt;Accept&lt;/code&gt; header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL &lt;code&gt;http://example.com/api/users_count.json&lt;/code&gt; might be an endpoint that always returns JSON data.</source>
          <target state="translated">컨텐츠 협상의 기본 프로세스 에는 응답의 예상 미디어 유형을 판별하기 위해 요청의 &lt;code&gt;Accept&lt;/code&gt; 헤더를 검사하는 작업이 포함됩니다 . 선택적으로 URL의 형식 접미사를 사용하여 특정 표현을 명시 적으로 요청할 수 있습니다. 예를 들어 URL &lt;code&gt;http://example.com/api/users_count.json&lt;/code&gt; 은 항상 JSON 데이터를 반환하는 엔드 포인트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e685653f07d88422c318f594cb2f17dd8cf599e4" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;__str__&lt;/code&gt; method of the model will be used to generate string representations of the objects used to populate the &lt;code&gt;choices&lt;/code&gt; property. These choices are used to populate select HTML inputs in the browsable API.</source>
          <target state="translated">모델 의 내장 &lt;code&gt;__str__&lt;/code&gt; 메소드는 &lt;code&gt;choices&lt;/code&gt; 속성 을 채우는 데 사용되는 객체의 문자열 표현을 생성하는 데 사용됩니다 . 이러한 선택 사항은 찾아보기 가능한 API에서 선택된 HTML 입력을 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dec317f596193dd3b15018a637ee96dcfcbb9d8c" translate="yes" xml:space="preserve">
          <source>The built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.</source>
          <target state="translated">내장 스타일은 현재 응답 내용의 일부로 포함 된 링크를 사용합니다. 이 스타일은 찾아보기 가능한 API를 사용할 때 더 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1fe0ab0fed8a3f6af4aa6e41e46fbeb60c9c33" translate="yes" xml:space="preserve">
          <source>The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on a uniform interface between components.</source>
          <target state="translated">REST 아키텍처 스타일을 다른 네트워크 기반 스타일과 구별하는 핵심 기능은 구성 요소 간 균일 한 인터페이스를 강조하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8766a199912305cec3e1d6adee40b91dae64bdbb" translate="yes" xml:space="preserve">
          <source>The class that should be used to initialize &lt;code&gt;request.auth&lt;/code&gt; for unauthenticated requests.</source>
          <target state="translated">인증되지 않은 요청에 대해 &lt;code&gt;request.auth&lt;/code&gt; 를 초기화하는 데 사용해야하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2bbf64bbff70029442ad58a7fc1ddd0ce8d7f58d" translate="yes" xml:space="preserve">
          <source>The class that should be used to initialize &lt;code&gt;request.user&lt;/code&gt; for unauthenticated requests. (If removing authentication entirely, e.g. by removing &lt;code&gt;django.contrib.auth&lt;/code&gt; from &lt;code&gt;INSTALLED_APPS&lt;/code&gt;, set &lt;code&gt;UNAUTHENTICATED_USER&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.)</source>
          <target state="translated">인증되지 않은 요청에 대해 &lt;code&gt;request.user&lt;/code&gt; 를 초기화하는 데 사용해야하는 클래스입니다 . (예 : &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 에서 &lt;code&gt;django.contrib.auth&lt;/code&gt; 를 제거하여 인증을 완전히 제거하는 경우 &lt;code&gt;UNAUTHENTICATED_USER&lt;/code&gt; 를 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .)</target>
        </trans-unit>
        <trans-unit id="97766ac811ff1b9081bbcccea88dd34b5cb73fe2" translate="yes" xml:space="preserve">
          <source>The client may additionally include an &lt;code&gt;'indent'&lt;/code&gt; media type parameter, in which case the returned &lt;code&gt;JSON&lt;/code&gt; will be indented. For example &lt;code&gt;Accept: application/json; indent=4&lt;/code&gt;.</source>
          <target state="translated">클라이언트는 &lt;code&gt;'indent'&lt;/code&gt; 미디어 유형 매개 변수를 추가로 포함 할 수 있으며 ,이 경우 반환 된 &lt;code&gt;JSON&lt;/code&gt; 이 들여 쓰기됩니다. 예를 들어 &lt;code&gt;Accept: application/json; indent=4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="604e1660814761c69fda20ea43fe44a42ad8e98c" translate="yes" xml:space="preserve">
          <source>The client may also specify reverse orderings by prefixing the field name with '-', like so:</source>
          <target state="translated">클라이언트는 다음과 같이 필드 이름 앞에 '-'를 붙여 역순을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70761aed14607fc78d2e2cc54bbdefb35fd836a6" translate="yes" xml:space="preserve">
          <source>The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as &lt;code&gt;context['view']&lt;/code&gt;.</source>
          <target state="translated">context 인수는 기본 처리기에서 사용되지 않지만 예외 처리기에서 현재 처리중인보기와 같은 추가 정보가 필요한 경우 유용합니다.이 정보는 &lt;code&gt;context['view']&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a998ebf79071600f0f37304f9e6ac4c2030162d" translate="yes" xml:space="preserve">
          <source>The context dictionary can be used within any serializer field logic, such as a custom &lt;code&gt;.to_representation()&lt;/code&gt; method, by accessing the &lt;code&gt;self.context&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;self.context&lt;/code&gt; 속성 에 액세스하여 사용자 정의 &lt;code&gt;.to_representation()&lt;/code&gt; 메소드 와 같은 직렬 변환기 필드 로직 내에서 컨텍스트 사전을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fd888e5a7dd1d91f9bc44a85780fa7cd2e1ccaf" translate="yes" xml:space="preserve">
          <source>The core of this functionality is the &lt;code&gt;api_view&lt;/code&gt; decorator, which takes a list of HTTP methods that your view should respond to. For example, this is how you would write a very simple view that just manually returns some data:</source>
          <target state="translated">이 기능의 핵심은 &lt;code&gt;api_view&lt;/code&gt; 데코레이터로, 뷰가 응답해야하는 HTTP 메소드 목록을 가져옵니다. 예를 들어 다음은 데이터를 수동으로 반환하는 매우 간단한 뷰를 작성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="06db57df28dc62ed5834577e3c68e4aabf518ad3" translate="yes" xml:space="preserve">
          <source>The create/retrieve/update/delete operations that we've been using so far are going to be pretty similar for any model-backed API views we create. Those bits of common behaviour are implemented in REST framework's mixin classes.</source>
          <target state="translated">지금까지 사용했던 생성 / 검색 / 업데이트 / 삭제 작업은 생성 한 모델 지원 API 뷰와 매우 유사합니다. 이러한 일반적인 동작은 REST 프레임 워크의 믹스 인 클래스에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3c78cc999a20968d9d59acd7068692769e96ce92" translate="yes" xml:space="preserve">
          <source>The cursor-based pagination presents an opaque &quot;cursor&quot; indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.</source>
          <target state="translated">커서 기반 페이지 매김은 클라이언트가 결과 세트를 페이징하는 데 사용할 수있는 불투명 한 &quot;커서&quot;표시기를 나타냅니다. 이 페이지 매김 스타일은 정방향 및 역방향 제어 만 제공하며 클라이언트가 임의의 위치로 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b6e4ca28999188f48eb4dbbae51434f6bc1cb91" translate="yes" xml:space="preserve">
          <source>The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class &lt;code&gt;default=...&lt;/code&gt;, because the value being used for the default wouldn't be generated until after the validation has run.</source>
          <target state="translated">유효성 검사에 사용되는 날짜 필드는 항상 serializer 클래스에 있어야합니다. 유효성 검사가 실행될 때까지 기본값에 사용되는 값이 생성되지 않으므로 모델 클래스 &lt;code&gt;default=...&lt;/code&gt; 에 의존 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aa8ca53f2e69270dbcda86a74139dbb6984ee636" translate="yes" xml:space="preserve">
          <source>The decorator can additionally take extra arguments that will be set for the routed view only. For example:</source>
          <target state="translated">데코레이터는 라우팅 뷰에 대해서만 추가 인수를 취할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72ba76d91cb4879a5db8f883f995cb0be490cd9d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;ModelSerializer&lt;/code&gt; uses primary keys for relationships, but you can also easily generate nested representations using the &lt;code&gt;depth&lt;/code&gt; option:</source>
          <target state="translated">기본 &lt;code&gt;ModelSerializer&lt;/code&gt; 는 관계에 기본 키를 사용하지만 &lt;code&gt;depth&lt;/code&gt; 옵션을 사용하여 중첩 표현을 쉽게 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4a60d1ad729f7a1da7a4e99f32b3562dc9267cf" translate="yes" xml:space="preserve">
          <source>The default JSON encoding style can be altered using the &lt;code&gt;UNICODE_JSON&lt;/code&gt; and &lt;code&gt;COMPACT_JSON&lt;/code&gt; settings keys.</source>
          <target state="translated">기본 JSON 인코딩 스타일은 &lt;code&gt;UNICODE_JSON&lt;/code&gt; 및 &lt;code&gt;COMPACT_JSON&lt;/code&gt; 설정 키를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63d71c13e533a81f0f9841d3423f11c8afd3dad1" translate="yes" xml:space="preserve">
          <source>The default authentication schemes may be set globally, using the &lt;code&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/code&gt; setting. For example.</source>
          <target state="translated">기본 인증 체계는 &lt;code&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/code&gt; 설정을 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어.</target>
        </trans-unit>
        <trans-unit id="fadf0cdbac848d784705a12d0c8bc32ef4e7e9ba" translate="yes" xml:space="preserve">
          <source>The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the &lt;a href=&quot;#listserializer&quot;&gt;ListSerializer&lt;/a&gt; documentation below.</source>
          <target state="translated">여러 개체를 역 직렬화하는 기본 동작은 여러 개체 생성을 지원하지만 여러 개체 업데이트는 지원하지 않는 것입니다. 이러한 경우를 지원하거나 사용자 지정하는 방법에 대한 자세한 내용은 아래 &lt;a href=&quot;#listserializer&quot;&gt;ListSerializer&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9433f8b20b5262010a789734b1c2e345b20abc2" translate="yes" xml:space="preserve">
          <source>The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.</source>
          <target state="translated">REST 프레임 워크의 일반 목록보기의 기본 작동은 모델 관리자에 대한 전체 조회 세트를 리턴하는 것입니다. 종종 API에서 쿼리 세트에 의해 반환되는 항목을 제한하기를 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="478a140a97bf15bf9ad651a902cd91fd6636189e" translate="yes" xml:space="preserve">
          <source>The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a &lt;code&gt;view&lt;/code&gt; model permission for &lt;code&gt;GET&lt;/code&gt; requests.</source>
          <target state="translated">사용자 지정 모델 권한을 지원하기 위해 기본 동작을 재정의 할 수도 있습니다. 예를 들어 &lt;code&gt;GET&lt;/code&gt; 요청에 대한 &lt;code&gt;view&lt;/code&gt; 모델 권한 을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63dde6a54d1260721ac0a323bc829bdc857a66c7" translate="yes" xml:space="preserve">
          <source>The default class to use for queryset pagination. If set to &lt;code&gt;None&lt;/code&gt;, pagination is disabled by default. See the pagination documentation for further guidance on &lt;a href=&quot;../pagination/index#setting-the-pagination-style&quot;&gt;setting&lt;/a&gt; and &lt;a href=&quot;../pagination/index#modifying-the-pagination-style&quot;&gt;modifying&lt;/a&gt; the pagination style.</source>
          <target state="translated">쿼리 셋 페이지 매김에 사용할 기본 클래스입니다. &lt;code&gt;None&lt;/code&gt; 으로 설정하면 페이지 매김이 기본적으로 비활성화됩니다. 페이지 매김 스타일 &lt;a href=&quot;../pagination/index#setting-the-pagination-style&quot;&gt;설정&lt;/a&gt; 및 &lt;a href=&quot;../pagination/index#modifying-the-pagination-style&quot;&gt;수정&lt;/a&gt; 에 대한 자세한 지침은 페이지 매김 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c1368c7618c2ea488a3b7ad1f84e4eba5d6ab8" translate="yes" xml:space="preserve">
          <source>The default content negotiation class may be set globally, using the &lt;code&gt;DEFAULT_CONTENT_NEGOTIATION_CLASS&lt;/code&gt; setting. For example, the following settings would use our example &lt;code&gt;IgnoreClientContentNegotiation&lt;/code&gt; class.</source>
          <target state="translated">기본 컨텐츠 협상 클래스는 &lt;code&gt;DEFAULT_CONTENT_NEGOTIATION_CLASS&lt;/code&gt; 설정을 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어 다음 설정은 예제 &lt;code&gt;IgnoreClientContentNegotiation&lt;/code&gt; 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dbbe8858143dcb1045733411d152a901d838863b" translate="yes" xml:space="preserve">
          <source>The default filter backends may be set globally, using the &lt;code&gt;DEFAULT_FILTER_BACKENDS&lt;/code&gt; setting. For example.</source>
          <target state="translated">기본 필터 백엔드는 &lt;code&gt;DEFAULT_FILTER_BACKENDS&lt;/code&gt; 설정을 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어.</target>
        </trans-unit>
        <trans-unit id="a1974af3d7f626b1ace4eabe9c47cc84dea58c21" translate="yes" xml:space="preserve">
          <source>The default format that should be used when making test requests.</source>
          <target state="translated">테스트 요청시 사용해야하는 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ae82fcb9785d697bac2cf2cc66c5627d18273cba" translate="yes" xml:space="preserve">
          <source>The default format used to make test requests may be set using the &lt;code&gt;TEST_REQUEST_DEFAULT_FORMAT&lt;/code&gt; setting key. For example, to always use JSON for test requests by default instead of standard multipart form requests, set the following in your &lt;code&gt;settings.py&lt;/code&gt; file:</source>
          <target state="translated">테스트 요청에 사용되는 기본 형식은 &lt;code&gt;TEST_REQUEST_DEFAULT_FORMAT&lt;/code&gt; 설정 키를 사용하여 설정할 수 있습니다 . 예를 들어 표준 멀티 파트 양식 요청 대신 기본적으로 테스트 요청에 JSON을 항상 사용하려면 &lt;code&gt;settings.py&lt;/code&gt; 파일 에서 다음을 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="77d49097c2e88ed73e3ee123085a46d31b5a7f2a" translate="yes" xml:space="preserve">
          <source>The default implementation dynamically creates a nested serializer class based on either &lt;code&gt;ModelSerializer&lt;/code&gt; or &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;ModelSerializer&lt;/code&gt; 또는 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 를 기반으로 중첩 된 직렬 변환기 클래스를 동적으로 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ed8ba58bc0fda05a2b1ff029b1fd77e653ae6139" translate="yes" xml:space="preserve">
          <source>The default implementation for multiple object creation is to simply call &lt;code&gt;.create()&lt;/code&gt; for each item in the list. If you want to customize this behavior, you'll need to customize the &lt;code&gt;.create()&lt;/code&gt; method on &lt;code&gt;ListSerializer&lt;/code&gt; class that is used when &lt;code&gt;many=True&lt;/code&gt; is passed.</source>
          <target state="translated">다중 객체 생성의 기본 구현은 단순히 목록의 각 항목에 대해 &lt;code&gt;.create()&lt;/code&gt; 를 호출 하는 것입니다. 이 동작을 사용자 정의하려면 &lt;code&gt;many=True&lt;/code&gt; 가 전달 될 때 사용되는 &lt;code&gt;ListSerializer&lt;/code&gt; 클래스 에서 &lt;code&gt;.create()&lt;/code&gt; 메소드 를 사용자 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24a57f35c21fa408bb1e7ad337bcda9ce0dd6864" translate="yes" xml:space="preserve">
          <source>The default implementation handles any subclass of &lt;code&gt;rest_framework.exceptions.APIException&lt;/code&gt;, as well as Django's &lt;code&gt;Http404&lt;/code&gt; and &lt;code&gt;PermissionDenied&lt;/code&gt; exceptions, and returns an appropriate error response.</source>
          <target state="translated">기본 구현은 &lt;code&gt;rest_framework.exceptions.APIException&lt;/code&gt; 의 서브 클래스 와 Django의 &lt;code&gt;Http404&lt;/code&gt; 및 &lt;code&gt;PermissionDenied&lt;/code&gt; 예외를 처리하고 적절한 오류 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="77a2dab3b75eb3fa5194242c642a3b967cbda6f6" translate="yes" xml:space="preserve">
          <source>The default implementation is to pass all arguments to both classes, except for &lt;code&gt;validators&lt;/code&gt;, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.</source>
          <target state="translated">기본 구현은 &lt;code&gt;validators&lt;/code&gt; 및 사용자 정의 키워드 인수를 제외한 모든 인수를 두 클래스에 모두 전달하는 것입니다 .이 두 가지 모두 자식 직렬 변환기 클래스 용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd28e3676330daab2a41537bab942b3970c229e" translate="yes" xml:space="preserve">
          <source>The default implementation returns a &lt;code&gt;ReadOnlyField&lt;/code&gt; class.</source>
          <target state="translated">기본 구현은 &lt;code&gt;ReadOnlyField&lt;/code&gt; 클래스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cf7ab0cff2846a6cf28ca2bebf736e811d82f825" translate="yes" xml:space="preserve">
          <source>The default implementation returns a serializer class based on the &lt;code&gt;serializer_field_mapping&lt;/code&gt; attribute.</source>
          <target state="translated">기본 구현은 &lt;code&gt;serializer_field_mapping&lt;/code&gt; 속성 에 따라 serializer 클래스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="00c070c40c682f491064fbb13e6306f234285072" translate="yes" xml:space="preserve">
          <source>The default implementation returns a serializer class based on the &lt;code&gt;serializer_related_field&lt;/code&gt; attribute.</source>
          <target state="translated">기본 구현은 &lt;code&gt;serializer_related_field&lt;/code&gt; 속성을 기반으로 serializer 클래스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4ce948c747ff375d07aa7ee2f3b795496003ecc7" translate="yes" xml:space="preserve">
          <source>The default page size to use for pagination. If set to &lt;code&gt;None&lt;/code&gt;, pagination is disabled by default.</source>
          <target state="translated">페이지 매김에 사용할 기본 페이지 크기입니다. &lt;code&gt;None&lt;/code&gt; 으로 설정하면 페이지 매김이 기본적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae5b4632fde8e9e22b955364491e27835858ba6" translate="yes" xml:space="preserve">
          <source>The default permission policy may be set globally, using the &lt;code&gt;DEFAULT_PERMISSION_CLASSES&lt;/code&gt; setting. For example.</source>
          <target state="translated">기본 권한 정책은 &lt;code&gt;DEFAULT_PERMISSION_CLASSES&lt;/code&gt; 설정을 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어.</target>
        </trans-unit>
        <trans-unit id="f2e55de72a9f8b32ef49cba3071d0a8c6e8c3398" translate="yes" xml:space="preserve">
          <source>The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:</source>
          <target state="translated">REST 프레임 워크에 포함 된 기본 라우터는 아래와 같이 표준 작성 / 검색 / 업데이트 / 파기 스타일 조치 세트에 대한 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93dd82f064eeed4818dc853b12f1fbf954a84485" translate="yes" xml:space="preserve">
          <source>The default set of parsers may be set globally, using the &lt;code&gt;DEFAULT_PARSER_CLASSES&lt;/code&gt; setting. For example, the following settings would allow only requests with &lt;code&gt;JSON&lt;/code&gt; content, instead of the default of JSON or form data.</source>
          <target state="translated">기본 구문 분석기 세트는 &lt;code&gt;DEFAULT_PARSER_CLASSES&lt;/code&gt; 설정을 사용하여 전체적으로 설정 될 수 있습니다 . 예를 들어 다음 설정은 기본 JSON 또는 양식 데이터 대신 &lt;code&gt;JSON&lt;/code&gt; 컨텐츠가있는 요청 만 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ccf5f9e51a63b5cb7ef4fe84c98429d29e66a6" translate="yes" xml:space="preserve">
          <source>The default set of renderers may be set globally, using the &lt;code&gt;DEFAULT_RENDERER_CLASSES&lt;/code&gt; setting. For example, the following settings would use &lt;code&gt;JSON&lt;/code&gt; as the main media type and also include the self describing API.</source>
          <target state="translated">&lt;code&gt;DEFAULT_RENDERER_CLASSES&lt;/code&gt; 설정을 사용하여 기본 렌더러 세트를 전체적으로 설정할 수 있습니다 . 예를 들어 다음 설정은 &lt;code&gt;JSON&lt;/code&gt; 을 기본 미디어 유형으로 사용 하고 자체 설명 API도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="847e76ce3b32cc0d9ed6b7e0d05dfb6d3e0eb2de" translate="yes" xml:space="preserve">
          <source>The default style is to return minified responses, in line with &lt;a href=&quot;https://github.com/interagent/http-api-design#keep-json-minified-in-all-responses&quot;&gt;Heroku's API design guidelines&lt;/a&gt;.</source>
          <target state="translated">기본 스타일은 &lt;a href=&quot;https://github.com/interagent/http-api-design#keep-json-minified-in-all-responses&quot;&gt;Heroku의 API 디자인 지침에 따라&lt;/a&gt; 축소 된 응답을 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="347c05a65e31b488693f6555049165415a5df4a7" translate="yes" xml:space="preserve">
          <source>The default throttling policy may be set globally, using the &lt;code&gt;DEFAULT_THROTTLE_CLASSES&lt;/code&gt; and &lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; settings. For example.</source>
          <target state="translated">기본 조절 정책은 &lt;code&gt;DEFAULT_THROTTLE_CLASSES&lt;/code&gt; 및 &lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; 설정을 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어.</target>
        </trans-unit>
        <trans-unit id="aabacd94a598bd1690e72a31e6f45a3146ddb30a" translate="yes" xml:space="preserve">
          <source>The example above would generate the following URL patterns:</source>
          <target state="translated">위의 예는 다음 URL 패턴을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fea16a6d0bf7263add0910c45ee4a0ac2cd1606" translate="yes" xml:space="preserve">
          <source>The exception handler must also be configured in your settings, using the &lt;code&gt;EXCEPTION_HANDLER&lt;/code&gt; setting key. For example:</source>
          <target state="translated">&lt;code&gt;EXCEPTION_HANDLER&lt;/code&gt; 설정 키를 사용하여 설정에서 예외 처리기를 구성해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e52438e532eb1b032b927643b1e79337d806029" translate="yes" xml:space="preserve">
          <source>The field flags can also control how the serializer should be displayed in certain circumstances, such as when rendering to HTML. The &lt;code&gt;{'base_template': 'textarea.html'}&lt;/code&gt; flag above is equivalent to using &lt;code&gt;widget=widgets.Textarea&lt;/code&gt; on a Django &lt;code&gt;Form&lt;/code&gt; class. This is particularly useful for controlling how the browsable API should be displayed, as we'll see later in the tutorial.</source>
          <target state="translated">필드 플래그는 HTML로 렌더링 할 때와 같이 특정 상황에서 직렬 변환기가 표시되는 방법을 제어 할 수도 있습니다. 위의 &lt;code&gt;{'base_template': 'textarea.html'}&lt;/code&gt; 플래그 는 Django &lt;code&gt;Form&lt;/code&gt; 클래스 에서 &lt;code&gt;widget=widgets.Textarea&lt;/code&gt; 를 사용하는 것과 같습니다 . 이 자습서의 뒷부분에서 볼 수 있듯이 탐색 가능한 API가 표시되는 방법을 제어하는 ​​데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9dadeb8b87a342712f5eeaa958f114176711e892" translate="yes" xml:space="preserve">
          <source>The field should have a database index.</source>
          <target state="translated">이 필드에는 데이터베이스 인덱스가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2e3beb03816e8c59f6b6c1ac5837800e8063043" translate="yes" xml:space="preserve">
          <source>The field we've added is the untyped &lt;code&gt;ReadOnlyField&lt;/code&gt; class, in contrast to the other typed fields, such as &lt;code&gt;CharField&lt;/code&gt;, &lt;code&gt;BooleanField&lt;/code&gt; etc... The untyped &lt;code&gt;ReadOnlyField&lt;/code&gt; is always read-only, and will be used for serialized representations, but will not be used for updating model instances when they are deserialized. We could have also used &lt;code&gt;CharField(read_only=True)&lt;/code&gt; here.</source>
          <target state="translated">우리가 추가 한 필드는 &lt;code&gt;CharField&lt;/code&gt; , &lt;code&gt;BooleanField&lt;/code&gt; 등과 같은 다른 형식의 필드와 달리 형식화되지 않은 &lt;code&gt;ReadOnlyField&lt;/code&gt; 클래스입니다 . 형식화되지 않은 &lt;code&gt;ReadOnlyField&lt;/code&gt; 는 항상 읽기 전용 이며 직렬화 된 표현에 사용되지만 역 직렬화 될 때 모델 인스턴스를 업데이트하는 데 사용됩니다. 여기서 &lt;code&gt;CharField(read_only=True)&lt;/code&gt; 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b4513ade046a03c806ef6f51def65aa784fa53" translate="yes" xml:space="preserve">
          <source>The field will not be writable to the user, but the default value will still be passed through to the &lt;code&gt;validated_data&lt;/code&gt;.</source>
          <target state="translated">이 필드는 사용자가 쓸 수 없지만 기본값은 여전히 &lt;code&gt;validated_data&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f22d72e5e47cd12eee906ad941d0b49fdfd45b22" translate="yes" xml:space="preserve">
          <source>The field_class and field_kwargs API</source>
          <target state="translated">field_class 및 field_kwargs API</target>
        </trans-unit>
        <trans-unit id="f1e2c31177c032a8824b295e39ce8947694d4e31" translate="yes" xml:space="preserve">
          <source>The first part of the serializer class defines the fields that get serialized/deserialized. The &lt;code&gt;create()&lt;/code&gt; and &lt;code&gt;update()&lt;/code&gt; methods define how fully fledged instances are created or modified when calling &lt;code&gt;serializer.save()&lt;/code&gt;</source>
          <target state="translated">직렬화 기 클래스의 첫 번째 부분은 직렬화 / 역 직렬화되는 필드를 정의합니다. (가) &lt;code&gt;create()&lt;/code&gt; 와 &lt;code&gt;update()&lt;/code&gt; 메소드가 생성되거나 호출 할 때 수정하는 방법을 완전히 본격적인 인스턴스 정의 &lt;code&gt;serializer.save()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0638aa71f584de2ea4ef0cd02b2f831b1f142be4" translate="yes" xml:space="preserve">
          <source>The first thing we need to get started on our Web API is to provide a way of serializing and deserializing the snippet instances into representations such as &lt;code&gt;json&lt;/code&gt;. We can do this by declaring serializers that work very similar to Django's forms. Create a file in the &lt;code&gt;snippets&lt;/code&gt; directory named &lt;code&gt;serializers.py&lt;/code&gt; and add the following.</source>
          <target state="translated">웹 API에서 시작해야 할 첫 번째 사항은 스 니펫 인스턴스를 &lt;code&gt;json&lt;/code&gt; 과 같은 표현으로 직렬화하고 역 직렬화하는 방법을 제공하는 것입니다 . Django의 양식과 매우 유사한 직렬 변환기를 선언하여이를 수행 할 수 있습니다. &lt;code&gt;snippets&lt;/code&gt; 디렉토리에 &lt;code&gt;serializers.py&lt;/code&gt; 라는 파일을 작성 하고 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fda4b36dfb9c1327ce6416d3eda598c4a9a87e14" translate="yes" xml:space="preserve">
          <source>The following argument can also be passed to a &lt;code&gt;ListSerializer&lt;/code&gt; field or a serializer that is passed &lt;code&gt;many=True&lt;/code&gt;:</source>
          <target state="translated">다음 인수는 &lt;code&gt;ListSerializer&lt;/code&gt; 필드 또는 &lt;code&gt;many=True&lt;/code&gt; 로 전달되는 직렬 변환기 에도 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c843c6e4e08b396dfc11b5f5504b106af579035" translate="yes" xml:space="preserve">
          <source>The following attributes are used to control pagination when used with list views.</source>
          <target state="translated">다음 속성은 목록보기와 함께 사용될 때 페이지 매김을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c718b5f9dc05baf49db6e80a13b01fb71ef351e" translate="yes" xml:space="preserve">
          <source>The following attributes control the basic view behavior.</source>
          <target state="translated">다음 속성은 기본보기 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="49a117ee43a585f58b69f5a7a71814d25a721834" translate="yes" xml:space="preserve">
          <source>The following attributes control the pluggable aspects of API views.</source>
          <target state="translated">다음 속성은 API보기의 플러그 가능 측면을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ded2defe5171a32fd8a36b3a9dd5da9c4e2c52d" translate="yes" xml:space="preserve">
          <source>The following class could be used to limit the information that is returned to &lt;code&gt;OPTIONS&lt;/code&gt; requests.</source>
          <target state="translated">다음 클래스를 사용하여 &lt;code&gt;OPTIONS&lt;/code&gt; 요청으로 리턴되는 정보를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8673d610421d6fc6e5955a7580ddff741cfe169c" translate="yes" xml:space="preserve">
          <source>The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.</source>
          <target state="translated">다음 클래스는 임의의 객체를 원시적 표현으로 강제 처리하는 일반 직렬 변환기의 예입니다.</target>
        </trans-unit>
        <trans-unit id="52658e8b201351ef8607eeb02a402719927475aa" translate="yes" xml:space="preserve">
          <source>The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.</source>
          <target state="translated">다음 클래스는 구체적인 일반 뷰입니다. 일반보기를 사용하는 경우 이는 일반적으로 심하게 사용자 정의 된 동작이 필요하지 않으면 작업중인 레벨입니다.</target>
        </trans-unit>
        <trans-unit id="b3efb5316b9d5c490a4d6b886d74a434028c9bfc" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how you might handle creating a user with a nested profile object.</source>
          <target state="translated">다음 예제는 중첩 된 프로파일 오브젝트로 사용자 작성을 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="88e6f7619f9375b8f7b4f6b9b5b872cf85e12e23" translate="yes" xml:space="preserve">
          <source>The following example uses a custom &lt;code&gt;X-API-Version&lt;/code&gt; header to determine the requested version.</source>
          <target state="translated">다음 예제는 사용자 정의 &lt;code&gt;X-API-Version&lt;/code&gt; 헤더를 사용하여 요청 된 버전을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="86811ff4623e7dce4f854e502815a08f19f61835" translate="yes" xml:space="preserve">
          <source>The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.</source>
          <target state="translated">다음 예제는 이름이 'X-USERNAME'인 사용자 정의 요청 헤더에서 사용자 이름으로 제공된 사용자로 들어오는 요청을 인증합니다.</target>
        </trans-unit>
        <trans-unit id="11710792895a3663b8fe9c7bea95588c9abb68af" translate="yes" xml:space="preserve">
          <source>The following example will only route to the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; actions, and does not use the trailing slash convention.</source>
          <target state="translated">다음의 예는 단지 노선 것 &lt;code&gt;list&lt;/code&gt; 및 &lt;code&gt;retrieve&lt;/code&gt; 작업을하고 후행 슬래시 규칙을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f22e8fcf96831c74adba5fec2f9a083786332e4d" translate="yes" xml:space="preserve">
          <source>The following helper functions are available for identifying the category of the response code.</source>
          <target state="translated">응답 코드의 범주를 식별하기 위해 다음 헬퍼 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9af063346c1e2dc318ab1fbfa0ee7609819a19" translate="yes" xml:space="preserve">
          <source>The following is a custom content negotiation class which ignores the client request when selecting the appropriate parser or renderer.</source>
          <target state="translated">다음은 적절한 파서 또는 렌더러를 선택할 때 클라이언트 요청을 무시하는 사용자 정의 컨텐츠 협상 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="64452fe4b10755efd9637591c1aa0e5045d3b406" translate="yes" xml:space="preserve">
          <source>The following is an example of a permission class that checks the incoming request's IP address against a blacklist, and denies the request if the IP has been blacklisted.</source>
          <target state="translated">다음은 블랙리스트에 대해 들어오는 요청의 IP 주소를 확인하고 IP가 블랙리스트에 올랐다면 요청을 거부하는 권한 클래스의 예입니다.</target>
        </trans-unit>
        <trans-unit id="50e0c8e3bdcfbb2b1dbed1c2f8fe8bf1408275e6" translate="yes" xml:space="preserve">
          <source>The following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.</source>
          <target state="translated">다음은 10 개의 요청마다 1을 임의로 조절하는 속도 조절의 예입니다.</target>
        </trans-unit>
        <trans-unit id="002af76430d24b5f8ae3645f1496907d270795bf" translate="yes" xml:space="preserve">
          <source>The following is an example plaintext parser that will populate the &lt;code&gt;request.data&lt;/code&gt; property with a string representing the body of the request.</source>
          <target state="translated">다음은 &lt;code&gt;request.data&lt;/code&gt; 속성을 요청 본문을 나타내는 문자열로 채우는 일반 텍스트 파서의 예 입니다.</target>
        </trans-unit>
        <trans-unit id="d6b2bfcdc691ea934fe1ee8fa94c2fdbcae14143" translate="yes" xml:space="preserve">
          <source>The following is an example plaintext renderer that will return a response with the &lt;code&gt;data&lt;/code&gt; parameter as the content of the response.</source>
          <target state="translated">다음은 응답 의 내용으로 &lt;code&gt;data&lt;/code&gt; 매개 변수를 사용하여 응답을 반환하는 일반 텍스트 렌더러의 예 입니다.</target>
        </trans-unit>
        <trans-unit id="2cb7b0631fcd40e7e185799ec961e191979d3574" translate="yes" xml:space="preserve">
          <source>The following mappings would be generated...</source>
          <target state="translated">다음과 같은 매핑이 생성됩니다 ...</target>
        </trans-unit>
        <trans-unit id="411a2deffcb60e8eb94770f3948a993d3a8e3d8e" translate="yes" xml:space="preserve">
          <source>The following methods are called before dispatching to the handler method.</source>
          <target state="translated">핸들러 메소드로 디스패치하기 전에 다음 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63414e77e4559c392798616cc4503da35bd1f3e0" translate="yes" xml:space="preserve">
          <source>The following methods are called directly by the view's &lt;code&gt;.dispatch()&lt;/code&gt; method. These perform any actions that need to occur before or after calling the handler methods such as &lt;code&gt;.get()&lt;/code&gt;, &lt;code&gt;.post()&lt;/code&gt;, &lt;code&gt;put()&lt;/code&gt;, &lt;code&gt;patch()&lt;/code&gt; and &lt;code&gt;.delete()&lt;/code&gt;.</source>
          <target state="translated">다음 메소드는 뷰의 &lt;code&gt;.dispatch()&lt;/code&gt; 메소드에 의해 직접 호출됩니다 . 이들은 &lt;code&gt;.get()&lt;/code&gt; , &lt;code&gt;.post()&lt;/code&gt; , &lt;code&gt;put()&lt;/code&gt; , &lt;code&gt;patch()&lt;/code&gt; 및 &lt;code&gt;.delete()&lt;/code&gt; 와 같은 핸들러 메소드를 호출하기 전 또는 후에 발생하는 모든 조치를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d2d983e7221343e6f55fe668fde85a4bf38eec62" translate="yes" xml:space="preserve">
          <source>The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of &lt;code&gt;(field_class, field_kwargs)&lt;/code&gt;.</source>
          <target state="translated">직렬화기에 자동으로 포함되어야하는 각 필드의 클래스 및 키워드 인수를 판별하기 위해 다음 메소드가 호출됩니다. 이러한 각 메소드는 두 개의 튜플 &lt;code&gt;(field_class, field_kwargs)&lt;/code&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57eb6aebe4449c459f2a0ef7f7847875148329f3" translate="yes" xml:space="preserve">
          <source>The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.</source>
          <target state="translated">다음 메소드는 mixin 클래스에서 제공되며 오브젝트 저장 또는 삭제 동작을 쉽게 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7dbcf284ade21c8a4436df06758b1afc52dfe3" translate="yes" xml:space="preserve">
          <source>The following methods are used by REST framework to instantiate the various pluggable API policies. You won't typically need to override these methods.</source>
          <target state="translated">REST 프레임 워크는 다음 메소드를 사용하여 다양한 플러그 가능 API 정책을 인스턴스화합니다. 일반적으로 이러한 방법을 재정의 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="631f6a4b7decf1238daf7b750bff85109643a77c" translate="yes" xml:space="preserve">
          <source>The following packages are optional:</source>
          <target state="translated">다음 패키지는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="64c0669430dd2d445000d02685ac55e3706f8bb3" translate="yes" xml:space="preserve">
          <source>The following route would be generated:</source>
          <target state="translated">다음과 같은 경로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ff88d9fb3102a50823fa3bf70a9b5447d677796" translate="yes" xml:space="preserve">
          <source>The following settings keys are also used to control versioning:</source>
          <target state="translated">다음 설정 키는 버전 관리를 제어하는 ​​데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9c4581a897a90912473c6bb88fb2d0774dc938" translate="yes" xml:space="preserve">
          <source>The following third party packages are also available.</source>
          <target state="translated">다음과 같은 타사 패키지도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c9ca9f1b1aa5c07e6765e7090efc725f2ed7b8ac" translate="yes" xml:space="preserve">
          <source>The following third party packages provide additional filter implementations.</source>
          <target state="translated">다음 타사 패키지는 추가 필터 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4e18383561a33aef20b2faa2fbec88695041706" translate="yes" xml:space="preserve">
          <source>The following third party packages provide additional generic view implementations.</source>
          <target state="translated">다음의 타사 패키지는 추가 일반보기 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf6a9ed24b7c804d2000dbcf274fe58acd5457c3" translate="yes" xml:space="preserve">
          <source>The following third party packages provide additional metadata implementations.</source>
          <target state="translated">다음 타사 패키지는 추가 메타 데이터 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4ba61cb93abfda95080fb7407211983eb9083f1" translate="yes" xml:space="preserve">
          <source>The format of any of these renderer classes may be used when constructing a test request, for example: &lt;code&gt;client.post('/users', {'username': 'jamie'}, format='json')&lt;/code&gt;</source>
          <target state="translated">이러한 렌더러 클래스의 형식은 테스트 요청을 구성 할 때 사용할 수 있습니다 &lt;code&gt;client.post('/users', {'username': 'jamie'}, format='json')&lt;/code&gt; 예 : client.post ( '/ users', { 'username': 'jamie'}, format = 'json')).</target>
        </trans-unit>
        <trans-unit id="ea1e5b981d6a19054129b2ea1a1cf48871c487b5" translate="yes" xml:space="preserve">
          <source>The full set of HTTP status codes included in the &lt;code&gt;status&lt;/code&gt; module is listed below.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 모듈에 포함 된 전체 HTTP 상태 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="679ce3cc4a243d93848bc07a2bfc67b3a6bf43c8" translate="yes" xml:space="preserve">
          <source>The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a &lt;code&gt;Response&lt;/code&gt; object, or return &lt;code&gt;None&lt;/code&gt; if the exception cannot be handled. If the handler returns &lt;code&gt;None&lt;/code&gt; then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.</source>
          <target state="translated">함수는 한 쌍의 인수를 가져야하며, 첫 번째는 처리 할 예외이고 두 번째는 현재 처리중인 뷰와 같은 추가 컨텍스트를 포함하는 사전입니다. 예외 처리기 함수는 &lt;code&gt;Response&lt;/code&gt; 객체를 반환하거나 예외를 처리 할 수 ​​없으면 &lt;code&gt;None&lt;/code&gt; 을 반환 해야합니다. 핸들러가 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 예외가 다시 발생하고 Django는 표준 HTTP 500 '서버 오류'응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b590172f5572968b5fedb23c1dc7b584bdb31c47" translate="yes" xml:space="preserve">
          <source>The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.</source>
          <target state="translated">REST 프레임 워크에서 제공하는 일반보기를 사용하면 데이터베이스 모델과 밀접하게 맵핑되는 API보기를 신속하게 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="553a8262cd77c3563519ed66da71b9fadd73d263" translate="yes" xml:space="preserve">
          <source>The generic views use the &lt;code&gt;raise_exception=True&lt;/code&gt; flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.</source>
          <target state="translated">일반 뷰는 &lt;code&gt;raise_exception=True&lt;/code&gt; 플래그를 사용합니다 . 이는 API에서 전체적으로 유효성 검증 오류 응답 스타일을 대체 할 수 있음을 의미합니다. 이렇게하려면 위에서 설명한대로 사용자 지정 예외 처리기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="db740dffbe35d8aa91c93a93d1321c9e9a8855ad" translate="yes" xml:space="preserve">
          <source>The handled exceptions are:</source>
          <target state="translated">처리 된 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e441396ead63a9de741ba5cadd532a7c332c540" translate="yes" xml:space="preserve">
          <source>The handler methods only get bound to the actions when we define the URLConf. To see what's going on under the hood let's first explicitly create a set of views from our ViewSets.</source>
          <target state="translated">핸들러 메소드는 URLConf를 정의 할 때만 액션에 바인딩됩니다. 후드 아래에서 무슨 일이 일어나고 있는지 보려면 먼저 ViewSets에서 뷰 세트를 명시 적으로 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ba2c37f4c567e91c0c20a2465795180b0237c552" translate="yes" xml:space="preserve">
          <source>The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.</source>
          <target state="translated">호스트 이름 버전 관리 체계를 사용하려면 클라이언트가 URL에서 호스트 이름의 일부로 요청 된 버전을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7be2f9ea93840dcb8c7a8f1156885e26a35d4e93" translate="yes" xml:space="preserve">
          <source>The interesting bit here is the &lt;code&gt;reference&lt;/code&gt; field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.</source>
          <target state="translated">여기서 흥미로운 부분은 &lt;code&gt;reference&lt;/code&gt; 필드입니다. serializer 필드에서 유효성 검사기가 고유성 제약 조건을 명시 적으로 적용하고 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc770cf1cb22083142e59e39a663d0b09a184236" translate="yes" xml:space="preserve">
          <source>The key points from the example, though, are:</source>
          <target state="translated">그러나이 예제의 핵심 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0200cab07974d27746c8da7b7190c80ccbf0921" translate="yes" xml:space="preserve">
          <source>The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. &lt;strong&gt;The first authentication class set on the view is used when determining the type of response&lt;/strong&gt;.</source>
          <target state="translated">사용될 응답의 종류는 인증 체계에 따라 다릅니다. 여러 인증 체계가 사용 중일 수 있지만 응답 유형을 결정하는 데 하나의 체계 만 사용할 수 있습니다. &lt;strong&gt;보기에 설정된 첫 번째 인증 클래스는 응답 유형을 결정할 때 사용됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d646d3520ad719abb0dfd42f4f866c89b548ce9f" translate="yes" xml:space="preserve">
          <source>The list views for users and code snippets could end up returning quite a lot of instances, so really we'd like to make sure we paginate the results, and allow the API client to step through each of the individual pages.</source>
          <target state="translated">사용자 및 코드 스 니펫에 대한 목록보기는 많은 인스턴스를 리턴 할 수 있으므로 실제로 결과를 페이지 매김하고 API 클라이언트가 각 개별 페이지를 단계별로 실행하도록하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="a0e0efc33dc135ef46009668d76d8022b8caf422" translate="yes" xml:space="preserve">
          <source>The low-level API for determining if a pagination class should display the controls or not is exposed as a &lt;code&gt;display_page_controls&lt;/code&gt; attribute on the pagination instance. Custom pagination classes should be set to &lt;code&gt;True&lt;/code&gt; in the &lt;code&gt;paginate_queryset&lt;/code&gt; method if they require the HTML pagination controls to be displayed.</source>
          <target state="translated">페이지 매김 클래스가 제어를 표시해야하는지 여부를 판별하기위한 저수준 API 는 페이지 매김 인스턴스에 &lt;code&gt;display_page_controls&lt;/code&gt; 속성으로 노출됩니다 . HTML 페이지 매김 컨트롤을 표시해야하는 경우 &lt;code&gt;paginate_queryset&lt;/code&gt; 메서드 에서 사용자 지정 페이지 매김 클래스를 &lt;code&gt;True&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06d35dd1db3c617bd950df542336d65bec421b93" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;regex&lt;/code&gt; argument may either be a string, or a compiled python regular expression object.</source>
          <target state="translated">필수 &lt;code&gt;regex&lt;/code&gt; 인수는 문자열이거나 컴파일 된 파이썬 정규식 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff264b48460b447f7d18fefdccbd91415e98af5e" translate="yes" xml:space="preserve">
          <source>The media type that was selected by the content negotiation stage.</source>
          <target state="translated">콘텐츠 협상 단계에서 선택한 미디어 유형</target>
        </trans-unit>
        <trans-unit id="6dbe3fe68d7be274abac55b4c108edb87b901587" translate="yes" xml:space="preserve">
          <source>The method handlers for a &lt;code&gt;ViewSet&lt;/code&gt; are only bound to the corresponding actions at the point of finalizing the view, using the &lt;code&gt;.as_view()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;ViewSet&lt;/code&gt; 의 메소드 핸들러 는 &lt;code&gt;.as_view()&lt;/code&gt; 메소드를 사용하여 뷰를 마무리 할 때 해당 조치에만 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f437e23a7187dae89fb24f67a60c2fbe4d9f9bd" translate="yes" xml:space="preserve">
          <source>The method should return a bytestring, which will be used as the body of the HTTP response.</source>
          <target state="translated">이 메소드는 바이트 문자열을 리턴해야하며 이는 HTTP 응답의 본문으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9d412ee162ecd07abd6fb771a11619b4bd9931" translate="yes" xml:space="preserve">
          <source>The method should return a list of &lt;code&gt;coreapi.Field&lt;/code&gt; instances.</source>
          <target state="translated">이 메소드는 &lt;code&gt;coreapi.Field&lt;/code&gt; 인스턴스 목록을 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c1a5fafc598f80efc71b056b14efabd004d2fd28" translate="yes" xml:space="preserve">
          <source>The method should return a rendered HTML string.</source>
          <target state="translated">이 메소드는 렌더링 된 HTML 문자열을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae6f559b7d439229838da69050f145aeba576e9f" translate="yes" xml:space="preserve">
          <source>The method should return the data that will be used to populate the &lt;code&gt;request.data&lt;/code&gt; property.</source>
          <target state="translated">이 메소드는 &lt;code&gt;request.data&lt;/code&gt; 특성 을 채우는 데 사용될 데이터를 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c2811c44e7bc927180c65d76534236aca67cf2a8" translate="yes" xml:space="preserve">
          <source>The methods should return &lt;code&gt;True&lt;/code&gt; if the request should be granted access, and &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">요청에 액세스 권한을 부여해야하는 경우 메소드는 &lt;code&gt;True&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ebb6cff3db6c6cb13e3aa1f1d49757d21a9e307" translate="yes" xml:space="preserve">
          <source>The mixin classes can be imported from &lt;code&gt;rest_framework.mixins&lt;/code&gt;.</source>
          <target state="translated">mixin 클래스는 &lt;code&gt;rest_framework.mixins&lt;/code&gt; 에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19611f866dff7910da94ee0210ac407eb6566f8b" translate="yes" xml:space="preserve">
          <source>The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as &lt;code&gt;.get()&lt;/code&gt; and &lt;code&gt;.post()&lt;/code&gt;, directly. This allows for more flexible composition of behavior.</source>
          <target state="translated">mixin 클래스는 기본보기 동작을 제공하는 데 사용되는 동작을 제공합니다. mixin 클래스는 핸들러 메소드 (예 : &lt;code&gt;.get()&lt;/code&gt; 및 &lt;code&gt;.post()&lt;/code&gt; 를 직접 정의하는 대신 조치 메소드를 제공합니다 . 이것은보다 유연한 행동 구성을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="fce80ef9b51a8f3ccc161427c3be6c0f13e7084d" translate="yes" xml:space="preserve">
          <source>The module also includes a set of helper functions for testing if a status code is in a given range.</source>
          <target state="translated">이 모듈에는 상태 코드가 지정된 범위에 있는지 테스트하기위한 도우미 기능 세트도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0076997b4147814852c110c295c94efdfbffa6" translate="yes" xml:space="preserve">
          <source>The name of a URL parameter that may be used to override the default content negotiation &lt;code&gt;Accept&lt;/code&gt; header behavior, by using a &lt;code&gt;format=&amp;hellip;&lt;/code&gt; query parameter in the request URL.</source>
          <target state="translated">요청 컨텐츠 URL에서 &lt;code&gt;format=&amp;hellip;&lt;/code&gt; query 매개 변수를 사용하여 기본 컨텐츠 협상 &lt;code&gt;Accept&lt;/code&gt; 헤더 동작 을 대체하는 데 사용할 수있는 URL 매개 변수의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="96dc7d8e0c1bd154983b950ed548bdef260c4c1f" translate="yes" xml:space="preserve">
          <source>The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using &lt;code&gt;format_suffix_patterns&lt;/code&gt; to include suffixed URL patterns.</source>
          <target state="translated">형식 접미사를 제공하는 데 사용될 수있는 URL conf의 매개 변수 이름입니다. 이 설정은 &lt;code&gt;format_suffix_patterns&lt;/code&gt; 를 사용하여 접미사 URL 패턴을 포함 할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85e3e3cbc8b84856cf2ac588edcbf6dd65b9064e" translate="yes" xml:space="preserve">
          <source>The name of a query parameter, which can be used to specify the ordering of results returned by &lt;code&gt;OrderingFilter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OrderingFilter&lt;/code&gt; 가 리턴 한 결과의 순서를 지정하는 데 사용할 수있는 조회 매개 변수의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9142f0a2c1014784ae40e3ce800e131925ee6920" translate="yes" xml:space="preserve">
          <source>The name of a query parameter, which can be used to specify the search term used by &lt;code&gt;SearchFilter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SearchFilter&lt;/code&gt; 가 사용하는 검색어를 지정하는 데 사용할 수있는 조회 매개 변수의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="aaf108abd8dcada89d49e9f4700ee8ac28a1dc56" translate="yes" xml:space="preserve">
          <source>The name of the URL field defaults to 'url'. You can override this globally, by using the &lt;code&gt;URL_FIELD_NAME&lt;/code&gt; setting.</source>
          <target state="translated">URL 필드의 이름은 기본적으로 'url'입니다. &lt;code&gt;URL_FIELD_NAME&lt;/code&gt; 설정 을 사용하여이를 전역 적으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74a25035eb7e8cac15c6111106d5ffcff0b47115" translate="yes" xml:space="preserve">
          <source>The name of the attribute that will be used to populate the field. May be a method that only takes a &lt;code&gt;self&lt;/code&gt; argument, such as &lt;code&gt;URLField(source='get_absolute_url')&lt;/code&gt;, or may use dotted notation to traverse attributes, such as &lt;code&gt;EmailField(source='user.email')&lt;/code&gt;. When serializing fields with dotted notation, it may be necessary to provide a &lt;code&gt;default&lt;/code&gt; value if any object is not present or is empty during attribute traversal.</source>
          <target state="translated">필드를 채우는 데 사용될 속성의 이름입니다. &lt;code&gt;URLField(source='get_absolute_url')&lt;/code&gt; 과 같은 &lt;code&gt;self&lt;/code&gt; 인수 만 사용하거나 &lt;code&gt;EmailField(source='user.email')&lt;/code&gt; 과 같은 속성을 통과하기 위해 점 표기법을 사용할 수있는 메소드 일 수 있습니다 . 점 표기법으로 필드를 직렬화 할 때 속성 순회 중 오브젝트가 없거나 비어있는 경우 &lt;code&gt;default&lt;/code&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92bf9e4af1ccf4aef0429bca61aba1ecdba5242c" translate="yes" xml:space="preserve">
          <source>The name of the kwarg used may be modified by using the &lt;code&gt;FORMAT_SUFFIX_KWARG&lt;/code&gt; setting.</source>
          <target state="translated">사용되는 kwarg의 이름은 &lt;code&gt;FORMAT_SUFFIX_KWARG&lt;/code&gt; 설정 을 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a0c0335bce32a7c2d5ec1fde8fb0d0e61cc3166" translate="yes" xml:space="preserve">
          <source>The name of this query parameter can be modified using the &lt;code&gt;URL_FORMAT_OVERRIDE&lt;/code&gt; setting. Set the value to &lt;code&gt;None&lt;/code&gt; to disable this behavior.</source>
          <target state="translated">이 쿼리 매개 변수의 이름은 &lt;code&gt;URL_FORMAT_OVERRIDE&lt;/code&gt; 설정을 사용하여 수정할 수 있습니다 . 이 동작을 비활성화 하려면 값을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6ebaa385b3842b4ba1ee8052a0fb6d654e45eef4" translate="yes" xml:space="preserve">
          <source>The names in the &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; attributes will normally map to model fields on the model class.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 속성 의 이름 은 일반적으로 모델 클래스의 모델 필드에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="e47646957b46f1e5a74fc89ee1c806bd0f1c5e4d" translate="yes" xml:space="preserve">
          <source>The numeric status code of the HTTP response.</source>
          <target state="translated">HTTP 응답의 숫자 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="212427d407b157c9beb6926caa5b72de2efa630e" translate="yes" xml:space="preserve">
          <source>The only difference you'll notice when doing so is the &lt;code&gt;BaseSerializer&lt;/code&gt; classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.</source>
          <target state="translated">그렇게 할 때 &lt;code&gt;BaseSerializer&lt;/code&gt; 은 BaseSerializer 클래스가 찾아보기 가능한 API에서 HTML 양식을 생성하지 않는다는 것입니다. 반환되는 데이터에 각 필드를 적절한 HTML 입력으로 렌더링 할 수있는 모든 필드 정보가 포함되어 있지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f37a3a78f26633c3b2a2d5ddc84c0d184a8d0daa" translate="yes" xml:space="preserve">
          <source>The other obvious thing that's still missing from our pastebin API is the code highlighting endpoints.</source>
          <target state="translated">pastebin API에서 여전히 누락 된 또 다른 분명한 점은 코드 강조 끝점입니다.</target>
        </trans-unit>
        <trans-unit id="a8999de3be70b8717e2138650b7627e696335778" translate="yes" xml:space="preserve">
          <source>The other thing we need to consider when creating the code highlight view is that there's no existing concrete generic view that we can use. We're not returning an object instance, but instead a property of an object instance.</source>
          <target state="translated">코드 하이라이트보기를 만들 때 고려해야 할 또 다른 사항은 사용할 수있는 기존의 구체적인 일반보기가 없다는 것입니다. 객체 인스턴스를 반환하지 않고 객체 인스턴스의 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5afc2f67d8f134ab620d7a3522eeb68579aff2b3" translate="yes" xml:space="preserve">
          <source>The pagination API can support either:</source>
          <target state="translated">페이지 매김 API는 다음 중 하나를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016f0f569a316745427b9a1ee341bc4706f154bc" translate="yes" xml:space="preserve">
          <source>The pagination style may be set globally, using the &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; and &lt;code&gt;PAGE_SIZE&lt;/code&gt; setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:</source>
          <target state="translated">페이지 매김 스타일은 &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; 및 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 설정 키를 사용하여 전체적으로 설정할 수 있습니다 . 예를 들어 내장 제한 / 오프셋 페이지 매김을 사용하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="d0ccb374871051814b5d55b114438d655af88513" translate="yes" xml:space="preserve">
          <source>The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.</source>
          <target state="translated">앞의 예제는 단순한 데이터 유형 만있는 객체를 처리하는 데 적합하지만 때로는 객체의 일부 속성이 문자열, 날짜 또는 정수와 같은 간단한 데이터 유형이 아닌 더 복잡한 객체를 나타낼 수도 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2d13988154c6cbbd6ec6093066214714bc39724" translate="yes" xml:space="preserve">
          <source>The priorities for each of the given media types would be:</source>
          <target state="translated">주어진 각 매체 유형에 대한 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="035ecc8455d435ed1c77f45b6b431fe298538786" translate="yes" xml:space="preserve">
          <source>The project layout should look like:</source>
          <target state="translated">프로젝트 레이아웃은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b1ed4b643d6e6fb427c809e936d7ffaf2585da85" translate="yes" xml:space="preserve">
          <source>The queryset argument</source>
          <target state="translated">queryset 인수</target>
        </trans-unit>
        <trans-unit id="729da51701a57bfb2aaa066cd5aab532c8c32258" translate="yes" xml:space="preserve">
          <source>The quote does not mention Accept headers, but it does make it clear that format suffixes should be considered an acceptable pattern.</source>
          <target state="translated">이 인용문에는 Accept 헤더가 언급되어 있지 않지만 형식 접미사가 허용 가능한 패턴으로 간주되어야 함을 분명히합니다.</target>
        </trans-unit>
        <trans-unit id="344e575a443f8ec81fc6ca4f2fd0b700d3085b45" translate="yes" xml:space="preserve">
          <source>The rate descriptions used in &lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; may include &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt; or &lt;code&gt;day&lt;/code&gt; as the throttle period.</source>
          <target state="translated">&lt;code&gt;DEFAULT_THROTTLE_RATES&lt;/code&gt; 에 사용 된 비율 설명 에는 조절 기간으로 &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; 또는 &lt;code&gt;day&lt;/code&gt; 이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="456e79e1e5ba46e9b3009e48a7d640da55f2cd74" translate="yes" xml:space="preserve">
          <source>The rendered content of the response. The &lt;code&gt;.render()&lt;/code&gt; method must have been called before &lt;code&gt;.content&lt;/code&gt; can be accessed.</source>
          <target state="translated">응답의 렌더링 된 컨텐츠입니다. &lt;code&gt;.render()&lt;/code&gt; 전에 메소드가 호출되어 있어야합니다 &lt;code&gt;.content&lt;/code&gt; 가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9eaacd1846e8b2811647a7dbc55f13dee5744" translate="yes" xml:space="preserve">
          <source>The renderer classes that are supported when building test requests.</source>
          <target state="translated">테스트 요청을 빌드 할 때 지원되는 렌더러 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7648fe93f2b5fe148c7f898589a2d6a298cb95a6" translate="yes" xml:space="preserve">
          <source>The renderer instance that was selected by the content negotiation stage.</source>
          <target state="translated">컨텐츠 협상 단계에서 선택된 렌더러 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="c6a7f6a71b09f7fea8269b8354d498287af0646c" translate="yes" xml:space="preserve">
          <source>The renderer instance that will be used to render the response.</source>
          <target state="translated">응답을 렌더링하는 데 사용되는 렌더러 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="5ab85dbcefee164215f1afe1b4a711c7bcfc3b4b" translate="yes" xml:space="preserve">
          <source>The renderers used by the &lt;code&gt;Response&lt;/code&gt; class cannot natively handle complex datatypes such as Django model instances, so you need to serialize the data into primitive datatypes before creating the &lt;code&gt;Response&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Response&lt;/code&gt; 클래스가 사용하는 렌더러 는 Django 모델 인스턴스와 같은 복잡한 데이터 유형을 기본적으로 처리 할 수 ​​없으므로 &lt;code&gt;Response&lt;/code&gt; 객체 를 만들기 전에 데이터를 기본 데이터 유형으로 직렬화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c40f6c5c19db9df61f58c981bcb798bb23761f5e" translate="yes" xml:space="preserve">
          <source>The request data, as set by the &lt;code&gt;Response()&lt;/code&gt; instantiation.</source>
          <target state="translated">&lt;code&gt;Response()&lt;/code&gt; 인스턴스화에 의해 설정된 요청 데이터</target>
        </trans-unit>
        <trans-unit id="d3040e779a641d2f890064cf80950850c1ad025a" translate="yes" xml:space="preserve">
          <source>The request exposes some properties that allow you to determine the result of the content negotiation stage. This allows you to implement behaviour such as selecting a different serialisation schemes for different media types.</source>
          <target state="translated">요청에는 컨텐츠 협상 단계의 결과를 판별 할 수있는 일부 특성이 표시됩니다. 이를 통해 다른 매체 유형에 대해 다른 직렬화 체계를 선택하는 등의 동작을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083ea84b8f4fb00aa23deec18c746eb32ee91a92" translate="yes" xml:space="preserve">
          <source>The request was not successfully authenticated, and the highest priority authentication class &lt;em&gt;does not&lt;/em&gt; use &lt;code&gt;WWW-Authenticate&lt;/code&gt; headers. &lt;em&gt;&amp;mdash; An HTTP 403 Forbidden response will be returned.&lt;/em&gt;</source>
          <target state="translated">요청이 성공적으로 인증 &lt;em&gt;되지 않았으며&lt;/em&gt; 우선 순위가 가장 높은 인증 클래스 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더를 사용 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;em&gt;&amp;mdash; HTTP 403 금지 된 응답이 반환됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5522f5b5aacff8f16e12fc7d8ed092bb5e49874" translate="yes" xml:space="preserve">
          <source>The request was not successfully authenticated, and the highest priority authentication class &lt;em&gt;does&lt;/em&gt; use &lt;code&gt;WWW-Authenticate&lt;/code&gt; headers. &lt;em&gt;&amp;mdash; An HTTP 401 Unauthorized response, with an appropriate &lt;code&gt;WWW-Authenticate&lt;/code&gt; header will be returned.&lt;/em&gt;</source>
          <target state="translated">요청이 성공적으로 인증되지 않은, 그리고 우선 순위가 가장 높은 인증 클래스는 &lt;em&gt;않습니다&lt;/em&gt; 사용 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더를. &lt;em&gt;&amp;mdash; 적절한 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 있는 HTTP 401 Unauthorized 응답 이 반환됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a8b47bf138a3f3bf3bd6371ea77b8658bfd7c73" translate="yes" xml:space="preserve">
          <source>The request was successfully authenticated, but permission was denied. &lt;em&gt;&amp;mdash; An HTTP 403 Forbidden response will be returned.&lt;/em&gt;</source>
          <target state="translated">요청이 성공적으로 인증되었지만 권한이 거부되었습니다. &lt;em&gt;&amp;mdash; HTTP 403 금지 된 응답이 반환됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fed14e3dafadbda11a9de8e8c94df0bd4970161" translate="yes" xml:space="preserve">
          <source>The return result of calling &lt;code&gt;view.get_template_names()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;view.get_template_names()&lt;/code&gt; 호출의 반환 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="852062cf80575fcec39f6d3c329a284fc4bdec82" translate="yes" xml:space="preserve">
          <source>The return value of this method should the object that corresponds to the matched URL conf arguments.</source>
          <target state="translated">이 메소드의 리턴 값은 일치하는 URL conf 인수에 해당하는 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b3247651ae7e671e721e068a14d1c4adf12311e4" translate="yes" xml:space="preserve">
          <source>The right way to deal with this is to specify the field explicitly on the serializer, providing both the &lt;code&gt;read_only=True&lt;/code&gt; and &lt;code&gt;default=&amp;hellip;&lt;/code&gt; keyword arguments.</source>
          <target state="translated">이를 처리하는 올바른 방법은 serializer에서 필드를 명시 적으로 지정하여 &lt;code&gt;read_only=True&lt;/code&gt; 및 &lt;code&gt;default=&amp;hellip;&lt;/code&gt; 키워드 인수를 모두 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5e2f198a421b993e25f106bc67a6258811c22928" translate="yes" xml:space="preserve">
          <source>The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.</source>
          <target state="translated">Manager가 제공 한 루트 QuerySet은 데이터베이스 테이블의 모든 개체를 설명합니다. 그러나 일반적으로 전체 개체 집합의 하위 집합 만 선택하면됩니다.</target>
        </trans-unit>
        <trans-unit id="69de271ab634226fc5389524a24edd9172d2d7b1" translate="yes" xml:space="preserve">
          <source>The root of our API is going to be a view that supports listing all the existing snippets, or creating a new snippet.</source>
          <target state="translated">API의 근본은 기존의 모든 스 니펫을 나열하거나 새 스 니펫을 만드는 것을 지원하는 뷰가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="ffd49cc64e3fa62d3dcd84e4cb57ef8ad5b370a2" translate="yes" xml:space="preserve">
          <source>The root of our API refers to &lt;code&gt;'user-list'&lt;/code&gt; and &lt;code&gt;'snippet-list'&lt;/code&gt;.</source>
          <target state="translated">API의 루트는 &lt;code&gt;'user-list'&lt;/code&gt; 및 &lt;code&gt;'snippet-list'&lt;/code&gt; 를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="7d7de6ff51a16f76eaf46e9dc2071685167c0b3f" translate="yes" xml:space="preserve">
          <source>The router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the &lt;code&gt;lookup_value_regex&lt;/code&gt; attribute on the viewset. For example, you can limit the lookup to valid UUIDs:</source>
          <target state="translated">라우터는 슬래시 및 마침표 문자를 제외한 모든 문자를 포함하는 조회 값과 일치합니다. 보다 제한적인 (또는 관대 한) 조회 패턴을 보려면 viewset 에서 &lt;code&gt;lookup_value_regex&lt;/code&gt; 속성을 설정하십시오 . 예를 들어 조회를 유효한 UUID로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d7b0dda2bce034ea0b775b619474fe097e269d" translate="yes" xml:space="preserve">
          <source>The search behavior may be restricted by prepending various characters to the &lt;code&gt;search_fields&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;search_fields&lt;/code&gt; 앞에 다양한 문자를 추가하여 검색 동작을 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76aa6f487e81d3724bdd471430a8e48b59e38557" translate="yes" xml:space="preserve">
          <source>The serializer field class that should be used for any &lt;code&gt;url&lt;/code&gt; field on the serializer.</source>
          <target state="translated">시리얼 라이저의 &lt;code&gt;url&lt;/code&gt; 필드에 사용해야하는 시리얼 라이저 필드 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2c27c88ce3562a5c0bb4f352343fe42610b6fc6d" translate="yes" xml:space="preserve">
          <source>The serializer field class that should be used for any choice fields on the serializer.</source>
          <target state="translated">직렬 변환기의 선택 필드에 사용해야하는 직렬 변환기 필드 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7bc3c8320ee6711894b76b3f0b0f5cb515319946" translate="yes" xml:space="preserve">
          <source>The serializer method referred to by the &lt;code&gt;method_name&lt;/code&gt; argument should accept a single argument (in addition to &lt;code&gt;self&lt;/code&gt;), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:</source>
          <target state="translated">&lt;code&gt;method_name&lt;/code&gt; 인수로 참조되는 serializer 메소드 는 직렬화되는 오브젝트 인 &lt;code&gt;self&lt;/code&gt; 외에도 단일 인수를 허용해야합니다 . 객체의 직렬화 된 표현에 포함 할 항목을 반환해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="719648f5906465227e804f6ef423bb1dfa46381c" translate="yes" xml:space="preserve">
          <source>The serializers in REST framework work very similarly to Django's &lt;code&gt;Form&lt;/code&gt; and &lt;code&gt;ModelForm&lt;/code&gt; classes. We provide a &lt;code&gt;Serializer&lt;/code&gt; class which gives you a powerful, generic way to control the output of your responses, as well as a &lt;code&gt;ModelSerializer&lt;/code&gt; class which provides a useful shortcut for creating serializers that deal with model instances and querysets.</source>
          <target state="translated">REST 프레임 워크의 serializer는 Django의 &lt;code&gt;Form&lt;/code&gt; 및 &lt;code&gt;ModelForm&lt;/code&gt; 클래스 와 매우 유사하게 작동 합니다. 응답의 출력을 제어하는 ​​강력하고 일반적인 방법을 제공하는 &lt;code&gt;Serializer&lt;/code&gt; 클래스 와 모델 인스턴스 및 쿼리 집합을 처리하는 Serializer를 만드는 데 유용한 바로 가기를 제공하는 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a417e5154977c4b34887c76cf6e419852f8965e8" translate="yes" xml:space="preserve">
          <source>The set of valid parsers for a view is always defined as a list of classes. When &lt;code&gt;request.data&lt;/code&gt; is accessed, REST framework will examine the &lt;code&gt;Content-Type&lt;/code&gt; header on the incoming request, and determine which parser to use to parse the request content.</source>
          <target state="translated">뷰의 유효한 파서 세트는 항상 클래스 목록으로 정의됩니다. 때 &lt;code&gt;request.data&lt;/code&gt; 가 액세스 할 수 있습니다, REST 프레임 워크는 검토 할 것이다 &lt;code&gt;Content-Type&lt;/code&gt; 들어오는 요청에 헤더를하고, 요청 내용을 분석하는 데 사용할 파서 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0c38e3b90c0bd187367ae43a4a3a4b004447c014" translate="yes" xml:space="preserve">
          <source>The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.</source>
          <target state="translated">뷰에 유효한 렌더러 세트는 항상 클래스 목록으로 정의됩니다. 뷰가 입력되면 REST 프레임 워크는 들어오는 요청에 대해 컨텐츠 협상을 수행하고 요청을 충족시키는 가장 적합한 렌더러를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5ccf58d7d99a90f3379e7e9a88ba190474fd664c" translate="yes" xml:space="preserve">
          <source>The signature for the method is &lt;code&gt;force_authenticate(request, user=None, token=None)&lt;/code&gt;. When making the call, either or both of the user and token may be set.</source>
          <target state="translated">메소드의 서명은 &lt;code&gt;force_authenticate(request, user=None, token=None)&lt;/code&gt; 입니다. 전화를 걸 때 사용자와 토큰 중 하나 또는 둘 다를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c10f5fe7e17f9cb21d16ba85279a26fb36bc164" translate="yes" xml:space="preserve">
          <source>The signatures for these methods are as follows:</source>
          <target state="translated">이러한 방법의 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1ac635c362edd2ae6055a46bf5447cf0dc3a4fe" translate="yes" xml:space="preserve">
          <source>The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the &lt;code&gt;IsAuthenticated&lt;/code&gt; class in REST framework.</source>
          <target state="translated">가장 간단한 권한 스타일은 인증 된 사용자에 대한 액세스를 허용하고 인증되지 않은 사용자에 대한 액세스를 거부하는 것입니다. 이것은 REST 프레임 워크 의 &lt;code&gt;IsAuthenticated&lt;/code&gt; 클래스에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="759b398d6eb3724d25990c413b1d617b29f0b396" translate="yes" xml:space="preserve">
          <source>The simplest way to filter the queryset of any view that subclasses &lt;code&gt;GenericAPIView&lt;/code&gt; is to override the &lt;code&gt;.get_queryset()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;GenericAPIView&lt;/code&gt; 를 서브 클래 싱하는 모든 뷰의 쿼리 세트를 필터링하는 가장 간단한 방법 은 &lt;code&gt;.get_queryset()&lt;/code&gt; 메소드 를 대체하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a20bf40867c7030548ebafc33c77a09e40ca03af" translate="yes" xml:space="preserve">
          <source>The simplest way to implement a custom router is to subclass one of the existing router classes. The &lt;code&gt;.routes&lt;/code&gt; attribute is used to template the URL patterns that will be mapped to each viewset. The &lt;code&gt;.routes&lt;/code&gt; attribute is a list of &lt;code&gt;Route&lt;/code&gt; named tuples.</source>
          <target state="translated">사용자 정의 라우터를 구현하는 가장 간단한 방법은 기존 라우터 클래스 중 하나를 서브 클래 싱하는 것입니다. &lt;code&gt;.routes&lt;/code&gt; 의 속성은 각 뷰셋에 매핑되는 URL 패턴을 템플릿하는 데 사용됩니다. &lt;code&gt;.routes&lt;/code&gt; 의 속성의 목록입니다 &lt;code&gt;Route&lt;/code&gt; 이름 튜플.</target>
        </trans-unit>
        <trans-unit id="07da0e7e9a5e0b966d074c28d1b4f46ee3d9c701" translate="yes" xml:space="preserve">
          <source>The string that should used for any versioning parameters, such as in the media type or URL query parameters.</source>
          <target state="translated">미디어 유형 또는 URL 쿼리 매개 변수와 같은 버전 관리 매개 변수에 사용해야하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="73001c6208b9b2a3486943d1f82eda84589cc29c" translate="yes" xml:space="preserve">
          <source>The template name is determined by (in order of preference):</source>
          <target state="translated">템플릿 이름은 다음과 같은 순서로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="96ca0bd780d33b41174e6c633e1ff0925f87afdc" translate="yes" xml:space="preserve">
          <source>The throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/settings/#caches&quot;&gt;cache settings&lt;/a&gt;. The default value of &lt;code&gt;LocMemCache&lt;/code&gt; backend should be okay for simple setups. See Django's &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/cache/#setting-up-the-cache&quot;&gt;cache documentation&lt;/a&gt; for more details.</source>
          <target state="translated">REST 프레임 워크에서 제공하는 스로틀 클래스는 Django의 캐시 백엔드를 사용합니다. 적절한 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/settings/#caches&quot;&gt;캐시 설정을 설정&lt;/a&gt; 했는지 확인해야합니다 . 간단한 설정 의 경우 &lt;code&gt;LocMemCache&lt;/code&gt; 백엔드 의 기본값 은 괜찮습니다. 자세한 내용은 Django의 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/cache/#setting-up-the-cache&quot;&gt;캐시 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fddae34f04d831988e0dc4ad9cc9cfdda3bb3a62" translate="yes" xml:space="preserve">
          <source>The tutorial is fairly in-depth, so you should probably get a cookie and a cup of your favorite brew before getting started. If you just want a quick overview, you should head over to the &lt;a href=&quot;../quickstart/index&quot;&gt;quickstart&lt;/a&gt; documentation instead.</source>
          <target state="translated">이 튜토리얼은 상당히 심층적이므로 시작하기 전에 쿠키와 좋아하는 맥주 한잔을 받아야합니다. 빠른 개요 만 원하면 빠른 &lt;a href=&quot;../quickstart/index&quot;&gt;시작&lt;/a&gt; 설명서로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="faa9007e2f47e2ab6770b9eddc3fca18c378e266" translate="yes" xml:space="preserve">
          <source>The two new actions will then be available at the urls &lt;code&gt;^users/{pk}/set_password/$&lt;/code&gt; and &lt;code&gt;^users/{pk}/unset_password/$&lt;/code&gt;</source>
          <target state="translated">그러면 &lt;code&gt;^users/{pk}/set_password/$&lt;/code&gt; 및 &lt;code&gt;^users/{pk}/unset_password/$&lt;/code&gt; 에서 두 가지 새로운 작업을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d37d5cd354b2c3295c52d47f70d5cb90fe6ddf53" translate="yes" xml:space="preserve">
          <source>The unrendered, serialized data of the response.</source>
          <target state="translated">렌더링되지 않은 일련의 응답 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="bd3b1f15448748784cd3ac8233e6046f2ce37cd7" translate="yes" xml:space="preserve">
          <source>The url field will be represented using a &lt;code&gt;HyperlinkedIdentityField&lt;/code&gt; serializer field, and any relationships on the model will be represented using a &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; serializer field.</source>
          <target state="translated">url 필드는 &lt;code&gt;HyperlinkedIdentityField&lt;/code&gt; serializer 필드를 사용하여 표현되며 모델의 모든 관계는 &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; serializer 필드를 사용하여 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e88251bfe40066425c977ca33b87aaf2a4a775de" translate="yes" xml:space="preserve">
          <source>The validator should be applied to &lt;em&gt;serializer classes&lt;/em&gt;, like so:</source>
          <target state="translated">유효성 검사기는 다음 과 같이 &lt;em&gt;serializer 클래스에&lt;/em&gt; 적용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b89d6376af52792763950ccbc22cf43f4b2674e9" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;source='*'&lt;/code&gt; has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.</source>
          <target state="translated">&lt;code&gt;source='*'&lt;/code&gt; 값 은 특별한 의미를 가지며 전체 오브젝트가 필드로 전달되어야 함을 나타내는 데 사용됩니다. 중첩 표현을 생성하거나 출력 표현을 결정하기 위해 전체 객체에 액세스해야하는 필드에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3414cdcac91a9f74e2e34441065782518dc7105" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;request.user&lt;/code&gt; and &lt;code&gt;request.auth&lt;/code&gt; for unauthenticated requests can be modified using the &lt;code&gt;UNAUTHENTICATED_USER&lt;/code&gt; and &lt;code&gt;UNAUTHENTICATED_TOKEN&lt;/code&gt; settings.</source>
          <target state="translated">인증되지 않은 요청 의 &lt;code&gt;request.user&lt;/code&gt; 및 &lt;code&gt;request.auth&lt;/code&gt; 값은 &lt;code&gt;UNAUTHENTICATED_USER&lt;/code&gt; 및 &lt;code&gt;UNAUTHENTICATED_TOKEN&lt;/code&gt; 설정을 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="319a31d096458414e5a8ce61447148256077dfea" translate="yes" xml:space="preserve">
          <source>The value that should be used for &lt;code&gt;request.version&lt;/code&gt; when no versioning information is present.</source>
          <target state="translated">버전 정보가없는 경우 &lt;code&gt;request.version&lt;/code&gt; 에 사용해야하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5721e190db4b7107f1ddd46f46f6b9e702adffc3" translate="yes" xml:space="preserve">
          <source>The versioning scheme is defined by the &lt;code&gt;DEFAULT_VERSIONING_CLASS&lt;/code&gt; settings key.</source>
          <target state="translated">버전 관리 체계는 &lt;code&gt;DEFAULT_VERSIONING_CLASS&lt;/code&gt; 설정 키로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4ab92e83f94f13aa86a81f10a75ef403da1d270" translate="yes" xml:space="preserve">
          <source>The view classes can be imported from &lt;code&gt;rest_framework.generics&lt;/code&gt;.</source>
          <target state="translated">뷰 클래스는 &lt;code&gt;rest_framework.generics&lt;/code&gt; 에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99426c015c42acee053a9df62b41415cbf0895db" translate="yes" xml:space="preserve">
          <source>The way we deal with that is by overriding a &lt;code&gt;.perform_create()&lt;/code&gt; method on our snippet views, that allows us to modify how the instance save is managed, and handle any information that is implicit in the incoming request or requested URL.</source>
          <target state="translated">이를 처리하는 방법은 스 니펫보기에서 &lt;code&gt;.perform_create()&lt;/code&gt; 메소드를 대체 하여 인스턴스 저장 관리 방법을 수정하고 수신 요청 또는 요청 된 URL에 내재 된 정보를 처리 할 수 ​​있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b91d41730b792c01926cf2e35da8a0d5cd8c2b35" translate="yes" xml:space="preserve">
          <source>The wrappers also provide behaviour such as returning &lt;code&gt;405 Method Not Allowed&lt;/code&gt; responses when appropriate, and handling any &lt;code&gt;ParseError&lt;/code&gt; exception that occurs when accessing &lt;code&gt;request.data&lt;/code&gt; with malformed input.</source>
          <target state="translated">래퍼는 적절한 경우 &lt;code&gt;405 Method Not Allowed&lt;/code&gt; 응답 을 반환 하고 잘못된 입력으로 &lt;code&gt;request.data&lt;/code&gt; 에 액세스 할 때 발생 하는 &lt;code&gt;ParseError&lt;/code&gt; 예외를 처리하는 등의 동작을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="c665f50a1290c2a38a1b80e97c2b93fbaab347e8" translate="yes" xml:space="preserve">
          <source>Then configure your settings to use this custom class:</source>
          <target state="translated">그런 다음이 사용자 정의 클래스를 사용하도록 설정을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="800692dfa5dbc547a38da9b343d295b1d9a189c7" translate="yes" xml:space="preserve">
          <source>Then, add the following property to &lt;strong&gt;both&lt;/strong&gt; the &lt;code&gt;SnippetList&lt;/code&gt; and &lt;code&gt;SnippetDetail&lt;/code&gt; view classes.</source>
          <target state="translated">그런 다음에 다음 속성을 추가 &lt;strong&gt;모두 &lt;/strong&gt; &lt;code&gt;SnippetList&lt;/code&gt; 및 &lt;code&gt;SnippetDetail&lt;/code&gt; 보기 클래스.</target>
        </trans-unit>
        <trans-unit id="52443848c8e84c77d3298bc320c87a6bc90aa889" translate="yes" xml:space="preserve">
          <source>There &lt;em&gt;are&lt;/em&gt; a few use cases when you might want to customize the &lt;code&gt;ListSerializer&lt;/code&gt; behavior. For example:</source>
          <target state="translated">이 &lt;em&gt;있습니다&lt;/em&gt; 당신은 사용자 정의 할 수있는 몇 가지 사용 사례 &lt;code&gt;ListSerializer&lt;/code&gt; 의 행동은. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eed48aaac6b60eb229e4d3bf0b20603ff3674533" translate="yes" xml:space="preserve">
          <source>There are a couple of reasons that you might choose to take this approach, including that &lt;code&gt;OPTIONS&lt;/code&gt; responses &lt;a href=&quot;https://www.mnot.net/blog/2012/10/29/NO_OPTIONS&quot;&gt;are not cacheable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 응답 &lt;a href=&quot;https://www.mnot.net/blog/2012/10/29/NO_OPTIONS&quot;&gt;을 캐시 할 수 없다는&lt;/a&gt; 것을 포함하여이 접근법을 선택하는 데는 몇 가지 이유가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb76409cb90ffdc2770af55b81641e6da948c63" translate="yes" xml:space="preserve">
          <source>There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using &lt;code&gt;ModelSerializer&lt;/code&gt; you'll probably simply rely on the defaults that REST framework generates for you, but if you are using &lt;code&gt;Serializer&lt;/code&gt; or simply want more explicit control, use on of the styles demonstrated below.</source>
          <target state="translated">API의 작동 방식에 따라 몇 가지 스타일을 사용할 수 있습니다. &lt;code&gt;ModelSerializer&lt;/code&gt; 를 사용 하는 경우 REST 프레임 워크가 생성하는 기본값에 의존 할 수 있지만 &lt;code&gt;Serializer&lt;/code&gt; 를 사용 하거나보다 명시적인 제어를 원하는 경우 아래에 설명 된 스타일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="84de9cd689fc3d1c9cb8d9e25964145f6d43b198" translate="yes" xml:space="preserve">
          <source>There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.</source>
          <target state="translated">API 예외 상태를 검사하는 데 사용할 수있는 여러 가지 속성이 있습니다. 이를 사용하여 프로젝트에 대한 사용자 정의 예외 처리를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a226d302363cd53ab13a25e4c62566bcb3feb589" translate="yes" xml:space="preserve">
          <source>There are a number of valid approaches to approaching versioning. &lt;a href=&quot;https://www.infoq.com/articles/roy-fielding-on-versioning&quot;&gt;Non-versioned systems can also be appropriate&lt;/a&gt;, particularly if you're engineering for very long-term systems with multiple clients outside of your control.</source>
          <target state="translated">버전 관리에 대한 여러 가지 유효한 접근 방식이 있습니다. &lt;a href=&quot;https://www.infoq.com/articles/roy-fielding-on-versioning&quot;&gt;비 버전 시스템은&lt;/a&gt; 특히 제어 할 수없는 여러 클라이언트가있는 매우 장기적인 시스템을 위해 엔지니어링하는 경우에 적합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e25fa7cb12a7fba9796ef2eb2eb74bd9ab881324" translate="yes" xml:space="preserve">
          <source>There are four methods that can be overridden, depending on what functionality you want the serializer class to support:</source>
          <target state="translated">serializer 클래스가 지원할 기능에 따라 재정의 할 수있는 네 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52511b4ddcac7b84065ef33ed599e1a3e11b8a41" translate="yes" xml:space="preserve">
          <source>There are however, third-party packages available such as &lt;a href=&quot;index#drf-writable-nested&quot;&gt;DRF Writable Nested&lt;/a&gt; that support automatic writable nested representations.</source>
          <target state="translated">그러나 자동 쓰기 가능 중첩 표현을 지원하는 &lt;a href=&quot;index#drf-writable-nested&quot;&gt;DRF Writable Nested&lt;/a&gt; 와 같은 타사 패키지를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd0592390fb76651f9090f8cb4373452b68675c3" translate="yes" xml:space="preserve">
          <source>There are not currently any widely adopted conventions for exactly what style of response should be returned for HTTP &lt;code&gt;OPTIONS&lt;/code&gt; requests, so we provide an ad-hoc style that returns some useful information.</source>
          <target state="translated">HTTP &lt;code&gt;OPTIONS&lt;/code&gt; 요청에 대해 정확히 어떤 스타일의 응답을 반환해야하는지에 대해 널리 채택 된 규칙이 없으므로 유용한 정보를 반환하는 특별 스타일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0a212c97d9712043063f4500bedce412868a7b8" translate="yes" xml:space="preserve">
          <source>There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that &lt;code&gt;ModelSerializer&lt;/code&gt; generates.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 가 생성 하는 기본 serializer 클래스에 의존하지 않고 명시 적으로 유효성 검사를 처리해야하는 모호한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88a46a18908ca88bb9f1cb0efebe67cd74021822" translate="yes" xml:space="preserve">
          <source>There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.</source>
          <target state="translated">직렬화되는 객체 외에 직렬 변환기에 추가 컨텍스트를 제공해야하는 경우가 있습니다. 하나의 일반적인 경우는 하이퍼 링크 관계가 포함 된 직렬 변환기를 사용하는 경우입니다. 직렬 변환기는 정규화 된 URL을 올바르게 생성 할 수 있도록 현재 요청에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1303f6354ad7bda56bce6c271f8a140d64888398" translate="yes" xml:space="preserve">
          <source>There are two keyword arguments you can use to control this behavior:</source>
          <target state="translated">이 동작을 제어하는 ​​데 사용할 수있는 키워드 인수는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3c2f7c24bc1f663618b6338c6211e2de9fe722b" translate="yes" xml:space="preserve">
          <source>There are two main advantages of using a &lt;code&gt;ViewSet&lt;/code&gt; class over using a &lt;code&gt;View&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;View&lt;/code&gt; 클래스 를 사용하는 것보다 &lt;code&gt;ViewSet&lt;/code&gt; 클래스를 사용하면 두 가지 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff13b6f5585b594f16800126978bb0e098798041" translate="yes" xml:space="preserve">
          <source>There are two mandatory arguments to the &lt;code&gt;register()&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;register()&lt;/code&gt; 메소드 에는 두 가지 필수 인수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30d36364138462fbe533496900143c37f86839e8" translate="yes" xml:space="preserve">
          <source>There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the &lt;code&gt;extra_kwargs&lt;/code&gt; option. As in the case of &lt;code&gt;read_only_fields&lt;/code&gt;, this means you do not need to explicitly declare the field on the serializer.</source>
          <target state="translated">&lt;code&gt;extra_kwargs&lt;/code&gt; 옵션을 사용하여 필드에 임의의 추가 키워드 인수를 지정할 수있는 바로 가기도 있습니다. &lt;code&gt;read_only_fields&lt;/code&gt; 의 경우와 같이 직렬 변환기에서 필드를 명시 적으로 선언 할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="becdead33c3eaede60d5dec9f854cbd24e1cd2da" translate="yes" xml:space="preserve">
          <source>There needs to be a way of determining which views should be used for hyperlinking to model instances.</source>
          <target state="translated">모델 인스턴스에 대한 하이퍼 링크에 사용할 뷰를 결정하는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a265b915715e307d76dd977d77ee1b9fcc288cf4" translate="yes" xml:space="preserve">
          <source>There seems to be a view among some of the Web community that filename extensions are not a RESTful pattern, and that &lt;code&gt;HTTP Accept&lt;/code&gt; headers should always be used instead.</source>
          <target state="translated">일부 웹 커뮤니티에는 파일 이름 확장자가 RESTful 패턴이 아니며 &lt;code&gt;HTTP Accept&lt;/code&gt; 헤더가 항상 대신 사용되어야한다는 견해 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b225e35c221345741fb91dde2b5f882db4e9fd4b" translate="yes" xml:space="preserve">
          <source>There's no ambiguity about the meaning of the string when it's found in representations such as JSON that do not have a native URI type.</source>
          <target state="translated">기본 URI 유형이없는 JSON과 같은 표현에서 문자열이 발견 될 때 문자열의 의미에 대해 모호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d518928cfe5ed730b8e51d84a547b6138bc4066d" translate="yes" xml:space="preserve">
          <source>There's no requirement for you to use the &lt;code&gt;Response&lt;/code&gt; class, you can also return regular &lt;code&gt;HttpResponse&lt;/code&gt; or &lt;code&gt;StreamingHttpResponse&lt;/code&gt; objects from your views if required. Using the &lt;code&gt;Response&lt;/code&gt; class simply provides a nicer interface for returning content-negotiated Web API responses, that can be rendered to multiple formats.</source>
          <target state="translated">&lt;code&gt;Response&lt;/code&gt; 클래스 를 사용할 필요는 없으며 필요한 경우 뷰에서 일반 &lt;code&gt;HttpResponse&lt;/code&gt; 또는 &lt;code&gt;StreamingHttpResponse&lt;/code&gt; 객체를 반환 할 수도 있습니다 . &lt;code&gt;Response&lt;/code&gt; 클래스를 사용하면 여러 가지 형식으로 렌더링 할 수있는 컨텐츠 협상 된 웹 API 응답을 리턴하기위한 더 좋은 인터페이스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c4109a0fef8547986475167deff5e27d8b8916b0" translate="yes" xml:space="preserve">
          <source>There's no requirement for you to use them, but if you do then the self-describing API will be able to automatically hyperlink its output for you, which makes browsing the API much easier.</source>
          <target state="translated">그것들을 사용할 필요는 없지만, 그렇게하면 자체 설명 API가 자동으로 출력을 하이퍼 링크하여 API를 훨씬 쉽게 찾아 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="319c11b3f446a365368192eaa48f129d100ebd46" translate="yes" xml:space="preserve">
          <source>These decorators correspond to the attributes set on &lt;code&gt;APIView&lt;/code&gt; subclasses, described above.</source>
          <target state="translated">이 데코레이터 는 위에서 설명한 &lt;code&gt;APIView&lt;/code&gt; 서브 클래스에 설정된 속성에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="65f52b15224f69daefd4f9bbacc9f8d2a28fbda2" translate="yes" xml:space="preserve">
          <source>These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return &lt;code&gt;HTTP 400 Bad Request&lt;/code&gt; responses by default.</source>
          <target state="translated">이러한 예외는 REST 프레임 워크가 제공하는 기본 예외 핸들러에 의해 자동으로 처리되며 기본적으로 &lt;code&gt;HTTP 400 Bad Request&lt;/code&gt; 응답을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f9c848422e2c2c9b424f8cb1148624bde5dbde57" translate="yes" xml:space="preserve">
          <source>These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.</source>
          <target state="translated">이러한 후크는 요청에 암시 적이지만 요청 데이터의 일부가 아닌 속성을 설정하는 데 특히 유용합니다. 예를 들어 요청 사용자 또는 URL 키워드 인수를 기반으로 객체에 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7d3acb8bf5aa0a5f66677288d7276fa87d4c88" translate="yes" xml:space="preserve">
          <source>These methods take a single argument, which is the field value that requires validation.</source>
          <target state="translated">이러한 메소드는 단일 인수를 사용하는데, 이는 유효성 검증이 필요한 필드 값입니다.</target>
        </trans-unit>
        <trans-unit id="9ecbb612c5c18fbaa52176bcf6ff26e593ff1462" translate="yes" xml:space="preserve">
          <source>These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.</source>
          <target state="translated">이러한 재정의 지점은 확인 전자 메일 보내기 또는 업데이트 로깅과 같이 개체 저장 전후에 발생하는 동작을 추가하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d54c2d88e001e4447c80c176ace95b41bc99bd1c" translate="yes" xml:space="preserve">
          <source>These validators can be used to enforce the &lt;code&gt;unique_for_date&lt;/code&gt;, &lt;code&gt;unique_for_month&lt;/code&gt; and &lt;code&gt;unique_for_year&lt;/code&gt; constraints on model instances. They take the following arguments:</source>
          <target state="translated">이 유효성 검증기를 사용하여 모델 인스턴스에 &lt;code&gt;unique_for_date&lt;/code&gt; , &lt;code&gt;unique_for_month&lt;/code&gt; 및 &lt;code&gt;unique_for_year&lt;/code&gt; 제한 조건 을 시행 할 수 있습니다 . 그들은 다음과 같은 주장을 취합니다.</target>
        </trans-unit>
        <trans-unit id="ee4ea7b952980e8c68e541690b31619ed700d5fd" translate="yes" xml:space="preserve">
          <source>These wrappers provide a few bits of functionality such as making sure you receive &lt;code&gt;Request&lt;/code&gt; instances in your view, and adding context to &lt;code&gt;Response&lt;/code&gt; objects so that content negotiation can be performed.</source>
          <target state="translated">이 랩퍼는 보기에서 &lt;code&gt;Request&lt;/code&gt; 인스턴스 를 수신 하고 컨텐츠 협상을 수행 할 수 있도록 &lt;code&gt;Response&lt;/code&gt; 오브젝트에 컨텍스트를 추가하는 것과 같은 몇 가지 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="de062256144cf2ddc652c999a1a3cc23ad27abd2" translate="yes" xml:space="preserve">
          <source>Third Party Packages</source>
          <target state="translated">타사 패키지</target>
        </trans-unit>
        <trans-unit id="20f4ac199b06202312761d625bc72a55712bba63" translate="yes" xml:space="preserve">
          <source>Third party packages</source>
          <target state="translated">타사 패키지</target>
        </trans-unit>
        <trans-unit id="cce041162d62ed67db5ea2e9a5ac9f21cd47f780" translate="yes" xml:space="preserve">
          <source>This API included the &lt;code&gt;.get_field()&lt;/code&gt;, &lt;code&gt;.get_pk_field()&lt;/code&gt; and other methods.</source>
          <target state="translated">이 API에는 &lt;code&gt;.get_field()&lt;/code&gt; , &lt;code&gt;.get_pk_field()&lt;/code&gt; 및 기타 메소드가 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="39b4494afddb31e377360ea296fca896dfe89de5" translate="yes" xml:space="preserve">
          <source>This also applies to extra actions for &lt;code&gt;ViewSet&lt;/code&gt;s:</source>
          <target state="translated">이는 &lt;code&gt;ViewSet&lt;/code&gt; 에 대한 추가 작업에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6048e0e058717abe4ccd1a4ab8f28c26ba998d04" translate="yes" xml:space="preserve">
          <source>This authentication scheme allows you to delegate authentication to your web server, which sets the &lt;code&gt;REMOTE_USER&lt;/code&gt; environment variable.</source>
          <target state="translated">이 인증 체계를 사용하면 웹 서버에 인증을 위임하여 &lt;code&gt;REMOTE_USER&lt;/code&gt; 환경 변수 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77e8c262fc342d396eebbdf41fdadc027a82da7c" translate="yes" xml:space="preserve">
          <source>This authentication scheme uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;HTTP Basic Authentication&lt;/a&gt;, signed against a user's username and password. Basic authentication is generally only appropriate for testing.</source>
          <target state="translated">이 인증 체계는 사용자의 사용자 이름 및 비밀번호로 서명 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;HTTP 기본 인증을&lt;/a&gt; 사용 합니다. 기본 인증은 일반적으로 테스트에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3a391c83670f4d9762958b787c7ef3d2df6b827c" translate="yes" xml:space="preserve">
          <source>This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.</source>
          <target state="translated">이 인증 체계는 인증을 위해 Django의 기본 세션 백엔드를 사용합니다. 세션 인증은 웹 사이트와 동일한 세션 컨텍스트에서 실행중인 AJAX 클라이언트에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1580914db40fc46e11b7b8cb9f8f195a697f3de6" translate="yes" xml:space="preserve">
          <source>This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.</source>
          <target state="translated">이 인증 체계는 간단한 토큰 기반 HTTP 인증 체계를 사용합니다. 토큰 인증은 기본 데스크탑 및 모바일 클라이언트와 같은 클라이언트 서버 설정에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e7f47c7b0da6eae315696d5cb38dcb7acf1e05d2" translate="yes" xml:space="preserve">
          <source>This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.</source>
          <target state="translated">이 동작은 매우 많은 수의 관계가 표시되어 템플릿이 허용 가능한 시간 범위 내에 렌더링되지 않도록 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="69e0a7a4b67422eebeb801e6cf02f96ae643b8c0" translate="yes" xml:space="preserve">
          <source>This behavior is now replaced with &lt;em&gt;always&lt;/em&gt; using an explicit &lt;code&gt;queryset&lt;/code&gt; argument for writable relational fields.</source>
          <target state="translated">이 동작은 이제 쓰기 가능한 관계형 필드에 대해 명시적인 &lt;code&gt;queryset&lt;/code&gt; 인수를 사용하여 &lt;em&gt;항상&lt;/em&gt; 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="141c5f655e6433fd9c0de087b73fc326ebd482ef" translate="yes" xml:space="preserve">
          <source>This can be a useful shortcut if you're testing the API but don't want to have to construct valid authentication credentials in order to make test requests.</source>
          <target state="translated">API를 테스트하고 있지만 테스트 요청을하기 위해 유효한 인증 자격 증명을 구성하지 않으려는 경우 유용한 바로 가기가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162811af1723caaad4696884dac921281a39cba2" translate="yes" xml:space="preserve">
          <source>This cannot be represented with the default implementation, which accepts only a single lookup field.</source>
          <target state="translated">단일 조회 필드 만 허용하는 기본 구현으로 표시 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce775bcf4dcb8384209a057e378a7533fdba7005" translate="yes" xml:space="preserve">
          <source>This class extends REST framework's &lt;code&gt;APIView&lt;/code&gt; class, adding commonly required behavior for standard list and detail views.</source>
          <target state="translated">이 클래스 는 표준 프레임 워크 및 세부 사항보기에 일반적으로 필요한 동작을 추가하여 REST 프레임 워크의 &lt;code&gt;APIView&lt;/code&gt; 클래스를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="043446cc3a17d509a456a1bac346aad4c68463fb" translate="yes" xml:space="preserve">
          <source>This class implements the same basic API as the &lt;code&gt;Serializer&lt;/code&gt; class:</source>
          <target state="translated">이 클래스는 &lt;code&gt;Serializer&lt;/code&gt; 클래스 와 동일한 기본 API를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="2cadb61e843620c84a6ab2df10a7e9b4978bbebb" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response. There are no 1xx status codes used in REST framework by default.</source>
          <target state="translated">이 클래스의 상태 코드는 임시 응답을 나타냅니다. REST 프레임 워크에는 기본적으로 1xx 상태 코드가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="580605836db1e2ab1be5271c89492fb18ac39808" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</source>
          <target state="translated">이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was successfully received, understood, and accepted.</source>
          <target state="translated">이 상태 코드 클래스는 클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="311fcaffc30b26353c90ef0082ba71fb4c82735e" translate="yes" xml:space="preserve">
          <source>This custom field would then serialize to the following representation.</source>
          <target state="translated">이 사용자 정의 필드는 다음 표현으로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="2f4267a36379ec0b5206620f0b0d3fca3adfeb4c" translate="yes" xml:space="preserve">
          <source>This decorator takes a single &lt;code&gt;AutoSchema&lt;/code&gt; instance, an &lt;code&gt;AutoSchema&lt;/code&gt; subclass instance or &lt;code&gt;ManualSchema&lt;/code&gt; instance as described in the &lt;a href=&quot;../schemas/index&quot;&gt;Schemas documentation&lt;/a&gt;. You may pass &lt;code&gt;None&lt;/code&gt; in order to exclude the view from schema generation.</source>
          <target state="translated">이 데코레이터는 &lt;a href=&quot;../schemas/index&quot;&gt;스키마 문서에&lt;/a&gt; 설명 된대로 단일 &lt;code&gt;AutoSchema&lt;/code&gt; 인스턴스, &lt;code&gt;AutoSchema&lt;/code&gt; 하위 클래스 인스턴스 또는 &lt;code&gt;ManualSchema&lt;/code&gt; 인스턴스를 사용 합니다 . 스키마 생성에서보기를 제외하기 위해 &lt;code&gt;None&lt;/code&gt; 을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="440a666dc1032676e19571a9229ec63eb15c3b19" translate="yes" xml:space="preserve">
          <source>This exposes exactly the same interface as if you were using a requests session directly.</source>
          <target state="translated">요청 세션을 직접 사용하는 것과 동일한 인터페이스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e02240c151bdedb25fcb6dc7e8ad3d1ff865f7b" translate="yes" xml:space="preserve">
          <source>This field also takes an optional argument, &lt;code&gt;coerce_to_string&lt;/code&gt;. If set to &lt;code&gt;True&lt;/code&gt; the representation will be output as a string. If set to &lt;code&gt;False&lt;/code&gt; the representation will be left as a &lt;code&gt;Decimal&lt;/code&gt; instance and the final representation will be determined by the renderer.</source>
          <target state="translated">이 필드는 선택적 인수 &lt;code&gt;coerce_to_string&lt;/code&gt; 도 사용 합니다. &lt;code&gt;True&lt;/code&gt; 로 설정 하면 표현이 문자열로 출력됩니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 표현은 &lt;code&gt;Decimal&lt;/code&gt; 인스턴스 로 남고 최종 표현은 렌더러에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="fed717ff9ab5bfd32218f4d04f26e163413b3f20" translate="yes" xml:space="preserve">
          <source>This field can be applied as an identity relationship, such as the &lt;code&gt;'url'&lt;/code&gt; field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:</source>
          <target state="translated">이 필드는 HyperlinkedModelSerializer 의 &lt;code&gt;'url'&lt;/code&gt; 필드 와 같은 ID 관계로 적용될 수 있습니다 . 객체의 속성에도 사용할 수 있습니다. 예를 들어 다음 직렬 변환기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3427d694db82f2473c224e954edf48abe49a9823" translate="yes" xml:space="preserve">
          <source>This field is always read-only.</source>
          <target state="translated">이 필드는 항상 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="828696c601d2f32c2b5336c70cab206c27da5d68" translate="yes" xml:space="preserve">
          <source>This field is doing something quite interesting. The &lt;code&gt;source&lt;/code&gt; argument controls which attribute is used to populate a field, and can point at any attribute on the serialized instance. It can also take the dotted notation shown above, in which case it will traverse the given attributes, in a similar way as it is used with Django's template language.</source>
          <target state="translated">이 분야는 꽤 흥미로운 일을하고 있습니다. &lt;code&gt;source&lt;/code&gt; 하는 속성 인수 컨트롤 필드를 채우는 데 사용되며, 직렬화 된 인스턴스의 모든 속성에 가리킬 수 있습니다. 위에 표시된 점 표기법을 사용할 수도 있습니다.이 경우 Django의 템플릿 언어와 비슷한 방식으로 주어진 속성을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="d2082b66210fd6cb149c2b8ea501abab2d768ea6" translate="yes" xml:space="preserve">
          <source>This field is read only.</source>
          <target state="translated">이 필드는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="9b723c215c52a0a84f3fb7fe7448d501dd23bbb7" translate="yes" xml:space="preserve">
          <source>This field is used by &lt;code&gt;ModelSerializer&lt;/code&gt; to correspond to custom model field classes.</source>
          <target state="translated">이 필드는 &lt;code&gt;ModelSerializer&lt;/code&gt; 에서 사용자 정의 모델 필드 클래스에 해당하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb0dd6e3e5181f4f5bda9bb22d9fc06b26754f9a" translate="yes" xml:space="preserve">
          <source>This field is used by default with &lt;code&gt;ModelSerializer&lt;/code&gt; when including field names that relate to an attribute rather than a model field.</source>
          <target state="translated">이 필드는 모델 필드가 아닌 속성과 관련된 필드 이름을 포함 할 때 &lt;code&gt;ModelSerializer&lt;/code&gt; 와 함께 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="da0de079c5a575a8c5942b25e01402a799fa3507" translate="yes" xml:space="preserve">
          <source>This helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.</source>
          <target state="translated">이를 통해 사용자가 비밀번호 해시 필드 또는 기타 민감한 데이터에 대해 주문할 수있는 등 예기치 않은 데이터 유출을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af31bebcd9de26e707a822af6d1fd5e61e2e60a" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;True&lt;/code&gt; by default, but can be set to &lt;code&gt;False&lt;/code&gt; if you want to disallow empty lists as valid input.</source>
          <target state="translated">이다 &lt;code&gt;True&lt;/code&gt; 기본적으로 만 설정할 수 있습니다 &lt;code&gt;False&lt;/code&gt; 유효한 입력으로 빈 목록을 허용하지 않으려합니다.</target>
        </trans-unit>
        <trans-unit id="abcdc71bb2dfd4ba71336c5cb42c366919f774b1" translate="yes" xml:space="preserve">
          <source>This is a good point to override if you want to customise the generated dictionary, for example to add custom &lt;a href=&quot;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#specification-extensions&quot;&gt;specification extensions&lt;/a&gt;.</source>
          <target state="translated">생성 된 사전을 사용자 정의하려는 경우 (예 : 사용자 정의 &lt;a href=&quot;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#specification-extensions&quot;&gt;스펙 확장&lt;/a&gt; 추가)이를 대체하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f7501d26035c2adf6fda9060dc399dfb4cab75ae" translate="yes" xml:space="preserve">
          <source>This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.</source>
          <target state="translated">이것은 읽기 전용 필드입니다. 연결된 serializer 클래스에서 메서드를 호출하여 값을 가져옵니다. 객체의 직렬화 된 표현에 모든 종류의 데이터를 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb9fe805626f2b0cf4116eb0e4b66a032dcb5e2" translate="yes" xml:space="preserve">
          <source>This is a valid approach as the HTTP spec deliberately underspecifies how a server should weight server-based preferences against client-based preferences.</source>
          <target state="translated">이는 HTTP 사양이 서버가 서버 기반 환경 설정을 클라이언트 기반 환경 설정과 비교하여 가중치를 부여하는 방법을 의도적으로 과소 지정하기 때문에 유효한 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="98976d3d6768870079c6acd3a9d25f5df3d82e2e" translate="yes" xml:space="preserve">
          <source>This is suitable for URLs that contain a single primary key or slug argument as part of the URL.</source>
          <target state="translated">URL의 일부로 단일 기본 키 또는 슬러그 인수가 포함 된 URL에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="4d6205e65623206e305b68fa8076a8c094c96574" translate="yes" xml:space="preserve">
          <source>This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our &lt;code&gt;.create()&lt;/code&gt; method on the serializer class can now be re-written to use the new manager method.</source>
          <target state="translated">이 관리자 클래스는 이제 사용자 인스턴스와 프로파일 인스턴스가 항상 동시에 작성되도록보다 잘 캡슐화합니다. serializer 클래스 의 &lt;code&gt;.create()&lt;/code&gt; 메소드를 새 관리자 메소드를 사용하도록 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16e2bc5bb60b3650d2b8b4b4636fd0f649b1e445" translate="yes" xml:space="preserve">
          <source>This means that setting attributes directly on the request object may not always have the effect you expect. For example, setting &lt;code&gt;.token&lt;/code&gt; directly will have no effect, and setting &lt;code&gt;.user&lt;/code&gt; directly will only work if session authentication is being used.</source>
          <target state="translated">이는 요청 오브젝트에서 직접 속성을 설정하는 것이 항상 예상 한 영향을 미치지는 않을 수 있음을 의미합니다. 예를 들어, &lt;code&gt;.token&lt;/code&gt; 을 직접 설정해 도 아무런 효과가 없으며 &lt;code&gt;.user&lt;/code&gt; 를 직접 설정 하면 세션 인증을 사용하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0b5d6ce914423853329ab83a0119ae3b17936694" translate="yes" xml:space="preserve">
          <source>This means you'll need to explicitly set the &lt;code&gt;basename&lt;/code&gt; argument when registering the viewset, as it could not be automatically determined from the model name.</source>
          <target state="translated">즉 , 뷰 &lt;code&gt;basename&lt;/code&gt; 을 등록 할 때 모델 이름에서 자동으로 확인할 수 없으므로 기본 이름 인수 를 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3d90f5c28b2a6632668a8228e99fd23b927d5ab" translate="yes" xml:space="preserve">
          <source>This method should always be used rather than accessing &lt;code&gt;self.queryset&lt;/code&gt; directly, as &lt;code&gt;self.queryset&lt;/code&gt; gets evaluated only once, and those results are cached for all subsequent requests.</source>
          <target state="translated">&lt;code&gt;self.queryset&lt;/code&gt; 은 한 번만 평가되고 결과는 모든 후속 요청에 대해 캐시 &lt;code&gt;self.queryset&lt;/code&gt; 메소드는 self.queryset에 직접 액세스하는 대신 항상 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1d34cdcff0f517eeb5e5aac3fa5e87bbf6ce3f07" translate="yes" xml:space="preserve">
          <source>This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:</source>
          <target state="translated">이 옵션은 필드 이름을 키워드 인수 사전에 매핑하는 사전입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34292c1a43eb09ad3e19121accdd9ddaca869741" translate="yes" xml:space="preserve">
          <source>This option should be a list or tuple of field names, and is declared as follows:</source>
          <target state="translated">이 옵션은 필드 이름의 목록 또는 튜플이어야하며 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="ab53ad8de22d8e9c07cbde816ea32a7c57da401a" translate="yes" xml:space="preserve">
          <source>This package was previously included directly in REST framework but is now supported and maintained as a third party package.</source>
          <target state="translated">이 패키지는 이전에 REST 프레임 워크에 직접 포함되었지만 이제는 타사 패키지로 지원 및 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="192594048769438ee410f621581a0f98a4e9eb28" translate="yes" xml:space="preserve">
          <source>This pagination style accepts a single number page number in the request query parameters.</source>
          <target state="translated">이 페이지 매김 스타일은 요청 쿼리 매개 변수에 단일 숫자 페이지 번호를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cc5138bc6cfd964bafcf5c1609f66a2bcf0ab20f" translate="yes" xml:space="preserve">
          <source>This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a &quot;limit&quot; and an &quot;offset&quot; query parameter. The limit indicates the maximum number of items to return, and is equivalent to the &lt;code&gt;page_size&lt;/code&gt; in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.</source>
          <target state="translated">이 페이지 매김 스타일은 여러 데이터베이스 레코드를 검색 할 때 사용되는 구문을 반영합니다. 클라이언트는 &quot;제한&quot;및 &quot;오프셋&quot;쿼리 매개 변수를 모두 포함합니다. 한도는 반환 할 최대 항목 수를 나타내며 다른 스타일 의 &lt;code&gt;page_size&lt;/code&gt; 와 같습니다 . 오프셋은 페이지 매김되지 않은 항목의 전체 세트와 관련하여 쿼리의 시작 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebf161c7674004426acb36a6435455dfa103615d" translate="yes" xml:space="preserve">
          <source>This permission class ties into Django's standard &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions&quot;&gt;object permissions framework&lt;/a&gt; that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as &lt;a href=&quot;https://github.com/lukaszb/django-guardian&quot;&gt;django-guardian&lt;/a&gt;.</source>
          <target state="translated">이 권한 클래스 는 모델에 대한 객체 별 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions&quot;&gt;권한&lt;/a&gt; 을 허용하는 Django의 표준 객체 권한 프레임 워크 에 연결됩니다. 이 권한 클래스를 사용하려면 &lt;a href=&quot;https://github.com/lukaszb/django-guardian&quot;&gt;django-guardian&lt;/a&gt; 과 같은 객체 수준 권한을 지원하는 권한 백엔드를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44a86c88f87e00847da4c11f26a542b4c571ba19" translate="yes" xml:space="preserve">
          <source>This permission class ties into Django's standard &lt;code&gt;django.contrib.auth&lt;/code&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/auth/customizing/#custom-permissions&quot;&gt;model permissions&lt;/a&gt;. This permission must only be applied to views that have a &lt;code&gt;.queryset&lt;/code&gt; property set. Authorization will only be granted if the user &lt;em&gt;is authenticated&lt;/em&gt; and has the &lt;em&gt;relevant model permissions&lt;/em&gt; assigned.</source>
          <target state="translated">이 권한 클래스는 Django의 표준 &lt;code&gt;django.contrib.auth&lt;/code&gt; &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/auth/customizing/#custom-permissions&quot;&gt;모델 권한에 연결&lt;/a&gt; 됩니다. 이 권한은 &lt;code&gt;.queryset&lt;/code&gt; 속성이 설정된 뷰에만 적용해야합니다 . 인증은 사용자 &lt;em&gt;가 인증&lt;/em&gt; 되고 &lt;em&gt;관련 모델 권한이&lt;/em&gt; 할당 된 경우에만 부여 됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3027c9c1fdb87ff817aaf6932444f64181db91" translate="yes" xml:space="preserve">
          <source>This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.</source>
          <target state="translated">권한 설정에 빈 목록이나 튜플을 사용하여 동일한 결과를 얻을 수 있으므로이 권한은 꼭 필요한 것은 아니지만 의도를 명시 적으로 나타 내기 때문에이 클래스를 지정하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f836a1310070324c47f8ebdbfc327d26c9aa3092" translate="yes" xml:space="preserve">
          <source>This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.</source>
          <target state="translated">이 권한은 익명 사용자에게 읽기 권한을 허용하고 인증 된 사용자에게 쓰기 권한 만 허용하도록 API에 원하는 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="95a18395ddd5dc6102d76236f67a5cfc94091050" translate="yes" xml:space="preserve">
          <source>This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.</source>
          <target state="translated">이 권한은 신뢰할 수있는 관리자 중 일부만 API에 액세스 할 수 있도록하려는 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5388279ed387c4045cc94f681458b8494abd167a" translate="yes" xml:space="preserve">
          <source>This permission is suitable if you want your API to only be accessible to registered users.</source>
          <target state="translated">이 권한은 등록 된 사용자 만 API에 액세스 할 수 있도록하려는 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b8bf7cdd061315e05da3502537ab2e37561ada68" translate="yes" xml:space="preserve">
          <source>This property should be the serializer field class, that is used for relational fields by default.</source>
          <target state="translated">이 특성은 직렬화 기 필드 클래스 여야하며 기본적으로 관계형 필드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd6494f6f0dcdbf1de0ddaadf26b11b8556f6af0" translate="yes" xml:space="preserve">
          <source>This provides complete control over view introspection.</source>
          <target state="translated">이를 통해 뷰 검사를 완벽하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3fa9254d64c2f095b60cdd099889635eea642f3" translate="yes" xml:space="preserve">
          <source>This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the &lt;code&gt;render_form&lt;/code&gt; template tag.</source>
          <target state="translated">이 렌더러는 직접 사용하기위한 것이 아니라 serializer 인스턴스를 &lt;code&gt;render_form&lt;/code&gt; 템플릿 태그 에 전달하여 템플릿에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08041ebb556f7443e58d45b7e84317ff2dcd8e39" translate="yes" xml:space="preserve">
          <source>This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.</source>
          <target state="translated">이 렌더러는 CRUD 스타일 웹 API에 적합하며 데이터 관리를위한 사용자 친화적 인 인터페이스도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee449a6ea20e42720d6013a0474419188bccdb01" translate="yes" xml:space="preserve">
          <source>This renderer is used for rendering HTML multipart form data. &lt;strong&gt;It is not suitable as a response renderer&lt;/strong&gt;, but is instead used for creating test requests, using REST framework's &lt;a href=&quot;../testing/index&quot;&gt;test client and test request factory&lt;/a&gt;.</source>
          <target state="translated">이 렌더러는 HTML 멀티 파트 양식 데이터를 렌더링하는 데 사용됩니다. &lt;strong&gt;응답 렌더러로는 적합하지&lt;/strong&gt; 않지만 대신 REST 프레임 워크의 &lt;a href=&quot;../testing/index&quot;&gt;테스트 클라이언트 및 테스트 요청 팩토리를&lt;/a&gt; 사용하여 테스트 요청을 작성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdee213e7541d35db7167c22653d0134024a0a34" translate="yes" xml:space="preserve">
          <source>This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.</source>
          <target state="translated">이 렌더러는 어떤 다른 렌더러에게 가장 높은 우선 순위가 부여되었는지 결정하고이를 사용하여 HTML 페이지 내에 API 스타일 응답을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5c8a5c414ed0d67d19f13e1269f093fb343eb057" translate="yes" xml:space="preserve">
          <source>This router includes routes for the standard set of &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;retrieve&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;partial_update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; actions. The viewset can also mark additional methods to be routed, using the &lt;code&gt;@action&lt;/code&gt; decorator.</source>
          <target state="translated">이 라우터에는 표준 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;create&lt;/code&gt; , &lt;code&gt;retrieve&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;partial_update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt; 조치 세트에 대한 라우트가 포함됩니다 . 뷰 세트는 &lt;code&gt;@action&lt;/code&gt; 데코레이터를 사용하여 라우팅 할 추가 메소드를 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b4c5bca420f55f4f842992f8fddeb89c9476578" translate="yes" xml:space="preserve">
          <source>This router is similar to &lt;code&gt;SimpleRouter&lt;/code&gt; as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional &lt;code&gt;.json&lt;/code&gt; style format suffixes.</source>
          <target state="translated">이 라우터는 위와 같이 &lt;code&gt;SimpleRouter&lt;/code&gt; 와 유사 하지만 기본 API 루트보기를 포함하여 모든 목록보기에 대한 하이퍼 링크를 포함하는 응답을 반환합니다. 또한 선택적인 &lt;code&gt;.json&lt;/code&gt; 스타일 형식 접미사에 대한 경로를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="1232e75d120cc5d64cff7a84a14b8f870bc15cad" translate="yes" xml:space="preserve">
          <source>This scheme is a simple style that includes the version as a query parameter in the URL. For example:</source>
          <target state="translated">이 체계는 URL에 버전을 쿼리 매개 변수로 포함하는 간단한 스타일입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e88cab6e86ff187386c0e706745fdc2e1efc3d53" translate="yes" xml:space="preserve">
          <source>This scheme requires the client to specify the version as part of the URL path.</source>
          <target state="translated">이 체계에서는 클라이언트가 URL 경로의 일부로 버전을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd6c1f8bcea41d24accb092d9594f7bf6d9762fe" translate="yes" xml:space="preserve">
          <source>This scheme requires the client to specify the version as part of the media type in the &lt;code&gt;Accept&lt;/code&gt; header. The version is included as a media type parameter, that supplements the main media type.</source>
          <target state="translated">이 체계를 사용하려면 클라이언트가 &lt;code&gt;Accept&lt;/code&gt; 헤더 에서 미디어 유형의 일부로 버전을 지정해야합니다 . 버전은 기본 미디어 유형을 보완하는 미디어 유형 매개 변수로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="830e98b5ab689f9de46f78d8ecbdf74284d95d1c" translate="yes" xml:space="preserve">
          <source>This setting can be changed to support error responses other than the default &lt;code&gt;{&quot;detail&quot;: &quot;Failure...&quot;}&lt;/code&gt; responses. For example, you can use it to provide API responses like &lt;code&gt;{&quot;errors&quot;: [{&quot;message&quot;: &quot;Failure...&quot;, &quot;code&quot;: &quot;&quot;} ...]}&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;{&quot;detail&quot;: &quot;Failure...&quot;}&lt;/code&gt; 응답 이외의 오류 응답을 지원하도록이 설정을 변경할 수 있습니다 . 예를 들어, &lt;code&gt;{&quot;errors&quot;: [{&quot;message&quot;: &quot;Failure...&quot;, &quot;code&quot;: &quot;&quot;} ...]}&lt;/code&gt; 과 같은 API 응답을 제공하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="745366e457f93e19755c63d570aa7b8bc14f8d42" translate="yes" xml:space="preserve">
          <source>This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support &lt;code&gt;rst&lt;/code&gt; markup in your view docstrings being output in the browsable API.</source>
          <target state="translated">기본 마크 다운 이외의 마크 업 스타일을 지원하도록이 설정을 변경할 수 있습니다. 예를 들어, browsable API에서 출력되는 뷰 docstring에서 &lt;code&gt;rst&lt;/code&gt; 마크 업 을 지원하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92abc10291a60bbc85fb615d100b2a618d2c440f" translate="yes" xml:space="preserve">
          <source>This should all feel very familiar - it is not a lot different from working with regular Django views.</source>
          <target state="translated">이것은 모두 매우 친숙하게 느껴질 것입니다-일반 Django 뷰를 사용하는 것과 크게 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f0eee4025159ed9ef519cfb951ec4ff564d9777" translate="yes" xml:space="preserve">
          <source>This should be a function with the following signature:</source>
          <target state="translated">이것은 다음 서명이있는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6054a8fd99d2e91a4d160e4d7089ac239ad5b88d" translate="yes" xml:space="preserve">
          <source>This should match up with the format of one of the renderer classes in the &lt;code&gt;TEST_REQUEST_RENDERER_CLASSES&lt;/code&gt; setting.</source>
          <target state="translated">이것은 &lt;code&gt;TEST_REQUEST_RENDERER_CLASSES&lt;/code&gt; 설정 에서 렌더러 클래스 중 하나의 형식과 일치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0cda2e5802f9c0a585d520c1f76dcb1a8f503dc1" translate="yes" xml:space="preserve">
          <source>This style keeps your error messages cleaner and more separated from your code, and should be preferred.</source>
          <target state="translated">이 스타일은 오류 메시지를 더 깔끔하고 코드와 분리하여 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc3fce01b6a8555c5b2b773e15a1d72267635de0" translate="yes" xml:space="preserve">
          <source>This time we've used the &lt;code&gt;ModelViewSet&lt;/code&gt; class in order to get the complete set of default read and write operations.</source>
          <target state="translated">이번에 는 기본 읽기 및 쓰기 작업의 전체 세트를 얻기 위해 &lt;code&gt;ModelViewSet&lt;/code&gt; 클래스를 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="abc785835bcaa8b78e3e762bf0feeb3857c68221" translate="yes" xml:space="preserve">
          <source>This tutorial will cover creating a simple pastebin code highlighting Web API. Along the way it will introduce the various components that make up REST framework, and give you a comprehensive understanding of how everything fits together.</source>
          <target state="translated">이 튜토리얼은 웹 API를 강조하는 간단한 pastebin 코드 작성을 다룹니다. 그 과정에서 REST 프레임 워크를 구성하는 다양한 구성 요소를 소개하고 모든 구성 요소가 어떻게 결합되는지 포괄적으로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="0ce1e5378bfea76636c164d70465157455909ff8" translate="yes" xml:space="preserve">
          <source>This validator can be used to enforce &lt;code&gt;unique_together&lt;/code&gt; constraints on model instances. It has two required arguments, and a single optional &lt;code&gt;messages&lt;/code&gt; argument:</source>
          <target state="translated">이 유효성 검사기는 모델 인스턴스에 &lt;code&gt;unique_together&lt;/code&gt; 제약 조건 을 적용하는 데 사용할 수 있습니다 . 두 개의 필수 인수와 단일 선택적 &lt;code&gt;messages&lt;/code&gt; 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2720dc3ab24968e3bf7dc0642155852ba60e9b1b" translate="yes" xml:space="preserve">
          <source>This validator can be used to enforce the &lt;code&gt;unique=True&lt;/code&gt; constraint on model fields. It takes a single required argument, and an optional &lt;code&gt;messages&lt;/code&gt; argument:</source>
          <target state="translated">이 유효성 검사기는 모델 필드에 &lt;code&gt;unique=True&lt;/code&gt; 제약 조건 을 적용하는 데 사용할 수 있습니다 . 단일 필수 인수와 선택적 &lt;code&gt;messages&lt;/code&gt; 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0874f222e9d7889773bff977bc89cf6a824c7ec1" translate="yes" xml:space="preserve">
          <source>This validator should be applied to &lt;em&gt;serializer fields&lt;/em&gt;, like so:</source>
          <target state="translated">이 유효성 검사기는 다음 과 같이 &lt;em&gt;serializer 필드에&lt;/em&gt; 적용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a4dcce9a26cccd8743ce7b28be5ac4b173dd887" translate="yes" xml:space="preserve">
          <source>This view will use the default renderers, parsers, authentication classes etc specified in the &lt;a href=&quot;../settings/index&quot;&gt;settings&lt;/a&gt;.</source>
          <target state="translated">이 뷰는 &lt;a href=&quot;../settings/index&quot;&gt;설정에&lt;/a&gt; 지정된 기본 렌더러, 파서, 인증 클래스 등을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="04caf3f2126fb54db58fd339d3587fdb79a4c28d" translate="yes" xml:space="preserve">
          <source>This will allow the client to filter the items in the list by making queries such as:</source>
          <target state="translated">이를 통해 클라이언트는 다음과 같은 쿼리를 수행하여 목록의 항목을 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ada99260fb34330273856da563a88e44ff5f05c0" translate="yes" xml:space="preserve">
          <source>This will automatically create a &lt;code&gt;FilterSet&lt;/code&gt; class for the given fields, and will allow you to make requests such as:</source>
          <target state="translated">그러면 주어진 필드에 대해 &lt;code&gt;FilterSet&lt;/code&gt; 클래스 가 자동으로 생성 되며 다음과 같은 요청을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9915efaece3f5749baf151d602e37e3d4715e90" translate="yes" xml:space="preserve">
          <source>This will either raise a &lt;code&gt;PermissionDenied&lt;/code&gt; or &lt;code&gt;NotAuthenticated&lt;/code&gt; exception, or simply return if the view has the appropriate permissions.</source>
          <target state="translated">이렇게하면 &lt;code&gt;PermissionDenied&lt;/code&gt; 또는 &lt;code&gt;NotAuthenticated&lt;/code&gt; 예외가 발생하거나보기에 적절한 권한이있는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="11b7cd86b1732b39cf211af42e6a7472530c1d89" translate="yes" xml:space="preserve">
          <source>This would then allow you to do the following:</source>
          <target state="translated">그러면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de4b81df47fca521f704dac953f3f2e50cd98bf4" translate="yes" xml:space="preserve">
          <source>Throttled</source>
          <target state="translated">Throttled</target>
        </trans-unit>
        <trans-unit id="52a6bfdb5d5f489b9d91c9a276ab52caf6601908" translate="yes" xml:space="preserve">
          <source>Throttles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.</source>
          <target state="translated">스로틀은 반드시 속도 제한 요청 만 참조 할 필요는 없습니다. 예를 들어 스토리지 서비스는 대역폭에 대해 조절해야하며 유료 데이터 서비스는 액세스중인 특정 수의 레코드에 대해 조절을 원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a013142994554a2d02ae7ff4142c0e4306c2941" translate="yes" xml:space="preserve">
          <source>Throttling</source>
          <target state="translated">Throttling</target>
        </trans-unit>
        <trans-unit id="e2c0607faea7044d2458f1d4366c2db0c0caeb3f" translate="yes" xml:space="preserve">
          <source>Throttling is similar to &lt;a href=&quot;../permissions/index&quot;&gt;permissions&lt;/a&gt;, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.</source>
          <target state="translated">제한은 요청이 승인되어야하는지 여부를 결정한다는 점에서 &lt;a href=&quot;../permissions/index&quot;&gt;permissions&lt;/a&gt; 와 유사합니다 . 스로틀은 임시 상태를 나타내며 클라이언트가 API에 요청할 수있는 비율을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46c0d7cadfa7859e0a2ea666ef13537c2a0f702b" translate="yes" xml:space="preserve">
          <source>TimeField</source>
          <target state="translated">TimeField</target>
        </trans-unit>
        <trans-unit id="a10f4adac34c4bbc16d7897e7d1ad7bf369e03d2" translate="yes" xml:space="preserve">
          <source>TimeField format strings</source>
          <target state="translated">TimeField 형식 문자열</target>
        </trans-unit>
        <trans-unit id="239317db38601b69fe2ea98f21a6b133ddad5068" translate="yes" xml:space="preserve">
          <source>To avoid having a file streamed without a filename (which the browser will often default to the filename &quot;download&quot;, with no extension), we need to use a mixin to override the &lt;code&gt;Content-Disposition&lt;/code&gt; header. If no filename is provided, it will default to &lt;code&gt;export.xlsx&lt;/code&gt;. For example:</source>
          <target state="translated">파일 이름없이 파일이 스트리밍되지 않도록하려면 (브라우저에서 기본적으로 파일 이름이 &quot;다운로드&quot;(확장자 없음)로 기본 설정 됨) 믹스 인을 사용하여 &lt;code&gt;Content-Disposition&lt;/code&gt; 헤더 를 재정의해야합니다 . 파일 이름이 제공되지 않으면 기본값은 &lt;code&gt;export.xlsx&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c15a6310995571ce73488415a4387e1be6ecd77" translate="yes" xml:space="preserve">
          <source>To create a base viewset class that provides &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, inherit from &lt;code&gt;GenericViewSet&lt;/code&gt;, and mixin the required actions:</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; 및 &lt;code&gt;retrieve&lt;/code&gt; 오퍼레이션 을 제공하는 기본 뷰 세트 클래스를 작성하려면 &lt;code&gt;GenericViewSet&lt;/code&gt; 을 상속 하고 필요한 조치 를 혼합 하십시오.</target>
        </trans-unit>
        <trans-unit id="288ea9bbff8c5ffc11d7362259d80f0f19884625" translate="yes" xml:space="preserve">
          <source>To create a custom pagination serializer class you should subclass &lt;code&gt;pagination.BasePagination&lt;/code&gt; and override the &lt;code&gt;paginate_queryset(self, queryset, request, view=None)&lt;/code&gt; and &lt;code&gt;get_paginated_response(self, data)&lt;/code&gt; methods:</source>
          <target state="translated">사용자 정의 페이지 매김 시리얼 클래스를 만들려면 하위 클래스해야 &lt;code&gt;pagination.BasePagination&lt;/code&gt; 을 하고 무시 &lt;code&gt;paginate_queryset(self, queryset, request, view=None)&lt;/code&gt; 및 &lt;code&gt;get_paginated_response(self, data)&lt;/code&gt; 방법 :</target>
        </trans-unit>
        <trans-unit id="1473a45ac77ca52af213db016b8ffbbb2be11745" translate="yes" xml:space="preserve">
          <source>To create a custom throttle, override &lt;code&gt;BaseThrottle&lt;/code&gt; and implement &lt;code&gt;.allow_request(self, request, view)&lt;/code&gt;. The method should return &lt;code&gt;True&lt;/code&gt; if the request should be allowed, and &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">사용자 지정 스로틀을 만들려면 &lt;code&gt;BaseThrottle&lt;/code&gt; 을 재정의 하고 &lt;code&gt;.allow_request(self, request, view)&lt;/code&gt; 구현 하십시오 . 요청이 허용되면 메소드는 &lt;code&gt;True&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88568756efa7c692a18b252387719f51ee6eff67" translate="yes" xml:space="preserve">
          <source>To create a read-write serializer we first need to implement a &lt;code&gt;.to_internal_value()&lt;/code&gt; method. This method returns the validated values that will be used to construct the object instance, and may raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt; if the supplied data is in an incorrect format.</source>
          <target state="translated">읽기-쓰기 시리얼 라이저를 만들려면 먼저 &lt;code&gt;.to_internal_value()&lt;/code&gt; 메서드 를 구현해야합니다 . 이 메서드는 개체 인스턴스를 구성하는 데 사용될 유효성 검사 된 값을 반환하며 제공된 데이터의 형식이 잘못된 경우 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c5740c0f52f5fef3338cc39c05208d314d25043" translate="yes" xml:space="preserve">
          <source>To do any other validation that requires access to multiple fields, add a method called &lt;code&gt;.validate()&lt;/code&gt; to your &lt;code&gt;Serializer&lt;/code&gt; subclass. This method takes a single argument, which is a dictionary of field values. It should raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt; if necessary, or just return the validated values. For example:</source>
          <target state="translated">여러 필드에 액세스해야하는 다른 유효성 검사를 수행하려면 &lt;code&gt;.validate()&lt;/code&gt; 라는 메서드 를 &lt;code&gt;Serializer&lt;/code&gt; 하위 클래스에 . 이 메소드는 단일 인수를 사용하는데, 이는 필드 값의 사전입니다. 그것은 인상해야 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 를 필요한 경우 아니면 그냥 검증 된 값을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="161fed4ab17088bf52230d3c5a104e40cce6cf6e" translate="yes" xml:space="preserve">
          <source>To do so override &lt;code&gt;BaseFilterBackend&lt;/code&gt;, and override the &lt;code&gt;.filter_queryset(self, request, queryset, view)&lt;/code&gt; method. The method should return a new, filtered queryset.</source>
          <target state="translated">재정의하려면 &lt;code&gt;BaseFilterBackend&lt;/code&gt; 를 재정의하고 &lt;code&gt;.filter_queryset(self, request, queryset, view)&lt;/code&gt; 메소드를 재정의하십시오 . 이 메소드는 필터링 된 새 쿼리 세트를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c452d3eeeea1b3a1247e2d76fe39cbaaca57bf2" translate="yes" xml:space="preserve">
          <source>To do so, open the Django shell, using &lt;code&gt;python manage.py shell&lt;/code&gt;, then import the serializer class, instantiate it, and print the object representation&amp;hellip;</source>
          <target state="translated">이렇게하려면 다음을 사용하여 Django 셸을 엽니 다. &lt;code&gt;python manage.py shell&lt;/code&gt; 을 다음 serializer 클래스를 가져 와서 인스턴스화하고 객체 표현을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="07e1fd663142c7b92f3d0ac973881d7f9891ccb8" translate="yes" xml:space="preserve">
          <source>To do that we're going to need to create a custom permission.</source>
          <target state="translated">그러기 위해서는 사용자 지정 권한을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c107282da807f8e3ef6fcfbafc40b7c232e43d7" translate="yes" xml:space="preserve">
          <source>To dynamically change search fields based on request content, it's possible to subclass the &lt;code&gt;SearchFilter&lt;/code&gt; and override the &lt;code&gt;get_search_fields()&lt;/code&gt; function. For example, the following subclass will only search on &lt;code&gt;title&lt;/code&gt; if the query parameter &lt;code&gt;title_only&lt;/code&gt; is in the request:</source>
          <target state="translated">요청 컨텐츠를 기반으로 검색 필드를 동적으로 변경하기 위해 &lt;code&gt;SearchFilter&lt;/code&gt; 를 서브 클래스 화 하고 &lt;code&gt;get_search_fields()&lt;/code&gt; 함수를 대체 할 수 있습니다. 예를 들어, 다음 서브 클래스는 쿼리 매개 변수 인 경우 &lt;code&gt;title&lt;/code&gt; 만 검색합니다. &lt;code&gt;title_only&lt;/code&gt; 가 요청에있는 .</target>
        </trans-unit>
        <trans-unit id="bf59c953cad864f61d9da86459872aa3c165648f" translate="yes" xml:space="preserve">
          <source>To enable the &lt;code&gt;CursorPagination&lt;/code&gt; style globally, use the following configuration, modifying the &lt;code&gt;PAGE_SIZE&lt;/code&gt; as desired:</source>
          <target state="translated">에이블하기 &lt;code&gt;CursorPagination&lt;/code&gt; 의 세계적 스타일의 수정, 다음과 같은 구성을 사용 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 를 원하는대로 :</target>
        </trans-unit>
        <trans-unit id="7434c868b7edf6250196dc16659b7bf8404fb690" translate="yes" xml:space="preserve">
          <source>To enable the &lt;code&gt;LimitOffsetPagination&lt;/code&gt; style globally, use the following configuration:</source>
          <target state="translated">&lt;code&gt;LimitOffsetPagination&lt;/code&gt; 을 활성화하려면 세계적 스타일을, 다음과 같은 구성을 사용 :</target>
        </trans-unit>
        <trans-unit id="9436eb66cfe22dbfb75ad7c2f454b53225c9590e" translate="yes" xml:space="preserve">
          <source>To enable the &lt;code&gt;PageNumberPagination&lt;/code&gt; style globally, use the following configuration, and set the &lt;code&gt;PAGE_SIZE&lt;/code&gt; as desired:</source>
          <target state="translated">에이블하려면 &lt;code&gt;PageNumberPagination&lt;/code&gt; 의 다음과 같은 구성을 사용, 전 세계적으로 스타일을하고 설정 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 를 원하는대로 :</target>
        </trans-unit>
        <trans-unit id="cc9ae2cec7a9694c0ff0690560267750fde94bbd" translate="yes" xml:space="preserve">
          <source>To forcibly authenticate a request, use the &lt;code&gt;force_authenticate()&lt;/code&gt; method.</source>
          <target state="translated">요청을 강제로 인증하려면 &lt;code&gt;force_authenticate()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a954343848d13653d2adf5e7cd2de9028fbb6e0" translate="yes" xml:space="preserve">
          <source>To have your custom pagination class be used by default, use the &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; setting:</source>
          <target state="translated">맞춤 페이지 매김 클래스를 기본적으로 사용하려면 &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; 설정을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a891ac08e11dd98dcbb6eb1e246a4c5c3a592648" translate="yes" xml:space="preserve">
          <source>To implement a custom authentication scheme, subclass &lt;code&gt;BaseAuthentication&lt;/code&gt; and override the &lt;code&gt;.authenticate(self, request)&lt;/code&gt; method. The method should return a two-tuple of &lt;code&gt;(user, auth)&lt;/code&gt; if authentication succeeds, or &lt;code&gt;None&lt;/code&gt; otherwise.</source>
          <target state="translated">사용자 정의 인증 체계를 구현하려면 &lt;code&gt;BaseAuthentication&lt;/code&gt; 을 서브 클래스로 만들고 &lt;code&gt;.authenticate(self, request)&lt;/code&gt; 메소드를 대체하십시오 . 인증이 성공하면 메소드는 두 개의 튜플 &lt;code&gt;(user, auth)&lt;/code&gt; 리턴하고 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d53ab5dfd1a1069ad72b1fe8124d1e34ed495bec" translate="yes" xml:space="preserve">
          <source>To implement a custom parser, you should override &lt;code&gt;BaseParser&lt;/code&gt;, set the &lt;code&gt;.media_type&lt;/code&gt; property, and implement the &lt;code&gt;.parse(self, stream, media_type, parser_context)&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 파서를 구현하려면 &lt;code&gt;BaseParser&lt;/code&gt; 를 재정의 하고 &lt;code&gt;.media_type&lt;/code&gt; 속성을 설정 한 다음 &lt;code&gt;.parse(self, stream, media_type, parser_context)&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5657b9b4c6ecf34b180d397c40a01442453ea4c" translate="yes" xml:space="preserve">
          <source>To implement a custom permission, override &lt;code&gt;BasePermission&lt;/code&gt; and implement either, or both, of the following methods:</source>
          <target state="translated">사용자 정의 권한을 구현하려면 &lt;code&gt;BasePermission&lt;/code&gt; 을 대체 하고 다음 방법 중 하나 또는 둘 다를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="a1c8a67c238ed03e49c75cbe5e56b6849c955b9c" translate="yes" xml:space="preserve">
          <source>To implement a custom relational field, you should override &lt;code&gt;RelatedField&lt;/code&gt;, and implement the &lt;code&gt;.to_representation(self, value)&lt;/code&gt; method. This method takes the target of the field as the &lt;code&gt;value&lt;/code&gt; argument, and should return the representation that should be used to serialize the target. The &lt;code&gt;value&lt;/code&gt; argument will typically be a model instance.</source>
          <target state="translated">사용자 정의 관계형 필드를 구현하려면 &lt;code&gt;RelatedField&lt;/code&gt; 를 재정의 하고 &lt;code&gt;.to_representation(self, value)&lt;/code&gt; 메소드를 구현 해야합니다 . 이 메소드는 필드의 대상을 &lt;code&gt;value&lt;/code&gt; 인수로 사용하며 대상을 직렬화하는 데 사용해야하는 표현을 리턴해야합니다. &lt;code&gt;value&lt;/code&gt; 인수는 일반적으로 모델의 인스턴스가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a9bac2268cab343c5cb061abb1037392e42d4b3" translate="yes" xml:space="preserve">
          <source>To implement a custom renderer, you should override &lt;code&gt;BaseRenderer&lt;/code&gt;, set the &lt;code&gt;.media_type&lt;/code&gt; and &lt;code&gt;.format&lt;/code&gt; properties, and implement the &lt;code&gt;.render(self, data, media_type=None, renderer_context=None)&lt;/code&gt; method.</source>
          <target state="translated">사용자 지정 렌더러를 구현하려면 &lt;code&gt;BaseRenderer&lt;/code&gt; 를 재정의 하고 &lt;code&gt;.media_type&lt;/code&gt; 및 &lt;code&gt;.format&lt;/code&gt; 속성을 설정 한 다음 &lt;code&gt;.render(self, data, media_type=None, renderer_context=None)&lt;/code&gt; 메서드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dc5e0c238a77c51b68e368ceb5adb41c8f4df62" translate="yes" xml:space="preserve">
          <source>To implement a custom versioning scheme, subclass &lt;code&gt;BaseVersioning&lt;/code&gt; and override the &lt;code&gt;.determine_version&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 버전 관리 체계를 구현하려면 &lt;code&gt;BaseVersioning&lt;/code&gt; 서브 클래스를 정의 하고 .determine_version 을 대체하십시오 &lt;code&gt;.determine_version&lt;/code&gt; 메소드를 .</target>
        </trans-unit>
        <trans-unit id="7063f4d8edc16565c60d82187adbfd2022109fc3" translate="yes" xml:space="preserve">
          <source>To implement a read-only serializer using the &lt;code&gt;BaseSerializer&lt;/code&gt; class, we just need to override the &lt;code&gt;.to_representation()&lt;/code&gt; method. Let's take a look at an example using a simple Django model:</source>
          <target state="translated">&lt;code&gt;BaseSerializer&lt;/code&gt; 클래스를 사용하여 읽기 전용 직렬 변환기를 구현하려면 &lt;code&gt;.to_representation()&lt;/code&gt; 메소드 를 대체하기 만하면 됩니다. 간단한 Django 모델을 사용하는 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ed01cc98eaaa4e2955cf5dbb043f63a216962708" translate="yes" xml:space="preserve">
          <source>To logout, call the &lt;code&gt;logout&lt;/code&gt; method as usual.</source>
          <target state="translated">로그 아웃하려면 평상시처럼 &lt;code&gt;logout&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="11ac8ed92b7a4004ef3de9bd094f2248d5e0f444" translate="yes" xml:space="preserve">
          <source>To override the default schema generation for function based views you may use the &lt;code&gt;@schema&lt;/code&gt; decorator. This must come &lt;em&gt;after&lt;/em&gt; (below) the &lt;code&gt;@api_view&lt;/code&gt; decorator. For example:</source>
          <target state="translated">함수 기반 뷰의 기본 스키마 생성을 무시하려면 &lt;code&gt;@schema&lt;/code&gt; 데코레이터를 사용할 수 있습니다 . 이것은 &lt;code&gt;@api_view&lt;/code&gt; 데코레이터 &lt;em&gt;뒤&lt;/em&gt; (아래)에 와야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dee8eec63266374acfb08ac8b1fc3336442063b0" translate="yes" xml:space="preserve">
          <source>To override the default settings, REST framework provides a set of additional decorators which can be added to your views. These must come &lt;em&gt;after&lt;/em&gt; (below) the &lt;code&gt;@api_view&lt;/code&gt; decorator. For example, to create a view that uses a &lt;a href=&quot;../throttling/index&quot;&gt;throttle&lt;/a&gt; to ensure it can only be called once per day by a particular user, use the &lt;code&gt;@throttle_classes&lt;/code&gt; decorator, passing a list of throttle classes:</source>
          <target state="translated">기본 설정을 재정의하기 위해 REST 프레임 워크는 뷰에 추가 할 수있는 추가 데코레이터 세트를 제공합니다. 이들은 &lt;code&gt;@api_view&lt;/code&gt; 데코레이터 &lt;em&gt;뒤&lt;/em&gt; (아래)에 와야 합니다. 예를 들어 &lt;a href=&quot;../throttling/index&quot;&gt;스로틀&lt;/a&gt; 을 사용 하여 특정 사용자가 하루에 한 번만 호출 할 수 있도록 뷰를 만들려면 &lt;code&gt;@throttle_classes&lt;/code&gt; 데코레이터를 사용하여 스로틀 클래스 목록을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="8e3fb69bfb521f30fb5597e21feb29f2b33455d1" translate="yes" xml:space="preserve">
          <source>To provide a custom exception, subclass &lt;code&gt;APIException&lt;/code&gt; and set the &lt;code&gt;.status_code&lt;/code&gt;, &lt;code&gt;.default_detail&lt;/code&gt;, and &lt;code&gt;default_code&lt;/code&gt; attributes on the class.</source>
          <target state="translated">사용자 정의 예외를 제공하려면 &lt;code&gt;APIException&lt;/code&gt; 서브 클래스를 작성 하고 클래스 에서 &lt;code&gt;.status_code&lt;/code&gt; , &lt;code&gt;.default_detail&lt;/code&gt; 및 &lt;code&gt;default_code&lt;/code&gt; 속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="dbed16ce40218dafadb56562fa67db190631b019" translate="yes" xml:space="preserve">
          <source>To provide a dynamic queryset based on the &lt;code&gt;context&lt;/code&gt;, you can also override &lt;code&gt;.get_queryset(self)&lt;/code&gt; instead of specifying &lt;code&gt;.queryset&lt;/code&gt; on the class or when initializing the field.</source>
          <target state="translated">에 기초 동적의 검색어 세트 제공하기 위해 &lt;code&gt;context&lt;/code&gt; , 당신은 또한 무시할 수 있습니다 &lt;code&gt;.get_queryset(self)&lt;/code&gt; 대신 지정하는 &lt;code&gt;.queryset&lt;/code&gt; 를 를 제공하기 위해 클래스에서 을 또는 필드를 초기화 할 때 .</target>
        </trans-unit>
        <trans-unit id="420e6fed0599fa1d392fbd26b41aa7883ce5a95e" translate="yes" xml:space="preserve">
          <source>To provide customized representations for such inputs, override &lt;code&gt;display_value()&lt;/code&gt; of a &lt;code&gt;RelatedField&lt;/code&gt; subclass. This method will receive a model object, and should return a string suitable for representing it. For example:</source>
          <target state="translated">이러한 입력에 대한 사용자 정의 표현을 제공하려면 &lt;code&gt;RelatedField&lt;/code&gt; 서브 클래스 의 &lt;code&gt;display_value()&lt;/code&gt; 를 대체 하십시오 . 이 메소드는 모델 객체를 수신하고이를 나타내는 데 적합한 문자열을 반환해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81935c5335d852228f056987976a510dc5725c32" translate="yes" xml:space="preserve">
          <source>To route a &lt;code&gt;SchemaView&lt;/code&gt;, use the &lt;code&gt;get_schema_view()&lt;/code&gt; helper.</source>
          <target state="translated">&lt;code&gt;SchemaView&lt;/code&gt; 를 라우트하려면 &lt;code&gt;get_schema_view()&lt;/code&gt; 헬퍼를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c9ab436de412718edb072c2649cc87798949261" translate="yes" xml:space="preserve">
          <source>To select a representation using its short format, use the &lt;code&gt;format&lt;/code&gt; query parameter. For example: &lt;code&gt;http://example.com/organizations/?format=csv&lt;/code&gt;.</source>
          <target state="translated">짧은 형식을 사용하여 표현을 선택하려면 &lt;code&gt;format&lt;/code&gt; query 매개 변수를 사용하십시오 . 예를 들면 다음과 같습니다 &lt;code&gt;http://example.com/organizations/?format=csv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd4f70dc6a19ab7b0dd44d22d78b415ee791888" translate="yes" xml:space="preserve">
          <source>To serialize a queryset or list of objects instead of a single object instance, you should pass the &lt;code&gt;many=True&lt;/code&gt; flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.</source>
          <target state="translated">단일 객체 인스턴스 대신 쿼리 세트 또는 객체 목록을 직렬화하려면 &lt;code&gt;many=True&lt;/code&gt; 를 전달해야합니다. 기를 인스턴스화 할 때 플래그를 . 그런 다음 직렬화 할 쿼리 집합 또는 개체 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a0d893d42f9814fa1f0113e2769ee42ec5591d" translate="yes" xml:space="preserve">
          <source>To set these attributes you should override the &lt;code&gt;CursorPagination&lt;/code&gt; class, and then enable your custom pagination class as above.</source>
          <target state="translated">이러한 속성을 설정하려면 &lt;code&gt;CursorPagination&lt;/code&gt; 클래스를 재정의 한 다음 위와 같이 사용자 지정 페이지 매김 클래스를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="025b41f0106951e53c640b36085f381ba7d77c1b" translate="yes" xml:space="preserve">
          <source>To set these attributes you should override the &lt;code&gt;LimitOffsetPagination&lt;/code&gt; class, and then enable your custom pagination class as above.</source>
          <target state="translated">이러한 속성을 설정하려면 &lt;code&gt;LimitOffsetPagination&lt;/code&gt; 클래스를 재정의 한 다음 위와 같이 사용자 지정 페이지 매김 클래스를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="87e08378e1fb589fb1cf78151ad3d2724acd3e81" translate="yes" xml:space="preserve">
          <source>To set these attributes you should override the &lt;code&gt;PageNumberPagination&lt;/code&gt; class, and then enable your custom pagination class as above.</source>
          <target state="translated">이러한 속성을 설정하려면 &lt;code&gt;PageNumberPagination&lt;/code&gt; 클래스를 재정의 한 다음 위와 같이 사용자 지정 페이지 매김 클래스를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="02a5e68a9fb224c678b440c0515d2b397132319b" translate="yes" xml:space="preserve">
          <source>To support a wider set of request formats, or change the default format, &lt;a href=&quot;#configuration&quot;&gt;see the configuration section&lt;/a&gt;.</source>
          <target state="translated">보다 광범위한 요청 형식을 지원하거나 기본 형식을 변경 &lt;a href=&quot;#configuration&quot;&gt;하려면 구성 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="369fcf271bc639520ed63e048318a8b8bf18093f" translate="yes" xml:space="preserve">
          <source>To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:</source>
          <target state="translated">여러 업데이트를 지원하려면 명시 적으로 업데이트해야합니다. 다중 업데이트 코드를 작성할 때 다음을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="f7fc35638abfe65bc3ce534f20289e020cb3d2aa" translate="yes" xml:space="preserve">
          <source>To take advantage of the fact that our responses are no longer hardwired to a single content type let's add support for format suffixes to our API endpoints. Using format suffixes gives us URLs that explicitly refer to a given format, and means our API will be able to handle URLs such as &lt;a href=&quot;http://example.com/api/items/4.json&quot;&gt;http://example.com/api/items/4.json&lt;/a&gt;.</source>
          <target state="translated">응답이 더 이상 단일 컨텐츠 유형에 고정되어 있지 않다는 사실을 이용하기 위해 API 엔드 포인트에 형식 접미사에 대한 지원을 추가하십시오. 형식 접미사를 사용하면 지정된 형식을 명시 적으로 참조하는 URL이 제공되며 API에서 &lt;a href=&quot;http://example.com/api/items/4.json&quot;&gt;http://example.com/api/items/4.json&lt;/a&gt; 과 같은 URL을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="8264bb7965963e9995ef1eeb0e9d12f86f3b501e" translate="yes" xml:space="preserve">
          <source>To the client, this scheme is the same as &lt;code&gt;URLPathVersioning&lt;/code&gt;. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.</source>
          <target state="translated">클라이언트에게이 체계는 &lt;code&gt;URLPathVersioning&lt;/code&gt; 과 동일합니다 . . 유일한 차이점은 URL 키워드 인수 대신 URL 네임 스페이스를 사용하므로 Django 애플리케이션에서이를 구성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f9f4b19d03648d107eaee0416396c849418c5100" translate="yes" xml:space="preserve">
          <source>To unauthenticate subsequent requests, call &lt;code&gt;force_authenticate&lt;/code&gt; setting the user and/or token to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">후속 요청을 인증 해제하려면 &lt;code&gt;force_authenticate&lt;/code&gt; 를 호출 하여 사용자 및 / 또는 토큰을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee7504b4cb208d71042f250fd01430e5566f2b8" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;DjangoFilterBackend&lt;/code&gt;, first install &lt;code&gt;django-filter&lt;/code&gt;. Then add &lt;code&gt;django_filters&lt;/code&gt; to Django's &lt;code&gt;INSTALLED_APPS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DjangoFilterBackend&lt;/code&gt; 를 사용하려면 먼저 &lt;code&gt;django-filter&lt;/code&gt; 를 설치하십시오 . 그런 다음 Django의 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 에 &lt;code&gt;django_filters&lt;/code&gt; 를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b77ec37e4e4bf20ba1a7caecbfb6f5cfa38adf64" translate="yes" xml:space="preserve">
          <source>To use custom model permissions, override &lt;code&gt;DjangoModelPermissions&lt;/code&gt; and set the &lt;code&gt;.perms_map&lt;/code&gt; property. Refer to the source code for details.</source>
          <target state="translated">사용자 지정 모델 권한을 사용하려면 &lt;code&gt;DjangoModelPermissions&lt;/code&gt; 를 재정의 하고 &lt;code&gt;.perms_map&lt;/code&gt; 속성을 설정하십시오 . 자세한 내용은 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ba38987fc056c3ed6a0f4da21294c712cd58f86" translate="yes" xml:space="preserve">
          <source>To use it, you must have &lt;code&gt;django.contrib.auth.backends.RemoteUserBackend&lt;/code&gt; (or a subclass) in your &lt;code&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; setting. By default, &lt;code&gt;RemoteUserBackend&lt;/code&gt; creates &lt;code&gt;User&lt;/code&gt; objects for usernames that don't already exist. To change this and other behaviour, consult the &lt;a href=&quot;https://docs.djangoproject.com/en/stable/howto/auth-remote-user/&quot;&gt;Django documentation&lt;/a&gt;.</source>
          <target state="translated">사용하려면 &lt;code&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; 설정 에 &lt;code&gt;django.contrib.auth.backends.RemoteUserBackend&lt;/code&gt; (또는 서브 클래스) 가 있어야 합니다. 기본적으로 &lt;code&gt;RemoteUserBackend&lt;/code&gt; 는 아직 존재하지 않는 사용자 이름에 대한 &lt;code&gt;User&lt;/code&gt; 개체를 만듭니다 . 이 동작과 다른 동작을 변경하려면 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/howto/auth-remote-user/&quot;&gt;Django 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6442ef7997f89f4fd59c4bea2991d4334d069622" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;TokenAuthentication&lt;/code&gt; scheme you'll need to &lt;a href=&quot;#setting-the-authentication-scheme&quot;&gt;configure the authentication classes&lt;/a&gt; to include &lt;code&gt;TokenAuthentication&lt;/code&gt;, and additionally include &lt;code&gt;rest_framework.authtoken&lt;/code&gt; in your &lt;code&gt;INSTALLED_APPS&lt;/code&gt; setting:</source>
          <target state="translated">용도에 &lt;code&gt;TokenAuthentication&lt;/code&gt; 의 계획을 당신이해야 &lt;a href=&quot;#setting-the-authentication-scheme&quot;&gt;인증 클래스를 구성&lt;/a&gt; 포함 &lt;code&gt;TokenAuthentication&lt;/code&gt; 를 포함 추가 및 &lt;code&gt;rest_framework.authtoken&lt;/code&gt; 당신의 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 의 설정 :</target>
        </trans-unit>
        <trans-unit id="9c5c641515422f62c320c2d4a7fc01d34497026c" translate="yes" xml:space="preserve">
          <source>To validate numbers up to 999 with a resolution of 2 decimal places, you would use:</source>
          <target state="translated">소수점 이하 두 자리의 분해능으로 최대 999까지의 숫자를 검증하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8c9df6deea56c32d7ccd97ebedba821da0a0a9bd" translate="yes" xml:space="preserve">
          <source>To view all extra actions, call the &lt;code&gt;.get_extra_actions()&lt;/code&gt; method.</source>
          <target state="translated">추가 조치를 모두 보려면 &lt;code&gt;.get_extra_actions()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="8863653c0fc4dc646f9f0b1fdf19fd9bb8484291" translate="yes" xml:space="preserve">
          <source>To write a class-based validator, use the &lt;code&gt;__call__&lt;/code&gt; method. Class-based validators are useful as they allow you to parameterize and reuse behavior.</source>
          <target state="translated">클래스 기반 유효성 검사기를 작성하려면 &lt;code&gt;__call__&lt;/code&gt; 메서드를 사용하십시오 . 클래스 기반 유효성 검사기는 동작을 매개 변수화하고 재사용 할 수 있으므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="281f31156991888e7e39caf9690448383b3d8133" translate="yes" xml:space="preserve">
          <source>Together with &lt;a href=&quot;../authentication/index&quot;&gt;authentication&lt;/a&gt; and &lt;a href=&quot;../throttling/index&quot;&gt;throttling&lt;/a&gt;, permissions determine whether a request should be granted or denied access.</source>
          <target state="translated">&lt;a href=&quot;../authentication/index&quot;&gt;인증&lt;/a&gt; 및 &lt;a href=&quot;../throttling/index&quot;&gt;조절 기능&lt;/a&gt; 과 함께 권한은 요청에 대한 액세스 권한 부여 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5b41333466d1dffdd18160ec5207641822eba192" translate="yes" xml:space="preserve">
          <source>TokenAuthentication</source>
          <target state="translated">TokenAuthentication</target>
        </trans-unit>
        <trans-unit id="35e32249df6955ad352374c8bc8077a821209fb6" translate="yes" xml:space="preserve">
          <source>Trade-offs between views vs viewsets</source>
          <target state="translated">조회수와 조회수 간의 균형</target>
        </trans-unit>
        <trans-unit id="d827f10b95e1290dd8b209c02cc95b7fe16dcfc7" translate="yes" xml:space="preserve">
          <source>Trailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.</source>
          <target state="translated">후행 슬래시는 Django에서 일반적이지만 Rails와 같은 다른 프레임 워크에서는 기본적으로 사용되지 않습니다. 어떤 자바 스크립트 프레임 워크는 특정한 라우팅 스타일을 기대할 수 있지만, 어떤 스타일을 사용하기로 선택했는지는 주로 선호의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="15486dd74697a0717b1e45e1a66a27df9877b533" translate="yes" xml:space="preserve">
          <source>Tutorial 1: Serialization</source>
          <target state="translated">튜토리얼 1 : 직렬화</target>
        </trans-unit>
        <trans-unit id="e648895485e60c9b777401e2fc35724a11047d0e" translate="yes" xml:space="preserve">
          <source>Tutorial 2: Requests and Responses</source>
          <target state="translated">학습서 2 : 요청 및 응답</target>
        </trans-unit>
        <trans-unit id="ae5ea9fa95132ea6b6576e6d34d1c9850cd72d11" translate="yes" xml:space="preserve">
          <source>Tutorial 3: Class-based Views</source>
          <target state="translated">튜토리얼 3 : 클래스 기반 뷰</target>
        </trans-unit>
        <trans-unit id="943d128a430ce3318300bbb297895b221ec89567" translate="yes" xml:space="preserve">
          <source>Tutorial 4: Authentication &amp;amp; Permissions</source>
          <target state="translated">학습서 4 : 인증 및 권한</target>
        </trans-unit>
        <trans-unit id="ec9bccebc129dd4dc98b816f054d2ba346958fd1" translate="yes" xml:space="preserve">
          <source>Tutorial 5: Relationships &amp;amp; Hyperlinked APIs</source>
          <target state="translated">학습서 5 : 관계 및 하이퍼 링크 API</target>
        </trans-unit>
        <trans-unit id="8355c506cc2d2d85326982983e8ded8496b6821f" translate="yes" xml:space="preserve">
          <source>Tutorial 6: ViewSets &amp;amp; Routers</source>
          <target state="translated">튜토리얼 6 : 뷰셋 및 라우터</target>
        </trans-unit>
        <trans-unit id="eff9c2327274ef24d9cfa6e20d68da48bfd1f9c8" translate="yes" xml:space="preserve">
          <source>Twitter API rate limiting response</source>
          <target state="translated">트위터 API 속도 제한 응답</target>
        </trans-unit>
        <trans-unit id="f10a5ff943059595db5dd6c193a01c41ee0917ee" translate="yes" xml:space="preserve">
          <source>Two examples here are &lt;code&gt;'input_type'&lt;/code&gt; and &lt;code&gt;'base_template'&lt;/code&gt;:</source>
          <target state="translated">여기에 &lt;code&gt;'input_type'&lt;/code&gt; 과 &lt;code&gt;'base_template'&lt;/code&gt; 의 두 가지 예가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7f18dcda6cb9184aea40deb9d533db411a539be" translate="yes" xml:space="preserve">
          <source>Two patterns that you may want to use for this sort of validation include:</source>
          <target state="translated">이러한 종류의 유효성 검사에 사용할 수있는 두 가지 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a1528616e736f5336102d2be36876a73584574" translate="yes" xml:space="preserve">
          <source>Two things should be noticed here. First, we're using REST framework's &lt;code&gt;reverse&lt;/code&gt; function in order to return fully-qualified URLs; second, URL patterns are identified by convenience names that we will declare later on in our &lt;code&gt;snippets/urls.py&lt;/code&gt;.</source>
          <target state="translated">여기서 두 가지를 주목해야합니다. 먼저 정규화 된 URL을 반환하기 위해 REST 프레임 워크의 &lt;code&gt;reverse&lt;/code&gt; 기능을 사용하고 있습니다. 둘째, URL 패턴은 나중에 &lt;code&gt;snippets/urls.py&lt;/code&gt; 에서 선언 할 편의 이름으로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="de1506d4135b3246660abfe48be265fdfafb2606" translate="yes" xml:space="preserve">
          <source>Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an &lt;code&gt;Http404&lt;/code&gt; or &lt;code&gt;PermissionDenied&lt;/code&gt; exception, or a subclass of &lt;code&gt;APIException&lt;/code&gt;.</source>
          <target state="translated">일반적으로 렌더러는 일반 응답을 처리 &lt;code&gt;Http404&lt;/code&gt; 또는 Http404 또는 &lt;code&gt;PermissionDenied&lt;/code&gt; 예외 또는 &lt;code&gt;APIException&lt;/code&gt; 의 서브 클래스 와 같은 예외 발생으로 인한 응답에 관계없이 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="e52b0e63907c9ce1af1f5821b392fee027aebc5a" translate="yes" xml:space="preserve">
          <source>Typically the approach you should take is:</source>
          <target state="translated">일반적으로 취해야 할 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2d67f326167ed95c164b81a70d8eb9966b92e90" translate="yes" xml:space="preserve">
          <source>Typically we would recommend &lt;em&gt;not&lt;/em&gt; using inheritance on inner Meta classes, but instead declaring all options explicitly.</source>
          <target state="translated">일반적으로 내부 메타 클래스에서 상속을 사용 &lt;em&gt;하지&lt;/em&gt; 말고 대신 모든 옵션을 명시 적으로 선언하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6683a0d0ee023644b96c3778486d04868f24ccee" translate="yes" xml:space="preserve">
          <source>Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.</source>
          <target state="translated">일반적으로이 작업은 수행하지 않지만 대신 라우터에 뷰셋을 등록하고 urlconf가 자동으로 생성되도록합니다.</target>
        </trans-unit>
        <trans-unit id="e6dc8093ce8027000116e6f4f656f138a5c4a6ad" translate="yes" xml:space="preserve">
          <source>Typically when using the generic views, you'll override the view, and set several class attributes.</source>
          <target state="translated">일반적으로 일반 뷰를 사용하는 경우 뷰를 재정의하고 여러 클래스 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fe6fbe5c9e1c8de6226a0684f6a8861c972f7242" translate="yes" xml:space="preserve">
          <source>Typically you won't &lt;em&gt;need&lt;/em&gt; to specify the &lt;code&gt;basename&lt;/code&gt; argument, but if you have a viewset where you've defined a custom &lt;code&gt;get_queryset&lt;/code&gt; method, then the viewset may not have a &lt;code&gt;.queryset&lt;/code&gt; attribute set. If you try to register that viewset you'll see an error like this:</source>
          <target state="translated">일반적으로 &lt;code&gt;basename&lt;/code&gt; 인수 를 지정할 &lt;em&gt;필요&lt;/em&gt; 는 없지만 사용자 정의 &lt;code&gt;get_queryset&lt;/code&gt; 메소드를 정의한 &lt;code&gt;.queryset&lt;/code&gt; 세트 가있는 경우 뷰 세트에 .queryset 속성 세트 가 없을 수 있습니다 . 해당 뷰셋을 등록하려고하면 다음과 같은 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="172d0a54407cf6c6fefdf0f22aa06a355aa72744" translate="yes" xml:space="preserve">
          <source>Typically you'd instead control this by setting &lt;code&gt;order_by&lt;/code&gt; on the initial queryset, but using the &lt;code&gt;ordering&lt;/code&gt; parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.</source>
          <target state="translated">일반적으로 초기 쿼리 세트에서 &lt;code&gt;order_by&lt;/code&gt; 를 설정하여이를 제어 하지만 뷰 에서 &lt;code&gt;ordering&lt;/code&gt; 매개 변수를 사용하면 렌더링 된 템플릿에 컨텍스트로 자동 전달 될 수있는 방식으로 순서를 지정할 수 있습니다. 따라서 결과를 정렬하는 데 사용되는 열 헤더를 자동으로 다르게 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd291f98f26717871d6e95227b1ec811f58ed82" translate="yes" xml:space="preserve">
          <source>Typically you'll instantiate &lt;code&gt;SchemaGenerator&lt;/code&gt; with a &lt;code&gt;title&lt;/code&gt; argument, like so:</source>
          <target state="translated">일반적으로 다음 과 같이 &lt;code&gt;title&lt;/code&gt; 인수를 사용하여 &lt;code&gt;SchemaGenerator&lt;/code&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="e07c212f3ef9e1f544ba0f4a0a4565281eac10fe" translate="yes" xml:space="preserve">
          <source>Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.</source>
          <target state="translated">일반적으로 urlconf의 뷰셋에 뷰를 명시 적으로 등록하는 대신 라우터 클래스에 뷰셋을 등록하면 자동으로 urlconf가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="63aca8e531e62880b7371eb34047feaa06b49717" translate="yes" xml:space="preserve">
          <source>UNAUTHENTICATED_TOKEN</source>
          <target state="translated">UNAUTHENTICATED_TOKEN</target>
        </trans-unit>
        <trans-unit id="bf3d04a12cba6d2f3574c56a826c96908a74e3ce" translate="yes" xml:space="preserve">
          <source>UNAUTHENTICATED_USER</source>
          <target state="translated">UNAUTHENTICATED_USER</target>
        </trans-unit>
        <trans-unit id="f03205f4dd835b303c755dd261fb75bb7d13ffad" translate="yes" xml:space="preserve">
          <source>UNICODE_JSON</source>
          <target state="translated">UNICODE_JSON</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="f211db950c7ba3b16a34089c6911b2ff32c81742" translate="yes" xml:space="preserve">
          <source>URL Name</source>
          <target state="translated">URL 이름</target>
        </trans-unit>
        <trans-unit id="e38d14f6e3de2be1718db1d4cc6931c722e0c119" translate="yes" xml:space="preserve">
          <source>URL Style</source>
          <target state="translated">URL 스타일</target>
        </trans-unit>
        <trans-unit id="f636df1702a77ce3799d8f22686674131c94eb93" translate="yes" xml:space="preserve">
          <source>URL name: &lt;code&gt;'user-change_password'&lt;/code&gt;</source>
          <target state="translated">URL 이름 : &lt;code&gt;'user-change_password'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7cefe3a4f5e983d190190ecfa5e7e445dd2526c" translate="yes" xml:space="preserve">
          <source>URL name: &lt;code&gt;'user-set-password'&lt;/code&gt;</source>
          <target state="translated">URL 이름 : &lt;code&gt;'user-set-password'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5e3c3ea76077ae88b74dd8b3b59c4ffde45dec0" translate="yes" xml:space="preserve">
          <source>URL path: &lt;code&gt;^users/{pk}/change-password/$&lt;/code&gt;</source>
          <target state="translated">URL 경로 : &lt;code&gt;^users/{pk}/change-password/$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ba5397b5f92aaa6eb3940fede43c7b4c0f8353f" translate="yes" xml:space="preserve">
          <source>URL pattern: &lt;code&gt;^accounts/$&lt;/code&gt; Name: &lt;code&gt;'account-list'&lt;/code&gt;</source>
          <target state="translated">URL 패턴 : &lt;code&gt;^accounts/$&lt;/code&gt; 이름 : &lt;code&gt;'account-list'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16157308ceca64a7168d04e5f69a1ab9fad2ce29" translate="yes" xml:space="preserve">
          <source>URL pattern: &lt;code&gt;^accounts/{pk}/$&lt;/code&gt; Name: &lt;code&gt;'account-detail'&lt;/code&gt;</source>
          <target state="translated">URL 패턴 : &lt;code&gt;^accounts/{pk}/$&lt;/code&gt; 이름 : &lt;code&gt;'account-detail'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8be61bb049d7c71342d9d24b0140a762c0b5700" translate="yes" xml:space="preserve">
          <source>URL pattern: &lt;code&gt;^users/$&lt;/code&gt; Name: &lt;code&gt;'user-list'&lt;/code&gt;</source>
          <target state="translated">URL 패턴 : &lt;code&gt;^users/$&lt;/code&gt; 이름 : &lt;code&gt;'user-list'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd7747dcfa21eaa6946108c0dd04573a34a8c6c" translate="yes" xml:space="preserve">
          <source>URL pattern: &lt;code&gt;^users/{pk}/$&lt;/code&gt; Name: &lt;code&gt;'user-detail'&lt;/code&gt;</source>
          <target state="translated">URL 패턴 : &lt;code&gt;^users/{pk}/$&lt;/code&gt; 이름 : &lt;code&gt;'user-detail'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a923f8c7864bf6233ab5ab85a000ca8626825969" translate="yes" xml:space="preserve">
          <source>URL pattern: &lt;code&gt;^users/{pk}/set_password/$&lt;/code&gt;</source>
          <target state="translated">URL 패턴 : &lt;code&gt;^users/{pk}/set_password/$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d758af075c125b47dbdce868227d00fea1e78842" translate="yes" xml:space="preserve">
          <source>URLField</source>
          <target state="translated">URLField</target>
        </trans-unit>
        <trans-unit id="7ae1541ab4e4718b3cb54c35e1e7189a847fa5d0" translate="yes" xml:space="preserve">
          <source>URLPathVersioning</source>
          <target state="translated">URLPathVersioning</target>
        </trans-unit>
        <trans-unit id="7581518e7d8475f25aec7aa815a25c6deff744af" translate="yes" xml:space="preserve">
          <source>URLPatternsTestCase</source>
          <target state="translated">URLPatternsTestCase</target>
        </trans-unit>
        <trans-unit id="69e056525543abd6ad60b96af8a974e714078637" translate="yes" xml:space="preserve">
          <source>URL_FIELD_NAME</source>
          <target state="translated">URL_FIELD_NAME</target>
        </trans-unit>
        <trans-unit id="e7ddcaf33bcc0eae285db60d80df4be9cd72a68a" translate="yes" xml:space="preserve">
          <source>URL_FORMAT_OVERRIDE</source>
          <target state="translated">URL_FORMAT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="a4252f8d667c901a05eb128f64d13d28df010eb2" translate="yes" xml:space="preserve">
          <source>UUIDField</source>
          <target state="translated">UUIDField</target>
        </trans-unit>
        <trans-unit id="ee7ec6a9f518bceb95dd5b655218fd9d7972c622" translate="yes" xml:space="preserve">
          <source>UltraJSON</source>
          <target state="translated">UltraJSON</target>
        </trans-unit>
        <trans-unit id="5488d39de2f472e90b2a229505904dbaecba2a65" translate="yes" xml:space="preserve">
          <source>Unauthenticated requests should have full read-only access.</source>
          <target state="translated">인증되지 않은 요청에는 전체 읽기 전용 액세스 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c77ae049b06614d11858e261503186d29274e0c" translate="yes" xml:space="preserve">
          <source>Unauthenticated responses that are denied permission will result in an &lt;code&gt;HTTP 401 Unauthorized&lt;/code&gt; response with an appropriate WWW-Authenticate header. For example:</source>
          <target state="translated">권한이 거부 된 인증되지 않은 응답 은 적절한 WWW-Authenticate 헤더와 함께 &lt;code&gt;HTTP 401 Unauthorized&lt;/code&gt; 응답을 발생시킵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a62cfe7c7c5a419559b5430464fcae140ec5fa25" translate="yes" xml:space="preserve">
          <source>Unauthenticated responses that are denied permission will result in an &lt;code&gt;HTTP 403 Forbidden&lt;/code&gt; response.</source>
          <target state="translated">권한이 거부 된 인증되지 않은 응답은 &lt;code&gt;HTTP 403 Forbidden&lt;/code&gt; 응답을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8f3a0f4b11c022160eff37a7612186211a52b62c" translate="yes" xml:space="preserve">
          <source>Unauthorized and Forbidden responses</source>
          <target state="translated">무단 및 금지 된 답변</target>
        </trans-unit>
        <trans-unit id="2e609bbbf5247406682725f8ad4f26ae4c2947d1" translate="yes" xml:space="preserve">
          <source>Underspecify a renderer's media type, such as using &lt;code&gt;media_type = 'image/*'&lt;/code&gt;, and use the &lt;code&gt;Accept&lt;/code&gt; header to vary the encoding of the response.</source>
          <target state="translated">&lt;code&gt;media_type = 'image/*'&lt;/code&gt; 사용과 같은 렌더러의 미디어 유형을 잘못 지정 하고 &lt;code&gt;Accept&lt;/code&gt; 헤더를 사용 하여 응답 인코딩을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="403835690495a28bfcb16834f5ebe2d76d553832" translate="yes" xml:space="preserve">
          <source>Underspecifying the media type</source>
          <target state="translated">용지 종류를 잘못 지정</target>
        </trans-unit>
        <trans-unit id="e9337ca11be1ff748c472021c3aa4758555ada89" translate="yes" xml:space="preserve">
          <source>UniqueForDateValidator</source>
          <target state="translated">UniqueForDateValidator</target>
        </trans-unit>
        <trans-unit id="2232400c04661d2836d8d084c40fc1cf7ee640cb" translate="yes" xml:space="preserve">
          <source>UniqueForMonthValidator</source>
          <target state="translated">UniqueForMonthValidator</target>
        </trans-unit>
        <trans-unit id="8801e11cfca82871e025a0357bccd3ce72dcb951" translate="yes" xml:space="preserve">
          <source>UniqueForYearValidator</source>
          <target state="translated">UniqueForYearValidator</target>
        </trans-unit>
        <trans-unit id="db0a155f61a01ca6d3300a0cceffca3751cf4996" translate="yes" xml:space="preserve">
          <source>UniqueTogetherValidator</source>
          <target state="translated">UniqueTogetherValidator</target>
        </trans-unit>
        <trans-unit id="4c968b4f8fd7788b86df8dda86ba54420ab5edfc" translate="yes" xml:space="preserve">
          <source>UniqueValidator</source>
          <target state="translated">UniqueValidator</target>
        </trans-unit>
        <trans-unit id="387e7e1b8cdfbdd8c3ceab5077daf2c1d399e109" translate="yes" xml:space="preserve">
          <source>Unless it is explicitly set, the value for &lt;code&gt;DEFAULT_VERSIONING_CLASS&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. In this case the &lt;code&gt;request.version&lt;/code&gt; attribute will always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 설정하지 않는 한, 값 &lt;code&gt;DEFAULT_VERSIONING_CLASS&lt;/code&gt; 는 없을 것 &lt;code&gt;None&lt;/code&gt; . 이 경우 &lt;code&gt;request.version&lt;/code&gt; 속성은 항상 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="473768d571abcb5a51eb9b64dc7149a7f3b2ca6f" translate="yes" xml:space="preserve">
          <source>Unless our field is to be read-only, &lt;code&gt;to_internal_value&lt;/code&gt; must map back to a dict suitable for updating our target object. With &lt;code&gt;source='*'&lt;/code&gt;, the return from &lt;code&gt;to_internal_value&lt;/code&gt; will update the root validated data dictionary, rather than a single key.</source>
          <target state="translated">필드가 읽기 전용이 &lt;code&gt;to_internal_value&lt;/code&gt; 는 대상 객체 업데이트에 적합한 dict에 다시 매핑되어야합니다. 와 &lt;code&gt;source='*'&lt;/code&gt; ,의 반환 &lt;code&gt;to_internal_value&lt;/code&gt; 아니라 하나의 키보다, 루트 검증 데이터 사전을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1d5ebf20975fd4682bb81a20097b72422a36babd" translate="yes" xml:space="preserve">
          <source>Unless you want to heavily customize REST framework for some reason, you should always use an &lt;code&gt;APIView&lt;/code&gt; class or &lt;code&gt;@api_view&lt;/code&gt; function for views that return &lt;code&gt;Response&lt;/code&gt; objects. Doing so ensures that the view can perform content negotiation and select the appropriate renderer for the response, before it is returned from the view.</source>
          <target state="translated">어떤 이유로 REST 프레임 워크를 심하게 사용자 정의하지 않는 한, &lt;code&gt;Response&lt;/code&gt; 오브젝트 를 리턴하는보기에 항상 &lt;code&gt;APIView&lt;/code&gt; 클래스 또는 &lt;code&gt;@api_view&lt;/code&gt; 함수를 사용해야 합니다. 그렇게하면 뷰가 컨텐츠 협상을 수행하고 뷰에서 리턴되기 전에 응답에 적합한 렌더러를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="791e5cacac87731556604bb6ed04bd6da03fdbbe" translate="yes" xml:space="preserve">
          <source>Unlike all our other API endpoints, we don't want to use JSON, but instead just present an HTML representation. There are two styles of HTML renderer provided by REST framework, one for dealing with HTML rendered using templates, the other for dealing with pre-rendered HTML. The second renderer is the one we'd like to use for this endpoint.</source>
          <target state="translated">다른 모든 API 엔드 포인트와 달리 JSON을 사용하지 않고 HTML 표현 만 제시합니다. REST 프레임 워크에서 제공하는 두 가지 스타일의 HTML 렌더러가 있습니다. 하나는 템플리트를 사용하여 렌더링 된 HTML을 처리하고 다른 하나는 사전 렌더링 된 HTML을 처리합니다. 두 번째 렌더러는이 엔드 포인트에 사용하려는 렌더러입니다.</target>
        </trans-unit>
        <trans-unit id="fff5772e43aa59b5b757f7b2030143441be31438" translate="yes" xml:space="preserve">
          <source>Unlike basic HttpResponse objects, TemplateResponse objects retain the details of the context that was provided by the view to compute the response. The final output of the response is not computed until it is needed, later in the response process.</source>
          <target state="translated">기본 HttpResponse 객체와 달리 TemplateResponse 객체는 응답을 계산하기 위해 뷰에서 제공 한 컨텍스트의 세부 정보를 유지합니다. 응답의 최종 출력은 응답 프로세스 후반에 필요할 때까지 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031171ff9526149dcd18c6e50a1d7020785b5da2" translate="yes" xml:space="preserve">
          <source>Unlike regular &lt;code&gt;HttpResponse&lt;/code&gt; objects, you do not instantiate &lt;code&gt;Response&lt;/code&gt; objects with rendered content. Instead you pass in unrendered data, which may consist of any Python primitives.</source>
          <target state="translated">일반 &lt;code&gt;HttpResponse&lt;/code&gt; 객체 와 달리 렌더링 된 내용으로 &lt;code&gt;Response&lt;/code&gt; 객체를 인스턴스화하지 않습니다 . 대신 렌더링되지 않은 데이터를 전달합니다.이 데이터는 모든 Python 기본 요소로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425ea7a1a5fe8b6173a2217f66ab433b46a93376" translate="yes" xml:space="preserve">
          <source>UnsupportedMediaType</source>
          <target state="translated">UnsupportedMediaType</target>
        </trans-unit>
        <trans-unit id="c7a2e7be8205a5ec08cd93af543197f12b6e58e3" translate="yes" xml:space="preserve">
          <source>UpdateAPIView</source>
          <target state="translated">UpdateAPIView</target>
        </trans-unit>
        <trans-unit id="55a4cf812ba217c892d57152fba2afa17b16a384" translate="yes" xml:space="preserve">
          <source>UpdateModelMixin</source>
          <target state="translated">UpdateModelMixin</target>
        </trans-unit>
        <trans-unit id="2b756af82e9b17f11fd6dd32fe4ea07642f092e8" translate="yes" xml:space="preserve">
          <source>Updating nested serializers</source>
          <target state="translated">중첩 된 시리얼 라이저 업데이트</target>
        </trans-unit>
        <trans-unit id="67fa4712ef37bbc40d105a7467b369be155c2d4f" translate="yes" xml:space="preserve">
          <source>Updating our serializer</source>
          <target state="translated">시리얼 라이저 업데이트</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9140a7dd26d5a3fa03ee47ae2eeda8e6471683e9" translate="yes" xml:space="preserve">
          <source>Use different authentication policies for different parts of your API.</source>
          <target state="translated">API의 다른 부분에 다른 인증 정책을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63236daedf12b8462f124899274c6fc21365f453" translate="yes" xml:space="preserve">
          <source>Use these as per &lt;a href=&quot;https://docs.djangoproject.com/en/dev/topics/http/views/#customizing-error-views&quot;&gt;Django's Customizing error views documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.djangoproject.com/en/dev/topics/http/views/#customizing-error-views&quot;&gt;Django의 사용자 정의 오류보기 문서에&lt;/a&gt; 따라 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff4cdbe4326e78451f3419381c3f603aba32e245" translate="yes" xml:space="preserve">
          <source>Used and trusted by internationally recognised companies including &lt;a href=&quot;https://www.mozilla.org/en-US/about/&quot;&gt;Mozilla&lt;/a&gt;, &lt;a href=&quot;https://www.redhat.com/&quot;&gt;Red Hat&lt;/a&gt;, &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;, and &lt;a href=&quot;https://www.eventbrite.co.uk/about/&quot;&gt;Eventbrite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.mozilla.org/en-US/about/&quot;&gt;Mozilla&lt;/a&gt; , &lt;a href=&quot;https://www.redhat.com/&quot;&gt;Red Hat&lt;/a&gt; , &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; 및 &lt;a href=&quot;https://www.eventbrite.co.uk/about/&quot;&gt;Eventbrite를&lt;/a&gt; 포함하여 국제적으로 인정 된 회사에서 사용하고 신뢰합니다 .</target>
        </trans-unit>
        <trans-unit id="e3cb40bb50c1514f9a96d7a55e319848d84532fb" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;ModelSerializer&lt;/code&gt; to automatically generate fields if the corresponding model field includes a &lt;code&gt;choices=&amp;hellip;&lt;/code&gt; argument.</source>
          <target state="translated">해당 모델 필드에 &lt;code&gt;choices=&amp;hellip;&lt;/code&gt; 인수가 포함 된 경우 &lt;code&gt;ModelSerializer&lt;/code&gt; 에서 자동으로 필드를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e512db5888e22bf5fae4efc35a3063b2a0d26c5" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;create-only&lt;/strong&gt; endpoints.</source>
          <target state="translated">에 사용 &lt;strong&gt;만들 전용&lt;/strong&gt; 엔드 포인트.</target>
        </trans-unit>
        <trans-unit id="0e2013e3500659fe16f1bba1f0c25f17f7b952ab" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;delete-only&lt;/strong&gt; endpoints for a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;단일 모델 인스턴스의 &lt;/strong&gt;&lt;strong&gt;삭제 전용&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d334a16a31fa29bd425fd408a041f9eeab074b5f" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read or delete&lt;/strong&gt; endpoints to represent a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;단일 모델 인스턴스&lt;/strong&gt; 를 나타 내기 위해 엔드 포인트를 &lt;strong&gt;읽거나 삭제하는&lt;/strong&gt; 데 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78827fe7e60496a9f26a4d2c7d2451d00911d9c7" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read or update&lt;/strong&gt; endpoints to represent a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;단일 모델 인스턴스&lt;/strong&gt; 를 나타 내기 위해 &lt;strong&gt;읽기 또는 업데이트&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35c3d9d5dc38bb962b847f046817462165bb4e15" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read-only&lt;/strong&gt; endpoints to represent a &lt;strong&gt;collection of model instances&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;모델 인스턴스&lt;/strong&gt; 의 &lt;strong&gt;콜렉션&lt;/strong&gt; 을 나타 내기 위해 &lt;strong&gt;읽기 전용&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0616e53d2f7439b0a1475ce39959d6c96c98ec40" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read-only&lt;/strong&gt; endpoints to represent a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;단일 모델 인스턴스&lt;/strong&gt; 를 나타 내기 위해 &lt;strong&gt;읽기 전용&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c7e5635a2d59cabdf05543578cd225ba4741c31" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read-write-delete&lt;/strong&gt; endpoints to represent a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;읽기-쓰기-삭제&lt;/strong&gt; 엔드 포인트가 &lt;strong&gt;단일 모델 인스턴스&lt;/strong&gt; 를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0102d4d5edb69b299a9bcda609f694f32b0757f" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;read-write&lt;/strong&gt; endpoints to represent a &lt;strong&gt;collection of model instances&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;모델 인스턴스&lt;/strong&gt; 의 &lt;strong&gt;콜렉션&lt;/strong&gt; 을 나타 내기 위해 &lt;strong&gt;읽기-쓰기&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baf2e76bff64f34606c1b04780a1317827555645" translate="yes" xml:space="preserve">
          <source>Used for &lt;strong&gt;update-only&lt;/strong&gt; endpoints for a &lt;strong&gt;single model instance&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;단일 모델 인스턴스의 &lt;/strong&gt;&lt;strong&gt;업데이트 전용&lt;/strong&gt; 엔드 포인트에 사용됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc81b5aa018ea0b4cd1d2a538174534c6fbd2ef0" translate="yes" xml:space="preserve">
          <source>Useful things that you might want to do could include returning schema information, using a format such as &lt;a href=&quot;https://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt;, or returning debug information to admin users.</source>
          <target state="translated">유용한 정보로는 스키마 정보 반환, &lt;a href=&quot;https://json-schema.org/&quot;&gt;JSON 스키마&lt;/a&gt; 와 같은 형식 사용 또는 관리자에게 디버그 정보 반환 이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dad852c40f1d6f76671daad21a571c6087f79d71" translate="yes" xml:space="preserve">
          <source>User requests to either &lt;code&gt;ContactListView&lt;/code&gt; or &lt;code&gt;ContactDetailView&lt;/code&gt; would be restricted to a total of 1000 requests per-day. User requests to &lt;code&gt;UploadView&lt;/code&gt; would be restricted to 20 requests per day.</source>
          <target state="translated">&lt;code&gt;ContactListView&lt;/code&gt; 또는 &lt;code&gt;ContactDetailView&lt;/code&gt; 에 대한 사용자 요청은 하루에 총 1000 개의 요청으로 제한됩니다. &lt;code&gt;UploadView&lt;/code&gt; 에 대한 사용자 요청 은 하루 20 개의 요청으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="bf6fc08539981a606ea7b9c6c9fd7312edf88472" translate="yes" xml:space="preserve">
          <source>UserRateThrottle</source>
          <target state="translated">UserRateThrottle</target>
        </trans-unit>
        <trans-unit id="23ca9937a2bdd139c1512fe420f2e1d539f46771" translate="yes" xml:space="preserve">
          <source>Uses Django's &lt;code&gt;django.core.validators.RegexValidator&lt;/code&gt; for validation.</source>
          <target state="translated">확인을 위해 Django의 &lt;code&gt;django.core.validators.RegexValidator&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df554b4711fe98389f1f860425405b088074fc63" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HiddenField&lt;/code&gt;. This field will be present in &lt;code&gt;validated_data&lt;/code&gt; but &lt;em&gt;will not&lt;/em&gt; be used in the serializer output representation.</source>
          <target state="translated">&lt;code&gt;HiddenField&lt;/code&gt; 사용하기 . 이 필드는 &lt;code&gt;validated_data&lt;/code&gt; 에 있지만 시리얼 라이저 출력 표현에는 사용 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="23fb27ea7c4dbdb8af91a6054d2c01992fc301f4" translate="yes" xml:space="preserve">
          <source>Using Django manage.py command</source>
          <target state="translated">Django manage.py 명령 사용</target>
        </trans-unit>
        <trans-unit id="375f54646ca859c732331e4e1d141f66e93765df" translate="yes" xml:space="preserve">
          <source>Using Django's &lt;code&gt;RequestFactory&lt;/code&gt;, you'd need to explicitly encode the data yourself:</source>
          <target state="translated">Django의 &lt;code&gt;RequestFactory&lt;/code&gt; 를 사용 하면 데이터를 직접 명시 적으로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="67bfe95d72d53c8402d2f6cccdebd3a5561bc8e9" translate="yes" xml:space="preserve">
          <source>Using ModelSerializers</source>
          <target state="translated">ModelSerializers 사용</target>
        </trans-unit>
        <trans-unit id="a9e34237900dee7c706411bbbfc5ca522327c2d7" translate="yes" xml:space="preserve">
          <source>Using Routers</source>
          <target state="translated">라우터 사용</target>
        </trans-unit>
        <trans-unit id="b18baaa1a273cf738ae085164c5bfa7d688d560d" translate="yes" xml:space="preserve">
          <source>Using a custom field and &lt;code&gt;source='*'&lt;/code&gt; we can provide a nested representation of the coordinate pair:</source>
          <target state="translated">사용자 정의 필드와 &lt;code&gt;source='*'&lt;/code&gt; 를 사용하면 좌표 쌍의 중첩 표현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1c560bb0d4671e0140a660bc0c85eed9503151" translate="yes" xml:space="preserve">
          <source>Using a standard field with &lt;code&gt;read_only=True&lt;/code&gt;, but that also includes a &lt;code&gt;default=&amp;hellip;&lt;/code&gt; argument. This field &lt;em&gt;will&lt;/em&gt; be used in the serializer output representation, but cannot be set directly by the user.</source>
          <target state="translated">&lt;code&gt;read_only=True&lt;/code&gt; 와 함께 표준 필드를 사용 하지만 &lt;code&gt;default=&amp;hellip;&lt;/code&gt; 인수 도 포함합니다 . 이 필드 &lt;em&gt;는&lt;/em&gt; 시리얼 라이저 출력 표현에 사용되지만 사용자가 직접 설정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c18f203fbd019f83ecf2df9387bf75d70b208090" translate="yes" xml:space="preserve">
          <source>Using a unique identifying slug field on the related entity.</source>
          <target state="translated">관련 엔터티에서 고유 식별 슬러그 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3adc1d48c5ed070ff9aa7ad249000f817e53e803" translate="yes" xml:space="preserve">
          <source>Using accept headers with vendor media types</source>
          <target state="translated">공급 업체 미디어 유형에 수락 헤더 사용</target>
        </trans-unit>
        <trans-unit id="7a283044bfe63e44ce0d4ec7b6745b3271fc7cd8" translate="yes" xml:space="preserve">
          <source>Using an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.</source>
          <target state="translated">이러한 제약 조건을 만족하지 않는 순서 필드를 사용하면 일반적으로 작동하지만 커서 페이지 매김의 이점을 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="dac13607002c5c928425190f00b412417faef0d8" translate="yes" xml:space="preserve">
          <source>Using bare status codes in your responses isn't recommended. REST framework includes a set of named constants that you can use to make your code more obvious and readable.</source>
          <target state="translated">응답에 베어 상태 코드를 사용하지 않는 것이 좋습니다. REST 프레임 워크에는 코드를보다 명확하고 읽기 쉽게 만드는 데 사용할 수있는 명명 된 상수 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="743075968ddff720cb14b37c94fe7b547775401b" translate="yes" xml:space="preserve">
          <source>Using cache with apiview and viewsets</source>
          <target state="translated">apiview 및 뷰 세트와 함께 캐시 사용</target>
        </trans-unit>
        <trans-unit id="ad38c3148a7eeb3e918fb6099f750b0f7e61acf5" translate="yes" xml:space="preserve">
          <source>Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.</source>
          <target state="translated">프로젝트 전체에 걸쳐 많은 뷰에서 일관되게 반복해야하는 사용자 지정 동작이있는 경우 사용자 지정 기본 클래스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62b336c5f723f5fc2e83eca9946de97a22f82f7a" translate="yes" xml:space="preserve">
          <source>Using custom mixins is a good option if you have custom behavior that needs to be used.</source>
          <target state="translated">사용해야하는 사용자 지정 동작이있는 경우 사용자 지정 믹스 인을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df21be8590d38788937cb0a3a7cdb1f7357dcc95" translate="yes" xml:space="preserve">
          <source>Using generic class-based views</source>
          <target state="translated">일반 클래스 기반 뷰 사용</target>
        </trans-unit>
        <trans-unit id="85e71a18ff94234958e5e312e5d64d03a4f829b5" translate="yes" xml:space="preserve">
          <source>Using hyperlinking between entities.</source>
          <target state="translated">엔터티 간 하이퍼 링크 사용</target>
        </trans-unit>
        <trans-unit id="4b2c64344b17e1c3d6c432e862cba2a7ead6bd9e" translate="yes" xml:space="preserve">
          <source>Using include with routers</source>
          <target state="translated">라우터와 함께 포함 사용</target>
        </trans-unit>
        <trans-unit id="54a59821b006489f143ba9ff1774c5e1eb660ec1" translate="yes" xml:space="preserve">
          <source>Using mixins</source>
          <target state="translated">믹스 인 사용</target>
        </trans-unit>
        <trans-unit id="220d1404cbc8d785215e5c5e103955f5a5843ae4" translate="yes" xml:space="preserve">
          <source>Using numeric HTTP status codes in your views doesn't always make for obvious reading, and it's easy to not notice if you get an error code wrong. REST framework provides more explicit identifiers for each status code, such as &lt;code&gt;HTTP_400_BAD_REQUEST&lt;/code&gt; in the &lt;code&gt;status&lt;/code&gt; module. It's a good idea to use these throughout rather than using numeric identifiers.</source>
          <target state="translated">뷰에서 숫자 HTTP 상태 코드를 사용한다고해서 항상 읽을 수있는 것은 아니며 오류 코드가 잘못되었는지 쉽게 알 수 없습니다. REST 프레임 워크는 각 상태 코드에 대한 더 명확한 식별자 제공 &lt;code&gt;HTTP_400_BAD_REQUEST&lt;/code&gt; 의 &lt;code&gt;status&lt;/code&gt; 모듈. 숫자 식별자 대신 전체를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="135c8e2b21639c79d4fbf290ba4ea46dc75339c7" translate="yes" xml:space="preserve">
          <source>Using primary keys.</source>
          <target state="translated">기본 키 사용</target>
        </trans-unit>
        <trans-unit id="3996c1ba036228d4d284bd6e7a0d349452effab2" translate="yes" xml:space="preserve">
          <source>Using set_context()</source>
          <target state="translated">set_context () 사용</target>
        </trans-unit>
        <trans-unit id="7a3d333978d3a4d2af8fa56d8ab1c971d31f744b" translate="yes" xml:space="preserve">
          <source>Using source='*'</source>
          <target state="translated">source = '*'사용</target>
        </trans-unit>
        <trans-unit id="c37397eb4c1ecee20e21282de00b6a85c5ccfbef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;APIView&lt;/code&gt; class is pretty much the same as using a regular &lt;code&gt;View&lt;/code&gt; class, as usual, the incoming request is dispatched to an appropriate handler method such as &lt;code&gt;.get()&lt;/code&gt; or &lt;code&gt;.post()&lt;/code&gt;. Additionally, a number of attributes may be set on the class that control various aspects of the API policy.</source>
          <target state="translated">은 Using &lt;code&gt;APIView&lt;/code&gt; 의 클래스 것은 거의 정기적으로 사용하는 것과 같습니다 &lt;code&gt;View&lt;/code&gt; 평소와 같이, 클래스, 들어오는 요청과 같은 적절한 핸들러 메소드에 전달됩니다 &lt;code&gt;.get()&lt;/code&gt; 또는 &lt;code&gt;.post()&lt;/code&gt; . 또한 API 정책의 다양한 측면을 제어하는 ​​많은 속성이 클래스에 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0083ca2cb3332a47c10b77167ae35d8714909550" translate="yes" xml:space="preserve">
          <source>Using the default string representation of the related entity.</source>
          <target state="translated">관련 엔터티의 기본 문자열 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1629af6f0b9f6798b704d07f4a4e42e5aaf54549" translate="yes" xml:space="preserve">
          <source>Using the example from the previous section:</source>
          <target state="translated">이전 섹션의 예제를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="fcb7aba392f8e4e25576823a8f74b4fd2661faf3" translate="yes" xml:space="preserve">
          <source>Using the format argument</source>
          <target state="translated">형식 인수 사용</target>
        </trans-unit>
        <trans-unit id="43535957e004471b5ad501613496542a059d4616" translate="yes" xml:space="preserve">
          <source>Using the mixin classes we've rewritten the views to use slightly less code than before, but we can go one step further. REST framework provides a set of already mixed-in generic views that we can use to trim down our &lt;code&gt;views.py&lt;/code&gt; module even more.</source>
          <target state="translated">mixin 클래스를 사용하여 이전보다 약간 적은 코드를 사용하도록 뷰를 다시 작성했지만 한 단계 더 나아갈 수 있습니다. REST 프레임 워크는 &lt;code&gt;views.py&lt;/code&gt; 모듈을 더욱 다듬기 위해 사용할 수있는 이미 혼합 된 일반 뷰 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b17656a3a06d56d48acbd3d735b83e4dc6fa8f2a" translate="yes" xml:space="preserve">
          <source>Using this style to create basic tests of a few core piece of functionality is a powerful way to validate your live service. Doing so may require some careful attention to setup and teardown to ensure that the tests run in a way that they do not directly affect customer data.</source>
          <target state="translated">이 스타일을 사용하여 몇 가지 핵심 기능에 대한 기본 테스트를 작성하면 라이브 서비스를 검증 할 수 있습니다. 이렇게하면 고객 데이터에 직접 영향을 미치지 않는 방식으로 테스트가 실행되도록 설정 및 해제에주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="2a5351726ea32a5aafabdce36cc71a1b6242c04a" translate="yes" xml:space="preserve">
          <source>Using viewsets can be a really useful abstraction. It helps ensure that URL conventions will be consistent across your API, minimizes the amount of code you need to write, and allows you to concentrate on the interactions and representations your API provides rather than the specifics of the URL conf.</source>
          <target state="translated">뷰셋을 사용하는 것은 정말 유용한 추상화 일 수 있습니다. URL 컨벤션이 API에서 일관성을 유지하고 작성해야하는 코드의 양을 최소화하며 URL conf의 특성보다는 API가 제공하는 상호 작용 및 표현에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1589abb797292065f772352dd6110fadfd1ba85" translate="yes" xml:space="preserve">
          <source>Using with a hidden date field.</source>
          <target state="translated">숨겨진 날짜 필드와 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b81924b47f49728a86c920a099ed2a783589d5d1" translate="yes" xml:space="preserve">
          <source>Using with a read-only date field.</source>
          <target state="translated">읽기 전용 날짜 필드와 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2bfee6c1dcada5e4a1cb8297a3d6fe06400ca259" translate="yes" xml:space="preserve">
          <source>Using with a writable date field.</source>
          <target state="translated">쓰기 가능한 날짜 필드와 함께 사용.</target>
        </trans-unit>
        <trans-unit id="4ddb9e44110954596183c2fc7618e5ab81450f78" translate="yes" xml:space="preserve">
          <source>Using with i18n_patterns</source>
          <target state="translated">i18n_patterns와 함께 사용</target>
        </trans-unit>
        <trans-unit id="287fc2eb785ba6b98a716e39c813df4a0250cd2c" translate="yes" xml:space="preserve">
          <source>Using with views that do not include a queryset attribute.</source>
          <target state="translated">queryset 속성이 포함되지 않은 뷰와 함께 사용.</target>
        </trans-unit>
        <trans-unit id="e5516e72d8c724ca01a9f0ca17864bbb1fb5f6b7" translate="yes" xml:space="preserve">
          <source>Using your custom pagination class</source>
          <target state="translated">맞춤 페이지 매김 클래스 사용</target>
        </trans-unit>
        <trans-unit id="174bcb0924f1eea73be9c4697ce52d2480589c3b" translate="yes" xml:space="preserve">
          <source>VERSION_PARAM</source>
          <target state="translated">VERSION_PARAM</target>
        </trans-unit>
        <trans-unit id="7ec7d09e7f0ddf4a7e3d904ec717e4bc5f2a3d50" translate="yes" xml:space="preserve">
          <source>VIEW_DESCRIPTION_FUNCTION</source>
          <target state="translated">VIEW_DESCRIPTION_FUNCTION</target>
        </trans-unit>
        <trans-unit id="e732e90f26b9c2954af334f0a77680851d664428" translate="yes" xml:space="preserve">
          <source>VIEW_NAME_FUNCTION</source>
          <target state="translated">VIEW_NAME_FUNCTION</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="ac4347d7058687d3f956865b705b09b0ab3c0575" translate="yes" xml:space="preserve">
          <source>Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the &quot;non_field_errors&quot; key, or whatever string value has been set for the &lt;code&gt;NON_FIELD_ERRORS_KEY&lt;/code&gt; setting.</source>
          <target state="translated">유효성 검사 오류는 약간 다르게 처리되며 필드 이름이 응답의 키로 포함됩니다. 유효성 검사 오류가 특정 필드에 고유하지 않은 경우 &quot;non_field_errors&quot;키 또는 &lt;code&gt;NON_FIELD_ERRORS_KEY&lt;/code&gt; 설정에 설정된 문자열 값을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="74225e813403f285a5aa4c7b16463ba95c8586d6" translate="yes" xml:space="preserve">
          <source>Validation in Django REST framework serializers is handled a little differently to how validation works in Django's &lt;code&gt;ModelForm&lt;/code&gt; class.</source>
          <target state="translated">Django REST 프레임 워크 serializer의 유효성 검사는 Django의 &lt;code&gt;ModelForm&lt;/code&gt; 클래스 에서 유효성 검사가 작동하는 방식과 약간 다르게 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="638b2915349cdee99e0a00ea25adacf5bb520afb" translate="yes" xml:space="preserve">
          <source>Validation in REST framework</source>
          <target state="translated">REST 프레임 워크의 유효성 검증</target>
        </trans-unit>
        <trans-unit id="13bc23c96316e00a87a163004ce4ef98a19ea996" translate="yes" xml:space="preserve">
          <source>ValidationError</source>
          <target state="translated">ValidationError</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="80245956c4558e83746b544f6624988a9854f48e" translate="yes" xml:space="preserve">
          <source>Validators can be useful for re-using validation logic between different types of fields.</source>
          <target state="translated">유효성 검사기는 서로 다른 유형의 필드간에 유효성 검사 논리를 재사용하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f0cbebc717b5085ae4b5f335c1c2e491b49f7b" translate="yes" xml:space="preserve">
          <source>Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that &lt;em&gt;is&lt;/em&gt; available as input to the validator.</source>
          <target state="translated">시리얼 라이저의 여러 분야에 걸쳐 적용되는 검사기 때로는 API 클라이언트가 제공되어서는 안 필드 입력을 요구할 수 있습니다, 그러나 그것은 &lt;em&gt;이다&lt;/em&gt; 검사기에 대한 입력으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f2a777d9673f61105e5c5ab441d9564f075502" translate="yes" xml:space="preserve">
          <source>Varying behavior based on the version</source>
          <target state="translated">버전에 따른 다양한 동작</target>
        </trans-unit>
        <trans-unit id="4d9ef8baf24a96f95adb7d605501bfaa67d5ba16" translate="yes" xml:space="preserve">
          <source>Varying behaviour by media type</source>
          <target state="translated">미디어 유형별 다양한 동작</target>
        </trans-unit>
        <trans-unit id="89ffcaa9efe48fe4e0d1959643dab5f11772254c" translate="yes" xml:space="preserve">
          <source>Versioned APIs and hyperlinked serializers</source>
          <target state="translated">버전이 지정된 API 및 하이퍼 링크 된 직렬 변환기</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="4eb03ee7034c892207a4d58a72db0d4ba6f27f3d" translate="yes" xml:space="preserve">
          <source>Versioning an interface is just a &quot;polite&quot; way to kill deployed clients.</source>
          <target state="translated">인터페이스의 버전 관리는 배포 된 클라이언트를 종료시키는 &quot;정치 된&quot;방법입니다.</target>
        </trans-unit>
        <trans-unit id="61ec560aed8718800e29efe0dc8ddde03881b027" translate="yes" xml:space="preserve">
          <source>Versioning based on accept headers is &lt;a href=&quot;http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http#i_want_my_api_to_be_versioned&quot;&gt;generally considered&lt;/a&gt; as &lt;a href=&quot;https://github.com/interagent/http-api-design/blob/master/en/foundations/require-versioning-in-the-accepts-header.md&quot;&gt;best practice&lt;/a&gt;, although other styles may be suitable depending on your client requirements.</source>
          <target state="translated">수락 헤더를 기반으로 한 버전 관리는 &lt;a href=&quot;http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http#i_want_my_api_to_be_versioned&quot;&gt;일반적&lt;/a&gt; 으로 &lt;a href=&quot;https://github.com/interagent/http-api-design/blob/master/en/foundations/require-versioning-in-the-accepts-header.md&quot;&gt;모범 사례&lt;/a&gt; 로 간주 되지만 클라이언트 요구 사항에 따라 다른 스타일이 적합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ada19dad6d735ae4a0a512e2236f025f63c960" translate="yes" xml:space="preserve">
          <source>Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.</source>
          <target state="translated">버전 관리는 들어오는 클라이언트 요청에 의해 결정되며 요청 URL을 기반으로하거나 요청 헤더를 기반으로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebf71f360bbafcef8c0a69e072160b68509e5783" translate="yes" xml:space="preserve">
          <source>Versioning settings</source>
          <target state="translated">버전 설정</target>
        </trans-unit>
        <trans-unit id="efb37212bf6adb2df402e440a7b2d956b587fec6" translate="yes" xml:space="preserve">
          <source>Versioning with REST framework</source>
          <target state="translated">REST 프레임 워크를 사용한 버전 관리</target>
        </trans-unit>
        <trans-unit id="3066abfae61ba54108c8f8d101d9379e543cc14c" translate="yes" xml:space="preserve">
          <source>View names and descriptions</source>
          <target state="translated">이름 및 설명보기</target>
        </trans-unit>
        <trans-unit id="68a23f6a43ecde8d98c0736c5d2ffa9a799ecddc" translate="yes" xml:space="preserve">
          <source>View schema decorator</source>
          <target state="translated">스키마 데코레이터보기</target>
        </trans-unit>
        <trans-unit id="742d46505dd45f18ad1305d0f3804562c7561ead" translate="yes" xml:space="preserve">
          <source>ViewSet</source>
          <target state="translated">ViewSet</target>
        </trans-unit>
        <trans-unit id="a220503a1f27097e91ddfc4a01a740a424e89f51" translate="yes" xml:space="preserve">
          <source>ViewSet actions</source>
          <target state="translated">ViewSet 작업</target>
        </trans-unit>
        <trans-unit id="f66002573d47f064edce56592ed274cfa3147b17" translate="yes" xml:space="preserve">
          <source>ViewSets</source>
          <target state="translated">ViewSets</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="9506c7e8eca203a77838e2fb141b2ef29d3ae046" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;highly recommend&lt;/strong&gt; and only officially support the latest patch release of each Python and Django series.</source>
          <target state="translated">우리는 &lt;strong&gt;매우 추천&lt;/strong&gt; 하고 공식적으로 각 파이썬과 장고 시리즈의 최신 패치 릴리스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bb3818408184fea7fcd4c179228ee15aa81144ca" translate="yes" xml:space="preserve">
          <source>We also need to wire up the root urlconf, in the &lt;code&gt;tutorial/urls.py&lt;/code&gt; file, to include our snippet app's URLs.</source>
          <target state="translated">또한 스 니펫 앱의 URL을 포함 시키려면 &lt;code&gt;tutorial/urls.py&lt;/code&gt; 파일 에 루트 urlconf를 연결해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ec87df981c3ac8e9ce8fa34855b9cc083ba24c19" translate="yes" xml:space="preserve">
          <source>We can actually also save ourselves some time by using the &lt;code&gt;ModelSerializer&lt;/code&gt; class, as we'll see later, but for now we'll keep our serializer definition explicit.</source>
          <target state="translated">나중에 보 겠지만 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스 를 사용하면 실제로 시간을 절약 할 수 있지만 지금은 serializer 정의를 명시 적으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="c7357c78487a4ec141f4068ef3ad5c0693933da0" translate="yes" xml:space="preserve">
          <source>We can add a login view for use with the browsable API, by editing the URLconf in our project-level &lt;code&gt;urls.py&lt;/code&gt; file.</source>
          <target state="translated">프로젝트 수준의 &lt;code&gt;urls.py&lt;/code&gt; 파일 에서 URLconf를 편집하여 탐색 가능한 API와 함께 사용할 로그인보기를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e91338811fc5992d65883b701199900996947421" translate="yes" xml:space="preserve">
          <source>We can also serialize querysets instead of model instances. To do so we simply add a &lt;code&gt;many=True&lt;/code&gt; flag to the serializer arguments.</source>
          <target state="translated">모델 인스턴스 대신 쿼리 세트를 직렬화 할 수도 있습니다. 그렇게하려면 serializer 인수에 &lt;code&gt;many=True&lt;/code&gt; 플래그를 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="a717a74ef26b3208e373b98e151dc61be61bc855" translate="yes" xml:space="preserve">
          <source>We can also write our API views using class-based views, rather than function based views. As we'll see this is a powerful pattern that allows us to reuse common functionality, and helps us keep our code &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt;.</source>
          <target state="translated">함수 기반 뷰가 아닌 클래스 기반 뷰를 사용하여 API 뷰를 작성할 수도 있습니다. 보시다시피 이것은 일반적인 기능을 재사용하고 코드를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY로&lt;/a&gt; 유지하는 데 도움이되는 강력한 패턴입니다 .</target>
        </trans-unit>
        <trans-unit id="c15b377f5e9d2e5d434a1f6d5d59d23cef1f3194" translate="yes" xml:space="preserve">
          <source>We can change the default list style to use pagination, by modifying our &lt;code&gt;tutorial/settings.py&lt;/code&gt; file slightly. Add the following setting:</source>
          <target state="translated">&lt;code&gt;tutorial/settings.py&lt;/code&gt; 파일을 약간 수정하여 페이지 매김을 사용하도록 기본 목록 스타일을 변경할 수 있습니다. 다음 설정을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ef5440f130e44e0d1e83f094b358266c1293bb9e" translate="yes" xml:space="preserve">
          <source>We can control the format of the response that we get back, either by using the &lt;code&gt;Accept&lt;/code&gt; header:</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; 헤더 를 사용하여 응답의 형식을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="331bdc4d2fe6612200a32524da73f1c67923e3d7" translate="yes" xml:space="preserve">
          <source>We can easily break these down into individual views if we need to, but using viewsets keeps the view logic nicely organized as well as being very concise.</source>
          <target state="translated">필요한 경우 이러한 뷰를 개별 뷰로 쉽게 세분화 할 수 있지만 뷰 세트를 사용하면 뷰 논리를 깔끔하게 정리하고 간결하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c45f595e6ac0beb87c993cac9065b2f02279f16" translate="yes" xml:space="preserve">
          <source>We can easily re-write our existing serializers to use hyperlinking. In your &lt;code&gt;snippets/serializers.py&lt;/code&gt; add:</source>
          <target state="translated">하이퍼 링크를 사용하기 위해 기존 시리얼 라이저를 쉽게 다시 작성할 수 있습니다. 당신의에서 &lt;code&gt;snippets/serializers.py&lt;/code&gt; 추가 :</target>
        </trans-unit>
        <trans-unit id="3adb785eba41b22aa74ed23e1b5844b5a2a5d982" translate="yes" xml:space="preserve">
          <source>We can get a list of all of the snippets, as before.</source>
          <target state="translated">이전과 같이 모든 스 니펫 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cba69ea35ddeb2dc80f4c7b9a9120672786010" translate="yes" xml:space="preserve">
          <source>We can make a successful request by including the username and password of one of the users we created earlier.</source>
          <target state="translated">앞서 만든 사용자 중 하나의 사용자 이름과 비밀번호를 포함시켜 요청을 성공적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08c1acc00a8395d9e174d5e775a055c79c36be3" translate="yes" xml:space="preserve">
          <source>We can now access our API, both from the command-line, using tools like &lt;code&gt;curl&lt;/code&gt;...</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 과 같은 도구를 사용하여 명령 행에서 API에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6844d6bc4c50b2b621e85bff5411d5d12c69cf2" translate="yes" xml:space="preserve">
          <source>We can now reuse our custom &lt;code&gt;StringListField&lt;/code&gt; class throughout our application, without having to provide a &lt;code&gt;child&lt;/code&gt; argument to it.</source>
          <target state="translated">이제 &lt;code&gt;child&lt;/code&gt; 인수를 제공하지 않고도 응용 프로그램 전체에서 사용자 정의 &lt;code&gt;StringListField&lt;/code&gt; 클래스를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb1c592bd4f76908b60ed13dc63c8b9c32dfbabf" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;CommentSerializer&lt;/code&gt; to serialize a comment, or list of comments. Again, using the &lt;code&gt;Serializer&lt;/code&gt; class looks a lot like using a &lt;code&gt;Form&lt;/code&gt; class.</source>
          <target state="translated">이제 &lt;code&gt;CommentSerializer&lt;/code&gt; 를 사용 하여 주석 또는 주석 목록을 직렬화 할 수 있습니다 . 다시 말하지만, &lt;code&gt;Serializer&lt;/code&gt; 클래스를 사용하는 것은 &lt;code&gt;Form&lt;/code&gt; 클래스를 사용하는 것과 매우 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="ee7fc949c27135f70f9daaaf941f2daea5f1b3db" translate="yes" xml:space="preserve">
          <source>We can now use this class to serialize single &lt;code&gt;HighScore&lt;/code&gt; instances:</source>
          <target state="translated">이제이 클래스를 사용하여 단일 &lt;code&gt;HighScore&lt;/code&gt; 인스턴스 를 직렬화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1b98f32488e38cabf0531dd1ead64447ecefd4" translate="yes" xml:space="preserve">
          <source>We can override &lt;code&gt;.get_queryset()&lt;/code&gt; to deal with URLs such as &lt;code&gt;http://example.com/api/purchases?username=denvercoder9&lt;/code&gt;, and filter the queryset only if the &lt;code&gt;username&lt;/code&gt; parameter is included in the URL:</source>
          <target state="translated">&lt;code&gt;http://example.com/api/purchases?username=denvercoder9&lt;/code&gt; 와 같은 URL을 처리하기 위해 &lt;code&gt;.get_queryset()&lt;/code&gt; 을 재정의 하고 &lt;code&gt;username&lt;/code&gt; 매개 변수가 URL에 포함 된 경우에만 queryset을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67057719fc8b1a208b75b8fc3672b8225a9e8931" translate="yes" xml:space="preserve">
          <source>We can test our API using &lt;a href=&quot;https://curl.haxx.se/&quot;&gt;curl&lt;/a&gt; or &lt;a href=&quot;https://github.com/jakubroztocil/httpie#installation&quot;&gt;httpie&lt;/a&gt;. Httpie is a user friendly http client that's written in Python. Let's install that.</source>
          <target state="translated">&lt;a href=&quot;https://curl.haxx.se/&quot;&gt;curl&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/jakubroztocil/httpie#installation&quot;&gt;httpie를&lt;/a&gt; 사용하여 API를 테스트 할 수 있습니다 . Httpie는 Python으로 작성된 사용자 친화적 인 http 클라이언트입니다. 설치해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a0225018ce6823611f3602a38ea3230af273b953" translate="yes" xml:space="preserve">
          <source>We could achieve the same behavior by overriding &lt;code&gt;get_queryset()&lt;/code&gt; on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.</source>
          <target state="translated">뷰에서 &lt;code&gt;get_queryset()&lt;/code&gt; 을 재정 의하여 동일한 동작을 달성 할 수 있지만 필터 백엔드를 사용하면 여러 뷰에이 제한을 더 쉽게 추가하거나 전체 API에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e1d86db82a56a119ba4cae2ce52d6b8aafeb87" translate="yes" xml:space="preserve">
          <source>We could also customize the pagination style if we needed too, but in this case we'll just stick with the default.</source>
          <target state="translated">필요한 경우 페이지 매김 스타일을 사용자 정의 할 수도 있지만이 경우 기본값을 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9caab2c770ec5b2135ec41d4bb212e6b4207cb" translate="yes" xml:space="preserve">
          <source>We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized.</source>
          <target state="translated">각 인스턴스 유형을 사용하여 태그 지정 인스턴스를 직렬화하는 데 사용할 수있는 사용자 정의 필드를 정의하여 직렬화 방법을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9101c9fc48a2e91028983b657c1be9e2b6b59954" translate="yes" xml:space="preserve">
          <source>We don't necessarily need to add these extra url patterns in, but it gives us a simple, clean way of referring to a specific format.</source>
          <target state="translated">이러한 추가 URL 패턴을 반드시 추가 할 필요는 없지만 특정 형식을 간단하고 깔끔하게 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e952630e210e13474639887e8e1e95956bb0013" translate="yes" xml:space="preserve">
          <source>We don't need our &lt;code&gt;JSONResponse&lt;/code&gt; class in &lt;code&gt;views.py&lt;/code&gt; any more, so go ahead and delete that. Once that's done we can start refactoring our views slightly.</source>
          <target state="translated">우리는 우리의 필요가 없습니다 &lt;code&gt;JSONResponse&lt;/code&gt; 의 클래스 &lt;code&gt;views.py&lt;/code&gt; 그래서 가서 그 삭제, 더 이상. 완료되면 뷰를 약간 리팩토링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29d02067657117968fd7ebb926aafed0b675c54" translate="yes" xml:space="preserve">
          <source>We'd also need to make sure that when the model is saved, that we populate the highlighted field, using the &lt;code&gt;pygments&lt;/code&gt; code highlighting library.</source>
          <target state="translated">또한 모델이 저장 될 때 &lt;code&gt;pygments&lt;/code&gt; 코드 강조 라이브러리를 사용하여 강조 표시된 필드를 채우도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b0ab45df765fa3565d7ed33bf6c93e48f4f8a1b" translate="yes" xml:space="preserve">
          <source>We'd then need to setup the custom class in our configuration:</source>
          <target state="translated">그런 다음 구성에서 사용자 정의 클래스를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="51047a26c580cf45c5ea707bb1bbd8fd7ab55586" translate="yes" xml:space="preserve">
          <source>We'll also add a couple of views to &lt;code&gt;views.py&lt;/code&gt;. We'd like to just use read-only views for the user representations, so we'll use the &lt;code&gt;ListAPIView&lt;/code&gt; and &lt;code&gt;RetrieveAPIView&lt;/code&gt; generic class-based views.</source>
          <target state="translated">&lt;code&gt;views.py&lt;/code&gt; 에 몇 개의 뷰를 추가 할 것 입니다. 우리는 사용자 표현에 읽기 전용 뷰를 사용하기를 원하므로 &lt;code&gt;ListAPIView&lt;/code&gt; 및 &lt;code&gt;RetrieveAPIView&lt;/code&gt; 일반 클래스 기반 뷰를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d90ca6d65a76ed6bd72f8d9e48914e8e032f7b74" translate="yes" xml:space="preserve">
          <source>We'll also create an initial user named &lt;code&gt;admin&lt;/code&gt; with a password of &lt;code&gt;password123&lt;/code&gt;. We'll authenticate as that user later in our example.</source>
          <target state="translated">또한 password123의 &lt;code&gt;password123&lt;/code&gt; &lt;code&gt;admin&lt;/code&gt; 이라는 초기 사용자를 작성 합니다 . 이 예에서 나중에 해당 사용자로 인증합니다.</target>
        </trans-unit>
        <trans-unit id="9d6e8381e0c5c49cabde4cf0a10d4d20d03ae03e" translate="yes" xml:space="preserve">
          <source>We'll also need a view which corresponds to an individual snippet, and can be used to retrieve, update or delete the snippet.</source>
          <target state="translated">또한 개별 스 니펫에 해당하는 뷰가 필요하며 스 니펫을 검색, 업데이트 또는 삭제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="882622554ec141de67e18bf55880e54b27efe25d" translate="yes" xml:space="preserve">
          <source>We'll also need to create an initial migration for our snippet model, and sync the database for the first time.</source>
          <target state="translated">또한 스 니펫 모델의 초기 마이그레이션을 작성하고 데이터베이스를 처음으로 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b26b2a0c1eec514bb2ddbecda0e3e7a422dd1e73" translate="yes" xml:space="preserve">
          <source>We'll also need to refactor our &lt;code&gt;snippets/urls.py&lt;/code&gt; slightly now that we're using class-based views.</source>
          <target state="translated">또한 클래스 기반 뷰를 사용 하고 있으므로 &lt;code&gt;snippets/urls.py&lt;/code&gt; 를 약간 리팩터링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b185e8d406958e1f9b88ffb4981897a10e63e276" translate="yes" xml:space="preserve">
          <source>We'll create a read-write API for accessing information on the users of our project.</source>
          <target state="translated">프로젝트 사용자 정보에 액세스하기위한 읽기-쓰기 API를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b40451043ca64a4ce998a6eec0b576175d14c06c" translate="yes" xml:space="preserve">
          <source>We'll declare a serializer that we can use to serialize and deserialize data that corresponds to &lt;code&gt;Comment&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 객체에 해당하는 데이터를 직렬화하고 역 직렬화하는 데 사용할 수있는 직렬화기를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="fa7b46338f0ae41093f49451c913e4cbec345350" translate="yes" xml:space="preserve">
          <source>We'll need some extra imports:</source>
          <target state="translated">추가 수입품이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="3e4b9f6b89cb3aabbcc1e777b82484d71365e420" translate="yes" xml:space="preserve">
          <source>We'll need to add our new &lt;code&gt;snippets&lt;/code&gt; app and the &lt;code&gt;rest_framework&lt;/code&gt; app to &lt;code&gt;INSTALLED_APPS&lt;/code&gt;. Let's edit the &lt;code&gt;tutorial/settings.py&lt;/code&gt; file:</source>
          <target state="translated">새 &lt;code&gt;snippets&lt;/code&gt; 앱과 &lt;code&gt;rest_framework&lt;/code&gt; 앱을 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 에 추가해야합니다 . &lt;code&gt;tutorial/settings.py&lt;/code&gt; 파일을 편집 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="ddda8bc6cfdffb81052536251f61c1d71daeebf1" translate="yes" xml:space="preserve">
          <source>We'll see how we can start to improve things in &lt;a href=&quot;../2-requests-and-responses/index&quot;&gt;part 2 of the tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../2-requests-and-responses/index&quot;&gt;튜토리얼 2 부&lt;/a&gt; 에서 개선을 시작할 수있는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="afee2a404766720c21b069f1557b3f9178a62baf" translate="yes" xml:space="preserve">
          <source>We'll start by rewriting the root view as a class-based view. All this involves is a little bit of refactoring of &lt;code&gt;views.py&lt;/code&gt;.</source>
          <target state="translated">루트 뷰를 클래스 기반 뷰로 다시 작성합니다. 이 모든 것은 &lt;code&gt;views.py&lt;/code&gt; 의 약간의 리팩토링입니다 .</target>
        </trans-unit>
        <trans-unit id="8905ba1d66f179603aaf04c7965b239b403a0b99" translate="yes" xml:space="preserve">
          <source>We'll take a moment to examine exactly what's happening here. We're building our view using &lt;code&gt;GenericAPIView&lt;/code&gt;, and adding in &lt;code&gt;ListModelMixin&lt;/code&gt; and &lt;code&gt;CreateModelMixin&lt;/code&gt;.</source>
          <target state="translated">여기서 무슨 일이 일어나고 있는지 정확히 조사 할 것입니다. &lt;code&gt;GenericAPIView&lt;/code&gt; 를 사용하여 뷰를 작성 하고 &lt;code&gt;ListModelMixin&lt;/code&gt; 및 &lt;code&gt;CreateModelMixin&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="fc6619a1bd55f1cdb6edd41a46b391b33d5ae42a" translate="yes" xml:space="preserve">
          <source>We're doing okay so far, we've got a serialization API that feels pretty similar to Django's Forms API, and some regular Django views.</source>
          <target state="translated">우리는 지금까지 잘하고 있습니다 .Django의 Forms API와 비슷한 느낌의 직렬화 API와 일부 Django 뷰가 있습니다.</target>
        </trans-unit>
        <trans-unit id="469781ae7250c96809f2909f9894d73851fad976" translate="yes" xml:space="preserve">
          <source>We're going to create a simple API to allow admin users to view and edit the users and groups in the system.</source>
          <target state="translated">관리자가 시스템의 사용자와 그룹을보고 편집 할 수 있도록 간단한 API를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5d1515566a67176ad1d3cec5f82a6cda352a274" translate="yes" xml:space="preserve">
          <source>We're going to make a couple of changes to our &lt;code&gt;Snippet&lt;/code&gt; model class. First, let's add a couple of fields. One of those fields will be used to represent the user who created the code snippet. The other field will be used to store the highlighted HTML representation of the code.</source>
          <target state="translated">스 &lt;code&gt;Snippet&lt;/code&gt; 모델 클래스 를 몇 가지 변경하겠습니다 . 먼저 몇 개의 필드를 추가하겠습니다. 이러한 필드 중 하나는 코드 스 니펫을 만든 사용자를 나타내는 데 사용됩니다. 다른 필드는 강조 표시된 코드의 HTML 표현을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a89337465ed7d034d45b47295d9f3a5a704fd27c" translate="yes" xml:space="preserve">
          <source>We're now ready to test the API we've built. Let's fire up the server from the command line.</source>
          <target state="translated">이제 빌드 한 API를 테스트 할 준비가되었습니다. 명령 행에서 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6dabf63be107948e9c6dd5d2b91091aeea62bc2f" translate="yes" xml:space="preserve">
          <source>We're ready to create our API now. Here's our project's root &lt;code&gt;urls.py&lt;/code&gt; module:</source>
          <target state="translated">이제 API를 만들 준비가되었습니다. 프로젝트의 루트 &lt;code&gt;urls.py&lt;/code&gt; 모듈은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="83e70a97bac3030cde29593e0173b9b5ee178c22" translate="yes" xml:space="preserve">
          <source>We've now got a fairly fine-grained set of permissions on our Web API, and end points for users of the system and for the code snippets that they have created.</source>
          <target state="translated">이제 우리는 웹 API와 시스템 사용자 및 그들이 작성한 코드 스 니펫에 대한 상당히 세밀한 권한 세트를 가졌습니다.</target>
        </trans-unit>
        <trans-unit id="66390a9261885771ccdd6da7c27fef2c1a152d15" translate="yes" xml:space="preserve">
          <source>We've now got a few snippet instances to play with. Let's take a look at serializing one of those instances.</source>
          <target state="translated">이제 몇 가지 스 니펫 인스턴스를 사용할 수 있습니다. 이러한 인스턴스 중 하나를 직렬화하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3d4b36bc57457b9920995102b0eb6da42363fb68" translate="yes" xml:space="preserve">
          <source>What's next?</source>
          <target state="translated">무엇 향후 계획?</target>
        </trans-unit>
        <trans-unit id="6e80d478bdf4229771212962bde8d4e038cec623" translate="yes" xml:space="preserve">
          <source>When API versioning is enabled, the &lt;code&gt;request.version&lt;/code&gt; attribute will contain a string that corresponds to the version requested in the incoming client request.</source>
          <target state="translated">API 버전 관리가 사용 가능한 경우 &lt;code&gt;request.version&lt;/code&gt; 속성에는 수신 클라이언트 요청에서 요청 된 버전에 해당하는 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="05c451ce293a605c8145c7f48bea42d1a0bbea43" translate="yes" xml:space="preserve">
          <source>When a serializer is instantiated and &lt;code&gt;many=True&lt;/code&gt; is passed, a &lt;code&gt;ListSerializer&lt;/code&gt; instance will be created. The serializer class then becomes a child of the parent &lt;code&gt;ListSerializer&lt;/code&gt;</source>
          <target state="translated">직렬 변환기가 인스턴스화되고 &lt;code&gt;many=True&lt;/code&gt; 가 전달되면 &lt;code&gt;ListSerializer&lt;/code&gt; 인스턴스가 작성됩니다. 그런 다음 serializer 클래스는 부모 &lt;code&gt;ListSerializer&lt;/code&gt; 의 자식이됩니다.</target>
        </trans-unit>
        <trans-unit id="68ab38cd0727a5ee3de2e0b2abd2d453e15efacd" translate="yes" xml:space="preserve">
          <source>When a serializer with &lt;code&gt;many=True&lt;/code&gt; is instantiated, we need to determine which arguments and keyword arguments should be passed to the &lt;code&gt;.__init__()&lt;/code&gt; method for both the child &lt;code&gt;Serializer&lt;/code&gt; class, and for the parent &lt;code&gt;ListSerializer&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;many=True&lt;/code&gt; 인 serializer 가 인스턴스화되면 자식 &lt;code&gt;Serializer&lt;/code&gt; 클래스와 부모 &lt;code&gt;ListSerializer&lt;/code&gt; 클래스 모두에 대해 &lt;code&gt;.__init__()&lt;/code&gt; 메서드에 전달할 인수 및 키워드 인수를 결정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="85d7ed4e553eb8712bbeb28556f988ba264d60cb" translate="yes" xml:space="preserve">
          <source>When a value of &lt;code&gt;None&lt;/code&gt; is used for the format &lt;code&gt;datetime&lt;/code&gt; objects will be returned by &lt;code&gt;to_representation&lt;/code&gt; and the final output representation will determined by the renderer class.</source>
          <target state="translated">형식 &lt;code&gt;datetime&lt;/code&gt; 에 &lt;code&gt;None&lt;/code&gt; 값 이 사용 되면 &lt;code&gt;to_representation&lt;/code&gt; 에 의해 객체가 반환되고 최종 출력 표현은 렌더러 클래스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="17eee09f8d8449ac6f02da1d00e9b32f90795984" translate="yes" xml:space="preserve">
          <source>When an unauthenticated request is denied permission there are two different error codes that may be appropriate.</source>
          <target state="translated">인증되지 않은 요청이 권한을 거부하면 두 가지 다른 오류 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="60cf3a15eefe257d12cfb999bea856d1d669294f" translate="yes" xml:space="preserve">
          <source>When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using &lt;code&gt;instance=...&lt;/code&gt; when instantiating the serializer.</source>
          <target state="translated">기존 인스턴스에 업데이트를 적용 할 때 고유성 유효성 검사기는 고유성 검사에서 현재 인스턴스를 제외합니다. 현재 인스턴스는 고유성 검사의 컨텍스트에서 사용할 수 있습니다 . 이는 직렬화기를 인스턴스화 할 때 &lt;code&gt;instance=...&lt;/code&gt; 사용하여 처음 전달 된 직렬화 기의 속성으로 존재하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="58f03d2165faaf45a743c9d045e9b2d658629366" translate="yes" xml:space="preserve">
          <source>When checking the validity of test responses it's often more convenient to inspect the data that the response was created with, rather than inspecting the fully rendered response.</source>
          <target state="translated">테스트 응답의 유효성을 검사 할 때는 완전히 렌더링 된 응답을 검사하지 않고 응답이 작성된 데이터를 검사하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="b50505d35954c3f3ccd2029b95f55bb3a2a5d5a1" translate="yes" xml:space="preserve">
          <source>When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.</source>
          <target state="translated">데이터 역 직렬화를 지원하는 중첩 표현을 처리 할 때 중첩 객체의 오류는 중첩 객체의 필드 이름 아래에 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="c9de2097e39b72a67bc479f54e87825f2e39ea5d" translate="yes" xml:space="preserve">
          <source>When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.</source>
          <target state="translated">항목 목록을 역 직렬화하면 각 역 직렬화 된 항목을 나타내는 사전 목록으로 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ffaddf30c1b8df659f7584f7a87ea3bf69f26c14" translate="yes" xml:space="preserve">
          <source>When deserializing data, you always need to call &lt;code&gt;is_valid()&lt;/code&gt; before attempting to access the validated data, or save an object instance. If any validation errors occur, the &lt;code&gt;.errors&lt;/code&gt; property will contain a dictionary representing the resulting error messages. For example:</source>
          <target state="translated">데이터를 직렬화 해제하는 경우, 유효성이 검증 된 데이터에 액세스하거나 객체 인스턴스를 저장하기 전에 항상 &lt;code&gt;is_valid()&lt;/code&gt; 를 호출해야 합니다. 유효성 검사 오류가 발생하면 &lt;code&gt;.errors&lt;/code&gt; 속성에 결과 오류 메시지를 나타내는 사전이 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f3420847f456546e88bc629901ef9aee90928bc" translate="yes" xml:space="preserve">
          <source>When in use, the browsable API will include a &lt;code&gt;SearchFilter&lt;/code&gt; control:</source>
          <target state="translated">사용 가능한 브라우징 가능한 API에는 &lt;code&gt;SearchFilter&lt;/code&gt; 컨트롤 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="19c4cc3c9f0f2237b287923838fab5a087a8cbae" translate="yes" xml:space="preserve">
          <source>When instantiating a &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; you must include the current &lt;code&gt;request&lt;/code&gt; in the serializer context, for example:</source>
          <target state="translated">&lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 를 인스턴스화 할 때 직렬 변환기 컨텍스트에 현재 &lt;code&gt;request&lt;/code&gt; 을 포함시켜야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94595409cbe5be0c4918173480e5111d70524843" translate="yes" xml:space="preserve">
          <source>When passing an initial object or queryset to a serializer instance, the object will be made available as &lt;code&gt;.instance&lt;/code&gt;. If no initial object is passed then the &lt;code&gt;.instance&lt;/code&gt; attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">초기 객체 또는 &lt;code&gt;.instance&lt;/code&gt; serializer 인스턴스에 전달하면 해당 객체를 .instance 로 사용할 수있게됩니다 . 초기 객체가 전달되지 않으면 &lt;code&gt;.instance&lt;/code&gt; 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="037e6c06adf1832534d719fbf49e70ce777fb67e" translate="yes" xml:space="preserve">
          <source>When passing data to a serializer instance, the unmodified data will be made available as &lt;code&gt;.initial_data&lt;/code&gt;. If the data keyword argument is not passed then the &lt;code&gt;.initial_data&lt;/code&gt; attribute will not exist.</source>
          <target state="translated">시리얼 라이저 인스턴스에 데이터를 전달할 때 수정되지 않은 데이터는 &lt;code&gt;.initial_data&lt;/code&gt; 로 제공됩니다 . data 키워드 인수가 전달되지 않으면 &lt;code&gt;.initial_data&lt;/code&gt; 속성이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adc231c651ee2fe38e3f76ffc8e9e4e6825f721a" translate="yes" xml:space="preserve">
          <source>When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with &quot;More than 1000 items&amp;hellip;&quot; will be displayed.</source>
          <target state="translated">찾아보기 가능한 API 관계형 필드에 렌더링 될 때 기본적으로 최대 1000 개의 선택 가능한 항목 만 표시됩니다. 더 많은 항목이 있으면 &quot;1000 개 이상의 항목&amp;hellip;&quot;과 함께 비활성화 된 옵션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9ba9f3b944c350252fe1a164d5df95a87a3ac9" translate="yes" xml:space="preserve">
          <source>When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.</source>
          <target state="translated">원시 10 진수 유형을 지원하지 않는 API 표현에서 10 진수 오브젝트를 리턴 할 때는 일반적으로 값을 문자열로 리턴하는 것이 가장 좋습니다. 이진 부동 소수점 구현에서 발생하는 정밀도 손실을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="3c56d1a05d47d414558a62eb20baea1c06da0c29" translate="yes" xml:space="preserve">
          <source>When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for &lt;code&gt;ModelSerializer&lt;/code&gt; is to use the primary keys of the related instances.</source>
          <target state="translated">모델 인스턴스를 직렬화 할 때 관계를 나타내는 여러 가지 방법이 있습니다. &lt;code&gt;ModelSerializer&lt;/code&gt; 의 기본 표현 은 관련 인스턴스의 기본 키를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cba43e2ca7b8be71134f15ad6b719a4410db8da5" translate="yes" xml:space="preserve">
          <source>When serializing the instance, default will be used if the the object attribute or dictionary key is not present in the instance.</source>
          <target state="translated">인스턴스를 직렬화 할 때 객체 속성 또는 사전 키가 인스턴스에없는 경우 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41f1f58e91bc6a1caf2f4370c3a2324bb9fc61b6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;False&lt;/code&gt;, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 로 설정하면 JSON 렌더링 및 구문 분석이 허용됩니다. 그러나 이러한 값은 여전히 ​​유효하지 않으므로 코드에서 특별히 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c20fa3588d42af93a64fb4d281c08b4746d624e" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;False&lt;/code&gt;, JSON responses will escape non-ascii characters, like so:</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 로 설정하면 JSON 응답은 다음과 같이 ASCII가 아닌 문자를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="3a6a476a4c576279d348eb732d2375290847e1dd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;False&lt;/code&gt;, JSON responses will return slightly more verbose representations, like so:</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 로 설정하면 JSON 응답이 다음과 같이 약간 더 자세한 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56c61faa25d7220976408a197a8efb19031fe6d7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (&lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, &lt;code&gt;-inf&lt;/code&gt;) accepted by Python's &lt;code&gt;json&lt;/code&gt; module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's &lt;code&gt;JSON.Parse&lt;/code&gt; nor PostgreSQL's JSON data type accept these values.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정하면 JSON 렌더링 및 구문 분석은 구문 상 유효한 JSON 만 관찰 &lt;code&gt;-inf&lt;/code&gt; Python의 &lt;code&gt;json&lt;/code&gt; 모듈 에서 허용 하는 확장 부동 소수점 값 ( &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; , -inf )에 대한 예외가 발생 합니다. 이 값은 일반적으로 지원되지 않으므로 권장되는 설정입니다. 예를 들어, Javascript의 &lt;code&gt;JSON.Parse&lt;/code&gt; 와 PostgreSQL의 JSON 데이터 유형은 이러한 값을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55fc0717ec9bb4c5476675853db1ebee8ac54135" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, JSON responses will allow unicode characters in responses. For example:</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정하면 JSON 응답이 응답에서 유니 코드 문자를 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6d698853940a14a4781d2413786a3ae0553c2fa" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, JSON responses will return compact representations, with no spacing after &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;','&lt;/code&gt; characters. For example:</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정하면 JSON 응답은 &lt;code&gt;':'&lt;/code&gt; 및 &lt;code&gt;','&lt;/code&gt; 문자 뒤에 공백이없는 간단한 표현을 반환 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d16a46d7c4257eb3209e5811e5bc7303b544dd7f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, the serializer &lt;code&gt;DecimalField&lt;/code&gt; class will return strings instead of &lt;code&gt;Decimal&lt;/code&gt; objects. When set to &lt;code&gt;False&lt;/code&gt;, serializers will return &lt;code&gt;Decimal&lt;/code&gt; objects, which the default JSON encoder will return as floats.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정 하면 직렬 변환기 &lt;code&gt;DecimalField&lt;/code&gt; 클래스가 &lt;code&gt;Decimal&lt;/code&gt; 객체 대신 문자열을 반환 합니다. &lt;code&gt;False&lt;/code&gt; 로 설정하면 serializer는 &lt;code&gt;Decimal&lt;/code&gt; 객체 를 반환 하며 기본 JSON 인코더는 float로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e77aae63a190d7ec517de8db71202c04aef85c56" translate="yes" xml:space="preserve">
          <source>When testing views directly using a request factory, it's often convenient to be able to directly authenticate the request, rather than having to construct the correct authentication credentials.</source>
          <target state="translated">요청 팩토리를 사용하여 직접보기를 테스트 할 때 올바른 인증 신임 정보를 구성하지 않고 요청을 직접 인증하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="17adec848da24632c649f7efa05ed00e4dd96520" translate="yes" xml:space="preserve">
          <source>When that's all done we'll need to update our database tables. Normally we'd create a database migration in order to do that, but for the purposes of this tutorial, let's just delete the database and start again.</source>
          <target state="translated">완료되면 데이터베이스 테이블을 업데이트해야합니다. 일반적으로이를 수행하기 위해 데이터베이스 마이그레이션을 작성하지만이 학습서의 목적을 위해 데이터베이스를 삭제하고 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7655ff453a8e9747c24b730d7a3a14ae76a220ca" translate="yes" xml:space="preserve">
          <source>When the permissions checks fail either a &quot;403 Forbidden&quot; or a &quot;401 Unauthorized&quot; response will be returned, according to the following rules:</source>
          <target state="translated">권한 검사가 실패하면 다음 규칙에 따라 &quot;403 Forbidden&quot;또는 &quot;401 Unauthorized&quot;응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74b2467e1f435e5f15caa90c53fca67a120154a8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;ModelSerializer&lt;/code&gt; or &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;, note that any model fields with &lt;code&gt;auto_now=True&lt;/code&gt; or &lt;code&gt;auto_now_add=True&lt;/code&gt; will use serializer fields that are &lt;code&gt;read_only=True&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 또는 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;auto_now=True&lt;/code&gt; 또는 &lt;code&gt;auto_now_add=True&lt;/code&gt; 인 모델 필드는 기본적으로 &lt;code&gt;read_only=True&lt;/code&gt; 인 직렬 변환기 필드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f61d5910e4526958c174ff8178554da618a280bf" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;SlugRelatedField&lt;/code&gt; as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with &lt;code&gt;unique=True&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;SlugRelatedField&lt;/code&gt; 를 읽기 - 쓰기 필드로, 당신은 일반적으로 그와 모델 필드에 슬러그 필드에 대응 있도록 할 것입니다 &lt;code&gt;unique=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72c29a27ad9114e85b6708f69da722424dcb4b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;TokenAuthentication&lt;/code&gt;, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behavior. To use it, add the &lt;code&gt;obtain_auth_token&lt;/code&gt; view to your URLconf:</source>
          <target state="translated">&lt;code&gt;TokenAuthentication&lt;/code&gt; 을 사용할 때 클라이언트가 사용자 이름과 비밀번호로 토큰을 얻을 수있는 메커니즘을 제공 할 수 있습니다. REST 프레임 워크는이 동작을 제공하기 위해 기본 제공보기를 제공합니다. 이를 사용하려면 &lt;code&gt;obtain_auth_token&lt;/code&gt; 보기를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="58596f104ef7fd1b13bdb48bca0d5873c995c794" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;format_suffix_patterns&lt;/code&gt;, you must make sure to add the &lt;code&gt;'format'&lt;/code&gt; keyword argument to the corresponding views. For example:</source>
          <target state="translated">&lt;code&gt;format_suffix_patterns&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;'format'&lt;/code&gt; 키워드 인수를 해당보기 에 추가해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3585a0395a9b378b202d60aadac12b7bd227ed5" translate="yes" xml:space="preserve">
          <source>When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to &lt;code&gt;False&lt;/code&gt;, even if it has a &lt;code&gt;default=True&lt;/code&gt; option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.</source>
          <target state="translated">HTML로 인코딩 된 양식 입력을 사용하는 경우 &lt;code&gt;default=True&lt;/code&gt; 옵션이 지정된 경우에도 값을 생략하면 항상 필드를 &lt;code&gt;False&lt;/code&gt; 로 설정하는 것으로 간주됩니다 . 이는 HTML 체크 박스 입력이 값을 생략하여 검사되지 않은 상태를 나타내므로 REST 프레임 워크는 생략이 빈 ​​체크 박스 입력 인 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f374d04ba9fe91e8cd7e70d37c4e2d3dffb0ebd1" translate="yes" xml:space="preserve">
          <source>When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.</source>
          <target state="translated">URL 기반 버전 관리 체계와 함께 하이퍼 링크 된 직렬화 스타일을 사용하는 경우 요청을 직렬화기에 대한 컨텍스트로 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b99c1056b92748a4ea92cc0a84a5ef8e62f6583" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ModelSerializer&lt;/code&gt; class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 사용하면 직렬 변환기 필드 및 관계가 자동으로 생성됩니다. 이러한 자동 생성 필드를 검사하면 관계 스타일을 사용자 정의하는 방법을 결정하는 데 유용한 도구가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63137b1d5fccf19506dffed18e109b148f03c3e5" translate="yes" xml:space="preserve">
          <source>When we interact with the API through the web browser, we can login, and the browser session will then provide the required authentication for the requests.</source>
          <target state="translated">웹 브라우저를 통해 API와 상호 작용할 때 로그인 할 수 있으며 브라우저 세션은 요청에 필요한 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0d357be36cdcdf17deb06846a45d772fafdde03" translate="yes" xml:space="preserve">
          <source>When you're using &lt;code&gt;ModelSerializer&lt;/code&gt; all of this is handled automatically for you. If you want to drop down to using &lt;code&gt;Serializer&lt;/code&gt; classes instead, then you need to define the validation rules explicitly.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 를 사용하면이 모든 것이 자동으로 처리됩니다. &lt;code&gt;Serializer&lt;/code&gt; 클래스를 대신 사용하려면 드롭 다운 검증 규칙을 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0263258329cf298da8b788d9012936be2962c472" translate="yes" xml:space="preserve">
          <source>Where are we now</source>
          <target state="translated">우리는 지금 어디에</target>
        </trans-unit>
        <trans-unit id="80b5c99f5385423f307a1a4f4159cd7fe911ebe3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ModelForm&lt;/code&gt; the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:</source>
          <target state="translated">함께 &lt;code&gt;ModelForm&lt;/code&gt; 검증 모델 인스턴스 부분적 형태에 부분적으로 수행된다. REST 프레임 워크를 사용하면 유효성 검증이 전적으로 serializer 클래스에서 수행됩니다. 이는 다음과 같은 이유로 유리합니다.</target>
        </trans-unit>
        <trans-unit id="f1a02d7132d701665aa04d1ef32622826aaa1cf6" translate="yes" xml:space="preserve">
          <source>With Django admin</source>
          <target state="translated">Django 관리자와 함께</target>
        </trans-unit>
        <trans-unit id="167b87fd7c8da3d4ee8c262d2326b3447a94f2a6" translate="yes" xml:space="preserve">
          <source>With careful usage both the &lt;code&gt;RequestsClient&lt;/code&gt; and the &lt;code&gt;CoreAPIClient&lt;/code&gt; provide the ability to write test cases that can run either in development, or be run directly against your staging server or production environment.</source>
          <target state="translated">주의해서 사용하면 &lt;code&gt;RequestsClient&lt;/code&gt; 와 &lt;code&gt;CoreAPIClient&lt;/code&gt; 가 개발시 실행되거나 스테이징 서버 또는 프로덕션 환경에서 직접 실행될 수있는 테스트 케이스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbfab6f1a4a68c74e05c06b0f4d6a35cc1ecf9fc" translate="yes" xml:space="preserve">
          <source>With this scheme the &lt;code&gt;request.version&lt;/code&gt; attribute is determined based on the &lt;code&gt;namespace&lt;/code&gt; that matches the incoming request path.</source>
          <target state="translated">이 체계를 사용하면 &lt;code&gt;request.version&lt;/code&gt; 속성이 들어오는 요청 경로와 일치하는 &lt;code&gt;namespace&lt;/code&gt; 를 기반으로 결정 됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b129aa0916bc382051b2e48b3290a1fe31a02a" translate="yes" xml:space="preserve">
          <source>Working with Serializers</source>
          <target state="translated">시리얼 라이저 작업</target>
        </trans-unit>
        <trans-unit id="059e72f33f2589702d1802dde6b0ce93c6c5365c" translate="yes" xml:space="preserve">
          <source>Would serialize to a nested representation like this:</source>
          <target state="translated">다음과 같이 중첩 표현으로 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="b3d71a72eadac8a4585febaba1d69ba05abbb0b6" translate="yes" xml:space="preserve">
          <source>Would serialize to a representation like this:</source>
          <target state="translated">다음과 같은 표현으로 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="d586dbe320048e5ccdfeddce1c43500fc43d5845" translate="yes" xml:space="preserve">
          <source>Would serialize to the following representation.</source>
          <target state="translated">다음 표현으로 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="689fc2a9339dcfcc36f2d56a8add64691ff13b2e" translate="yes" xml:space="preserve">
          <source>Wow, that's pretty concise. We've gotten a huge amount for free, and our code looks like good, clean, idiomatic Django.</source>
          <target state="translated">와우, 그것은 간결합니다. 우리는 무료로 엄청난 양을 얻었고 코드는 깨끗하고 관용적 인 장고처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="13f2a38b590e89ac9af28ae16b359f38e74ed399" translate="yes" xml:space="preserve">
          <source>Wrapping API views</source>
          <target state="translated">랩핑 API 뷰</target>
        </trans-unit>
        <trans-unit id="c9e4bdc11d4549be84df1ae6228b7f501a369698" translate="yes" xml:space="preserve">
          <source>Writable nested representations</source>
          <target state="translated">쓰기 가능한 중첩 표현</target>
        </trans-unit>
        <trans-unit id="2e9bbef5a036b135ae8a15e1faf7ea4ae8626161" translate="yes" xml:space="preserve">
          <source>Writable nested serializers</source>
          <target state="translated">쓰기 가능한 중첩 시리얼 라이저</target>
        </trans-unit>
        <trans-unit id="17d8306e16569aca3e74dbb650220cb1e55f95e7" translate="yes" xml:space="preserve">
          <source>Writing .create() methods for nested representations</source>
          <target state="translated">중첩 표현을위한 .create () 메소드 작성</target>
        </trans-unit>
        <trans-unit id="7308b5dffa2929a4036c76809477c9397bb03088" translate="yes" xml:space="preserve">
          <source>Writing .update() methods for nested representations</source>
          <target state="translated">중첩 표현을위한 .update () 메소드 작성</target>
        </trans-unit>
        <trans-unit id="a171f8190760e2d63371a9373dc5a78b4d67cf01" translate="yes" xml:space="preserve">
          <source>Writing custom validators</source>
          <target state="translated">사용자 정의 유효성 검사기 작성</target>
        </trans-unit>
        <trans-unit id="4547b1a22460ad6f4311b7794666c02a5fb3a3fd" translate="yes" xml:space="preserve">
          <source>Writing regular Django views using our Serializer</source>
          <target state="translated">Serializer를 사용하여 일반 장고 뷰 작성</target>
        </trans-unit>
        <trans-unit id="c4ba50f60e5da7bcf412574885357e8f1faa8dda" translate="yes" xml:space="preserve">
          <source>XLSX (Binary Spreadsheet Endpoints)</source>
          <target state="translated">XLSX (이진 스프레드 시트 엔드 포인트)</target>
        </trans-unit>
        <trans-unit id="b06cc622c0ce75e90095ea31fb119d88511f9d95" translate="yes" xml:space="preserve">
          <source>XLSX is the world's most popular binary spreadsheet format. &lt;a href=&quot;https://github.com/flipperpa&quot;&gt;Tim Allen&lt;/a&gt; of &lt;a href=&quot;https://github.com/wharton&quot;&gt;The Wharton School&lt;/a&gt; maintains &lt;a href=&quot;https://github.com/wharton/drf-renderer-xlsx&quot;&gt;drf-renderer-xlsx&lt;/a&gt;, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.</source>
          <target state="translated">XLSX는 세계에서 가장 인기있는 이진 스프레드 시트 형식입니다. &lt;a href=&quot;https://github.com/wharton&quot;&gt;The Wharton School&lt;/a&gt; 의 &lt;a href=&quot;https://github.com/flipperpa&quot;&gt;Tim Allen&lt;/a&gt; 은 &lt;a href=&quot;https://github.com/wharton/drf-renderer-xlsx&quot;&gt;drf-renderer-xlsx를&lt;/a&gt; 유지 관리 하여 OpenPyXL을 사용하여 엔드 포인트를 XLSX 스프레드 시트로 렌더링하고 클라이언트가 다운로드 할 수 있도록합니다. 스프레드 시트는보기별로 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="d98e74272edd7dfaacca7a77e3ede170add8bdd3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;may&lt;/em&gt; also override the &lt;code&gt;.authenticate_header(self, request)&lt;/code&gt; method. If implemented, it should return a string that will be used as the value of the &lt;code&gt;WWW-Authenticate&lt;/code&gt; header in a &lt;code&gt;HTTP 401 Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">당신은 &lt;em&gt;할 수있다&lt;/em&gt; 또한 무시 &lt;code&gt;.authenticate_header(self, request)&lt;/code&gt; 방법을. 구현 된 경우 &lt;code&gt;HTTP 401 Unauthorized&lt;/code&gt; 응답 에서 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더 의 값으로 사용될 문자열을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf853d2eca2dd48dfdac03811683fc94493c6c5b" translate="yes" xml:space="preserve">
          <source>You are expecting to interface with the API primarily from another Python service, and want to test the service at the same level as the client will see.</source>
          <target state="translated">주로 다른 Python 서비스에서 API와 인터페이스하고 클라이언트와 동일한 수준에서 서비스를 테스트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6600d5aa9be001ac1c3082d0ae5ae122ce835cea" translate="yes" xml:space="preserve">
          <source>You can achieve this by overriding &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt;. There are two methods that may be overridden:</source>
          <target state="translated">&lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; 를 재정 의하여이를 달성 할 수 있습니다 . 재정의 될 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="756e8160cf7387b1dc69229c79f54fffc4312fa8" translate="yes" xml:space="preserve">
          <source>You can add extra fields to a &lt;code&gt;ModelSerializer&lt;/code&gt; or override the default fields by declaring fields on the class, just as you would for a &lt;code&gt;Serializer&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;Serializer&lt;/code&gt; 클래스 와 마찬가지로 클래스에서 필드를 선언 하여 &lt;code&gt;ModelSerializer&lt;/code&gt; 에 추가 필드를 추가 하거나 기본 필드를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86cd366b3eaec4e7c35bcc3963807b8dc5361c79" translate="yes" xml:space="preserve">
          <source>You can also control these globally using the settings &lt;code&gt;HTML_SELECT_CUTOFF&lt;/code&gt; and &lt;code&gt;HTML_SELECT_CUTOFF_TEXT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HTML_SELECT_CUTOFF&lt;/code&gt; 및 &lt;code&gt;HTML_SELECT_CUTOFF_TEXT&lt;/code&gt; 설정을 사용하여 전역 적으로이를 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec09b2aec76a7b124091910b2aa43c2143399a3d" translate="yes" xml:space="preserve">
          <source>You can also customize how the &lt;code&gt;@action&lt;/code&gt; decorator is routed. Include the &lt;code&gt;DynamicRoute&lt;/code&gt; named tuple in the &lt;code&gt;.routes&lt;/code&gt; list, setting the &lt;code&gt;detail&lt;/code&gt; argument as appropriate for the list-based and detail-based routes. In addition to &lt;code&gt;detail&lt;/code&gt;, the arguments to &lt;code&gt;DynamicRoute&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;@action&lt;/code&gt; 데코레이터가 라우팅되는 방법을 사용자 정의 할 수도 있습니다 . &lt;code&gt;.routes&lt;/code&gt; 목록 에 &lt;code&gt;DynamicRoute&lt;/code&gt; 라는 이름의 튜플을 포함시켜 list 기반 및 detail 기반 경로에 대해 &lt;code&gt;detail&lt;/code&gt; 인수를 설정하십시오 . &lt;code&gt;detail&lt;/code&gt; 이외에도 &lt;code&gt;DynamicRoute&lt;/code&gt; 에 대한 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e347b68397e70b15875b13209a82d200a1e14b1d" translate="yes" xml:space="preserve">
          <source>You can also make the filter controls available to the schema autogeneration that REST framework provides, by implementing a &lt;code&gt;get_schema_fields()&lt;/code&gt; method. This method should have the following signature:</source>
          <target state="translated">&lt;code&gt;get_schema_fields()&lt;/code&gt; 메소드를 구현하여 REST 프레임 워크가 제공하는 스키마 자동 생성에 필터 제어를 사용 가능하게 할 수도 있습니다 . 이 방법에는 다음과 같은 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="04db1db684fab96927d4ecb3ccf90734c82f0c42" translate="yes" xml:space="preserve">
          <source>You can also make the pagination controls available to the schema autogeneration that REST framework provides, by implementing a &lt;code&gt;get_schema_fields()&lt;/code&gt; method. This method should have the following signature:</source>
          <target state="translated">&lt;code&gt;get_schema_fields()&lt;/code&gt; 메소드를 구현하여 페이지 매김 제어를 REST 프레임 워크가 제공하는 스키마 자동 생성에 사용 가능하게 만들 수도 있습니다 . 이 방법에는 다음과 같은 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1cc7c410136b064a429f39c304e8d62704caa614" translate="yes" xml:space="preserve">
          <source>You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:</source>
          <target state="translated">조회 API 이중 밑줄 표기법을 사용하여 ForeignKey 또는 ManyToManyField에서 관련 조회를 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="633c513f8400995e56a9592f0d37f7b070c43152" translate="yes" xml:space="preserve">
          <source>You can also provide your own generic filtering backend, or write an installable app for other developers to use.</source>
          <target state="translated">고유 한 필터링 백엔드를 제공하거나 다른 개발자가 사용할 수있는 설치 가능한 앱을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dc74c5094d0f1198d40191f36104382d315e5a9" translate="yes" xml:space="preserve">
          <source>You can also set the &lt;code&gt;fields&lt;/code&gt; attribute to the special value &lt;code&gt;'__all__'&lt;/code&gt; to indicate that all fields in the model should be used.</source>
          <target state="translated">또한 설정할 수 있습니다 &lt;code&gt;fields&lt;/code&gt; 특수 값에 속성 &lt;code&gt;'__all__'&lt;/code&gt; 모델의 모든 필드를 사용하는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3709ecef426861a8ed0956b93a01af7286e1b1a8" translate="yes" xml:space="preserve">
          <source>You can also set the authentication policy on a per-view, or per-viewset basis, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반보기를 사용하여보기 별 또는보기별로 인증 정책을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="631887056122010427f09bd3d290589fdfdc7b54" translate="yes" xml:space="preserve">
          <source>You can also set the authentication scheme on a per-view or per-viewset basis, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반보기를 사용하여보기별로 또는보기별로 인증 체계를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea6a45a658e9acac0bbb0e0594488493b83c6c2" translate="yes" xml:space="preserve">
          <source>You can also set the content negotiation used for an individual view, or viewset, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반보기를 사용하여 개별보기 또는보기 세트에 사용되는 컨텐츠 협상을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e18bd6c30f0134b3ab7feccde7f207b5a0f167a" translate="yes" xml:space="preserve">
          <source>You can also set the filter backends on a per-view, or per-viewset basis, using the &lt;code&gt;GenericAPIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;GenericAPIView&lt;/code&gt; 클래스 기반보기를 사용하여보기 별 또는보기별로 필터 백엔드를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad888edc0e09c933c5b3bd34fde936f6fac47aa" translate="yes" xml:space="preserve">
          <source>You can also set the pagination class on an individual view by using the &lt;code&gt;pagination_class&lt;/code&gt; attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.</source>
          <target state="translated">&lt;code&gt;pagination_class&lt;/code&gt; 속성 을 사용하여 개별보기에서 페이지 매김 클래스를 설정할 수도 있습니다 . 보기마다 기본 또는 최대 페이지 크기와 같은 페이지 매김의 개별 측면을 다양하게 할 수 있지만 일반적으로 API 전체에서 동일한 페이지 매김 스타일을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="47acdee01ffb5bd46c63b02fb8e77b8ca38ab252" translate="yes" xml:space="preserve">
          <source>You can also set the parsers used for an individual view, or viewset, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반 뷰를 사용하여 개별 뷰 또는 뷰셋에 사용되는 파서를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f8daf218002e4660ee8d838ec47ef4c084a907" translate="yes" xml:space="preserve">
          <source>You can also set the renderers used for an individual view, or viewset, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반 뷰를 사용하여 개별 뷰 또는 뷰셋에 사용되는 렌더러를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72110bec7d360e1519acbe0dd887d4ebde00118a" translate="yes" xml:space="preserve">
          <source>You can also set the throttling policy on a per-view or per-viewset basis, using the &lt;code&gt;APIView&lt;/code&gt; class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 클래스 기반 뷰를 사용하여 뷰별 또는 뷰셋별로 스로틀 정책을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8eb5ac21679e97588e64a4c5bc54507eb7c19c" translate="yes" xml:space="preserve">
          <source>You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the &lt;code&gt;versioning_class&lt;/code&gt; attribute.</source>
          <target state="translated">개별 뷰에서 버전 관리 체계를 설정할 수도 있습니다. 일반적으로 단일 버전 관리 체계를 전체적으로 사용하는 것이 더 합리적이므로이 작업을 수행 할 필요가 없습니다. 그렇게해야 할 경우 &lt;code&gt;versioning_class&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c65ba6c734202cae7f4ba2f74b1736c9f3639cf3" translate="yes" xml:space="preserve">
          <source>You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the &lt;code&gt;default_version&lt;/code&gt;, &lt;code&gt;allowed_versions&lt;/code&gt; and &lt;code&gt;version_param&lt;/code&gt; class variables. For example, if you want to use &lt;code&gt;URLPathVersioning&lt;/code&gt;:</source>
          <target state="translated">고유 한 버전 관리 체계를 정의하고 &lt;code&gt;default_version&lt;/code&gt; , &lt;code&gt;allowed_versions&lt;/code&gt; 및 &lt;code&gt;version_param&lt;/code&gt; 클래스 변수를 사용하여 버전 별 클래스와 뷰당 또는 뷰셋별로 세 개의 값을 설정할 수도 있습니다 . 예를 들어 &lt;code&gt;URLPathVersioning&lt;/code&gt; 을 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="191289f8e1652185383c4274f9da092d4b5e79c5" translate="yes" xml:space="preserve">
          <source>You can also use the declarative style, as with &lt;code&gt;ListField&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;ListField&lt;/code&gt; 와 마찬가지로 선언 스타일을 사용할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f716e0a2fb2b29de676be70581c7ab2e6e60a57b" translate="yes" xml:space="preserve">
          <source>You can also use these hooks to provide additional validation, by raising a &lt;code&gt;ValidationError()&lt;/code&gt;. This can be useful if you need some validation logic to apply at the point of database save. For example:</source>
          <target state="translated">&lt;code&gt;ValidationError()&lt;/code&gt; 발생시켜 이러한 후크를 사용하여 추가 유효성 검사를 제공 할 수도 있습니다 . 데이터베이스 저장 시점에 적용 할 유효성 검증 논리가 필요한 경우 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f55cc598b11b5f80aaaf881d1400d961f703dec" translate="yes" xml:space="preserve">
          <source>You can also write your own adapter to work with your specific frontend. If you wish to do so, it also provides an exporter that can export those schema information to json files.</source>
          <target state="translated">특정 프론트 엔드에서 작동하도록 고유 한 어댑터를 작성할 수도 있습니다. 원하는 경우 스키마 정보를 json 파일로 내보낼 수있는 내보내기 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="060ce0cb756171397cc08b95e61a61247e14a5f9" translate="yes" xml:space="preserve">
          <source>You can do so by filtering based on the value of &lt;code&gt;request.user&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;request.user&lt;/code&gt; 값을 기준으로 필터링하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="623163c8395844418b4bbe789c46de457d50d253" translate="yes" xml:space="preserve">
          <source>You can do so by following the same flow that a JavaScript based client would use. First make a &lt;code&gt;GET&lt;/code&gt; request in order to obtain a CRSF token, then present that token in the following request.</source>
          <target state="translated">JavaScript 기반 클라이언트가 사용하는 것과 동일한 흐름을 수행하면됩니다. 먼저 CRSF 토큰을 얻기 위해 &lt;code&gt;GET&lt;/code&gt; 요청을 한 후 다음 요청에서 해당 토큰을 제시하십시오.</target>
        </trans-unit>
        <trans-unit id="589a4c27bf3af552a9af8e876deaf8ac8a3f3ef8" translate="yes" xml:space="preserve">
          <source>You can do so by including additional keyword arguments when calling &lt;code&gt;.save()&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;.save()&lt;/code&gt; 호출 할 때 추가 키워드 인수를 포함하면됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21b67f80b380b0a2d61e7c5951009bfe3c55eee0" translate="yes" xml:space="preserve">
          <source>You can do some pretty flexible things using REST framework's renderers. Some examples...</source>
          <target state="translated">REST 프레임 워크의 렌더러를 사용하여 매우 유연한 작업을 수행 할 수 있습니다. 몇 가지 예 ...</target>
        </trans-unit>
        <trans-unit id="423dd3a246f1cd96b71ce6b5ab888526688086cd" translate="yes" xml:space="preserve">
          <source>You can explicitly include the primary key by adding it to the &lt;code&gt;fields&lt;/code&gt; option, for example:</source>
          <target state="translated">기본 키를 &lt;code&gt;fields&lt;/code&gt; 옵션 에 추가하여 명시 적으로 포함시킬 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a9f28f8ad5a6704f81d2260ce9f83a4ba89a7cd" translate="yes" xml:space="preserve">
          <source>You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.</source>
          <target state="translated">API보기에서 발생한 예외를 응답 객체로 변환하는 핸들러 함수를 만들어 사용자 지정 예외 처리를 구현할 수 있습니다. 이를 통해 API에서 사용하는 오류 응답 스타일을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee0a58dacd4c28e96d7dd89fbf080897d170612c" translate="yes" xml:space="preserve">
          <source>You can install httpie using pip:</source>
          <target state="translated">pip를 사용하여 httpie를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a0b3b6c0c10e1b97ae338dd45741ce683fd705" translate="yes" xml:space="preserve">
          <source>You can modify the ordering by overriding the &lt;code&gt;'ordering'&lt;/code&gt; attribute on the pagination class, or by using the &lt;code&gt;OrderingFilter&lt;/code&gt; filter class together with &lt;code&gt;CursorPagination&lt;/code&gt;. When used with &lt;code&gt;OrderingFilter&lt;/code&gt; you should strongly consider restricting the fields that the user may order by.</source>
          <target state="translated">페이지 매김 클래스 에서 &lt;code&gt;'ordering'&lt;/code&gt; 속성을 재정의 하거나 &lt;code&gt;CursorPagination&lt;/code&gt; 과 함께 &lt;code&gt;OrderingFilter&lt;/code&gt; 필터 클래스를 사용하여 순서 를 수정할 수 있습니다. &lt;code&gt;OrderingFilter&lt;/code&gt; 와 함께 사용 하는 경우 사용자가 주문할 수있는 필드를 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6397b7a8d848df2f6de7d747a2399e7c95b272ec" translate="yes" xml:space="preserve">
          <source>You can now open the API in your browser at &lt;a href=&quot;http://127.0.0.1:8000/&quot;&gt;http://127.0.0.1:8000/&lt;/a&gt;, and view your new 'users' API. If you use the login control in the top right corner you'll also be able to add, create and delete users from the system.</source>
          <target state="translated">이제 브라우저 ( &lt;a href=&quot;http://127.0.0.1:8000/&quot;&gt;http://127.0.0.1:8000/&lt;/a&gt; ) 에서 API를 열고 새 '사용자'API를 볼 수 있습니다. 오른쪽 상단에있는 로그인 컨트롤을 사용하면 시스템에서 사용자를 추가, 생성 및 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb813992d086ec4c2712ce106ee9e29836a4dc6" translate="yes" xml:space="preserve">
          <source>You can override a URL field view name and lookup field by using either, or both of, the &lt;code&gt;view_name&lt;/code&gt; and &lt;code&gt;lookup_field&lt;/code&gt; options in the &lt;code&gt;extra_kwargs&lt;/code&gt; setting, like so:</source>
          <target state="translated">&lt;code&gt;extra_kwargs&lt;/code&gt; 설정 에서 &lt;code&gt;view_name&lt;/code&gt; 및 &lt;code&gt;lookup_field&lt;/code&gt; 옵션 중 하나 또는 둘 다를 사용하여 URL 필드보기 이름 및 조회 필드를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d783f2e9c18a51e96a6cefc05528e20a720a7ef4" translate="yes" xml:space="preserve">
          <source>You can override the templates that render the HTML pagination controls. The two built-in styles are:</source>
          <target state="translated">HTML 페이지 매김 컨트롤을 렌더링하는 템플릿을 재정의 할 수 있습니다. 내장 된 두 가지 스타일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf651361d52be87d38c81503f508a88b19f6d3be" translate="yes" xml:space="preserve">
          <source>You can provide arbitrary additional context by passing a &lt;code&gt;context&lt;/code&gt; argument when instantiating the serializer. For example:</source>
          <target state="translated">직렬화기를 인스턴스화 할 때 &lt;code&gt;context&lt;/code&gt; 인수 를 전달하여 임의의 추가 컨텍스트를 제공 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8fae7625ad5ee089c72fd69e3d187dbe79faa9d" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;exclude&lt;/code&gt; attribute to a list of fields to be excluded from the serializer.</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; 속성을 직렬 변환기에서 제외 할 필드 목록으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f0fd395d5615c9043b7254905be5e7cdb034df2" translate="yes" xml:space="preserve">
          <source>You can set the metadata class globally using the &lt;code&gt;'DEFAULT_METADATA_CLASS'&lt;/code&gt; settings key:</source>
          <target state="translated">&lt;code&gt;'DEFAULT_METADATA_CLASS'&lt;/code&gt; 설정 키를 사용하여 메타 데이터 클래스를 전체적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d1bfe0b1fd868e2966d093f60a249b72d89b508" translate="yes" xml:space="preserve">
          <source>You can specify custom field-level validation by adding &lt;code&gt;.validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; methods to your &lt;code&gt;Serializer&lt;/code&gt; subclass. These are similar to the &lt;code&gt;.clean_&amp;lt;field_name&amp;gt;&lt;/code&gt; methods on Django forms.</source>
          <target state="translated">&lt;code&gt;Serializer&lt;/code&gt; 서브 클래스에 &lt;code&gt;.validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; 메소드를 추가하여 사용자 정의 필드 레벨 유효성 검증을 지정할 수 있습니다 . Django 폼 의 &lt;code&gt;.clean_&amp;lt;field_name&amp;gt;&lt;/code&gt; 메소드 와 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="74a703969656c606591c95d4f338d38081cff8b9" translate="yes" xml:space="preserve">
          <source>You can specify custom field-level validation by adding &lt;code&gt;.validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; methods to your &lt;code&gt;Serializer&lt;/code&gt; subclass. This is documented in the &lt;a href=&quot;../serializers/index#field-level-validation&quot;&gt;Serializer docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Serializer&lt;/code&gt; 서브 클래스에 &lt;code&gt;.validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; 메소드를 추가하여 사용자 정의 필드 레벨 유효성 검증을 지정할 수 있습니다 . 이것은 &lt;a href=&quot;../serializers/index#field-level-validation&quot;&gt;Serializer 문서에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40b596540268a17885c7e3668d210c663c19821" translate="yes" xml:space="preserve">
          <source>You can then apply your new style to a view using the &lt;code&gt;pagination_class&lt;/code&gt; attribute:</source>
          <target state="translated">그런 다음 &lt;code&gt;pagination_class&lt;/code&gt; 속성을 사용하여 새 스타일을보기에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc144d5316c8a9e216267c5c083e6d01162a0c1e" translate="yes" xml:space="preserve">
          <source>You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.</source>
          <target state="translated">그런 다음 사용자 지정 동작을 적용해야 할 때마다이 믹스 인을보기 또는보기에 간단히 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72161f0afc6aad61f40e3dc0a4a1d0afc8d79fbc" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;StaticHTMLRenderer&lt;/code&gt; either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.</source>
          <target state="translated">&lt;code&gt;StaticHTMLRenderer&lt;/code&gt; 를 사용하여 REST 프레임 워크를 사용하여 일반 HTML 페이지를 리턴하거나 단일 엔드 포인트에서 HTML 및 API 응답을 모두 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be2a31b7e0291155e22f905e51402f82a7f4a717" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.</source>
          <target state="translated">&lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 를 사용하여 REST 프레임 워크를 사용하여 일반 HTML 페이지를 리턴하거나 단일 엔드 포인트에서 HTML 및 API 응답을 모두 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89aa2abc610d782ca6033775dce3ef46aa5632c2" translate="yes" xml:space="preserve">
          <source>You can use REST framework's &lt;code&gt;Serializer&lt;/code&gt; classes to perform this data serialization, or use your own custom serialization.</source>
          <target state="translated">REST 프레임 워크의 &lt;code&gt;Serializer&lt;/code&gt; 클래스를 사용하여이 데이터 직렬화를 수행하거나 고유 한 사용자 정의 직렬화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdf5f27f228336c67d7682c40c12e93676b4641" translate="yes" xml:space="preserve">
          <source>You can use any of Django's existing validators, or write your own custom validators.</source>
          <target state="translated">Django의 기존 유효성 검사기를 사용하거나 고유 한 사용자 지정 유효성 검사기를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f5c918c5621ff33ee4d3edce0922377c90877d" translate="yes" xml:space="preserve">
          <source>You can use any of REST framework's test case classes as you would for the regular Django test case classes. The &lt;code&gt;self.client&lt;/code&gt; attribute will be an &lt;code&gt;APIClient&lt;/code&gt; instance.</source>
          <target state="translated">일반 Django 테스트 케이스 클래스에서와 마찬가지로 REST 프레임 워크의 테스트 케이스 클래스를 사용할 수 있습니다. &lt;code&gt;self.client&lt;/code&gt; 의 속성은 될 것 &lt;code&gt;APIClient&lt;/code&gt; 의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="befae55754108d51472b9016e7be77f386eee131" translate="yes" xml:space="preserve">
          <source>You could then write a view that returned a purchase queryset filtered by the username portion of the URL:</source>
          <target state="translated">그런 다음 URL의 사용자 이름 부분으로 필터링 된 구매 쿼리 세트를 반환하는 뷰를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d61d73daf67f8b15722412eb9df483087093808f" translate="yes" xml:space="preserve">
          <source>You may also want to override the &lt;code&gt;get_default_basename(self, viewset)&lt;/code&gt; method, or else always explicitly set the &lt;code&gt;basename&lt;/code&gt; argument when registering your viewsets with the router.</source>
          <target state="translated">&lt;code&gt;get_default_basename(self, viewset)&lt;/code&gt; 메소드 를 재정의 하거나 라우터에 뷰 세트 를 등록 할 때 항상 &lt;code&gt;basename&lt;/code&gt; 인수를 명시 적으로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="356400dc62103ee9682e748e30ae8d3b642b5e55" translate="yes" xml:space="preserve">
          <source>You may customize schema generation at the level of the schema as a whole, or on a per-view basis.</source>
          <target state="translated">스키마 수준에서 전체 또는보기별로 스키마 생성을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0ff198ec1e086438e7c12e4f1aed118a70d079" translate="yes" xml:space="preserve">
          <source>You may disable schema generation for a view by setting &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;schema&lt;/code&gt; 를 &lt;code&gt;None&lt;/code&gt; 으로 설정하여 뷰에 대한 스키마 생성을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa43900785126b92c664b4edc9f1b1f55473759c" translate="yes" xml:space="preserve">
          <source>You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the &lt;code&gt;list&lt;/code&gt; action similar to this:</source>
          <target state="translated">현재 작업을 기반으로 동작을 조정하기 위해 이러한 속성을 검사 할 수 있습니다. 예를 들어, 다음 과 유사한 &lt;code&gt;list&lt;/code&gt; 동작을 제외한 모든 권한을 권한으로 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa3e03e148ba21163985ddc93d6caa04e83d9b03" translate="yes" xml:space="preserve">
          <source>You may need to provide custom &lt;code&gt;ViewSet&lt;/code&gt; classes that do not have the full set of &lt;code&gt;ModelViewSet&lt;/code&gt; actions, or that customize the behavior in some other way.</source>
          <target state="translated">전체 &lt;code&gt;ModelViewSet&lt;/code&gt; 조치 세트가 없거나 다른 방식으로 동작을 사용자 정의하는 사용자 정의 &lt;code&gt;ViewSet&lt;/code&gt; 클래스 를 제공해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="318a3461de47e2f95a81baae4cadccd486f8bb33" translate="yes" xml:space="preserve">
          <source>You may use &lt;code&gt;include&lt;/code&gt; with an application namespace:</source>
          <target state="translated">응용 프로그램 네임 스페이스와 함께 &lt;code&gt;include&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2473a2c6da67427a28351fdaf8a644158e2bdd72" translate="yes" xml:space="preserve">
          <source>You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the &lt;code&gt;read_only=True&lt;/code&gt; attribute, you may use the shortcut Meta option, &lt;code&gt;read_only_fields&lt;/code&gt;.</source>
          <target state="translated">여러 필드를 읽기 전용으로 지정할 수 있습니다. &lt;code&gt;read_only=True&lt;/code&gt; 속성을 사용 하여 각 필드를 명시 적으로 추가하는 대신 바로 가기 메타 옵션 &lt;code&gt;read_only_fields&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7d4a5ce396a7b005adaf3dff0acf80504d2d67f" translate="yes" xml:space="preserve">
          <source>You might also want to create a few different users, to use for testing the API. The quickest way to do this will be with the &lt;code&gt;createsuperuser&lt;/code&gt; command.</source>
          <target state="translated">API 테스트에 사용할 몇 가지 다른 사용자를 만들 수도 있습니다. 가장 빠른 방법은 &lt;code&gt;createsuperuser&lt;/code&gt; 명령을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5e1ec431ba1fab78b108257496fdc7a6bea2ed0" translate="yes" xml:space="preserve">
          <source>You might want to check your API schema into version control and update it with each new release, or serve the API schema from your site's static media.</source>
          <target state="translated">API 스키마를 버전 제어로 확인하여 새 릴리스마다 업데이트하거나 사이트의 정적 미디어에서 API 스키마를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dacde7704efcafa06908198ff7122622e928cdf" translate="yes" xml:space="preserve">
          <source>You might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.</source>
          <target state="translated">요청한 현재 인증 된 사용자와 관련된 결과 만 반환되도록 쿼리 세트를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c72b4370f1aefe7fce5ffe85c2e7112ffa11eb2d" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;include the request as a keyword argument&lt;/strong&gt; to the function, for example:</source>
          <target state="translated">&lt;strong&gt;요청을&lt;/strong&gt; 함수 &lt;strong&gt;의 키워드 인수로 포함&lt;/strong&gt; 해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="897d4b89ead2c9a3d036098fcd2709cef5ce914f" translate="yes" xml:space="preserve">
          <source>You should now either add the filter backend to your settings:</source>
          <target state="translated">이제 필터 백엔드를 설정에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d913b409090a6bc7b0525ffe59d13c2171eb9e4" translate="yes" xml:space="preserve">
          <source>You want to customize the create or update behavior of multiple objects.</source>
          <target state="translated">여러 객체의 작성 또는 업데이트 동작을 사용자 정의하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2bab36e2f8e3a7403f7186894364f7e973ed2024" translate="yes" xml:space="preserve">
          <source>You want to provide particular validation of the lists, such as checking that one element does not conflict with another element in a list.</source>
          <target state="translated">한 요소가 목록의 다른 요소와 충돌하지 않는지 확인하는 등 목록의 특정 유효성 검사를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="383828e644aebacab42358efba40876d88094e4f" translate="yes" xml:space="preserve">
          <source>You want to write tests in such a way that they can also be run against a staging or live environment. (See &quot;Live tests&quot; below.)</source>
          <target state="translated">준비 또는 라이브 환경에 대해 실행할 수있는 방식으로 테스트를 작성하려고합니다. 아래의 &quot;실시간 테스트&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1fdb56529a282df45b04cb5128512a75d4da905" translate="yes" xml:space="preserve">
          <source>You will need to add an explicit &lt;code&gt;id&lt;/code&gt; field to the instance serializer. The default implicitly-generated &lt;code&gt;id&lt;/code&gt; field is marked as &lt;code&gt;read_only&lt;/code&gt;. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's &lt;code&gt;update&lt;/code&gt; method.</source>
          <target state="translated">인스턴스 시리얼 라이저에 명시적인 &lt;code&gt;id&lt;/code&gt; 필드 를 추가해야합니다 . 내재적으로 생성 된 기본 &lt;code&gt;id&lt;/code&gt; 필드는 &lt;code&gt;read_only&lt;/code&gt; 로 표시됩니다 . 이로 인해 업데이트시 제거됩니다. 명시 적으로 선언하면 목록 serializer의 &lt;code&gt;update&lt;/code&gt; 방법 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44fc44c9c8f6eee0b1a73b231ddd50b850982ec6" translate="yes" xml:space="preserve">
          <source>You will typically want to use both &lt;code&gt;FormParser&lt;/code&gt; and &lt;code&gt;MultiPartParser&lt;/code&gt; together in order to fully support HTML form data.</source>
          <target state="translated">HTML 양식 데이터를 완전히 지원하기 위해 일반적으로 &lt;code&gt;FormParser&lt;/code&gt; 와 &lt;code&gt;MultiPartParser&lt;/code&gt; 를 함께 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="31b4cbd8eba5e081509c9357f77e9cc0d06398d6" translate="yes" xml:space="preserve">
          <source>You won't typically need to access this property.</source>
          <target state="translated">일반적으로이 속성에 액세스 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="df63c0bf97ba405d904ea2ffe9efd7ec5963cd89" translate="yes" xml:space="preserve">
          <source>You won't typically need to call &lt;code&gt;.render()&lt;/code&gt; yourself, as it's handled by Django's standard response cycle.</source>
          <target state="translated">Django의 표준 응답주기에 의해 처리 &lt;code&gt;.render()&lt;/code&gt; 일반적으로 .render ()를 직접 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="339d15bbc1bdaa16976658fdc025beccd929fde1" translate="yes" xml:space="preserve">
          <source>You won't typically need to directly access the request's content type, as you'll normally rely on REST framework's default request parsing behavior.</source>
          <target state="translated">일반적으로 REST 프레임 워크의 기본 요청 구문 분석 동작에 의존하므로 일반적으로 요청의 컨텐츠 유형에 직접 액세스 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="239fbf1931b8bc9c4e49d39dd557c58342c63ef6" translate="yes" xml:space="preserve">
          <source>You won't typically need to directly access the request's content, as you'll normally rely on REST framework's default request parsing behavior.</source>
          <target state="translated">일반적으로 REST 프레임 워크의 기본 요청 구문 분석 동작에 의존하므로 일반적으로 요청의 컨텐츠에 직접 액세스 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b85756d955020b3227c40bdbd4217912bce145c7" translate="yes" xml:space="preserve">
          <source>You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using &lt;code&gt;GenericAPIView&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GenericAPIView&lt;/code&gt; 를 사용하여 사용자 정의보기를 작성하는 경우 다음 메소드를 호출해야 할 수도 있지만 일반적으로 다음 메소드를 대체하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="918e7aa5c624c1d8a4bfd3b1f541639068f57486" translate="yes" xml:space="preserve">
          <source>You won't typically need to override this method.</source>
          <target state="translated">일반적으로이 방법을 재정의 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d5041e0c373c4b6cfe5895237a3e605bb5daf01" translate="yes" xml:space="preserve">
          <source>You'll also be able to see the 'highlight' links on the snippet instances, that will take you to the highlighted code HTML representations.</source>
          <target state="translated">또한 스 니펫 인스턴스에서 '강조 표시'링크를 볼 수 있으며 강조 표시된 코드 HTML 표현으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="52ed6663a4dd786b0132d5b63b0c234c7635c006" translate="yes" xml:space="preserve">
          <source>You'll also need to create tokens for your users.</source>
          <target state="translated">또한 사용자를위한 토큰을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa473ae050fc2ff81040f8383a5b22150b49098" translate="yes" xml:space="preserve">
          <source>You'll need to install &lt;code&gt;pyyaml&lt;/code&gt;, so that you can render your generated schema into the commonly used YAML-based OpenAPI format.</source>
          <target state="translated">&lt;code&gt;pyyaml&lt;/code&gt; 을 설치 해야 생성 된 스키마를 일반적으로 사용되는 YAML 기반 OpenAPI 형식으로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c1e76a0ee72cddeece167adb994615c732e666" translate="yes" xml:space="preserve">
          <source>You'll need to remember to also set your custom throttle class in the &lt;code&gt;'DEFAULT_THROTTLE_CLASSES'&lt;/code&gt; settings key, or using the &lt;code&gt;throttle_classes&lt;/code&gt; view attribute.</source>
          <target state="translated">&lt;code&gt;'DEFAULT_THROTTLE_CLASSES'&lt;/code&gt; 설정 키에서 또는 &lt;code&gt;throttle_classes&lt;/code&gt; 보기 속성을 사용 하여 사용자 정의 스로틀 클래스를 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d94ad7c7117419add3a074d0bf54bf87f5fa2f04" translate="yes" xml:space="preserve">
          <source>You'll normally want to ensure that you've set an appropriate &lt;code&gt;related_name&lt;/code&gt; argument on the relationship, that you can use as the field name. For example:</source>
          <target state="translated">일반적으로 관계에 적절한 &lt;code&gt;related_name&lt;/code&gt; 인수를 설정 하여 필드 이름으로 사용할 수 있도록해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9e971e6d990e7e3ca08e842331ff46cfd803cf5" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; methods should return the validated value or raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt;. For example:</source>
          <target state="translated">귀하의 &lt;code&gt;validate_&amp;lt;field_name&amp;gt;&lt;/code&gt; 방법이 검증 값을 반환하거나 인상해야 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 을 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a13102036385a9d64d535e1b1b0105900b26d1cf" translate="yes" xml:space="preserve">
          <source>Your URL conf must include a pattern that matches the version with a &lt;code&gt;'version'&lt;/code&gt; keyword argument, so that this information is available to the versioning scheme.</source>
          <target state="translated">URL conf에는 버전 정보와 &lt;code&gt;'version'&lt;/code&gt; 정보가 일치하도록 'version' 키워드 인수 와 버전이 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd209ff1b28f9d563f3e2f4325edf1cdd2dc09df" translate="yes" xml:space="preserve">
          <source>Your client requests would now look like this:</source>
          <target state="translated">클라이언트 요청은 이제 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43ad616ef14f6a83abdbe63878b7495ca40b6ef5" translate="yes" xml:space="preserve">
          <source>[.format]</source>
          <target state="translated">[.format]</target>
        </trans-unit>
        <trans-unit id="4ce85fca0a4d594813c71fc6431877b07b296f39" translate="yes" xml:space="preserve">
          <source>[The &lt;code&gt;OPTIONS&lt;/code&gt;] method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.</source>
          <target state="translated">[ &lt;code&gt;OPTIONS&lt;/code&gt; ] 방법을 사용하면 클라이언트는 리소스 작업을 암시하거나 리소스 검색을 시작하지 않고도 리소스 또는 서버의 기능과 관련된 옵션 및 / 또는 요구 사항을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093e791ad7a9c3a0ec30b752159ad7cf3936f5ba" translate="yes" xml:space="preserve">
          <source>`@action(detail=False)` decorated method</source>
          <target state="translated">`@action (detail = False)`장식 된 방법</target>
        </trans-unit>
        <trans-unit id="a390fad12629877da799b7c47255f6b11f1cd516" translate="yes" xml:space="preserve">
          <source>`@action(detail=True)` decorated method</source>
          <target state="translated">`@action (detail = True)`장식 된 방법</target>
        </trans-unit>
        <trans-unit id="6fb791fc0793e5da35aadb4e56a20517c0ee0469" translate="yes" xml:space="preserve">
          <source>allow_empty</source>
          <target state="translated">allow_empty</target>
        </trans-unit>
        <trans-unit id="d4bf6f67e1eba9d1fe33608181af1dab11ec1462" translate="yes" xml:space="preserve">
          <source>allow_null</source>
          <target state="translated">allow_null</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="a9520b55a901e81f7340a83668f7cc4e672b51ad" translate="yes" xml:space="preserve">
          <source>api-root</source>
          <target state="translated">api-root</target>
        </trans-unit>
        <trans-unit id="3991eed2c13dd92afac3f6e2ba94959741d8f4b5" translate="yes" xml:space="preserve">
          <source>authentication.py</source>
          <target state="translated">authentication.py</target>
        </trans-unit>
        <trans-unit id="72fa26e01e6b5554a2756ac5c107b1f745ee04c3" translate="yes" xml:space="preserve">
          <source>auto_now and auto_now_add model fields.</source>
          <target state="translated">auto_now 및 auto_now_add 모델 필드</target>
        </trans-unit>
        <trans-unit id="4a7e925445bf522d033161f86425a43195e70c57" translate="yes" xml:space="preserve">
          <source>automatically generated root view</source>
          <target state="translated">자동 생성 된 루트 뷰</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="6870010883a79e8b2a508909dc21a05cc8ff73b8" translate="yes" xml:space="preserve">
          <source>destroy</source>
          <target state="translated">destroy</target>
        </trans-unit>
        <trans-unit id="442fdbdf9d81f38dabeb3f42f914c483f83cbf79" translate="yes" xml:space="preserve">
          <source>django-rest-auth</source>
          <target state="translated">django-rest-auth</target>
        </trans-unit>
        <trans-unit id="ac84c7c6069facb626e426e5a8b265dec5529fd6" translate="yes" xml:space="preserve">
          <source>django-rest-framework-gis</source>
          <target state="translated">django-rest-framework-gis</target>
        </trans-unit>
        <trans-unit id="ea96a379c7d2c5ea2a3119a0df2aeb135ade04d5" translate="yes" xml:space="preserve">
          <source>django-rest-framework-hstore</source>
          <target state="translated">django-rest-framework-hstore</target>
        </trans-unit>
        <trans-unit id="cb876140e32df8b596c918e71fd6a36249b605de" translate="yes" xml:space="preserve">
          <source>django-rest-framework-social-oauth2</source>
          <target state="translated">django-rest-framework-social-oauth2</target>
        </trans-unit>
        <trans-unit id="ff03bc57880f9e0cf91b66cb8a4a153f526dfdd4" translate="yes" xml:space="preserve">
          <source>django-rest-knox</source>
          <target state="translated">django-rest-knox</target>
        </trans-unit>
        <trans-unit id="620a62d2cdef6ef21ecbf3d72ac68e10feca8965" translate="yes" xml:space="preserve">
          <source>djangorestframework-recursive</source>
          <target state="translated">djangorestframework-recursive</target>
        </trans-unit>
        <trans-unit id="848fde7accfa33b81527109ab2a330cfa77fe873" translate="yes" xml:space="preserve">
          <source>drf-proxy-pagination</source>
          <target state="translated">drf-proxy-pagination</target>
        </trans-unit>
        <trans-unit id="5b24370d54413f4452722d795d837adbb53e06c4" translate="yes" xml:space="preserve">
          <source>drf-url-filters</source>
          <target state="translated">drf-url-filters</target>
        </trans-unit>
        <trans-unit id="37a6e3e0e6549aaaa79416864b625ec984a093a2" translate="yes" xml:space="preserve">
          <source>drfpasswordless</source>
          <target state="translated">drfpasswordless</target>
        </trans-unit>
        <trans-unit id="68eea605b542bdedfd8c166ca0f05555e8a02a44" translate="yes" xml:space="preserve">
          <source>error_messages</source>
          <target state="translated">error_messages</target>
        </trans-unit>
        <trans-unit id="677d996d969a156d5c3d603cc4dbc3cfae75245d" translate="yes" xml:space="preserve">
          <source>exceptions.py</source>
          <target state="translated">exceptions.py</target>
        </trans-unit>
        <trans-unit id="32f970db29c040bc3e814ea7d448f254de207b09" translate="yes" xml:space="preserve">
          <source>fields.py</source>
          <target state="translated">fields.py</target>
        </trans-unit>
        <trans-unit id="77fc400487ebf1ee955d8ada9c4c4b2a2d6e5fdd" translate="yes" xml:space="preserve">
          <source>filter_queryset(self, queryset)</source>
          <target state="translated">filter_queryset (자체, queryset)</target>
        </trans-unit>
        <trans-unit id="fe42ab13180bfe62696b769448b6352e24a99fd8" translate="yes" xml:space="preserve">
          <source>filters.py</source>
          <target state="translated">filters.py</target>
        </trans-unit>
        <trans-unit id="849c95483132a693288353cff40a8fb44c958963" translate="yes" xml:space="preserve">
          <source>format_suffix_patterns</source>
          <target state="translated">format_suffix_patterns</target>
        </trans-unit>
        <trans-unit id="0f929f3da146898b8d61f2e6630e4702879ef82f" translate="yes" xml:space="preserve">
          <source>get_object(self)</source>
          <target state="translated">get_object(self)</target>
        </trans-unit>
        <trans-unit id="0eefc0a1130f232e1fe436c265992f6609084ea4" translate="yes" xml:space="preserve">
          <source>get_queryset(self)</source>
          <target state="translated">get_queryset(self)</target>
        </trans-unit>
        <trans-unit id="aa9b43c8474750ec03ff022d972adf115842ba37" translate="yes" xml:space="preserve">
          <source>get_schema(self, request)</source>
          <target state="translated">get_schema (자체, 요청)</target>
        </trans-unit>
        <trans-unit id="0e1196cb409009e359f523d66e1a558aa554aaba" translate="yes" xml:space="preserve">
          <source>get_schema_view()</source>
          <target state="translated">get_schema_view()</target>
        </trans-unit>
        <trans-unit id="538662ee21204497baec21c2ed9242acd587cf1b" translate="yes" xml:space="preserve">
          <source>get_serializer_class(self)</source>
          <target state="translated">get_serializer_class(self)</target>
        </trans-unit>
        <trans-unit id="7a530a29c940f83858e6989570ffbdc5f2f71d95" translate="yes" xml:space="preserve">
          <source>group_names</source>
          <target state="translated">group_names</target>
        </trans-unit>
        <trans-unit id="e48d56c0945079bdee9ae96260d801473839bd47" translate="yes" xml:space="preserve">
          <source>help_text</source>
          <target state="translated">help_text</target>
        </trans-unit>
        <trans-unit id="8ad7d21c71b049b7003ba31b5f1322974df77ac8" translate="yes" xml:space="preserve">
          <source>initial</source>
          <target state="translated">initial</target>
        </trans-unit>
        <trans-unit id="64c65374dbab6fe3762748196d9d3a9610e2e5a9" translate="yes" xml:space="preserve">
          <source>label</source>
          <target state="translated">label</target>
        </trans-unit>
        <trans-unit id="0a5e4f72487b1873ff0fb0e57bc53d7ca3ca3e62" translate="yes" xml:space="preserve">
          <source>link-header-pagination</source>
          <target state="translated">link-header-pagination</target>
        </trans-unit>
        <trans-unit id="38b62be4bddaa5661c7d6b8e36e28159314df5c7" translate="yes" xml:space="preserve">
          <source>list</source>
          <target state="translated">list</target>
        </trans-unit>
        <trans-unit id="637a0dd7f9068a9ca80decee00259006ef0dbdb7" translate="yes" xml:space="preserve">
          <source>media_type</source>
          <target state="translated">media_type</target>
        </trans-unit>
        <trans-unit id="f6d90a9aca306074fcab486a7876b872ea484bd8" translate="yes" xml:space="preserve">
          <source>media_type=None</source>
          <target state="translated">media_type=None</target>
        </trans-unit>
        <trans-unit id="a77237ace4055dec5d1bd17dc107166609823ff3" translate="yes" xml:space="preserve">
          <source>metadata.py</source>
          <target state="translated">metadata.py</target>
        </trans-unit>
        <trans-unit id="af57f7197178d7005e9e7c75c7db224b753241e4" translate="yes" xml:space="preserve">
          <source>negotiation.py</source>
          <target state="translated">negotiation.py</target>
        </trans-unit>
        <trans-unit id="899ddde1125d36c028b20ad2162894d2a2fba7d9" translate="yes" xml:space="preserve">
          <source>pagination.py</source>
          <target state="translated">pagination.py</target>
        </trans-unit>
        <trans-unit id="478bc2561a60edf75473e0327dcfb69c3453ba7e" translate="yes" xml:space="preserve">
          <source>parser_context</source>
          <target state="translated">parser_context</target>
        </trans-unit>
        <trans-unit id="c28586813a2201858b2c3a589731636524792afb" translate="yes" xml:space="preserve">
          <source>parsers.py</source>
          <target state="translated">parsers.py</target>
        </trans-unit>
        <trans-unit id="7ef64b5fbe467e1e1ba0dba4d9cca0754f0dccac" translate="yes" xml:space="preserve">
          <source>partial_update</source>
          <target state="translated">partial_update</target>
        </trans-unit>
        <trans-unit id="82cbd3f74c3cd2d3a476311f130b69565b1f00b2" translate="yes" xml:space="preserve">
          <source>permissions.py</source>
          <target state="translated">permissions.py</target>
        </trans-unit>
        <trans-unit id="ec9cfa44dd5385dc53a7a258ac8f38913049835f" translate="yes" xml:space="preserve">
          <source>read_only</source>
          <target state="translated">read_only</target>
        </trans-unit>
        <trans-unit id="2d8598b394f1093bf526e83e00ccb6c099c136c7" translate="yes" xml:space="preserve">
          <source>relations.py</source>
          <target state="translated">relations.py</target>
        </trans-unit>
        <trans-unit id="64ed18205c333be71ff73fe2c1d71270bb0e4ff6" translate="yes" xml:space="preserve">
          <source>renderer_context=None</source>
          <target state="translated">renderer_context=None</target>
        </trans-unit>
        <trans-unit id="6f757a907b6bdc9aeefa5205af9de1aaaa5e3a6f" translate="yes" xml:space="preserve">
          <source>renderers.py</source>
          <target state="translated">renderers.py</target>
        </trans-unit>
        <trans-unit id="adee7d72e7a7eaa810541f688537452257797107" translate="yes" xml:space="preserve">
          <source>request.py</source>
          <target state="translated">request.py</target>
        </trans-unit>
        <trans-unit id="1a77d416224cbbe77a439cfd6c198030cb522872" translate="yes" xml:space="preserve">
          <source>required</source>
          <target state="translated">required</target>
        </trans-unit>
        <trans-unit id="0358a578260722479788a0be8ed7720fe91d7fbd" translate="yes" xml:space="preserve">
          <source>response.py</source>
          <target state="translated">response.py</target>
        </trans-unit>
        <trans-unit id="8f7012116984fbe875dffb6db6ba5e40a48bece9" translate="yes" xml:space="preserve">
          <source>rest_framework.exceptions.bad_request</source>
          <target state="translated">rest_framework.exceptions.bad_request</target>
        </trans-unit>
        <trans-unit id="f78f691929f6ac5a28525811a28fc158f2552c7a" translate="yes" xml:space="preserve">
          <source>rest_framework.exceptions.server_error</source>
          <target state="translated">rest_framework.exceptions.server_error</target>
        </trans-unit>
        <trans-unit id="413bc6164a680171ec99ade785c5b1e80ab3ee07" translate="yes" xml:space="preserve">
          <source>retrieve</source>
          <target state="translated">retrieve</target>
        </trans-unit>
        <trans-unit id="75470a3076d8da06e21a0f542f3a535af3f72e94" translate="yes" xml:space="preserve">
          <source>reverse</source>
          <target state="translated">reverse</target>
        </trans-unit>
        <trans-unit id="369da54d999d5fcd3b7734590a028612505e4c03" translate="yes" xml:space="preserve">
          <source>reverse.py</source>
          <target state="translated">reverse.py</target>
        </trans-unit>
        <trans-unit id="432059b5a8c24c7081616011f63c91cc84d9aeeb" translate="yes" xml:space="preserve">
          <source>reverse_lazy</source>
          <target state="translated">reverse_lazy</target>
        </trans-unit>
        <trans-unit id="b4d18844979ea5c8502ee442f480a7ae0051ddfb" translate="yes" xml:space="preserve">
          <source>routers.py</source>
          <target state="translated">routers.py</target>
        </trans-unit>
        <trans-unit id="603a8cf1bdd78ed40a01c84b71b4e473eca3e2a2" translate="yes" xml:space="preserve">
          <source>schema_url_patterns = [ url(r'^api/', include('myproject.api.urls')), ]</source>
          <target state="translated">schema_url_patterns = [url (r '^ api /', 포함 ( 'myproject.api.urls')),]</target>
        </trans-unit>
        <trans-unit id="a0947cf48fa69c290325f6ca7a75801798aedffc" translate="yes" xml:space="preserve">
          <source>schema_view = get_schema_view( title='Server Monitoring API', url='https://www.example.org/api/', patterns=schema_url_patterns, )</source>
          <target state="translated">schema_view = get_schema_view (title = '서버 모니터링 API', url = 'https : //www.example.org/api/', patterns = schema_url_patterns,)</target>
        </trans-unit>
        <trans-unit id="dc854a8114ddd470282c3b1e6fc7fe5f7e50e9d7" translate="yes" xml:space="preserve">
          <source>schemas.py</source>
          <target state="translated">schemas.py</target>
        </trans-unit>
        <trans-unit id="b949ea5e3950eda105a96e8ff4a9d3a4c522f95e" translate="yes" xml:space="preserve">
          <source>serializer_choice_field</source>
          <target state="translated">serializer_choice_field</target>
        </trans-unit>
        <trans-unit id="b410af3b7924a60865fb400724025c4a660c5c35" translate="yes" xml:space="preserve">
          <source>serializer_url_field</source>
          <target state="translated">serializer_url_field</target>
        </trans-unit>
        <trans-unit id="85db5ec643679f8e5e6c6a8fa4a3b0d07a8524d7" translate="yes" xml:space="preserve">
          <source>serializers.py</source>
          <target state="translated">serializers.py</target>
        </trans-unit>
        <trans-unit id="888c15d72e41c9f0f1882f4aea4c2d19f1a044eb" translate="yes" xml:space="preserve">
          <source>settings.py</source>
          <target state="translated">settings.py</target>
        </trans-unit>
        <trans-unit id="828d338a9b04221c9cbe286f50cd389f68de4ecf" translate="yes" xml:space="preserve">
          <source>source</source>
          <target state="translated">source</target>
        </trans-unit>
        <trans-unit id="7ea80f6391a82b23dd931e04fec7732effa779d6" translate="yes" xml:space="preserve">
          <source>status.py</source>
          <target state="translated">status.py</target>
        </trans-unit>
        <trans-unit id="c82e3d7279efa3eca576370af952c815d48ce41f" translate="yes" xml:space="preserve">
          <source>stream</source>
          <target state="translated">stream</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="a36e355ddb203d7d4133221f339dc406cb9f480f" translate="yes" xml:space="preserve">
          <source>test.py</source>
          <target state="translated">test.py</target>
        </trans-unit>
        <trans-unit id="3f8d9cda4b2817fef14f627d9fc43604b9eed766" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;https://github.com/heywbj/django-rest-framework-recursive&quot;&gt;djangorestframework-recursive&lt;/a&gt; package provides a &lt;code&gt;RecursiveField&lt;/code&gt; for serializing and deserializing recursive structures</source>
          <target state="translated">&lt;a href=&quot;https://github.com/heywbj/django-rest-framework-recursive&quot;&gt;djangorestframework 재귀&lt;/a&gt; 패키지는 제공 &lt;code&gt;RecursiveField&lt;/code&gt; 를 재귀 적 구조를 직렬화 및 역 직렬화를 위해</target>
        </trans-unit>
        <trans-unit id="45842d8317a295f3a920a9dc24268a8b7fdff8d5" translate="yes" xml:space="preserve">
          <source>this command will return the API token for the given user, creating it if it doesn't exist:</source>
          <target state="translated">이 명령은 주어진 사용자에 대한 API 토큰을 반환하여 존재하지 않는 경우 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4d69ce77dcbbd13873bf01a4bd5c1da404a4636e" translate="yes" xml:space="preserve">
          <source>throttling.py</source>
          <target state="translated">throttling.py</target>
        </trans-unit>
        <trans-unit id="0a25ba5991316bdda4a9b3abcee2106016df28a0" translate="yes" xml:space="preserve">
          <source>update</source>
          <target state="translated">update</target>
        </trans-unit>
        <trans-unit id="35ca276ebe85bc2c3e2d533b427cee393daa43a4" translate="yes" xml:space="preserve">
          <source>urlpatterns.py</source>
          <target state="translated">urlpatterns.py</target>
        </trans-unit>
        <trans-unit id="a1e10758ad5093193381c3cb1f14c4f62c084b20" translate="yes" xml:space="preserve">
          <source>user-detail</source>
          <target state="translated">user-detail</target>
        </trans-unit>
        <trans-unit id="219fb96e29cf20b9e544d59a062084fa10b45ca9" translate="yes" xml:space="preserve">
          <source>user-group-names</source>
          <target state="translated">user-group-names</target>
        </trans-unit>
        <trans-unit id="07c4ed3e34c751e2a6de6b2203425abf35e17a04" translate="yes" xml:space="preserve">
          <source>user-list</source>
          <target state="translated">user-list</target>
        </trans-unit>
        <trans-unit id="7c93aa4db37e03ea5aba04f295228d8b0a94f873" translate="yes" xml:space="preserve">
          <source>validators</source>
          <target state="translated">validators</target>
        </trans-unit>
        <trans-unit id="f5f640b1ea5eba19902cfd6fdce6c1e508b235e9" translate="yes" xml:space="preserve">
          <source>validators.py</source>
          <target state="translated">validators.py</target>
        </trans-unit>
        <trans-unit id="7373d11e06171e673d74b2f232860a00f9a72e4d" translate="yes" xml:space="preserve">
          <source>versioning.py</source>
          <target state="translated">versioning.py</target>
        </trans-unit>
        <trans-unit id="fdf33b657db8a371aca7fa0f030df77ccfe594e6" translate="yes" xml:space="preserve">
          <source>viewsets.py</source>
          <target state="translated">viewsets.py</target>
        </trans-unit>
        <trans-unit id="aa8585b23be5964ef1ee547af2ed7cf1ea6c8603" translate="yes" xml:space="preserve">
          <source>write_only</source>
          <target state="translated">write_only</target>
        </trans-unit>
        <trans-unit id="b34868591f4be49ec5053ff3221097896a0988b7" translate="yes" xml:space="preserve">
          <source>{basename}-detail</source>
          <target state="translated">{basename}-detail</target>
        </trans-unit>
        <trans-unit id="2aaa26ac26f9db8c618e2dde9bf3d92fd3e60cdb" translate="yes" xml:space="preserve">
          <source>{basename}-list</source>
          <target state="translated">{basename}-list</target>
        </trans-unit>
        <trans-unit id="8c1f5f5d50a7066b42edf52495b1ede77331978d" translate="yes" xml:space="preserve">
          <source>{basename}-{url_name}</source>
          <target state="translated">{basename}-{url_name}</target>
        </trans-unit>
        <trans-unit id="d9588702aeedc7fa2ca572ea3e4ee735cdad4098" translate="yes" xml:space="preserve">
          <source>{prefix}/</source>
          <target state="translated">{prefix}/</target>
        </trans-unit>
        <trans-unit id="e4c2698b353b34d1d12cf03215ff27e3917d07a6" translate="yes" xml:space="preserve">
          <source>{prefix}/[.format]</source>
          <target state="translated">{prefix}/[.format]</target>
        </trans-unit>
        <trans-unit id="eebc32be8cf9c219b68c8ae6b737b133f5cf73e4" translate="yes" xml:space="preserve">
          <source>{prefix}/{lookup}/</source>
          <target state="translated">{prefix}/{lookup}/</target>
        </trans-unit>
        <trans-unit id="4369656341b00ce841c3e3b615faf1b23425ba66" translate="yes" xml:space="preserve">
          <source>{prefix}/{lookup}/[.format]</source>
          <target state="translated">{prefix}/{lookup}/[.format]</target>
        </trans-unit>
        <trans-unit id="a19b32c60ea011eb3f417041f78d1be0455b2457" translate="yes" xml:space="preserve">
          <source>{prefix}/{lookup}/{url_path}/</source>
          <target state="translated">{prefix}/{lookup}/{url_path}/</target>
        </trans-unit>
        <trans-unit id="fc59d20c6a682f5a60f1e09eb380ac94423734c7" translate="yes" xml:space="preserve">
          <source>{prefix}/{lookup}/{url_path}/[.format]</source>
          <target state="translated">{prefix}/{lookup}/{url_path}/[.format]</target>
        </trans-unit>
        <trans-unit id="d83c07b96cb3c6781049d9702b8d33e5f1948645" translate="yes" xml:space="preserve">
          <source>{prefix}/{url_path}/</source>
          <target state="translated">{prefix}/{url_path}/</target>
        </trans-unit>
        <trans-unit id="b2a66bc48e0d03262a9f52e2f57444949f542205" translate="yes" xml:space="preserve">
          <source>{prefix}/{url_path}/[.format]</source>
          <target state="translated">{prefix}/{url_path}/[.format]</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
