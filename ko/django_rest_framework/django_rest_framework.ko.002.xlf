<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="django_rest_framework">
    <body>
      <group id="django_rest_framework">
        <trans-unit id="e9c543a358437599437e1e7fcf525b858b441e83" translate="yes" xml:space="preserve">
          <source>For details on configuration and usage see the Django REST framework OAuth documentation for &lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/authentication/&quot;&gt;authentication&lt;/a&gt; and &lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/permissions/&quot;&gt;permissions&lt;/a&gt;.</source>
          <target state="translated">구성 및 사용법에 대한 자세한 내용은 &lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/authentication/&quot;&gt;인증&lt;/a&gt; 및 &lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/permissions/&quot;&gt;권한에&lt;/a&gt; 대한 Django REST 프레임 워크 OAuth 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82a62585b9e40eb7a68025161fc597202770dc35" translate="yes" xml:space="preserve">
          <source>For example if your API serves JSON responses and the HTML browsable API, you might want to make &lt;code&gt;JSONRenderer&lt;/code&gt; your default renderer, in order to send &lt;code&gt;JSON&lt;/code&gt; responses to clients that do not specify an &lt;code&gt;Accept&lt;/code&gt; header.</source>
          <target state="translated">예를 들어 API가 JSON 응답 및 HTML 검색 가능 API를 제공 하는 경우 &lt;code&gt;Accept&lt;/code&gt; 헤더를 지정하지 않은 클라이언트에 &lt;code&gt;JSON&lt;/code&gt; 응답을 보내 려면 &lt;code&gt;JSONRenderer&lt;/code&gt; 를 기본 렌더러 로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0e5a4d0186d2460fdc99ce833a56ac7008d745f" translate="yes" xml:space="preserve">
          <source>For example if your URL config contained an entry like this:</source>
          <target state="translated">예를 들어 URL 구성에 다음과 같은 항목이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="4383d1c5017c24e1535c79e53ba6c81fb3bd2217" translate="yes" xml:space="preserve">
          <source>For example the following is an HTTP request to the &lt;code&gt;http://v1.example.com/bookings/&lt;/code&gt; URL:</source>
          <target state="translated">예를 들어 다음은 &lt;code&gt;http://v1.example.com/bookings/&lt;/code&gt; URL에 대한 HTTP 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="1a1777ddd8445aef4be2edec441ea13139ed8f5b" translate="yes" xml:space="preserve">
          <source>For example your project's &lt;code&gt;settings.py&lt;/code&gt; file might include something like this:</source>
          <target state="translated">예를 들어 프로젝트의 &lt;code&gt;settings.py&lt;/code&gt; 파일에는 다음과 같은 내용이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db04e79976eeaaf78a0153684b722b46a2a5b911" translate="yes" xml:space="preserve">
          <source>For example, given the following &lt;code&gt;Accept&lt;/code&gt; header:</source>
          <target state="translated">예를 들어 다음과 같은 &lt;code&gt;Accept&lt;/code&gt; 헤더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f800d8cb0f348b3eecfa070213caa4ec712169e" translate="yes" xml:space="preserve">
          <source>For example, given the following model for a tag, which has a generic relationship with other arbitrary models:</source>
          <target state="translated">예를 들어, 다른 임의의 모델과 일반적인 관계를 갖는 태그에 대해 다음 모델을 가정하면</target>
        </trans-unit>
        <trans-unit id="9f409a523ff3068b3f284f7bbf82013c2336e48a" translate="yes" xml:space="preserve">
          <source>For example, given the following views...</source>
          <target state="translated">예를 들어 다음과 같은 관점에서 볼 때 ...</target>
        </trans-unit>
        <trans-unit id="11189d71aab8784bc10c45c7c0a980f4435a7848" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;has_expired&lt;/code&gt; was a property on the &lt;code&gt;Account&lt;/code&gt; model, then the following serializer would automatically generate it as a &lt;code&gt;ReadOnlyField&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;has_expired&lt;/code&gt; 가 &lt;code&gt;Account&lt;/code&gt; 모델 의 속성 인 경우 다음 serializer는 자동으로 &lt;code&gt;ReadOnlyField&lt;/code&gt; 로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="db04e43d8de6330aac13ffc7aa4912be619b754e" translate="yes" xml:space="preserve">
          <source>For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:</source>
          <target state="translated">예를 들어 URL conf의 여러 필드를 기반으로 객체를 조회해야하는 경우 다음과 같은 mixin 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4daaa9c483c26920fb313e344e2c132ea2515a7" translate="yes" xml:space="preserve">
          <source>For example, if you want to change the URL for our custom action to &lt;code&gt;^users/{pk}/change-password/$&lt;/code&gt;, you could write:</source>
          <target state="translated">예를 들어, 사용자 정의 조치의 URL을 &lt;code&gt;^users/{pk}/change-password/$&lt;/code&gt; 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02660097feb3b9b5a09175b1c04c6204b72b0902" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:</source>
          <target state="translated">예를 들어, 초기화 시점에 직렬 변환기에서 사용해야하는 필드를 설정하려면 다음과 같이 직렬 변환기 클래스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c26de526ee046af3f5145c5efb0a3e1f46f2c5d" translate="yes" xml:space="preserve">
          <source>For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the &quot;503 Service Unavailable&quot; HTTP response code. You could do this like so:</source>
          <target state="translated">예를 들어, API가 때때로 도달 할 수없는 타사 서비스를 사용하는 경우 &quot;503 서비스를 사용할 수 없음&quot;HTTP 응답 코드에 대한 예외를 구현할 수 있습니다. 당신은 이렇게 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7245b6e5becdd0323a2d7a3a297ef39060c2ac73" translate="yes" xml:space="preserve">
          <source>For example, it's easier to inspect &lt;code&gt;response.data&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;response.data&lt;/code&gt; 검사가 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="886db48c31c39c83fec55a846cc4b09933990363" translate="yes" xml:space="preserve">
          <source>For example, multiple user throttle rates could be implemented by using the following classes...</source>
          <target state="translated">예를 들어 다음과 같은 클래스를 사용하여 여러 사용자 스로틀 속도를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14d8960c9dd49c3ffd1eee2dc1e435e215c479a" translate="yes" xml:space="preserve">
          <source>For example, suppose we wanted to ensure that &lt;code&gt;User&lt;/code&gt; instances and &lt;code&gt;Profile&lt;/code&gt; instances are always created together as a pair. We might write a custom manager class that looks something like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;User&lt;/code&gt; 인스턴스와 &lt;code&gt;Profile&lt;/code&gt; 인스턴스가 항상 한 쌍으로 작성 되도록하려고한다고 가정하십시오 . 다음과 같은 사용자 정의 관리자 클래스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="690b680dc1d5bdb8d75a0409c32ad821ac033387" translate="yes" xml:space="preserve">
          <source>For example, the following additional route could be used on a viewset to provide a linkable schema endpoint.</source>
          <target state="translated">예를 들어 다음 추가 경로를 뷰 세트에서 사용하여 링크 가능한 스키마 끝점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402b0745198813513d520d882ca7700bab55d618" translate="yes" xml:space="preserve">
          <source>For example, the following request:</source>
          <target state="translated">예를 들어 다음과 같은 요청이 있습니다.</target>
        </trans-unit>
        <trans-unit id="33676b463006adb8c9579f696b792bb0497d8619" translate="yes" xml:space="preserve">
          <source>For example, the following serializer.</source>
          <target state="translated">예를 들어 다음 직렬 변환기입니다.</target>
        </trans-unit>
        <trans-unit id="0f8b2d16da98838438db929a22b3e6778f06dec3" translate="yes" xml:space="preserve">
          <source>For example, the following serializer:</source>
          <target state="translated">예를 들어 다음 직렬 변환기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="296c6a4db703f561414d20277b2d64aeef1bda29" translate="yes" xml:space="preserve">
          <source>For example, to add support for using &lt;code&gt;format='html'&lt;/code&gt; in test requests, you might have something like this in your &lt;code&gt;settings.py&lt;/code&gt; file.</source>
          <target state="translated">예를 들어 테스트 요청에서 &lt;code&gt;format='html'&lt;/code&gt; 사용에 대한 지원을 추가 하려면 &lt;code&gt;settings.py&lt;/code&gt; 파일 에 이와 같은 것이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5cdc1e90b8f8d2e3724c66682de4c8b23b0c2da2" translate="yes" xml:space="preserve">
          <source>For example, to create a field that validates a mapping of strings to strings, you would write something like this:</source>
          <target state="translated">예를 들어, 문자열과 문자열의 매핑을 확인하는 필드를 만들려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a8df27e89380cd328709cb7ca975b2bf7dc81631" translate="yes" xml:space="preserve">
          <source>For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:</source>
          <target state="translated">예를 들어 직렬화 기 유효성 검사 데이터의 일부로 항상 현재 시간을 제공하는 필드를 포함하려면 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a85df1b95a16d09692cf8582d2eaf951a6771db2" translate="yes" xml:space="preserve">
          <source>For example, to order users by username:</source>
          <target state="translated">예를 들어, 사용자 이름으로 사용자를 주문하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad72f7773f4a35cc6adbb016a638b482d89750a7" translate="yes" xml:space="preserve">
          <source>For example, to validate a list of integers you might use something like the following:</source>
          <target state="translated">예를 들어 정수 목록의 유효성을 검사하기 위해 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08769d3a75519425b9b5b0bd60ee3bb9f9d6265" translate="yes" xml:space="preserve">
          <source>For example, using &lt;code&gt;APIRequestFactory&lt;/code&gt;, you can make a form PUT request like so:</source>
          <target state="translated">예를 들어, &lt;code&gt;APIRequestFactory&lt;/code&gt; 를 사용하면 다음과 같이 양식 PUT 요청을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2462c92d64a08a7b25d123efa8b0bc3ce76ac8af" translate="yes" xml:space="preserve">
          <source>For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration.</source>
          <target state="translated">예를 들어, 순서, 제목 및 지속 시간을 사용하여 트랙을 사용자 정의 문자열 표현으로 직렬화하기 위해 관계형 필드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="463f1f5468e90ee54861782be95a2efaef0ef979" translate="yes" xml:space="preserve">
          <source>For example, when forcibly authenticating using a token, you might do something like the following:</source>
          <target state="translated">예를 들어, 토큰을 사용하여 강제로 인증하는 경우 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c8402a95725f0469c107df023b11aaef5e0f92" translate="yes" xml:space="preserve">
          <source>For example, you can append &lt;code&gt;router.urls&lt;/code&gt; to a list of existing views...</source>
          <target state="translated">예를 들어 &lt;code&gt;router.urls&lt;/code&gt; 를 기존보기 목록에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e68fccfc29b1fd6d3ee2148a9ee0714dadba0bc6" translate="yes" xml:space="preserve">
          <source>For example, you may return additional user information beyond the &lt;code&gt;token&lt;/code&gt; value:</source>
          <target state="translated">예를 들어 &lt;code&gt;token&lt;/code&gt; 값 이외의 추가 사용자 정보를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce526da432eca509fb4cc7e47c1054ed542b99b7" translate="yes" xml:space="preserve">
          <source>For example, you might need to restrict users to only being able to see objects they created.</source>
          <target state="translated">예를 들어, 사용자가 자신이 만든 개체 만 볼 수 있도록 제한해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a42ff9d060992df35e6b18b5d4ab83f3d02926" translate="yes" xml:space="preserve">
          <source>For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:</source>
          <target state="translated">예를 들어, 모든 오류 응답에 다음과 같이 응답 본문에 HTTP 상태 코드가 포함되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4a9a1afba08c0e0323d4da1c781504ee13c4f37" translate="yes" xml:space="preserve">
          <source>For example...</source>
          <target state="translated">예를 들어 ...</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4198a1d731707d17d2ea01a556eefe18f957c0a" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;http://example.com/organizations.csv/&lt;/code&gt;</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;http://example.com/organizations.csv/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e25c7ce9bd47aa05d832134c49da88fb77eac25c" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;http://example.com/organizations/?format=csv&lt;/code&gt;</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;http://example.com/organizations/?format=csv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7928ba71a1508aa804bf30b5b18498ea66d5e57" translate="yes" xml:space="preserve">
          <source>For full details see the &lt;a href=&quot;../relations/index&quot;&gt;serializer relations&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../relations/index&quot;&gt;시리얼 라이저 관계&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e22c0509bfd4f98392b4cadb6e9a68a12a5bb9ca" translate="yes" xml:space="preserve">
          <source>For further examples on &lt;code&gt;HiddenField&lt;/code&gt; see the &lt;a href=&quot;../validators/index&quot;&gt;validators&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;HiddenField&lt;/code&gt; 에 대한 추가 예 는 &lt;a href=&quot;../validators/index&quot;&gt;유효성 검사기&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b351c4f846a64bcfc723f8ba666dac82e61c705" translate="yes" xml:space="preserve">
          <source>For good examples of custom media types, see GitHub's use of a custom &lt;a href=&quot;https://developer.github.com/v3/media/&quot;&gt;application/vnd.github+json&lt;/a&gt; media type, and Mike Amundsen's IANA approved &lt;a href=&quot;http://www.amundsen.com/media-types/collection/&quot;&gt;application/vnd.collection+json&lt;/a&gt; JSON-based hypermedia.</source>
          <target state="translated">사용자 정의 미디어 유형의 좋은 예는 GitHub의 사용자 정의 &lt;a href=&quot;https://developer.github.com/v3/media/&quot;&gt;응용 프로그램 /vnd.github+json&lt;/a&gt; 미디어 유형 사용 및 Mike Amundsen의 IANA 승인 &lt;a href=&quot;http://www.amundsen.com/media-types/collection/&quot;&gt;application / vnd.collection + json&lt;/a&gt; JSON 기반 하이퍼 미디어를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40314d028a214bf4225b8e5f1713f4a5ff521677" translate="yes" xml:space="preserve">
          <source>For information on how to setup the permission polices for your API please see the &lt;a href=&quot;../permissions/index&quot;&gt;permissions documentation&lt;/a&gt;.</source>
          <target state="translated">API에 대한 권한 정책을 설정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;../permissions/index&quot;&gt;권한 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aaee8d0fdb389b51f7ccae53f31628f22fd028b" translate="yes" xml:space="preserve">
          <source>For instance, given the previous example, and a product with an id of &lt;code&gt;4675&lt;/code&gt;, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:</source>
          <target state="translated">예를 들어, 앞의 예제와 ID가 &lt;code&gt;4675&lt;/code&gt; 인 제품의 경우 다음 URL은 지정된 제품 인스턴스에서 필터링 조건이 충족되었는지 여부에 따라 해당 객체를 반환하거나 404 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f943581e5b4c92df979994e9a2338a2a620e524" translate="yes" xml:space="preserve">
          <source>For more advanced filtering requirements you can specify a &lt;code&gt;FilterSet&lt;/code&gt; class that should be used by the view. You can read more about &lt;code&gt;FilterSet&lt;/code&gt;s in the &lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/index.html&quot;&gt;django-filter documentation&lt;/a&gt;. It's also recommended that you read the section on &lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html&quot;&gt;DRF integration&lt;/a&gt;.</source>
          <target state="translated">보다 고급 필터링 요구 사항을 보려면 뷰에서 사용해야 하는 &lt;code&gt;FilterSet&lt;/code&gt; 클래스를 지정할 수 있습니다. &lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/index.html&quot;&gt;django-filter documentation&lt;/a&gt; 에서 &lt;code&gt;FilterSet&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 . &lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html&quot;&gt;DRF 통합&lt;/a&gt; 에 대한 섹션을 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="99465d71c6b7eb2e797e612128d62bc6950d21b9" translate="yes" xml:space="preserve">
          <source>For more complex cases you might also want to override various methods on the view class. For example.</source>
          <target state="translated">더 복잡한 경우에는보기 클래스에서 다양한 메소드를 대체 할 수도 있습니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="e0c33397768e68b24ba0dbfee1fa83a5e3d1489d" translate="yes" xml:space="preserve">
          <source>For more details on this approach see the Django documentation on &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/db/managers/&quot;&gt;model managers&lt;/a&gt;, and &lt;a href=&quot;https://www.dabapps.com/blog/django-models-and-encapsulation/&quot;&gt;this blogpost on using model and manager classes&lt;/a&gt;.</source>
          <target state="translated">이 방법에 대한 자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/db/managers/&quot;&gt;모델 관리자&lt;/a&gt; 에 대한 Django 설명서 및 &lt;a href=&quot;https://www.dabapps.com/blog/django-models-and-encapsulation/&quot;&gt;모델 및 관리자 클래스 사용에 대한이 블로그 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89ca7e35e990b8d1f8a35f78a4af6ab1577bae2a" translate="yes" xml:space="preserve">
          <source>For more details see the &lt;a href=&quot;../authentication/index&quot;&gt;authentication documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../authentication/index&quot;&gt;인증 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b45df454852a460f2072fe5bb9bc928b58153bc" translate="yes" xml:space="preserve">
          <source>For more details see the &lt;a href=&quot;../parsers/index&quot;&gt;parsers documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../parsers/index&quot;&gt;파서 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d9b85d5dfa4f6278213353472edacdd3c9d25c4" translate="yes" xml:space="preserve">
          <source>For more details see the &lt;a href=&quot;https://django-oauth-toolkit.readthedocs.io/en/latest/rest-framework/getting_started.html&quot;&gt;Django REST framework - Getting started&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://django-oauth-toolkit.readthedocs.io/en/latest/rest-framework/getting_started.html&quot;&gt;Django REST 프레임 워크-시작&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8b501d3215cf9be383d40435033542c3316b5b7" translate="yes" xml:space="preserve">
          <source>For more details see the &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;HTML &amp;amp; Forms&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;HTML 및 양식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1e8c073330381bfe31520d3e2752757fe2553fc" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields&quot;&gt;Django documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields&quot;&gt;Django 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0bd58375db3c9cafb99b7a7d756c92dbdd0d98d" translate="yes" xml:space="preserve">
          <source>For more information on proper usage of HTTP status codes see &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;.</source>
          <target state="translated">HTTP 상태 코드의 올바른 사용법에 대한 자세한 내용은 &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;RFC 2616&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21b2d5a6538e00063b2d2d110ff80107db153f7c" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;HTTP Accept&lt;/code&gt; header, see &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;HTTP Accept&lt;/code&gt; 헤더 에 대한 자세한 내용 은 &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot;&gt;RFC 2616을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bea41b21be4cddcaa35166f5bc6263c34524e622" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#id1&quot;&gt;the Django documentation on generic relations&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#id1&quot;&gt;일반 관계에 대한 Django 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef79fa7ce63e3aa8b4952f1313a12d56915daaf4" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;../validators/index&quot;&gt;validators documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../validators/index&quot;&gt;유효성 검사기 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2ba95fe4a3f37bc7ca888625c1010fafde11fcb" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://www.django-rest-framework.org/topics/browser-enhancements/&quot;&gt;browser enhancements documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.django-rest-framework.org/topics/browser-enhancements/&quot;&gt;브라우저 향상 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03555c415fd074777a6080120c0a814c8af82fbe" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;HTML &amp;amp; Forms&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;HTML 및 양식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8533dba87c9741b2c7a6c4f4d254d023fb7df8e6" translate="yes" xml:space="preserve">
          <source>For more information see the documentation on &lt;a href=&quot;../content-negotiation/index&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../content-negotiation/index&quot;&gt;내용 협상&lt;/a&gt; 에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="821ad211b1ced7b449c2635810f2010bdd63e93d" translate="yes" xml:space="preserve">
          <source>For more technical details on the implementation we use for cursor pagination, the &lt;a href=&quot;https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api&quot;&gt;&quot;Building cursors for the Disqus API&quot;&lt;/a&gt; blog post gives a good overview of the basic approach.</source>
          <target state="translated">커서 페이지 매김에 사용하는 구현에 대한 자세한 기술 정보는 &lt;a href=&quot;https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api&quot;&gt;&quot;Disqus API 용 커서 작성&quot;&lt;/a&gt; 블로그 게시물에서 기본 접근 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8a8b69d5da4c0ccff1d41771312a53f941ed5f2" translate="yes" xml:space="preserve">
          <source>For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.</source>
          <target state="translated">성능상의 이유로 일반 뷰는 개체 목록을 반환 할 때 쿼리 집합의 각 인스턴스에 개체 수준 권한을 자동으로 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="261e34432a92bf8ada061223eb2a8f663c363e96" translate="yes" xml:space="preserve">
          <source>For priority support please sign up for a &lt;a href=&quot;https://fund.django-rest-framework.org/topics/funding/&quot;&gt;professional or premium sponsorship plan&lt;/a&gt;.</source>
          <target state="translated">우선 지원을 받으려면 &lt;a href=&quot;https://fund.django-rest-framework.org/topics/funding/&quot;&gt;전문가 또는 프리미엄 후원 계획에 가입하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25569ce5bd023431f84f9049a37ecf3eb8f4d6a8" translate="yes" xml:space="preserve">
          <source>For support please see the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/django-rest-framework&quot;&gt;REST framework discussion group&lt;/a&gt;, try the &lt;code&gt;#restframework&lt;/code&gt; channel on &lt;code&gt;irc.freenode.net&lt;/code&gt;, search &lt;a href=&quot;https://botbot.me/freenode/restframework/&quot;&gt;the IRC archives&lt;/a&gt;, or raise a question on &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;, making sure to include the &lt;a href=&quot;https://stackoverflow.com/questions/tagged/django-rest-framework&quot;&gt;'django-rest-framework'&lt;/a&gt; tag.</source>
          <target state="translated">지원을 받으려면 &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/django-rest-framework&quot;&gt;REST 프레임 워크 토론 그룹을&lt;/a&gt; 참조하고 &lt;code&gt;irc.freenode.net&lt;/code&gt; 에서 &lt;code&gt;#restframework&lt;/code&gt; 채널을 시도 하거나 &lt;a href=&quot;https://botbot.me/freenode/restframework/&quot;&gt;, IRC 아카이브를&lt;/a&gt; 검색 하거나 , &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt; 에 대한 질문을 제기 하여 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/django-rest-framework&quot;&gt;'django-rest-framework'&lt;/a&gt; 태그 를 포함 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d2380812c45aa66d4707400bb3250168d81b82b4" translate="yes" xml:space="preserve">
          <source>For the purposes of many Web APIs, simple &lt;code&gt;JSON&lt;/code&gt; responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and &lt;a href=&quot;http://timelessrepo.com/haters-gonna-hateoas&quot;&gt;HATEOAS&lt;/a&gt; you'll need to consider the design and usage of your media types in more detail.</source>
          <target state="translated">많은 웹 API의 목적을 위해 하이퍼 링크 관계가있는 간단한 &lt;code&gt;JSON&lt;/code&gt; 응답으로 충분할 수 있습니다. RESTful 디자인과 &lt;a href=&quot;http://timelessrepo.com/haters-gonna-hateoas&quot;&gt;HATEOAS&lt;/a&gt; 를 완전히 수용 하려면 미디어 유형의 디자인과 사용법을보다 자세히 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bd079d4b965973bab00761062345323d15886b1" translate="yes" xml:space="preserve">
          <source>For the purposes of this tutorial we're going to start by creating a simple &lt;code&gt;Snippet&lt;/code&gt; model that is used to store code snippets. Go ahead and edit the &lt;code&gt;snippets/models.py&lt;/code&gt; file. Note: Good programming practices include comments. Although you will find them in our repository version of this tutorial code, we have omitted them here to focus on the code itself.</source>
          <target state="translated">이 튜토리얼의 목적 을 위해 코드 스 니펫을 저장하는 데 사용되는 간단한 스 &lt;code&gt;Snippet&lt;/code&gt; 모델을 만들어 보겠습니다 . &lt;code&gt;snippets/models.py&lt;/code&gt; 파일을 편집 하십시오. 참고 : 좋은 프로그래밍 방법에는 주석이 포함됩니다. 이 튜토리얼 코드의 리포지토리 버전에서 찾을 수 있지만 여기서는 코드 자체에 초점을 맞추기 위해 생략했습니다.</target>
        </trans-unit>
        <trans-unit id="2bc89af918b34c91ed9997a7c81cef276628edeb" translate="yes" xml:space="preserve">
          <source>For these cases you can modify the class that is used when &lt;code&gt;many=True&lt;/code&gt; is passed, by using the &lt;code&gt;list_serializer_class&lt;/code&gt; option on the serializer &lt;code&gt;Meta&lt;/code&gt; class.</source>
          <target state="translated">이러한 경우 serializer &lt;code&gt;Meta&lt;/code&gt; 클래스 의 &lt;code&gt;list_serializer_class&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;many=True&lt;/code&gt; 가 전달 될 때 사용되는 클래스를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="727e619b78a30533e4f73acbe768b196d21e7227" translate="yes" xml:space="preserve">
          <source>For this reason, the nested serialiser approach would be the first to try. You would use the custom field approach when the nested serialiser becomes infeasible or overly complex.</source>
          <target state="translated">이러한 이유로, 중첩 된 직렬 변환기 접근 방식이 가장 먼저 시도 될 것입니다. 중첩 된 직렬 변환기가 실행 불가능하거나 지나치게 복잡해지면 사용자 정의 필드 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aba092f7a94435f425889220b49ed91e6644425f" translate="yes" xml:space="preserve">
          <source>For updates on REST framework development, you may also want to follow &lt;a href=&quot;https://twitter.com/_tomchristie&quot;&gt;the author&lt;/a&gt; on Twitter.</source>
          <target state="translated">REST 프레임 워크 개발에 대한 업데이트 는 Twitter &lt;a href=&quot;https://twitter.com/_tomchristie&quot;&gt;에서 저자&lt;/a&gt; 를 팔로우하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4be1ffe9f09f8e04ddda6cef810e4cef5c2407d3" translate="yes" xml:space="preserve">
          <source>For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is &lt;code&gt;None&lt;/code&gt;, or not provided, which of the following should occur?</source>
          <target state="translated">업데이트의 경우 관계 업데이트를 처리하는 방법에 대해 신중하게 생각해야합니다. 예를 들어 관계에 대한 데이터가 &lt;code&gt;None&lt;/code&gt; 이거나 제공되지 않은 경우 다음 중 어떤 것이 발생해야합니까?</target>
        </trans-unit>
        <trans-unit id="36451460d0d8cbb29af7609e38e838238efd1a79" translate="yes" xml:space="preserve">
          <source>For very simple cases you might want to pass through any class attributes using the &lt;code&gt;.as_view()&lt;/code&gt; method. For example, your URLconf might include something like the following entry:</source>
          <target state="translated">매우 간단한 경우에는 &lt;code&gt;.as_view()&lt;/code&gt; 메소드를 사용하여 클래스 속성을 전달할 수 있습니다 . 예를 들어 URLconf에는 다음과 같은 항목이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a28448c651ecfcaee48c4ca154606ac0ad114a0" translate="yes" xml:space="preserve">
          <source>Forcing CSRF validation</source>
          <target state="translated">CSRF 검증 강제</target>
        </trans-unit>
        <trans-unit id="e93eb8297ee6e9f615f5d81a119cbcf920bb008e" translate="yes" xml:space="preserve">
          <source>Forcing authentication</source>
          <target state="translated">인증 강제</target>
        </trans-unit>
        <trans-unit id="9d17c5779f4457ef3d3a22fbb0eeef9a9b53b96a" translate="yes" xml:space="preserve">
          <source>FormParser</source>
          <target state="translated">FormParser</target>
        </trans-unit>
        <trans-unit id="651a3eabc714702a1ef48ca736737c9986cf2c4f" translate="yes" xml:space="preserve">
          <source>Format strings may either be &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;Python strftime formats&lt;/a&gt; which explicitly specify the format, or the special string &lt;code&gt;'iso-8601'&lt;/code&gt;, which indicates that &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; style dates should be used. (eg &lt;code&gt;'2013-01-29'&lt;/code&gt;)</source>
          <target state="translated">형식 문자열은 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;형식&lt;/a&gt; 을 명시 적으로 지정하는 Python strftime 형식 이거나 &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; 스타일 날짜를 사용해야한다는 특수 문자열 &lt;code&gt;'iso-8601'&lt;/code&gt; 일 수 있습니다. (예 : &lt;code&gt;'2013-01-29'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5e8e1ef2fd6fe19fd5c658cb84781503dde14f84" translate="yes" xml:space="preserve">
          <source>Format strings may either be &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;Python strftime formats&lt;/a&gt; which explicitly specify the format, or the special string &lt;code&gt;'iso-8601'&lt;/code&gt;, which indicates that &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; style datetimes should be used. (eg &lt;code&gt;'2013-01-29T12:34:56.000000Z'&lt;/code&gt;)</source>
          <target state="translated">형식 문자열은 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;형식&lt;/a&gt; 을 명시 적으로 지정하는 Python strftime 형식 이거나 &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; 스타일 날짜 시간을 사용해야한다는 특수 문자열 &lt;code&gt;'iso-8601'&lt;/code&gt; 일 수 있습니다. (예 : &lt;code&gt;'2013-01-29T12:34:56.000000Z'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6b7da15bb357dcaa7b62fc0f96c981b456b273d0" translate="yes" xml:space="preserve">
          <source>Format strings may either be &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;Python strftime formats&lt;/a&gt; which explicitly specify the format, or the special string &lt;code&gt;'iso-8601'&lt;/code&gt;, which indicates that &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; style times should be used. (eg &lt;code&gt;'12:34:56.000000'&lt;/code&gt;)</source>
          <target state="translated">형식 문자열은 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;형식&lt;/a&gt; 을 명시 적으로 지정하는 Python strftime 형식 이거나 &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601&lt;/a&gt; 스타일 시간을 사용해야한다는 특수 문자열 &lt;code&gt;'iso-8601'&lt;/code&gt; 일 수 있습니다. (예 : &lt;code&gt;'12:34:56.000000'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d2072fee998c46713c191a32ed679d761ae451c2" translate="yes" xml:space="preserve">
          <source>Format suffixes</source>
          <target state="translated">형식 접미사</target>
        </trans-unit>
        <trans-unit id="edf386184ad59de61c7bf2e55a096d857564d882" translate="yes" xml:space="preserve">
          <source>From this point we're going to really start covering the core of REST framework. Let's introduce a couple of essential building blocks.</source>
          <target state="translated">이 시점에서 우리는 실제로 REST 프레임 워크의 핵심을 다루기 시작할 것입니다. 몇 가지 필수 구성 요소를 소개하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6a6c116b4e4e9d659812fa703d3a956debea8377" translate="yes" xml:space="preserve">
          <source>Function Based Views</source>
          <target state="translated">함수 기반 뷰</target>
        </trans-unit>
        <trans-unit id="fd274d21fd5b619ca72a7b31b593f9c26ff4b26d" translate="yes" xml:space="preserve">
          <source>Function based</source>
          <target state="translated">기능 기반</target>
        </trans-unit>
        <trans-unit id="6ff171c66738f3aca6840ae3df12a51c55bce440" translate="yes" xml:space="preserve">
          <source>Funding</source>
          <target state="translated">Funding</target>
        </trans-unit>
        <trans-unit id="f0687ce4404ec85a9d4a2f2f232fa625198e2f02" translate="yes" xml:space="preserve">
          <source>Further context on how the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header works, and identifying a remote client IP can be &lt;a href=&quot;http://oxpedia.org/wiki/index.php?title=AppSuite:Grizzly#Multiple_Proxies_in_front_of_the_cluster&quot;&gt;found here&lt;/a&gt;.</source>
          <target state="translated">어떻게 '에 대한 자세한 상황 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더 작품 및 원격 클라이언트 IP를 식별을 할 수 있습니다 &lt;a href=&quot;http://oxpedia.org/wiki/index.php?title=AppSuite:Grizzly#Multiple_Proxies_in_front_of_the_cluster&quot;&gt;여기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fba66bdcf6ec240ef327d98f27d5e7d637567db7" translate="yes" xml:space="preserve">
          <source>Further notes</source>
          <target state="translated">추가 메모</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="fa1e0bc4957b876fe54e9201a62876958760e6dc" translate="yes" xml:space="preserve">
          <source>GET, or as specified by `methods` argument</source>
          <target state="translated">GET 또는`methods` 인수로 지정된</target>
        </trans-unit>
        <trans-unit id="bf8068c8318c37acbd9dee1ba10c5b1f735fdd82" translate="yes" xml:space="preserve">
          <source>Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.</source>
          <target state="translated">일반적으로 가능한 경우 API 표현에 플랫 스타일을 권장하지만 조정에 사용될 경우 중첩 된 URL 스타일도 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee55c666c5d3cb12ea6bc4b6eae1749e0c93d3f" translate="yes" xml:space="preserve">
          <source>Generating Tokens</source>
          <target state="translated">토큰 생성</target>
        </trans-unit>
        <trans-unit id="564ca03b24becc174f89a4cdc9a77c4d57f6985e" translate="yes" xml:space="preserve">
          <source>Generating a dynamic schema with SchemaView</source>
          <target state="translated">SchemaView를 사용하여 동적 스키마 생성</target>
        </trans-unit>
        <trans-unit id="f40c01744ad8babf546885dc03b9cb5499fd318a" translate="yes" xml:space="preserve">
          <source>Generating a static schema with the generateschema management command</source>
          <target state="translated">generatechema 관리 명령으로 정적 스키마 생성</target>
        </trans-unit>
        <trans-unit id="1742f633800fa34952421201c4f387efea98cfeb" translate="yes" xml:space="preserve">
          <source>Generating an OpenAPI Schema</source>
          <target state="translated">OpenAPI 스키마 생성</target>
        </trans-unit>
        <trans-unit id="f99361b3c3214e2138e024b1875260c964b9b225" translate="yes" xml:space="preserve">
          <source>Generic Error Views</source>
          <target state="translated">일반적인 오류보기</target>
        </trans-unit>
        <trans-unit id="643e14ec017c81a2bfbcdd4c145540414f0b1e6b" translate="yes" xml:space="preserve">
          <source>Generic Filtering</source>
          <target state="translated">일반 필터링</target>
        </trans-unit>
        <trans-unit id="cec0e44b62eebe75763b09f6f8869e772152ce54" translate="yes" xml:space="preserve">
          <source>Generic filters can also present themselves as HTML controls in the browsable API and admin API.</source>
          <target state="translated">일반 필터는 탐색 가능한 API 및 관리 API에서 HTML 컨트롤로 표시 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f211fbd015d16ec4d378f3602e55adf18c271d" translate="yes" xml:space="preserve">
          <source>Generic filters may also present an interface in the browsable API. To do so you should implement a &lt;code&gt;to_html()&lt;/code&gt; method which returns a rendered HTML representation of the filter. This method should have the following signature:</source>
          <target state="translated">일반 필터는 찾아보기 가능한 API에 인터페이스를 제공 할 수도 있습니다. 그렇게하려면 필터의 렌더링 된 HTML 표현을 반환하는 &lt;code&gt;to_html()&lt;/code&gt; 메서드를 구현해야합니다 . 이 방법에는 다음과 같은 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2bb37295743cc6aaa17b171db5e84b256fa5b1" translate="yes" xml:space="preserve">
          <source>Generic relationships</source>
          <target state="translated">일반적인 관계</target>
        </trans-unit>
        <trans-unit id="0f5ba99e85307895b0b82c960b06cf40211dd001" translate="yes" xml:space="preserve">
          <source>Generic view settings</source>
          <target state="translated">일반보기 설정</target>
        </trans-unit>
        <trans-unit id="5501abd5185b3c6248d23e02a1ce2bfbd96f81c6" translate="yes" xml:space="preserve">
          <source>Generic views</source>
          <target state="translated">일반 뷰</target>
        </trans-unit>
        <trans-unit id="b46cc131fc0ec840ef04b25b980bd50067849f6c" translate="yes" xml:space="preserve">
          <source>GenericAPIView</source>
          <target state="translated">GenericAPIView</target>
        </trans-unit>
        <trans-unit id="a43c15efd56d774c87ad80301e6864841c49525c" translate="yes" xml:space="preserve">
          <source>GenericViewSet</source>
          <target state="translated">GenericViewSet</target>
        </trans-unit>
        <trans-unit id="a86ebc3eb8516bd03cba34a27d62750f207bbb7b" translate="yes" xml:space="preserve">
          <source>GeoFeatureModelSerializer</source>
          <target state="translated">GeoFeatureModelSerializer</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="595f2069a21cf2796d8bed33ce1999ae0c5195b0" translate="yes" xml:space="preserve">
          <source>Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.</source>
          <target state="translated">쿼리 세트가 주어지면 사용중인 필터 백엔드로 필터링하여 새 쿼리 세트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="63da1f16913535c553c38a6704122c4924fabdcf" translate="yes" xml:space="preserve">
          <source>Global setting for the &lt;code&gt;html_cutoff&lt;/code&gt; value. Must be an integer.</source>
          <target state="translated">&lt;code&gt;html_cutoff&lt;/code&gt; 값의 전역 설정 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e86e0f6dc1718778ac46a0767e84dca84fa722ab" translate="yes" xml:space="preserve">
          <source>Global settings for &lt;a href=&quot;../relations/index#select-field-cutoffs&quot;&gt;select field cutoffs for rendering relational fields&lt;/a&gt; in the browsable API.</source>
          <target state="translated">찾아보기 가능한 API에서 &lt;a href=&quot;../relations/index#select-field-cutoffs&quot;&gt;관계형 필드를 렌더링&lt;/a&gt; 하기위한 선택 필드 컷오프에 대한 글로벌 설정 .</target>
        </trans-unit>
        <trans-unit id="5dcc7ede05bdb6f5348b1b612287e6f86376a32a" translate="yes" xml:space="preserve">
          <source>Go ahead and test the API from the command line, as we did in &lt;a href=&quot;../1-serialization/index&quot;&gt;tutorial part 1&lt;/a&gt;. Everything is working pretty similarly, although we've got some nicer error handling if we send invalid requests.</source>
          <target state="translated">&lt;a href=&quot;../1-serialization/index&quot;&gt;튜토리얼 1 부&lt;/a&gt; 에서와 같이 명령 행에서 API를 테스트하십시오 . 유효하지 않은 요청을 보내면 더 좋은 오류 처리가 가능하지만 모든 것이 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2ca413be393b406badebcb96c91cf7b7a57309e5" translate="yes" xml:space="preserve">
          <source>Great, that was easy!</source>
          <target state="translated">좋아, 쉬웠다!</target>
        </trans-unit>
        <trans-unit id="c8c28d2b893c0d8a40af111dc14a163107a3cb15" translate="yes" xml:space="preserve">
          <source>HStoreField</source>
          <target state="translated">HStoreField</target>
        </trans-unit>
        <trans-unit id="79f2014c4a7bbc7bbcf7bad5c6ec210851de5bcb" translate="yes" xml:space="preserve">
          <source>HStoreSerializer</source>
          <target state="translated">HStoreSerializer</target>
        </trans-unit>
        <trans-unit id="e69db199e819883bc42eabde426053c1de4dca85" translate="yes" xml:space="preserve">
          <source>HTML JSON Forms</source>
          <target state="translated">HTML JSON 양식</target>
        </trans-unit>
        <trans-unit id="af21a2cb4171d95bc1593165ba9580d4035294b9" translate="yes" xml:space="preserve">
          <source>HTML Select Field cutoffs</source>
          <target state="translated">HTML 선택 필드 컷오프</target>
        </trans-unit>
        <trans-unit id="c6d7ce11c1179d9459f88904d2b5de3753846e8b" translate="yes" xml:space="preserve">
          <source>HTML error views</source>
          <target state="translated">HTML 오류보기</target>
        </trans-unit>
        <trans-unit id="70b01ca7c82eabe20ad18a66963955183a1844fa" translate="yes" xml:space="preserve">
          <source>HTML pagination controls</source>
          <target state="translated">HTML 페이지 매김 컨트롤</target>
        </trans-unit>
        <trans-unit id="aa731860255227851ce3f135e3919c70d8d6e3e7" translate="yes" xml:space="preserve">
          <source>HTMLFormRenderer</source>
          <target state="translated">HTMLFormRenderer</target>
        </trans-unit>
        <trans-unit id="e613c1c09f58ba3f9720d643bdd17c69609f8659" translate="yes" xml:space="preserve">
          <source>HTML_SELECT_CUTOFF</source>
          <target state="translated">HTML_SELECT_CUTOFF</target>
        </trans-unit>
        <trans-unit id="e8a590c16527024e0e079f21615d5ba4fa942a81" translate="yes" xml:space="preserve">
          <source>HTML_SELECT_CUTOFF_TEXT</source>
          <target state="translated">HTML_SELECT_CUTOFF_TEXT</target>
        </trans-unit>
        <trans-unit id="56fddf04b157cb183b3b4c47d7d81612aafcaff1" translate="yes" xml:space="preserve">
          <source>HTTP 401 Unauthorized</source>
          <target state="translated">HTTP 401 무단</target>
        </trans-unit>
        <trans-unit id="1d7797c04550a2f1d4dd7f490a622228209a09a4" translate="yes" xml:space="preserve">
          <source>HTTP 401 responses must always include a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header, that instructs the client how to authenticate. HTTP 403 responses do not include the &lt;code&gt;WWW-Authenticate&lt;/code&gt; header.</source>
          <target state="translated">HTTP 401 응답에는 항상 클라이언트에게 인증 방법을 지시 하는 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 포함되어야 합니다. HTTP 403 응답에는 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 포함되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad5fd1c7ad3f6adc41cf5823fb24502bf0d588b" translate="yes" xml:space="preserve">
          <source>HTTP 403 Permission Denied</source>
          <target state="translated">HTTP 403 권한이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc0bd707e958f2af349ee4894ba5657c8c2c796a" translate="yes" xml:space="preserve">
          <source>HTTP Method</source>
          <target state="translated">HTTP 메소드</target>
        </trans-unit>
        <trans-unit id="a0ba1b70752a6e29760e6a454c7b14d09cde7781" translate="yes" xml:space="preserve">
          <source>HTTP Signature (currently a &lt;a href=&quot;https://datatracker.ietf.org/doc/draft-cavage-http-signatures/&quot;&gt;IETF draft&lt;/a&gt;) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to &lt;a href=&quot;https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html&quot;&gt;Amazon's HTTP Signature scheme&lt;/a&gt;, used by many of its services, it permits stateless, per-request authentication. &lt;a href=&quot;https://github.com/etoccalino/&quot;&gt;Elvio Toccalino&lt;/a&gt; maintains the &lt;a href=&quot;https://github.com/etoccalino/django-rest-framework-httpsignature&quot;&gt;djangorestframework-httpsignature&lt;/a&gt; (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of &lt;a href=&quot;https://github.com/etoccalino/django-rest-framework-httpsignature&quot;&gt;djangorestframework-httpsignature&lt;/a&gt;, which is &lt;a href=&quot;https://github.com/ahknight/drf-httpsig&quot;&gt;drf-httpsig&lt;/a&gt;.</source>
          <target state="translated">HTTP 서명 (현재 &lt;a href=&quot;https://datatracker.ietf.org/doc/draft-cavage-http-signatures/&quot;&gt;IETF 초안&lt;/a&gt; )은 HTTP 메시지의 원본 인증 및 메시지 무결성을 달성하는 방법을 제공합니다. 많은 서비스에서 사용되는 &lt;a href=&quot;https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html&quot;&gt;Amazon의 HTTP 서명 체계&lt;/a&gt; 와 유사하게 요청없는 상태 별 인증을 허용합니다. &lt;a href=&quot;https://github.com/etoccalino/&quot;&gt;Elvio Toccalino&lt;/a&gt; 는 사용하기 쉬운 HTTP 서명 인증 메커니즘을 제공하는 &lt;a href=&quot;https://github.com/etoccalino/django-rest-framework-httpsignature&quot;&gt;djangorestframework-httpsignature&lt;/a&gt; (오래된) 패키지를 유지 관리합니다 . 당신의 업데이트 된 포크 버전을 사용할 수 있습니다 &lt;a href=&quot;https://github.com/etoccalino/django-rest-framework-httpsignature&quot;&gt;djangorestframework-httpsignature&lt;/a&gt; 이다, &lt;a href=&quot;https://github.com/ahknight/drf-httpsig&quot;&gt;DRF-httpsig을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="889fa1705b0eb885f7d60710578e51d431264f7d" translate="yes" xml:space="preserve">
          <source>HTTP Signature Authentication</source>
          <target state="translated">HTTP 서명 인증</target>
        </trans-unit>
        <trans-unit id="a35f64384f3ef65b0b23169d559ca699db90c196" translate="yes" xml:space="preserve">
          <source>HTTP has provisions for several mechanisms for &quot;content negotiation&quot; - the process of selecting the best representation for a given response when there are multiple representations available.</source>
          <target state="translated">HTTP에는 &quot;컨텐츠 협상&quot;에 대한 여러 메커니즘이 있습니다. 사용 가능한 표현이 여러 개인 경우 지정된 응답에 가장 적합한 표현을 선택하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="b8d09874fb2ae0467cd1e05f163d17b5db01f989" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 420 Enhance Your Calm</source>
          <target state="translated">HTTP / 1.1 420 진정 향상</target>
        </trans-unit>
        <trans-unit id="3ddd3faaab88843ba7a3d567d6a152c05b2d9850" translate="yes" xml:space="preserve">
          <source>Handler methods may return REST framework's &lt;code&gt;Response&lt;/code&gt;, instead of Django's &lt;code&gt;HttpResponse&lt;/code&gt;. The view will manage content negotiation and setting the correct renderer on the response.</source>
          <target state="translated">핸들러 메소드는 Django의 &lt;code&gt;HttpResponse&lt;/code&gt; 대신 REST 프레임 워크의 &lt;code&gt;Response&lt;/code&gt; 를 리턴 할 수 있습니다 . 뷰는 컨텐츠 협상을 관리하고 응답에 올바른 렌더러를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9274f39248e1da8f2bf1230ee0366e79fcccaaa2" translate="yes" xml:space="preserve">
          <source>Handling saving related instances in model manager classes</source>
          <target state="translated">모델 관리자 클래스에서 관련 인스턴스 저장 처리</target>
        </trans-unit>
        <trans-unit id="785f95ce939b787977f06fd64a741713b658d48a" translate="yes" xml:space="preserve">
          <source>Has the same behavior as &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/urls/#reverse&quot;&gt;&lt;code&gt;django.urls.reverse&lt;/code&gt;&lt;/a&gt;, except that it returns a fully qualified URL, using the request to determine the host and port.</source>
          <target state="translated">호스트 및 포트를 판별하기위한 요청을 사용하여 완전한 URL을 리턴한다는 점을 제외하고 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/urls/#reverse&quot;&gt; &lt;code&gt;django.urls.reverse&lt;/code&gt; &lt;/a&gt; 와 동일한 작동을 합니다.</target>
        </trans-unit>
        <trans-unit id="bf9808701409e22ac5972c5eafe391aaca194bdc" translate="yes" xml:space="preserve">
          <source>Has the same behavior as &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/urls/#reverse-lazy&quot;&gt;&lt;code&gt;django.urls.reverse_lazy&lt;/code&gt;&lt;/a&gt;, except that it returns a fully qualified URL, using the request to determine the host and port.</source>
          <target state="translated">호스트 및 포트를 판별하기위한 요청을 사용하여 완전한 URL을 리턴한다는 점을 제외하고 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/urls/#reverse-lazy&quot;&gt; &lt;code&gt;django.urls.reverse_lazy&lt;/code&gt; &lt;/a&gt; 와 동일한 작동을 합니다.</target>
        </trans-unit>
        <trans-unit id="30862785fb7c5b9b6ff71e893cc9a4d786fbd085" translate="yes" xml:space="preserve">
          <source>Having a web-browsable API is a huge usability win, and makes developing and using your API much easier. It also dramatically lowers the barrier-to-entry for other developers wanting to inspect and work with your API.</source>
          <target state="translated">웹 브라우징 가능한 API를 사용하면 유용성이 크게 향상되고 API를 훨씬 쉽게 개발하고 사용할 수 있습니다. 또한 API를 검사하고 작업하려는 다른 개발자의 진입 장벽을 크게 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="79358758c0f4048f83be018397ea8e6eb3480273" translate="yes" xml:space="preserve">
          <source>Hawk HTTP Authentication</source>
          <target state="translated">호크 HTTP 인증</target>
        </trans-unit>
        <trans-unit id="500e5500bf2a87f2e4356909dcf53fafc0358c13" translate="yes" xml:space="preserve">
          <source>Headers &amp;amp; Authentication</source>
          <target state="translated">헤더 및 인증</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="175b05c3fb1be451d239b757f143eedd4ff404fd" translate="yes" xml:space="preserve">
          <source>Here is the view for an individual snippet, in the &lt;code&gt;views.py&lt;/code&gt; module.</source>
          <target state="translated">다음은 &lt;code&gt;views.py&lt;/code&gt; 모듈 의 개별 스 니펫에 대한보기입니다 .</target>
        </trans-unit>
        <trans-unit id="aef0b1798ef971c684a53310fbf9778830acb4b1" translate="yes" xml:space="preserve">
          <source>Here the mapping between the target and source attribute pairs (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;x_coordinate&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;y_coordinate&lt;/code&gt;) is handled in the &lt;code&gt;IntegerField&lt;/code&gt; declarations. It's our &lt;code&gt;NestedCoordinateSerializer&lt;/code&gt; that takes &lt;code&gt;source='*'&lt;/code&gt;.</source>
          <target state="translated">여기서 대상과 소스 속성 쌍 ( &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;x_coordinate&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;y_coordinate&lt;/code&gt; ) 간의 매핑 은 &lt;code&gt;IntegerField&lt;/code&gt; 선언 에서 처리됩니다 . 그것은 우리의 &lt;code&gt;NestedCoordinateSerializer&lt;/code&gt; 소요 &lt;code&gt;source='*'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85475e7796d1263e2788e54ccb40754776350a06" translate="yes" xml:space="preserve">
          <source>Here we'll take an example of a &lt;em&gt;flat&lt;/em&gt;&lt;code&gt;DataPoint&lt;/code&gt; model with &lt;code&gt;x_coordinate&lt;/code&gt; and &lt;code&gt;y_coordinate&lt;/code&gt; attributes.</source>
          <target state="translated">다음은 &lt;code&gt;x_coordinate&lt;/code&gt; 및 &lt;code&gt;y_coordinate&lt;/code&gt; 속성을 가진 &lt;em&gt;플랫 &lt;/em&gt; &lt;code&gt;DataPoint&lt;/code&gt; 모델 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="0aefbe55cdc104a08c16241f383ddf709c7eb266" translate="yes" xml:space="preserve">
          <source>Here we've used the &lt;code&gt;ReadOnlyModelViewSet&lt;/code&gt; class to automatically provide the default 'read-only' operations. We're still setting the &lt;code&gt;queryset&lt;/code&gt; and &lt;code&gt;serializer_class&lt;/code&gt; attributes exactly as we did when we were using regular views, but we no longer need to provide the same information to two separate classes.</source>
          <target state="translated">여기서는 &lt;code&gt;ReadOnlyModelViewSet&lt;/code&gt; 클래스를 사용하여 기본 '읽기 전용'작업을 자동으로 제공했습니다. 우리는 여전히 일반 뷰를 사용할 때 와 똑같이 &lt;code&gt;queryset&lt;/code&gt; 및 &lt;code&gt;serializer_class&lt;/code&gt; 속성을 설정하고 있지만 더 이상 두 개의 개별 클래스에 동일한 정보를 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d43be75fd78340ed55323ac39cfd8535a1199d13" translate="yes" xml:space="preserve">
          <source>Here's a basic &lt;code&gt;ModelSerializer&lt;/code&gt; that we can use for creating or updating instances of &lt;code&gt;CustomerReportRecord&lt;/code&gt;:</source>
          <target state="translated">다음 은 &lt;code&gt;CustomerReportRecord&lt;/code&gt; 인스턴스를 작성하거나 업데이트하는 데 사용할 수 있는 기본 &lt;code&gt;ModelSerializer&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="95af128258e44e86c5a766367bc9934d2a29bf9c" translate="yes" xml:space="preserve">
          <source>Here's a complete example of our previous &lt;code&gt;HighScoreSerializer&lt;/code&gt;, that's been updated to support both read and write operations.</source>
          <target state="translated">다음은 이전 &lt;code&gt;HighScoreSerializer&lt;/code&gt; 의 완전한 예입니다.이 예는 읽기 및 쓰기 작업을 모두 지원하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf5f57174631ac6cc9d1043457a672a8fb5a9648" translate="yes" xml:space="preserve">
          <source>Here's an example HTTP request using the accept header versioning style.</source>
          <target state="translated">다음은 accept 헤더 버전 관리 스타일을 사용하는 HTTP 요청의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0379b7882df31f4c946788bf163bd64fd6e26e7d" translate="yes" xml:space="preserve">
          <source>Here's an example for an &lt;code&gt;.update()&lt;/code&gt; method on our previous &lt;code&gt;UserSerializer&lt;/code&gt; class.</source>
          <target state="translated">다음은 이전 &lt;code&gt;UserSerializer&lt;/code&gt; 클래스 의 &lt;code&gt;.update()&lt;/code&gt; 메서드에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bfb605c49985a2cc10eb9992ceb8beabe435d2c6" translate="yes" xml:space="preserve">
          <source>Here's an example of a simple URL conf, that uses &lt;code&gt;SimpleRouter&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;SimpleRouter&lt;/code&gt; 를 사용하는 간단한 URL conf의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="73dfe8288992866f0c84250247c0189e7bb83b1b" translate="yes" xml:space="preserve">
          <source>Here's an example of how you might choose to implement multiple updates:</source>
          <target state="translated">다음은 여러 업데이트를 구현하도록 선택하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="525aa64e1f9c1366eb8a944090c36e82f9809b88" translate="yes" xml:space="preserve">
          <source>Here's an example response that demonstrates the information that is returned by default.</source>
          <target state="translated">다음은 기본적으로 반환되는 정보를 보여주는 응답 예입니다.</target>
        </trans-unit>
        <trans-unit id="0413b69bdca6db6872506c437345028661969376" translate="yes" xml:space="preserve">
          <source>Here's our re-wired &lt;code&gt;snippets/urls.py&lt;/code&gt; file.</source>
          <target state="translated">다시 배선 된 &lt;code&gt;snippets/urls.py&lt;/code&gt; 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cbd7e5b262e108dc01bd7762dc777b9b0a7771" translate="yes" xml:space="preserve">
          <source>HiddenField</source>
          <target state="translated">HiddenField</target>
        </trans-unit>
        <trans-unit id="d8e6fbd48496c9b41a1e0c5d32d1808abd7d541a" translate="yes" xml:space="preserve">
          <source>HostNameVersioning</source>
          <target state="translated">HostNameVersioning</target>
        </trans-unit>
        <trans-unit id="e1e6b24f1e9bd8f18c962ccd9beacce422982b54" translate="yes" xml:space="preserve">
          <source>Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.</source>
          <target state="translated">API 버전마다 다른 DNS 레코드를 구성 할 수 있으므로 수신 요청을 버전에 따라 다른 서버로 라우팅해야하는 경우 호스트 이름 기반 버전 관리가 특히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ba7e5bffbfb2db6b5c7190e576c42cd3c715b5" translate="yes" xml:space="preserve">
          <source>How authentication is determined</source>
          <target state="translated">인증 결정 방법</target>
        </trans-unit>
        <trans-unit id="4cd4a95299370d3cc669411bfd8bf0719647f0fa" translate="yes" xml:space="preserve">
          <source>How clients are identified</source>
          <target state="translated">고객을 식별하는 방법</target>
        </trans-unit>
        <trans-unit id="45ed251ac5463fa95da511c3f1c83585409ace31" translate="yes" xml:space="preserve">
          <source>How do you determine which instance should be updated for each item in the list of data?</source>
          <target state="translated">데이터 목록에서 각 항목에 대해 업데이트 할 인스턴스를 어떻게 결정합니까?</target>
        </trans-unit>
        <trans-unit id="54cfbdef5afd8575a913fb1bfde8294696fa4210" translate="yes" xml:space="preserve">
          <source>How hyperlinked views are determined</source>
          <target state="translated">하이퍼 링크 된 뷰가 결정되는 방법</target>
        </trans-unit>
        <trans-unit id="0cf8b77b026537f3af664093b626cf3f840d1fd9" translate="yes" xml:space="preserve">
          <source>How permissions are determined</source>
          <target state="translated">권한 결정 방법</target>
        </trans-unit>
        <trans-unit id="459b6f987ba6207373dee5779a78c550c76555a9" translate="yes" xml:space="preserve">
          <source>How should insertions be handled? Are they invalid, or do they create new objects?</source>
          <target state="translated">삽입은 어떻게 처리해야합니까? 그것들이 유효하지 않습니까, 아니면 새로운 객체를 생성합니까?</target>
        </trans-unit>
        <trans-unit id="4606665fe76a471c8ca9b99aa69363b80c78a657" translate="yes" xml:space="preserve">
          <source>How should ordering be handled? Does changing the position of two items imply any state change or is it ignored?</source>
          <target state="translated">주문은 어떻게 처리해야합니까? 두 항목의 위치를 ​​변경하면 상태가 변경되거나 무시됩니까?</target>
        </trans-unit>
        <trans-unit id="a8a38153aa0dd696e49b4b82cc33bac57ec804f0" translate="yes" xml:space="preserve">
          <source>How should removals be handled? Do they imply object deletion, or removing a relationship? Should they be silently ignored, or are they invalid?</source>
          <target state="translated">제거는 어떻게 처리해야합니까? 그것들은 객체 삭제 또는 관계 제거를 의미합니까? 자동으로 무시해야합니까, 아니면 유효하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="49c2584f45d5d1d7981b085b45eb8c75c04c4499" translate="yes" xml:space="preserve">
          <source>How the parser is determined</source>
          <target state="translated">파서가 결정되는 방법</target>
        </trans-unit>
        <trans-unit id="604c72a8a43b08a758f6cbb4ea0037acafac778c" translate="yes" xml:space="preserve">
          <source>How the renderer is determined</source>
          <target state="translated">렌더러가 결정되는 방법</target>
        </trans-unit>
        <trans-unit id="096325cc624cf757929dde89ae7cc58861a7fc87" translate="yes" xml:space="preserve">
          <source>How throttling is determined</source>
          <target state="translated">조절 결정 방법</target>
        </trans-unit>
        <trans-unit id="e8562ee34c66675e21d1c6f7679f5037c260ddb9" translate="yes" xml:space="preserve">
          <source>How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:</source>
          <target state="translated">API 동작을 다양하게 변경하는 방법은 사용자에게 달려 있지만 일반적으로 원하는 예는 최신 버전에서 다른 직렬화 스타일로 전환하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="995d1b21dbe6553976ba253abaa1d73ef33758ca" translate="yes" xml:space="preserve">
          <source>How's it looking?</source>
          <target state="translated">어때요?</target>
        </trans-unit>
        <trans-unit id="1356325c14b709bbd99baea5454b8ef107f30355" translate="yes" xml:space="preserve">
          <source>However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.</source>
          <target state="translated">그러나 때로는 유효성 검사 논리를 재사용 가능한 구성 요소에 배치하여 코드베이스 전체에서 쉽게 재사용 할 수 있습니다. 이는 유효성 검증기 함수 및 유효성 검증기 클래스를 사용하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8f111c94ad24c1d77d73aef275e190e37c07769" translate="yes" xml:space="preserve">
          <source>However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won&amp;rsquo;t prevent the &lt;code&gt;ModelSerializer&lt;/code&gt; from generating a default field. To opt-out from default fields, see &lt;a href=&quot;#specifying-which-fields-to-include&quot;&gt;Specifying which fields to include&lt;/a&gt;.</source>
          <target state="translated">그러나이 기술 만 사용하여 부모 클래스에 의해 선언적으로 정의 된 필드를 옵트 아웃 할 수 있습니다. &lt;code&gt;ModelSerializer&lt;/code&gt; 가 기본 필드를 생성하는 것을 막지 않습니다 . 기본 필드에서 옵트 아웃하려면 &lt;a href=&quot;#specifying-which-fields-to-include&quot;&gt;포함 할 필드 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="019d51ae85b203b4599be4e3d85bac0a7ca10e2d" translate="yes" xml:space="preserve">
          <source>HyperlinkedIdentityField</source>
          <target state="translated">HyperlinkedIdentityField</target>
        </trans-unit>
        <trans-unit id="53d0d9cb9a3659cc02a736749cca291162869768" translate="yes" xml:space="preserve">
          <source>HyperlinkedModelSerializer</source>
          <target state="translated">HyperlinkedModelSerializer</target>
        </trans-unit>
        <trans-unit id="af77b9252508bae5e4a42e92f4a96a8002bbab25" translate="yes" xml:space="preserve">
          <source>HyperlinkedRelatedField</source>
          <target state="translated">HyperlinkedRelatedField</target>
        </trans-unit>
        <trans-unit id="d3b51daf70e4372fea56eb63ccab1d9af0eb9b19" translate="yes" xml:space="preserve">
          <source>Hyperlinking our API</source>
          <target state="translated">API 하이퍼 링크</target>
        </trans-unit>
        <trans-unit id="a8d61d3792e3e1ee82dd8dec736ba9d83e830bf3" translate="yes" xml:space="preserve">
          <source>IPAddressField</source>
          <target state="translated">IPAddressField</target>
        </trans-unit>
        <trans-unit id="ebf5477be1d5a66c6f882b98ebe1772b44e44c67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NamespaceVersioning&lt;/code&gt; was being used, and the API version was 'v1', then the URL lookup used would be &lt;code&gt;'v1:bookings-list'&lt;/code&gt;, which might resolve to a URL like &lt;code&gt;http://example.org/v1/bookings/&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;NamespaceVersioning&lt;/code&gt; 가 사용되었고, API 버전 'V1'이고, 조회 될 사용 후 URL은 &lt;code&gt;'v1:bookings-list'&lt;/code&gt; , 같은 URL에 해결할 수있는 &lt;code&gt;http://example.org/v1/bookings/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbd3169215b5755912a5239ad0a14499c0913bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QueryParameterVersioning&lt;/code&gt; was being used, and the API version was &lt;code&gt;1.0&lt;/code&gt;, then the returned URL might be something like &lt;code&gt;http://example.org/bookings/?version=1.0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;QueryParameterVersioning&lt;/code&gt; 가 사용되었고, API 버전이었다 &lt;code&gt;1.0&lt;/code&gt; , 다음은 URL이 같은 수 있습니다 반환 &lt;code&gt;http://example.org/bookings/?version=1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="151172500eedb4999d5e10c3ce45e86a4919d89a" translate="yes" xml:space="preserve">
          <source>If a client sends a request with a content-type that cannot be parsed then a &lt;code&gt;UnsupportedMediaType&lt;/code&gt; exception will be raised, which by default will be caught and return a &lt;code&gt;415 Unsupported Media Type&lt;/code&gt; response.</source>
          <target state="translated">클라이언트가 구문 분석 할 수없는 컨텐츠 유형으로 요청을 보내면 &lt;code&gt;UnsupportedMediaType&lt;/code&gt; 예외가 발생하며,이 예외는 기본적으로 잡히고 &lt;code&gt;415 Unsupported Media Type&lt;/code&gt; 응답을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="32a2e23a0fb4bc4d68c4fb7bb3c0d6eda8e2272e" translate="yes" xml:space="preserve">
          <source>If a nested representation may optionally accept the &lt;code&gt;None&lt;/code&gt; value you should pass the &lt;code&gt;required=False&lt;/code&gt; flag to the nested serializer.</source>
          <target state="translated">중첩 표현이 선택적으로 &lt;code&gt;None&lt;/code&gt; 값을 허용 할 경우 &lt;code&gt;required=False&lt;/code&gt; 플래그를 중첩 된 직렬 변환기에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c1624c9270285b4008aabd3df0832432ff79781" translate="yes" xml:space="preserve">
          <source>If all you need is simple equality-based filtering, you can set a &lt;code&gt;filterset_fields&lt;/code&gt; attribute on the view, or viewset, listing the set of fields you wish to filter against.</source>
          <target state="translated">단순 동등 기반 필터링 만 있으면 뷰 또는 필터링 할 필드 집합을 나열하는 viewset에서 &lt;code&gt;filterset_fields&lt;/code&gt; 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e35f9c71ba8acb499b1fcb0eb30207a9a75b5630" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ordering&lt;/code&gt; attribute is set on the view, this will be used as the default ordering.</source>
          <target state="translated">경우 &lt;code&gt;ordering&lt;/code&gt; 속성이보기에 설정이 기본 순서로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb5c2a59bbce25ba134c98ab18bb8565a1dded3" translate="yes" xml:space="preserve">
          <source>If an object can be retrieved this returns a &lt;code&gt;200 OK&lt;/code&gt; response, with a serialized representation of the object as the body of the response. Otherwise it will return a &lt;code&gt;404 Not Found&lt;/code&gt;.</source>
          <target state="translated">객체를 검색 할 수있는 경우 객체 의 직렬화 된 표현을 응답 본문으로하여 &lt;code&gt;200 OK&lt;/code&gt; 응답을 반환합니다 . 그렇지 않으면 &lt;code&gt;404 Not Found&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="46b737b46902636aa4fe051496038d62345768be" translate="yes" xml:space="preserve">
          <source>If an object is created this returns a &lt;code&gt;201 Created&lt;/code&gt; response, with a serialized representation of the object as the body of the response. If the representation contains a key named &lt;code&gt;url&lt;/code&gt;, then the &lt;code&gt;Location&lt;/code&gt; header of the response will be populated with that value.</source>
          <target state="translated">객체가 생성되면 객체 의 직렬화 된 표현을 응답 본문으로하여 &lt;code&gt;201 Created&lt;/code&gt; 응답을 반환합니다 . 표시에 &lt;code&gt;url&lt;/code&gt; 이라는 키가 포함되어 있으면 응답 의 &lt;code&gt;Location&lt;/code&gt; 헤더가 해당 값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d4004507afebf41a45cce113a5f539f52018854a" translate="yes" xml:space="preserve">
          <source>If an object is deleted this returns a &lt;code&gt;204 No Content&lt;/code&gt; response, otherwise it will return a &lt;code&gt;404 Not Found&lt;/code&gt;.</source>
          <target state="translated">객체가 삭제되면 &lt;code&gt;204 No Content&lt;/code&gt; 응답을 반환하고, 그렇지 않으면 &lt;code&gt;404 Not Found&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3762d67e46fadd0046cf7922e0498a000de20890" translate="yes" xml:space="preserve">
          <source>If an object is updated this returns a &lt;code&gt;200 OK&lt;/code&gt; response, with a serialized representation of the object as the body of the response.</source>
          <target state="translated">개체가 업데이트되면 개체 의 직렬화 된 표현이 응답 본문으로 &lt;code&gt;200 OK&lt;/code&gt; 응답 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ad1b0f1459e229805a6499a53d26613abb019d9" translate="yes" xml:space="preserve">
          <source>If any of the validation fails, then the method should raise a &lt;code&gt;serializers.ValidationError(errors)&lt;/code&gt;. The &lt;code&gt;errors&lt;/code&gt; argument should be a dictionary mapping field names (or &lt;code&gt;settings.NON_FIELD_ERRORS_KEY&lt;/code&gt;) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the &lt;a href=&quot;#object-level-validation&quot;&gt;&lt;code&gt;.validate()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유효성 검사 중 하나라도 실패하면 메서드는 &lt;code&gt;serializers.ValidationError(errors)&lt;/code&gt; 시켜야합니다 . &lt;code&gt;errors&lt;/code&gt; 인수는 사전 매핑 필드 이름 (또는해야 &lt;code&gt;settings.NON_FIELD_ERRORS_KEY&lt;/code&gt; 오류 메시지 목록에). 역 직렬화 동작을 변경할 필요가없고 대신 오브젝트 레벨 유효성 검증을 제공하려는 경우 대신 &lt;a href=&quot;#object-level-validation&quot;&gt; &lt;code&gt;.validate()&lt;/code&gt; &lt;/a&gt; 메소드 를 대체하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e5c82ce334ad23ff527e64cd77f8d563dbdfd972" translate="yes" xml:space="preserve">
          <source>If authentication is attempted but fails, raise a &lt;code&gt;AuthenticationFailed&lt;/code&gt; exception. An error response will be returned immediately, regardless of any permissions checks, and without checking any other authentication schemes.</source>
          <target state="translated">인증을 시도했지만 실패하면 &lt;code&gt;AuthenticationFailed&lt;/code&gt; 예외가 발생합니다. 권한 확인에 관계없이 다른 인증 체계를 확인하지 않고 오류 응답이 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a28664c171ee61d2af627fc8e33e900518233b4" translate="yes" xml:space="preserve">
          <source>If authentication is not attempted, return &lt;code&gt;None&lt;/code&gt;. Any other authentication schemes also in use will still be checked.</source>
          <target state="translated">인증을 시도하지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 사용중인 다른 인증 체계도 계속 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="4d535c232b6130ee795f2d337922b2765b29a1be" translate="yes" xml:space="preserve">
          <source>If it is called without a &lt;code&gt;filename&lt;/code&gt; URL keyword argument, then the client must set the filename in the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP header. For example &lt;code&gt;Content-Disposition: attachment; filename=upload.jpg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; URL 키워드 인수 없이 호출 된 경우 클라이언트는 &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP 헤더 에서 파일 이름을 설정해야합니다 . 예를 들어 &lt;code&gt;Content-Disposition: attachment; filename=upload.jpg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="781ec054e7600192b9cfeff809352220ed8070be" translate="yes" xml:space="preserve">
          <source>If multiple media types have the same specificity, then preference is given to based on the ordering of the renderers configured for the given view.</source>
          <target state="translated">여러 미디어 유형이 동일한 고유성을 갖는 경우, 주어진 뷰에 대해 구성된 렌더러의 순서에 따라 선호도가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="c71d2022ba5a59c33bf2edb2d41d3ff0254f5769" translate="yes" xml:space="preserve">
          <source>If no class authenticates, &lt;code&gt;request.user&lt;/code&gt; will be set to an instance of &lt;code&gt;django.contrib.auth.models.AnonymousUser&lt;/code&gt;, and &lt;code&gt;request.auth&lt;/code&gt; will be set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">클래스가 인증되지 않으면 &lt;code&gt;request.user&lt;/code&gt; 는 &lt;code&gt;django.contrib.auth.models.AnonymousUser&lt;/code&gt; 의 인스턴스 로 설정 되고 &lt;code&gt;request.auth&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fc335a7d334f1ce9ac5fa81ad06984d5bdc90b3" translate="yes" xml:space="preserve">
          <source>If not specified, the &lt;code&gt;'EXCEPTION_HANDLER'&lt;/code&gt; setting defaults to the standard exception handler provided by REST framework:</source>
          <target state="translated">지정되지 않은 경우 &lt;code&gt;'EXCEPTION_HANDLER'&lt;/code&gt; 설정은 기본적으로 REST 프레임 워크에서 제공하는 표준 예외 핸들러로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8405c9f786a3a19079509256af88db8fb4d039cc" translate="yes" xml:space="preserve">
          <source>If not specified, this setting defaults to allowing unrestricted access:</source>
          <target state="translated">지정하지 않으면이 설정은 기본적으로 무제한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b755c9a26acc59abf062c580cfcf382c4dfd47db" translate="yes" xml:space="preserve">
          <source>If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.</source>
          <target state="translated">설정하면 입력 값이 제공되지 않은 경우 필드에 사용될 기본값이 제공됩니다. 설정하지 않으면 기본 동작은 속성을 전혀 채우지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80d32608b1eb6ccdc1307e98ee1cc0c3f1b4ce26" translate="yes" xml:space="preserve">
          <source>If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.</source>
          <target state="translated">설정된 경우 이는 내부 뷰 세트 메소드 이름을 스키마 생성에 사용 된 외부 조치 이름에 맵핑하는 데 사용됩니다. 이를 통해 코드베이스에서 내부적으로 사용되는 이름보다 외부 표현에 더 적합한 이름을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98ca408c0aec431a544d88204cd8d11d300b56c" translate="yes" xml:space="preserve">
          <source>If set, this maps the &lt;code&gt;'pk'&lt;/code&gt; identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be &lt;code&gt;'id'&lt;/code&gt;. This gives a more suitable representation as &quot;primary key&quot; is an implementation detail, whereas &quot;identifier&quot; is a more general concept.</source>
          <target state="translated">설정된 경우 스키마 경로 매개 변수를 생성 할 때 URL conf 의 &lt;code&gt;'pk'&lt;/code&gt; 식별자를 실제 필드 이름에 매핑합니다 . 일반적으로 이것은 &lt;code&gt;'id'&lt;/code&gt; 입니다. 이는 &quot;기본 키&quot;가 구현 세부 사항 인 반면 &quot;식별자&quot;가보다 일반적인 개념이므로보다 적합한 표현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2004d81ff4f7d93f1efefd10b7bc90533e95e43a" translate="yes" xml:space="preserve">
          <source>If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.</source>
          <target state="translated">설정된 경우,이 값은 버전 관리 체계에서 리턴 할 수있는 버전 세트를 제한하고이 세트에없는 경우 제공된 버전 인 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="724bf32cda9301a3160923eacc1bdafdd94e8514" translate="yes" xml:space="preserve">
          <source>If successfully authenticated, &lt;code&gt;BasicAuthentication&lt;/code&gt; provides the following credentials.</source>
          <target state="translated">성공적으로 인증되면 &lt;code&gt;BasicAuthentication&lt;/code&gt; 은 다음 자격 증명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0170680e0546d0539f86b3af67111e04db9cf116" translate="yes" xml:space="preserve">
          <source>If successfully authenticated, &lt;code&gt;RemoteUserAuthentication&lt;/code&gt; provides the following credentials:</source>
          <target state="translated">성공적으로 인증되면 &lt;code&gt;RemoteUserAuthentication&lt;/code&gt; 은 다음 자격 증명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf5d10a064f9ec41b6b209f8e1f52eea774e4d6f" translate="yes" xml:space="preserve">
          <source>If successfully authenticated, &lt;code&gt;SessionAuthentication&lt;/code&gt; provides the following credentials.</source>
          <target state="translated">성공적으로 인증되면 &lt;code&gt;SessionAuthentication&lt;/code&gt; 은 다음 자격 증명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49dbf4a6450c296e39679277679a03550952acc3" translate="yes" xml:space="preserve">
          <source>If successfully authenticated, &lt;code&gt;TokenAuthentication&lt;/code&gt; provides the following credentials.</source>
          <target state="translated">성공적으로 인증되면 &lt;code&gt;TokenAuthentication&lt;/code&gt; 은 다음 자격 증명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17139f567b09df009291ee42ef10e85da42a231e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;.authenticate_header()&lt;/code&gt; method is not overridden, the authentication scheme will return &lt;code&gt;HTTP 403 Forbidden&lt;/code&gt; responses when an unauthenticated request is denied access.</source>
          <target state="translated">는 IF &lt;code&gt;.authenticate_header()&lt;/code&gt; 메소드가 오버라이드 (override)되지 않는, 인증 방식은 반환됩니다 &lt;code&gt;HTTP 403 Forbidden&lt;/code&gt; 인증되지 않은 요청이 액세스가 거부 될 때 응답을.</target>
        </trans-unit>
        <trans-unit id="bc08ff2b1a93412af113ed304cb1737ae38a519a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;.wait()&lt;/code&gt; method is implemented and the request is throttled, then a &lt;code&gt;Retry-After&lt;/code&gt; header will be included in the response.</source>
          <target state="translated">경우] &lt;code&gt;.wait()&lt;/code&gt; 메소드를 구현하고 요구가 스로틀 링되고, 다음 &lt;code&gt;Retry-After&lt;/code&gt; 헤더는 응답에 포함된다.</target>
        </trans-unit>
        <trans-unit id="50c8928fbcfcaa52031b198595e75fbbfd933f9d" translate="yes" xml:space="preserve">
          <source>If the field is used to represent a to-many relationship, you should add the &lt;code&gt;many=True&lt;/code&gt; flag to the serializer field.</source>
          <target state="translated">필드가 다 대 관계를 나타내는 데 사용되는 경우 serializer 필드에 &lt;code&gt;many=True&lt;/code&gt; 플래그를 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7759860d1ecdbed30a700fb38ace7ab253cbf247" translate="yes" xml:space="preserve">
          <source>If the generic views don't suit the needs of your API, you can drop down to using the regular &lt;code&gt;APIView&lt;/code&gt; class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.</source>
          <target state="translated">일반 뷰가 API 요구에 적합하지 않은 경우 일반 &lt;code&gt;APIView&lt;/code&gt; 클래스 사용으로 드롭 다운 하거나 일반 뷰에서 사용하는 믹스 인 및 기본 클래스를 재사용하여 고유 한 재사용 가능한 일반 뷰 세트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a390df3edd1db405d9691f8496c1e1a64c0cee6" translate="yes" xml:space="preserve">
          <source>If the queryset is populated, this returns a &lt;code&gt;200 OK&lt;/code&gt; response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.</source>
          <target state="translated">쿼리 세트가 채워지면, 응답의 본문으로 쿼리 세트의 직렬화 된 표현과 함께 &lt;code&gt;200 OK&lt;/code&gt; 응답을 리턴합니다 . 응답 데이터는 선택적으로 페이지 매김 될 수있다.</target>
        </trans-unit>
        <trans-unit id="e292621ee644e0903e045531be5e6962b6d3c78f" translate="yes" xml:space="preserve">
          <source>If the renderer returns a bytestring representing raw binary content, you should set a charset value of &lt;code&gt;None&lt;/code&gt;, which will ensure the &lt;code&gt;Content-Type&lt;/code&gt; header of the response will not have a &lt;code&gt;charset&lt;/code&gt; value set.</source>
          <target state="translated">렌더러가 원시 이진 컨텐츠를 나타내는 바이트 문자열을 리턴하는 경우 응답 의 &lt;code&gt;Content-Type&lt;/code&gt; 헤더에 &lt;code&gt;charset&lt;/code&gt; 값이 설정 되지 않도록 문자 세트 값을 &lt;code&gt;None&lt;/code&gt; 으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="11175bd26ae9a043216a2def09454a4454a14db1" translate="yes" xml:space="preserve">
          <source>If the request data provided for creating the object was invalid, a &lt;code&gt;400 Bad Request&lt;/code&gt; response will be returned, with the error details as the body of the response.</source>
          <target state="translated">오브젝트 작성을 위해 제공된 요청 데이터가 유효하지 않은 경우 &lt;code&gt;400 Bad Request&lt;/code&gt; 본문 요청 응답이 리턴되며 오류 세부 사항은 응답 본문으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="af1836c7a58e439d70edb0376218e6272e45c923" translate="yes" xml:space="preserve">
          <source>If the request data provided for updating the object was invalid, a &lt;code&gt;400 Bad Request&lt;/code&gt; response will be returned, with the error details as the body of the response.</source>
          <target state="translated">오브젝트 업데이트를 위해 제공된 요청 데이터가 유효하지 않은 경우 &lt;code&gt;400 Bad Request&lt;/code&gt; 본문 요청 응답이 리턴되며 오류 세부 사항은 응답 본문입니다.</target>
        </trans-unit>
        <trans-unit id="8b70a2f697203161fe8fbb7adf2e08d541d96ff0" translate="yes" xml:space="preserve">
          <source>If the request is unauthenticated the default value of &lt;code&gt;request.user&lt;/code&gt; is an instance of &lt;code&gt;django.contrib.auth.models.AnonymousUser&lt;/code&gt;.</source>
          <target state="translated">요청이 인증되지 않은 경우 &lt;code&gt;request.user&lt;/code&gt; 의 기본값 은 &lt;code&gt;django.contrib.auth.models.AnonymousUser&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="0be00917a7cb212517b09975ac295c110e893649" translate="yes" xml:space="preserve">
          <source>If the request is unauthenticated, or if no additional context is present, the default value of &lt;code&gt;request.auth&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">요청이 인증되지 않았거나 추가 컨텍스트가없는 경우 &lt;code&gt;request.auth&lt;/code&gt; 의 기본값 은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f64cd8c8685e54a353a93546485db83d3367708b" translate="yes" xml:space="preserve">
          <source>If the requested view was only configured with renderers for &lt;code&gt;YAML&lt;/code&gt; and &lt;code&gt;HTML&lt;/code&gt;, then REST framework would select whichever renderer was listed first in the &lt;code&gt;renderer_classes&lt;/code&gt; list or &lt;code&gt;DEFAULT_RENDERER_CLASSES&lt;/code&gt; setting.</source>
          <target state="translated">요청 된 뷰가 &lt;code&gt;YAML&lt;/code&gt; 및 &lt;code&gt;HTML&lt;/code&gt; 에 대한 렌더러로만 구성된 경우 REST 프레임 워크는 &lt;code&gt;renderer_classes&lt;/code&gt; 목록 또는 &lt;code&gt;DEFAULT_RENDERER_CLASSES&lt;/code&gt; 설정 에서 가장 먼저 나열된 렌더러를 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="7828acbe527a2daaaa383c73e0725fd540fcfed8" translate="yes" xml:space="preserve">
          <source>If the value of this setting is &lt;code&gt;None&lt;/code&gt; then URL format overrides will be disabled.</source>
          <target state="translated">이 설정의 값이 &lt;code&gt;None&lt;/code&gt; 이면 URL 형식 무시가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="29eefd2c7a9ecdb3b0e2f8e66213de676a4f65d0" translate="yes" xml:space="preserve">
          <source>If the view instance inherits &lt;code&gt;ViewSet&lt;/code&gt;, it may have been initialized with several optional arguments:</source>
          <target state="translated">뷰 인스턴스가 &lt;code&gt;ViewSet&lt;/code&gt; 을 상속 하면 몇 가지 선택적 인수로 초기화되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f937af6308b40651e6c57fa89817f4705a2f4fa" translate="yes" xml:space="preserve">
          <source>If the view used with &lt;code&gt;FileUploadParser&lt;/code&gt; is called with a &lt;code&gt;filename&lt;/code&gt; URL keyword argument, then that argument will be used as the filename.</source>
          <target state="translated">&lt;code&gt;FileUploadParser&lt;/code&gt; 와 함께 사용 된보기 가 &lt;code&gt;filename&lt;/code&gt; URL 키워드 인수 와 함께 호출 되면 해당 인수가 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee07002daf78889d0b9379951b4873cfb2854595" translate="yes" xml:space="preserve">
          <source>If unset, this will default to the same value as the &lt;code&gt;COERCE_DECIMAL_TO_STRING&lt;/code&gt; setting, which is &lt;code&gt;True&lt;/code&gt; unless set otherwise.</source>
          <target state="translated">설정 하지 않으면 &lt;code&gt;COERCE_DECIMAL_TO_STRING&lt;/code&gt; 설정 과 동일한 값으로 기본 설정되며, 달리 설정하지 않으면 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="badf43f5f71dea780d1bb47e31ecaa97c8ca9abe" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;i18n_patterns&lt;/code&gt; function provided by Django, as well as &lt;code&gt;format_suffix_patterns&lt;/code&gt; you should make sure that the &lt;code&gt;i18n_patterns&lt;/code&gt; function is applied as the final, or outermost function. For example:</source>
          <target state="translated">Django에서 제공 하는 &lt;code&gt;i18n_patterns&lt;/code&gt; 함수와 &lt;code&gt;format_suffix_patterns&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;i18n_patterns&lt;/code&gt; 함수가 최종 또는 가장 바깥 쪽 함수로 적용 되어야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b6cedcdac1cfd4ddeabf31e95fe63c505f7d667" translate="yes" xml:space="preserve">
          <source>If we need to, we can bind this viewset into two separate views, like so:</source>
          <target state="translated">필요한 경우이 뷰셋을 두 개의 개별 뷰에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b3c78ca47e0ba56208fac890d659cc9ed61fd0" translate="yes" xml:space="preserve">
          <source>If we open a browser and navigate to the browsable API, you'll find that you can now work your way around the API simply by following links.</source>
          <target state="translated">브라우저를 열고 탐색 가능한 API로 이동하면 링크를 따라 가면 API를 둘러 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61c2a3708942fdbbc6b25876bd9d06fb61811500" translate="yes" xml:space="preserve">
          <source>If we open up the Django shell using &lt;code&gt;manage.py shell&lt;/code&gt; we can now</source>
          <target state="translated">&lt;code&gt;manage.py shell&lt;/code&gt; 을 사용하여 Django 셸을 열면</target>
        </trans-unit>
        <trans-unit id="b74a96c879ee71b3ee740607aee4469f9733da9a" translate="yes" xml:space="preserve">
          <source>If we try to create a snippet without authenticating, we'll get an error:</source>
          <target state="translated">인증하지 않고 스 니펫을 만들려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="937f280cd3aacfd7745f966a57969312a469165d" translate="yes" xml:space="preserve">
          <source>If we want to be able to return complete object instances based on the validated data we need to implement one or both of the &lt;code&gt;.create()&lt;/code&gt; and &lt;code&gt;.update()&lt;/code&gt; methods. For example:</source>
          <target state="translated">검증 된 데이터를 기반으로 완전한 객체 인스턴스를 반환하려면 &lt;code&gt;.create()&lt;/code&gt; 및 &lt;code&gt;.update()&lt;/code&gt; 메소드 중 하나 또는 둘 다를 구현해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e537c32e3ab92c29be0f57acf967f3a934e3876" translate="yes" xml:space="preserve">
          <source>If we're going to have a hyperlinked API, we need to make sure we name our URL patterns. Let's take a look at which URL patterns we need to name.</source>
          <target state="translated">하이퍼 링크 된 API를 사용하려면 URL 패턴의 이름을 지정해야합니다. 이름을 지정해야하는 URL 패턴을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7e06e5a02932703202751967e9d4078cc056cf34" translate="yes" xml:space="preserve">
          <source>If we're interacting with the API programmatically we need to explicitly provide the authentication credentials on each request.</source>
          <target state="translated">프로그래밍 방식으로 API와 상호 작용하는 경우 각 요청에 대해 인증 자격 증명을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8cb2b3310c00368f07b3a88b1015101916ddc02" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; want to use relative URLs, you should explicitly pass &lt;code&gt;{'request': None}&lt;/code&gt; in the serializer context.</source>
          <target state="translated">당신이 경우 &lt;em&gt;않는&lt;/em&gt; 상대 URL을 사용하려면, 당신은 명시 적으로 전달해야합니다 &lt;code&gt;{'request': None}&lt;/code&gt; 시리얼 라이저 문맥을.</target>
        </trans-unit>
        <trans-unit id="ceeeb6b592a3860b3f47b57e1dee4577cbb88040" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't&lt;/em&gt; specify an &lt;code&gt;ordering_fields&lt;/code&gt; attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the &lt;code&gt;serializer_class&lt;/code&gt; attribute.</source>
          <target state="translated">당신이 경우 &lt;em&gt;하지 않습니다&lt;/em&gt; 지정 &lt;code&gt;ordering_fields&lt;/code&gt; 의 뷰에 속성을 필터 클래스로 지정된 시리얼에 어떤 읽을 수 필드에 필터에 사용자 수를 기본값으로 &lt;code&gt;serializer_class&lt;/code&gt; 의 속성을.</target>
        </trans-unit>
        <trans-unit id="9b1f9482e8a9363c06038f743d59129c62e8c4ed" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;--debug&lt;/code&gt; switch to the &lt;code&gt;http&lt;/code&gt; requests above, you will be able to see the request type in request headers.</source>
          <target state="translated">위 의 &lt;code&gt;http&lt;/code&gt; 요청에 &lt;code&gt;--debug&lt;/code&gt; 스위치를 추가하면 요청 헤더에서 요청 유형을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29d5c6bce4346ea32c03e44134b0ab11d511fe53" translate="yes" xml:space="preserve">
          <source>If you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on &lt;em&gt;any&lt;/em&gt; model field or queryset aggregate, by using the special value &lt;code&gt;'__all__'&lt;/code&gt;.</source>
          <target state="translated">의 검색어가 중요한 데이터를 포함하지 않는 뷰에서 사용하고 있다는 확신이 있다면, 당신은 또한 명시 적으로보기에 순서를 허용하도록 지정할 수 &lt;em&gt;있는&lt;/em&gt; 특수 값 사용하여 모델 필드 또는의 검색어 집계 &lt;code&gt;'__all__'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46e4cbea69fbbd9653b41057fcbc950cc577955b" translate="yes" xml:space="preserve">
          <source>If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the &lt;code&gt;WSGIPassAuthorization&lt;/code&gt; directive in the appropriate context and setting it to &lt;code&gt;'On'&lt;/code&gt;.</source>
          <target state="translated">Apache에 배치하고 세션 기반이 아닌 인증을 사용하는 경우 필요한 헤더를 애플리케이션으로 전달하도록 mod_wsgi를 명시 적으로 구성해야합니다. 적절한 컨텍스트에서 &lt;code&gt;WSGIPassAuthorization&lt;/code&gt; 지시문 을 지정하고 &lt;code&gt;'On'&lt;/code&gt; 으로 설정하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f22915475458b11688422e3108e08965f06506fd" translate="yes" xml:space="preserve">
          <source>If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:</source>
          <target state="translated">여러보기에서 믹스 인을 사용하는 경우이 단계를 한 단계 더 진행하여 프로젝트 전체에서 사용할 수있는 고유 한 기본보기 세트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73d48a6c53043250f1cb0af6a7c313155f814d6f" translate="yes" xml:space="preserve">
          <source>If you believe you&amp;rsquo;ve found something in Django REST framework which has security implications, please &lt;strong&gt;do not raise the issue in a public forum&lt;/strong&gt;.</source>
          <target state="translated">보안과 관련이있는 Django REST 프레임 워크에서 무언가를 발견했다고 생각되면 &lt;strong&gt;공개 포럼에서 문제를 제기하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="09432f3348bbcdce78721c9395ae83b2b1fe6de1" translate="yes" xml:space="preserve">
          <source>If you do need to access the content type of the request you should use the &lt;code&gt;.content_type&lt;/code&gt; property in preference to using &lt;code&gt;request.META.get('HTTP_CONTENT_TYPE')&lt;/code&gt;, as it provides transparent support for browser-based non-form content.</source>
          <target state="translated">요청의 컨텐츠 유형에 액세스해야하는 경우 브라우저 기반 비 형식 컨텐츠에 대한 투명한 지원을 제공하므로 &lt;code&gt;request.META.get('HTTP_CONTENT_TYPE')&lt;/code&gt; 사용에 우선 하여 &lt;code&gt;.content_type&lt;/code&gt; 특성을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="330758aebd8e0cc4645be7e7b82dfbcd3cd16258" translate="yes" xml:space="preserve">
          <source>If you don't set the content type, most clients will default to using &lt;code&gt;'application/x-www-form-urlencoded'&lt;/code&gt;, which may not be what you wanted.</source>
          <target state="translated">컨텐츠 유형을 설정하지 않으면 대부분의 클라이언트는 기본적으로 &lt;code&gt;'application/x-www-form-urlencoded'&lt;/code&gt; 를 사용하도록 설정하는데, 이는 원하지 않는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="443d4714f16470b2d6bde33f0df55ef74b2e580a" translate="yes" xml:space="preserve">
          <source>If you explicitly specify a relational field pointing to a &lt;code&gt;ManyToManyField&lt;/code&gt; with a through model, be sure to set &lt;code&gt;read_only&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">스루 모델 로 &lt;code&gt;ManyToManyField&lt;/code&gt; 를 가리키는 관계형 필드를 명시 적으로 지정하는 경우 &lt;code&gt;read_only&lt;/code&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db160806cbb4e89c6fa2ab08eecd5e21b65914d0" translate="yes" xml:space="preserve">
          <source>If you have ad-hoc methods that should be routable, you can mark them as such with the &lt;code&gt;@action&lt;/code&gt; decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the &lt;code&gt;detail&lt;/code&gt; argument to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. The router will configure its URL patterns accordingly. e.g., the &lt;code&gt;DefaultRouter&lt;/code&gt; will configure detail actions to contain &lt;code&gt;pk&lt;/code&gt; in their URL patterns.</source>
          <target state="translated">라우팅 가능한 임시 메소드가있는 경우 &lt;code&gt;@action&lt;/code&gt; 데코레이터를 사용하여 표시 할 수 있습니다 . 일반 작업과 마찬가지로 단일 개체 또는 전체 컬렉션에 대해 추가 작업을 수행 할 수 있습니다. 이를 나타내려면 &lt;code&gt;detail&lt;/code&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 로 설정하십시오 . 라우터는 그에 따라 URL 패턴을 구성합니다. 예를 들어 &lt;code&gt;DefaultRouter&lt;/code&gt; 는 URL 패턴에 &lt;code&gt;pk&lt;/code&gt; 를 포함하도록 세부 조치를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="0009991cbfacf0193e20e01780170981348df506" translate="yes" xml:space="preserve">
          <source>If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the &lt;code&gt;fields&lt;/code&gt; argument. For example:</source>
          <target state="translated">역관계에 관련 이름을 설정하지 않은 경우 &lt;code&gt;fields&lt;/code&gt; 인수 에 자동으로 생성 된 관련 이름을 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2778f0e3e06aa8f5df991405a30428ab69ec3a18" translate="yes" xml:space="preserve">
          <source>If you have specific requirements for creating schema endpoints that are accessed with regular &lt;code&gt;GET&lt;/code&gt; requests, you might consider re-using the metadata API for doing so.</source>
          <target state="translated">일반 &lt;code&gt;GET&lt;/code&gt; 요청으로 액세스되는 스키마 엔드 포인트를 작성하기위한 특정 요구 사항이있는 경우 메타 데이터 API를 재사용하여 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f2165129b3d9850ddc9adb78b17b0f49ba5623" translate="yes" xml:space="preserve">
          <source>If you need a customized version of the &lt;code&gt;obtain_auth_token&lt;/code&gt; view, you can do so by subclassing the &lt;code&gt;ObtainAuthToken&lt;/code&gt; view class, and using that in your url conf instead.</source>
          <target state="translated">사용자 정의 된 버전의 &lt;code&gt;obtain_auth_token&lt;/code&gt; 뷰 가 필요한 경우 , &lt;code&gt;ObtainAuthToken&lt;/code&gt; 뷰 클래스 를 서브 클래 싱하고 대신 URL conf에서이를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="24a9f83459d63eb9cbe62ad1a2666d7b6a15572c" translate="yes" xml:space="preserve">
          <source>If you need the target of the relationship to have a nested representation, you can use the required serializers inside the &lt;code&gt;.to_representation()&lt;/code&gt; method:</source>
          <target state="translated">관계의 대상에 중첩 표현이 필요하면 &lt;code&gt;.to_representation()&lt;/code&gt; 메서드 내에서 필요한 serializer를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33469cc6d47562b36e75dd49e810ab01644d3af9" translate="yes" xml:space="preserve">
          <source>If you need to access the values of REST framework's API settings in your project, you should use the &lt;code&gt;api_settings&lt;/code&gt; object. For example.</source>
          <target state="translated">프로젝트에서 REST 프레임 워크의 API 설정 값에 액세스해야하는 경우 &lt;code&gt;api_settings&lt;/code&gt; 오브젝트를 사용해야 합니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="ce685b5177b93ce39ff6abea3c58c0e18d54959c" translate="yes" xml:space="preserve">
          <source>If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the &lt;code&gt;.to_representation()&lt;/code&gt; or &lt;code&gt;.to_internal_value()&lt;/code&gt; methods.</source>
          <target state="translated">serializer 클래스의 serialization 또는 deserialization 동작을 변경해야하는 경우 &lt;code&gt;.to_representation()&lt;/code&gt; 또는 &lt;code&gt;.to_internal_value()&lt;/code&gt; 메서드 를 재정의하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="de7b5da8973593d81f6e7bd7dbaf22bc79865bf2" translate="yes" xml:space="preserve">
          <source>If you need to customize the error responses your API returns you should subclass this method.</source>
          <target state="translated">오류 응답을 사용자 정의해야하는 경우 API가이 메소드를 서브 클래스로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3985e207c5ee6e926cff6ef3cb2b21bc3a8d8d42" translate="yes" xml:space="preserve">
          <source>If you need to explicitly encode the request body, you can do so by setting the &lt;code&gt;content_type&lt;/code&gt; flag. For example:</source>
          <target state="translated">요청 본문을 명시 적으로 인코딩해야하는 경우 &lt;code&gt;content_type&lt;/code&gt; 플래그 를 설정하면 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="837c4ba4238c54c8fb61635198a65e70fb8aa769" translate="yes" xml:space="preserve">
          <source>If you need to generic PUT-as-create behavior you may want to include something like &lt;a href=&quot;https://gist.github.com/tomchristie/a2ace4577eff2c603b1b&quot;&gt;this &lt;code&gt;AllowPUTAsCreateMixin&lt;/code&gt; class&lt;/a&gt; as a mixin to your views.</source>
          <target state="translated">당신이해야 할 경우 같은 것을 포함 할 수있다 행동 만들 PUT-로 제네릭 &lt;a href=&quot;https://gist.github.com/tomchristie/a2ace4577eff2c603b1b&quot;&gt;이 &lt;code&gt;AllowPUTAsCreateMixin&lt;/code&gt; 의 클래스&lt;/a&gt; 귀하의 의견에 믹스 인으로한다.</target>
        </trans-unit>
        <trans-unit id="14e8e7d414ae633aad97d181660bf90d38fdaaf1" translate="yes" xml:space="preserve">
          <source>If you need to get the URL of an action, use the &lt;code&gt;.reverse_action()&lt;/code&gt; method. This is a convenience wrapper for &lt;code&gt;reverse()&lt;/code&gt;, automatically passing the view's &lt;code&gt;request&lt;/code&gt; object and prepending the &lt;code&gt;url_name&lt;/code&gt; with the &lt;code&gt;.basename&lt;/code&gt; attribute.</source>
          <target state="translated">조치의 URL을 &lt;code&gt;.reverse_action()&lt;/code&gt; 하는 경우 .reverse_action () 메소드를 사용하십시오 . 이것은 &lt;code&gt;reverse()&lt;/code&gt; 의 편리한 래퍼로 , 뷰의 &lt;code&gt;request&lt;/code&gt; 객체를 자동으로 전달 하고 &lt;code&gt;.basename&lt;/code&gt; 속성으로 &lt;code&gt;url_name&lt;/code&gt; 앞에 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="459afe0a30043b0523f501d9b44136c5a1282ade" translate="yes" xml:space="preserve">
          <source>If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the &lt;code&gt;NUM_PROXIES&lt;/code&gt; setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header, once any application proxy IP addresses have first been excluded. If set to zero, then the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; value will always be used as the identifying IP address.</source>
          <target state="translated">고유 한 클라이언트 IP 주소를 엄격하게 식별해야하는 경우 먼저 &lt;code&gt;NUM_PROXIES&lt;/code&gt; 설정 을 설정하여 API가 실행되는 애플리케이션 프록시 수를 구성해야 합니다. 이 설정은 0 이상의 정수 여야합니다. 0이 아닌 값으로 설정 하면 응용 프로그램 프록시 IP 주소가 먼저 제외 된 후 클라이언트 IP가 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더 에서 마지막 IP 주소로 식별 됩니다. 0으로 설정하면 &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 값이 항상 식별 IP 주소로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7092c266ec8a6da91950acf341cdedfb8805fdb8" translate="yes" xml:space="preserve">
          <source>If you need to test if a request is a read operation or a write operation, you should check the request method against the constant &lt;code&gt;SAFE_METHODS&lt;/code&gt;, which is a tuple containing &lt;code&gt;'GET'&lt;/code&gt;, &lt;code&gt;'OPTIONS'&lt;/code&gt; and &lt;code&gt;'HEAD'&lt;/code&gt;. For example:</source>
          <target state="translated">요청이 읽기 작업인지 쓰기 작업인지 테스트해야하는 경우 &lt;code&gt;SAFE_METHODS&lt;/code&gt; 상수에 대해 요청 방법을 확인해야합니다. 상수 는 &lt;code&gt;'GET'&lt;/code&gt; , &lt;code&gt;'OPTIONS'&lt;/code&gt; 및 &lt;code&gt;'HEAD'&lt;/code&gt; 를 포함하는 튜플 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da011226b1c858c25a2a030362ddf82abf07504b" translate="yes" xml:space="preserve">
          <source>If you need to test requests using something other than multipart or json requests, you can do so by setting the &lt;code&gt;TEST_REQUEST_RENDERER_CLASSES&lt;/code&gt; setting.</source>
          <target state="translated">multipart 또는 json 요청 이외의 다른 것을 사용하여 요청을 테스트해야하는 경우 &lt;code&gt;TEST_REQUEST_RENDERER_CLASSES&lt;/code&gt; 설정 을 설정하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f83bf4aab12d38e667719df975ec9b051ba5ac7" translate="yes" xml:space="preserve">
          <source>If you need to use a cache other than &lt;code&gt;'default'&lt;/code&gt;, you can do so by creating a custom throttle class and setting the &lt;code&gt;cache&lt;/code&gt; attribute. For example:</source>
          <target state="translated">&lt;code&gt;'default'&lt;/code&gt; 이외의 캐시를 사용해야하는 경우 사용자 정의 스로틀 클래스를 작성하고 &lt;code&gt;cache&lt;/code&gt; 속성을 설정하면 됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d722234ee32ff58eae4952f2d2fb710da358631" translate="yes" xml:space="preserve">
          <source>If you only want a subset of the default fields to be used in a model serializer, you can do so using &lt;code&gt;fields&lt;/code&gt; or &lt;code&gt;exclude&lt;/code&gt; options, just as you would with a &lt;code&gt;ModelForm&lt;/code&gt;. It is strongly recommended that you explicitly set all fields that should be serialized using the &lt;code&gt;fields&lt;/code&gt; attribute. This will make it less likely to result in unintentionally exposing data when your models change.</source>
          <target state="translated">모델 시리얼 라이저에서 기본 필드의 하위 집합 만 사용 하려면 &lt;code&gt;ModelForm&lt;/code&gt; 과 마찬가지로 &lt;code&gt;fields&lt;/code&gt; 사용 하거나 옵션을 &lt;code&gt;exclude&lt;/code&gt; 할 수 있습니다 . &lt;code&gt;fields&lt;/code&gt; 속성을 사용하여 직렬화해야하는 모든 필드를 명시 적으로 설정하는 것이 좋습니다 . 이렇게하면 모델이 변경 될 때 의도하지 않은 데이터 노출이 발생할 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="7af2459b09154f2ee940031bb074fe3e42bfc9ac" translate="yes" xml:space="preserve">
          <source>If you open a browser and navigate to the browsable API at the moment, you'll find that you're no longer able to create new code snippets. In order to do so we'd need to be able to login as a user.</source>
          <target state="translated">브라우저를 열고 현재 찾아보기 가능한 API로 이동하면 더 이상 새 코드 스 니펫을 만들 수 없습니다. 그렇게하려면 사용자로 로그인 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ef58e0a6ead2efd033939b9c18cf179b9663eb2" translate="yes" xml:space="preserve">
          <source>If you require a dynamic schema, because foreign key choices depend on database values, for example, you can route a &lt;code&gt;SchemaView&lt;/code&gt; that will generate and serve your schema on demand.</source>
          <target state="translated">예를 들어 외래 키 선택은 데이터베이스 값에 따라 달라 지므로 동적 스키마가 필요한 경우 필요에 따라 스키마를 생성하고 제공 할 &lt;code&gt;SchemaView&lt;/code&gt; 를 라우팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65ba50d5d28a006dcfa2308b4c1218373f266101" translate="yes" xml:space="preserve">
          <source>If you require more complex hyperlinked representation you'll need to customize the field, as described in the &lt;a href=&quot;#custom-hyperlinked-fields&quot;&gt;custom hyperlinked fields&lt;/a&gt; section, below.</source>
          <target state="translated">보다 복잡한 하이퍼 링크 표현이 필요한 경우 아래 의 &lt;a href=&quot;#custom-hyperlinked-fields&quot;&gt;사용자 정의 하이퍼 링크 필드&lt;/a&gt; 섹션에 설명 된대로 필드를 사용자 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f62931f75a212ef99143230cc51ef5223a8140c2" translate="yes" xml:space="preserve">
          <source>If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the &lt;code&gt;content_type&lt;/code&gt; attribute. For example:</source>
          <target state="translated">렌더러의 미디어 유형을 지정하지 않으면 &lt;code&gt;content_type&lt;/code&gt; 속성을 사용하여 응답을 반환 할 때 미디어 유형을 명시 적으로 지정해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d523f4713786d610ed5e517180bc944f2fdb056" translate="yes" xml:space="preserve">
          <source>If you want every user to have an automatically generated Token, you can simply catch the User's &lt;code&gt;post_save&lt;/code&gt; signal.</source>
          <target state="translated">모든 사용자가 자동으로 생성 된 토큰을 갖기를 원하면 사용자의 &lt;code&gt;post_save&lt;/code&gt; 신호를 간단히 잡을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="488cc5b736975a6cf1f5a67ec43e6abb7097c101" translate="yes" xml:space="preserve">
          <source>If you want the date field to be entirely hidden from the user, then use &lt;code&gt;HiddenField&lt;/code&gt;. This field type does not accept user input, but instead always returns its default value to the &lt;code&gt;validated_data&lt;/code&gt; in the serializer.</source>
          <target state="translated">날짜 필드를 사용자로부터 완전히 숨기려면 &lt;code&gt;HiddenField&lt;/code&gt; 를 사용하십시오 . 이 필드 유형은 사용자 입력을 허용하지 않지만 항상 기본값을 직렬 변환기 의 &lt;code&gt;validated_data&lt;/code&gt; 로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2d10cdd2d206d475f23bceadfd0b25cfd29dc4a4" translate="yes" xml:space="preserve">
          <source>If you want the date field to be visible, but not editable by the user, then set &lt;code&gt;read_only=True&lt;/code&gt; and additionally set a &lt;code&gt;default=...&lt;/code&gt; argument.</source>
          <target state="translated">날짜 필드를 표시하지만 사용자가 편집 할 수 없도록하려면 &lt;code&gt;read_only=True&lt;/code&gt; 를 설정 하고 추가적으로 &lt;code&gt;default=...&lt;/code&gt; 인수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="622139648192d13f7f74beebf0f159b8c902e01e" translate="yes" xml:space="preserve">
          <source>If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a &lt;code&gt;default&lt;/code&gt; argument, or by setting &lt;code&gt;required=True&lt;/code&gt;.</source>
          <target state="translated">날짜 필드를 쓰기 가능하게하려면 &lt;code&gt;default&lt;/code&gt; 인수를 설정하거나 &lt;code&gt;required=True&lt;/code&gt; 를 설정 하여 입력 데이터에서 항상 사용 가능 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02d01a7350106c6ba50b1c53296d61e751e7597e" translate="yes" xml:space="preserve">
          <source>If you want to also support &lt;code&gt;.save()&lt;/code&gt; you'll need to also implement either or both of the &lt;code&gt;.create()&lt;/code&gt; and &lt;code&gt;.update()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;.save()&lt;/code&gt; 도 지원 하려면 &lt;code&gt;.create()&lt;/code&gt; 및 &lt;code&gt;.update()&lt;/code&gt; 메소드 중 하나 또는 둘 다를 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0419b40ffb675cd9b0244abd6a1d34be05f3038b" translate="yes" xml:space="preserve">
          <source>If you want to create a custom field, you'll need to subclass &lt;code&gt;Field&lt;/code&gt; and then override either one or both of the &lt;code&gt;.to_representation()&lt;/code&gt; and &lt;code&gt;.to_internal_value()&lt;/code&gt; methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, &lt;code&gt;date&lt;/code&gt;/&lt;code&gt;time&lt;/code&gt;/&lt;code&gt;datetime&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.</source>
          <target state="translated">사용자 정의 필드를 작성하려면 &lt;code&gt;Field&lt;/code&gt; 를 서브 클래 싱 한 다음 &lt;code&gt;.to_representation()&lt;/code&gt; 및 &lt;code&gt;.to_internal_value()&lt;/code&gt; 메소드 중 하나 또는 둘 다를 대체해야 합니다. 이 두 가지 방법은 초기 데이터 유형과 기본 직렬화 가능 데이터 유형을 변환하는 데 사용됩니다. 기본 데이터 유형은 일반적으로 숫자, 문자열, 부울, &lt;code&gt;date&lt;/code&gt; / &lt;code&gt;time&lt;/code&gt; / &lt;code&gt;datetime&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 입니다. 다른 기본 객체 만 포함하는 객체와 같은 목록 또는 사전 일 수도 있습니다. 사용중인 렌더러에 따라 다른 유형이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e035ba4436d6e1b849f87efde28ced8cff6b915" translate="yes" xml:space="preserve">
          <source>If you want to customize the way the serialization is done you'll need to define the field yourself.</source>
          <target state="translated">직렬화 수행 방식을 사용자 정의하려면 필드를 직접 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="4626c9cb05dae5171d93c4a08e8ed6c564c30395" translate="yes" xml:space="preserve">
          <source>If you want to get a more in depth understanding of how REST framework fits together head on over to &lt;a href=&quot;../1-serialization/index&quot;&gt;the tutorial&lt;/a&gt;, or start browsing the &lt;a href=&quot;../index#api-guide&quot;&gt;API guide&lt;/a&gt;.</source>
          <target state="translated">REST 프레임 워크가 서로 어떻게 조화를 이루는 지 이해하고 싶다면 &lt;a href=&quot;../1-serialization/index&quot;&gt;튜토리얼로&lt;/a&gt; 넘어가 거나 &lt;a href=&quot;../index#api-guide&quot;&gt;API 안내서를&lt;/a&gt; 찾아보기 바란다 .</target>
        </trans-unit>
        <trans-unit id="4f31550f4d2279789e5f2fd04bed881956869bd8" translate="yes" xml:space="preserve">
          <source>If you want to implement a read-write relational field, you must also implement the &lt;code&gt;.to_internal_value(self, data)&lt;/code&gt; method.</source>
          <target state="translated">읽기-쓰기 관계형 필드를 구현하려면 &lt;code&gt;.to_internal_value(self, data)&lt;/code&gt; 메소드 도 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8170d3b2076f134333ab7c374c3392b7dc2691ea" translate="yes" xml:space="preserve">
          <source>If you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.</source>
          <target state="translated">페이지 매김 스타일의 특정 측면을 수정하려는 경우 페이지 매김 클래스 중 하나를 재정의하고 변경하려는 속성을 설정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="89ad6b83208b32a7961d8a34c236c0a8b24207b0" translate="yes" xml:space="preserve">
          <source>If you want to override this behavior, you'll need to declare the &lt;code&gt;DateTimeField&lt;/code&gt; explicitly on the serializer. For example:</source>
          <target state="translated">이 동작을 재정의 하려면 serializer 에서 &lt;code&gt;DateTimeField&lt;/code&gt; 를 명시 적으로 선언해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ac8c97d6dc0ef008d46c605962467da9a0ee03b" translate="yes" xml:space="preserve">
          <source>If you want to provide a custom metadata class you should override &lt;code&gt;BaseMetadata&lt;/code&gt; and implement the &lt;code&gt;determine_metadata(self, request, view)&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 메타 데이터 클래스를 제공하려면 &lt;code&gt;BaseMetadata&lt;/code&gt; 를 대체 하고 &lt;code&gt;determine_metadata(self, request, view)&lt;/code&gt; _ 메타 데이터 (자체, 요청,보기) 메소드를 구현 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8976cc57fd793cfba0cca6d584d869e3009ab81d" translate="yes" xml:space="preserve">
          <source>If you want to provide totally custom behavior, you can override &lt;code&gt;BaseRouter&lt;/code&gt; and override the &lt;code&gt;get_urls(self)&lt;/code&gt; method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the &lt;code&gt;self.registry&lt;/code&gt; attribute.</source>
          <target state="translated">완전히 사용자 정의 동작을 제공하려면 &lt;code&gt;BaseRouter&lt;/code&gt; 를 대체하고 &lt;code&gt;get_urls(self)&lt;/code&gt; 메소드를 대체 할 수 있습니다 . 이 메소드는 등록 된 뷰 세트를 검사하고 URL 패턴 목록을 반환해야합니다. 등록 된 접두사, 뷰셋 및 기본 이름 튜플은 &lt;code&gt;self.registry&lt;/code&gt; 속성 에 액세스하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f94400d66bae1a3c96f58c4ee1025684c9dc596b" translate="yes" xml:space="preserve">
          <source>If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.</source>
          <target state="translated">일반 외래 키를 직렬화하려면 관계 대상을 직렬화하는 방법을 명시 적으로 결정하기 위해 사용자 정의 필드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbeb3c4da0f719e73015962b208ad964d57cc356" translate="yes" xml:space="preserve">
          <source>If you want to support a writable hyperlinked field then you'll also want to override &lt;code&gt;get_object&lt;/code&gt;, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.</source>
          <target state="translated">쓰기 가능한 하이퍼 링크 필드를 지원 하려면 들어오는 URL을 다시 나타내는 객체로 매핑하기 위해 &lt;code&gt;get_object&lt;/code&gt; 를 재정의 해야합니다. 읽기 전용 하이퍼 링크 필드의 경우이 방법을 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c55cde9d25686c3cab0d280e25e0e955dee19cef" translate="yes" xml:space="preserve">
          <source>If you wish to provide a base &lt;code&gt;AutoSchema&lt;/code&gt; subclass to be used throughout your project you may adjust &lt;code&gt;settings.DEFAULT_SCHEMA_CLASS&lt;/code&gt; appropriately.</source>
          <target state="translated">프로젝트 전체에서 사용할 기본 &lt;code&gt;AutoSchema&lt;/code&gt; 서브 클래스 를 제공 하려면 &lt;code&gt;settings.DEFAULT_SCHEMA_CLASS&lt;/code&gt; 적절하게 조정할 수 있습니다 .DEFAULT_SCHEMA_CLASS</target>
        </trans-unit>
        <trans-unit id="5efa6b8856eeac89e4ebd728c3b85133b29d4b14" translate="yes" xml:space="preserve">
          <source>If you wish to represent &lt;a href=&quot;https://docs.djangoproject.com/en/2.2/topics/db/models/#intermediary-manytomany&quot;&gt;extra fields on a through model&lt;/a&gt; then you may serialize the through model as &lt;a href=&quot;../serializers/index#dealing-with-nested-objects&quot;&gt;a nested object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.djangoproject.com/en/2.2/topics/db/models/#intermediary-manytomany&quot;&gt;스루 모델에서 추가 필드&lt;/a&gt; 를 나타내 려면 스루 모델을 &lt;a href=&quot;../serializers/index#dealing-with-nested-objects&quot;&gt;중첩 된 개체&lt;/a&gt; 로 직렬화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="121d74de94f90a6e55cb3eaf718b63863a44ede4" translate="yes" xml:space="preserve">
          <source>If you wish to use the provided permission classes in order to check object permissions, &lt;strong&gt;you must&lt;/strong&gt; subclass them and implement the &lt;code&gt;has_object_permission()&lt;/code&gt; method described in the &lt;a href=&quot;#custom-permissions&quot;&gt;&lt;em&gt;Custom permissions&lt;/em&gt;&lt;/a&gt; section (below).</source>
          <target state="translated">개체 권한을 확인하기 위해 제공된 권한 클래스를 사용하려면 해당 권한 클래스를 서브 클래 싱하고 &lt;a href=&quot;#custom-permissions&quot;&gt;&lt;em&gt;사용자 정의 권한&lt;/em&gt;&lt;/a&gt; 섹션 (아래)에 설명 된 &lt;code&gt;has_object_permission()&lt;/code&gt; 메소드를 구현 &lt;strong&gt;해야합니다&lt;/strong&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66d538a335f62aaaf9bf21bfdad68adf89867a1a" translate="yes" xml:space="preserve">
          <source>If you're building websites that use &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; along with other renderer classes, you should consider listing &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; as the first class in the &lt;code&gt;renderer_classes&lt;/code&gt; list, so that it will be prioritised first even for browsers that send poorly formed &lt;code&gt;ACCEPT:&lt;/code&gt; headers.</source>
          <target state="translated">다른 렌더러 클래스와 함께 &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 를 사용하는 웹 사이트를 구축하는 경우 , 형식이 &lt;code&gt;ACCEPT:&lt;/code&gt; 헤더 를 보내는 브라우저의 경우에도 우선 순위가 지정되도록 &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 를 &lt;code&gt;renderer_classes&lt;/code&gt; 목록 의 첫 번째 클래스로 나열하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="79a7ff5c68d9c2713c8f429e41b246ef58a8399d" translate="yes" xml:space="preserve">
          <source>If you're doing REST-based web service stuff ... you should ignore request.POST.</source>
          <target state="translated">REST 기반 웹 서비스 작업을 수행하는 경우 request.POST를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="7935da2f03c68f04e504051cf1ad4631de53b628" translate="yes" xml:space="preserve">
          <source>If you're intending to use the browsable API you'll probably also want to add REST framework's login and logout views. Add the following to your root &lt;code&gt;urls.py&lt;/code&gt; file.</source>
          <target state="translated">찾아보기 가능한 API를 사용하려는 경우 REST 프레임 워크의 로그인 및 로그 아웃보기를 추가 할 수도 있습니다. 루트 &lt;code&gt;urls.py&lt;/code&gt; 파일에 다음을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="4052e38c99e221e5181ae64b99933444efe61e3a" translate="yes" xml:space="preserve">
          <source>If you're not sure exactly what behavior a &lt;code&gt;ModelSerializer&lt;/code&gt; class will generate it is usually a good idea to run &lt;code&gt;manage.py shell&lt;/code&gt;, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 클래스가 어떤 동작 을 생성 하는지 확실하지 않은 경우 일반적으로 &lt;code&gt;manage.py shell&lt;/code&gt; 을 실행 하고 직렬 변환기 인스턴스를 인쇄하여 자동으로 생성되는 필드 및 유효성 검증기를 검사하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="6f2de65e8db5b6c6fb45472a424e7f8e37bb6ab6" translate="yes" xml:space="preserve">
          <source>If you're supporting writable nested representations you'll need to write &lt;code&gt;.create()&lt;/code&gt; or &lt;code&gt;.update()&lt;/code&gt; methods that handle saving multiple objects.</source>
          <target state="translated">쓰기 가능한 중첩 표현을 지원하는 경우 여러 객체 저장을 처리하는 &lt;code&gt;.create()&lt;/code&gt; 또는 &lt;code&gt;.update()&lt;/code&gt; 메서드 를 작성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2da35dbb332c7350e63b23109d8e331a35d4be2c" translate="yes" xml:space="preserve">
          <source>If you're testing views directly using &lt;code&gt;APIRequestFactory&lt;/code&gt;, the responses that are returned will not yet be rendered, as rendering of template responses is performed by Django's internal request-response cycle. In order to access &lt;code&gt;response.content&lt;/code&gt;, you'll first need to render the response.</source>
          <target state="translated">&lt;code&gt;APIRequestFactory&lt;/code&gt; 를 사용하여 직접 뷰를 테스트하는 경우 Django의 내부 요청-응답주기에 의해 템플릿 응답 렌더링이 수행되므로 반환되는 응답은 아직 렌더링되지 않습니다. &lt;code&gt;response.content&lt;/code&gt; 에 액세스 하려면 먼저 응답을 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="96450688e3b933e7655e448f1f504949067a9099" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;RequestsClient&lt;/code&gt; you'll want to ensure that test setup, and results assertions are performed as regular API calls, rather than interacting with the database models directly. For example, rather than checking that &lt;code&gt;Customer.objects.count() == 3&lt;/code&gt; you would list the customers endpoint, and ensure that it contains three records.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;RequestsClient&lt;/code&gt; 을 당신은 테스트 설정을 확인한 다음 결과의 주장은 오히려 직접 데이터베이스 모델과 상호 작용보다 일반 API 호출로 수행됩니다. 예를 들어 &lt;code&gt;Customer.objects.count() == 3&lt;/code&gt; 을 확인하지 않고 고객 엔드 포인트를 나열하고 세 개의 레코드가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fd8974e734dd298d0429cdbe52c8be482cbc0816" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;SessionAuthentication&lt;/code&gt; then you'll need to include a CSRF token for any &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; requests.</source>
          <target state="translated">&lt;code&gt;SessionAuthentication&lt;/code&gt; 을 사용 하는 경우 &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;PATCH&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 요청에 대해 CSRF 토큰을 포함해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9d8387c865010e963bcac67fae75632b6d8dca64" translate="yes" xml:space="preserve">
          <source>If you're using an AJAX style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any &quot;unsafe&quot; HTTP method calls, such as &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; requests. See the &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/csrf/#ajax&quot;&gt;Django CSRF documentation&lt;/a&gt; for more details.</source>
          <target state="translated">SessionAuthentication과 함께 AJAX 스타일 API를 사용하는 경우 &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;PATCH&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 요청 과 같은 &quot;안전하지 않은&quot;HTTP 메소드 호출에 유효한 CSRF 토큰을 포함시켜야 합니다. 자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/csrf/#ajax&quot;&gt;Django CSRF 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8a760b5589c367ecb5c3b0c10b8a78049091cc2" translate="yes" xml:space="preserve">
          <source>If you're using either the &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; or the &lt;code&gt;StaticHTMLRenderer&lt;/code&gt; and an exception is raised, the behavior is slightly different, and mirrors &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views&quot;&gt;Django's default handling of error views&lt;/a&gt;.</source>
          <target state="translated">당신이 중 하나를 사용하는 경우 &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 또는 &lt;code&gt;StaticHTMLRenderer&lt;/code&gt; 을 하고 예외가 발생, 동작이 약간 다르고, 거울 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views&quot;&gt;오류보기 장고의 기본 처리를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f25723e9d2f21201851ff90a0193e43a1dfaa73" translate="yes" xml:space="preserve">
          <source>If you're using this permission with a view that uses an overridden &lt;code&gt;get_queryset()&lt;/code&gt; method there may not be a &lt;code&gt;queryset&lt;/code&gt; attribute on the view. In this case we suggest also marking the view with a sentinel queryset, so that this class can determine the required permissions. For example:</source>
          <target state="translated">재정의 된 &lt;code&gt;get_queryset()&lt;/code&gt; 메소드 를 사용하는보기에서이 권한을 사용하는 경우보기에 &lt;code&gt;queryset&lt;/code&gt; 속성 이 없을 수 있습니다. 이 경우 센티넬 쿼리 셋으로 뷰를 표시하여이 클래스가 필요한 권한을 결정할 수 있도록하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b114c70dadf43ea19c909b13cdbb226f29928f80" translate="yes" xml:space="preserve">
          <source>If you're working through the browser, make sure to login using the control in the top right corner.</source>
          <target state="translated">브라우저를 통해 작업하는 경우 오른쪽 상단의 컨트롤을 사용하여 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="80f68c2ff896f7205535585c68a16109f13ff946" translate="yes" xml:space="preserve">
          <source>If you're writing your own views and want to enforce object level permissions, or if you override the &lt;code&gt;get_object&lt;/code&gt; method on a generic view, then you'll need to explicitly call the &lt;code&gt;.check_object_permissions(request, obj)&lt;/code&gt; method on the view at the point at which you've retrieved the object.</source>
          <target state="translated">자체 뷰를 작성하고 객체 레벨 권한을 적용하려는 경우 또는 일반 뷰 에서 &lt;code&gt;get_object&lt;/code&gt; 메소드 를 대체하는 경우 뷰의 &lt;code&gt;.check_object_permissions(request, obj)&lt;/code&gt; 메소드 를 명시 적으로 호출해야 합니다. 객체를 검색 한 지점.</target>
        </trans-unit>
        <trans-unit id="02cf87af64d52b56dd63e57361d8a3957bedd21d" translate="yes" xml:space="preserve">
          <source>If you've already created some users, you can generate tokens for all existing users like this:</source>
          <target state="translated">이미 일부 사용자를 만든 경우 다음과 같이 기존의 모든 사용자에 대한 토큰을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36110577cb7130f7ef619388e2f57f40d59ec41d" translate="yes" xml:space="preserve">
          <source>If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; your default renderer, in order to play nicely with older browsers that send &lt;a href=&quot;http://www.gethifi.com/blog/browser-rest-http-accept-headers&quot;&gt;broken accept headers&lt;/a&gt;.</source>
          <target state="translated">API에 요청에 따라 일반 웹 페이지와 API 응답을 모두 제공 할 수있는 뷰가 포함 된 경우, &lt;a href=&quot;http://www.gethifi.com/blog/browser-rest-http-accept-headers&quot;&gt;깨진 수락 헤더&lt;/a&gt; 를 보내는 오래된 브라우저에서 훌륭하게 재생하기 위해 &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 를 기본 렌더러로 만드는 것을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e09ba0d2da866d07d99a56e32aba9c797410c90" translate="yes" xml:space="preserve">
          <source>If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if &lt;code&gt;Comment&lt;/code&gt; was a Django model, the methods might look like this:</source>
          <target state="translated">객체 인스턴스가 Django 모델에 해당하는 경우 이러한 메소드가 객체를 데이터베이스에 저장하도록해야합니다. 예를 들어, &lt;code&gt;Comment&lt;/code&gt; 가 Django 모델 인 경우 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b79c4e7b7e210bf9af47e42cb273de14d5315e3" translate="yes" xml:space="preserve">
          <source>If your schema is static, you can use the &lt;code&gt;generateschema&lt;/code&gt; management command:</source>
          <target state="translated">스키마가 정적 인 경우 &lt;code&gt;generateschema&lt;/code&gt; 관리 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51727e0970476599cc11a6f111af47ba8dae38a4" translate="yes" xml:space="preserve">
          <source>If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the &lt;code&gt;.reverse()&lt;/code&gt; method on the class. See the source code for examples.</source>
          <target state="translated">버전 관리 체계가 요청 URL을 기반으로하는 경우 버전이 지정된 URL을 결정하는 방법도 변경해야합니다. 이렇게하려면 클래스 에서 &lt;code&gt;.reverse()&lt;/code&gt; 메서드를 재정의해야합니다 . 예제는 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec0f94b7f1d42cba194b2fd041fdea054d7a065e" translate="yes" xml:space="preserve">
          <source>Ignore the data and leave the instance as it is.</source>
          <target state="translated">데이터를 무시하고 인스턴스를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="65c28397128d45ca02c4c7d754d1b076c2fee261" translate="yes" xml:space="preserve">
          <source>ImageField</source>
          <target state="translated">ImageField</target>
        </trans-unit>
        <trans-unit id="9168902583606b20f546445aec86f82111b91551" translate="yes" xml:space="preserve">
          <source>Implementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.</source>
          <target state="translated">커스텀 라우터를 구현하는 것은 자주 수행 할 필요는 없지만 API의 URL을 구성하는 방법에 대한 특정 요구 사항이있는 경우 유용 할 수 있습니다. 그렇게하면 재사용 할 수있는 방식으로 URL 구조를 캡슐화하여 각각의 새로운보기에 대해 URL 패턴을 명시 적으로 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5294487792e6db8e814bc0dd08dafb9579d9acb6" translate="yes" xml:space="preserve">
          <source>Improving serialization performance for a frequently accessed API endpoint that returns lots of data.</source>
          <target state="translated">많은 양의 데이터를 반환하는 자주 액세스하는 API 엔드 포인트에 대한 직렬화 성능 향상</target>
        </trans-unit>
        <trans-unit id="9bc0a557b253ef4474f0872ece9d2330715709ea" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../3-class-based-views/index&quot;&gt;tutorial part 3&lt;/a&gt;, we'll start using class-based views, and see how generic views reduce the amount of code we need to write.</source>
          <target state="translated">에서 &lt;a href=&quot;../3-class-based-views/index&quot;&gt;튜토리얼 3 부&lt;/a&gt; , 우리는 클래스 기반 뷰를 사용하기 시작, 우리가 작성해야하는 코드의 양을 줄이는 방법 일반적인 전망을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de8f8eece72c42e8ef0595499605c9085caae1e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../5-relationships-and-hyperlinked-apis/index&quot;&gt;part 5&lt;/a&gt; of the tutorial we'll look at how we can tie everything together by creating an HTML endpoint for our highlighted snippets, and improve the cohesion of our API by using hyperlinking for the relationships within the system.</source>
          <target state="translated">학습서의 &lt;a href=&quot;../5-relationships-and-hyperlinked-apis/index&quot;&gt;5 부&lt;/a&gt; 에서는 강조 표시된 스 니펫에 대한 HTML 엔드 포인트를 작성하여 모든 것을 하나로 묶을 수있는 방법을 살펴보고 시스템 내 관계에 하이퍼 링크를 사용하여 API의 응집력을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="2c8a7bb6e248ab63a50f973c06988804e6bfff7e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../6-viewsets-and-routers/index&quot;&gt;part 6&lt;/a&gt; of the tutorial we'll look at how we can use ViewSets and Routers to reduce the amount of code we need to build our API.</source>
          <target state="translated">튜토리얼 &lt;a href=&quot;../6-viewsets-and-routers/index&quot;&gt;6 부&lt;/a&gt; 에서는 ViewSets 및 Routers를 사용하여 API를 작성하는 데 필요한 코드의 양을 줄이는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="85da5b3f3c33e72a5a4088dab60e816853affd51" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;the words of Roy Fielding&lt;/a&gt;, &quot;A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.&quot;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;로이 필딩의 말&lt;/a&gt; , &quot;A REST API는, 또는 확장 된 관계 이름 및 / 또는 하이퍼 텍스트 기반 마크로를 정의하는 자원을 나타내는 및 응용 프로그램 상태를 구동하기 위해 사용되는 미디어 타입 (들)을 정의하는 거의 모든 설명의 노력 지출해야 기존의 표준 미디어 유형에 적합합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="3364cd64fae1b8e22888f013dc5fa0677045eb0e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;urls.py&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;urls.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9f1c22599e7c1055ba9b4e95fccaa142383c7273" translate="yes" xml:space="preserve">
          <source>In another terminal window, we can test the server.</source>
          <target state="translated">다른 터미널 창에서 서버를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f30eedd1f26ff249bc872a0f68b5d92734a45a7" translate="yes" xml:space="preserve">
          <source>In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:</source>
          <target state="translated">토큰을 재생성하려는 경우 (예 : 손상 또는 유출 된 경우) 추가 매개 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f868a50ed70044bf1e515be92cd9e9223eba4732" translate="yes" xml:space="preserve">
          <source>In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the &lt;code&gt;style&lt;/code&gt; keyword argument. For example:</source>
          <target state="translated">컷오프가 적용되는 경우 HTML 양식에서 일반 입력 필드를 대신 사용할 수 있습니다. &lt;code&gt;style&lt;/code&gt; 키워드 인수를 사용하면 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="688533119976ed4519c058b9b0bea5d2e6f431b9" translate="yes" xml:space="preserve">
          <source>In compiling the schema, &lt;code&gt;SchemaGenerator&lt;/code&gt; calls &lt;code&gt;view.schema.get_operation()&lt;/code&gt; for each view, allowed method, and path.</source>
          <target state="translated">스키마를 컴파일 할 때 &lt;code&gt;SchemaGenerator&lt;/code&gt; 는 각보기, 허용 된 메소드 및 경로에 대해 &lt;code&gt;view.schema.get_operation()&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="9973c8a9c430982a53f9d763a0d2e6ca01b4afd4" translate="yes" xml:space="preserve">
          <source>In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.</source>
          <target state="translated">각각의 경우 REST 프레임 워크는 적절한 상태 코드 및 컨텐츠 유형으로 응답을 리턴합니다. 응답 본문에는 오류의 성격에 관한 추가 세부 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f864bfceecefc2ce1db9c676440074218c92aa6d" translate="yes" xml:space="preserve">
          <source>In most cases the error detail will be a simple item:</source>
          <target state="translated">대부분의 경우 오류 세부 사항은 간단한 항목입니다.</target>
        </trans-unit>
        <trans-unit id="0690e51d2227d8a2fdd9b2d54589edb7a8564bfb" translate="yes" xml:space="preserve">
          <source>In order to alter the style of the response, you could write the following custom exception handler:</source>
          <target state="translated">응답 스타일을 변경하기 위해 다음과 같은 사용자 정의 예외 핸들러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b851f37b5fe52e602dd164cfa9728452d7a148" translate="yes" xml:space="preserve">
          <source>In order to customise the operation generation, you should provide an &lt;code&gt;AutoSchema&lt;/code&gt; subclass, overriding &lt;code&gt;get_operation()&lt;/code&gt; as you need:</source>
          <target state="translated">작업 생성을 사용자 지정 하려면 필요에 따라 &lt;code&gt;get_operation()&lt;/code&gt; 을 재정 의하여 &lt;code&gt;AutoSchema&lt;/code&gt; 하위 클래스를 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="57311f27d476b7265fe4d5be1f0c009f48ebf09b" translate="yes" xml:space="preserve">
          <source>In order to customize the top-level schema sublass &lt;code&gt;rest_framework.schemas.openapi.SchemaGenerator&lt;/code&gt; and provide it as an argument to the &lt;code&gt;generateschema&lt;/code&gt; command or &lt;code&gt;get_schema_view()&lt;/code&gt; helper function.</source>
          <target state="translated">최상위 스키마 하위 레이블 &lt;code&gt;rest_framework.schemas.openapi.SchemaGenerator&lt;/code&gt; 를 사용자 정의하고 &lt;code&gt;generateschema&lt;/code&gt; 명령 또는 &lt;code&gt;get_schema_view()&lt;/code&gt; 헬퍼 함수에 인수로 제공하려면 .</target>
        </trans-unit>
        <trans-unit id="e046c00a4bea26c59a2cddcea0839625c85f94e1" translate="yes" xml:space="preserve">
          <source>In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.</source>
          <target state="translated">다양한 유형의 관계형 필드를 설명하기 위해 예제에 몇 가지 간단한 모델을 사용합니다. 우리의 모델은 음악 앨범 및 각 앨범에 나열된 트랙 용입니다.</target>
        </trans-unit>
        <trans-unit id="d98f4cb080ce59cee3f4d1e0f3cbdd3adf407d47" translate="yes" xml:space="preserve">
          <source>In order to use a &lt;code&gt;GenericViewSet&lt;/code&gt; class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.</source>
          <target state="translated">&lt;code&gt;GenericViewSet&lt;/code&gt; 클래스 를 사용 하려면 클래스를 재정의하고 필요한 믹스 인 클래스를 믹스 인하 거나 액션 구현을 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8af114e7501515d97ddfee42bc5614300bf12286" translate="yes" xml:space="preserve">
          <source>In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.</source>
          <target state="translated">기존의 관계형 스타일 중 어느 것도 필요한 표현에 맞지 않는 경우는 드물지만 모델 인스턴스에서 출력 표현을 생성하는 방법을 정확하게 설명하는 완전히 사용자 정의 관계형 필드를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfe0be8c16eefaae47bb1667e8cbcb0bbec08c72" translate="yes" xml:space="preserve">
          <source>In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by declaring a &lt;code&gt;set_context&lt;/code&gt; method on a class-based validator.</source>
          <target state="translated">일부 고급 경우 유효성 검사기에 추가 컨텍스트로 사용중인 시리얼 라이저 필드에 유효성 검사기가 전달되도록 할 수 있습니다. 클래스 기반 유효성 검사기에서 &lt;code&gt;set_context&lt;/code&gt; 메서드를 선언하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb1776dbdcb2d0ba2a0cc302579c4a2b382fba6" translate="yes" xml:space="preserve">
          <source>In some cases the &lt;code&gt;.create()&lt;/code&gt; and &lt;code&gt;.update()&lt;/code&gt; method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.</source>
          <target state="translated">경우에 따라 &lt;code&gt;.create()&lt;/code&gt; 및 &lt;code&gt;.update()&lt;/code&gt; 메서드 이름이 의미가 없을 수 있습니다. 예를 들어, 문의 양식에서 새 인스턴스를 만들지 않고 대신 전자 메일이나 다른 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14c92e31d1575bd150457de53bf7a6a7f39efd6" translate="yes" xml:space="preserve">
          <source>In some cases you may also want to set the &lt;code&gt;render_style&lt;/code&gt; attribute to &lt;code&gt;'binary'&lt;/code&gt;. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.</source>
          <target state="translated">경우에 따라 &lt;code&gt;render_style&lt;/code&gt; 속성을 &lt;code&gt;'binary'&lt;/code&gt; 로 설정할 수도 있습니다 . 그렇게하면 탐색 가능한 API가 이진 컨텐츠를 문자열로 표시하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="926943bfc0cfbfb0841944f2962bcc3adb5ce7e7" translate="yes" xml:space="preserve">
          <source>In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.</source>
          <target state="translated">경우에 따라 하나 이상의 조회 필드가 필요한 URL을 나타 내기 위해 하이퍼 링크 된 필드의 동작을 사용자 정의해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="882e2cc9e1a6bb355f77c0dc5b9abececa3cb487" translate="yes" xml:space="preserve">
          <source>In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a &lt;code&gt;media_type&lt;/code&gt; value such as &lt;code&gt;image/*&lt;/code&gt;, or &lt;code&gt;*/*&lt;/code&gt;.</source>
          <target state="translated">경우에 따라 렌더러가 다양한 미디어 유형을 제공하도록 할 수 있습니다. 이 경우 &lt;code&gt;image/*&lt;/code&gt; 또는 &lt;code&gt;*/*&lt;/code&gt; 와 같은 &lt;code&gt;media_type&lt;/code&gt; 값 을 사용하여 응답해야하는 미디어 유형을 잘못 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4acd91baffe82b2a23eab3a33126d2e9e49cedab" translate="yes" xml:space="preserve">
          <source>In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access &lt;code&gt;request.accepted_renderer&lt;/code&gt; to determine the negotiated renderer that will be used for the response.</source>
          <target state="translated">경우에 따라 허용되는 미디어 유형에 따라보기에서 다른 직렬화 스타일을 사용하기를 원할 수도 있습니다. 이 작업을 수행해야하는 경우 &lt;code&gt;request.accepted_renderer&lt;/code&gt; 에 액세스 하여 응답에 사용될 협상 된 렌더러를 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad116876b849eeab46ccdb1e9c9094a5abe38fe" translate="yes" xml:space="preserve">
          <source>In some circumstances instead of returning &lt;code&gt;None&lt;/code&gt;, you may want to raise an &lt;code&gt;AuthenticationFailed&lt;/code&gt; exception from the &lt;code&gt;.authenticate()&lt;/code&gt; method.</source>
          <target state="translated">경우에 따라 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 &lt;code&gt;.authenticate()&lt;/code&gt; 메서드 에서 &lt;code&gt;AuthenticationFailed&lt;/code&gt; 예외를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f6a9e5885d07ae5d127e72fb4bc3247ec2bb6ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;snippets/urls.py&lt;/code&gt; file we bind our &lt;code&gt;ViewSet&lt;/code&gt; classes into a set of concrete views.</source>
          <target state="translated">에서 &lt;code&gt;snippets/urls.py&lt;/code&gt; 파일 우리는 우리의 결합 &lt;code&gt;ViewSet&lt;/code&gt; 콘크리트 뷰의 집합으로 클래스를.</target>
        </trans-unit>
        <trans-unit id="3f906f6840d5ff34c1d10c0bfe79d8643b361ccb" translate="yes" xml:space="preserve">
          <source>In the case of update operations on &lt;em&gt;nested&lt;/em&gt; serializers there's no way of applying this exclusion, because the instance is not available.</source>
          <target state="translated">&lt;em&gt;중첩 된&lt;/em&gt; serializer 에서 업데이트 작업의 경우 인스턴스를 사용할 수 없기 때문에이 제외를 적용 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb423586dbd035b1048e62867b192b688b3ccbb7" translate="yes" xml:space="preserve">
          <source>In the case of validation errors the error detail will be either a list or dictionary of items:</source>
          <target state="translated">유효성 검증 오류의 경우 오류 세부 사항은 항목 목록 또는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="7e1e635e26c7d6065e21e8ef27f2945f1c9e176d" translate="yes" xml:space="preserve">
          <source>In the example above, if the &lt;code&gt;Account&lt;/code&gt; model had 3 fields &lt;code&gt;account_name&lt;/code&gt;, &lt;code&gt;users&lt;/code&gt;, and &lt;code&gt;created&lt;/code&gt;, this will result in the fields &lt;code&gt;account_name&lt;/code&gt; and &lt;code&gt;created&lt;/code&gt; to be serialized.</source>
          <target state="translated">경우 위의 예에서, &lt;code&gt;Account&lt;/code&gt; 모델은 3 개 필드 한 &lt;code&gt;account_name&lt;/code&gt; , &lt;code&gt;users&lt;/code&gt; 및 &lt;code&gt;created&lt;/code&gt; 필드는,이가 발생합니다 &lt;code&gt;account_name&lt;/code&gt; 및 &lt;code&gt;created&lt;/code&gt; 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f542bf2493c8e0135b33b0bfe2571e93f8970518" translate="yes" xml:space="preserve">
          <source>In the example request above &lt;code&gt;request.version&lt;/code&gt; attribute would return the string &lt;code&gt;'1.0'&lt;/code&gt;.</source>
          <target state="translated">위의 요청에서 &lt;code&gt;request.version&lt;/code&gt; 속성은 문자열 &lt;code&gt;'1.0'&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34c4b78667cc70007d5c10c4be0ca2b76d18295f" translate="yes" xml:space="preserve">
          <source>In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:</source>
          <target state="translated">다음 예제에서는 각각 다른 네임 스페이스 아래에 두 가지 가능한 URL 접두사를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="107235d1e1d5a96c3661309001d0afc11a168864" translate="yes" xml:space="preserve">
          <source>In the same way that Django provides both &lt;code&gt;Form&lt;/code&gt; classes and &lt;code&gt;ModelForm&lt;/code&gt; classes, REST framework includes both &lt;code&gt;Serializer&lt;/code&gt; classes, and &lt;code&gt;ModelSerializer&lt;/code&gt; classes.</source>
          <target state="translated">Django가 &lt;code&gt;Form&lt;/code&gt; 클래스와 &lt;code&gt;ModelForm&lt;/code&gt; 클래스를 모두 제공하는 것과 마찬가지로 REST 프레임 워크에는 &lt;code&gt;Serializer&lt;/code&gt; 클래스와 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스가 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2129aca9c3d44aa8a2ebc9624d02a6720fb70c72" translate="yes" xml:space="preserve">
          <source>In the snippets app, create a new file, &lt;code&gt;permissions.py&lt;/code&gt;</source>
          <target state="translated">스 니펫 앱에서 &lt;code&gt;permissions.py&lt;/code&gt; 라는 새 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07f7bc65c0d9f00de0e2c6cd61ee137b474e9321" translate="yes" xml:space="preserve">
          <source>In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer &lt;code&gt;Meta.validators&lt;/code&gt; attribute.</source>
          <target state="translated">이러한 경우 serializer &lt;code&gt;Meta.validators&lt;/code&gt; 속성에 빈 목록을 지정하여 자동으로 생성 된 유효성 검사기를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45a05d73c2e5da0f0bb110c4f1c6bbabe4f5b4cd" translate="yes" xml:space="preserve">
          <source>In these cases you might instead choose to override &lt;code&gt;.save()&lt;/code&gt; directly, as being more readable and meaningful.</source>
          <target state="translated">이 경우 보다 읽기 쉽고 의미있는 &lt;code&gt;.save()&lt;/code&gt; 직접 재정의하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4a5058e9c9ef5b7664a86d8c25bab74ae0b457c" translate="yes" xml:space="preserve">
          <source>In this case we'd like to use a hyperlinked style between entities. In order to do so, we'll modify our serializers to extend &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; instead of the existing &lt;code&gt;ModelSerializer&lt;/code&gt;.</source>
          <target state="translated">이 경우 엔터티간에 하이퍼 링크 스타일을 사용하려고합니다. 이를 위해 기존 &lt;code&gt;ModelSerializer&lt;/code&gt; 대신 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 를 확장하도록 serializer를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="47e5ae9773c8a52ac3d36cac41c890c92aa13313" translate="yes" xml:space="preserve">
          <source>In this case we'd need to override &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; to get the behavior we want:</source>
          <target state="translated">이 경우 원하는 동작을 얻으려면 &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; 를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f04763f433f28f252a1b876810bb8b3935379597" translate="yes" xml:space="preserve">
          <source>In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the &lt;code&gt;.validate()&lt;/code&gt; method, or else in the view.</source>
          <target state="translated">이 경우 일반적으로 serializer 클래스에서 유효성 검사기를 제외하고 대신 &lt;code&gt;.validate()&lt;/code&gt; 메서드 또는보기에서 유효성 검사 논리를 명시 적으로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8320315a47d9cbe21c22ae41e640144d3f06735b" translate="yes" xml:space="preserve">
          <source>In version 2.x a serializer class could &lt;em&gt;sometimes&lt;/em&gt; automatically determine the &lt;code&gt;queryset&lt;/code&gt; argument &lt;em&gt;if&lt;/em&gt; a &lt;code&gt;ModelSerializer&lt;/code&gt; class was being used.</source>
          <target state="translated">버전 2.xa에서 시리얼 클래스는 수 &lt;em&gt;때로는&lt;/em&gt; 자동으로 결정 &lt;code&gt;queryset&lt;/code&gt; 인수를 &lt;em&gt;하는 경우 &lt;/em&gt; &lt;code&gt;ModelSerializer&lt;/code&gt; 의 클래스가 사용되었다.</target>
        </trans-unit>
        <trans-unit id="5b8c8d42f5b8e256d00c4aebc7ccebd1ff12920c" translate="yes" xml:space="preserve">
          <source>Including extra context</source>
          <target state="translated">추가 컨텍스트 포함</target>
        </trans-unit>
        <trans-unit id="3f346ab5bc9c3fa0be9e75578b5816c77b44b7c4" translate="yes" xml:space="preserve">
          <source>Incoming requests will be authenticated and appropriate permission and/or throttle checks will be run before dispatching the request to the handler method.</source>
          <target state="translated">들어오는 요청이 인증되고 요청을 처리기 메서드로 디스패치하기 전에 적절한 권한 및 / 또는 스로틀 검사가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b12364b5b5d2f31b2c1099d4758a14eb4dc5de9a" translate="yes" xml:space="preserve">
          <source>Individual fields on a serializer can include validators, by declaring them on the field instance, for example:</source>
          <target state="translated">시리얼 라이저의 개별 필드는 필드 인스턴스에서 선언하여 유효성 검사기를 포함 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2143d2136bd9fbc7eb18e9ae008dc90e8385bee6" translate="yes" xml:space="preserve">
          <source>Informational - 1xx</source>
          <target state="translated">정보 용-1xx</target>
        </trans-unit>
        <trans-unit id="a41b358a4c095820b6c556cf6de2b0c04588535e" translate="yes" xml:space="preserve">
          <source>Inspecting API exceptions</source>
          <target state="translated">API 예외 검사</target>
        </trans-unit>
        <trans-unit id="4592d1f9d969d8eceacc50bfd757e6ceaae65efd" translate="yes" xml:space="preserve">
          <source>Inspecting a ModelSerializer</source>
          <target state="translated">ModelSerializer 검사</target>
        </trans-unit>
        <trans-unit id="64619cf619624bae08d9d31b0e70e8d5e596c4c9" translate="yes" xml:space="preserve">
          <source>Inspecting relationships.</source>
          <target state="translated">관계 검사.</target>
        </trans-unit>
        <trans-unit id="48e835725b6125565d12f7824bc34a014d64086b" translate="yes" xml:space="preserve">
          <source>Install pyyaml</source>
          <target state="translated">pyyaml ​​설치</target>
        </trans-unit>
        <trans-unit id="2120cad4e5cffc3226a84f09c6063e015255f999" translate="yes" xml:space="preserve">
          <source>Install the package using &lt;code&gt;pip&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pip&lt;/code&gt; 를 사용하여 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c0b2568b224aff08e3aa258c4a9194ca2eb8559" translate="yes" xml:space="preserve">
          <source>Install using &lt;code&gt;pip&lt;/code&gt;, including any optional packages you want...</source>
          <target state="translated">원하는 옵션 패키지를 포함 하여 &lt;code&gt;pip&lt;/code&gt; 를 사용하여 설치하십시오 ...</target>
        </trans-unit>
        <trans-unit id="b7c5130dc01ae5a68649c4c7875710fa111dac26" translate="yes" xml:space="preserve">
          <source>Install using &lt;code&gt;pip&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pip&lt;/code&gt; 를 사용하여 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="d745af040cceeaad04052e841f5ff1f88160a150" translate="yes" xml:space="preserve">
          <source>Install using pip.</source>
          <target state="translated">pip를 사용하여 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="9989f58a9680ff093212d449bc5902f3eb524e9a" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; configuration</source>
          <target state="translated">설치 및 구성</target>
        </trans-unit>
        <trans-unit id="68dcfc2bb18731e2f5aa2801838ca10c0c6581ad" translate="yes" xml:space="preserve">
          <source>Instead of inspecting the result of parsing &lt;code&gt;response.content&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;response.content&lt;/code&gt; 구문 분석 결과를 검사하는 대신 :</target>
        </trans-unit>
        <trans-unit id="bdd26b7fc927ba085e48699fd298e298bcd7e8a1" translate="yes" xml:space="preserve">
          <source>Instead of using a concrete generic view, we'll use the base class for representing instances, and create our own &lt;code&gt;.get()&lt;/code&gt; method. In your &lt;code&gt;snippets/views.py&lt;/code&gt; add:</source>
          <target state="translated">구체적인 일반 뷰를 사용하는 대신 인스턴스를 나타내는 데 기본 클래스를 사용하고 자체 &lt;code&gt;.get()&lt;/code&gt; 메서드를 만듭니다. 당신의에서 &lt;code&gt;snippets/views.py&lt;/code&gt; 추가 :</target>
        </trans-unit>
        <trans-unit id="85fb196fa9650404b51b0c6a0b9643dbf491b236" translate="yes" xml:space="preserve">
          <source>IntegerField</source>
          <target state="translated">IntegerField</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e148dadf58575cb6f6118313b7b04fcf7879e178" translate="yes" xml:space="preserve">
          <source>Introspecting ViewSet actions</source>
          <target state="translated">ViewSet 작업 검사</target>
        </trans-unit>
        <trans-unit id="4f90db5206b386352deca0deeae6be2f37571a9f" translate="yes" xml:space="preserve">
          <source>IsAdminUser</source>
          <target state="translated">IsAdminUser</target>
        </trans-unit>
        <trans-unit id="f4e9992bcd26b461360322d36ea3ccdb55d3b7ae" translate="yes" xml:space="preserve">
          <source>IsAuthenticated</source>
          <target state="translated">IsAuthenticated</target>
        </trans-unit>
        <trans-unit id="6bac6d6b563dfa1457b257c5ca2ed2e20cc6af8d" translate="yes" xml:space="preserve">
          <source>IsAuthenticatedOrReadOnly</source>
          <target state="translated">IsAuthenticatedOrReadOnly</target>
        </trans-unit>
        <trans-unit id="d6dc5f7f1837f2f64debfabc5adaa110f2dd45b1" translate="yes" xml:space="preserve">
          <source>It does not include the &lt;code&gt;id&lt;/code&gt; field by default.</source>
          <target state="translated">기본적으로 &lt;code&gt;id&lt;/code&gt; 필드 는 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67c34a887521bad612d381ca00050ac39c8cd775" translate="yes" xml:space="preserve">
          <source>It includes a &lt;code&gt;url&lt;/code&gt; field, using &lt;code&gt;HyperlinkedIdentityField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HyperlinkedIdentityField&lt;/code&gt; 를 사용 하는 &lt;code&gt;url&lt;/code&gt; 필드를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="1bea45bade3d72a23e4f26688912e87156ba1f60" translate="yes" xml:space="preserve">
          <source>It includes all parsed content, including &lt;em&gt;file and non-file&lt;/em&gt; inputs.</source>
          <target state="translated">&lt;em&gt;파일 및 비 파일&lt;/em&gt; 입력을 포함하여 구문 분석 된 모든 컨텐츠를 포함 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="848942a5dc93884052d898f7df64a14574bcf2db" translate="yes" xml:space="preserve">
          <source>It includes simple default implementations of &lt;code&gt;.create()&lt;/code&gt; and &lt;code&gt;.update()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.create()&lt;/code&gt; 및 &lt;code&gt;.update()&lt;/code&gt; 의 간단한 기본 구현이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b743c47ecf8dc2e6158ebd132102a55e4b46a34" translate="yes" xml:space="preserve">
          <source>It introduces a proper separation of concerns, making your code behavior more obvious.</source>
          <target state="translated">코드 문제를보다 명확하게하기 위해 우려를 적절히 분리시킵니다.</target>
        </trans-unit>
        <trans-unit id="56fdf7c8b8b10a161e613e7c4a6c2d8ba4be3291" translate="yes" xml:space="preserve">
          <source>It is actually a misconception. For example, take the following quote from Roy Fielding discussing the relative merits of query parameter media-type indicators vs. file extension media-type indicators:</source>
          <target state="translated">실제로 오해입니다. 예를 들어, Roy Fielding의 다음 인용문을 사용하여 쿼리 매개 변수 미디어 유형 표시기 대 파일 확장명 미디어 유형 표시기의 상대적인 장점을 논의하십시오.</target>
        </trans-unit>
        <trans-unit id="732410e0431137bbc4d1be9387c6072cdbfe33fe" translate="yes" xml:space="preserve">
          <source>It is also possible to create Tokens manually through admin interface. In case you are using a large user base, we recommend that you monkey patch the &lt;code&gt;TokenAdmin&lt;/code&gt; class to customize it to your needs, more specifically by declaring the &lt;code&gt;user&lt;/code&gt; field as &lt;code&gt;raw_field&lt;/code&gt;.</source>
          <target state="translated">관리자 인터페이스를 통해 수동으로 토큰을 생성 할 수도 있습니다. 대규모 사용자 기반을 사용하는 경우 &lt;code&gt;user&lt;/code&gt; 필드를 &lt;code&gt;raw_field&lt;/code&gt; 로 선언하여 &lt;code&gt;TokenAdmin&lt;/code&gt; 클래스를 원숭이 패치 하여 필요에 맞게 사용자 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="09a4ce5b755df95fd216fa76d706f82139b1e0d2" translate="yes" xml:space="preserve">
          <source>It is easy to switch between using shortcut &lt;code&gt;ModelSerializer&lt;/code&gt; classes and using explicit &lt;code&gt;Serializer&lt;/code&gt; classes. Any validation behavior being used for &lt;code&gt;ModelSerializer&lt;/code&gt; is simple to replicate.</source>
          <target state="translated">바로 가기 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스 사용과 명시 적 &lt;code&gt;Serializer&lt;/code&gt; 클래스 사용 간을 쉽게 전환 할 수 있습니다. &lt;code&gt;ModelSerializer&lt;/code&gt; 에 사용되는 모든 검증 동작은 복제 하기 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="765d0dbfe0c1979a6e47885d4c9ff2505c88ce21" translate="yes" xml:space="preserve">
          <source>It is important to understand that if you configure the &lt;code&gt;NUM_PROXIES&lt;/code&gt; setting, then all clients behind a unique &lt;a href=&quot;https://en.wikipedia.org/wiki/Network_address_translation&quot;&gt;NAT'd&lt;/a&gt; gateway will be treated as a single client.</source>
          <target state="translated">&lt;code&gt;NUM_PROXIES&lt;/code&gt; 설정 을 구성하면 고유 한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Network_address_translation&quot;&gt;NAT&lt;/a&gt; 게이트웨이 뒤에있는 모든 클라이언트 가 단일 클라이언트로 취급된다는 것을 이해해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9ceaeeeda5a1657b4451ce1f5f5498584ed46840" translate="yes" xml:space="preserve">
          <source>It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the &lt;code&gt;allow_add_remove&lt;/code&gt; behavior that was present in REST framework 2.</source>
          <target state="translated">REST 프레임 워크 2에 있는 &lt;code&gt;allow_add_remove&lt;/code&gt; 동작 과 유사하게 여러 업데이트 조작에 대한 일부 자동 지원을 제공하는 3.1 릴리스와 함께 써드 파티 패키지가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fc018e0a231d09bbbb8ae48ea1a2ce74b0af12f" translate="yes" xml:space="preserve">
          <source>It leaves less work for your API clients.</source>
          <target state="translated">API 클라이언트의 작업이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d528f44c7eb011c7074f4471accbb62a582cc7eb" translate="yes" xml:space="preserve">
          <source>It makes it easy to do things like markup HTML representations with hyperlinks.</source>
          <target state="translated">하이퍼 링크를 사용하여 마크 업 HTML 표현과 같은 작업을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7fcfc1b9092f8f4f9f5d909e83eccf70a8154c" translate="yes" xml:space="preserve">
          <source>It may look unusual that the application has been created within the project directory. Using the project's namespace avoids name clashes with external modules (a topic that goes outside the scope of the quickstart).</source>
          <target state="translated">응용 프로그램이 프로젝트 디렉토리 내에 생성 된 경우가 드 unusual니다. 프로젝트의 네임 스페이스를 사용하면 외부 모듈 (퀵 스타트의 범위를 벗어난 주제)과 이름이 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47d3f7629ce94cafab1adf298950509e71d57a2c" translate="yes" xml:space="preserve">
          <source>It supports REST framework's flexible request parsing, rather than just supporting form data. For example you can handle incoming JSON data in the same way that you handle incoming form data.</source>
          <target state="translated">양식 데이터 만 지원하는 것이 아니라 REST 프레임 워크의 유연한 요청 구문 분석을 지원합니다. 예를 들어 들어오는 양식 데이터를 처리하는 것과 같은 방식으로 들어오는 JSON 데이터를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5550a262c3a6dc5adc02419121eef0532b3f36d5" translate="yes" xml:space="preserve">
          <source>It supports parsing the content of HTTP methods other than &lt;code&gt;POST&lt;/code&gt;, meaning that you can access the content of &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;PATCH&lt;/code&gt; requests.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 이외의 HTTP 메소드 컨텐츠 구문 분석을 지원하므로 &lt;code&gt;PUT&lt;/code&gt; 및 &lt;code&gt;PATCH&lt;/code&gt; 요청 의 컨텐츠에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0216659a21aa3c8864c201b56915e5c8b1355d25" translate="yes" xml:space="preserve">
          <source>It takes a single argument, which is the default value or callable that should be used during create operations.</source>
          <target state="translated">작성 조작 중에 사용해야하는 기본값 또는 호출 가능 인 단일 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f73ca6b5820dbd1d34dabe69681f867975dc08a3" translate="yes" xml:space="preserve">
          <source>It will automatically generate a set of fields for you, based on the model.</source>
          <target state="translated">모델을 기반으로 자동으로 일련의 필드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e4f16a93007447aded60f763defd492b8ea5191" translate="yes" xml:space="preserve">
          <source>It will automatically generate validators for the serializer, such as unique_together validators.</source>
          <target state="translated">unique_together 유효성 검사기와 같은 serializer에 대한 유효성 검사기를 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f00faa120a59687d5cfacd633db612d462d80f79" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to declaratively remove a &lt;code&gt;Field&lt;/code&gt; inherited from a parent class by setting the name to be &lt;code&gt;None&lt;/code&gt; on the subclass.</source>
          <target state="translated">서브 클래스 에서 이름을 &lt;code&gt;None&lt;/code&gt; 으로 설정하여 부모 클래스에서 상속 된 &lt;code&gt;Field&lt;/code&gt; 를 선언적으로 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd4bc6b7140224f7325e781dc5ffcc92230f1baa" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;code&gt;ModelSerializer&lt;/code&gt; classes don't do anything particularly magical, they are simply a shortcut for creating serializer classes:</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 클래스는 특히 마술적인 작업을 수행하지 않으며 단순히 serializer 클래스를 작성하기위한 지름길 이라는 것을 기억해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc441de95978246488d276533176f33b09b12a00" translate="yes" xml:space="preserve">
          <source>It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an &lt;code&gt;Accept: */*&lt;/code&gt; header, or not including an &lt;code&gt;Accept&lt;/code&gt; header at all, then REST framework will select the first renderer in the list to use for the response.</source>
          <target state="translated">API에 렌더러 클래스를 지정할 때 각 미디어 유형에 할당 할 우선 순위를 생각하는 것이 중요합니다. 클라이언트가 &lt;code&gt;Accept: */*&lt;/code&gt; 헤더 를 보내 거나 &lt;code&gt;Accept&lt;/code&gt; 헤더를 전혀 포함하지 않는 등 수용 할 수있는 표현을 지정 하지 않으면 REST 프레임 워크는 목록에서 응답에 사용할 첫 번째 렌더러를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="bef0da00280978aa509333261e0fcd736ce5b717" translate="yes" xml:space="preserve">
          <source>It's more explicit.</source>
          <target state="translated">더 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="a1802461a9236aa400c0aeb3c587dfe188ec8d4c" translate="yes" xml:space="preserve">
          <source>It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an &lt;code&gt;ordering_fields&lt;/code&gt; attribute on the view, like so:</source>
          <target state="translated">순서 필터에서 API가 허용해야하는 필드를 명시 적으로 지정하는 것이 좋습니다. 다음 과 같이보기에서 &lt;code&gt;ordering_fields&lt;/code&gt; 속성을 설정하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="119f7caa9a491e936157659c5a10864373a6cded" translate="yes" xml:space="preserve">
          <source>It's simple to create a read-only serializer for converting &lt;code&gt;HighScore&lt;/code&gt; instances into primitive data types.</source>
          <target state="translated">&lt;code&gt;HighScore&lt;/code&gt; 인스턴스를 기본 데이터 유형으로 변환하기위한 읽기 전용 직렬 변환기를 작성하는 것은 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="bd520dda2a94c71334a309ef953a11ec9a542392" translate="yes" xml:space="preserve">
          <source>It's unlikely that you'll want to provide a custom content negotiation scheme for REST framework, but you can do so if needed. To implement a custom content negotiation scheme override &lt;code&gt;BaseContentNegotiation&lt;/code&gt;.</source>
          <target state="translated">REST 프레임 워크에 대한 사용자 정의 컨텐츠 협상 체계를 제공하지는 않지만 필요한 경우 그렇게 할 수 있습니다. 사용자 정의 컨텐츠 협상 체계를 구현하려면 &lt;code&gt;BaseContentNegotiation&lt;/code&gt; 을 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0585b992d7aac528ea76ea1406db45df4c7284a" translate="yes" xml:space="preserve">
          <source>It's worth noting that there are a couple of edge cases we're not dealing with properly at the moment. If we send malformed &lt;code&gt;json&lt;/code&gt;, or if a request is made with a method that the view doesn't handle, then we'll end up with a 500 &quot;server error&quot; response. Still, this'll do for now.</source>
          <target state="translated">현재 제대로 다루지 않은 몇 가지 최첨단 사례가 있다는 점은 주목할 가치가 있습니다. 잘못된 &lt;code&gt;json&lt;/code&gt; 을 보내 거나 뷰가 처리하지 않는 메소드로 요청하면 500 &quot;서버 오류&quot;응답이 발생합니다. 아직도, 이것은 지금 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="de01153545640ea8f5d8eaea7a3207925bd7c514" translate="yes" xml:space="preserve">
          <source>JSON Web Token Authentication</source>
          <target state="translated">JSON 웹 토큰 인증</target>
        </trans-unit>
        <trans-unit id="5edfecd4fdbf652b383452f8a775274f059ce02d" translate="yes" xml:space="preserve">
          <source>JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is &lt;a href=&quot;https://github.com/davesque/django-rest-framework-simplejwt&quot;&gt;djangorestframework-simplejwt&lt;/a&gt; which provides some features as well as a pluggable token blacklist app.</source>
          <target state="translated">JSON 웹 토큰은 토큰 기반 인증에 사용할 수있는 상당히 새로운 표준입니다. 내장 된 TokenAuthentication 체계와 달리 JWT 인증은 데이터베이스를 사용하여 토큰을 검증 할 필요가 없습니다. JWT 인증을위한 패키지는 &lt;a href=&quot;https://github.com/davesque/django-rest-framework-simplejwt&quot;&gt;djangorestframework-simplejwt&lt;/a&gt; 이며 일부 기능과 플러그 가능한 토큰 블랙리스트 앱을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f59a6d4cc2a97dda0c89bb441b49907b8b863025" translate="yes" xml:space="preserve">
          <source>JSONField</source>
          <target state="translated">JSONField</target>
        </trans-unit>
        <trans-unit id="42c6036ddd5d662bc456c530699d3704be7c5087" translate="yes" xml:space="preserve">
          <source>JSONP</source>
          <target state="translated">JSONP</target>
        </trans-unit>
        <trans-unit id="a0216a4980b579f083b25149b2468bf86428d5ea" translate="yes" xml:space="preserve">
          <source>JSONParser</source>
          <target state="translated">JSONParser</target>
        </trans-unit>
        <trans-unit id="e353c458a12d999f0d4bbdbc6b1f599beaf87bfb" translate="yes" xml:space="preserve">
          <source>JSONRenderer</source>
          <target state="translated">JSONRenderer</target>
        </trans-unit>
        <trans-unit id="90ed5fa6126220d08ec26a8ab40e35372a119750" translate="yes" xml:space="preserve">
          <source>Kloudless</source>
          <target state="translated">Kloudless</target>
        </trans-unit>
        <trans-unit id="f7a9de65b78abbad1f3ee6660e9e4fe36f4edfd2" translate="yes" xml:space="preserve">
          <source>LaTeX</source>
          <target state="translated">LaTeX</target>
        </trans-unit>
        <trans-unit id="11430d6f172fc621cd992f45612278cf16c8aa09" translate="yes" xml:space="preserve">
          <source>Let's define a simple viewset that can be used to list or retrieve all the users in the system.</source>
          <target state="translated">시스템의 모든 사용자를 나열하거나 검색하는 데 사용할 수있는 간단한 뷰셋을 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="904c7e7fca08b12e4673be616da85008f5d57be2" translate="yes" xml:space="preserve">
          <source>Let's look at an example of serializing a class that represents an RGB color value:</source>
          <target state="translated">RGB 색상 값을 나타내는 클래스를 직렬화하는 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0b021bbe30818830a821ac55bafbb1c1571396d1" translate="yes" xml:space="preserve">
          <source>Let's look at refactoring our serializer using the &lt;code&gt;ModelSerializer&lt;/code&gt; class. Open the file &lt;code&gt;snippets/serializers.py&lt;/code&gt; again, and replace the &lt;code&gt;SnippetSerializer&lt;/code&gt; class with the following.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 사용하여 시리얼 라이저 리팩토링을 살펴 보자 . &lt;code&gt;snippets/serializers.py&lt;/code&gt; 파일을 다시 열고 &lt;code&gt;SnippetSerializer&lt;/code&gt; 클래스를 다음으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="1c29164e15ed47e4db7894d7c02c38030e9d458f" translate="yes" xml:space="preserve">
          <source>Let's see how we can write some API views using our new Serializer class. For the moment we won't use any of REST framework's other features, we'll just write the views as regular Django views.</source>
          <target state="translated">새로운 Serializer 클래스를 사용하여 일부 API 뷰를 작성하는 방법을 살펴 보겠습니다. 현재로서는 REST 프레임 워크의 다른 기능을 사용하지 않을 것입니다. 뷰를 일반 Django 뷰로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="99abeb391f09e909850d3b0dbc590326de05f3f4" translate="yes" xml:space="preserve">
          <source>Let's start by creating a simple object we can use for example purposes:</source>
          <target state="translated">예제 목적으로 사용할 수있는 간단한 객체를 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="06d9721cd9559d2d9305ad6bcdcdda65b8e07f9d" translate="yes" xml:space="preserve">
          <source>Let's take a look at a quick example of using REST framework to build a simple model-backed API.</source>
          <target state="translated">REST 프레임 워크를 사용하여 간단한 모델 기반 API를 빌드하는 간단한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1e7793ad2e72fe9924c787f70e34650fefd2c1c1" translate="yes" xml:space="preserve">
          <source>Let's take a look at how we can compose the views by using the mixin classes. Here's our &lt;code&gt;views.py&lt;/code&gt; module again.</source>
          <target state="translated">mixin 클래스를 사용하여 뷰를 작성하는 방법을 살펴 보겠습니다. 여기 &lt;code&gt;views.py&lt;/code&gt; 모듈이 다시 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff9884b7b6f5e3f9db79e7af0d777f74e824479" translate="yes" xml:space="preserve">
          <source>Let's take a look at the routes our &lt;code&gt;CustomReadOnlyRouter&lt;/code&gt; would generate for a simple viewset.</source>
          <target state="translated">&lt;code&gt;CustomReadOnlyRouter&lt;/code&gt; 가 간단한 뷰셋을 위해 생성 할 경로를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="58c27de43434b3af87cc3340f2c9f8575f00c7a9" translate="yes" xml:space="preserve">
          <source>Let's take our current set of views, and refactor them into view sets.</source>
          <target state="translated">현재 뷰 세트를 가져 와서 뷰 세트로 리팩토링합시다.</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSD 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a994ebc93a3a08ac2b67f2ffc76510f2752337d" translate="yes" xml:space="preserve">
          <source>Lights On Software</source>
          <target state="translated">소프트웨어 켜짐</target>
        </trans-unit>
        <trans-unit id="2d0c1881eb0924053da3bf4e8a4d29372381a8a9" translate="yes" xml:space="preserve">
          <source>Like Django's &lt;code&gt;Model&lt;/code&gt; and &lt;code&gt;ModelForm&lt;/code&gt; classes, the inner &lt;code&gt;Meta&lt;/code&gt; class on serializers does not implicitly inherit from it's parents' inner &lt;code&gt;Meta&lt;/code&gt; classes. If you want the &lt;code&gt;Meta&lt;/code&gt; class to inherit from a parent class you must do so explicitly. For example:</source>
          <target state="translated">Django의 &lt;code&gt;Model&lt;/code&gt; 및 &lt;code&gt;ModelForm&lt;/code&gt; 클래스 와 마찬가지로 serializer 의 내부 &lt;code&gt;Meta&lt;/code&gt; 클래스는 부모의 내부 &lt;code&gt;Meta&lt;/code&gt; 클래스 에서 암시 적으로 상속되지 않습니다 . 당신이 원하는 경우 &lt;code&gt;Meta&lt;/code&gt; 부모 클래스에서 상속 클래스를 그렇게 명시 적으로 수행해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49bb913ebaff42e34187e6b996b8f137042426a8" translate="yes" xml:space="preserve">
          <source>LimitOffsetPagination</source>
          <target state="translated">LimitOffsetPagination</target>
        </trans-unit>
        <trans-unit id="564341936ffd28cb7674aa7bacb111d57249566c" translate="yes" xml:space="preserve">
          <source>Limitations of object level permissions</source>
          <target state="translated">개체 수준 권한의 제한</target>
        </trans-unit>
        <trans-unit id="f6780b78279003920fe3e65b3f6a19861e8bd1d4" translate="yes" xml:space="preserve">
          <source>Limitations of validators</source>
          <target state="translated">유효성 검사기의 한계</target>
        </trans-unit>
        <trans-unit id="c1ada30218e6b0f89d0863bbd7df583839e7d726" translate="yes" xml:space="preserve">
          <source>ListAPIView</source>
          <target state="translated">ListAPIView</target>
        </trans-unit>
        <trans-unit id="306b3858e49600466e6aaecd4cafaa6d8486def3" translate="yes" xml:space="preserve">
          <source>ListCreateAPIView</source>
          <target state="translated">ListCreateAPIView</target>
        </trans-unit>
        <trans-unit id="dc0f9116c0ed8840cb05f3d2fc25a3fea1ab9b9e" translate="yes" xml:space="preserve">
          <source>ListField</source>
          <target state="translated">ListField</target>
        </trans-unit>
        <trans-unit id="a6ae9fad927530cbcad78bac97bf5bdad52b6dc7" translate="yes" xml:space="preserve">
          <source>ListModelMixin</source>
          <target state="translated">ListModelMixin</target>
        </trans-unit>
        <trans-unit id="112bb50edf0e9bb2a9303eb000e2e1c872cb9371" translate="yes" xml:space="preserve">
          <source>ListSerializer</source>
          <target state="translated">ListSerializer</target>
        </trans-unit>
        <trans-unit id="e5b6116211dc49c00b6ba2813a65d0d500fbecde" translate="yes" xml:space="preserve">
          <source>Live tests</source>
          <target state="translated">라이브 테스트</target>
        </trans-unit>
        <trans-unit id="a8a1b8d5b559559cb96805c720db5a2c866262b3" translate="yes" xml:space="preserve">
          <source>Load and render a template named &lt;code&gt;api_exception.html&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;api_exception.html&lt;/code&gt; 이라는 템플릿을로드하고 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="b6ebd4d8afb4cbc4c5512cf50d816bd9883eb8ac" translate="yes" xml:space="preserve">
          <source>Load and render a template named &lt;code&gt;{status_code}.html&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{status_code}.html&lt;/code&gt; 이라는 템플리트를로드하고 렌더링하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d6d8a4a3d80f7a9a4b0fca3ddd96b0e94466abd" translate="yes" xml:space="preserve">
          <source>Low-level API</source>
          <target state="translated">저수준 API</target>
        </trans-unit>
        <trans-unit id="b9266ae1b1357ffe2d4eca6b3b778ccd366b483e" translate="yes" xml:space="preserve">
          <source>Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms</source>
          <target state="translated">기계 상호 작용 웹 서비스는 단순한 형식보다 복잡한 데이터를 전송하기 때문에 양식 인코딩보다 데이터를 구조화하는 데보다 구조화 된 형식을 사용하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6bbf0c8455a5a154eb9129e7a6aefcde5a05680" translate="yes" xml:space="preserve">
          <source>Make sure to also import the &lt;code&gt;IsOwnerOrReadOnly&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;IsOwnerOrReadOnly&lt;/code&gt; 클래스 도 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="d9cb51edcb9160aa934afb5528b72a9d8742f63a" translate="yes" xml:space="preserve">
          <source>Make sure to also import the &lt;code&gt;UserSerializer&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;UserSerializer&lt;/code&gt; 클래스 도 가져와야합니다</target>
        </trans-unit>
        <trans-unit id="f36af64091c8859d03f0c5912aa8c3e10b3dd9b4" translate="yes" xml:space="preserve">
          <source>Making requests</source>
          <target state="translated">요구하다</target>
        </trans-unit>
        <trans-unit id="44254034717706abf23be9d0434653cbc1faac1b" translate="yes" xml:space="preserve">
          <source>Making sure our URL patterns are named</source>
          <target state="translated">URL 패턴의 이름이 지정되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="c756fe270b8985d04c9262bc94e893aff0304bbf" translate="yes" xml:space="preserve">
          <source>ManyToManyFields with a Through Model</source>
          <target state="translated">관통 모델이있는 ManyToManyFields</target>
        </trans-unit>
        <trans-unit id="d79a1aab3a17bad65199969b61243102bd5e687c" translate="yes" xml:space="preserve">
          <source>Marking extra actions for routing</source>
          <target state="translated">라우팅을위한 추가 작업 표시</target>
        </trans-unit>
        <trans-unit id="600bfef1abe8d0e1c456a49fe2df4331ff112218" translate="yes" xml:space="preserve">
          <source>May be a list including the string &lt;code&gt;'iso-8601'&lt;/code&gt; or Python &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.strftime&quot;&gt;strftime format&lt;/a&gt; strings.</source>
          <target state="translated">문자열 &lt;code&gt;'iso-8601'&lt;/code&gt; 또는 Python &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.strftime&quot;&gt;strftime 형식&lt;/a&gt; 문자열을 포함하는 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51a257cf42fc4b3eab836e1a8e71b59cda0cd5e5" translate="yes" xml:space="preserve">
          <source>May be any of &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;'iso-8601'&lt;/code&gt; or a Python &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.strftime&quot;&gt;strftime format&lt;/a&gt; string.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; , &lt;code&gt;'iso-8601'&lt;/code&gt; 또는 Python &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.strftime&quot;&gt;strftime 형식&lt;/a&gt; 문자열 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="309fffea75df437c55dda938dc7fd0439c6e1453" translate="yes" xml:space="preserve">
          <source>May be overridden in order modify the representation style. For example:</source>
          <target state="translated">표현 스타일을 수정하기 위해 재정의 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d232f33234b58abb0b97396f407734f3b5b4ee3f" translate="yes" xml:space="preserve">
          <source>May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.</source>
          <target state="translated">요청한 사용자에게 고유 한 쿼리 세트 반환과 같은 동적 동작을 제공하도록 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ed1eab7660c403df512f43c905cbff828fbcc1" translate="yes" xml:space="preserve">
          <source>May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.</source>
          <target state="translated">읽기 및 쓰기 작업에 다른 시리얼 라이저를 사용하거나 다른 유형의 사용자에게 다른 시리얼 라이저를 제공하는 등의 동적 동작을 제공하도록 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be850c6ec715e588b1182f79c3859e9a098fbcf7" translate="yes" xml:space="preserve">
          <source>May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.</source>
          <target state="translated">둘 이상의 URL 크워 그에 기반한 객체 조회와 같이보다 복잡한 동작을 제공하도록 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb41efa58f7013d13e02f03e76223b230d5ba77c" translate="yes" xml:space="preserve">
          <source>May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a &lt;code&gt;set_context&lt;/code&gt; method, that will be called each time before getting the value with the field instance as only argument. This works the same way as for &lt;a href=&quot;../validators/index#using-set_context&quot;&gt;validators&lt;/a&gt;.</source>
          <target state="translated">함수 또는 다른 호출 가능으로 설정 될 수 있으며,이 경우 값은 사용될 때마다 평가됩니다. 호출되면 인수를받지 않습니다. 호출 가능에 &lt;code&gt;set_context&lt;/code&gt; 메소드 가있는 경우, 필드 인스턴스를 인수로 사용하여 값을 가져 오기 전에 매번 호출됩니다. 이것은 &lt;a href=&quot;../validators/index#using-set_context&quot;&gt;유효성 검사기&lt;/a&gt; 와 같은 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="c55910840b646f30c3e90f59a7e53588f644254c" translate="yes" xml:space="preserve">
          <source>May raise a &lt;code&gt;NoReverseMatch&lt;/code&gt; if the &lt;code&gt;view_name&lt;/code&gt; and &lt;code&gt;lookup_field&lt;/code&gt; attributes are not configured to correctly match the URL conf.</source>
          <target state="translated">인상 수 &lt;code&gt;NoReverseMatch&lt;/code&gt; 을 경우 &lt;code&gt;view_name&lt;/code&gt; 및 &lt;code&gt;lookup_field&lt;/code&gt; 속성이 올바르게 URL의 conf에 맞게 구성되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af53d2dce04c62e3e92af2c39cb841727b1e7e55" translate="yes" xml:space="preserve">
          <source>May raise an &lt;code&gt;ObjectDoesNotExist&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;ObjectDoesNotExist&lt;/code&gt; 예외 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5201c043e16e7a0ac4f0e2a4a40238c3bd7da510" translate="yes" xml:space="preserve">
          <source>MessagePack</source>
          <target state="translated">MessagePack</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="c409ac10f925f09e05ca03d4b4646dd99af196e5" translate="yes" xml:space="preserve">
          <source>MethodNotAllowed</source>
          <target state="translated">MethodNotAllowed</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="c98ad1d5db9150d3f175cf2295299e8b76c2f1d8" translate="yes" xml:space="preserve">
          <source>Methods which create a request body, such as &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt;, include a &lt;code&gt;format&lt;/code&gt; argument, which make it easy to generate requests using a content type other than multipart form data. For example:</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 와 같이 요청 본문을 작성하는 메소드 에는 &lt;code&gt;format&lt;/code&gt; 인수가 포함되어있어 멀티 파트 양식 데이터 이외의 컨텐츠 유형을 사용하여 요청을 쉽게 생성 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee13aed6dc4feb8283d2bed86ae043a77f90f953" translate="yes" xml:space="preserve">
          <source>Might receive an error response indicating that the &lt;code&gt;DELETE&lt;/code&gt; method is not allowed on that resource:</source>
          <target state="translated">해당 자원 에서 &lt;code&gt;DELETE&lt;/code&gt; 메소드가 허용되지 않음을 나타내는 오류 응답이 수신 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="354cd645556020593b0ddc51a1a65ab7eec9acad" translate="yes" xml:space="preserve">
          <source>Miscellaneous fields</source>
          <target state="translated">기타 분야</target>
        </trans-unit>
        <trans-unit id="5f4aefdba022099873bc3ea5cdff46a438a420e7" translate="yes" xml:space="preserve">
          <source>Miscellaneous settings</source>
          <target state="translated">기타 설정</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="6c659d2c52e971112d67311c8e4477ec032d2d29" translate="yes" xml:space="preserve">
          <source>Model fields which have &lt;code&gt;editable=False&lt;/code&gt; set, and &lt;code&gt;AutoField&lt;/code&gt; fields will be set to read-only by default, and do not need to be added to the &lt;code&gt;read_only_fields&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;editable=False&lt;/code&gt; 로 설정되고 &lt;code&gt;AutoField&lt;/code&gt; 필드가있는 모델 필드는 기본적으로 읽기 전용으로 설정되며 &lt;code&gt;read_only_fields&lt;/code&gt; 옵션에 추가 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20233b15ec4eaace9bf40b99efff28da318e72ea" translate="yes" xml:space="preserve">
          <source>ModelField</source>
          <target state="translated">ModelField</target>
        </trans-unit>
        <trans-unit id="2ae71d93471d439d05478926f6c85bc2e8f036ab" translate="yes" xml:space="preserve">
          <source>ModelRouter (wq.db.rest)</source>
          <target state="translated">ModelRouter (wq.db.rest)</target>
        </trans-unit>
        <trans-unit id="abc9d80ad7826b7154e0703775e6ea613d364fd9" translate="yes" xml:space="preserve">
          <source>ModelSerializer</source>
          <target state="translated">ModelSerializer</target>
        </trans-unit>
        <trans-unit id="3122ab99af076e422932449b2acceea1dc9fbf92" translate="yes" xml:space="preserve">
          <source>ModelViewSet</source>
          <target state="translated">ModelViewSet</target>
        </trans-unit>
        <trans-unit id="c96bc5f21b84fdbac4fd25f909c04e8ae0a9ea0b" translate="yes" xml:space="preserve">
          <source>Modify your REST framework settings.</source>
          <target state="translated">REST 프레임 워크 설정을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="4f8bd2fd992ef312b6a60b9e2f786f7c96efb4e6" translate="yes" xml:space="preserve">
          <source>Modifying the &lt;code&gt;fields&lt;/code&gt; argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; 인수를 직접 수정하면 serializer를 선언하는 시점이 아니라 런타임에 serializer 필드의 인수를 변경하는 등 흥미로운 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af95d503f7be2b1c6564a54322423da9bf96027" translate="yes" xml:space="preserve">
          <source>Modifying the behavior slightly for an existing class.</source>
          <target state="translated">기존 클래스의 동작을 약간 수정합니다.</target>
        </trans-unit>
        <trans-unit id="955a9ea46ba696b745329e3bffd1e76425d542d5" translate="yes" xml:space="preserve">
          <source>Modifying the pagination style</source>
          <target state="translated">페이지 매김 스타일 수정</target>
        </trans-unit>
        <trans-unit id="43e9f2c4dc036e24692981311061267704d50098" translate="yes" xml:space="preserve">
          <source>MongoengineModelSerializer</source>
          <target state="translated">MongoengineModelSerializer</target>
        </trans-unit>
        <trans-unit id="4a58a6d0d305d33b199ca24fb8798c0cc7d59598" translate="yes" xml:space="preserve">
          <source>More specific media types are given preference to less specific media types.</source>
          <target state="translated">보다 구체적인 용지 종류가 덜 특정한 용지 종류보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3fb1418cf62c4fd295cddf0cf4a834a54c4dd9c4" translate="yes" xml:space="preserve">
          <source>Most error responses will include a key &lt;code&gt;detail&lt;/code&gt; in the body of the response.</source>
          <target state="translated">대부분의 오류 응답에는 응답 본문에 주요 &lt;code&gt;detail&lt;/code&gt; 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1c67877584246667dd88bc3657b49471101da6b" translate="yes" xml:space="preserve">
          <source>Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.</source>
          <target state="translated">REST 프레임 워크에서 유효성 검사를 처리하는 대부분의 경우 단순히 기본 필드 유효성 검사에 의존하거나 직렬화 기 또는 필드 클래스에서 명시 적 유효성 검사 방법을 작성하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="863384085f5473b735f70fd4eadebf806998987e" translate="yes" xml:space="preserve">
          <source>MultiPartParser</source>
          <target state="translated">MultiPartParser</target>
        </trans-unit>
        <trans-unit id="f7e4c356d6516eabadc165f884b2f2cff58442b0" translate="yes" xml:space="preserve">
          <source>MultiPartRenderer</source>
          <target state="translated">MultiPartRenderer</target>
        </trans-unit>
        <trans-unit id="7eae13bc0896675231af763681ea0b1b10aedf8f" translate="yes" xml:space="preserve">
          <source>Multiple orderings may also be specified:</source>
          <target state="translated">여러 주문을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aedbdb9585b0330432b09edb3a1d29d4df6207d" translate="yes" xml:space="preserve">
          <source>Multiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.</source>
          <target state="translated">버스트 스로틀 속도와 지속적인 스로틀 속도를 모두 적용하려는 경우 여러 스로틀을 사용할 수도 있습니다. 예를 들어, 사용자를 분당 최대 60 개의 요청과 하루에 1,000 개의 요청으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d7245b8071be6e0d4ed5e5e25c51cb7557b63b" translate="yes" xml:space="preserve">
          <source>MultipleChoiceField</source>
          <target state="translated">MultipleChoiceField</target>
        </trans-unit>
        <trans-unit id="d9d7a5dc9af65279e928590272bbc3c5d16adf7e" translate="yes" xml:space="preserve">
          <source>NGINX (Restricting Access)</source>
          <target state="translated">NGINX (액세스 제한)</target>
        </trans-unit>
        <trans-unit id="49004ae8ebb6e8eeccce26741f201d54cca5438f" translate="yes" xml:space="preserve">
          <source>NON_FIELD_ERRORS_KEY</source>
          <target state="translated">NON_FIELD_ERRORS_KEY</target>
        </trans-unit>
        <trans-unit id="e47bdf59a4e98e24c8b152a477e9902db7ac2a25" translate="yes" xml:space="preserve">
          <source>NUM_PROXIES</source>
          <target state="translated">NUM_PROXIES</target>
        </trans-unit>
        <trans-unit id="7639c0dde3f513851856cfc2e086de94e2d9ec3e" translate="yes" xml:space="preserve">
          <source>NamespaceVersioning</source>
          <target state="translated">NamespaceVersioning</target>
        </trans-unit>
        <trans-unit id="ace851b6926724f1e5cb214cee9cf5d6e2a14f54" translate="yes" xml:space="preserve">
          <source>Namespaces are one honking great idea - let's do more of those!</source>
          <target state="translated">네임 스페이스는 훌륭한 아이디어 중 하나입니다. 더 많은 것을 해보자!</target>
        </trans-unit>
        <trans-unit id="021cfd32aa503c2616fa2414404cee36ba4b5847" translate="yes" xml:space="preserve">
          <source>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">특정 사전 서면 허가없이 저작권 소유자의 이름이나 제공자의 이름을 사용하여이 소프트웨어에서 파생 된 제품을 보증하거나 홍보 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ceaea2d81e75f0cf43b4cfd0d5f710806ad0dc77" translate="yes" xml:space="preserve">
          <source>Nested relationships</source>
          <target state="translated">중첩 된 관계</target>
        </trans-unit>
        <trans-unit id="3d9c564782d961503e2b118d6d4fd59571ca0daa" translate="yes" xml:space="preserve">
          <source>Nested relationships can be expressed by using serializers as fields.</source>
          <target state="translated">시리얼 라이저를 필드로 사용하여 중첩 관계를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb73d4bd00e6a61f6ec08ef4896d393cb812093" translate="yes" xml:space="preserve">
          <source>Nesting the related entity inside the parent representation.</source>
          <target state="translated">부모 표현 내에 관련 엔터티 중첩</target>
        </trans-unit>
        <trans-unit id="563c6c1a5c19f0811bbbf8613d1e0cb072569565" translate="yes" xml:space="preserve">
          <source>Next we'll move onto &lt;a href=&quot;../4-authentication-and-permissions/index&quot;&gt;part 4 of the tutorial&lt;/a&gt;, where we'll take a look at how we can deal with authentication and permissions for our API.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../4-authentication-and-permissions/index&quot;&gt;자습서의 4 부로&lt;/a&gt; 넘어 가서 API에 대한 인증 및 권한을 처리하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="95018ee5edec4492d349911b3b4d675c9fb34667" translate="yes" xml:space="preserve">
          <source>Next we're going to replace the &lt;code&gt;SnippetList&lt;/code&gt;, &lt;code&gt;SnippetDetail&lt;/code&gt; and &lt;code&gt;SnippetHighlight&lt;/code&gt; view classes. We can remove the three views, and again replace them with a single class.</source>
          <target state="translated">다음으로 &lt;code&gt;SnippetList&lt;/code&gt; , &lt;code&gt;SnippetDetail&lt;/code&gt; 및 &lt;code&gt;SnippetHighlight&lt;/code&gt; 뷰 클래스 를 교체 하겠습니다 . 세 개의 뷰를 제거하고 다시 단일 클래스로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c905dba689783614e7cd8189d7380a8142bf699" translate="yes" xml:space="preserve">
          <source>Normal Python name resolution rules apply. If you have multiple base classes that declare a &lt;code&gt;Meta&lt;/code&gt; inner class, only the first one will be used. This means the child&amp;rsquo;s &lt;code&gt;Meta&lt;/code&gt;, if it exists, otherwise the &lt;code&gt;Meta&lt;/code&gt; of the first parent, etc.</source>
          <target state="translated">일반적인 파이썬 이름 확인 규칙이 적용됩니다. &lt;code&gt;Meta&lt;/code&gt; 내부 클래스 를 선언하는 여러 기본 클래스가있는 경우 첫 번째 클래스 만 사용됩니다. 이것은 아이의 &lt;code&gt;Meta&lt;/code&gt; 가 존재한다면 존재하고 그렇지 않으면 첫 번째 부모 의 &lt;code&gt;Meta&lt;/code&gt; 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd2b2ba443db2dceac1b295aa6fe8f27d2cdd2a2" translate="yes" xml:space="preserve">
          <source>Normally an error will be raised if &lt;code&gt;None&lt;/code&gt; is passed to a serializer field. Set this keyword argument to &lt;code&gt;True&lt;/code&gt; if &lt;code&gt;None&lt;/code&gt; should be considered a valid value.</source>
          <target state="translated">Serializer 필드에 &lt;code&gt;None&lt;/code&gt; 이 전달 되면 일반적으로 오류가 발생 합니다. 이 키워드 인수를 설정 &lt;code&gt;True&lt;/code&gt; 경우 &lt;code&gt;None&lt;/code&gt; 유효한 값으로 간주 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cfa88a4facfababc3dd2966348f27ac24f02da1" translate="yes" xml:space="preserve">
          <source>Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.</source>
          <target state="translated">역 직렬화 중에 필드가 제공되지 않으면 일반적으로 오류가 발생합니다. 역 직렬화 중에이 필드가 필요하지 않으면 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d01db10d7fe90908f5a77af80aa3dceb7126434c" translate="yes" xml:space="preserve">
          <source>Normally if a &lt;code&gt;ModelSerializer&lt;/code&gt; does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular &lt;code&gt;Serializer&lt;/code&gt; class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.</source>
          <target state="translated">일반적으로 &lt;code&gt;ModelSerializer&lt;/code&gt; 가 기본적으로 필요한 필드를 생성하지 않으면 클래스에 명시 적으로 추가하거나 일반 &lt;code&gt;Serializer&lt;/code&gt; 클래스를 대신 사용해야합니다 . 그러나 어떤 경우에는 주어진 모델에 대해 serializer 필드를 만드는 방법을 정의하는 새로운 기본 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9938c294364da7574cb05e6594e42e34971069" translate="yes" xml:space="preserve">
          <source>NotAcceptable</source>
          <target state="translated">NotAcceptable</target>
        </trans-unit>
        <trans-unit id="8f8b6f2ee757b6c9e5df1167f887827ef9452eae" translate="yes" xml:space="preserve">
          <source>NotAuthenticated</source>
          <target state="translated">NotAuthenticated</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="e5a922bed6a458ec817e7586eeeca1baf25e44a5" translate="yes" xml:space="preserve">
          <source>Note however that upon removal of the &lt;code&gt;queryset&lt;/code&gt; property from your &lt;code&gt;ViewSet&lt;/code&gt;, any associated &lt;a href=&quot;../routers/index&quot;&gt;router&lt;/a&gt; will be unable to derive the basename of your Model automatically, and so you will have to specify the &lt;code&gt;basename&lt;/code&gt; kwarg as part of your &lt;a href=&quot;../routers/index&quot;&gt;router registration&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;ViewSet&lt;/code&gt; 에서 &lt;code&gt;queryset&lt;/code&gt; 속성을 제거 하면 연결된 &lt;a href=&quot;../routers/index&quot;&gt;라우터&lt;/a&gt; 가 모델의 기본 이름을 자동으로 파생시킬 수 없으므로 &lt;a href=&quot;../routers/index&quot;&gt;라우터 등록의&lt;/a&gt; 일부로 &lt;code&gt;basename&lt;/code&gt; kwarg 를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="975f0540cd60e834b13127b5d5fbe494caa1beb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DjangoObjectPermissions&lt;/code&gt;&lt;strong&gt;does not&lt;/strong&gt; require the &lt;code&gt;django-guardian&lt;/code&gt; package, and should support other object-level backends equally well.</source>
          <target state="translated">참고 &lt;code&gt;DjangoObjectPermissions&lt;/code&gt; 가&lt;strong&gt;되지 않는&lt;/strong&gt; 요구] &lt;code&gt;django-guardian&lt;/code&gt; 패키지를 똑같이 다른 개체 수준 백엔드를 지원해야한다.</target>
        </trans-unit>
        <trans-unit id="90eff0cb4d0c7b580ecfbdece0b0f7b7aee83d68" translate="yes" xml:space="preserve">
          <source>Note that Django 2.1 removed the &lt;code&gt;blank&lt;/code&gt; kwarg from &lt;code&gt;models.BooleanField&lt;/code&gt;. Prior to Django 2.1 &lt;code&gt;models.BooleanField&lt;/code&gt; fields were always &lt;code&gt;blank=True&lt;/code&gt;. Thus since Django 2.1 default &lt;code&gt;serializers.BooleanField&lt;/code&gt; instances will be generated without the &lt;code&gt;required&lt;/code&gt; kwarg (i.e. equivalent to &lt;code&gt;required=True&lt;/code&gt;) whereas with previous versions of Django, default &lt;code&gt;BooleanField&lt;/code&gt; instances will be generated with a &lt;code&gt;required=False&lt;/code&gt; option. If you want to control this behaviour manually, explicitly declare the &lt;code&gt;BooleanField&lt;/code&gt; on the serializer class, or use the &lt;code&gt;extra_kwargs&lt;/code&gt; option to set the &lt;code&gt;required&lt;/code&gt; flag.</source>
          <target state="translated">참고 장고 2.1 제거 된 것을 &lt;code&gt;blank&lt;/code&gt; 에서 kwarg &lt;code&gt;models.BooleanField&lt;/code&gt; 을 . Django 2.1 이전의 &lt;code&gt;models.BooleanField&lt;/code&gt; 필드는 항상 &lt;code&gt;blank=True&lt;/code&gt; 입니다. 따라서 Django 2.1 기본 &lt;code&gt;serializers.BooleanField&lt;/code&gt; 인스턴스는 &lt;code&gt;required&lt;/code&gt; kwarg 없이 생성 되므로 (즉 &lt;code&gt;required=True&lt;/code&gt; 와 동일 ) 이전 버전의 Django에서는 기본 &lt;code&gt;BooleanField&lt;/code&gt; 인스턴스가 &lt;code&gt;required=False&lt;/code&gt; 옵션 으로 생성됩니다 . 이 동작을 수동으로 제어 하려면 serializer 클래스 에서 &lt;code&gt;BooleanField&lt;/code&gt; 를 명시 적으로 선언 하거나 &lt;code&gt;extra_kwargs&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;required&lt;/code&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="f99a7244f261dcb89ae28d36fbddd3b4580a65f1" translate="yes" xml:space="preserve">
          <source>Note that because we want to be able to POST to this view from clients that won't have a CSRF token we need to mark the view as &lt;code&gt;csrf_exempt&lt;/code&gt;. This isn't something that you'd normally want to do, and REST framework views actually use more sensible behavior than this, but it'll do for our purposes right now.</source>
          <target state="translated">CSRF 토큰이없는 클라이언트에서이 뷰에 POST를 수행하려면 뷰를 &lt;code&gt;csrf_exempt&lt;/code&gt; 로 표시해야합니다 . 이것은 일반적으로하고 싶은 것이 아니며 REST 프레임 워크보기는 실제로 이것보다 더 합리적인 행동을 사용하지만 지금은 우리의 목적을 위해 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce0572936be3b58ff956a8a91bef728ca1ca2cfd" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;credentials&lt;/code&gt; a second time overwrites any existing credentials. You can unset any existing credentials by calling the method with no arguments.</source>
          <target state="translated">&lt;code&gt;credentials&lt;/code&gt; 을 두 번 호출 하면 기존 자격 증명을 덮어 씁니다. 인수없이 메소드를 호출하여 기존 신임 정보를 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c81450495eee7e283d07e55bc2286b993c3d650" translate="yes" xml:space="preserve">
          <source>Note that due to implementation reasons the &lt;code&gt;Request&lt;/code&gt; class does not inherit from &lt;code&gt;HttpRequest&lt;/code&gt; class, but instead extends the class using composition.</source>
          <target state="translated">구현 이유 때문에 &lt;code&gt;Request&lt;/code&gt; 클래스는 &lt;code&gt;HttpRequest&lt;/code&gt; 클래스 에서 상속되지 않고 컴포지션을 사용하여 클래스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="a8c96ab3d91a0abbb188832bd93189c28aba2f0a" translate="yes" xml:space="preserve">
          <source>Note that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.</source>
          <target state="translated">필터 백엔드가보기에 대해 구성되고 목록보기를 필터링하는 데 사용되는 경우 단일 오브젝트를 리턴하는 데 사용되는 조회 세트를 필터링하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ab7494e1243079f42e1cd890778433302bece29" translate="yes" xml:space="preserve">
          <source>Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the &lt;code&gt;Response&lt;/code&gt; class, with the &lt;code&gt;charset&lt;/code&gt; attribute set on the renderer used to determine the encoding.</source>
          <target state="translated">렌더러 클래스가 유니 코드 문자열을 반환하는 경우 &lt;code&gt;Response&lt;/code&gt; 클래스 는 응답 클래스에 의해 인코딩을 결정하는 데 사용 된 렌더러 의 &lt;code&gt;charset&lt;/code&gt; 집합 속성 을 사용하여 바이트 문자열로 강제 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="034578091bfdbc3210bec0abd501cafa21fa9602" translate="yes" xml:space="preserve">
          <source>Note that if deploying to &lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIPassAuthorization.html&quot;&gt;Apache using mod_wsgi&lt;/a&gt;, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.</source>
          <target state="translated">&lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIPassAuthorization.html&quot;&gt;mod_wsgi를 사용하여 Apache에&lt;/a&gt; 배포하는 경우 인증 수준은 응용 프로그램 수준이 아닌 Apache에 의해 처리된다고 가정하므로 기본적으로 권한 부여 헤더는 WSGI 응용 프로그램으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f57e804278bb4ef65d7a89b351da7c78057dc865" translate="yes" xml:space="preserve">
          <source>Note that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an &lt;code&gt;OrderedDict&lt;/code&gt; when constructing the body of paginated responses, but this is optional.</source>
          <target state="translated">찾아보기 가능한 API에서 응답에 키 순서가 표시되는 방식에 관심이있는 경우 페이지 매김 된 응답 본문을 구성 할 때 &lt;code&gt;OrderedDict&lt;/code&gt; 를 사용하도록 선택할 수 있지만 이는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="5a12784a97580e76e90704a81cd9aa2b36c7c31d" translate="yes" xml:space="preserve">
          <source>Note that if you wanted to use this style together with the generic views then you'd also need to override &lt;code&gt;.get_object&lt;/code&gt; on the view in order to get the correct lookup behavior.</source>
          <target state="translated">이 스타일을 일반 뷰와 함께 사용 하려면 올바른 조회 동작을 얻기 위해 뷰에서 &lt;code&gt;.get_object&lt;/code&gt; 를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="62327bda9dad5555899953d87c3f029a029dd302" translate="yes" xml:space="preserve">
          <source>Note that if your API doesn't include any object level permissions, you may optionally exclude the &lt;code&gt;self.check_object_permissions&lt;/code&gt;, and simply return the object from the &lt;code&gt;get_object_or_404&lt;/code&gt; lookup.</source>
          <target state="translated">API에 객체 수준 권한이 포함되어 있지 않은 경우 선택적으로 &lt;code&gt;self.check_object_permissions&lt;/code&gt; 를 제외 하고 &lt;code&gt;get_object_or_404&lt;/code&gt; 조회 에서 객체를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f82c866f47484d86dc27da76d3650c3623738507" translate="yes" xml:space="preserve">
          <source>Note that in the case above we're now having to access the serializer &lt;code&gt;.validated_data&lt;/code&gt; property directly.</source>
          <target state="translated">위의 경우 serializer &lt;code&gt;.validated_data&lt;/code&gt; 속성에 직접 액세스해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f0f522dd57619627316dbd03f7597a05f405ef1a" translate="yes" xml:space="preserve">
          <source>Note that reverse generic keys, expressed using the &lt;code&gt;GenericRelation&lt;/code&gt; field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.</source>
          <target state="translated">관계의 대상 유형이 항상 알려져 있기 때문에 &lt;code&gt;GenericRelation&lt;/code&gt; 필드를 사용하여 표현 된 리버스 일반 키 는 일반 관계형 필드 유형을 사용하여 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c369602f4e84310271ec1a921233e937bc481e" translate="yes" xml:space="preserve">
          <source>Note that reverse relationships are not automatically included by the &lt;code&gt;ModelSerializer&lt;/code&gt; and &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:</source>
          <target state="translated">역관계는 &lt;code&gt;ModelSerializer&lt;/code&gt; 및 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 클래스에 의해 자동으로 포함되지 않습니다 . 역관계를 포함 시키려면 명시 적으로 필드 목록에 관계를 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f51c4c71472aa43c6b40b63007fc76da9c755e1c" translate="yes" xml:space="preserve">
          <source>Note that setting a &lt;code&gt;default&lt;/code&gt; value implies that the field is not required. Including both the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;required&lt;/code&gt; keyword arguments is invalid and will raise an error.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 을 설정 하면 필드가 필요하지 않다는 것을 의미합니다. &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;required&lt;/code&gt; 키워드 인수를 모두 포함하는 것은 유효하지 않으며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22b4f44b3219bb7f374733f32a2860a154923f53" translate="yes" xml:space="preserve">
          <source>Note that settings in REST framework are all namespaced into a single dictionary setting, named &lt;code&gt;REST_FRAMEWORK&lt;/code&gt;, which helps keep them well separated from your other project settings.</source>
          <target state="translated">REST 프레임 워크의 설정은 모두 이름 공간이 &lt;code&gt;REST_FRAMEWORK&lt;/code&gt; 인 단일 사전 설정으로 이름 지정 되어 다른 프로젝트 설정과 잘 분리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ded6d2a5e51d60d080fd400bac7c49c9f83e3394" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;WritableField&lt;/code&gt; class that was present in version 2.x no longer exists. You should subclass &lt;code&gt;Field&lt;/code&gt; and override &lt;code&gt;to_internal_value()&lt;/code&gt; if the field supports data input.</source>
          <target state="translated">있습니다 &lt;code&gt;WritableField&lt;/code&gt; 의 버전 2.x에 존재 클래스가 더 이상 존재하지 않습니다. 필드가 데이터 입력을 지원하는 경우 &lt;code&gt;Field&lt;/code&gt; 를 서브 클래 싱 하고 &lt;code&gt;to_internal_value()&lt;/code&gt; 재정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2d766bd22054602e34c5ebfce824a8df70c9ccae" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;basename&lt;/code&gt; is provided by the router during &lt;code&gt;ViewSet&lt;/code&gt; registration. If you are not using a router, then you must provide the &lt;code&gt;basename&lt;/code&gt; argument to the &lt;code&gt;.as_view()&lt;/code&gt; method.</source>
          <target state="translated">점을 유의 &lt;code&gt;basename&lt;/code&gt; 중 라우터에 의해 제공되는 &lt;code&gt;ViewSet&lt;/code&gt; 등록. 라우터를 사용하지 않는 경우 &lt;code&gt;.as_view()&lt;/code&gt; 메소드에 &lt;code&gt;basename&lt;/code&gt; 인수를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b24fb947c3ec202c6667db8edb60bcba9426f91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;paginate_queryset&lt;/code&gt; method may set state on the pagination instance, that may later be used by the &lt;code&gt;get_paginated_response&lt;/code&gt; method.</source>
          <target state="translated">참고는 것을 &lt;code&gt;paginate_queryset&lt;/code&gt; 에 있어서, 상기 페이징 인스턴스의 상태를 설정할 수있다, 즉 이후에 의해 사용될 수있다 &lt;code&gt;get_paginated_response&lt;/code&gt; 의 방법.</target>
        </trans-unit>
        <trans-unit id="32adc52f2a2a0f537e56bc32f313b5bfe1537216" translate="yes" xml:space="preserve">
          <source>Note that the URL part of the pattern can be whatever you want to use.</source>
          <target state="translated">패턴의 URL 부분은 원하는대로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ace64253d89d4f92cd067c9fc017e3ba06e0c99" translate="yes" xml:space="preserve">
          <source>Note that the URL path can be whatever you want.</source>
          <target state="translated">URL 경로는 원하는대로 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89407dd6375887a6497e32b6b368f623dff66c2f" translate="yes" xml:space="preserve">
          <source>Note that the child field &lt;strong&gt;must&lt;/strong&gt; be an instance of &lt;code&gt;CharField&lt;/code&gt;, as the hstore extension stores values as strings.</source>
          <target state="translated">hstore 확장은 값을 문자열로 저장 하므로 자식 필드 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;CharField&lt;/code&gt; 의 인스턴스 &lt;strong&gt;여야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="df9f392faad7ae769aa54b826c2a96f6094089ad" translate="yes" xml:space="preserve">
          <source>Note that the default &lt;code&gt;obtain_auth_token&lt;/code&gt; view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.</source>
          <target state="translated">기본 &lt;code&gt;obtain_auth_token&lt;/code&gt; 뷰는 설정에서 기본 렌더러 및 파서 클래스를 사용하지 않고 명시 적으로 JSON 요청 및 응답을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="545e627cf8a83235ec83ee1b070ff96ab989dc77" translate="yes" xml:space="preserve">
          <source>Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:</source>
          <target state="translated">기본 스타일은 유니 코드 문자를 포함하고 불필요한 공백이없는 간단한 스타일을 사용하여 응답을 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b7daff09926cee1b3d519f2a3e717c6d9b5d708" translate="yes" xml:space="preserve">
          <source>Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the &lt;code&gt;HTTP_400_BAD_REQUEST&lt;/code&gt; responses that are returned by the generic views when serializer validation fails.</source>
          <target state="translated">예외 핸들러는 발생한 예외에 의해 생성 된 응답에 대해서만 호출됩니다. 직렬화 기 유효성 검증에 실패 할 때 일반보기에서 리턴되는 &lt;code&gt;HTTP_400_BAD_REQUEST&lt;/code&gt; 응답 과 같이보기에서 직접 리턴 된 응답에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ab6e7bbce3678676095a4c2052e08b275222f00" translate="yes" xml:space="preserve">
          <source>Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.</source>
          <target state="translated">첫 번째 그룹은 괄호로 묶여 호스트 이름과 일치 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b2cd7d3bf0f3d5f13610310be23e9c77b889ba52" translate="yes" xml:space="preserve">
          <source>Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling &lt;code&gt;self.check_object_permissions(request, obj)&lt;/code&gt; from the view once you have the object instance. This call will raise an appropriate &lt;code&gt;APIException&lt;/code&gt; if any object-level permission checks fail, and will otherwise simply return.</source>
          <target state="translated">일반보기는 적절한 개체 수준 권한을 확인하지만 고유 한 사용자 지정보기를 작성하는 경우 개체 수준 권한 확인을 직접 확인해야합니다. 객체 인스턴스가 있으면 뷰에서 &lt;code&gt;self.check_object_permissions(request, obj)&lt;/code&gt; 를 호출 하면됩니다. 이 호출은 객체 수준 권한 검사가 실패 하면 적절한 &lt;code&gt;APIException&lt;/code&gt; 을 발생시키고 그렇지 않으면 단순히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83a60566b56c0507eee502eca8d9f229ddec0346" translate="yes" xml:space="preserve">
          <source>Note that the requests client requires you to pass fully qualified URLs.</source>
          <target state="translated">요청 클라이언트는 정규화 된 URL을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a49fafd1499d557b435925e09a86a5f63bad017" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serialiser using &lt;code&gt;source='*'&lt;/code&gt;, with two &lt;code&gt;IntegerField&lt;/code&gt; instances, each with their own &lt;code&gt;source&lt;/code&gt; pointing to the relevant field.</source>
          <target state="translated">이 예제는 유효성 검사를 처리하지 않습니다. 이러한 이유로 부분적으로 실제 프로젝트에서 &lt;code&gt;source='*'&lt;/code&gt; 를 사용하여 중첩 된 serialiser를 사용하여 좌표 중첩을보다 잘 처리 할 수 ​​있습니다 . 각각의 &lt;code&gt;source&lt;/code&gt; 는 관련 필드를 가리키는 두 개의 &lt;code&gt;IntegerField&lt;/code&gt; 인스턴스를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="43a306ac1cf4de274fcf85a8523f170cd74827ad" translate="yes" xml:space="preserve">
          <source>Note that views that have nested or list serializers for their input won't work well with the &lt;code&gt;AdminRenderer&lt;/code&gt;, as the HTML forms are unable to properly support them.</source>
          <target state="translated">HTML 양식이 제대로 지원할 수 없으므로 입력에 대해 중첩 또는 나열 직렬 변환기가있는보기는 &lt;code&gt;AdminRenderer&lt;/code&gt; 에서 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a94b60b378243f42925aa9a3cbd8c54938fc87fb" translate="yes" xml:space="preserve">
          <source>Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a &lt;code&gt;403 Permission Denied&lt;/code&gt; response will always be used, regardless of the authentication scheme.</source>
          <target state="translated">요청이 성공적으로 인증 될 수 있지만 요청을 수행 할 수있는 권한이 여전히 거부 될 경우 인증 체계에 관계없이 &lt;code&gt;403 Permission Denied&lt;/code&gt; 응답이 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73311b41a697ea50e8a566522f602aa8b8de45af" translate="yes" xml:space="preserve">
          <source>Note that you can use any of the standard attributes or method overrides provided by &lt;code&gt;GenericAPIView&lt;/code&gt;. For example, to use a &lt;code&gt;ViewSet&lt;/code&gt; that dynamically determines the queryset it should operate on, you might do something like this:</source>
          <target state="translated">&lt;code&gt;GenericAPIView&lt;/code&gt; 가 제공하는 표준 속성 또는 메소드 대체를 사용할 수 있습니다 . 예를 들어, 작동해야하는 &lt;code&gt;ViewSet&lt;/code&gt; 를 동적으로 결정 하는 ViewSet 을 사용하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="f822231cef91e6252a6e2e12481059ebda5f74d7" translate="yes" xml:space="preserve">
          <source>Note that you can use both an overridden &lt;code&gt;.get_queryset()&lt;/code&gt; and generic filtering together, and everything will work as expected. For example, if &lt;code&gt;Product&lt;/code&gt; had a many-to-many relationship with &lt;code&gt;User&lt;/code&gt;, named &lt;code&gt;purchase&lt;/code&gt;, you might want to write a view like this:</source>
          <target state="translated">재정의 된 &lt;code&gt;.get_queryset()&lt;/code&gt; 및 일반 필터링을 함께 사용할 수 있으며 모든 것이 예상대로 작동합니다. 예를 들어, &lt;code&gt;Product&lt;/code&gt; 가 &lt;code&gt;purchase&lt;/code&gt; 라는 &lt;code&gt;User&lt;/code&gt; 와 다 대다 관계를 가진 경우 다음과 같은보기를 작성하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b60356a6dbd453c122a85b0c233845ffa06646a" translate="yes" xml:space="preserve">
          <source>Note that you need to set both the pagination class, and the page size that should be used. Both &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; and &lt;code&gt;PAGE_SIZE&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt; by default.</source>
          <target state="translated">페이지 매김 클래스와 사용해야하는 페이지 크기를 모두 설정해야합니다. 두 &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; 및 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 는 없습니다 &lt;code&gt;None&lt;/code&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="df4b20d6313feb1288f3b6fbd28c79c913b64388" translate="yes" xml:space="preserve">
          <source>Note that you'll want to ensure you place this code snippet in an installed &lt;code&gt;models.py&lt;/code&gt; module, or some other location that will be imported by Django on startup.</source>
          <target state="translated">이 코드 스 니펫을 설치된 &lt;code&gt;models.py&lt;/code&gt; 모듈 또는 시작시 Django에서 가져올 다른 위치에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a473963d7e629244512baad152d598e29571cb" translate="yes" xml:space="preserve">
          <source>Note that, without an explicit &lt;code&gt;default&lt;/code&gt;, setting this argument to &lt;code&gt;True&lt;/code&gt; will imply a &lt;code&gt;default&lt;/code&gt; value of &lt;code&gt;null&lt;/code&gt; for serialization output, but does not imply a default for input deserialization.</source>
          <target state="translated">명시 적 &lt;code&gt;default&lt;/code&gt; 가 없으면 이 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정하면 직렬화 출력 의 경우 &lt;code&gt;default&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; 을 의미하지만 입력 역 직렬화의 기본값을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="1b7a356a41eb66f0c09557c6567a0f8faf3f316e" translate="yes" xml:space="preserve">
          <source>Notice how similar the API is to working with forms. The similarity should become even more apparent when we start writing views that use our serializer.</source>
          <target state="translated">API가 양식을 사용하는 것과 비슷한 점에 유의하십시오. 시리얼 라이저를 사용하는 뷰를 작성하기 시작하면 유사성이 훨씬 더 분명 해져야합니다.</target>
        </trans-unit>
        <trans-unit id="faab1fa02f9cdf2969aaab31769256179c8e5709" translate="yes" xml:space="preserve">
          <source>Notice how we're creating multiple views from each &lt;code&gt;ViewSet&lt;/code&gt; class, by binding the http methods to the required action for each view.</source>
          <target state="translated">http 메소드를 각보기에 필요한 조치에 바인딩하여 각 &lt;code&gt;ViewSet&lt;/code&gt; 클래스 에서 여러보기를 작성하는 방법에 주목 하십시오.</target>
        </trans-unit>
        <trans-unit id="ce58e9c7b9822089be8ebef1abc45aa28280c63b" translate="yes" xml:space="preserve">
          <source>Notice that we're no longer explicitly tying our requests or responses to a given content type. &lt;code&gt;request.data&lt;/code&gt; can handle incoming &lt;code&gt;json&lt;/code&gt; requests, but it can also handle other formats. Similarly we're returning response objects with data, but allowing REST framework to render the response into the correct content type for us.</source>
          <target state="translated">Google은 더 이상 요청이나 특정 콘텐츠 유형에 대한 응답을 명시 적으로 연결하지 않습니다. &lt;code&gt;request.data&lt;/code&gt; 는 들어오는 &lt;code&gt;json&lt;/code&gt; 요청을 처리 할 수 ​​있지만 다른 형식도 처리 할 수 ​​있습니다. 마찬가지로 데이터가 포함 된 응답 객체를 반환하지만 REST 프레임 워크가 응답을 올바른 컨텐츠 유형으로 렌더링하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5c5b992b1a429e6b794c28b7efaaeb3331bd305d" translate="yes" xml:space="preserve">
          <source>Notice that we're using hyperlinked relations in this case with &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;. You can also use primary key and various other relationships, but hyperlinking is good RESTful design.</source>
          <target state="translated">이 경우 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 와 함께 하이퍼 링크 관계를 사용하고 있습니다. 기본 키와 다양한 다른 관계를 사용할 수도 있지만 하이퍼 링크는 RESTful 한 디자인입니다.</target>
        </trans-unit>
        <trans-unit id="f4957d7e6b6b4c1c37e7c0232d17f9556e4093de" translate="yes" xml:space="preserve">
          <source>Notice that we've also added a new &lt;code&gt;'highlight'&lt;/code&gt; field. This field is of the same type as the &lt;code&gt;url&lt;/code&gt; field, except that it points to the &lt;code&gt;'snippet-highlight'&lt;/code&gt; url pattern, instead of the &lt;code&gt;'snippet-detail'&lt;/code&gt; url pattern.</source>
          <target state="translated">새로운 &lt;code&gt;'highlight'&lt;/code&gt; 필드 도 추가했습니다 . 이 필드는 같은 유형 인 &lt;code&gt;url&lt;/code&gt; 가 가리키는 것을 제외하고, 필드 &lt;code&gt;'snippet-highlight'&lt;/code&gt; 대신에, URL 패턴 &lt;code&gt;'snippet-detail'&lt;/code&gt; URL 패턴.</target>
        </trans-unit>
        <trans-unit id="b09056c2971ef1602a20c7a81025ffc7ae838353" translate="yes" xml:space="preserve">
          <source>Notice that we've also used the &lt;code&gt;@action&lt;/code&gt; decorator to create a custom action, named &lt;code&gt;highlight&lt;/code&gt;. This decorator can be used to add any custom endpoints that don't fit into the standard &lt;code&gt;create&lt;/code&gt;/&lt;code&gt;update&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; style.</source>
          <target state="translated">우리는 또한 사용한 것을 알 수 &lt;code&gt;@action&lt;/code&gt; 사용자 지정 작업, 이름을 만들 장식을 &lt;code&gt;highlight&lt;/code&gt; . 이 데코레이터를 사용하여 표준 &lt;code&gt;create&lt;/code&gt; / &lt;code&gt;update&lt;/code&gt; / &lt;code&gt;delete&lt;/code&gt; 스타일에 맞지 않는 사용자 정의 엔드 포인트를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb62394d596f98e69eaf8408df83b0685a10904" translate="yes" xml:space="preserve">
          <source>Now go and open the API in a web browser, by visiting &lt;a href=&quot;http://127.0.0.1:8000/snippets/&quot;&gt;http://127.0.0.1:8000/snippets/&lt;/a&gt;.</source>
          <target state="translated">이제 &lt;a href=&quot;http://127.0.0.1:8000/snippets/&quot;&gt;http://127.0.0.1:8000/snippets/&lt;/a&gt; 를 방문하여 웹 브라우저에서 API 를여십시오 .</target>
        </trans-unit>
        <trans-unit id="515d44174fbc3faea9507a29e2d199c8bba50e39" translate="yes" xml:space="preserve">
          <source>Now if you open up the browser again and refresh the page you'll see a 'Login' link in the top right of the page. If you log in as one of the users you created earlier, you'll be able to create code snippets again.</source>
          <target state="translated">이제 브라우저를 다시 열고 페이지를 새로 고치면 페이지 오른쪽 상단에 '로그인'링크가 표시됩니다. 앞에서 만든 사용자 중 하나로 로그인하면 코드 스 니펫을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6910cede8885b8639b74ed274828741591efe81b" translate="yes" xml:space="preserve">
          <source>Now sync your database for the first time:</source>
          <target state="translated">이제 처음으로 데이터베이스를 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="f04984140c8c84aadcd6177cafc9d21fff7baed4" translate="yes" xml:space="preserve">
          <source>Now that code snippets are associated with users, we want to make sure that only authenticated users are able to create, update and delete code snippets.</source>
          <target state="translated">이제 코드 스 니펫이 사용자와 연관되었으므로 인증 된 사용자 만 코드 스 니펫을 작성, 업데이트 및 삭제할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="7908489371b30fbb39e16e9acf10076d342743e4" translate="yes" xml:space="preserve">
          <source>Now that snippets are associated with the user that created them, let's update our &lt;code&gt;SnippetSerializer&lt;/code&gt; to reflect that. Add the following field to the serializer definition in &lt;code&gt;serializers.py&lt;/code&gt;:</source>
          <target state="translated">스 니펫은이를 생성 한 사용자와 연결 &lt;code&gt;SnippetSerializer&lt;/code&gt; 이를 반영하도록 SnippetSerializer 를 업데이트하겠습니다 . 의 직렬 정의에 다음 필드를 추가 &lt;code&gt;serializers.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9da0ba1b8a1c6384cf7beb81edcb98a09ed0c87a" translate="yes" xml:space="preserve">
          <source>Now that we're inside a virtual environment, we can install our package requirements.</source>
          <target state="translated">이제 가상 환경 내부에 있으므로 패키지 요구 사항을 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="173c0a1dd33984485aba38ce050dcf1a3adae8da" translate="yes" xml:space="preserve">
          <source>Now that we've bound our resources into concrete views, we can register the views with the URL conf as usual.</source>
          <target state="translated">리소스를 구체적 뷰에 바인딩 했으므로 평소처럼 URL conf로 뷰를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be255ad71292e709d61098e1e93a1baefabb2fc9" translate="yes" xml:space="preserve">
          <source>Now that we've got some users to work with, we'd better add representations of those users to our API. Creating a new serializer is easy. In &lt;code&gt;serializers.py&lt;/code&gt; add:</source>
          <target state="translated">이제 일부 사용자와 작업 할 수있게되었으므로 해당 사용자의 표현을 API에 추가하는 것이 좋습니다. 새로운 시리얼 라이저를 만드는 것은 쉽습니다. 에서 &lt;code&gt;serializers.py&lt;/code&gt; 추가 :</target>
        </trans-unit>
        <trans-unit id="094f1b767466b215e918121b287a29f04d9ddea0" translate="yes" xml:space="preserve">
          <source>Now update the &lt;code&gt;snippets/urls.py&lt;/code&gt; file slightly, to append a set of &lt;code&gt;format_suffix_patterns&lt;/code&gt; in addition to the existing URLs.</source>
          <target state="translated">이제 &lt;code&gt;snippets/urls.py&lt;/code&gt; 파일을 약간 업데이트하여 기존 URL 외에 &lt;code&gt;format_suffix_patterns&lt;/code&gt; 세트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c78cb9cf64f3896bbc3c6145b157050b19b97ca5" translate="yes" xml:space="preserve">
          <source>Now we can add that custom permission to our snippet instance endpoint, by editing the &lt;code&gt;permission_classes&lt;/code&gt; property on the &lt;code&gt;SnippetDetail&lt;/code&gt; view class:</source>
          <target state="translated">이제 &lt;code&gt;SnippetDetail&lt;/code&gt; 뷰 클래스 에서 &lt;code&gt;permission_classes&lt;/code&gt; 속성을 편집하여 스 니펫 인스턴스 엔드 포인트에 해당 사용자 정의 권한을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28671c9961bd55f63bdbb836866aa03c7864b618" translate="yes" xml:space="preserve">
          <source>Now we can start up a sample server that serves our snippets.</source>
          <target state="translated">이제 스 니펫을 제공하는 샘플 서버를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="378e43074fc197cafd58af4549aa11dc59b01622" translate="yes" xml:space="preserve">
          <source>Now when deserializing data, we can call &lt;code&gt;.save()&lt;/code&gt; to return an object instance, based on the validated data.</source>
          <target state="translated">이제 데이터를 역 직렬화 할 때 유효성 검사 된 데이터를 기반으로 &lt;code&gt;.save()&lt;/code&gt; 를 호출 하여 객체 인스턴스를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c672d93ba55278f360e33d6e8f7bc1092313019" translate="yes" xml:space="preserve">
          <source>Now, if you open a browser again, you find that the 'DELETE' and 'PUT' actions only appear on a snippet instance endpoint if you're logged in as the same user that created the code snippet.</source>
          <target state="translated">이제 브라우저를 다시 열면 코드 스 니펫을 작성한 동일한 사용자로 로그인 한 경우 'DELETE'및 'PUT'조치가 스 니펫 인스턴스 엔드 포인트에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2b7c77301a2929db5f73f734c81a60d710e37c20" translate="yes" xml:space="preserve">
          <source>NullBooleanField</source>
          <target state="translated">NullBooleanField</target>
        </trans-unit>
        <trans-unit id="64f397c30c09c83d0e1fe862cff6333c141af219" translate="yes" xml:space="preserve">
          <source>Numeric fields</source>
          <target state="translated">숫자 필드</target>
        </trans-unit>
        <trans-unit id="10a8bfc72bb25ac79e23bac257fae4e0c248b99b" translate="yes" xml:space="preserve">
          <source>ORDERING_PARAM</source>
          <target state="translated">ORDERING_PARAM</target>
        </trans-unit>
        <trans-unit id="866a656e96fbba9a5c7daf98370166d9a8f414a0" translate="yes" xml:space="preserve">
          <source>Object level permissions</source>
          <target state="translated">객체 수준 권한</target>
        </trans-unit>
        <trans-unit id="0d6bfa22bbe9fea16e3570fc2f5cd54b8018a312" translate="yes" xml:space="preserve">
          <source>Object level permissions are run by REST framework's generic views when &lt;code&gt;.get_object()&lt;/code&gt; is called. As with view level permissions, an &lt;code&gt;exceptions.PermissionDenied&lt;/code&gt; exception will be raised if the user is not allowed to act on the given object.</source>
          <target state="translated">&lt;code&gt;.get_object()&lt;/code&gt; 가 호출 될 때 REST 프레임 워크의 일반 뷰에서 오브젝트 레벨 권한이 실행됩니다 . 뷰 수준 권한과 마찬가지로 사용자가 지정된 개체에 대해 작업을 수행 할 수없는 경우 &lt;code&gt;exceptions.PermissionDenied&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb7cdad3d567dc8263a9ca3fde44caab2833a604" translate="yes" xml:space="preserve">
          <source>Object-level validation</source>
          <target state="translated">객체 레벨 검증</target>
        </trans-unit>
        <trans-unit id="574d8b2159efe4b94b0b20b5abb51e2e1a10d4f5" translate="yes" xml:space="preserve">
          <source>Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when &lt;code&gt;many=True&lt;/code&gt; is passed. You can do so by using the &lt;code&gt;many_init&lt;/code&gt; class method.</source>
          <target state="translated">때로 &lt;code&gt;many=True&lt;/code&gt; 가 전달 될 때 자식 클래스와 부모 클래스를 인스턴스화하는 방법을 명시 적으로 지정해야 할 수도 있습니다 . &lt;code&gt;many_init&lt;/code&gt; 클래스 메소드를 사용하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3310f53f761054eca9d73669ac16f0d6a930f106" translate="yes" xml:space="preserve">
          <source>Often when you're using object level permissions you'll also want to &lt;a href=&quot;../filtering/index&quot;&gt;filter the queryset&lt;/a&gt; appropriately, to ensure that users only have visibility onto instances that they are permitted to view.</source>
          <target state="translated">개체 수준 권한 을 사용하는 경우 사용자가 볼 수있는 인스턴스 만 볼 수 있도록 &lt;a href=&quot;../filtering/index&quot;&gt;쿼리 집합을&lt;/a&gt; 적절하게 필터링 하려고 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="16dc994d248ebb1ef8dc39ed87e3425c220264a1" translate="yes" xml:space="preserve">
          <source>Often you'll want serializer classes that map closely to Django model definitions.</source>
          <target state="translated">Django 모델 정의에 밀접하게 매핑되는 직렬 변환기 클래스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="625a5d9f8dee1792fa1a9e4497e67a97f60ac501" translate="yes" xml:space="preserve">
          <source>Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.</source>
          <target state="translated">기존의 일반 뷰를 사용하고 싶지만 약간 맞춤화 된 동작을 사용하는 경우가 있습니다. 여러 위치에서 약간의 사용자 지정 동작을 다시 사용하는 경우 동작을 공통 클래스로 리팩토링 한 다음 필요에 따라 모든 뷰 또는 뷰 세트에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6801a29b0001a60d0e7508b95cdfe299f5a358b5" translate="yes" xml:space="preserve">
          <source>Okay, let's go ahead and start using these new components to write a few views.</source>
          <target state="translated">자, 계속해서 새로운 구성 요소를 사용하여 몇 가지 견해를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="28b9d5cc876307f4214c13f21715860c1148d424" translate="yes" xml:space="preserve">
          <source>Okay, now let's wire up the API URLs. On to &lt;code&gt;tutorial/urls.py&lt;/code&gt;...</source>
          <target state="translated">이제 API URL을 연결해 보겠습니다. On으로 &lt;code&gt;tutorial/urls.py&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="612cdbfb1112d6d77881e4fe97a6507a62bce307" translate="yes" xml:space="preserve">
          <source>Okay, once we've got a few imports out of the way, let's create a couple of code snippets to work with.</source>
          <target state="translated">이제 몇 가지 가져 오기가 완료되면 몇 가지 코드 스 니펫을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0e869cdaa40fb00f0f37dce3831c4e3ad38fb9bc" translate="yes" xml:space="preserve">
          <source>Okay, we're done.</source>
          <target state="translated">좋아, 끝났어</target>
        </trans-unit>
        <trans-unit id="fc317b74910d1cd1f12a9a19d2812cf01d53f3f9" translate="yes" xml:space="preserve">
          <source>Okay, we're done. If you run the development server everything should be working just as before.</source>
          <target state="translated">좋아, 끝났어 개발 서버를 실행하면 모든 것이 이전처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="d143c1e6315cee0c434f595e607b63814668e53d" translate="yes" xml:space="preserve">
          <source>Okay, we're ready to get coding. To get started, let's create a new project to work with.</source>
          <target state="translated">이제 코딩 할 준비가되었습니다. 시작하기 위해 작업 할 새 프로젝트를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="d50bc850e77ce18ac03078297d022730c6dfb97a" translate="yes" xml:space="preserve">
          <source>Okay, we're ready to roll.</source>
          <target state="translated">자 이제 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e861046c108731731b234169f136003a811b60f3" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;GenericAPIView&lt;/code&gt; subclasses you may also set the &lt;code&gt;pagination_class&lt;/code&gt; attribute to select &lt;code&gt;CursorPagination&lt;/code&gt; on a per-view basis.</source>
          <target state="translated">에 &lt;code&gt;GenericAPIView&lt;/code&gt; 의 서브 클래스 당신은 또한 설정할 수 있습니다 &lt;code&gt;pagination_class&lt;/code&gt; 의 선택 속성을 &lt;code&gt;CursorPagination&lt;/code&gt; 당 뷰 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="fef0d4bd3fbd885715131826d369ef4e3f6121f5" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;GenericAPIView&lt;/code&gt; subclasses you may also set the &lt;code&gt;pagination_class&lt;/code&gt; attribute to select &lt;code&gt;LimitOffsetPagination&lt;/code&gt; on a per-view basis.</source>
          <target state="translated">에 &lt;code&gt;GenericAPIView&lt;/code&gt; 는 서브 클래스 당신은 또한 설정할 수 있습니다 &lt;code&gt;pagination_class&lt;/code&gt; 의 선택 속성 &lt;code&gt;LimitOffsetPagination&lt;/code&gt; 을 당 뷰 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="b2e77b5841c8a573cd6e9ca4550c353d7c36b65a" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;GenericAPIView&lt;/code&gt; subclasses you may also set the &lt;code&gt;pagination_class&lt;/code&gt; attribute to select &lt;code&gt;PageNumberPagination&lt;/code&gt; on a per-view basis.</source>
          <target state="translated">에 &lt;code&gt;GenericAPIView&lt;/code&gt; 의 서브 클래스 당신은 또한 설정할 수 있습니다 &lt;code&gt;pagination_class&lt;/code&gt; 의 선택 속성을 &lt;code&gt;PageNumberPagination&lt;/code&gt; 당 뷰 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="ed684499aaee4f1d469e622e5ba2947ba58aefdf" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;SnippetList&lt;/code&gt; view class, add the following method:</source>
          <target state="translated">온 &lt;code&gt;SnippetList&lt;/code&gt; 의 뷰 클래스, 다음과 같은 방법을 추가 :</target>
        </trans-unit>
        <trans-unit id="2e9e6fa6db0a6baa09f83e49fa8a90a67d297864" translate="yes" xml:space="preserve">
          <source>Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the &lt;code&gt;.fields&lt;/code&gt; attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.</source>
          <target state="translated">시리얼 라이저가 초기화되면 &lt;code&gt;.fields&lt;/code&gt; 속성을 사용하여 시리얼 라이저에 설정된 필드 사전에 액세스 할 수 있습니다 . 이 속성에 액세스하고 수정하면 직렬 변환기를 동적으로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a73e3d2fa02eb7b2274f8e6ee1bf246a1c99933" translate="yes" xml:space="preserve">
          <source>Once that's done we can create an app that we'll use to create a simple Web API.</source>
          <target state="translated">완료되면 간단한 웹 API를 만드는 데 사용할 앱을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5433fcc29c83d63cb7cc96ab51a337accef089ae" translate="yes" xml:space="preserve">
          <source>Once you've created a few code snippets, navigate to the '/users/' endpoint, and notice that the representation includes a list of the snippet ids that are associated with each user, in each user's 'snippets' field.</source>
          <target state="translated">코드 스 니펫을 몇 개 만든 후에는 '/ users /'엔드 포인트로 이동하여 각 사용자의 '스 니펫'필드에서 각 사용자와 관련된 스 니펫 ID 목록이 표시에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="41be347ee3a9c422d61ef423d7b9c24ac557de28" translate="yes" xml:space="preserve">
          <source>Once you've generated a schema in this way you can annotate it with any additional information that cannot be automatically inferred by the schema generator.</source>
          <target state="translated">이러한 방식으로 스키마를 생성하면 스키마 생성기가 자동으로 추론 할 수없는 추가 정보로 스키마에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520d6a29b68d6e04d2589a497d07196a06b94bbc" translate="yes" xml:space="preserve">
          <source>Once you've implemented &lt;code&gt;.to_internal_value()&lt;/code&gt;, the basic validation API will be available on the serializer, and you will be able to use &lt;code&gt;.is_valid()&lt;/code&gt;, &lt;code&gt;.validated_data&lt;/code&gt; and &lt;code&gt;.errors&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.to_internal_value()&lt;/code&gt; 구현 하면 시리얼 라이저에서 기본 유효성 검사 API를 사용할 수 있으며 &lt;code&gt;.is_valid()&lt;/code&gt; , &lt;code&gt;.validated_data&lt;/code&gt; 및 &lt;code&gt;.errors&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1741af68a17399fe36224088116c2c82ccfd9edc" translate="yes" xml:space="preserve">
          <source>Once you've set up a database and the initial user is created and ready to go, open up the app's directory and we'll get coding...</source>
          <target state="translated">데이터베이스를 설정하고 초기 사용자가 생성되어 준비가되면 앱의 디렉토리를 열면 코딩이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f0cb2e359eb36e36c8a01e3af0df75deb9ef1f1a" translate="yes" xml:space="preserve">
          <source>One difference worth noting between Django's &lt;code&gt;RequestFactory&lt;/code&gt; and REST framework's &lt;code&gt;APIRequestFactory&lt;/code&gt; is that multipart form data will be encoded for methods other than just &lt;code&gt;.post()&lt;/code&gt;.</source>
          <target state="translated">Django의 &lt;code&gt;RequestFactory&lt;/code&gt; 와 REST 프레임 워크의 &lt;code&gt;APIRequestFactory&lt;/code&gt; 사이에 주목할 가치가있는 한 가지 차이점 은 다중 부분 양식 데이터가 단지 &lt;code&gt;.post()&lt;/code&gt; 이외의 메소드에 대해 인코딩된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="52760e0e7fe50c4271ebc15024b815a72cf142e9" translate="yes" xml:space="preserve">
          <source>One example of this is a read-only relation to the currently authenticated &lt;code&gt;User&lt;/code&gt; which is &lt;code&gt;unique_together&lt;/code&gt; with another identifier. In this case you would declare the user field like so:</source>
          <target state="translated">이것의 한 예는 현재 인증에 대한 읽기 전용의 관계이다 &lt;code&gt;User&lt;/code&gt; 입니다 &lt;code&gt;unique_together&lt;/code&gt; 다른 식별자. 이 경우 사용자 필드를 다음과 같이 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="59f6d591257b0ec109c18c7d16f80fe71654cdbc" translate="yes" xml:space="preserve">
          <source>One nice property that serializers have is that you can inspect all the fields in a serializer instance, by printing its representation. Open the Django shell with &lt;code&gt;python manage.py shell&lt;/code&gt;, then try the following:</source>
          <target state="translated">시리얼 라이저가 가지고있는 좋은 특성 중 하나는 표현을 인쇄하여 시리얼 라이저 인스턴스의 모든 필드를 검사 할 수 있다는 것입니다. &lt;code&gt;python manage.py shell&lt;/code&gt; shell을 사용하여 Django 셸을 열고 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="f9c9446db7fe492c0a7e7e7df12e0a4bf0148cb3" translate="yes" xml:space="preserve">
          <source>One of the big wins of using class-based views is that it allows us to easily compose reusable bits of behaviour.</source>
          <target state="translated">클래스 기반 뷰를 사용하는 것의 가장 큰 장점 중 하나는 재사용 가능한 비트를 쉽게 작성할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="609d28bf323fc14b31d538e9780a54336438c604" translate="yes" xml:space="preserve">
          <source>One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.</source>
          <target state="translated">클래스 기반 뷰의 주요 이점 중 하나는 재사용 가능한 동작을 작성할 수있는 방법입니다. REST 프레임 워크는 일반적으로 사용되는 패턴을 제공하는 사전 빌드 된 여러보기를 제공하여이를 활용합니다.</target>
        </trans-unit>
        <trans-unit id="b3045b022c08cf1bb514dad73817f2da7edb2828" translate="yes" xml:space="preserve">
          <source>Only authenticated users may create snippets.</source>
          <target state="translated">인증 된 사용자 만 스 니펫을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b673bcc9823e309dac8ec13a7c99412c9ca56a1b" translate="yes" xml:space="preserve">
          <source>Only the creator of a snippet may update or delete it.</source>
          <target state="translated">스 니펫을 만든 사람 만 업데이트하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d691aa2446c1c4d41d5eb8505a8bade71f653b" translate="yes" xml:space="preserve">
          <source>Optional fields</source>
          <target state="translated">선택적 필드</target>
        </trans-unit>
        <trans-unit id="d552743956c0bab76b9b58a7cad279c611c25573" translate="yes" xml:space="preserve">
          <source>Optional. If provided, this is a dictionary of contextual information provided by the view.</source>
          <target state="translated">선택 과목. 제공되는 경우 이는보기에서 제공하는 컨텍스트 정보 사전입니다.</target>
        </trans-unit>
        <trans-unit id="c9144a6baebc2076c845958ebe3ce851ffa980cc" translate="yes" xml:space="preserve">
          <source>Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.</source>
          <target state="translated">선택 과목. 제공되는 경우 이는 컨텐츠 협상 단계에 의해 결정된대로 허용되는 매체 유형입니다.</target>
        </trans-unit>
        <trans-unit id="96b9d10ee78b342d22891cb8c14b99819178c23c" translate="yes" xml:space="preserve">
          <source>Optional. If provided, this is the media type of the incoming request content.</source>
          <target state="translated">선택 과목. 제공되는 경우 이는 수신 요청 컨텐츠의 매체 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fb94ae08a10fd0d80a25f1aa66d8e9ce1d00b6d5" translate="yes" xml:space="preserve">
          <source>Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.</source>
          <target state="translated">선택 과목. 제공된 경우이 인수는 요청 컨텐츠를 구문 분석하는 데 필요할 수있는 추가 컨텍스트를 포함하는 사전이됩니다.</target>
        </trans-unit>
        <trans-unit id="904aad41da2f418839e9ba8df0bce140724fbef6" translate="yes" xml:space="preserve">
          <source>Optionally you may also override the &lt;code&gt;.wait()&lt;/code&gt; method. If implemented, &lt;code&gt;.wait()&lt;/code&gt; should return a recommended number of seconds to wait before attempting the next request, or &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;.wait()&lt;/code&gt; method will only be called if &lt;code&gt;.allow_request()&lt;/code&gt; has previously returned &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적으로 &lt;code&gt;.wait()&lt;/code&gt; 메소드를 대체 할 수도 있습니다 . 구현 된 경우 &lt;code&gt;.wait()&lt;/code&gt; 는 다음 요청을 시도하기 전에 대기하는 데 권장되는 시간 (초 ) 을 반환하거나 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;.wait()&lt;/code&gt; 경우 메소드는 호출 될 것이다 &lt;code&gt;.allow_request()&lt;/code&gt; 이전에 돌아왔다 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8c26464fbbd03f80777316db474cfcca1fae44" translate="yes" xml:space="preserve">
          <source>Optionally, you may also set a &lt;code&gt;PAGE_SIZE&lt;/code&gt; key. If the &lt;code&gt;PAGE_SIZE&lt;/code&gt; parameter is also used then the &lt;code&gt;limit&lt;/code&gt; query parameter will be optional, and may be omitted by the client.</source>
          <target state="translated">선택적으로 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 키를 설정할 수도 있습니다 . 는 IF &lt;code&gt;PAGE_SIZE&lt;/code&gt; 의 매개 변수는 다음 사용되는 &lt;code&gt;limit&lt;/code&gt; 쿼리 매개 변수는 선택 될 것이며, 클라이언트에 의해 생략 할 수있다.</target>
        </trans-unit>
        <trans-unit id="eb1558e806287d1867d20241c30a1ad761460fbd" translate="yes" xml:space="preserve">
          <source>Optionally, you may also specify an additional argument:</source>
          <target state="translated">선택적으로 추가 인수를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26893cf6937305774d238ada98550b8d2ca97058" translate="yes" xml:space="preserve">
          <source>Or add the filter backend to an individual View or ViewSet.</source>
          <target state="translated">또는 필터 백엔드를 개별 View 또는 ViewSet에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="efe5c8fce94ab8ce5ee6e0dc4764421228cdd49f" translate="yes" xml:space="preserve">
          <source>Or apply the style globally, using the &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; settings key. For example:</source>
          <target state="translated">또는 &lt;code&gt;DEFAULT_PAGINATION_CLASS&lt;/code&gt; 설정 키를 사용하여 스타일을 전체적으로 적용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49f28a0ddaf2c6c47c270531a30d8fc342ae001d" translate="yes" xml:space="preserve">
          <source>Or both an application and instance namespace:</source>
          <target state="translated">또는 애플리케이션과 인스턴스 네임 스페이스 모두 :</target>
        </trans-unit>
        <trans-unit id="f742482488af7b6903db14bcfe1ea4fb73a3910a" translate="yes" xml:space="preserve">
          <source>Or by appending a format suffix:</source>
          <target state="translated">또는 형식 접미사를 추가하여 :</target>
        </trans-unit>
        <trans-unit id="45b98bcb1ef807f0b9dd8059fdb3e8b46c83e399" translate="yes" xml:space="preserve">
          <source>Or directly through the browser, by going to the URL &lt;code&gt;http://127.0.0.1:8000/users/&lt;/code&gt;...</source>
          <target state="translated">또는 URL &lt;code&gt;http://127.0.0.1:8000/users/&lt;/code&gt; ... 로 이동하여 브라우저를 통해 직접</target>
        </trans-unit>
        <trans-unit id="1f196f1c9732874bb5940857bdb1127c881b3a2b" translate="yes" xml:space="preserve">
          <source>Or use it to serialize multiple instances:</source>
          <target state="translated">또는 여러 인스턴스를 직렬화하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e828686e604d346b3d8ad45078bbb66588e52f54" translate="yes" xml:space="preserve">
          <source>Or using the &lt;a href=&quot;https://github.com/jakubroztocil/httpie#installation&quot;&gt;httpie&lt;/a&gt;, command line tool...</source>
          <target state="translated">또는 &lt;a href=&quot;https://github.com/jakubroztocil/httpie#installation&quot;&gt;httpie&lt;/a&gt; 명령 줄 도구를 사용하여 ...</target>
        </trans-unit>
        <trans-unit id="3d7c8dad2a96b62e5842068756e3d321fa43f1c4" translate="yes" xml:space="preserve">
          <source>Or we can get a particular snippet by referencing its id:</source>
          <target state="translated">또는 id를 참조하여 특정 스 니펫을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f6f2f9bfb3f17bf14f133b0bf3c4aec84774add" translate="yes" xml:space="preserve">
          <source>Or with class-based views:</source>
          <target state="translated">또는 클래스 기반보기의 경우 :</target>
        </trans-unit>
        <trans-unit id="37247a7bbc6e7a4dd81691e806c99749e6e7c94f" translate="yes" xml:space="preserve">
          <source>Or you can set the metadata class individually for a view:</source>
          <target state="translated">또는보기에 대해 메타 데이터 클래스를 개별적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be92a248988a8c3f0619ae445466c2fb206830a" translate="yes" xml:space="preserve">
          <source>Or, if you're using the &lt;code&gt;@api_view&lt;/code&gt; decorator with function based views.</source>
          <target state="translated">또는 함수 기반 뷰와 함께 &lt;code&gt;@api_view&lt;/code&gt; 데코레이터를 사용하는 경우 .</target>
        </trans-unit>
        <trans-unit id="e18f69d7ec25f7efef92b50fa6ed2ee45908084e" translate="yes" xml:space="preserve">
          <source>Ordering of renderer classes</source>
          <target state="translated">렌더러 클래스의 순서</target>
        </trans-unit>
        <trans-unit id="4a680a3f0b6d757b015d957798796af0274cc223" translate="yes" xml:space="preserve">
          <source>OrderingFilter</source>
          <target state="translated">OrderingFilter</target>
        </trans-unit>
        <trans-unit id="6259560526ae1e68cdb3fbdcd8795597dcd6a20b" translate="yes" xml:space="preserve">
          <source>Other versioning settings</source>
          <target state="translated">다른 버전 관리 설정</target>
        </trans-unit>
        <trans-unit id="53dbe63b534153a79dc46d4495e7292756be8783" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;ColorField&lt;/code&gt; class above currently does not perform any data validation. To indicate invalid data, we should raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt;, like so:</source>
          <target state="translated">위 의 &lt;code&gt;ColorField&lt;/code&gt; 클래스는 현재 데이터 유효성 검사를 수행하지 않습니다. 유효하지 않은 데이터를 나타내려면 다음과 같이 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 를 발생 시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="6742b6f185e695513d4ce3595f096143cbb2a2e2" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;SnippetSerializer&lt;/code&gt; class is replicating a lot of information that's also contained in the &lt;code&gt;Snippet&lt;/code&gt; model. It would be nice if we could keep our code a bit more concise.</source>
          <target state="translated">우리 &lt;code&gt;SnippetSerializer&lt;/code&gt; 의 클래스는에 포함되어있어 많은 정보를 복제하는 &lt;code&gt;Snippet&lt;/code&gt; 모델. 코드를 좀 더 간결하게 유지할 수 있다면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="191068573e349df477e77d95a5b8072d796b0517" translate="yes" xml:space="preserve">
          <source>Our API views don't do anything particularly special at the moment, beyond serving &lt;code&gt;json&lt;/code&gt; responses, and there are some error handling edge cases we'd still like to clean up, but it's a functioning Web API.</source>
          <target state="translated">우리의 API 뷰는 &lt;code&gt;json&lt;/code&gt; 응답 을 제공하는 것 이상으로 현재 특별한 작업을 수행하지 않으며 여전히 정리하고 싶은 오류 처리 에지 사례가 있지만 작동하는 웹 API입니다.</target>
        </trans-unit>
        <trans-unit id="320f862b4aacd2726d3d23df08d88e293e985c9d" translate="yes" xml:space="preserve">
          <source>Our instance view is an improvement over the previous example. It's a little more concise, and the code now feels very similar to if we were working with the Forms API. We're also using named status codes, which makes the response meanings more obvious.</source>
          <target state="translated">인스턴스 뷰는 이전 예제보다 개선되었습니다. 조금 더 간결하고 코드는 이제 Forms API로 작업하는 것과 매우 유사합니다. 또한 명명 된 상태 코드를 사용하여 응답 의미를보다 명확하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0457d8ef4047aa46b9ef6211592ee400d0b4e4d8" translate="yes" xml:space="preserve">
          <source>Our new &lt;code&gt;DataPointSerializer&lt;/code&gt; exhibits the same behaviour as the custom field approach.</source>
          <target state="translated">새로운 &lt;code&gt;DataPointSerializer&lt;/code&gt; 는 커스텀 필드 접근 방식과 동일한 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="77986b859da6f09a970d3508a0b6a68dd0226ca8" translate="yes" xml:space="preserve">
          <source>Our snippet and user serializers include &lt;code&gt;'url'&lt;/code&gt; fields that by default will refer to &lt;code&gt;'{model_name}-detail'&lt;/code&gt;, which in this case will be &lt;code&gt;'snippet-detail'&lt;/code&gt; and &lt;code&gt;'user-detail'&lt;/code&gt;.</source>
          <target state="translated">스 니펫 및 사용자 시리얼 라이저에는 기본적으로 &lt;code&gt;'{model_name}-detail'&lt;/code&gt; 을 참조하는 &lt;code&gt;'url'&lt;/code&gt; 필드가 포함 되며이 경우 &lt;code&gt;'snippet-detail'&lt;/code&gt; 및 &lt;code&gt;'user-detail'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8213751bcaec3f3a36b0dcc6f9e705584cb6fefc" translate="yes" xml:space="preserve">
          <source>Our snippet serializer includes a field that refers to &lt;code&gt;'snippet-highlight'&lt;/code&gt;.</source>
          <target state="translated">스 니펫 시리얼 라이저에는 &lt;code&gt;'snippet-highlight'&lt;/code&gt; 를 나타내는 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9da44a7df070e2cfed3b55e75d1859408ebfa1e" translate="yes" xml:space="preserve">
          <source>Our user serializer includes a field that refers to &lt;code&gt;'snippet-detail'&lt;/code&gt;.</source>
          <target state="translated">우리의 사용자 시리얼 라이저는 &lt;code&gt;'snippet-detail'&lt;/code&gt; 을 나타내는 필드를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="d63b0f0b9d56666416e596c609577446a600a75b" translate="yes" xml:space="preserve">
          <source>Overriding .save() directly.</source>
          <target state="translated">.save ()를 직접 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="710a98a1fccdaf996bb28b5ea77b4b03d1716bbd" translate="yes" xml:space="preserve">
          <source>Overriding serialization and deserialization behavior</source>
          <target state="translated">직렬화 및 역 직렬화 동작 재정의</target>
        </trans-unit>
        <trans-unit id="127275baf3ed8ea00418353b5e36f2c08ab49505" translate="yes" xml:space="preserve">
          <source>Overriding the initial queryset</source>
          <target state="translated">초기 쿼리 셋 재정의</target>
        </trans-unit>
        <trans-unit id="78464d4b318de48c59765cf36b0fbf69d3555264" translate="yes" xml:space="preserve">
          <source>Overriding this method allows you to customize the queryset returned by the view in a number of different ways.</source>
          <target state="translated">이 방법을 재정의하면 다양한 방법으로보기에서 반환 된 쿼리 집합을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b52994dc88c9712256d6347664b4288df66f87eb" translate="yes" xml:space="preserve">
          <source>PAGE_SIZE</source>
          <target state="translated">PAGE_SIZE</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="834ebff92449ef46b1f64d19bdc65a582073d4c3" translate="yes" xml:space="preserve">
          <source>PUT and PATCH with form data</source>
          <target state="translated">양식 데이터가있는 PUT 및 PATCH</target>
        </trans-unit>
        <trans-unit id="2cf5ee6ef7fdef89e6d7ef04443b994e935e2463" translate="yes" xml:space="preserve">
          <source>PUT as create</source>
          <target state="translated">작성으로 PUT</target>
        </trans-unit>
        <trans-unit id="b148ebbe8b36fb6056c6f49b77b2b97eee6c6a5f" translate="yes" xml:space="preserve">
          <source>PageNumberPagination</source>
          <target state="translated">PageNumberPagination</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="6948a373bc8b2b1028e149b9580c1a68bc4e3511" translate="yes" xml:space="preserve">
          <source>Pagination &amp;amp; schemas</source>
          <target state="translated">페이지 매김 및 스키마</target>
        </trans-unit>
        <trans-unit id="b191d9ff50db999afefacc43d5c218daf82e4d94" translate="yes" xml:space="preserve">
          <source>Pagination allows you to control how many objects per page are returned. To enable it add the following lines to &lt;code&gt;tutorial/settings.py&lt;/code&gt;</source>
          <target state="translated">페이지 매김을 사용하면 페이지 당 반환되는 개체 수를 제어 할 수 있습니다. 이를 활성화하려면 &lt;code&gt;tutorial/settings.py&lt;/code&gt; 에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="95bbe79f07ac768254d0e6651220966955a8a714" translate="yes" xml:space="preserve">
          <source>Pagination can be turned off by setting the pagination class to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">페이지 매김 클래스를 &lt;code&gt;None&lt;/code&gt; 으로 설정하여 페이지 매김을 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e384c185ae375ace11c2e9af3f61d776d8d160d9" translate="yes" xml:space="preserve">
          <source>Pagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular &lt;code&gt;APIView&lt;/code&gt;, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the &lt;code&gt;mixins.ListModelMixin&lt;/code&gt; and &lt;code&gt;generics.GenericAPIView&lt;/code&gt; classes for an example.</source>
          <target state="translated">페이지 매김은 일반 뷰 또는 뷰 세트를 사용하는 경우에만 자동으로 수행됩니다. 일반 &lt;code&gt;APIView&lt;/code&gt; 를 사용하는 경우 페이지 매김 된 응답을 리턴하도록 페이지 매김 API를 직접 호출해야합니다. 예를 들어 &lt;code&gt;mixins.ListModelMixin&lt;/code&gt; 및 &lt;code&gt;generics.GenericAPIView&lt;/code&gt; 클래스 의 소스 코드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b5a727b265d5b11e5f77941882164008fa61200" translate="yes" xml:space="preserve">
          <source>Pagination links that are included in response headers, such as &lt;code&gt;Content-Range&lt;/code&gt; or &lt;code&gt;Link&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; 또는 &lt;code&gt;Link&lt;/code&gt; 와 같은 응답 헤더에 포함 된 페이지 매김 링크 .</target>
        </trans-unit>
        <trans-unit id="d4e145a99a900d85fc40c7baf3b167807caf5052" translate="yes" xml:space="preserve">
          <source>Pagination links that are provided as part of the content of the response.</source>
          <target state="translated">응답 내용의 일부로 제공되는 페이지 매김 링크.</target>
        </trans-unit>
        <trans-unit id="f38a991b4b1cbef563a8728c3a8519751f91a0e3" translate="yes" xml:space="preserve">
          <source>Pandas (CSV, Excel, PNG)</source>
          <target state="translated">팬더 (CSV, Excel, PNG)</target>
        </trans-unit>
        <trans-unit id="df633b0d4b46131792d5ed485e94f872474b0ba2" translate="yes" xml:space="preserve">
          <source>ParseError</source>
          <target state="translated">ParseError</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="43211571b9cb7aac08251bf8bdea0f7a8ec45aa8" translate="yes" xml:space="preserve">
          <source>Parsers and file uploads.</source>
          <target state="translated">파서 및 파일 업로드</target>
        </trans-unit>
        <trans-unit id="4d1cb17016b65604e7148ee14736706c4bfa6cfa" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;JSON&lt;/code&gt; request content.</source>
          <target state="translated">&lt;code&gt;JSON&lt;/code&gt; 요청 컨텐츠를 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="13485e1cccb0eba2acbbe4b294198f0690710d46" translate="yes" xml:space="preserve">
          <source>Parses HTML form content. &lt;code&gt;request.data&lt;/code&gt; will be populated with a &lt;code&gt;QueryDict&lt;/code&gt; of data.</source>
          <target state="translated">HTML 양식 컨텐츠를 구문 분석합니다. &lt;code&gt;request.data&lt;/code&gt; 는 &lt;code&gt;QueryDict&lt;/code&gt; 의 데이터 로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="c93c85d44cdee3fc7bb315295b404b5b9cec8cfa" translate="yes" xml:space="preserve">
          <source>Parses multipart HTML form content, which supports file uploads. Both &lt;code&gt;request.data&lt;/code&gt; will be populated with a &lt;code&gt;QueryDict&lt;/code&gt;.</source>
          <target state="translated">파일 업로드를 지원하는 멀티 파트 HTML 양식 컨텐츠를 구문 분석합니다. &lt;code&gt;request.data&lt;/code&gt; 둘 다 &lt;code&gt;QueryDict&lt;/code&gt; 로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="369f1e5652f89541dee6ff5c272827b6be3da7f3" translate="yes" xml:space="preserve">
          <source>Parses raw file upload content. The &lt;code&gt;request.data&lt;/code&gt; property will be a dictionary with a single key &lt;code&gt;'file'&lt;/code&gt; containing the uploaded file.</source>
          <target state="translated">원시 파일 업로드 컨텐츠를 구문 분석합니다. &lt;code&gt;request.data&lt;/code&gt; 의 속성은 하나의 키를 사전 될 것 &lt;code&gt;'file'&lt;/code&gt; 업로드 된 파일을 포함.</target>
        </trans-unit>
        <trans-unit id="a3fe54cb0b8ba82b444ae082b2105c137623b124" translate="yes" xml:space="preserve">
          <source>Partial updates</source>
          <target state="translated">부분 업데이트</target>
        </trans-unit>
        <trans-unit id="fb07fd49c4bbf3f72536aa675ac66ba5260908ce" translate="yes" xml:space="preserve">
          <source>Passing additional attributes to .save()</source>
          <target state="translated">.save ()에 추가 속성 전달</target>
        </trans-unit>
        <trans-unit id="e49e3141c600796225ed3d710d595ee84461ff5a" translate="yes" xml:space="preserve">
          <source>Per-View Customization</source>
          <target state="translated">뷰당 사용자 정의</target>
        </trans-unit>
        <trans-unit id="af0dd07a69011441db910a8eebcd7b543a1ead2f" translate="yes" xml:space="preserve">
          <source>Performs any actions that need to occur before the handler method gets called. This method is used to enforce permissions and throttling, and perform content negotiation.</source>
          <target state="translated">핸들러 메소드가 호출되기 전에 발생해야하는 조치를 수행합니다. 이 방법은 권한 및 제한을 시행하고 콘텐츠 협상을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f04d94c62e9ee70692f850aad239e362d3e7c6d" translate="yes" xml:space="preserve">
          <source>Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the &lt;code&gt;request.user&lt;/code&gt; and &lt;code&gt;request.auth&lt;/code&gt; properties to determine if the incoming request should be permitted.</source>
          <target state="translated">권한 검사는 다른 코드가 진행되기 전에 항상보기 시작시 실행됩니다. 권한 검사는 일반적으로 &lt;code&gt;request.user&lt;/code&gt; 및 &lt;code&gt;request.auth&lt;/code&gt; 특성 의 인증 정보를 사용 하여 수신 요청을 허용해야하는지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="4636c20125232583a78fcf9bd2b7beb3e0ee79a6" translate="yes" xml:space="preserve">
          <source>PermissionDenied</source>
          <target state="translated">PermissionDenied</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="c4deea70e526a9ef98987db7697fd554c37c0fd7" translate="yes" xml:space="preserve">
          <source>Permissions are used to grant or deny access for different classes of users to different parts of the API.</source>
          <target state="translated">권한은 다른 클래스의 사용자에게 API의 다른 부분에 대한 액세스 권한을 부여하거나 거부하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da8dba14e2286baef48985b89f0d26cadbdacbca" translate="yes" xml:space="preserve">
          <source>Permissions in REST framework are always defined as a list of permission classes.</source>
          <target state="translated">REST 프레임 워크의 권한은 항상 권한 클래스 목록으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="876ed6f31134f69a4e42535e0c4e8fa1946f84d1" translate="yes" xml:space="preserve">
          <source>Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the &lt;code&gt;extra_kwargs&lt;/code&gt; option will be ignored.</source>
          <target state="translated">필드가 이미 serializer 클래스에서 명시 적으로 선언 된 경우 &lt;code&gt;extra_kwargs&lt;/code&gt; 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cde49ac2080aa2d4660cc1c6e41dbb3080cc6403" translate="yes" xml:space="preserve">
          <source>Please review the &lt;a href=&quot;../validators/index&quot;&gt;Validators Documentation&lt;/a&gt; for details on the &lt;a href=&quot;../validators/index#uniquetogethervalidator&quot;&gt;UniqueTogetherValidator&lt;/a&gt; and &lt;a href=&quot;../validators/index#currentuserdefault&quot;&gt;CurrentUserDefault&lt;/a&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;../validators/index#uniquetogethervalidator&quot;&gt;UniqueTogetherValidator&lt;/a&gt; 및 &lt;a href=&quot;../validators/index#currentuserdefault&quot;&gt;CurrentUserDefault&lt;/a&gt; 클래스 에 대한 자세한 내용 은 &lt;a href=&quot;../validators/index&quot;&gt;유효성 검사기 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0edf3e44ab307fc9e605cce5f1b1153a0103d4d4" translate="yes" xml:space="preserve">
          <source>Pretty similar. Again we're using the &lt;code&gt;GenericAPIView&lt;/code&gt; class to provide the core functionality, and adding in mixins to provide the &lt;code&gt;.retrieve()&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt; and &lt;code&gt;.destroy()&lt;/code&gt; actions.</source>
          <target state="translated">꽤 비슷합니다. 다시 우리는 핵심 기능을 제공하기 위해 &lt;code&gt;GenericAPIView&lt;/code&gt; 클래스를 사용하고 &lt;code&gt;.retrieve()&lt;/code&gt; , &lt;code&gt;.update()&lt;/code&gt; 및 .destroy () 작업 을 제공하기 위해 믹스 인을 추가 &lt;code&gt;.destroy()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df22240e4dc4ce2fab264554065094380089333f" translate="yes" xml:space="preserve">
          <source>PrimaryKeyRelatedField</source>
          <target state="translated">PrimaryKeyRelatedField</target>
        </trans-unit>
        <trans-unit id="9054ab892577a95d226b444fb369976ae9e528a0" translate="yes" xml:space="preserve">
          <source>Printing the &lt;code&gt;repr&lt;/code&gt; of a serializer instance will show you exactly what validation rules it applies. There's no extra hidden validation behavior being called on the model instance.</source>
          <target state="translated">시리얼 라이저 인스턴스 의 &lt;code&gt;repr&lt;/code&gt; 을 인쇄하면 적용되는 유효성 검사 규칙이 정확히 표시됩니다. 모델 인스턴스에서 추가로 숨겨진 유효성 검사 동작이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0580efdda53656c5b208791e376da0efc297d40" translate="yes" xml:space="preserve">
          <source>Prior to version 3.0 the REST framework mixins treated &lt;code&gt;PUT&lt;/code&gt; as either an update or a create operation, depending on if the object already existed or not.</source>
          <target state="translated">버전 3.0 이전의 REST 프레임 워크 믹스 인 은 오브젝트가 이미 존재하는지 여부에 따라 &lt;code&gt;PUT&lt;/code&gt; 을 갱신 또는 작성 조작으로 처리했습니다.</target>
        </trans-unit>
        <trans-unit id="a0e72cd3d2e8c6323770f1cbb79c7116a0e7fe1c" translate="yes" xml:space="preserve">
          <source>Project setup</source>
          <target state="translated">프로젝트 설정</target>
        </trans-unit>
        <trans-unit id="47ad295710d815c441e1db50d3ee870196244f9a" translate="yes" xml:space="preserve">
          <source>Proper usage of cursor pagination should have an ordering field that satisfies the following:</source>
          <target state="translated">커서 페이지 매김을 올바르게 사용하려면 다음을 충족하는 순서 필드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5da530b3dbcb722f973231a6884520ad6d88e7c" translate="yes" xml:space="preserve">
          <source>Proper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by &lt;code&gt;&quot;-created&quot;&lt;/code&gt;. This assumes that &lt;strong&gt;there must be a 'created' timestamp field&lt;/strong&gt; on the model instances, and will present a &quot;timeline&quot; style paginated view, with the most recently added items first.</source>
          <target state="translated">커서 기반 페이지 매김을 올바르게 사용하려면 세부 사항에 약간의주의가 필요합니다. 체계를 적용하려는 순서에 대해 생각해야합니다. 기본값은 &lt;code&gt;&quot;-created&quot;&lt;/code&gt; 로 주문하는 것 입니다. 이 있다고 가정 &lt;strong&gt;거기에 '생성'타임 스탬프 필드이어야&lt;/strong&gt; 모델 인스턴스에, 먼저 가장 최근에 추가 된 항목으로는 &quot;타임 라인&quot;스타일의 페이지 매김보기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7013144d732472d64e3faaeca11c63b3463dfadc" translate="yes" xml:space="preserve">
          <source>Provide both user and token information associated with the incoming request.</source>
          <target state="translated">수신 요청과 관련된 사용자 및 토큰 정보를 모두 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="4b385192bded241b50916dfe7c58e78fd421d46e" translate="yes" xml:space="preserve">
          <source>Provide either flat or nested representations from the same endpoint, depending on the requested media type.</source>
          <target state="translated">요청 된 미디어 유형에 따라 동일한 엔드 포인트에서 평평하거나 중첩 된 표현을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac7d5fa51823458e7b8dd9b8a214c35f69e73bb" translate="yes" xml:space="preserve">
          <source>Provided they inherit from &lt;code&gt;rest_framework.permissions.BasePermission&lt;/code&gt;, permissions can be composed using standard Python bitwise operators. For example, &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt; could be written:</source>
          <target state="translated">&lt;code&gt;rest_framework.permissions.BasePermission&lt;/code&gt; 을 상속받은 경우 표준 Python 비트 연산자를 사용하여 권한을 구성 할 수 있습니다. 예를 들어 &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt; 는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c543e0dfa8dfdca8b114bfd53aa6f816e103db15" translate="yes" xml:space="preserve">
          <source>Provides &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; method handlers.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="452f83ee9f2a3f76ad84d12641679df3216861f6" translate="yes" xml:space="preserve">
          <source>Provides &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;post&lt;/code&gt; method handlers.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;post&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f19ca7204ae0b48660d7d3fd5dc3c257a94cb7d4" translate="yes" xml:space="preserve">
          <source>Provides &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; method handlers.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd7398495b24a31574ac0e1c1ed86930c2be5b77" translate="yes" xml:space="preserve">
          <source>Provides &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; method handlers.</source>
          <target state="translated">제공 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 방법 핸들러.</target>
        </trans-unit>
        <trans-unit id="b456570af758ecc02dc8632e5312576b6d16d642" translate="yes" xml:space="preserve">
          <source>Provides &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; method handlers.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="eec4c969a7db94142374064b1e2a4c9e1d60a2a8" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;.create(request, *args, **kwargs)&lt;/code&gt; method, that implements creating and saving a new model instance.</source>
          <target state="translated">새 모델 인스턴스 작성 및 저장을 구현 하는 &lt;code&gt;.create(request, *args, **kwargs)&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67b53f8fd08c7ab9a1c158dc12db6c28094d2900" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;.destroy(request, *args, **kwargs)&lt;/code&gt; method, that implements deletion of an existing model instance.</source>
          <target state="translated">기존 모델 인스턴스의 삭제를 구현 하는 &lt;code&gt;.destroy(request, *args, **kwargs)&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1ad4cb130e5eb32ebfcb396e34e2fc6ade3a566" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;.list(request, *args, **kwargs)&lt;/code&gt; method, that implements listing a queryset.</source>
          <target state="translated">쿼리 세트 나열을 구현 하는 &lt;code&gt;.list(request, *args, **kwargs)&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50316537313584cf9902613337843967734b5344" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;.retrieve(request, *args, **kwargs)&lt;/code&gt; method, that implements returning an existing model instance in a response.</source>
          <target state="translated">응답으로 기존 모델 인스턴스를 리턴 하는 &lt;code&gt;.retrieve(request, *args, **kwargs)&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7258b1af7508626243797774b13b73c68c762f61" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;.update(request, *args, **kwargs)&lt;/code&gt; method, that implements updating and saving an existing model instance.</source>
          <target state="translated">기존 모델 인스턴스의 업데이트 및 저장을 구현 하는 &lt;code&gt;.update(request, *args, **kwargs)&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00c2a58a09d7cffd3e60bc52ed50b8d57fc16cda" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;delete&lt;/code&gt; method handler.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ba91fb643bc9a5a0f6029de79c5831a7c5432e8c" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;get&lt;/code&gt; method handler.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5de44a4cb9d48da4031cd6199719edc376adcd" translate="yes" xml:space="preserve">
          <source>Provides a &lt;code&gt;post&lt;/code&gt; method handler.</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; 메소드 핸들러를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8c8efb395412d29a987e493a9fc4428feaa0d16e" translate="yes" xml:space="preserve">
          <source>Provides a consistent pagination view. When used properly &lt;code&gt;CursorPagination&lt;/code&gt; ensures that the client will never see the same item twice when paging through records, even when new items are being inserted by other clients during the pagination process.</source>
          <target state="translated">일관된 페이지 매김보기를 제공합니다. 올바르게 사용하면 &lt;code&gt;CursorPagination&lt;/code&gt; 은 페이지 매김 프로세스 중에 다른 클라이언트가 새 항목을 삽입하는 경우에도 레코드를 페이징 할 때 클라이언트가 동일한 항목을 두 번 보지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="6757f8461ff3252dc1860ee32df40084aaaca324" translate="yes" xml:space="preserve">
          <source>Providing a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.</source>
          <target state="translated">전역 템플릿 디렉토리에 이러한 경로 중 하나를 가진 템플릿을 제공하면 관련 페이지 매김 클래스에 대한 기본 렌더링이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="24ae4babd82f894853c981d9368c11ff073d1296" translate="yes" xml:space="preserve">
          <source>Pulling it all together</source>
          <target state="translated">모두 함께 당기기</target>
        </trans-unit>
        <trans-unit id="9fbf249bc8d1469a36edb8ec042669ca077bcda4" translate="yes" xml:space="preserve">
          <source>Python (3.5, 3.6, 3.7)</source>
          <target state="translated">파이썬 (3.5, 3.6, 3.7)</target>
        </trans-unit>
        <trans-unit id="ecbfbef36e589a411efda8a1391afa645eb761e4" translate="yes" xml:space="preserve">
          <source>Query parameter formats</source>
          <target state="translated">쿼리 매개 변수 형식</target>
        </trans-unit>
        <trans-unit id="07f1adc12ae138ef0077e47986e81e2075ff71c9" translate="yes" xml:space="preserve">
          <source>QueryFields</source>
          <target state="translated">QueryFields</target>
        </trans-unit>
        <trans-unit id="0da525eb34bbedc6d1bb70f4aa5a893692a37a66" translate="yes" xml:space="preserve">
          <source>QueryParameterVersioning</source>
          <target state="translated">QueryParameterVersioning</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="fada44ca4f3d7535c5057091bd1d9944ec010a21" translate="yes" xml:space="preserve">
          <source>Quit out of the shell...</source>
          <target state="translated">껍질을 그만 둔다 ...</target>
        </trans-unit>
        <trans-unit id="5e9cc2b0a642b0540c5ba634f499f64b144ccb5c" translate="yes" xml:space="preserve">
          <source>REST Condition</source>
          <target state="translated">REST 조건</target>
        </trans-unit>
        <trans-unit id="2e28e061dec299bd3936814d60f921424f696cab" translate="yes" xml:space="preserve">
          <source>REST framework 2 provided an API to allow developers to override how a &lt;code&gt;ModelSerializer&lt;/code&gt; class would automatically generate the default set of fields.</source>
          <target state="translated">REST 프레임 워크 2는 개발자가 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스가 기본 필드 세트를 자동으로 생성하는 방법을 대체 할 수 있도록 API를 제공했습니다 .</target>
        </trans-unit>
        <trans-unit id="880be8b26326496c77f5fd46b0e9e36c0286d5c1" translate="yes" xml:space="preserve">
          <source>REST framework adds support for automatic URL routing to Django, and provides you with a simple, quick and consistent way of wiring your view logic to a set of URLs.</source>
          <target state="translated">REST 프레임 워크는 Django에 자동 URL 라우팅을 지원하고 뷰 로직을 일련의 URL에 간단하고 빠르고 일관되게 연결하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e190333aabf41f78c85835094d7e73e69a8e895d" translate="yes" xml:space="preserve">
          <source>REST framework also allows you to work with regular function based views. It provides a set of simple decorators that wrap your function based views to ensure they receive an instance of &lt;code&gt;Request&lt;/code&gt; (rather than the usual Django &lt;code&gt;HttpRequest&lt;/code&gt;) and allows them to return a &lt;code&gt;Response&lt;/code&gt; (instead of a Django &lt;code&gt;HttpResponse&lt;/code&gt;), and allow you to configure how the request is processed.</source>
          <target state="translated">REST 프레임 워크를 사용하면 일반 함수 기반보기로 작업 할 수 있습니다. 함수 기반 뷰를 래핑하여 일반적인 Django &lt;code&gt;HttpRequest&lt;/code&gt; 대신 &lt;code&gt;Request&lt;/code&gt; 인스턴스를 수신 하고 Django &lt;code&gt;HttpResponse&lt;/code&gt; 대신 &lt;code&gt;Response&lt;/code&gt; 을 반환 할 수 있도록 간단한 데코레이터 세트를 제공하고 방법을 구성 할 수 있습니다 요청이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0726680912684306c0866ce5acd69c91266f07" translate="yes" xml:space="preserve">
          <source>REST framework also includes a client for interacting with your application using the popular Python library, &lt;code&gt;requests&lt;/code&gt;. This may be useful if:</source>
          <target state="translated">REST 프레임 워크에는 널리 사용되는 Python 라이브러리 &lt;code&gt;requests&lt;/code&gt; 을 사용하여 애플리케이션과 상호 작용하기위한 클라이언트도 포함됩니다 . 다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0b4bc05555b95a911cd24dc6c4279cc987bacf" translate="yes" xml:space="preserve">
          <source>REST framework also introduces a &lt;code&gt;Response&lt;/code&gt; object, which is a type of &lt;code&gt;TemplateResponse&lt;/code&gt; that takes unrendered content and uses content negotiation to determine the correct content type to return to the client.</source>
          <target state="translated">REST 프레임 워크는 또한 렌더링되지 않은 컨텐츠를 가져오고 컨텐츠 협상을 사용하여 클라이언트에 리턴 할 올바른 컨텐츠 유형을 판별하는 &lt;code&gt;TemplateResponse&lt;/code&gt; 유형 인 &lt;code&gt;Response&lt;/code&gt; 오브젝트를 도입합니다 .</target>
        </trans-unit>
        <trans-unit id="8dff91d1052f2b4e884d6a73c6c2f81ea1fee000" translate="yes" xml:space="preserve">
          <source>REST framework also provides a test case class for isolating &lt;code&gt;urlpatterns&lt;/code&gt; on a per-class basis. Note that this inherits from Django's &lt;code&gt;SimpleTestCase&lt;/code&gt;, and will most likely need to be mixed with another test case class.</source>
          <target state="translated">REST 프레임 워크는 또한 클래스별로 &lt;code&gt;urlpatterns&lt;/code&gt; 을 분리하기위한 테스트 케이스 클래스를 제공 합니다. 이것은 Django의 &lt;code&gt;SimpleTestCase&lt;/code&gt; 에서 상속 되며 다른 테스트 케이스 클래스와 혼합되어야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c803f9285651b9fefa91c11153732766cabc4e94" translate="yes" xml:space="preserve">
          <source>REST framework includes a configurable mechanism for determining how your API should respond to &lt;code&gt;OPTIONS&lt;/code&gt; requests. This allows you to return API schema or other resource information.</source>
          <target state="translated">REST 프레임 워크에는 API가 &lt;code&gt;OPTIONS&lt;/code&gt; 요청에 응답하는 방법을 결정하기위한 구성 가능한 메커니즘이 포함되어 있습니다 . 이를 통해 API 스키마 또는 기타 리소스 정보를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6392e94e6cbfcf2b9371767c95840510cff121bb" translate="yes" xml:space="preserve">
          <source>REST framework includes a couple of defaults that may be useful in this context.</source>
          <target state="translated">REST 프레임 워크에는이 컨텍스트에서 유용 할 수있는 몇 가지 기본값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0343a7c23fc17cd499ba1461d36b3aaa9ba3fbdf" translate="yes" xml:space="preserve">
          <source>REST framework includes a few helper classes that extend Django's existing test framework, and improve support for making API requests.</source>
          <target state="translated">REST 프레임 워크에는 Django의 기존 테스트 프레임 워크를 확장하고 API 요청 작성 지원을 향상시키는 몇 가지 헬퍼 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de1c6151c4e46acd27061c40d63e10cfdadf0a10" translate="yes" xml:space="preserve">
          <source>REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.</source>
          <target state="translated">REST 프레임 워크에는 다양한 내장 파서 클래스가 포함되어있어 다양한 매체 유형의 요청을 승인 할 수 있습니다. 고유 한 사용자 정의 파서 정의도 지원하므로 API에서 허용하는 미디어 유형을 유연하게 디자인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29efb753cf488a96b733aa2b8ff9a23ec2ec1158" translate="yes" xml:space="preserve">
          <source>REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.</source>
          <target state="translated">REST 프레임 워크에는 다양한 렌더러 클래스가 포함되어있어 다양한 미디어 유형으로 응답을 반환 할 수 있습니다. 고유 한 사용자 정의 렌더러를 정의 할 수있어 고유 한 미디어 유형을 디자인 할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="18cdf9ad6ef92afa8033e147734f51b78739a3df" translate="yes" xml:space="preserve">
          <source>REST framework includes a number of permission classes that we can use to restrict who can access a given view. In this case the one we're looking for is &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt;, which will ensure that authenticated requests get read-write access, and unauthenticated requests get read-only access.</source>
          <target state="translated">REST 프레임 워크에는 지정된 뷰에 액세스 할 수있는 사람을 제한하는 데 사용할 수있는 여러 권한 클래스가 포함되어 있습니다. 이 경우 우리가 찾는 것은 &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt; 입니다 . 이것은 인증 된 요청이 읽기-쓰기 액세스를 받고 인증되지 않은 요청이 읽기 전용 액세스를 갖도록합니다.</target>
        </trans-unit>
        <trans-unit id="a8963149cc79756f8a17f3a9f95c6b16fda0546b" translate="yes" xml:space="preserve">
          <source>REST framework includes an abstraction for dealing with &lt;code&gt;ViewSets&lt;/code&gt;, that allows the developer to concentrate on modeling the state and interactions of the API, and leave the URL construction to be handled automatically, based on common conventions.</source>
          <target state="translated">REST 프레임 워크에는 개발자가 API의 상태 및 상호 작용을 모델링하는 데 집중하고 공통된 규칙에 따라 URL 구성이 자동으로 처리되도록 하는 &lt;code&gt;ViewSets&lt;/code&gt; 처리를위한 추상화가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="6c88300f41be30d0c1caf6de751c3e8f24014cec" translate="yes" xml:space="preserve">
          <source>REST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.</source>
          <target state="translated">REST 프레임 워크에는 사용자 정의 가능한 페이지 매김 스타일 지원이 포함됩니다. 이를 통해 큰 결과 집합이 개별 데이터 페이지로 분할되는 정도를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437474affca462e3291cafef9dc92a25f72b644c" translate="yes" xml:space="preserve">
          <source>REST framework includes the following test case classes, that mirror the existing Django test case classes, but use &lt;code&gt;APIClient&lt;/code&gt; instead of Django's default &lt;code&gt;Client&lt;/code&gt;.</source>
          <target state="translated">REST 프레임 워크에는 기존 Django 테스트 케이스 클래스를 미러링하지만 Django의 기본 &lt;code&gt;Client&lt;/code&gt; 대신 &lt;code&gt;APIClient&lt;/code&gt; 를 사용하는 다음 테스트 케이스 클래스가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5aab35647e175862c0a8ef3dc9f9a7b9bd1206b" translate="yes" xml:space="preserve">
          <source>REST framework introduces a &lt;code&gt;Request&lt;/code&gt; object that extends the regular &lt;code&gt;HttpRequest&lt;/code&gt;, and provides more flexible request parsing. The core functionality of the &lt;code&gt;Request&lt;/code&gt; object is the &lt;code&gt;request.data&lt;/code&gt; attribute, which is similar to &lt;code&gt;request.POST&lt;/code&gt;, but more useful for working with Web APIs.</source>
          <target state="translated">REST 프레임 워크 는 일반 &lt;code&gt;HttpRequest&lt;/code&gt; 를 확장하고 보다 유연한 요청 구문 분석을 제공 하는 &lt;code&gt;Request&lt;/code&gt; 객체를 도입합니다 . &lt;code&gt;Request&lt;/code&gt; 객체 의 핵심 기능은 &lt;code&gt;request.data&lt;/code&gt; 속성으로 &lt;code&gt;request.POST&lt;/code&gt; 와 비슷 하지만 웹 API 작업에 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6f68b87812eec299799c438ac4923c01341c7298" translate="yes" xml:space="preserve">
          <source>REST framework is a &lt;em&gt;collaboratively funded project&lt;/em&gt;. If you use REST framework commercially we strongly encourage you to invest in its continued development by &lt;strong&gt;&lt;a href=&quot;https://www.django-rest-framework.org/community/funding/&quot;&gt;signing up for a paid plan&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">REST 프레임 워크는 &lt;em&gt;공동 자금 지원 프로젝트&lt;/em&gt; 입니다. REST 프레임 워크를 상업적으로 사용 &lt;strong&gt;&lt;a href=&quot;https://www.django-rest-framework.org/community/funding/&quot;&gt;하는 경우 유료 요금제&lt;/a&gt;&lt;/strong&gt; 에 &lt;strong&gt;가입&lt;/strong&gt; 하여 지속적인 개발에 투자하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b2360a55c608ac4b94dd40f7936f310142b0a382" translate="yes" xml:space="preserve">
          <source>REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.</source>
          <target state="translated">REST 프레임 워크 권한은 객체 레벨 권한도 지원합니다. 개체 수준 권한은 사용자가 특정 개체 (일반적으로 모델 인스턴스)에 대해 작업 할 수 있는지 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe9515e608a58af6db3d51ab8fe5169fb332dc8" translate="yes" xml:space="preserve">
          <source>REST framework provides a number of authentication schemes out of the box, and also allows you to implement custom schemes.</source>
          <target state="translated">REST 프레임 워크는 기본적으로 여러 가지 인증 체계를 제공하며 사용자 정의 체계를 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15cc09c94bc4879d337f8fe40525b80ae776644" translate="yes" xml:space="preserve">
          <source>REST framework provides an &lt;code&gt;APIView&lt;/code&gt; class, which subclasses Django's &lt;code&gt;View&lt;/code&gt; class.</source>
          <target state="translated">REST 프레임 워크는 Django의 &lt;code&gt;View&lt;/code&gt; 클래스 를 서브 클래스로 하는 &lt;code&gt;APIView&lt;/code&gt; 클래스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6bc9fad60070b310dbe25f28647a6ad9d0047433" translate="yes" xml:space="preserve">
          <source>REST framework provides flexible, per-request authentication, that gives you the ability to:</source>
          <target state="translated">REST 프레임 워크는 유연한 요청 당 인증을 제공하여 다음과 같은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="492d1a02bdce0c7351e3bd3500e69778eef6312b" translate="yes" xml:space="preserve">
          <source>REST framework provides two utility functions to make it more simple to return absolute URIs from your Web API.</source>
          <target state="translated">REST 프레임 워크는 웹 API에서 절대 URI를 더 간단하게 리턴 할 수 있도록 두 가지 유틸리티 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fdf677aac99248dc5489ce84e986610113da9607" translate="yes" xml:space="preserve">
          <source>REST framework provides two wrappers you can use to write API views.</source>
          <target state="translated">REST 프레임 워크는 API보기를 작성하는 데 사용할 수있는 두 개의 랩퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e265b3f93979d9e2787e01b71f2b974c595c18c" translate="yes" xml:space="preserve">
          <source>REST framework requires the following:</source>
          <target state="translated">REST 프레임 워크에는 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3d08ab92c3b61083995d9b01687e314ea9c55e63" translate="yes" xml:space="preserve">
          <source>REST framework supports HTTP content negotiation by providing a &lt;code&gt;Response&lt;/code&gt; class which allows you to return content that can be rendered into multiple content types, depending on the client request.</source>
          <target state="translated">REST 프레임 워크는 클라이언트 요청에 따라 여러 컨텐츠 유형으로 렌더링 될 수있는 컨텐츠를 리턴 할 수 있는 &lt;code&gt;Response&lt;/code&gt; 클래스를 제공하여 HTTP 컨텐츠 협상을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="0663d6160fea974e4092f8a0772107677e8ee887" translate="yes" xml:space="preserve">
          <source>REST framework supports a few browser enhancements such as browser-based &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; forms.</source>
          <target state="translated">REST 프레임 워크는 브라우저 기반 &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;PATCH&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 양식 과 같은 몇 가지 브라우저 개선 사항을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="42daee16fffebc5f54a6ef88ecba15118ce0b0e9" translate="yes" xml:space="preserve">
          <source>REST framework supports all of these styles, and can apply them across forward or reverse relationships, or apply them across custom managers such as generic foreign keys.</source>
          <target state="translated">REST 프레임 워크는 이러한 모든 스타일을 지원하며 정방향 또는 역방향 관계에 적용하거나 일반 외래 키와 같은 사용자 정의 관리자에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158f45037357943662d92c79cc139aa30173c666" translate="yes" xml:space="preserve">
          <source>REST framework uses a simple style of content negotiation to determine which media type should be returned to a client, based on the available renderers, the priorities of each of those renderers, and the client's &lt;code&gt;Accept:&lt;/code&gt; header. The style used is partly client-driven, and partly server-driven.</source>
          <target state="translated">REST 프레임 워크는 간단한 스타일의 컨텐츠 협상을 사용하여 사용 가능한 렌더러, 각 렌더러의 우선 순위 및 클라이언트의 &lt;code&gt;Accept:&lt;/code&gt; 헤더 에 따라 클라이언트에 리턴 할 매체 유형을 판별합니다 . 사용 된 스타일은 부분적으로 클라이언트 중심이며 부분적으로 서버 중심입니다.</target>
        </trans-unit>
        <trans-unit id="60703ba510378b0c661036811734c7adb1de777c" translate="yes" xml:space="preserve">
          <source>REST framework's &lt;code&gt;Request&lt;/code&gt; class extends the standard &lt;code&gt;HttpRequest&lt;/code&gt;, adding support for REST framework's flexible request parsing and request authentication.</source>
          <target state="translated">REST 프레임 워크의 &lt;code&gt;Request&lt;/code&gt; 클래스는 표준 &lt;code&gt;HttpRequest&lt;/code&gt; 를 확장하여 REST 프레임 워크의 유연한 요청 구문 분석 및 요청 인증에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5bb153b9b5177b6ef9d9ed42f63210a4a4684fff" translate="yes" xml:space="preserve">
          <source>REST framework's Request objects provide flexible request parsing that allows you to treat requests with JSON data or other media types in the same way that you would normally deal with form data.</source>
          <target state="translated">REST 프레임 워크의 요청 오브젝트는 일반적으로 양식 데이터를 처리하는 것과 동일한 방식으로 JSON 데이터 또는 기타 매체 유형으로 요청을 처리 할 수있는 유연한 요청 구문 분석을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fef79add22e38cf53cc3e9372ab3622d5efd62ad" translate="yes" xml:space="preserve">
          <source>REST framework's content negotiation classes handle selection of both the appropriate parser for the request, and the appropriate renderer for the response, so you should implement both the &lt;code&gt;.select_parser(request, parsers)&lt;/code&gt; and &lt;code&gt;.select_renderer(request, renderers, format_suffix)&lt;/code&gt; methods.</source>
          <target state="translated">REST 프레임 워크의 컨텐츠 협상 클래스는 요청에 대한 적절한 구문 분석기와 응답에 대한 적절한 렌더러 모두의 선택을 처리하므로 &lt;code&gt;.select_parser(request, parsers)&lt;/code&gt; 및 &lt;code&gt;.select_renderer(request, renderers, format_suffix)&lt;/code&gt; 메소드를 모두 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5837ca6ada1d2cb673a680eab91d539a65045de5" translate="yes" xml:space="preserve">
          <source>REST framework's views handle various exceptions, and deal with returning appropriate error responses.</source>
          <target state="translated">REST 프레임 워크의 뷰는 다양한 예외를 처리하고 적절한 오류 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1667358e0c127c960f41d632436bcb17139bf35c" translate="yes" xml:space="preserve">
          <source>Raise a validation error.</source>
          <target state="translated">유효성 검사 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6c92e184a9403cf0278350ce60f7f20187a7cab9" translate="yes" xml:space="preserve">
          <source>Raised if the request contains malformed data when accessing &lt;code&gt;request.data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;request.data&lt;/code&gt; 에 액세스 할 때 요청에 잘못된 데이터가 포함되어 있으면 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8ac960a02b71c3c8f60e07fd3f6edfea1be98cdf" translate="yes" xml:space="preserve">
          <source>Raised if there are no parsers that can handle the content type of the request data when accessing &lt;code&gt;request.data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;request.data&lt;/code&gt; 에 액세스 할 때 요청 데이터의 컨텐츠 유형을 처리 할 수있는 구문 분석기가없는 경우 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="9db406367f67f4bf92e92b22fda924a8819f393a" translate="yes" xml:space="preserve">
          <source>Raised when a resource does not exists at the given URL. This exception is equivalent to the standard &lt;code&gt;Http404&lt;/code&gt; Django exception.</source>
          <target state="translated">주어진 URL에 리소스가 없을 때 발생합니다. 이 예외는 표준 &lt;code&gt;Http404&lt;/code&gt; Django 예외 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7c0c211abf448ce4f4e2f91369252198096a2d14" translate="yes" xml:space="preserve">
          <source>Raised when an authenticated request fails the permission checks.</source>
          <target state="translated">인증 된 요청이 권한 검사에 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2675d0d5097477c1cddf1170b94bea34a0e89b26" translate="yes" xml:space="preserve">
          <source>Raised when an incoming request fails the throttling checks.</source>
          <target state="translated">들어오는 요청이 제한 검사에 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bdc7bdac61cb8bfd4de6ed80117827693a9a0b1" translate="yes" xml:space="preserve">
          <source>Raised when an incoming request includes incorrect authentication.</source>
          <target state="translated">들어오는 요청에 잘못된 인증이 포함되어있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52a3b50bda3ac92714bc9863a82cfb7b1947887b" translate="yes" xml:space="preserve">
          <source>Raised when an incoming request occurs that does not map to a handler method on the view.</source>
          <target state="translated">보기의 핸들러 메소드에 맵핑되지 않은 수신 요청이 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78d7e45d41a92473fd618e52af5e817f1f5008b8" translate="yes" xml:space="preserve">
          <source>Raised when an incoming request occurs with an &lt;code&gt;Accept&lt;/code&gt; header that cannot be satisfied by any of the available renderers.</source>
          <target state="translated">사용 가능한 렌더러가 만족할 수없는 &lt;code&gt;Accept&lt;/code&gt; 헤더 로 들어오는 요청이 발생하면 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3cc735d066b051212660790240eccfc8cb1c88ea" translate="yes" xml:space="preserve">
          <source>Raised when an unauthenticated request fails the permission checks.</source>
          <target state="translated">인증되지 않은 요청이 권한 검사에 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a45199f4ebba1d4ce008f3ab4247300cb1a28a2" translate="yes" xml:space="preserve">
          <source>Raising an exception on invalid data</source>
          <target state="translated">유효하지 않은 데이터에 대한 예외 발생</target>
        </trans-unit>
        <trans-unit id="9e2d62f8a01d436ee4b6b0251db223796267aced" translate="yes" xml:space="preserve">
          <source>Raising validation errors</source>
          <target state="translated">유효성 검사 오류 발생</target>
        </trans-unit>
        <trans-unit id="9e6dd0e17a3a1c90245627e3c8e42c98d05a9c5e" translate="yes" xml:space="preserve">
          <source>Rather than relative URLs, such as:</source>
          <target state="translated">다음과 같은 상대 URL 대신</target>
        </trans-unit>
        <trans-unit id="aefb41d5ac993924ddbde4d7bb64637f02dfc047" translate="yes" xml:space="preserve">
          <source>Rather than write multiple views we're grouping together all the common behavior into classes called &lt;code&gt;ViewSets&lt;/code&gt;.</source>
          <target state="translated">여러 개의 뷰를 작성하는 대신 모든 일반적인 동작을 &lt;code&gt;ViewSets&lt;/code&gt; 클래스로 그룹화합니다 .</target>
        </trans-unit>
        <trans-unit id="90726a283a16293be3b685bbadc17b2e18188ea5" translate="yes" xml:space="preserve">
          <source>Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:</source>
          <target state="translated">자체 뷰 세트를 작성하는 대신 기본 동작 집합을 제공하는 기존 기본 클래스를 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3133fa43b1596a3a2ad081bd82bb3b7feec05c2" translate="yes" xml:space="preserve">
          <source>Read-only BaseSerializer classes</source>
          <target state="translated">읽기 전용 BaseSerializer 클래스</target>
        </trans-unit>
        <trans-unit id="6ff14213f1f79737792047d6e5dc9c4b0e9fdb3c" translate="yes" xml:space="preserve">
          <source>Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.</source>
          <target state="translated">읽기 전용 필드는 API 출력에 포함되지만 작성 또는 업데이트 조작 중에 입력에 포함되지 않아야합니다. 시리얼 라이저 입력에 잘못 포함 된 'read_only'필드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="df3b4ec76d74814111b1cc49af788792a6675cc7" translate="yes" xml:space="preserve">
          <source>Read-write BaseSerializer classes</source>
          <target state="translated">읽기 / 쓰기 BaseSerializer 클래스</target>
        </trans-unit>
        <trans-unit id="8558bb40fd34dc2246346fdfd0db426ab1bcf2cb" translate="yes" xml:space="preserve">
          <source>ReadOnlyField</source>
          <target state="translated">ReadOnlyField</target>
        </trans-unit>
        <trans-unit id="631cd46f76e064977e92b8ac83f7d8e5f4a045df" translate="yes" xml:space="preserve">
          <source>ReadOnlyModelViewSet</source>
          <target state="translated">ReadOnlyModelViewSet</target>
        </trans-unit>
        <trans-unit id="d5cd62637be1653b4e5db14e6962c7eb03cdfe42" translate="yes" xml:space="preserve">
          <source>Really we'd like all code snippets to be visible to anyone, but also make sure that only the user that created a code snippet is able to update or delete it.</source>
          <target state="translated">실제로 모든 코드 스 니펫을 누구나 볼 수 있기를 원하지만 코드 스 니펫을 만든 사용자 만 업데이트하거나 삭제할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5844da1b0e0d971812044e0db1ad44b4c4902fda" translate="yes" xml:space="preserve">
          <source>Redirection - 3xx</source>
          <target state="translated">리디렉션-3xx</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되는 경우 수정하거나 수정하지 않고 소스 및 이진 형식으로 재배포 및 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">이진 형식으로 재배포 할 경우 위의 저작권 표시,이 조건 목록 및 배포와 함께 제공된 설명서 및 / 또는 기타 자료의 다음 면책 사항을 재현해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">소스 코드의 재배포에는 위의 저작권 표시,이 조건 목록 및 다음 면책 사항이 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="405dbb3628a89c922fce6ec4735d55b03ee9ebeb" translate="yes" xml:space="preserve">
          <source>Ref: Authentication</source>
          <target state="translated">참조 : 인증</target>
        </trans-unit>
        <trans-unit id="abba040e64db0d4437cba8ea3b35460e5c9f31e5" translate="yes" xml:space="preserve">
          <source>Ref: Exceptions</source>
          <target state="translated">참고 : 예외</target>
        </trans-unit>
        <trans-unit id="b49fba8e0e98053464a3342a4e92330e762b6200" translate="yes" xml:space="preserve">
          <source>Ref: Filtering</source>
          <target state="translated">참조 : 필터링</target>
        </trans-unit>
        <trans-unit id="31bd099533a9ff44a57af96cf408a98173f4bb07" translate="yes" xml:space="preserve">
          <source>Ref: Generic views</source>
          <target state="translated">참조 : 일반 뷰</target>
        </trans-unit>
        <trans-unit id="1c808cd30dc66da1e8ce8cd4fa5e8a1a30054a5b" translate="yes" xml:space="preserve">
          <source>Ref: Pagination</source>
          <target state="translated">참조 : 페이지 매김</target>
        </trans-unit>
        <trans-unit id="2229b443d2b01e89a485bcde6376d87e34967558" translate="yes" xml:space="preserve">
          <source>Ref: Parsers</source>
          <target state="translated">참조 : 파서</target>
        </trans-unit>
        <trans-unit id="f7a2e90b18f77488612161445f1280401515c977" translate="yes" xml:space="preserve">
          <source>Ref: Permissions</source>
          <target state="translated">참조 : 권한</target>
        </trans-unit>
        <trans-unit id="1dff6ca594597785b8d8694199a1c43e65927650" translate="yes" xml:space="preserve">
          <source>Ref: Renderers</source>
          <target state="translated">참조 : 렌더러</target>
        </trans-unit>
        <trans-unit id="6f1962544bed979f188166c8eca645878d4548f4" translate="yes" xml:space="preserve">
          <source>Ref: Routers</source>
          <target state="translated">참조 : 라우터</target>
        </trans-unit>
        <trans-unit id="4347d28065f13f26bc9b61911dcd1efc7339fb69" translate="yes" xml:space="preserve">
          <source>Ref: Serializer fields</source>
          <target state="translated">참조 : 시리얼 라이저 필드</target>
        </trans-unit>
        <trans-unit id="22a8fa573d56a40e5c337e389ad3f9508a316df7" translate="yes" xml:space="preserve">
          <source>Ref: Serializer relations</source>
          <target state="translated">참조 : 시리얼 라이저 관계</target>
        </trans-unit>
        <trans-unit id="921153299896d17c05ab76067cb0c298d24a8072" translate="yes" xml:space="preserve">
          <source>Ref: Serializers</source>
          <target state="translated">참조 : 시리얼 라이저</target>
        </trans-unit>
        <trans-unit id="43d293fe82987df25fdb0b524123b6b746f1530b" translate="yes" xml:space="preserve">
          <source>Ref: Settings</source>
          <target state="translated">참조 : 설정</target>
        </trans-unit>
        <trans-unit id="655c2fcd56586488e094dcd8e1d213c05d101fc4" translate="yes" xml:space="preserve">
          <source>Ref: Throttling</source>
          <target state="translated">참조 : 조절</target>
        </trans-unit>
        <trans-unit id="5764974b13ec74cf33917e3923ecf23091085bca" translate="yes" xml:space="preserve">
          <source>Ref: Validators</source>
          <target state="translated">참조 : 검증 자</target>
        </trans-unit>
        <trans-unit id="85ede1d441de942646a3344ab885b59d5a7118b1" translate="yes" xml:space="preserve">
          <source>Ref: Versioning</source>
          <target state="translated">참조 : 버전 관리</target>
        </trans-unit>
        <trans-unit id="53bb8dce334d5890ef27c3451513c4e657691d33" translate="yes" xml:space="preserve">
          <source>Ref: ViewSets</source>
          <target state="translated">참조 : ViewSets</target>
        </trans-unit>
        <trans-unit id="ab20e00cd979d08454c70130ad88e5f29aaa27b0" translate="yes" xml:space="preserve">
          <source>Refactoring to use ViewSets</source>
          <target state="translated">ViewSet을 사용하기위한 리팩토링</target>
        </trans-unit>
        <trans-unit id="39d471f36dbc2982caaa3c8d1076d2760a3dc1a3" translate="yes" xml:space="preserve">
          <source>RegexField</source>
          <target state="translated">RegexField</target>
        </trans-unit>
        <trans-unit id="ea0429828de082200e1eed68f832107b100865e5" translate="yes" xml:space="preserve">
          <source>Registering the viewsets with the router is similar to providing a urlpattern. We include two arguments - the URL prefix for the views, and the viewset itself.</source>
          <target state="translated">라우터에 뷰셋을 등록하는 것은 urlpattern을 제공하는 것과 유사합니다. 뷰의 URL 접두사와 뷰셋 자체라는 두 가지 인수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e14322d05b8be1e3275c87c5a2dd1a9f497c78" translate="yes" xml:space="preserve">
          <source>Relational fields</source>
          <target state="translated">관계형 필드</target>
        </trans-unit>
        <trans-unit id="8ca24410212670164bb82955818ef65913d011e9" translate="yes" xml:space="preserve">
          <source>Relational fields are used to represent model relationships. They can be applied to &lt;code&gt;ForeignKey&lt;/code&gt;, &lt;code&gt;ManyToManyField&lt;/code&gt; and &lt;code&gt;OneToOneField&lt;/code&gt; relationships, as well as to reverse relationships, and custom relationships such as &lt;code&gt;GenericForeignKey&lt;/code&gt;.</source>
          <target state="translated">관계형 필드는 모델 관계를 나타내는 데 사용됩니다. &lt;code&gt;ForeignKey&lt;/code&gt; , &lt;code&gt;ManyToManyField&lt;/code&gt; 및 &lt;code&gt;OneToOneField&lt;/code&gt; 관계뿐만 아니라 관계 및 &lt;code&gt;GenericForeignKey&lt;/code&gt; 와 같은 사용자 정의 관계 에도 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a825474b932386d2c40ba0b374e46d68103b0543" translate="yes" xml:space="preserve">
          <source>Relationships use &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt;, instead of &lt;code&gt;PrimaryKeyRelatedField&lt;/code&gt;.</source>
          <target state="translated">관계 는 &lt;code&gt;PrimaryKeyRelatedField&lt;/code&gt; 대신 &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="619841dbc69ba7a2cecf822bd9c270fd14a313a8" translate="yes" xml:space="preserve">
          <source>RemoteUserAuthentication</source>
          <target state="translated">RemoteUserAuthentication</target>
        </trans-unit>
        <trans-unit id="dc95ef5866b51fb2e2f1a3e5068f3f8c76d8aaa9" translate="yes" xml:space="preserve">
          <source>Render the HTTP status code and text, for example &quot;404 Not Found&quot;.</source>
          <target state="translated">HTTP 상태 코드 및 텍스트를 렌더링하십시오 (예 : &quot;404 Not Found&quot;).</target>
        </trans-unit>
        <trans-unit id="fb59598c634370a7e7270b7912d5ffc5e9389ddc" translate="yes" xml:space="preserve">
          <source>Renderers</source>
          <target state="translated">Renderers</target>
        </trans-unit>
        <trans-unit id="18047b947a4e03aaee4f9221eac1c0bfa4baf250" translate="yes" xml:space="preserve">
          <source>Rendering responses</source>
          <target state="translated">렌더링 응답</target>
        </trans-unit>
        <trans-unit id="97b78e8c886b0f6a16c0f2ac093d1c8f5c9e2b1c" translate="yes" xml:space="preserve">
          <source>Renders data into HTML for an admin-like display:</source>
          <target state="translated">관리자와 유사한 디스플레이를 위해 데이터를 HTML로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="864b07257725389965ae34624fb0a9ab4204098e" translate="yes" xml:space="preserve">
          <source>Renders data into HTML for the Browsable API:</source>
          <target state="translated">검색 가능한 API를 위해 데이터를 HTML로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="42bd32225aa732513c197619ab254b7bb2dd9c4d" translate="yes" xml:space="preserve">
          <source>Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags, a hidden CSRF input or any submit buttons.</source>
          <target state="translated">직렬 변환기에서 반환 한 데이터를 HTML 양식으로 렌더링합니다. 이 렌더러의 출력에는 둘러싸는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그, 숨겨진 CSRF 입력 또는 제출 단추 가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="054c463dc5f42f114d9604fe29c7deb77545c59a" translate="yes" xml:space="preserve">
          <source>Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the &lt;code&gt;Response&lt;/code&gt; does not need to be serialized. Also, unlike other renderers, you may want to include a &lt;code&gt;template_name&lt;/code&gt; argument when creating the &lt;code&gt;Response&lt;/code&gt;.</source>
          <target state="translated">Django의 표준 템플릿 렌더링을 사용하여 데이터를 HTML로 렌더링합니다. 다른 렌더러와 달리 &lt;code&gt;Response&lt;/code&gt; 전달 된 데이터는 직렬화 될 필요가 없습니다. 또한 다른 렌더러와 달리 &lt;code&gt;Response&lt;/code&gt; 를 만들 때 &lt;code&gt;template_name&lt;/code&gt; 인수 를 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c236003b202a54e0c358af86e709c8e72dea1e6" translate="yes" xml:space="preserve">
          <source>Renders the request data into &lt;code&gt;JSON&lt;/code&gt;, using utf-8 encoding.</source>
          <target state="translated">utf-8 인코딩을 사용하여 요청 데이터를 &lt;code&gt;JSON&lt;/code&gt; 으로 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="acfd663c4b864341449fcbe2c63f20f1dc2ba35a" translate="yes" xml:space="preserve">
          <source>Repeated logic can be combined into a single class. In the above example, we only need to specify the &lt;code&gt;queryset&lt;/code&gt; once, and it'll be used across multiple views.</source>
          <target state="translated">반복 된 논리를 단일 클래스로 결합 할 수 있습니다. 위의 예에서는 &lt;code&gt;queryset&lt;/code&gt; 한 번만 지정하면 여러 뷰에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3003ae03d30be0e2b1c9ed8ad581657a52abd788" translate="yes" xml:space="preserve">
          <source>Request objects</source>
          <target state="translated">요청 객체</target>
        </trans-unit>
        <trans-unit id="7ff112a80688d34e1d2801a0af88fb33c0839c5c" translate="yes" xml:space="preserve">
          <source>Request parsing</source>
          <target state="translated">요청 파싱</target>
        </trans-unit>
        <trans-unit id="f7194e6a0d0b838382b202853e7c198d693fbabc" translate="yes" xml:space="preserve">
          <source>Requests</source>
          <target state="translated">Requests</target>
        </trans-unit>
        <trans-unit id="d31a577abf3f1936075b663dcf77c17e57528acb" translate="yes" xml:space="preserve">
          <source>Requests passed to the handler methods will be REST framework's &lt;code&gt;Request&lt;/code&gt; instances, not Django's &lt;code&gt;HttpRequest&lt;/code&gt; instances.</source>
          <target state="translated">핸들러 메소드에 전달 된 요청은 Django의 &lt;code&gt;HttpRequest&lt;/code&gt; 인스턴스가 아닌 REST 프레임 워크의 &lt;code&gt;Request&lt;/code&gt; 인스턴스가됩니다.</target>
        </trans-unit>
        <trans-unit id="f857cce3beafccc0d18ccdb009ede46e453abec1" translate="yes" xml:space="preserve">
          <source>RequestsClient</source>
          <target state="translated">RequestsClient</target>
        </trans-unit>
        <trans-unit id="567c7a88cb8e256ec6cfb7e6ee98b0842081b33c" translate="yes" xml:space="preserve">
          <source>RequestsClient and working with the database</source>
          <target state="translated">RequestsClient 및 데이터베이스 작업</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="4e44eac1867a5f49afff590b28705cfd584adb62" translate="yes" xml:space="preserve">
          <source>Requires either the &lt;code&gt;Pillow&lt;/code&gt; package or &lt;code&gt;PIL&lt;/code&gt; package. The &lt;code&gt;Pillow&lt;/code&gt; package is recommended, as &lt;code&gt;PIL&lt;/code&gt; is no longer actively maintained.</source>
          <target state="translated">&lt;code&gt;Pillow&lt;/code&gt; 패키지 또는 &lt;code&gt;PIL&lt;/code&gt; 패키지가 필요합니다 . &lt;code&gt;Pillow&lt;/code&gt; 로 패키지를 추천합니다 &lt;code&gt;PIL&lt;/code&gt; 은 더 이상 적극적으로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c96d91b6d9546af9ff2b726e00a19002e5be8a3a" translate="yes" xml:space="preserve">
          <source>Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your index... a resourceful route declares them in a single line of code.</source>
          <target state="translated">리소스 라우팅을 사용하면 주어진 유용한 컨트롤러에 대한 모든 공통 경로를 신속하게 선언 할 수 있습니다. 색인에 대해 별도의 경로를 선언하는 대신 리소스가 많은 경로는 단일 코드 행으로 선언합니다.</target>
        </trans-unit>
        <trans-unit id="e8c78c512002853b251ef9078ef6fdf5584fac17" translate="yes" xml:space="preserve">
          <source>Response objects</source>
          <target state="translated">응답 객체</target>
        </trans-unit>
        <trans-unit id="4de3193bd59587f34b8ed4f63db914502e1ada66" translate="yes" xml:space="preserve">
          <source>Response status codes beginning with the digit &quot;5&quot; indicate cases in which the server is aware that it has erred or is incapable of performing the request. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.</source>
          <target state="translated">숫자 &quot;5&quot;로 시작하는 응답 상태 코드는 서버가 서버에 오류가 있거나 요청을 수행 할 수 없음을 인식하는 경우를 나타냅니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다.</target>
        </trans-unit>
        <trans-unit id="1d449e0ee1765be49f04bcca59db5994625740d6" translate="yes" xml:space="preserve">
          <source>Response()</source>
          <target state="translated">Response()</target>
        </trans-unit>
        <trans-unit id="633f6e8b851aad01759e04e23cfe5188859a4d5b" translate="yes" xml:space="preserve">
          <source>Responses</source>
          <target state="translated">Responses</target>
        </trans-unit>
        <trans-unit id="19f9c2c26414593bc8073bed608705d8cddd422d" translate="yes" xml:space="preserve">
          <source>Rest Framework Generic Relations</source>
          <target state="translated">나머지 프레임 워크 일반 관계</target>
        </trans-unit>
        <trans-unit id="8be4775f6e23fad95d4c07938f76187ddb56bc17" translate="yes" xml:space="preserve">
          <source>RetrieveAPIView</source>
          <target state="translated">RetrieveAPIView</target>
        </trans-unit>
        <trans-unit id="4d4e65357b0f00d2b4751beba32eec30ed0ac257" translate="yes" xml:space="preserve">
          <source>RetrieveDestroyAPIView</source>
          <target state="translated">RetrieveDestroyAPIView</target>
        </trans-unit>
        <trans-unit id="b252bf85f84e57930516d774b14bc3ddc92d1d2f" translate="yes" xml:space="preserve">
          <source>RetrieveModelMixin</source>
          <target state="translated">RetrieveModelMixin</target>
        </trans-unit>
        <trans-unit id="f3305a9519a28b6d27eec3f986d609f186e6fde2" translate="yes" xml:space="preserve">
          <source>RetrieveUpdateAPIView</source>
          <target state="translated">RetrieveUpdateAPIView</target>
        </trans-unit>
        <trans-unit id="6864ef52b7ec2d874c793e23e797df4c129ee17e" translate="yes" xml:space="preserve">
          <source>RetrieveUpdateDestroyAPIView</source>
          <target state="translated">RetrieveUpdateDestroyAPIView</target>
        </trans-unit>
        <trans-unit id="24e35e1b4e423f2c0d8354fd9a5c9d92291c6cff" translate="yes" xml:space="preserve">
          <source>Returning URLs</source>
          <target state="translated">URL 반환</target>
        </trans-unit>
        <trans-unit id="2857a79b63bc9b6f7eba27f6c3277ce936c3e430" translate="yes" xml:space="preserve">
          <source>Returns a URL pattern list which includes format suffix patterns appended to each of the URL patterns provided.</source>
          <target state="translated">제공된 각 URL 패턴에 추가 된 형식 접미사 패턴을 포함하는 URL 패턴 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f90bc49086b251cda57f9a201391a353cca6f0dc" translate="yes" xml:space="preserve">
          <source>Returns a dictionary that represents the OpenAPI schema:</source>
          <target state="translated">OpenAPI 스키마를 나타내는 사전을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0fc24ece53d3977f0a6add646388b4a0a8070050" translate="yes" xml:space="preserve">
          <source>Returns a response with status code &lt;code&gt;400&lt;/code&gt; and &lt;code&gt;application/json&lt;/code&gt; content type.</source>
          <target state="translated">상태 코드 &lt;code&gt;400&lt;/code&gt; 및 &lt;code&gt;application/json&lt;/code&gt; 컨텐츠 유형 의 응답을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4948b35a5a0f84bc7b385e81f437525a2baff00e" translate="yes" xml:space="preserve">
          <source>Returns a response with status code &lt;code&gt;500&lt;/code&gt; and &lt;code&gt;application/json&lt;/code&gt; content type.</source>
          <target state="translated">상태 코드 &lt;code&gt;500&lt;/code&gt; 및 &lt;code&gt;application/json&lt;/code&gt; 컨텐츠 유형 의 응답을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a0529855d1c02c838c809353001a154fd48ea49a" translate="yes" xml:space="preserve">
          <source>Returns an object instance that should be used for detail views. Defaults to using the &lt;code&gt;lookup_field&lt;/code&gt; parameter to filter the base queryset.</source>
          <target state="translated">상세도에 사용해야하는 객체 인스턴스를 반환합니다. 기본 &lt;code&gt;lookup_field&lt;/code&gt; 을 필터링하기 위해 lookup_field 매개 변수 를 사용하도록 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c93cc6737de53495a50ea03f3fcd84d3f1742adc" translate="yes" xml:space="preserve">
          <source>Returns the class that should be used for the serializer. Defaults to returning the &lt;code&gt;serializer_class&lt;/code&gt; attribute.</source>
          <target state="translated">시리얼 라이저에 사용되는 클래스를 돌려줍니다. &lt;code&gt;serializer_class&lt;/code&gt; 속성 을 반환하도록 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2551bd36d5257bd85926bcd7b40ba7f2b86a5b15" translate="yes" xml:space="preserve">
          <source>Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the &lt;code&gt;queryset&lt;/code&gt; attribute.</source>
          <target state="translated">목록보기에 사용해야하고 상세보기에서 조회의 기준으로 사용해야하는 쿼리 집합을 반환합니다. &lt;code&gt;queryset&lt;/code&gt; 속성으로 지정된 쿼리 세트를 반환하도록 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8839eaf3a080a07477af458a5c26e6803bd86d9" translate="yes" xml:space="preserve">
          <source>Reverse relations</source>
          <target state="translated">역관계</target>
        </trans-unit>
        <trans-unit id="021a44eec413b01bdb27801d4c528b87525bf5d2" translate="yes" xml:space="preserve">
          <source>Reversing URLs for versioned APIs</source>
          <target state="translated">버전이 지정된 API의 URL 반전</target>
        </trans-unit>
        <trans-unit id="edb7261c3b09d5103cf7fbc0f2e35796d5f25a9d" translate="yes" xml:space="preserve">
          <source>Reversing action URLs</source>
          <target state="translated">작업 URL 반전</target>
        </trans-unit>
        <trans-unit id="5c613fa4e207ca1df5f683f7e749421992d7371e" translate="yes" xml:space="preserve">
          <source>Rewriting our API using class-based views</source>
          <target state="translated">클래스 기반 뷰를 사용하여 API 재 작성</target>
        </trans-unit>
        <trans-unit id="738fd18a3f32bfa3c466b005712a54adba21a248" translate="yes" xml:space="preserve">
          <source>Right now we have endpoints for 'snippets' and 'users', but we don't have a single entry point to our API. To create one, we'll use a regular function-based view and the &lt;code&gt;@api_view&lt;/code&gt; decorator we introduced earlier. In your &lt;code&gt;snippets/views.py&lt;/code&gt; add:</source>
          <target state="translated">현재 '스 니펫'및 '사용자'에 대한 엔드 포인트가 있지만 API에 대한 단일 진입 점이 없습니다. 하나를 만들기 위해, 우리는 일반적인 함수 기반 뷰와 앞에서 소개 한 &lt;code&gt;@api_view&lt;/code&gt; 데코레이터를 사용할 것입니다. 당신의에서 &lt;code&gt;snippets/views.py&lt;/code&gt; 추가 :</target>
        </trans-unit>
        <trans-unit id="84e01b9f05e43dffc77806552385ef2bc250848d" translate="yes" xml:space="preserve">
          <source>Right now, if we created a code snippet, there'd be no way of associating the user that created the snippet, with the snippet instance. The user isn't sent as part of the serialized representation, but is instead a property of the incoming request.</source>
          <target state="translated">지금 코드 스 니펫을 만든 경우 스 니펫을 만든 사용자를 스 니펫 인스턴스와 연결할 방법이 없습니다. 사용자는 직렬화 된 표현의 일부로 전송되지 않고 대신 들어오는 요청의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="d184916a450cba2b8f0c6e27ba85a391979732f9" translate="yes" xml:space="preserve">
          <source>Right, we'd better write some views then. Open &lt;code&gt;tutorial/quickstart/views.py&lt;/code&gt; and get typing.</source>
          <target state="translated">맞다, 우리는 그때 몇 가지 견해를 쓰는 것이 낫다. &lt;code&gt;tutorial/quickstart/views.py&lt;/code&gt; 를 열고 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="0dc9b74db6a17f69382e156593de1f1b3cc09561" translate="yes" xml:space="preserve">
          <source>Rollbar</source>
          <target state="translated">Rollbar</target>
        </trans-unit>
        <trans-unit id="a71de1eeb90eff3c477ad64ebacc7e70e1fbe621" translate="yes" xml:space="preserve">
          <source>Routers</source>
          <target state="translated">Routers</target>
        </trans-unit>
        <trans-unit id="f0bc1c8a8728d1215d3bb1e27b7047521c4d46a3" translate="yes" xml:space="preserve">
          <source>Routing additional HTTP methods for extra actions</source>
          <target state="translated">추가 조치를위한 추가 HTTP 메소드 라우팅</target>
        </trans-unit>
        <trans-unit id="f8778077e3d1a7ac817a0486071e28cf2b43d90e" translate="yes" xml:space="preserve">
          <source>Routing for extra actions</source>
          <target state="translated">추가 작업을위한 라우팅</target>
        </trans-unit>
        <trans-unit id="a4744abb68fdceb42247d8ae443ad8ab372339ce" translate="yes" xml:space="preserve">
          <source>SCHEMA_COERCE_METHOD_NAMES</source>
          <target state="translated">SCHEMA_COERCE_METHOD_NAMES</target>
        </trans-unit>
        <trans-unit id="5add3889c4ad5ddd151b318322bcca4a2ba8f4f8" translate="yes" xml:space="preserve">
          <source>SCHEMA_COERCE_PATH_PK</source>
          <target state="translated">SCHEMA_COERCE_PATH_PK</target>
        </trans-unit>
        <trans-unit id="5f5931f71005424afff1e52abc674cfc994a8f0f" translate="yes" xml:space="preserve">
          <source>SEARCH_PARAM</source>
          <target state="translated">SEARCH_PARAM</target>
        </trans-unit>
        <trans-unit id="baa58e9a7b4d5e163ee88f0a9400f5b72e6e0b7c" translate="yes" xml:space="preserve">
          <source>STRICT_JSON</source>
          <target state="translated">STRICT_JSON</target>
        </trans-unit>
        <trans-unit id="c5c829b40a5d73ea25cfba7437bfb99e6a3e200f" translate="yes" xml:space="preserve">
          <source>Saving instances</source>
          <target state="translated">인스턴스 저장</target>
        </trans-unit>
        <trans-unit id="cff33a126d41c71a83c268efd8ae036fddfee0ff" translate="yes" xml:space="preserve">
          <source>Say we have a URL for a customer object that takes two keyword arguments, like so:</source>
          <target state="translated">다음과 같이 두 개의 키워드 인수를 사용하는 고객 객체에 대한 URL이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="140309ac8d63e95f829a3122153fa69614ba2d48" translate="yes" xml:space="preserve">
          <source>Saying [that class-based views] is always the superior solution is a mistake.</source>
          <target state="translated">[클래스 기반 뷰]가 항상 최상의 해결책이라고 말하는 것은 실수입니다.</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="952603677f6e7579c7becafc9fb7467d1ef86433" translate="yes" xml:space="preserve">
          <source>Schema Level Customization</source>
          <target state="translated">스키마 레벨 커스터마이징</target>
        </trans-unit>
        <trans-unit id="8301485eeb88cd7c0442918fd650487b6d5917a1" translate="yes" xml:space="preserve">
          <source>Schema generation controls</source>
          <target state="translated">스키마 생성 컨트롤</target>
        </trans-unit>
        <trans-unit id="5ce8ec153436cd20f0e312cb2d9136220b119098" translate="yes" xml:space="preserve">
          <source>SchemaGenerator</source>
          <target state="translated">SchemaGenerator</target>
        </trans-unit>
        <trans-unit id="9f37eaafb01960f326d5074fa291f5bc9d658a51" translate="yes" xml:space="preserve">
          <source>ScopedRateThrottle</source>
          <target state="translated">ScopedRateThrottle</target>
        </trans-unit>
        <trans-unit id="2059f77918fcdcf68dd006edc6712bc894b88ab0" translate="yes" xml:space="preserve">
          <source>SearchFilter</source>
          <target state="translated">SearchFilter</target>
        </trans-unit>
        <trans-unit id="8cd9664cd8568a6b2a24f1441dd8b59f0a9ccb6f" translate="yes" xml:space="preserve">
          <source>Section 6.2.1 does not say that content negotiation should be used all the time.</source>
          <target state="translated">6.2.1 절에서는 콘텐츠 협상을 항상 사용해야한다고 말하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="df9f93f0af11ac6c537ec0c3257c849b7ad8f4ee" translate="yes" xml:space="preserve">
          <source>See Django's &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/http/urls/#url-namespaces&quot;&gt;URL namespaces docs&lt;/a&gt; and the &lt;a href=&quot;https://docs.djangoproject.com/en/2.0/ref/urls/#include&quot;&gt;&lt;code&gt;include&lt;/code&gt; API reference&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 Django의 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/http/urls/#url-namespaces&quot;&gt;URL 네임 스페이스 문서&lt;/a&gt; 및 &lt;a href=&quot;https://docs.djangoproject.com/en/2.0/ref/urls/#include&quot;&gt; &lt;code&gt;include&lt;/code&gt; API 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10a0c4f12a9047d3476460bc7172e5e9de744d07" translate="yes" xml:space="preserve">
          <source>See also: &lt;code&gt;StaticHTMLRenderer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;StaticHTMLRenderer&lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71baa2b6c9b41f4533785a289bbd207652d7e510" translate="yes" xml:space="preserve">
          <source>See also: &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt;</source>
          <target state="translated">참조 : &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e88e0b66a4d13b135b04dbaf1ded55766096e83e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://www.django-rest-framework.org/community/contributing/&quot;&gt;Contribution guidelines&lt;/a&gt; for information on how to clone the repository, run the test suite and contribute changes back to REST Framework.</source>
          <target state="translated">저장소 복제, 테스트 스위트 실행 및 변경 사항을 REST Framework에 다시 제공하는 방법에 대한 정보 는 &lt;a href=&quot;https://www.django-rest-framework.org/community/contributing/&quot;&gt;컨트 리뷰 션 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b960da029e0ae5fbaadd210332af05b2ee82bdb" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://www.django-rest-framework.org/topics/browsable-api/&quot;&gt;browsable api&lt;/a&gt; topic for more information about the browsable API feature and how to customize it.</source>
          <target state="translated">&lt;a href=&quot;https://www.django-rest-framework.org/topics/browsable-api/&quot;&gt;찾아&lt;/a&gt; 보기 가능한 API 기능 및이를 사용자 정의하는 방법에 대한 자세한 정보 는 찾아 보기 가능한 API 주제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="84df64cf1273394afbfad545f607a0b70c90a6ed" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;&lt;em&gt;HTML &amp;amp; Forms&lt;/em&gt; Topic Page&lt;/a&gt; for further examples of &lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; usage.</source>
          <target state="translated">&lt;code&gt;TemplateHTMLRenderer&lt;/code&gt; 사용법에 대한 추가 예제 는 &lt;a href=&quot;https://www.django-rest-framework.org/topics/html-and-forms/&quot;&gt;&lt;em&gt;HTML 및 양식&lt;/em&gt; 주제 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3fac9119000f710ae014b6707c816b5a1e4343a" translate="yes" xml:space="preserve">
          <source>See the Django documentation on &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/db/queries/#following-relationships-backward&quot;&gt;reverse relationships&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/topics/db/queries/#following-relationships-backward&quot;&gt;역 관계에&lt;/a&gt; 대한 장고 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf4e090e985756b4da07ef4f0731461ecdab9033" translate="yes" xml:space="preserve">
          <source>Select field cutoffs</source>
          <target state="translated">필드 컷오프 선택</target>
        </trans-unit>
        <trans-unit id="1b49e7940329158c1cfb32de62a6b2d865579b9e" translate="yes" xml:space="preserve">
          <source>Send a description of the issue via email to &lt;a href=&quot;mailto:rest-framework-security@googlegroups.com&quot;&gt;rest-framework-security@googlegroups.com&lt;/a&gt;. The project maintainers will then work with you to resolve any issues where required, prior to any public disclosure.</source>
          <target state="translated">이메일을 통해 문제에 대한 설명을 &lt;a href=&quot;mailto:rest-framework-security@googlegroups.com&quot;&gt;rest-framework-security@googlegroups.com으로&lt;/a&gt; 보내 십시오 . 그런 다음 프로젝트 관리자는 공개 공개 전에 필요한 경우 문제를 해결하기 위해 귀하와 협력 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="17f228be7faef7815f5475737e55f8ffbdd2b4b6" translate="yes" xml:space="preserve">
          <source>Sentry</source>
          <target state="translated">Sentry</target>
        </trans-unit>
        <trans-unit id="9899b9d88f2864ca65e2110a5300bdbf12e07758" translate="yes" xml:space="preserve">
          <source>Serialising:</source>
          <target state="translated">Serialising:</target>
        </trans-unit>
        <trans-unit id="79f27bca8d94ff7f010138473fa6661d28c7adcc" translate="yes" xml:space="preserve">
          <source>Serializer Extensions</source>
          <target state="translated">시리얼 라이저 확장</target>
        </trans-unit>
        <trans-unit id="39634b627817514736bd09d1227d9da1175dd5cc" translate="yes" xml:space="preserve">
          <source>Serializer Inheritance</source>
          <target state="translated">시리얼 라이저 상속</target>
        </trans-unit>
        <trans-unit id="9d67467effbdef23e6cb11e953883458da97e7b9" translate="yes" xml:space="preserve">
          <source>Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner &lt;code&gt;Meta&lt;/code&gt; class, like so:</source>
          <target state="translated">시리얼 라이저 클래스에는 전체 필드 데이터 세트에 적용되는 재사용 가능한 유효성 검사기가 포함될 수도 있습니다. 이러한 유효성 검사기는 내부 &lt;code&gt;Meta&lt;/code&gt; 클래스에서 다음과 같이 선언하여 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfc431250d08b753b14c186b8f91d7dd6a494c59" translate="yes" xml:space="preserve">
          <source>Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with &lt;code&gt;ModelSerializers&lt;/code&gt; where you want to determine what set of fields and validators are being automatically created for you.</source>
          <target state="translated">Serializer 클래스는 유용한 상세 표현 문자열을 생성하여 해당 필드의 상태를 완전히 검사 할 수 있습니다. 이 기능은 &lt;code&gt;ModelSerializers&lt;/code&gt; 를 사용할 때 자동으로 생성되는 필드 및 유효성 검사기 집합을 결정할 때 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="9318b78a7cd321867a9f36d5d824ba82cb4fe254" translate="yes" xml:space="preserve">
          <source>Serializer fields</source>
          <target state="translated">시리얼 라이저 필드</target>
        </trans-unit>
        <trans-unit id="ef880d50270812093c055bc663b7545dd877a06b" translate="yes" xml:space="preserve">
          <source>Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.</source>
          <target state="translated">시리얼 라이저 필드는 프리미티브 값과 내부 데이터 유형 간 변환을 처리합니다. 또한 입력 값의 유효성을 검사하고 부모 개체에서 값을 검색하고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5d7c361ca63aa09669fb1324ba916a1ccc3f3835" translate="yes" xml:space="preserve">
          <source>Serializer relations</source>
          <target state="translated">시리얼 라이저 관계</target>
        </trans-unit>
        <trans-unit id="314e0789af8c689409f6c5c15b7d4daa050f3c00" translate="yes" xml:space="preserve">
          <source>SerializerMethodField</source>
          <target state="translated">SerializerMethodField</target>
        </trans-unit>
        <trans-unit id="71796031218483adb9338df6ac1fe8ad1217e178" translate="yes" xml:space="preserve">
          <source>Serializers</source>
          <target state="translated">Serializers</target>
        </trans-unit>
        <trans-unit id="c04bf7bbce86a8301afb0eb57e1fe511b54bfc49" translate="yes" xml:space="preserve">
          <source>Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into &lt;code&gt;JSON&lt;/code&gt;, &lt;code&gt;XML&lt;/code&gt; or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.</source>
          <target state="translated">시리얼 라이저를 사용하면 쿼리 셋 및 모델 인스턴스와 같은 복잡한 데이터를 기본 Python 데이터 유형으로 변환 한 다음 &lt;code&gt;JSON&lt;/code&gt; , &lt;code&gt;XML&lt;/code&gt; 또는 기타 콘텐츠 유형 으로 쉽게 렌더링 할 수 있습니다. 시리얼 라이저는 역 직렬화 기능을 제공하여 파싱 된 데이터를 먼저 들어오는 데이터의 유효성을 검사 한 후 복잡한 유형으로 다시 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b98466d2f6e13bf79068964926563aa6a99df754" translate="yes" xml:space="preserve">
          <source>Serializing multiple objects</source>
          <target state="translated">여러 객체 직렬화</target>
        </trans-unit>
        <trans-unit id="95360ae238038149f91fad4eb8279d556428144b" translate="yes" xml:space="preserve">
          <source>Serializing objects</source>
          <target state="translated">객체 직렬화</target>
        </trans-unit>
        <trans-unit id="b086fe394120114406b6052be2bd306161f4d988" translate="yes" xml:space="preserve">
          <source>Serpy</source>
          <target state="translated">Serpy</target>
        </trans-unit>
        <trans-unit id="e8d10f5d13256694298e675a4b3fc379b9426cb0" translate="yes" xml:space="preserve">
          <source>Serve both regular HTML webpages, and JSON based API responses from the same endpoints.</source>
          <target state="translated">동일한 엔드 포인트에서 일반 HTML 웹 페이지와 JSON 기반 API 응답을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bebc842f88acacdc9a1ab92dcddb618db61a8a81" translate="yes" xml:space="preserve">
          <source>Server Error - 5xx</source>
          <target state="translated">서버 오류-5xx</target>
        </trans-unit>
        <trans-unit id="487982028d405a03f06253978dec1f602a2f42da" translate="yes" xml:space="preserve">
          <source>SessionAuthentication</source>
          <target state="translated">SessionAuthentication</target>
        </trans-unit>
        <trans-unit id="e92e1ed6e3644333818b089a8427e2fb2bc49ca3" translate="yes" xml:space="preserve">
          <source>Set as &lt;code&gt;handler400&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;handler400&lt;/code&gt; 으로 설정 :</target>
        </trans-unit>
        <trans-unit id="7914f2a542b03eb757e20e0dab3b3154c01d48dc" translate="yes" xml:space="preserve">
          <source>Set as &lt;code&gt;handler500&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;handler500&lt;/code&gt; 으로 설정 :</target>
        </trans-unit>
        <trans-unit id="9ac8c412b70b51b9475e902dfa480b1126ed6bc1" translate="yes" xml:space="preserve">
          <source>Set automatically by the &lt;code&gt;APIView&lt;/code&gt; or &lt;code&gt;@api_view&lt;/code&gt; immediately before the response is returned from the view.</source>
          <target state="translated">응답이보기에서 리턴되기 직전에 &lt;code&gt;APIView&lt;/code&gt; 또는 &lt;code&gt;@api_view&lt;/code&gt; 에 의해 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3fe2b4f60f7f88814bcab603760ab291137e758" translate="yes" xml:space="preserve">
          <source>Set the relationship to &lt;code&gt;NULL&lt;/code&gt; in the database.</source>
          <target state="translated">데이터베이스에서 관계를 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="729fde881b9c1ce1956509eda5a8ccae26286095" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;True&lt;/code&gt; to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.</source>
          <target state="translated">표현을 직렬화 할 때 필드가 사용되지만 역 직렬화 중에 인스턴스를 작성하거나 업데이트 할 때는 필드가 사용되지 않도록 하려면이 값을 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="16b783073995002441de5c44f12e348d128547c2" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;True&lt;/code&gt; to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.</source>
          <target state="translated">인스턴스를 업데이트하거나 작성할 때 필드를 사용할 수 있지만 표시를 직렬화 할 때는 포함되지 않도록 하려면이 값을 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1caf317e3be78959fc09e44e42c04045813ed4b" translate="yes" xml:space="preserve">
          <source>Setting filter backends</source>
          <target state="translated">필터 백엔드 설정</target>
        </trans-unit>
        <trans-unit id="85b260b1b74c62ff3d8652742c4efa9190fafead" translate="yes" xml:space="preserve">
          <source>Setting the authentication scheme</source>
          <target state="translated">인증 체계 설정</target>
        </trans-unit>
        <trans-unit id="564cbcf6d764108fcfd8e906676cde6036246fab" translate="yes" xml:space="preserve">
          <source>Setting the available formats</source>
          <target state="translated">사용 가능한 형식 설정</target>
        </trans-unit>
        <trans-unit id="3d2f6385d4f3e1856317e270b80900c1f3bf741a" translate="yes" xml:space="preserve">
          <source>Setting the character set</source>
          <target state="translated">문자 세트 설정</target>
        </trans-unit>
        <trans-unit id="e0a4d109e2e4748afd906d42dd92a05335e2adda" translate="yes" xml:space="preserve">
          <source>Setting the content negotiation</source>
          <target state="translated">컨텐츠 협상 설정</target>
        </trans-unit>
        <trans-unit id="03c654b5d2f77e93757602c724623d5e87b24477" translate="yes" xml:space="preserve">
          <source>Setting the default format</source>
          <target state="translated">기본 형식 설정</target>
        </trans-unit>
        <trans-unit id="6f90e15390054e770c3eb615cc5f46d349ba6fed" translate="yes" xml:space="preserve">
          <source>Setting the metadata scheme</source>
          <target state="translated">메타 데이터 체계 설정</target>
        </trans-unit>
        <trans-unit id="407eb492d514a883b1a2baa99ac4024f54fc8fb5" translate="yes" xml:space="preserve">
          <source>Setting the pagination style</source>
          <target state="translated">페이지 매김 스타일 설정</target>
        </trans-unit>
        <trans-unit id="50468dff052e7842da4cc841b067689d1c297dde" translate="yes" xml:space="preserve">
          <source>Setting the parsers</source>
          <target state="translated">파서 설정</target>
        </trans-unit>
        <trans-unit id="131e71f927d71e7d3e6a4bd4a06aff06a0513431" translate="yes" xml:space="preserve">
          <source>Setting the permission policy</source>
          <target state="translated">권한 정책 설정</target>
        </trans-unit>
        <trans-unit id="337b6be62b905245803ef9143d6c6d59e8c05f31" translate="yes" xml:space="preserve">
          <source>Setting the renderers</source>
          <target state="translated">렌더러 설정</target>
        </trans-unit>
        <trans-unit id="ffac8ce16bdd86b0817740926f760bae8807c2c5" translate="yes" xml:space="preserve">
          <source>Setting the throttling policy</source>
          <target state="translated">조절 정책 설정</target>
        </trans-unit>
        <trans-unit id="10eebcf3dcac617d4fde477adfc0b69d12cc70b1" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;False&lt;/code&gt; also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.</source>
          <target state="translated">이것을 &lt;code&gt;False&lt;/code&gt; 로 설정 하면 인스턴스를 직렬화 할 때 오브젝트 속성 또는 사전 키가 출력에서 ​​생략 될 수 있습니다. 키가 없으면 단순히 출력 표현에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96d6e1319feaf00a87a8fd73254abfb70e4edbcf" translate="yes" xml:space="preserve">
          <source>Setting up a new environment</source>
          <target state="translated">새로운 환경 설정</target>
        </trans-unit>
        <trans-unit id="70141fb124d4755c0506b6893cb2bad35ead79df" translate="yes" xml:space="preserve">
          <source>Setting up the cache</source>
          <target state="translated">캐시 설정</target>
        </trans-unit>
        <trans-unit id="c7f73bb54d928922c3838bb789ee9fb8a5b1eb37" translate="yes" xml:space="preserve">
          <source>Settings</source>
          <target state="translated">Settings</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="1f7c7994616a220b47b312bc80aa73aab4f85e3d" translate="yes" xml:space="preserve">
          <source>Should be a non-nullable value that can be coerced to a string.</source>
          <target state="translated">문자열로 강제 변환 할 수있는 널 입력 불가능 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="157d19057bc7c0ee6cb5f8a05dde0373cf04e2c0" translate="yes" xml:space="preserve">
          <source>Should be an unchanging value, such as a timestamp, slug, or other field that is only set once, on creation.</source>
          <target state="translated">타임 스탬프, 슬러그 또는 생성시 한 번만 설정된 다른 필드와 같이 변하지 않는 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8fa77c0dbd0117cc8c25e4d8e7538e48fd39a392" translate="yes" xml:space="preserve">
          <source>Should be unique, or nearly unique. Millisecond precision timestamps are a good example. This implementation of cursor pagination uses a smart &quot;position plus offset&quot; style that allows it to properly support not-strictly-unique values as the ordering.</source>
          <target state="translated">고유하거나 거의 고유해야합니다. 밀리 초 정밀도 타임 스탬프가 좋은 예입니다. 이 커서 페이지 매김 구현은 스마트 한 &quot;포지션 플러스 오프셋&quot;스타일을 사용하여 엄격하게 고유하지 않은 값을 순서대로 올바르게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1982ac0aaa1e01c4ea67d03f383844dc5f3921c" translate="yes" xml:space="preserve">
          <source>Should not be a float. Precision errors easily lead to incorrect results. Hint: use decimals instead. (If you already have a float field and must paginate on that, an &lt;a href=&quot;https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py&quot;&gt;example &lt;code&gt;CursorPagination&lt;/code&gt; subclass that uses decimals to limit precision is available here&lt;/a&gt;.)</source>
          <target state="translated">플로트가되어서는 안됩니다. 정밀 오차는 잘못된 결과로 쉽게 이어집니다. 힌트 : 대신 소수점을 사용하십시오. (float 필드가 이미 있고 그 위에 페이지를 매겨 야하는 경우, &lt;a href=&quot;https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py&quot;&gt;소수를 사용하여 정밀도를 제한하는 &lt;/a&gt; &lt;code&gt;CursorPagination&lt;/code&gt; 서브 클래스 예제 가 여기에 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="cf997c6d4416ec1e36bcb692ddf7f3436ae8c212" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;DjangoModelPermissions&lt;/code&gt;, but also allows unauthenticated users to have read-only access to the API.</source>
          <target state="translated">&lt;code&gt;DjangoModelPermissions&lt;/code&gt; 와 유사 하지만 인증되지 않은 사용자가 API에 대한 읽기 전용 액세스 권한을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a038dd8d0d363deb606a76af572f5cefd795fa52" translate="yes" xml:space="preserve">
          <source>Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,</source>
          <target state="translated">장고 양식과 유사하게 상속을 통해 직렬 변환기를 확장하고 재사용 할 수 있습니다. 이를 통해 부모 클래스에서 공통 필드 또는 메소드 세트를 선언 한 후 여러 직렬 변환기에서 사용할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2c1e73ff2a33c0e0b264da58b64d4f91b0073c97" translate="yes" xml:space="preserve">
          <source>Similarly if a nested representation should be a list of items, you should pass the &lt;code&gt;many=True&lt;/code&gt; flag to the nested serialized.</source>
          <target state="translated">마찬가지로 중첩 표현이 항목 목록이어야하는 경우 &lt;code&gt;many=True&lt;/code&gt; 플래그를 중첩 된 직렬화에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f2db6ce36a69da9037f43f0f84350f6a4ad51dd" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;.validated_data&lt;/code&gt; property will include nested data structures.</source>
          <target state="translated">마찬가지로 &lt;code&gt;.validated_data&lt;/code&gt; 속성에는 중첩 된 데이터 구조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d0adbe96e55f32fcfe8a67f9d6434f40a780493" translate="yes" xml:space="preserve">
          <source>Similarly, we can control the format of the request that we send, using the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Content-Type&lt;/code&gt; 헤더를 사용하여 전송하는 요청의 형식을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10ec65ab40cc71585b934fadcb07ab902486beb6" translate="yes" xml:space="preserve">
          <source>Similarly, you can have the same json displayed by visiting these URLs in a web browser.</source>
          <target state="translated">마찬가지로 웹 브라우저에서 이러한 URL을 방문하여 동일한 json을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e71a94563d259d7059a656944422cded05a6a4" translate="yes" xml:space="preserve">
          <source>Simple default implementations for the &lt;code&gt;create()&lt;/code&gt; and &lt;code&gt;update()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;create()&lt;/code&gt; 및 &lt;code&gt;update()&lt;/code&gt; 메소드에 대한 간단한 기본 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="0328bff3182af84a5e9bfb982c50f412cfbb4351" translate="yes" xml:space="preserve">
          <source>SimpleRouter</source>
          <target state="translated">SimpleRouter</target>
        </trans-unit>
        <trans-unit id="75d65632d68627ee45cae101ac5504208046a514" translate="yes" xml:space="preserve">
          <source>Since this parser's &lt;code&gt;media_type&lt;/code&gt; matches any content type, &lt;code&gt;FileUploadParser&lt;/code&gt; should generally be the only parser set on an API view.</source>
          <target state="translated">이 구문 분석기의 &lt;code&gt;media_type&lt;/code&gt; 은 모든 컨텐츠 유형과 일치하므로 &lt;code&gt;FileUploadParser&lt;/code&gt; 는 일반적으로 API보기에서 유일하게 구문 분석기 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4db72fcad763718efe427007d7c3462a2ed3aba" translate="yes" xml:space="preserve">
          <source>Since version 3.3.0, it is &lt;strong&gt;mandatory&lt;/strong&gt; to provide one of the attributes &lt;code&gt;fields&lt;/code&gt; or &lt;code&gt;exclude&lt;/code&gt;.</source>
          <target state="translated">버전 3.3.0 때문에,은 &lt;strong&gt;필수&lt;/strong&gt; 속성의 중 하나를 제공하기 위해 &lt;code&gt;fields&lt;/code&gt; 또는 &lt;code&gt;exclude&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbabda59e71d22499ba4e47af8cd517297d68c8b" translate="yes" xml:space="preserve">
          <source>Since version 3.6.4 it's possible to generate a user token using the following command:</source>
          <target state="translated">버전 3.6.4부터 다음 명령을 사용하여 사용자 토큰을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c87c9449797d6bbaa4e53274adaf5b4d5f06a6d6" translate="yes" xml:space="preserve">
          <source>SlugField</source>
          <target state="translated">SlugField</target>
        </trans-unit>
        <trans-unit id="da064478b1fdf13895d12422ef4c1eb7fafdbf30" translate="yes" xml:space="preserve">
          <source>SlugRelatedField</source>
          <target state="translated">SlugRelatedField</target>
        </trans-unit>
        <trans-unit id="2aef59106baaf97ce2985d6d863e510792e3d603" translate="yes" xml:space="preserve">
          <source>So far, so good. It looks pretty similar to the previous case, but we've got better separation between the different HTTP methods. We'll also need to update the instance view in &lt;code&gt;views.py&lt;/code&gt;.</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 이전 사례와 매우 비슷해 보이지만 서로 다른 HTTP 메소드를 더 잘 구분할 수 있습니다. 또한 &lt;code&gt;views.py&lt;/code&gt; 에서 인스턴스 뷰를 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="38723025253bf17d36ff220c824fc5c60b67d2a7" translate="yes" xml:space="preserve">
          <source>Some Web frameworks such as Rails provide functionality for automatically determining how the URLs for an application should be mapped to the logic that deals with handling incoming requests.</source>
          <target state="translated">Rails와 같은 일부 웹 프레임 워크는 애플리케이션의 URL을 수신 요청 처리를 처리하는 논리에 맵핑해야하는 방법을 자동으로 결정하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d461f4561f192d27b7b9fa6c13efd73c75c41400" translate="yes" xml:space="preserve">
          <source>Some other custom representation.</source>
          <target state="translated">다른 사용자 지정 표현.</target>
        </trans-unit>
        <trans-unit id="e1ce8c9b47c2e0b42d00f473088fd1fc5d8d9678" translate="yes" xml:space="preserve">
          <source>Some reasons this might be useful include...</source>
          <target state="translated">이것이 유용한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df78c26eed05e141edd8d6499ef5b2f30b78dd32" translate="yes" xml:space="preserve">
          <source>Some reasons you might want to use REST framework:</source>
          <target state="translated">REST 프레임 워크를 사용하려는 몇 가지 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b957dac1aac10d6b137f7b8d84b7d063460bf9a" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to bypass authentication entirely and force all requests by the test client to be automatically treated as authenticated.</source>
          <target state="translated">때로는 인증을 완전히 무시하고 테스트 클라이언트의 모든 요청이 인증 된 것으로 자동 처리되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0a754c6dcca8c958dfb538aa44c529d8d0ec74" translate="yes" xml:space="preserve">
          <source>Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.</source>
          <target state="translated">경우에 따라 인스턴스를 저장할 때 뷰 코드가 추가 데이터를 주입 할 수 있기를 원할 수도 있습니다. 이 추가 데이터에는 현재 사용자, 현재 시간 또는 요청 데이터의 일부가 아닌 다른 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a219e76b788661e6e020408b753053d513b8125" translate="yes" xml:space="preserve">
          <source>Specify multiple types of HTML representation for API clients to use.</source>
          <target state="translated">API 클라이언트가 사용할 여러 유형의 HTML 표현을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="aafde7808c3f61e9098a23721c70eae79b826cb1" translate="yes" xml:space="preserve">
          <source>Specifying a default ordering</source>
          <target state="translated">기본 주문 지정</target>
        </trans-unit>
        <trans-unit id="905a1e3620f45af1b89c08301d94922c6e48f84b" translate="yes" xml:space="preserve">
          <source>Specifying fields explicitly</source>
          <target state="translated">명시 적으로 필드 지정</target>
        </trans-unit>
        <trans-unit id="30e0ffd1f1069da1f04ad8d8ca6d094241a84961" translate="yes" xml:space="preserve">
          <source>Specifying nested serialization</source>
          <target state="translated">중첩 직렬화 지정</target>
        </trans-unit>
        <trans-unit id="7ee026f07ee4b3049977a22a6ada1a8e6eb67fad" translate="yes" xml:space="preserve">
          <source>Specifying read only fields</source>
          <target state="translated">읽기 전용 필드 지정</target>
        </trans-unit>
        <trans-unit id="1a7ce229e2fcbabb78512b6b75126b7a715c9ec2" translate="yes" xml:space="preserve">
          <source>Specifying which fields may be ordered against</source>
          <target state="translated">주문할 수있는 필드 지정</target>
        </trans-unit>
        <trans-unit id="89a7e140cad64afa602024698f154859bb8b0e29" translate="yes" xml:space="preserve">
          <source>Specifying which fields to include</source>
          <target state="translated">포함 할 필드 지정</target>
        </trans-unit>
        <trans-unit id="5cf5a53a70423e7f39900ab8e88c0dcae5268796" translate="yes" xml:space="preserve">
          <source>Standard HttpRequest attributes</source>
          <target state="translated">표준 HttpRequest 속성</target>
        </trans-unit>
        <trans-unit id="e38cfa26d089c38facf09a6db17b8fb6719c8755" translate="yes" xml:space="preserve">
          <source>Standard HttpResponse attributes</source>
          <target state="translated">표준 HttpResponse 속성</target>
        </trans-unit>
        <trans-unit id="b1bcc6c953749d1fc5857a2a4e83909a39440a69" translate="yes" xml:space="preserve">
          <source>Start by adding a &lt;code&gt;format&lt;/code&gt; keyword argument to both of the views, like so.</source>
          <target state="translated">두 가지보기 모두에 &lt;code&gt;format&lt;/code&gt; 키워드 인수를 추가하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="71f59505ef09f4d1dada606ac1977d60ec3d2bf6" translate="yes" xml:space="preserve">
          <source>StaticHTMLRenderer</source>
          <target state="translated">StaticHTMLRenderer</target>
        </trans-unit>
        <trans-unit id="7f5583f5096a76c834c0bcc4f4885ffca8fe34cd" translate="yes" xml:space="preserve">
          <source>Status Codes</source>
          <target state="translated">상태 코드</target>
        </trans-unit>
        <trans-unit id="20bff13ce14f7a70a5d8ebe6f9aed5edc33830a1" translate="yes" xml:space="preserve">
          <source>Status codes</source>
          <target state="translated">상태 코드</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="6dc094dc983e58db8345c7b3d74c860e7b33a2d5" translate="yes" xml:space="preserve">
          <source>Strictly speaking the &lt;code&gt;json&lt;/code&gt; media type is not specified as &lt;a href=&quot;https://tools.ietf.org/html/rfc4627#section-6&quot;&gt;including additional parameters&lt;/a&gt;. If you are building a well-specified public API you might consider using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_media_type#Vendor_tree&quot;&gt;vendor media type&lt;/a&gt;. To do so, configure your renderers to use a JSON based renderer with a custom media type:</source>
          <target state="translated">엄격히 말하면 &lt;code&gt;json&lt;/code&gt; 미디어 유형은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4627#section-6&quot;&gt;추가 매개 변수&lt;/a&gt; 를 포함하는 것으로 지정되지 않습니다 . 올바르게 지정된 퍼블릭 API를 구축하는 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_media_type#Vendor_tree&quot;&gt;공급 업체 미디어 유형&lt;/a&gt; 사용을 고려할 수 있습니다 . 이렇게하려면 커스텀 미디어 유형의 JSON 기반 렌더러를 사용하도록 렌더러를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="71f397c2fe894bbc4e9a03d886970128c384e227" translate="yes" xml:space="preserve">
          <source>String fields</source>
          <target state="translated">문자열 필드</target>
        </trans-unit>
        <trans-unit id="53959011c52e5ee767aea980fff8ccd950e00987" translate="yes" xml:space="preserve">
          <source>StringRelatedField</source>
          <target state="translated">StringRelatedField</target>
        </trans-unit>
        <trans-unit id="37a083dca515875c9ff754f1529a476777dec0b6" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;APIException&lt;/code&gt; raised inside REST framework.</source>
          <target state="translated">REST 프레임 워크 내에서 발생한 &lt;code&gt;APIException&lt;/code&gt; 의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="617f311464f55d0ff31246c939366deb2b3555bc" translate="yes" xml:space="preserve">
          <source>Successful - 2xx</source>
          <target state="translated">성공-2xx</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="f32d5a3b17e614297417cc279a7ec1cd02274d65" translate="yes" xml:space="preserve">
          <source>Support</source>
          <target state="translated">Support</target>
        </trans-unit>
        <trans-unit id="a8461134208c35250e4a014add2e1b0ebd92f871" translate="yes" xml:space="preserve">
          <source>Support the use of multiple authentication policies.</source>
          <target state="translated">여러 인증 정책 사용을 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="fbdf4d0538d17fbfb77998ef365494e0b9558719" translate="yes" xml:space="preserve">
          <source>Supports usage with very large datasets. With extremely large datasets pagination using offset-based pagination styles may become inefficient or unusable. Cursor based pagination schemes instead have fixed-time properties, and do not slow down as the dataset size increases.</source>
          <target state="translated">매우 큰 데이터 세트 사용을 지원합니다. 매우 큰 데이터 세트에서 오프셋 기반 페이지 매김 스타일을 사용하는 페이지 매김은 비효율적이거나 사용할 수 없게 될 수 있습니다. 커서 기반 페이지 매김 구성표에는 고정 시간 속성이 있으며 데이터 세트 크기가 증가해도 속도가 느려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbed9104762d24bbd35c25ba2d08aee2b9c789b1" translate="yes" xml:space="preserve">
          <source>Suppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:</source>
          <target state="translated">기본 페이지 매김 출력 스타일을 중첩 된 '링크'키에있는 다음 및 이전 링크를 포함하는 수정 된 형식으로 바꾸려고한다고 가정하십시오. 다음과 같이 커스텀 페이지 매김 클래스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2766242835aa99c97f32ae5ea08dc0be64515f2" translate="yes" xml:space="preserve">
          <source>TEST_REQUEST_DEFAULT_FORMAT</source>
          <target state="translated">TEST_REQUEST_DEFAULT_FORMAT</target>
        </trans-unit>
        <trans-unit id="40b21cc34b3a7c9980147c7ec483021c91b1406e" translate="yes" xml:space="preserve">
          <source>TEST_REQUEST_RENDERER_CLASSES</source>
          <target state="translated">TEST_REQUEST_RENDERER_CLASSES</target>
        </trans-unit>
        <trans-unit id="4dcff10d1557d276c63c24add6ad5a5118d4e375" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">이 소프트웨어는 저작권 소유자 및 배포자에 의해 &quot;있는 그대로&quot;제공되며, 명시 적 또는 묵시적 보증을 포함하되 이에 국한되지는 않지만 상품성 및 특정 목적에의 적합성에 대한 묵시적 보증은 이에 제한되지 않습니다. 어떠한 경우에도 저작권 소유자 또는 제공자는 직접적, 간접적, 우발적, 특수 적, 간접적 또는 결과적 손해에 대해 책임을지지 않습니다 (대체 상품 또는 서비스의 제조, 데이터 손실, 사용 손실, 데이터 손실). 또는 비즈니스 중단) 계약, 엄격 책임 또는 불법 행위 (어떠한 태만 또는 기타 포함)에 관계없이 본 소프트웨어를 사용하지 않더라도 본 소프트웨어를 사용하지 않더라도 발생하는 책임 이론에 따라 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4415efad8f80db2789d8125ffed0553836a393f7" translate="yes" xml:space="preserve">
          <source>TIME_FORMAT</source>
          <target state="translated">TIME_FORMAT</target>
        </trans-unit>
        <trans-unit id="cd52f3fabf110faa27e8d8338f81ec3af0f4fe44" translate="yes" xml:space="preserve">
          <source>TIME_INPUT_FORMATS</source>
          <target state="translated">TIME_INPUT_FORMATS</target>
        </trans-unit>
        <trans-unit id="d59b0421f64adb3dea4d18ca765aaf0a0ef353cd" translate="yes" xml:space="preserve">
          <source>Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.</source>
          <target state="translated">직렬화가 필요한 객체 인스턴스를 가져 와서 기본 표현을 반환해야합니다. 일반적으로 이것은 내장 Python 데이터 유형의 구조를 반환합니다. 처리 할 수있는 정확한 유형은 API에 대해 구성한 렌더 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bc830b0e112df790bafeaa47d1cd02ceac5ad95d" translate="yes" xml:space="preserve">
          <source>Takes the unvalidated incoming data as input and should return the validated data that will be made available as &lt;code&gt;serializer.validated_data&lt;/code&gt;. The return value will also be passed to the &lt;code&gt;.create()&lt;/code&gt; or &lt;code&gt;.update()&lt;/code&gt; methods if &lt;code&gt;.save()&lt;/code&gt; is called on the serializer class.</source>
          <target state="translated">확인되지 않은 수신 데이터를 입력으로 취하고 &lt;code&gt;serializer.validated_data&lt;/code&gt; 로 사용 가능한 검증 된 데이터를 리턴해야합니다 . serializer 클래스에서 &lt;code&gt;.save()&lt;/code&gt; 가 호출 되면 반환 값도 &lt;code&gt;.create()&lt;/code&gt; 또는 &lt;code&gt;.update()&lt;/code&gt; 메서드 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0463559421ee0189b711b38dd29173f42bb1981b" translate="yes" xml:space="preserve">
          <source>TemplateHTMLRenderer</source>
          <target state="translated">TemplateHTMLRenderer</target>
        </trans-unit>
        <trans-unit id="f3d7c07bedd29275b3b6e25efb74eeca6fa26982" translate="yes" xml:space="preserve">
          <source>Templates will render with a &lt;code&gt;RequestContext&lt;/code&gt; which includes the &lt;code&gt;status_code&lt;/code&gt; and &lt;code&gt;details&lt;/code&gt; keys.</source>
          <target state="translated">템플릿은 &lt;code&gt;status_code&lt;/code&gt; 및 &lt;code&gt;details&lt;/code&gt; 키 를 포함 하는 &lt;code&gt;RequestContext&lt;/code&gt; 와 함께 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cdd308955f7f408b8b6b6fa308a073ba072a786" translate="yes" xml:space="preserve">
          <source>Test settings</source>
          <target state="translated">테스트 설정</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="95bfd7de3b0e7fd6e89d450e052b2df0e353de69" translate="yes" xml:space="preserve">
          <source>Testing our API</source>
          <target state="translated">API 테스트</target>
        </trans-unit>
        <trans-unit id="2615d3b41c5adda17d5ef9c50d6ae80df5e95497" translate="yes" xml:space="preserve">
          <source>Testing our first attempt at a Web API</source>
          <target state="translated">웹 API에서 첫 번째 시도 테스트</target>
        </trans-unit>
        <trans-unit id="802b52725b6569631bb94335fbd56065e721f791" translate="yes" xml:space="preserve">
          <source>Testing responses</source>
          <target state="translated">테스트 응답</target>
        </trans-unit>
        <trans-unit id="973d90c5e5fe57a58994edd43e30038efc055e54" translate="yes" xml:space="preserve">
          <source>That doesn't mean it's always the right approach to take. There's a similar set of trade-offs to consider as when using class-based views instead of function based views. Using viewsets is less explicit than building your views individually.</source>
          <target state="translated">그렇다고 항상 올바른 접근 방식을 취하는 것은 아닙니다. 함수 기반 뷰 대신 클래스 기반 뷰를 사용할 때와 비슷한 단점이 있습니다. 뷰 세트를 사용하는 것은 뷰를 개별적으로 작성하는 것보다 덜 명확합니다.</target>
        </trans-unit>
        <trans-unit id="59806672c726bef891fc5bfc82c52c7e40d43068" translate="yes" xml:space="preserve">
          <source>That's looking good. Again, it's still pretty similar to the function based view right now.</source>
          <target state="translated">좋아 보인다 다시 말하지만, 여전히 기능 기반 뷰와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9370f0761144d59babb5da524bbfd80b2db365e0" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.</source>
          <target state="translated">4xx 등급의 상태 코드는 클라이언트가 오류가 발생한 것처럼 보입니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다.</target>
        </trans-unit>
        <trans-unit id="1f974f8f698d1a6fedcf777e467774b94de988a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/&quot;&gt;&lt;code&gt;DRF-extensions&lt;/code&gt; package&lt;/a&gt; includes a &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin&quot;&gt;&lt;code&gt;PaginateByMaxMixin&lt;/code&gt; mixin class&lt;/a&gt; that allows your API clients to specify &lt;code&gt;?page_size=max&lt;/code&gt; to obtain the maximum allowed page size.</source>
          <target state="translated">&lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/&quot;&gt; &lt;code&gt;DRF-extensions&lt;/code&gt; 패키지는&lt;/a&gt; 포함 &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin&quot;&gt; &lt;code&gt;PaginateByMaxMixin&lt;/code&gt; 의 믹스 인 클래스&lt;/a&gt; 귀하의 API 클라이언트가 지정할 수있는 &lt;code&gt;?page_size=max&lt;/code&gt; 최대 허용 페이지 크기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ebd8e32ccc4d691fbae7ddd89c83f0f9674a1f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/&quot;&gt;&lt;code&gt;DRF-extensions&lt;/code&gt; package&lt;/a&gt; provides &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#routers&quot;&gt;routers&lt;/a&gt; for creating &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#nested-routes&quot;&gt;nested viewsets&lt;/a&gt;, &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers&quot;&gt;collection level controllers&lt;/a&gt; with &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name&quot;&gt;customizable endpoint names&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/&quot;&gt; &lt;code&gt;DRF-extensions&lt;/code&gt; 패키지를&lt;/a&gt; 제공하는 &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#routers&quot;&gt;라우터를&lt;/a&gt; 만들기위한 &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#nested-routes&quot;&gt;중첩 된 viewsets&lt;/a&gt; , &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers&quot;&gt;모음 수준 컨트롤러&lt;/a&gt; 와 &lt;a href=&quot;https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name&quot;&gt;사용자 정의 엔드 포인트 이름&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94085b27509e55c8c795519d8df2e0849ba6d06e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/index.html&quot;&gt;&lt;code&gt;django-filter&lt;/code&gt;&lt;/a&gt; library includes a &lt;code&gt;DjangoFilterBackend&lt;/code&gt; class which supports highly customizable field filtering for REST framework.</source>
          <target state="translated">&lt;a href=&quot;https://django-filter.readthedocs.io/en/latest/index.html&quot;&gt; &lt;code&gt;django-filter&lt;/code&gt; &lt;/a&gt; 라이브러리는 포함 &lt;code&gt;DjangoFilterBackend&lt;/code&gt; 의 REST 프레임 워크에 대한 필터링 고도로 사용자 정의 필드를 지원하는 클래스를.</target>
        </trans-unit>
        <trans-unit id="e8472ee8fbfc846a4e6d817dabc81f7e01cfef13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://drf-compound-fields.readthedocs.io&quot;&gt;drf-compound-fields&lt;/a&gt; package provides &quot;compound&quot; serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the &lt;code&gt;many=True&lt;/code&gt; option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.</source>
          <target state="translated">&lt;a href=&quot;https://drf-compound-fields.readthedocs.io&quot;&gt;DRF-화합물 필드의&lt;/a&gt; 패키지와 같은 다른 필드가 아닌 직렬로 설명 될 수있는 간단한 값리스트로서 &quot;화합물&quot;직렬 필드 제공 &lt;code&gt;many=True&lt;/code&gt; 옵션. 특정 유형이거나 해당 유형의 항목 목록이 될 수있는 유형 사전 및 값에 대한 필드도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f5427c30793e2b4cdf4172a0cfd1be27def312e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://florimondmanca.github.io/djangorestframework-api-key/&quot;&gt;Django REST Framework API Key&lt;/a&gt; package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. &lt;em&gt;machines&lt;/em&gt;) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.</source>
          <target state="translated">&lt;a href=&quot;https://florimondmanca.github.io/djangorestframework-api-key/&quot;&gt;장고 REST 프레임 워크 API 키&lt;/a&gt; 패키지는 API에 API 키 인증을 추가 할 수있는 권한 클래스 모델과 도우미를 제공합니다. 사용자 계정이없는 내부 또는 타사 백엔드 및 서비스 (예 : &lt;em&gt;머신&lt;/em&gt; ) 를 인증하는 데 사용할 수 있습니다 . API 키는 Django의 비밀번호 해싱 인프라를 사용하여 안전하게 저장되며 언제든지 Django 관리자에서보고 편집하고 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fada373286e1d7af7cacf1e8a850829128ffc1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/AltSchool/dynamic-rest&quot;&gt;dynamic-rest&lt;/a&gt; package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/AltSchool/dynamic-rest&quot;&gt;동적 나머지&lt;/a&gt; 패키지는 시리얼에 의해 정의 된 모든 필드와의 관계를, 필터링, 정렬 및 포함 / 제외에 대한 API 쿼리 매개 변수를 추가하는 ModelSerializer 및 ModelViewSet 인터페이스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="d1a62a19604a1efca329a1ffbe264a4d9e03afd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/Helioscene/dry-rest-permissions&quot;&gt;DRY Rest Permissions&lt;/a&gt; package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Helioscene/dry-rest-permissions&quot;&gt;DRY 나머지 권한&lt;/a&gt; 패키지는 개별 기본 및 사용자 정의의 행동에 대한 서로 다른 권한을 정의 할 수있는 기능을 제공합니다. 이 패키지는 앱의 데이터 모델에 정의 된 관계에서 파생 된 권한이있는 앱을 위해 만들어졌습니다. 또한 API 시리얼 라이저를 통해 권한 검사가 클라이언트 앱으로 반환되도록 지원합니다. 또한 기본 및 사용자 지정 목록 작업에 권한을 추가하여 사용자별로 검색하는 데이터를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7ac8bd36a8608db3d6642af8cd42cae87160db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/Hipo/drf-extra-fields&quot;&gt;drf-extra-fields&lt;/a&gt; package provides extra serializer fields for REST framework, including &lt;code&gt;Base64ImageField&lt;/code&gt; and &lt;code&gt;PointField&lt;/code&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Hipo/drf-extra-fields&quot;&gt;DRF-추가 필드의&lt;/a&gt; 패키지를 포함하여 REST 프레임 워크에 대한 별도의 시리얼 필드, 제공 &lt;code&gt;Base64ImageField&lt;/code&gt; 및 &lt;code&gt;PointField&lt;/code&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="8279f7b8ef2ace42a46affae32ca8ce407cf8cda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/Ian-Foote/rest-framework-generic-relations&quot;&gt;rest-framework-generic-relations&lt;/a&gt; library provides read/write serialization for generic foreign keys.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Ian-Foote/rest-framework-generic-relations&quot;&gt;나머지 프레임 워크 - 일반 - 관계&lt;/a&gt; 라이브러리는 일반적인 외래 키에 대한 읽기 / 쓰기 직렬화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a714360f580c73f28456db4a7ab92e57232bb3af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/alanjds/drf-nested-routers&quot;&gt;drf-nested-routers package&lt;/a&gt; provides routers and relationship fields for working with nested resources.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/alanjds/drf-nested-routers&quot;&gt;DRF-중첩 - 라우터 패키지는&lt;/a&gt; 중첩 된 자원이 작업을위한 라우터와 관계 필드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2af1049264e7df55cb178a17aff38b4ab6faeea7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/allisson/django-rest-framework-role-filters&quot;&gt;Django Rest Framework Role Filters&lt;/a&gt; package provides simple filtering over multiple types of roles.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/allisson/django-rest-framework-role-filters&quot;&gt;장고 나머지 프레임 워크 역할 필터&lt;/a&gt; 패키지는 역할의 여러 유형을 통해 간단한 필터링을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="202048ac6fd2124039f4521f651677fde177bf17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/beda-software/drf-writable-nested&quot;&gt;drf-writable-nested&lt;/a&gt; package provides writable nested model serializer which allows to create/update models with nested related data.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/beda-software/drf-writable-nested&quot;&gt;DRF-기록 가능한 중첩 된&lt;/a&gt; 패키지는 중첩 된 관련 데이터 / 업데이트 모델을 만들 수 있습니다 쓰기 중첩 된 모델 시리얼을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc6a0228ad0f3afd54aa565bdb834763e9fdab52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/caxap/rest_condition&quot;&gt;REST Condition&lt;/a&gt; package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/caxap/rest_condition&quot;&gt;REST 조건&lt;/a&gt; 패키지는 간단하고 편리한 방법으로 복잡한 권한을 구축하기위한 또 다른 확장 기능입니다. 확장을 통해 권한을 논리 연산자와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39dc31e23e5982012243956b2b0db8c6c3ec5e7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/clarkduvall/serpy&quot;&gt;serpy&lt;/a&gt; package is an alternative implementation for serializers that is built for speed. &lt;a href=&quot;https://github.com/clarkduvall/serpy&quot;&gt;Serpy&lt;/a&gt; serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/clarkduvall/serpy&quot;&gt;serpy의&lt;/a&gt; 패키지는 속도를 구축 시리얼에 대한 대체 구현입니다. &lt;a href=&quot;https://github.com/clarkduvall/serpy&quot;&gt;Serpy는&lt;/a&gt; 복잡한 데이터 유형을 간단한 기본 유형으로 직렬화합니다. 기본 유형은 JSON 또는 필요한 다른 형식으로 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551cac3e3c62ebf8be8882514ba77db0e92caa33" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/computer-lab/django-rest-framework-roles&quot;&gt;Django Rest Framework Roles&lt;/a&gt; package makes it easier to parameterize your API over multiple types of users.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/computer-lab/django-rest-framework-roles&quot;&gt;장고 나머지 프레임 워크 역할&lt;/a&gt; 패키지는보다 쉽게 사용자의 여러 유형에 당신의 API를 매개 변수화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1f4331b6e952e4375d9820f47e949043a4fda6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/dbrgn/drf-dynamic-fields&quot;&gt;drf-dynamic-fields&lt;/a&gt; package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dbrgn/drf-dynamic-fields&quot;&gt;DRF-동적 필드&lt;/a&gt; 패키지는 동적 URL 매개 변수에 의해 지정된 하위 집합 시리얼 당 필드를 제한하는 믹스 인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79eb3fbf204829fe4c37d4365f714b355f07c012" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-gis&quot;&gt;django-rest-framework-gis&lt;/a&gt; package provides a &lt;code&gt;GeoFeatureModelSerializer&lt;/code&gt; serializer class that supports GeoJSON both for read and write operations.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-gis&quot;&gt;장고 - 나머지 프레임 워크-GIS의&lt;/a&gt; 패키지는 제공 &lt;code&gt;GeoFeatureModelSerializer&lt;/code&gt; 의 읽기 및 쓰기 작업을 모두 GeoJSON을 지원하는 시리얼 클래스를.</target>
        </trans-unit>
        <trans-unit id="be0fc185c5f1a2be1d64b7716f46a9e2206e7ae0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-gis&quot;&gt;django-rest-framework-gis&lt;/a&gt; package provides geographic addons for django rest framework like a &lt;code&gt;GeometryField&lt;/code&gt; field and a GeoJSON serializer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-gis&quot;&gt;장고 - 나머지 프레임 워크-GIS의&lt;/a&gt; 패키지는 같은 장고 나머지 프레임 워크에 대한 지리적 애드온을 제공 &lt;code&gt;GeometryField&lt;/code&gt; 필드와 GeoJSON 시리얼.</target>
        </trans-unit>
        <trans-unit id="83fced487bf8ef6f3c89f8a192b66e39e9f3c40d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-hstore&quot;&gt;django-rest-framework-hstore&lt;/a&gt; package provides an &lt;code&gt;HStoreField&lt;/code&gt; to support &lt;a href=&quot;https://github.com/djangonauts/django-hstore&quot;&gt;django-hstore&lt;/a&gt;&lt;code&gt;DictionaryField&lt;/code&gt; model field.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-hstore&quot;&gt;장고 - 나머지 프레임 워크 - hstore의&lt;/a&gt; 패키지는 제공 &lt;code&gt;HStoreField&lt;/code&gt; 을 지원하기 위해 &lt;a href=&quot;https://github.com/djangonauts/django-hstore&quot;&gt;-hstore 장고 &lt;/a&gt; &lt;code&gt;DictionaryField&lt;/code&gt; 의 모델 필드를.</target>
        </trans-unit>
        <trans-unit id="19e8324b0df3652e03a15fa8e109358ac5bdb5cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-hstore&quot;&gt;django-rest-framework-hstore&lt;/a&gt; package provides an &lt;code&gt;HStoreSerializer&lt;/code&gt; to support &lt;a href=&quot;https://github.com/djangonauts/django-hstore&quot;&gt;django-hstore&lt;/a&gt;&lt;code&gt;DictionaryField&lt;/code&gt; model field and its &lt;code&gt;schema-mode&lt;/code&gt; feature.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/djangonauts/django-rest-framework-hstore&quot;&gt;장고 - 나머지 프레임 워크 - hstore의&lt;/a&gt; 패키지는 제공 &lt;code&gt;HStoreSerializer&lt;/code&gt; 을 지원하기 위해 &lt;a href=&quot;https://github.com/djangonauts/django-hstore&quot;&gt;-hstore 장고 &lt;/a&gt; &lt;code&gt;DictionaryField&lt;/code&gt; 의 모델 필드와의 &lt;code&gt;schema-mode&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="db8a4219781fec5a025e790ba598eac832078ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evenicoulddoit/django-rest-framework-serializer-extensions&quot;&gt;django-rest-framework-serializer-extensions&lt;/a&gt; package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evenicoulddoit/django-rest-framework-serializer-extensions&quot;&gt;장고 - 나머지 프레임 워크 - 시리얼 - 확장&lt;/a&gt; 패키지는 필드 별보기 / 요청으로 정의 할 수 있도록하여, 사용자의 시리얼을 건조 할 수있는 도구 모음을 제공합니다. 필드는 화이트리스트, 블랙리스트 및 하위 직렬 변환기를 선택적으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="611b241373aae042b4aa1e4baa355860fcc93cbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evonove/django-oauth-toolkit&quot;&gt;Django OAuth Toolkit&lt;/a&gt; package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by &lt;a href=&quot;https://github.com/evonove/&quot;&gt;Evonove&lt;/a&gt; and uses the excellent &lt;a href=&quot;https://github.com/idan/oauthlib&quot;&gt;OAuthLib&lt;/a&gt;. The package is well documented, and well supported and is currently our &lt;strong&gt;recommended package for OAuth 2.0 support&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evonove/django-oauth-toolkit&quot;&gt;장고의 OAuth 툴킷&lt;/a&gt; 패키지의 OAuth 2.0 지원을 제공하고, 파이썬 3.4 이상에서 작동합니다. 패키지는 &lt;a href=&quot;https://github.com/evonove/&quot;&gt;Evonove에&lt;/a&gt; 의해 유지 보수되며 우수한 &lt;a href=&quot;https://github.com/idan/oauthlib&quot;&gt;OAuthLib를&lt;/a&gt; 사용합니다 . 패키지는 잘 문서화되어 있고 잘 지원되며 현재 &lt;strong&gt;OAuth 2.0 지원을 위해 권장되는 패키지입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd1675f4b08cf4d08873c77224073b55ce03c34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/miki725/django-rest-framework-bulk&quot;&gt;django-rest-framework-bulk package&lt;/a&gt; implements generic view mixins as well as some common concrete generic views to allow to apply bulk operations via API requests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/miki725/django-rest-framework-bulk&quot;&gt;장고 - 나머지 프레임 워크 벌크 패키지&lt;/a&gt; 구현 일반적인보기 유지 mixin뿐만 아니라 몇 가지 일반적인 콘크리트 일반적인 견해는 API 요청을 통해 대량의 작업을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11168496fc45a2eb929d3a0655476bdf710be6ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/niwibe/djangorestframework-composed-permissions&quot;&gt;Composed Permissions&lt;/a&gt; package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.</source>
          <target state="translated">작성 &lt;a href=&quot;https://github.com/niwibe/djangorestframework-composed-permissions&quot;&gt;권한&lt;/a&gt; 패키지는 작고 재사용 가능한 구성 요소를 사용하여 복잡하고 다양한 심도 (논리 연산자 포함) 권한 개체를 정의하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bee48f8f151656ec237adb531b31d288c3682ec9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/philipn/django-rest-framework-filters&quot;&gt;django-rest-framework-filters package&lt;/a&gt; works together with the &lt;code&gt;DjangoFilterBackend&lt;/code&gt; class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/philipn/django-rest-framework-filters&quot;&gt;장고 - 나머지 프레임 워크 - 필터 패키지는&lt;/a&gt; 와 함께 작동 &lt;code&gt;DjangoFilterBackend&lt;/code&gt; 의 클래스와 쉽게 관계를 통해 필터를 만들거나 특정 필드에 대해 여러 필터 조회 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16de4cbb6591c13b4764e8db02dba8a8c8a8c0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rsinger86/drf-access-policy&quot;&gt;Django REST - Access Policy&lt;/a&gt; package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity &amp;amp; Access Management policies.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rsinger86/drf-access-policy&quot;&gt;장고 REST - 액세스 정책&lt;/a&gt; 패키지 세트 또는 기능 기반 뷰를 볼 부착 선언적 정책 클래스 복잡한 액세스 규칙을 정의 할 수있는 방법을 제공합니다. 정책은 AWS의 Identity &amp;amp; Access Management 정책과 유사한 형식으로 JSON으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="94630ea1be3bb7eef05442fdaf49bd068a98faa8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rsinger86/drf-flex-fields&quot;&gt;drf-flex-fields&lt;/a&gt; package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rsinger86/drf-flex-fields&quot;&gt;DRF-플렉스 필드&lt;/a&gt; 패키지는 ModelSerializer 및 ModelViewSet 동적으로 필드를 설정하고 URL 매개 변수와 시리얼 클래스 정의에서 모두 중첩 된 모델에 기본 필드를 확장을 위해 일반적으로 사용되는 기능을 제공하는 확장합니다.</target>
        </trans-unit>
        <trans-unit id="bd3647f71d7820ff7280c5665b3d4edc9b7f1fe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tbeadle/django-rest-framework-link-header-pagination&quot;&gt;&lt;code&gt;django-rest-framework-link-header-pagination&lt;/code&gt; package&lt;/a&gt; includes a &lt;code&gt;LinkHeaderPagination&lt;/code&gt; class which provides pagination via an HTTP &lt;code&gt;Link&lt;/code&gt; header as described in &lt;a href=&quot;github-link-pagination&quot;&gt;Github's developer documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tbeadle/django-rest-framework-link-header-pagination&quot;&gt; &lt;code&gt;django-rest-framework-link-header-pagination&lt;/code&gt; 패키지는&lt;/a&gt; 포함 &lt;code&gt;LinkHeaderPagination&lt;/code&gt; 의 는 HTTP를 통해 매김을 제공하는 클래스 &lt;code&gt;Link&lt;/code&gt; 에 설명 된대로 헤더 &lt;a href=&quot;github-link-pagination&quot;&gt;Github에서의 개발자 문서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e0a18a129227fb51990e9700388f13bf8644d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/trollknurr/django-rest-framework-word-search-filter&quot;&gt;djangorestframework-word-filter&lt;/a&gt; developed as alternative to &lt;code&gt;filters.SearchFilter&lt;/code&gt; which will search full word in text, or exact match.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/trollknurr/django-rest-framework-word-search-filter&quot;&gt;djangorestframework - 워드 필터&lt;/a&gt; 에 대한 대안으로 개발 &lt;code&gt;filters.SearchFilter&lt;/code&gt; 텍스트로 전체 단어를 검색합니다, 또는 일치.</target>
        </trans-unit>
        <trans-unit id="6d46c41656e2ba10080fd3c73894dba8af124c97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tuffnatty/drf-proxy-pagination&quot;&gt;&lt;code&gt;drf-proxy-pagination&lt;/code&gt; package&lt;/a&gt; includes a &lt;code&gt;ProxyPagination&lt;/code&gt; class which allows to choose pagination class with a query parameter.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tuffnatty/drf-proxy-pagination&quot;&gt; &lt;code&gt;drf-proxy-pagination&lt;/code&gt; 패키지는&lt;/a&gt; 포함 &lt;code&gt;ProxyPagination&lt;/code&gt; 의 쿼리 매개 변수를 사용하여 페이지 매김 클래스를 선택할 수 있습니다 클래스를.</target>
        </trans-unit>
        <trans-unit id="99cfd21327962a035a4f46a9ba7ce30902752a1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/umutbozkurt/django-rest-framework-mongoengine&quot;&gt;django-rest-framework-mongoengine&lt;/a&gt; package provides a &lt;code&gt;MongoEngineModelSerializer&lt;/code&gt; serializer class that supports using MongoDB as the storage layer for Django REST framework.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umutbozkurt/django-rest-framework-mongoengine&quot;&gt;장고 - 나머지 프레임 워크 - mongoengine의&lt;/a&gt; 패키지는 제공 &lt;code&gt;MongoEngineModelSerializer&lt;/code&gt; 의 지원 장고 REST 프레임 워크의 저장 층으로하여 MongoDB를 사용하는 것을 시리얼 클래스를.</target>
        </trans-unit>
        <trans-unit id="c799ed2093748459a0eee7d0093410a5519fa6d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/wq/html-json-forms&quot;&gt;html-json-forms&lt;/a&gt; package provides an algorithm and serializer for processing &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; submissions per the (inactive) &lt;a href=&quot;https://www.w3.org/TR/html-json-forms/&quot;&gt;HTML JSON Form specification&lt;/a&gt;. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, &lt;code&gt;&amp;lt;input name=&quot;items[0][id]&quot; value=&quot;5&quot;&amp;gt;&lt;/code&gt; will be interpreted as &lt;code&gt;{&quot;items&quot;: [{&quot;id&quot;: &quot;5&quot;}]}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wq/html-json-forms&quot;&gt;HTML-JSON - 형태의&lt;/a&gt; 패키지 처리를위한 알고리즘과 직렬 제공 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 을 제 (비활성) 당 제출 &lt;a href=&quot;https://www.w3.org/TR/html-json-forms/&quot;&gt;HTML 폼 JSON 사양&lt;/a&gt; . 시리얼 라이저를 사용하면 HTML 내에 임의로 중첩 된 JSON 구조를 쉽게 처리 할 수 ​​있습니다. 예를 들어, &lt;code&gt;&amp;lt;input name=&quot;items[0][id]&quot; value=&quot;5&quot;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;{&quot;items&quot;: [{&quot;id&quot;: &quot;5&quot;}]}&lt;/code&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fef5c361ebcd73eec16442f95d2344a90637944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hawkrest.readthedocs.io/en/latest/&quot;&gt;HawkREST&lt;/a&gt; library builds on the &lt;a href=&quot;https://mohawk.readthedocs.io/en/latest/&quot;&gt;Mohawk&lt;/a&gt; library to let you work with &lt;a href=&quot;https://github.com/hueniverse/hawk&quot;&gt;Hawk&lt;/a&gt; signed requests and responses in your API. &lt;a href=&quot;https://github.com/hueniverse/hawk&quot;&gt;Hawk&lt;/a&gt; lets two parties securely communicate with each other using messages signed by a shared key. It is based on &lt;a href=&quot;https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05&quot;&gt;HTTP MAC access authentication&lt;/a&gt; (which was based on parts of &lt;a href=&quot;https://oauth.net/core/1.0a/&quot;&gt;OAuth 1.0&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://hawkrest.readthedocs.io/en/latest/&quot;&gt;HawkREST&lt;/a&gt; 라이브러리는 기반으로 &lt;a href=&quot;https://mohawk.readthedocs.io/en/latest/&quot;&gt;모 호크&lt;/a&gt; 함께 작업 수 있도록 라이브러리 &lt;a href=&quot;https://github.com/hueniverse/hawk&quot;&gt;호크&lt;/a&gt; 당신의 API에서 요청과 응답을 체결했다. &lt;a href=&quot;https://github.com/hueniverse/hawk&quot;&gt;Hawk&lt;/a&gt; 는 공유 키로 서명 된 메시지를 사용하여 두 당사자가 서로 안전하게 통신 할 수 있도록합니다. 이를 기반으로 &lt;a href=&quot;https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05&quot;&gt;HTTP MAC 액세스 인증&lt;/a&gt; (부분에 기반 &lt;a href=&quot;https://oauth.net/core/1.0a/&quot;&gt;하여 OAuth 1.0&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="86c5343d9d72ba2a015fcd55974f504c53e64f94" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/&quot;&gt;Django REST framework OAuth&lt;/a&gt; package provides both OAuth1 and OAuth2 support for REST framework.</source>
          <target state="translated">&lt;a href=&quot;https://jpadilla.github.io/django-rest-framework-oauth/&quot;&gt;장고 REST 프레임 워크의 OAuth&lt;/a&gt; 패키지는 REST 프레임 워크 모두 OAuth1 및 OAuth2를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="99ca3f41f4c34b58e5486c8ad9b2604d94260d91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://marshmallow-code.github.io/django-rest-marshmallow/&quot;&gt;django-rest-marshmallow&lt;/a&gt; package provides an alternative implementation for serializers, using the python &lt;a href=&quot;https://marshmallow.readthedocs.io/en/latest/&quot;&gt;marshmallow&lt;/a&gt; library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.</source>
          <target state="translated">&lt;a href=&quot;https://marshmallow-code.github.io/django-rest-marshmallow/&quot;&gt;장고 - 휴식 - 마시맬로&lt;/a&gt; 패키지는 파이썬 사용 시리얼에 대한 대체 구현을 제공 &lt;a href=&quot;https://marshmallow.readthedocs.io/en/latest/&quot;&gt;마시 멜로의&lt;/a&gt; 라이브러리를. REST 프레임 워크 직렬 변환기와 동일한 API를 제공하며 일부 유스 케이스에서 드롭 인 대체로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36847fbc9c7379de1b52a9b697a3e32fe12f3de4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://restframework.herokuapp.com/&quot;&gt;Web browsable API&lt;/a&gt; is a huge usability win for your developers.</source>
          <target state="translated">&lt;a href=&quot;https://restframework.herokuapp.com/&quot;&gt;웹 검색 가능한 API는&lt;/a&gt; 개발자를위한 거대한 사용성 승리.</target>
        </trans-unit>
        <trans-unit id="aadfd9b11fbbfeadcb08d9bddac5a3c3fabab5e9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://wq.io/wq.db&quot;&gt;wq.db package&lt;/a&gt; provides an advanced &lt;a href=&quot;https://wq.io/docs/router&quot;&gt;ModelRouter&lt;/a&gt; class (and singleton instance) that extends &lt;code&gt;DefaultRouter&lt;/code&gt; with a &lt;code&gt;register_model()&lt;/code&gt; API. Much like Django's &lt;code&gt;admin.site.register&lt;/code&gt;, the only required argument to &lt;code&gt;rest.router.register_model&lt;/code&gt; is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.</source>
          <target state="translated">&lt;a href=&quot;https://wq.io/wq.db&quot;&gt;wq.db 패키지는&lt;/a&gt; 고급 제공 &lt;a href=&quot;https://wq.io/docs/router&quot;&gt;ModelRouter의&lt;/a&gt; 확장 클래스 (및 단독 인스턴스) &lt;code&gt;DefaultRouter&lt;/code&gt; 와 &lt;code&gt;register_model()&lt;/code&gt; API를. Django의 &lt;code&gt;admin.site.register&lt;/code&gt; 와 마찬가지로 &lt;code&gt;rest.router.register_model&lt;/code&gt; 에 필요한 유일한 인수 는 모델 클래스입니다. url 접두사, serializer 및 viewset에 대한 합리적인 기본값은 모델 및 전역 구성에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="28401e259d3c17b1cde2dab936bd12f3a64862a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'api-auth/'&lt;/code&gt; part of pattern can actually be whatever URL you want to use.</source>
          <target state="translated">패턴 의 &lt;code&gt;'api-auth/'&lt;/code&gt; 부분은 실제로 사용하려는 URL이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a5dd6f03ab9f7aa94ca1c9f5276c04c45e6177" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.fail()&lt;/code&gt; method is a shortcut for raising &lt;code&gt;ValidationError&lt;/code&gt; that takes a message string from the &lt;code&gt;error_messages&lt;/code&gt; dictionary. For example:</source>
          <target state="translated">&lt;code&gt;.fail()&lt;/code&gt; 메소드는 상승하는 지름길 &lt;code&gt;ValidationError&lt;/code&gt; (가)로부터 메시지 문자열을 얻어 &lt;code&gt;error_messages&lt;/code&gt; 사전. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3eb31645698dd25567153f45fc8a71e65e1a1d65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.is_valid()&lt;/code&gt; method takes an optional &lt;code&gt;raise_exception&lt;/code&gt; flag that will cause it to raise a &lt;code&gt;serializers.ValidationError&lt;/code&gt; exception if there are validation errors.</source>
          <target state="translated">&lt;code&gt;.is_valid()&lt;/code&gt; 메소드는 선택합니다 &lt;code&gt;raise_exception&lt;/code&gt; 의 그것은 인상의 원인이됩니다 플래그 &lt;code&gt;serializers.ValidationError&lt;/code&gt; 의 검증 오류가있는 경우 예외를.</target>
        </trans-unit>
        <trans-unit id="75f30bb19b4cffcd3a6d342f3239cfc4d50719b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.to_html()&lt;/code&gt; and &lt;code&gt;.get_html_context()&lt;/code&gt; methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.</source>
          <target state="translated">&lt;code&gt;.to_html()&lt;/code&gt; 및 &lt;code&gt;.get_html_context()&lt;/code&gt; 메서드는 컨트롤 렌더링 방법을 추가로 사용자 정의하기 위해 사용자 정의 페이지 매김 클래스에서 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b2b6a4967c380af4305fe6c48c4303bb5399d64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.to_representation()&lt;/code&gt; method is called to convert the initial datatype into a primitive, serializable datatype.</source>
          <target state="translated">&lt;code&gt;.to_representation()&lt;/code&gt; 메소드는 프리미티브 직렬화 데이터 형식으로 초기 데이터 형식을 변환하기 위해 호출된다.</target>
        </trans-unit>
        <trans-unit id="da7cf0c0b4c78d9aef2bff71868dbf982ffd485f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.urls&lt;/code&gt; attribute on a router instance is simply a standard list of URL patterns. There are a number of different styles for how you can include these URLs.</source>
          <target state="translated">라우터 인스턴스 의 &lt;code&gt;.urls&lt;/code&gt; 속성은 단순히 표준 URL 패턴 목록입니다. 이러한 URL을 포함시키는 방법에는 여러 가지 스타일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e3aaa5284cd69ec44a36135722596cd0dc91f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@api_view&lt;/code&gt; decorator for working with function based views.</source>
          <target state="translated">&lt;code&gt;@api_view&lt;/code&gt; 의 함수 기반 뷰와 협력 장식.</target>
        </trans-unit>
        <trans-unit id="693bd5aa80ab7c9158e4c71bd2cb8d2ee20f10e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;APIClient&lt;/code&gt; class supports the same request interface as Django's standard &lt;code&gt;Client&lt;/code&gt; class. This means that the standard &lt;code&gt;.get()&lt;/code&gt;, &lt;code&gt;.post()&lt;/code&gt;, &lt;code&gt;.put()&lt;/code&gt;, &lt;code&gt;.patch()&lt;/code&gt;, &lt;code&gt;.delete()&lt;/code&gt;, &lt;code&gt;.head()&lt;/code&gt; and &lt;code&gt;.options()&lt;/code&gt; methods are all available. For example:</source>
          <target state="translated">&lt;code&gt;APIClient&lt;/code&gt; 의 클래스는 장고의 표준과 같은 요청 인터페이스를 지원하는 &lt;code&gt;Client&lt;/code&gt; 클래스를. 이는 표준 &lt;code&gt;.get()&lt;/code&gt; , &lt;code&gt;.post()&lt;/code&gt; , &lt;code&gt;.put()&lt;/code&gt; , &lt;code&gt;.patch()&lt;/code&gt; , &lt;code&gt;.delete()&lt;/code&gt; , &lt;code&gt;.head()&lt;/code&gt; 및 &lt;code&gt;.options()&lt;/code&gt; 메소드를 모두 사용할 수 있음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="958d0da90b5e70f231a7ab72fa7fc021b6919246" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;APIRequestFactory&lt;/code&gt; class supports an almost identical API to Django's standard &lt;code&gt;RequestFactory&lt;/code&gt; class. This means that the standard &lt;code&gt;.get()&lt;/code&gt;, &lt;code&gt;.post()&lt;/code&gt;, &lt;code&gt;.put()&lt;/code&gt;, &lt;code&gt;.patch()&lt;/code&gt;, &lt;code&gt;.delete()&lt;/code&gt;, &lt;code&gt;.head()&lt;/code&gt; and &lt;code&gt;.options()&lt;/code&gt; methods are all available.</source>
          <target state="translated">&lt;code&gt;APIRequestFactory&lt;/code&gt; 의 클래스는 장고의 표준에 거의 동일한 API 지원 &lt;code&gt;RequestFactory&lt;/code&gt; 의 클래스를. 이는 표준 &lt;code&gt;.get()&lt;/code&gt; , &lt;code&gt;.post()&lt;/code&gt; , &lt;code&gt;.put()&lt;/code&gt; , &lt;code&gt;.patch()&lt;/code&gt; , &lt;code&gt;.delete()&lt;/code&gt; , &lt;code&gt;.head()&lt;/code&gt; 및 &lt;code&gt;.options()&lt;/code&gt; 메소드를 모두 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a4130f447f0ba102b0d62d884fcf2c134ad6c5d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;APIView&lt;/code&gt; class for working with class-based views.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 의 클래스 기반 뷰 작업을위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="405bb47b9825e5e9cc939596878e552197358b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;APIView&lt;/code&gt; class or &lt;code&gt;@api_view&lt;/code&gt; decorator will ensure that this property is automatically set to a list of &lt;code&gt;Authentication&lt;/code&gt; instances, based on the &lt;code&gt;authentication_classes&lt;/code&gt; set on the view or based on the &lt;code&gt;DEFAULT_AUTHENTICATORS&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 의 클래스 또는 &lt;code&gt;@api_view&lt;/code&gt; 의 장식이 속성이 자동으로 목록으로 설정되어 있는지 확인합니다 &lt;code&gt;Authentication&lt;/code&gt; 에 기초하여, 인스턴스 &lt;code&gt;authentication_classes&lt;/code&gt; 상의 뷰에 설정 또는 기반 &lt;code&gt;DEFAULT_AUTHENTICATORS&lt;/code&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="e1d60dda4fabc213fc160899fc93388bd1c50f4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;APIView&lt;/code&gt; class or &lt;code&gt;@api_view&lt;/code&gt; decorator will ensure that this property is automatically set to a list of &lt;code&gt;Parser&lt;/code&gt; instances, based on the &lt;code&gt;parser_classes&lt;/code&gt; set on the view or based on the &lt;code&gt;DEFAULT_PARSER_CLASSES&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;APIView&lt;/code&gt; 의 클래스 또는 &lt;code&gt;@api_view&lt;/code&gt; 의 장식이 속성이 자동으로 목록으로 설정되어 있는지 확인합니다 &lt;code&gt;Parser&lt;/code&gt; 에 기초하여, 인스턴스 &lt;code&gt;parser_classes&lt;/code&gt; 상의 뷰에 설정하거나 기반 &lt;code&gt;DEFAULT_PARSER_CLASSES&lt;/code&gt; 의 설정.</target>
        </trans-unit>
        <trans-unit id="3ce27736ed550df0b15a13eebbb242747bad9ba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllowAny&lt;/code&gt; permission class will allow unrestricted access, &lt;strong&gt;regardless of if the request was authenticated or unauthenticated&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;AllowAny&lt;/code&gt; 의 권한 클래스는 제한없이 액세스 할 수 &lt;strong&gt;에 관계없이 요청이 인증 또는 인증되지 않은 경우의&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c703a314588f28d3cfb6f9b2012a614c9e7ab361" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AnonRateThrottle&lt;/code&gt; will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.</source>
          <target state="translated">&lt;code&gt;AnonRateThrottle&lt;/code&gt; 는 지금까지 인증되지 않은 사용자 만 스로틀됩니다. 들어오는 요청의 IP 주소는 조절할 고유 키를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98afe8cb07c049ed388ec2a93f3defb46e83266d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BaseSerializer&lt;/code&gt; class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.</source>
          <target state="translated">&lt;code&gt;BaseSerializer&lt;/code&gt; 의 당신이, 또는 다른 스토리지 백엔드와 통합을 위해 특정 직렬화 스타일을 다루는 새로운 일반적인 시리얼 클래스를 구현하려는 경우에 클래스도 유용하다.</target>
        </trans-unit>
        <trans-unit id="6d099070718b3fc0172f75341cbd33a6ec942ce3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CursorPagination&lt;/code&gt; class includes a number of attributes that may be overridden to modify the pagination style.</source>
          <target state="translated">&lt;code&gt;CursorPagination&lt;/code&gt; 의 클래스는 매김 스타일을 수정 오버라이드 (override) 할 수 속성의 수를 포함한다.</target>
        </trans-unit>
        <trans-unit id="f86af01366da9f8f1af7a33b81cada50cabf996c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT_THROTTLE_RATES['anon']&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;DEFAULT_THROTTLE_RATES['anon']&lt;/code&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="f0b188db7306ed97234e57dcdbbaa963ade376e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT_THROTTLE_RATES['user']&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;DEFAULT_THROTTLE_RATES['user']&lt;/code&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="41cfa590acfa6f5445cd77aaeefa358c82abdf6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DefaultRouter&lt;/code&gt; class we're using also automatically creates the API root view for us, so we can now delete the &lt;code&gt;api_root&lt;/code&gt; method from our &lt;code&gt;views&lt;/code&gt; module.</source>
          <target state="translated">우리가 사용 하는 &lt;code&gt;DefaultRouter&lt;/code&gt; 클래스도 자동으로 API 루트 뷰를 생성하므로 이제 &lt;code&gt;views&lt;/code&gt; 모듈 에서 &lt;code&gt;api_root&lt;/code&gt; 메소드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fcf36c014d92abef6ecd90fe3b0e7c7c733d6cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FileField&lt;/code&gt; and &lt;code&gt;ImageField&lt;/code&gt; classes are only suitable for use with &lt;code&gt;MultiPartParser&lt;/code&gt; or &lt;code&gt;FileUploadParser&lt;/code&gt;. Most parsers, such as e.g. JSON don't support file uploads. Django's regular &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-FILE_UPLOAD_HANDLERS&quot;&gt;FILE_UPLOAD_HANDLERS&lt;/a&gt; are used for handling uploaded files.</source>
          <target state="translated">&lt;code&gt;FileField&lt;/code&gt; 및 &lt;code&gt;ImageField&lt;/code&gt; 클래스에 사용에만 적합 &lt;code&gt;MultiPartParser&lt;/code&gt; 또는 &lt;code&gt;FileUploadParser&lt;/code&gt; . JSON과 같은 대부분의 파서는 파일 업로드를 지원하지 않습니다. 장고의 일반 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-FILE_UPLOAD_HANDLERS&quot;&gt;FILE_UPLOAD_HANDLERS&lt;/a&gt; 는 업로드 된 파일을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0307406a9637b10ca192aee40ca555a722f344f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FileUploadParser&lt;/code&gt; is for usage with native clients that can upload the file as a raw data request. For web-based uploads, or for native clients with multipart upload support, you should use the &lt;code&gt;MultiPartParser&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;FileUploadParser&lt;/code&gt; 는 원시 데이터 요청으로 파일을 업로드 할 수 있습니다 네이티브 클라이언트와의 사용을위한 것입니다. 웹 기반 업로드 또는 멀티 파트 업로드가 지원되는 기본 클라이언트의 경우 &lt;code&gt;MultiPartParser&lt;/code&gt; 를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8683b1c8541a12c8cebd8fb4f44a4c241457dec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenericViewSet&lt;/code&gt; class inherits from &lt;code&gt;GenericAPIView&lt;/code&gt;, and provides the default set of &lt;code&gt;get_object&lt;/code&gt;, &lt;code&gt;get_queryset&lt;/code&gt; methods and other generic view base behavior, but does not include any actions by default.</source>
          <target state="translated">&lt;code&gt;GenericViewSet&lt;/code&gt; 의 클래스에서 상속 &lt;code&gt;GenericAPIView&lt;/code&gt; , 그리고 기본 세트 제공 &lt;code&gt;get_object&lt;/code&gt; , &lt;code&gt;get_queryset&lt;/code&gt; 의 방법 및 기타 일반적인보기 기본 동작은하지만, 기본적으로 어떤 조치를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ba80eeb840dc6462760eb4a9017e0690b0e82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HiddenField&lt;/code&gt; class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.</source>
          <target state="translated">&lt;code&gt;HiddenField&lt;/code&gt; 당신이 필요 일부 사전 제공 한 필드 값을 기준으로 실행하려면 몇 가지 확인이있는 경우 클래스는 보통 필요합니다,하지만 당신은 최종 사용자에게 그 모든 필드를 노출하고 싶지 않아요.</target>
        </trans-unit>
        <trans-unit id="709343a8ab7d7f6e13d28156e7c27cfe9421ffc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostNameVersioning&lt;/code&gt; scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as &lt;code&gt;127.0.0.1&lt;/code&gt;. There are various online tutorials on how to &lt;a href=&quot;https://reinteractive.net/posts/199-developing-and-testing-rails-applications-with-subdomains&quot;&gt;access localhost with a custom subdomain&lt;/a&gt; which you may find helpful in this case.</source>
          <target state="translated">&lt;code&gt;HostNameVersioning&lt;/code&gt; 의 방식은 당신이 일반적으로 원시 IP 주소를 액세스하는 것 같은 디버그 모드에서 사용하기 어색 할 수있다 &lt;code&gt;127.0.0.1&lt;/code&gt; . 이 경우 유용 할 수 &lt;a href=&quot;https://reinteractive.net/posts/199-developing-and-testing-rails-applications-with-subdomains&quot;&gt;있는 사용자 정의 하위 도메인으로 localhost&lt;/a&gt; 에 액세스 하는 방법에 대한 다양한 온라인 학습서가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b732e113b702fae815b39b84ffa2d80c92b837cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; class is similar to the &lt;code&gt;ModelSerializer&lt;/code&gt; class except that it uses hyperlinks to represent relationships, rather than primary keys.</source>
          <target state="translated">&lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 의 클래스는 비슷합니다 &lt;code&gt;ModelSerializer&lt;/code&gt; 에 오히려 기본 키보다는 관계를 표현하기 위해 하이퍼 링크를 사용하는 것을 제외하고 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0e9a6478b1f06252932ae0ac2a61c3af0ead0ce4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; has the following differences from &lt;code&gt;ModelSerializer&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt; 는 에서 다음과 같은 차이가있다 &lt;code&gt;ModelSerializer&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="3726176894274acac486c8e1b99736465c8bf583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsAdminUser&lt;/code&gt; permission class will deny permission to any user, unless &lt;code&gt;user.is_staff&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; in which case permission will be allowed.</source>
          <target state="translated">&lt;code&gt;IsAdminUser&lt;/code&gt; 를 하지 않는 한 권한 클래스는 모든 사용자에게 권한을 거부합니다 &lt;code&gt;user.is_staff&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 허용 할 경우 허가한다.</target>
        </trans-unit>
        <trans-unit id="f1d28d538a96c837f6f8de00c972d21ce0a61048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsAuthenticated&lt;/code&gt; permission class will deny permission to any unauthenticated user, and allow permission otherwise.</source>
          <target state="translated">&lt;code&gt;IsAuthenticated&lt;/code&gt; 는의 액세스권 클래스는 인증되지 않은 사용자에게 권한을 거부하고, 다른 권한을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3264710e92be2dfe0cd4ba6b3be28e0573092c8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt; will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the &quot;safe&quot; methods; &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;OPTIONS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt; 는 인증 된 사용자가 어떤 요청을 수행 할 수 있습니다. 승인되지 않은 사용자에 대한 요청은 요청 방법이 &quot;안전한&quot;방법 중 하나 인 경우에만 허용됩니다. &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; 또는 &lt;code&gt;OPTIONS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d0eda288a663d7f6df8b54c88cc45f153592657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOffsetPagination&lt;/code&gt; class includes a number of attributes that may be overridden to modify the pagination style.</source>
          <target state="translated">&lt;code&gt;LimitOffsetPagination&lt;/code&gt; 의 클래스는 매김 스타일을 수정 오버라이드 (override) 할 수 속성의 수를 포함한다.</target>
        </trans-unit>
        <trans-unit id="e239ce83acc26d8ba96adb55d14018b1d18a57d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListField&lt;/code&gt; class also supports a declarative style that allows you to write reusable list field classes.</source>
          <target state="translated">&lt;code&gt;ListField&lt;/code&gt; 클래스는 재사용 가능한 목록 필드 클래스를 작성 할 수있는 선언적 스타일을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a668f27a4a8ff4ce39e84680c119e0104651e77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListSerializer&lt;/code&gt; class provides the behavior for serializing and validating multiple objects at once. You won't &lt;em&gt;typically&lt;/em&gt; need to use &lt;code&gt;ListSerializer&lt;/code&gt; directly, but should instead simply pass &lt;code&gt;many=True&lt;/code&gt; when instantiating a serializer.</source>
          <target state="translated">&lt;code&gt;ListSerializer&lt;/code&gt; 의 클래스는 직렬화 한 번에 여러 개체를 검증하기위한 동작을 제공한다. &lt;em&gt;일반적으로 &lt;/em&gt; &lt;code&gt;ListSerializer&lt;/code&gt; 를 직접 사용할 필요 는 없지만 직렬 변환기를 인스턴스화 할 때 간단히 &lt;code&gt;many=True&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9237b00416e2450996acbd2bb5b4720bc70584" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModelField&lt;/code&gt; class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a &lt;code&gt;ModelField&lt;/code&gt;, it must be passed a field that is attached to an instantiated model. For example: &lt;code&gt;ModelField(model_field=MyModel()._meta.get_field('custom_field'))&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ModelField&lt;/code&gt; 의 클래스는 일반적으로 내부 사용을위한 것입니다,하지만 필요한 경우 API를 사용할 수 있습니다. &lt;code&gt;ModelField&lt;/code&gt; 를 올바르게 인스턴스화 하려면 인스턴스화 된 모델에 첨부 된 필드를 전달해야합니다. 예를 들면 다음과 같습니다. &lt;code&gt;ModelField(model_field=MyModel()._meta.get_field('custom_field'))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bd13578e20225786b737b1c310bf6f6f48b4c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModelSerializer&lt;/code&gt; class provides a shortcut that lets you automatically create a &lt;code&gt;Serializer&lt;/code&gt; class with fields that correspond to the Model fields.</source>
          <target state="translated">&lt;code&gt;ModelSerializer&lt;/code&gt; 의 클래스는 자동으로 만들 수있는 바로 가기를 제공 &lt;code&gt;Serializer&lt;/code&gt; 필드 클래스를 모델 필드에 대응.</target>
        </trans-unit>
        <trans-unit id="b4996c8372fe4b448d89d5f4a0f04e730a6f63ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModelViewSet&lt;/code&gt; class inherits from &lt;code&gt;GenericAPIView&lt;/code&gt; and includes implementations for various actions, by mixing in the behavior of the various mixin classes.</source>
          <target state="translated">&lt;code&gt;ModelViewSet&lt;/code&gt; 의 클래스에서 상속 &lt;code&gt;GenericAPIView&lt;/code&gt; 및 다양한 믹스 인 클래스의 동작에 혼합하여, 다양한 작업에 대한 구현이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="44192bf70d86d4e8d297f828257eb177697b49b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OrderingFilter&lt;/code&gt; class supports simple query parameter controlled ordering of results.</source>
          <target state="translated">&lt;code&gt;OrderingFilter&lt;/code&gt; 의 클래스는 결과의 간단한 쿼리 매개 변수를 제어 순서를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4a47146936f2e9524cea60f3a760acce0e7ae958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PageNumberPagination&lt;/code&gt; class includes a number of attributes that may be overridden to modify the pagination style.</source>
          <target state="translated">&lt;code&gt;PageNumberPagination&lt;/code&gt; 의 클래스는 매김 스타일을 수정 오버라이드 (override) 할 수 속성의 수를 포함한다.</target>
        </trans-unit>
        <trans-unit id="764120474b44cc97ad07f87da020da291be98948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadOnlyModelViewSet&lt;/code&gt; class also inherits from &lt;code&gt;GenericAPIView&lt;/code&gt;. As with &lt;code&gt;ModelViewSet&lt;/code&gt; it also includes implementations for various actions, but unlike &lt;code&gt;ModelViewSet&lt;/code&gt; only provides the 'read-only' actions, &lt;code&gt;.list()&lt;/code&gt; and &lt;code&gt;.retrieve()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ReadOnlyModelViewSet&lt;/code&gt; 의 클래스는 상속 &lt;code&gt;GenericAPIView&lt;/code&gt; . &lt;code&gt;ModelViewSet&lt;/code&gt; 과 마찬가지로 다양한 조치에 대한 구현도 포함하지만 &lt;code&gt;ModelViewSet&lt;/code&gt; 과 달리 '읽기 전용'조치 인 &lt;code&gt;.list()&lt;/code&gt; 및 &lt;code&gt;.retrieve()&lt;/code&gt; 만 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="02eb6a22581abc8b2c8f4afd20aff5675fbe250c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RequestsClient&lt;/code&gt; class is useful if you want to write tests that solely interact with the service interface. This is a little stricter than using the standard Django test client, as it means that all interactions should be via the API.</source>
          <target state="translated">&lt;code&gt;RequestsClient&lt;/code&gt; 의 당신이 전적으로 상호 작용 서비스 인터페이스 테스트를 작성하려면 클래스에 유용합니다. 이는 표준 Django 테스트 클라이언트를 사용하는 것보다 조금 더 엄격합니다. 이는 모든 상호 작용이 API를 통해 이루어져야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fd7a4d568225171aa2f46e5ddadf4ef5ebf4be27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Response&lt;/code&gt; class extends &lt;code&gt;SimpleTemplateResponse&lt;/code&gt;, and all the usual attributes and methods are also available on the response. For example you can set headers on the response in the standard way:</source>
          <target state="translated">&lt;code&gt;Response&lt;/code&gt; 클래스는 확장 &lt;code&gt;SimpleTemplateResponse&lt;/code&gt; 를 , 그리고 모든 일반적인 속성과 메소드는 응답에도 사용할 수 있습니다. 예를 들어 표준 방식으로 응답에 헤더를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b461207d4949a92613cb0e30d5b6cdfb2a3e83a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Response&lt;/code&gt; class subclasses Django's &lt;code&gt;SimpleTemplateResponse&lt;/code&gt;. &lt;code&gt;Response&lt;/code&gt; objects are initialised with data, which should consist of native Python primitives. REST framework then uses standard HTTP content negotiation to determine how it should render the final response content.</source>
          <target state="translated">&lt;code&gt;Response&lt;/code&gt; 클래스는 장고의 서브 클래스 &lt;code&gt;SimpleTemplateResponse&lt;/code&gt; 을 . &lt;code&gt;Response&lt;/code&gt; 객체는 데이터로 초기화되며, 기본 Python 프리미티브로 구성되어야합니다. 그런 다음 REST 프레임 워크는 표준 HTTP 컨텐츠 협상을 사용하여 최종 응답 컨텐츠를 렌더링하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b3171dc3328f6477ad0c3bdc80a4ccf11768c189" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ScopedRateThrottle&lt;/code&gt; class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a &lt;code&gt;.throttle_scope&lt;/code&gt; property. The unique throttle key will then be formed by concatenating the &quot;scope&quot; of the request with the unique user id or IP address.</source>
          <target state="translated">&lt;code&gt;ScopedRateThrottle&lt;/code&gt; 의 클래스는 API의 특정 부분에 대한 액세스를 제한 할 수 있습니다. 이 스로틀은 액세스중인보기에 &lt;code&gt;.throttle_scope&lt;/code&gt; 속성이 포함 된 경우에만 적용됩니다 . 그런 다음 요청의 &quot;범위&quot;를 고유 사용자 ID 또는 IP 주소와 연결하여 고유 스로틀 키가 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3698b0d31f524697067958f9b02aaa5a3c19f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SearchFilter&lt;/code&gt; class supports simple single query parameter based searching, and is based on the &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields&quot;&gt;Django admin's search functionality&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SearchFilter&lt;/code&gt; 의 클래스는 간단한 단일 쿼리 매개 변수 기반 검색을 지원하고 기반으로 &lt;a href=&quot;https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields&quot;&gt;장고 관리자의 검색 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9333110cbad1cd373c5c2a81252c4ea3b4f0f5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SearchFilter&lt;/code&gt; class will only be applied if the view has a &lt;code&gt;search_fields&lt;/code&gt; attribute set. The &lt;code&gt;search_fields&lt;/code&gt; attribute should be a list of names of text type fields on the model, such as &lt;code&gt;CharField&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SearchFilter&lt;/code&gt; 의 뷰가있는 경우 클래스는 적용됩니다 &lt;code&gt;search_fields&lt;/code&gt; 의 속성 세트를. &lt;code&gt;search_fields&lt;/code&gt; 의 속성은 같은 모델의 텍스트 입력 필드의 이름 목록이어야한다 &lt;code&gt;CharField&lt;/code&gt; 또는 &lt;code&gt;TextField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65720615da11c9c61c645f34c3938f79dbed550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Serializer&lt;/code&gt; class can also handle serializing or deserializing lists of objects.</source>
          <target state="translated">&lt;code&gt;Serializer&lt;/code&gt; 클래스는 직렬화 또는 객체의 목록을 역 직렬화 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4d9de6f4f170ade62f0a5aadcfd11ec72b806c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Serializer&lt;/code&gt; class is itself a type of &lt;code&gt;Field&lt;/code&gt;, and can be used to represent relationships where one object type is nested inside another.</source>
          <target state="translated">&lt;code&gt;Serializer&lt;/code&gt; 클래스의 종류 자체 &lt;code&gt;Field&lt;/code&gt; , 하나 개의 오브젝트 타입은 다른 내부 중첩 관계를 나타내는 데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d224db30d4a7185a4d9aab492b084c5535022f8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UserRateThrottle&lt;/code&gt; will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.</source>
          <target state="translated">&lt;code&gt;UserRateThrottle&lt;/code&gt; 는 API를 통해 요청 주어진 속도에 사용자를 스로틀합니다. 사용자 ID는 조절할 고유 키를 생성하는 데 사용됩니다. 인증되지 않은 요청은 들어오는 요청의 IP 주소를 사용하여 스로틀 할 고유 키를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1f92b13d8f525f29abd5a1b143f6d50c024b8180" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ValidationError&lt;/code&gt; class should be used for serializer and field validation, and by validator classes. It is also raised when calling &lt;code&gt;serializer.is_valid&lt;/code&gt; with the &lt;code&gt;raise_exception&lt;/code&gt; keyword argument:</source>
          <target state="translated">&lt;code&gt;ValidationError&lt;/code&gt; 의 클래스는 시리얼 라이저 및 현장 확인을 위해 사용되며, 유효성 검사기 클래스가되어야한다. &lt;code&gt;raise_exception&lt;/code&gt; 키워드 인수로 &lt;code&gt;serializer.is_valid&lt;/code&gt; 를 호출 할 때도 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bd92b0c00e045e9b0cd36930e66d4be4b3a0c6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ValidationError&lt;/code&gt; exception is slightly different from the other &lt;code&gt;APIException&lt;/code&gt; classes:</source>
          <target state="translated">&lt;code&gt;ValidationError&lt;/code&gt; 의 예외는 다른 약간 다른 &lt;code&gt;APIException&lt;/code&gt; 클래스 :</target>
        </trans-unit>
        <trans-unit id="49c04698e18a3aa0b19e39781857c76c51867083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ViewSet&lt;/code&gt; class does not provide any implementations of actions. In order to use a &lt;code&gt;ViewSet&lt;/code&gt; class you'll override the class and define the action implementations explicitly.</source>
          <target state="translated">&lt;code&gt;ViewSet&lt;/code&gt; 클래스는 작업 중 하나 구현을 제공하지 않습니다. &lt;code&gt;ViewSet&lt;/code&gt; 클래스 를 사용하려면 클래스를 재정의하고 동작 구현을 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5cd1ef9b267602b226d2d5cfbb679f043a1b5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ViewSet&lt;/code&gt; class inherits from &lt;code&gt;APIView&lt;/code&gt;. You can use any of the standard attributes such as &lt;code&gt;permission_classes&lt;/code&gt;, &lt;code&gt;authentication_classes&lt;/code&gt; in order to control the API policy on the viewset.</source>
          <target state="translated">&lt;code&gt;ViewSet&lt;/code&gt; 에서 클래스 상속 &lt;code&gt;APIView&lt;/code&gt; . viewset에서 API 정책을 제어하기 위해 &lt;code&gt;permission_classes&lt;/code&gt; , &lt;code&gt;authentication_classes&lt;/code&gt; 와 같은 표준 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23b67e692511f5598d86213a16194eaaad1c6e2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; HTTP header and &lt;code&gt;REMOTE_ADDR&lt;/code&gt; WSGI variable are used to uniquely identify client IP addresses for throttling. If the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header is present then it will be used, otherwise the value of the &lt;code&gt;REMOTE_ADDR&lt;/code&gt; variable from the WSGI environment will be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; HTTP 헤더와 &lt;code&gt;REMOTE_ADDR&lt;/code&gt; WSGI 변수는 고유 제한에 대한 클라이언트의 IP 주소를 식별하는 데 사용됩니다. 경우] &lt;code&gt;X-Forwarded-For&lt;/code&gt; 헤더가 다음은 달리의 값을 사용한다 &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 의 WSGI 환경의 변수들이 사용된다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
