<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="23489b054c9d1e661085fd7ade8acb2475375094" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; helper can be used to defer the selection of a component to run time. The &lt;code&gt;{{my-component}}&lt;/code&gt; syntax always renders the same component, while using the &lt;code&gt;{{component}}&lt;/code&gt; helper allows choosing a component to render on the fly. This is useful in cases where you want to interact with different external libraries depending on the data. Using the &lt;code&gt;{{component}}&lt;/code&gt; helper would allow you to keep different logic well separated.</source>
          <target state="translated">는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt; 도우미는 런타임에 구성 요소의 선택을 연기 할 수 있습니다. &lt;code&gt;{{my-component}}&lt;/code&gt; 사용하는 동안 구문은 항상 같은 구성 요소를 렌더링 &lt;code&gt;{{component}}&lt;/code&gt; 도우미가 즉시 렌더링 할 구성 요소를 선택하는 허용한다. 데이터에 따라 다른 외부 라이브러리와 상호 작용하려는 경우에 유용합니다. 은 Using &lt;code&gt;{{component}}&lt;/code&gt; 헬퍼하면 잘 분리 된 다른 논리를 유지 할 수있다.</target>
        </trans-unit>
        <trans-unit id="80ffe12423c4f4418b92c52ce25e13ca8840255f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt;&lt;code&gt;{{debugger}}&lt;/code&gt;&lt;/a&gt; helper provides a handlebars equivalent to JavaScript's &lt;code&gt;debugger&lt;/code&gt; keyword. It will halt execution inside the debugger helper and give you the ability to inspect the current rendering context:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt; &lt;code&gt;{{debugger}}&lt;/code&gt; &lt;/a&gt; 헬퍼는 자바 스크립트의 동등한 핸들 제공 &lt;code&gt;debugger&lt;/code&gt; 키워드를. 디버거 도우미 내에서 실행이 중단되고 현재 렌더링 컨텍스트를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8f61b48bfab920e95655c42840396a2f3f8014" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper can have a corresponding &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the array passed to &lt;code&gt;{{#each}}&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt; 헬퍼가있을 수 있습니다 해당 &lt;code&gt;{{else}}&lt;/code&gt; . &lt;code&gt;{{#each}}&lt;/code&gt; 에 전달 된 배열 이 비어 있으면이 블록의 내용이 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a5dfe3aacaf09268ef43166eeb9e8edcded68ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt;&lt;code&gt;{{#each-in}}&lt;/code&gt;&lt;/a&gt; helper can have a matching &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the object is empty, null, or undefined:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt; &lt;code&gt;{{#each-in}}&lt;/code&gt; &lt;/a&gt; 도우미는 일치 할 수 있습니다 &lt;code&gt;{{else}}&lt;/code&gt; . 이 블록의 내용은 객체가 비어 있거나 null이거나 정의되지 않은 경우 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="b327dbd565eb9fdd986c4b054241ad5e30065698" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt;&lt;code&gt;{{get}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to dynamically send the value of a variable to another helper or component. This can be useful if you want to output one of several values based on the result of a computed property.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt; &lt;code&gt;{{get}}&lt;/code&gt; &lt;/a&gt; 도우미 동적으로 다른 도우미 또는 구성 요소에 변수의 값을 쉽게 전송할을 수 있습니다. 계산 된 속성의 결과에 따라 여러 값 중 하나를 출력하려는 ​​경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61302d7882e1a4a6e553fe68b02feeeae75416e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;&lt;code&gt;{{textarea}}&lt;/code&gt;&lt;/a&gt; helpers in Ember.js are the easiest way to create common form controls. Using these helpers, you can create form controls that are almost identical to the native HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; elements, but are aware of Ember's two-way bindings and can automatically update.</source>
          <target state="translated">Ember.js 의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt; &lt;code&gt;{{textarea}}&lt;/code&gt; &lt;/a&gt; 도우미는 일반적인 양식 컨트롤을 만드는 가장 쉬운 방법입니다. 이러한 도우미를 사용하면 네이티브 HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 요소와 거의 동일한 양식 컨트롤을 만들 수 있지만 Ember의 양방향 바인딩을 인식하고 자동으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85d9f0441c7c29d7da9b855a389e22f68bcf461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt;&lt;code&gt;{{log}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to output variables or expressions in the current rendering context into your browser's console:</source>
          <target state="translated">는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt; &lt;code&gt;{{log}}&lt;/code&gt; &lt;/a&gt; 헬퍼는 브라우저의 콘솔에 현재 렌더링 컨텍스트에서 출력 변수 나 표현에 쉽게 그것을 만드는 :</target>
        </trans-unit>
        <trans-unit id="17f528362a0405c2911a3e6d031edc5b960dfd08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt;&lt;code&gt;fillIn&lt;/code&gt;&lt;/a&gt; helper &quot;fills in&quot; the given text into an input field matching the given selector.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt; &lt;code&gt;fillIn&lt;/code&gt; &lt;/a&gt; 헬퍼 지정된 선택 입력 정합 필드에 지정된 텍스트 &quot;채운다&quot;.</target>
        </trans-unit>
        <trans-unit id="fadd4ef675168e49d87ffb530f6637c11e100846" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt;&lt;code&gt;keyEvent&lt;/code&gt;&lt;/a&gt; helper sends a key stroke event to the UI, simulating the user typing a key.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt; &lt;code&gt;keyEvent&lt;/code&gt; &lt;/a&gt; 도우미는 키를 입력하는 사용자를 모방하여 UI에 키 스트로크 이벤트를 송신한다.</target>
        </trans-unit>
        <trans-unit id="0aef6d62598e457e26c06a939a5185bf766acd4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter&lt;/a&gt; has a handful of hooks that are commonly used to extend it to work with non-standard backends.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter는&lt;/a&gt; 일반적 비표준 백엔드 작동하도록 확장하는 데 사용되는 후크의 소수를 갖는다.</target>
        </trans-unit>
        <trans-unit id="484456215b5f899d8ed5e829d7551272461d51b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;Google Maps API&lt;/a&gt; requires us to reference its library from a remote script. In this case we'll provide this script to our Ember app via an Addon called &lt;code&gt;ember-simple-google-maps&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;Google지도 API는&lt;/a&gt; 원격 스크립트의 라이브러리를 참조하기 위해 우리를 필요로한다. 이 경우 &lt;code&gt;ember-simple-google-maps&lt;/code&gt; 라는 애드온을 통해이 스크립트를 Ember 앱에 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="721d0aca3cae4958efdc2c786984eea8d65f5f0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt;&lt;code&gt;vendor&lt;/code&gt; directory&lt;/a&gt; in Ember is a special directory where you can include content that gets compiled into your application. When Ember CLI builds our app from our source code, it copies &lt;code&gt;ember-tutorial.css&lt;/code&gt; into a file called &lt;code&gt;vendor.css&lt;/code&gt;.</source>
          <target state="translated">Ember 의 &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt; &lt;code&gt;vendor&lt;/code&gt; 디렉토리&lt;/a&gt; 는 응용 프로그램으로 컴파일 된 컨텐츠를 포함 할 수있는 특수 디렉토리입니다. Ember CLI가 소스 코드에서 앱을 빌드 할 때 &lt;code&gt;ember-tutorial.css&lt;/code&gt; 를 &lt;code&gt;vendor.css&lt;/code&gt; 파일에 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="f3296c43c92a794424bfcbe162e716bebeab8f9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;Object Model&lt;/a&gt; section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</source>
          <target state="translated">안내서의 &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;객체 모델&lt;/a&gt; 섹션에서는 프로토 타입 확장없이 계산 된 속성, 관찰자 ​​및 바인딩을 작성하는 방법에 대해 설명합니다. 아래에서 기존 코드를 현재 권장되는 형식으로 변환하는 방법에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3016cd065a1ea33674454f4b4409c5a76ecee77d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ApplicationInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Application&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ApplicationInstance&lt;/code&gt; 실행중인의 상태 측면을 모두 캡슐화 &lt;code&gt;Application&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f930fd3f23af023ef9f744a703e14d94dcebcaeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlogPost&lt;/code&gt; model would have properties like:</source>
          <target state="translated">&lt;code&gt;BlogPost&lt;/code&gt; 모델과 같은 특성을 가지고 것입니다 :</target>
        </trans-unit>
        <trans-unit id="fae849844f7c3ca3ad9b933a44e600ae65479143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BroadwayStar&lt;/code&gt; class contains three methods: &lt;code&gt;say()&lt;/code&gt;, &lt;code&gt;sing()&lt;/code&gt;, and &lt;code&gt;dance()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BroadwayStar&lt;/code&gt; 의 : 클래스는 세 가지 방법이 포함되어 &lt;code&gt;say()&lt;/code&gt; , &lt;code&gt;sing()&lt;/code&gt; 와 &lt;code&gt;dance()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d63f1b0f445b29ddfc61aeec73fb12eb211d5567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ContainerDebugAdapter&lt;/code&gt; helps the container and resolver interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">&lt;code&gt;ContainerDebugAdapter&lt;/code&gt; 는 등 같은 디버그 엠버 그 도구를 사용하여 용기 및 해결 프로그램 인터페이스 도움 &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;엠버 경위&lt;/a&gt; 크롬과 파이어 폭스를.</target>
        </trans-unit>
        <trans-unit id="2b819ff65f7652ad8943fa82a80ca24f474b2a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.BooleanTransform&lt;/code&gt; class is used to serialize and deserialize boolean attributes on Ember Data record objects. This transform is used when &lt;code&gt;boolean&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.BooleanTransform&lt;/code&gt; 의 클래스는 직렬화에 사용 엠버 데이터 레코드 개체에 대한 부울 속성을 역 직렬화된다. 이 변환은 &lt;code&gt;boolean&lt;/code&gt; 이 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd3e9a0eed710efe4a88384528b918c339217700" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.DateTransform&lt;/code&gt; class is used to serialize and deserialize date attributes on Ember Data record objects. This transform is used when &lt;code&gt;date&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function. It uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;code&gt;ISO 8601&lt;/code&gt;&lt;/a&gt; standard.</source>
          <target state="translated">&lt;code&gt;DS.DateTransform&lt;/code&gt; 의 클래스는 직렬화에 사용되며, 직렬화 날짜 엠버 데이터 레코드 객체에 속성. 이 변환은 &lt;code&gt;date&lt;/code&gt; 가 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 . &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt; &lt;code&gt;ISO 8601&lt;/code&gt; &lt;/a&gt; 표준을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2982cc3dc82ca2b47f88e8fdbe38cb683d0cbfa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Model&lt;/code&gt; states are themselves stateless. What that means is that, the hierarchical states that each of &lt;em&gt;those&lt;/em&gt; points to is a shared data structure. For performance reasons, instead of each record getting its own copy of the hierarchy of states, each record points to this global, immutable shared instance. How does a state know which record it should be acting on? We pass the record instance into the state's event handlers as the first argument.</source>
          <target state="translated">&lt;code&gt;DS.Model&lt;/code&gt; 의 상태는 그 자체가 상태입니다. 그 수단이, 계층 상태 란이 각각 &lt;em&gt;그&lt;/em&gt; 포인트 공유 데이터 구조에 관한 것이다. 성능상의 이유로 각 레코드가 고유 한 상태 계층 복사본을 가져 오는 대신 각 레코드는 변경 불가능한이 전역 공유 인스턴스를 가리 킵니다. 국가는 어떤 기록이 행동해야하는지 어떻게 알 수 있습니까? 레코드 인스턴스를 첫 번째 인수로 상태의 이벤트 핸들러에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f0eb91368a9212981a5c1132e3c4cf949c7a59b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.NumberTransform&lt;/code&gt; class is used to serialize and deserialize numeric attributes on Ember Data record objects. This transform is used when &lt;code&gt;number&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.NumberTransform&lt;/code&gt; 의 클래스는 직렬화에 사용 엠버 데이터 레코드 개체의 숫자 속성을 역 직렬화된다. 이 변환은 &lt;code&gt;number&lt;/code&gt; 가 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="57ede3918d3480e3b06e6aa03ddac19ce5a83194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.StringTransform&lt;/code&gt; class is used to serialize and deserialize string attributes on Ember Data record objects. This transform is used when &lt;code&gt;string&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DS.StringTransform&lt;/code&gt; 의 클래스는 직렬화에 사용되며, 직렬화 문자열은 엠버 데이터 레코드 객체에 속성. 이 변환은 &lt;code&gt;string&lt;/code&gt; 이 유형 매개 변수로 &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; 함수에 전달 될 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c7d84bb5ae36b5bebe679b64273fe856da64324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Transform&lt;/code&gt; class is used to serialize and deserialize model attributes when they are saved or loaded from an adapter. Subclassing &lt;code&gt;DS.Transform&lt;/code&gt; is useful for creating custom attributes. All subclasses of &lt;code&gt;DS.Transform&lt;/code&gt; must implement a &lt;code&gt;serialize&lt;/code&gt; and a &lt;code&gt;deserialize&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;DS.Transform&lt;/code&gt; 의 클래스는 직렬화에 사용하고 저장하거나 어댑터에서로드 할 때 직렬화 모델 속성. 서브 클래 &lt;code&gt;DS.Transform&lt;/code&gt; 은 사용자 정의 속성을 작성하는 데 유용합니다. &lt;code&gt;DS.Transform&lt;/code&gt; 의 모든 하위 클래스는 &lt;code&gt;serialize&lt;/code&gt; 및 &lt;code&gt;deserialize&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e00a79faab114e9901c4f0599964d16729665318" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; helps a data persistence library interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;Ember Extension&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">&lt;code&gt;DataAdapter&lt;/code&gt; 데이터가 같은 같은 디버그 엠버 그 도구를 사용하여 라이브러리 인터페이스 지속성하는 데 도움이 &lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;엠버 확장&lt;/a&gt; 크롬과 파이어 폭스를.</target>
        </trans-unit>
        <trans-unit id="319307645bea1fa807d738e83c0a90cd1cf5ef96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; responsible for delegating events to this application's views.</source>
          <target state="translated">이 응용 프로그램의 뷰에 이벤트를 위임 할 책임 이있는 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a1153767edf9a9bc5406d38e28481d0c34bda34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Mixin&lt;/code&gt; class allows you to create mixins, whose properties can be added to other classes. For instance,</source>
          <target state="translated">&lt;code&gt;Ember.Mixin&lt;/code&gt; 의 클래스는 그 속성을 다른 클래스에 추가 할 수 있습니다 유지 mixin을 만들 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6a4036df61adabd029b6eba87bb294575bc9d7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Route&lt;/code&gt; class is used to define individual routes. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">&lt;code&gt;Ember.Route&lt;/code&gt; 의 클래스는 각각의 경로를 정의하는 데 사용됩니다. &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;설명서&lt;/a&gt; 는 라우팅 가이드 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="885e6e3f5749d0e1ec5e434cb9dfa2078fb80a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Router&lt;/code&gt; class manages the application state and URLs. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">&lt;code&gt;Ember.Router&lt;/code&gt; 의 클래스는 응용 프로그램 상태와 URL을 관리합니다. &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;설명서&lt;/a&gt; 는 라우팅 가이드 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="211a8a0ab63aee094d2b679406429c9861efd416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.run&lt;/code&gt; method can be used to create a run loop. In this example, jQuery and &lt;code&gt;Ember.run&lt;/code&gt; are used to handle a click event and run some Ember code.</source>
          <target state="translated">&lt;code&gt;Ember.run&lt;/code&gt; 의 방법은 실행 루프를 만드는 데 사용할 수 있습니다. 이 예제에서 jQuery와 &lt;code&gt;Ember.run&lt;/code&gt; 은 클릭 이벤트를 처리하고 일부 Ember 코드를 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c7c53858dc783a25f5941955654a26b7b31a8c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Engine&lt;/code&gt; class contains core functionality for both applications and engines.</source>
          <target state="translated">&lt;code&gt;Engine&lt;/code&gt; 클래스는 응용 프로그램과 엔진 모두를위한 핵심 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14638c0630a0a3cff87817f36c2554b1c8d6490b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EngineInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Engine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EngineInstance&lt;/code&gt; 는 실행의 상태 측면을 모두 캡슐화 &lt;code&gt;Engine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef790b8517960a1d3695e93af0bd1b8f3839440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is smart enough to determine the URLs it communicates with based on the name of the model. For example, if you ask for a &lt;code&gt;Post&lt;/code&gt; by ID:</source>
          <target state="translated">&lt;code&gt;JSONAPIAdapter&lt;/code&gt; 는 이 모델의 이름을 기반으로 통신하는 URL을 결정하는 스마트 충분하다. 예를 들어 ID 별 &lt;code&gt;Post&lt;/code&gt; 을 요청하는 경우 :</target>
        </trans-unit>
        <trans-unit id="c950fbe2c97da63e2b034eaca1b0c609b4171279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is the default adapter used by Ember Data. It is responsible for transforming the store's requests into HTTP requests that follow the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API&lt;/a&gt; format.</source>
          <target state="translated">&lt;code&gt;JSONAPIAdapter&lt;/code&gt; 은 엠버 데이터가 사용하는 기본 어댑터입니다. 상점의 요청을 &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API&lt;/a&gt; 형식 을 따르는 HTTP 요청으로 변환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="34c3733779dc0df0421669354af118f5e875520e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; expects the backend to return a JSON API Document that follows the JSON API specification and the conventions of the examples found on &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format&lt;/a&gt;. This means all type names should be pluralized and attribute and relationship names should be dash-cased. For example, if you request a record from &lt;code&gt;/people/123&lt;/code&gt;, the response should look like this:</source>
          <target state="translated">&lt;code&gt;JSONAPISerializer&lt;/code&gt; 는 백엔드는 JSON의 API 사양 및에있는 예제의 규칙을 따르는 JSON API 문서 반환 할 것으로 예상 &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format을&lt;/a&gt; . 즉, 모든 유형 이름은 복수형이어야하고 속성 및 관계 이름은 대괄호로 묶어야합니다. 예를 들어, &lt;code&gt;/people/123&lt;/code&gt; 에서 레코드를 요청 하면 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a163a2de99844b44ded1af52c454ec8cb95bad1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; is built on top of the &lt;code&gt;JSONSerializer&lt;/code&gt; so they share many of the same hooks for customizing the behavior of the serialization process. Be sure to check out the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;API docs&lt;/a&gt; for a full list of methods and properties.</source>
          <target state="translated">&lt;code&gt;JSONAPISerializer&lt;/code&gt; 은 의 상단에 내장되어 &lt;code&gt;JSONSerializer&lt;/code&gt; 가 직렬화 프로세스의 동작을 사용자 정의에 대해 같은 후크의 많은 것을 공유 할 수 있도록. 메서드 및 속성의 전체 목록은 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;API 문서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2372e29f3591a6e06a86749f11f23bc152d06ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONSerializer&lt;/code&gt; normalization process follows these steps:</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 의 정상화 과정은 다음 단계에 따라 :</target>
        </trans-unit>
        <trans-unit id="b8d7134db8562c548ba83e1398f6d35393db9323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; will be rendered in place of the &lt;code&gt;{{yield}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; 의 위치에 렌더링됩니다 &lt;code&gt;{{yield}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="595ef6a646450a473c800b0f4386c1825ddf018a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ManyArray&lt;/code&gt; is instantiated lazily the first time the relationship is requested.</source>
          <target state="translated">&lt;code&gt;ManyArray&lt;/code&gt; 는 게으르게 관계가 요청 처음 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="0dfb03cf2957c12e3cd48a12a2a6c5c0716c3419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Router.map&lt;/code&gt; function allows you to define mappings from URLs to routes in your application. These mappings are defined within the supplied callback function using &lt;code&gt;this.route&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Router.map&lt;/code&gt; 의 기능을 사용하면 응용 프로그램의 루트에 URL의 매핑을 정의 할 수 있습니다. 이러한 매핑은 &lt;code&gt;this.route&lt;/code&gt; 를 사용하여 제공된 콜백 함수 내에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b94bcc514f833c5ef1923bb0c25457ea933534f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;action&lt;/code&gt; helper allows you to add event listeners to elements and call named functions. By default, the &lt;code&gt;action&lt;/code&gt; helper adds a &lt;code&gt;click&lt;/code&gt; event listener, but it can be used to listen for any element event. Now, when the &lt;code&gt;li&lt;/code&gt; element is clicked a &lt;code&gt;showPerson&lt;/code&gt; function will be called from the &lt;code&gt;actions&lt;/code&gt; object in the &lt;code&gt;people-list&lt;/code&gt; component. Think of this like calling &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; from our template.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; 도우미는 요소에 이벤트 리스너를 추가하고 이름이 지정된 함수를 호출 할 수 있습니다. 기본적으로 &lt;code&gt;action&lt;/code&gt; 헬퍼는 &lt;code&gt;click&lt;/code&gt; 이벤트 리스너를 추가 하지만 모든 요소 이벤트를 청취하는 데 사용할 수 있습니다. 이제 &lt;code&gt;li&lt;/code&gt; 요소를 클릭하면 &lt;code&gt;people-list&lt;/code&gt; 구성 요소 의 &lt;code&gt;actions&lt;/code&gt; 오브젝트에서 &lt;code&gt;showPerson&lt;/code&gt; 함수가 호출됩니다 . 템플릿에서 &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; 을 호출하는 것과 같이 이것을 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="6781996b5d8528d30fde9ec99ae34a524c6762c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; hash will inherit action handlers from the &lt;code&gt;actions&lt;/code&gt; hash defined on extended parent classes or mixins rather than just replace the entire hash, e.g.:</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 로부터 액션 핸들러 상속 해시 &lt;code&gt;actions&lt;/code&gt; 단지 전체 해시, 예를 대체하기보다는 확장 된 상위 클래스 나 유지 mixin에 정의 된 해시 :</target>
        </trans-unit>
        <trans-unit id="9f0188c56bfb8d604ed462187f6484e25c179952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; queue is the general work queue and will typically contain scheduled tasks e.g. promises.</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 큐는 일반 작업 큐이며, 일반적으로 작업 예를 들어, 약속 일정을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="41ff0eeabf56cfc059010cc4c18262f67f627814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterRender&lt;/code&gt; queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</source>
          <target state="translated">&lt;code&gt;afterRender&lt;/code&gt; 의 큐는 모든 이전 작업이 완료 렌더링 예약 후 의미 작업이 실행되도록이 포함되어 있습니다. 이것은 종종 DOM 전체 트리가 업데이트 된 후에 만 ​​실행되는 타사 DOM 조작 라이브러리에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="95d664e2d1d83fcd6e5b1affc99d006e5870087d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;andThen&lt;/code&gt; helper will wait for all preceding asynchronous helpers to complete prior to progressing forward. Let's take a look at the following example.</source>
          <target state="translated">&lt;code&gt;andThen&lt;/code&gt; 의 도우미 앞으로 진행하기 전에 완료하기 위해 모든 이전 비동기 헬퍼 기다립니다. 다음 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4d4a81e4ca7c1ec493df5706886873c52cf64207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application&lt;/code&gt; route is entered when your app first boots up. Like other routes, it will load a template with the same name (&lt;code&gt;application&lt;/code&gt; in this case) by default. You should put your header, footer, and any other decorative content here. All other routes will render their templates into the &lt;code&gt;application.hbs&lt;/code&gt; template's &lt;code&gt;{{outlet}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;application&lt;/code&gt; 경로는 경우 앱이 처음 부팅 입력됩니다. 다른 경로와 마찬가지로 기본적으로 동일한 이름 ( 이 경우 &lt;code&gt;application&lt;/code&gt; )으로 템플릿을로드합니다 . 머리글, 바닥 글 및 기타 장식적인 내용을 여기에 넣어야합니다. 다른 모든 경로는 템플릿을 &lt;code&gt;application.hbs&lt;/code&gt; 템플릿의 &lt;code&gt;{{outlet}}&lt;/code&gt; 에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="4a5ab553a8d271896a510ee5268f14190264cb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; object can be used to declare a simple mapping between property names on &lt;code&gt;DS.Model&lt;/code&gt; records and payload keys in the serialized JSON object representing the record. An object with the property &lt;code&gt;key&lt;/code&gt; can also be used to designate the attribute's key on the response payload.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 객체에 속성 이름과 간단한 매핑 선언 할 수 있습니다 &lt;code&gt;DS.Model&lt;/code&gt; 의 기록을 나타내는 직렬화 된 JSON 개체의 레코드와 페이로드 키를. 속성 &lt;code&gt;key&lt;/code&gt; 가 있는 객체를 사용하여 응답 페이로드 에서 속성 키를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc40241d339c1bb5c98150382b9bbb509e1494e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; option for a resource &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for:</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 자원에 대한 옵션 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 에 대한 속기입니다 :</target>
        </trans-unit>
        <trans-unit id="d11fb7ffee10a29dcba72e4be14a34886533a524" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; property can be set on the &lt;code&gt;ApplicationSerializer&lt;/code&gt; or a per-type serializer.</source>
          <target state="translated">&lt;code&gt;attrs&lt;/code&gt; 속성은 설정할 수 있습니다 &lt;code&gt;ApplicationSerializer&lt;/code&gt; 또는 당 형 시리얼.</target>
        </trans-unit>
        <trans-unit id="91ff220601d5dc8de2569eafda2d847e2de3da0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backgroundReload&lt;/code&gt; option is used to prevent the fetching of the destroyed record, since &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;findRecord()&lt;/code&gt;&lt;/a&gt; automatically schedules a fetch of the record from the adapter.</source>
          <target state="translated">&lt;code&gt;backgroundReload&lt;/code&gt; 의 옵션이 파괴 된 레코드의 인출을 방지하기 위해 사용되기 때문에 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;findRecord()&lt;/code&gt; &lt;/a&gt; 자동으로 일정은 어댑터에서 레코드의 가져 오기.</target>
        </trans-unit>
        <trans-unit id="a4f5e918a009088b91687277e637fe04016877fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;boolean&lt;/code&gt; transform can handle values other than &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The strings &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;t&quot;&lt;/code&gt; in any casing, &lt;code&gt;&quot;1&quot;&lt;/code&gt;, and the number &lt;code&gt;1&lt;/code&gt; will all coerce to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">는 &lt;code&gt;boolean&lt;/code&gt; 이외의 값 처리 할 수있는 변환 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;t&quot;&lt;/code&gt; 모든 케이스에서, &lt;code&gt;&quot;1&quot;&lt;/code&gt; , 및 숫자 &lt;code&gt;1&lt;/code&gt; 것이다 모든 강제 변환 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="71a103dc62034f2f7cae2908b76c1995a2fd8b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;build&lt;/code&gt; command packages up all of the assets that make up your application&amp;mdash;JavaScript, templates, CSS, web fonts, images, and more.</source>
          <target state="translated">&lt;code&gt;build&lt;/code&gt; 응용 프로그램 - 자바 스크립트, 템플릿, CSS, 웹 글꼴, 이미지 등을 구성하는 모든 자산까지 명령 패키지로 제공된다.</target>
        </trans-unit>
        <trans-unit id="84d78207fa37bb2b65a91e18bf5316cd6ed67a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute of an &lt;code&gt;Ember.Checkbox&lt;/code&gt; object should always be set through the Ember object or by interacting with its rendered element representation via the mouse, keyboard, or touch. Updating the value of the checkbox via jQuery will result in the checked value of the object and its element losing synchronization.</source>
          <target state="translated">&lt;code&gt;Ember.Checkbox&lt;/code&gt; 객체 의 &lt;code&gt;checked&lt;/code&gt; 속성 은 항상 Ember 객체를 통해 설정하거나 마우스, 키보드 또는 터치를 통해 렌더링 된 요소 표현과 상호 작용하여 설정해야합니다. jQuery를 통해 확인란의 값을 업데이트하면 객체와 해당 요소의 확인 된 값이 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="388167e41998946f805b5e706d65af0e5c7f26f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component&lt;/code&gt; helper can be used to package a component path with initial attrs. The included attrs can then be merged during the final invocation. For example, given a &lt;code&gt;person-form&lt;/code&gt; component with the following template:</source>
          <target state="translated">&lt;code&gt;component&lt;/code&gt; 도우미는 초기 attrs에있는 구성 요소 경로를 포장하는 데 사용할 수 있습니다. 그런 다음 포함 된 속성을 최종 호출 중에 병합 할 수 있습니다. 예를 들어 다음과 같은 템플릿을 사용 하는 &lt;code&gt;person-form&lt;/code&gt; 구성 요소가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c34fbc331365e1345b641ddb67e8318a5245aaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; argument allows you to optionally specify the &lt;code&gt;this&lt;/code&gt; with which your callback will be invoked.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 인수는 선택적으로 지정할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 콜백이 호출 될 함께합니다.</target>
        </trans-unit>
        <trans-unit id="89d688b3c007bc970797daf54bb128d1ea052cf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; on line #17 creates an &lt;em&gt;instance&lt;/em&gt; of the &lt;code&gt;Soldier&lt;/code&gt; class. The &lt;code&gt;extend()&lt;/code&gt; on line #8 creates a &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;Person&lt;/code&gt;. Any instance of the &lt;code&gt;Person&lt;/code&gt; class will &lt;em&gt;not&lt;/em&gt; have the &lt;code&gt;march()&lt;/code&gt; method.</source>
          <target state="translated">17 번 줄 의 &lt;code&gt;create()&lt;/code&gt; 는 &lt;code&gt;Soldier&lt;/code&gt; 클래스 의 &lt;em&gt;인스턴스&lt;/em&gt; 를 만듭니다 . # 8 행 의 &lt;code&gt;extend()&lt;/code&gt; 는 &lt;code&gt;Person&lt;/code&gt; 의 &lt;em&gt;서브 클래스&lt;/em&gt; 를 만듭니다 . &lt;code&gt;Person&lt;/code&gt; 클래스 의 모든 인스턴스 에는 &lt;code&gt;march()&lt;/code&gt; 메소드 가 &lt;em&gt;없습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c49797066693990d496ec9bb1f4d6f26783f06a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP POST) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createRecord&lt;/code&gt; 의 방법은 기록을 직렬화에 의해 계산 된 URL에 아약스 (HTTP POST) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f9a93643d5938fe543825d7c0628e35429505c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date&lt;/code&gt; transform will transform an &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; string to a JavaScript date object.</source>
          <target state="translated">&lt;code&gt;date&lt;/code&gt; 변환됩니다 변환 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; 자바 스크립트 날짜 개체에 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e80e5ce5365720cc0f4de3729b802465bc83fe09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultSerializer&lt;/code&gt; property can be used to specify the serializer that will be used by this adapter. This is only used when a model specific serializer or &lt;code&gt;serializer:application&lt;/code&gt; are not defined.</source>
          <target state="translated">&lt;code&gt;defaultSerializer&lt;/code&gt; 의 속성은이 어댑터가 사용되는 시리얼을 지정하는 데 사용할 수 있습니다. 모델 고유의 serializer 또는 &lt;code&gt;serializer:application&lt;/code&gt; 이 정의되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47279489597e5ac74e3e86c13c5db07112deff0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deleteRecord&lt;/code&gt; method makes an Ajax (HTTP DELETE) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;deleteRecord&lt;/code&gt; 의 방법은 아약스에 의해 계산 된 URL에 (HTTP DELETE) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c30f86ae15c9c161bf558adf4801995e475ede16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destroy&lt;/code&gt; queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</source>
          <target state="translated">는 &lt;code&gt;destroy&lt;/code&gt; 큐 다른 작업이 파괴 예약 한 개체의 분해를 완료하는 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec8ac796a650bf4f17575a944af8c803f7569ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didRender&lt;/code&gt; hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after it's been updated.</source>
          <target state="translated">&lt;code&gt;didRender&lt;/code&gt; 의 후크는 동안이라고 모두 렌더링 템플릿을 렌더링하고, DOM을 업데이트 한 후 다시 렌더링합니다. 이 후크를 사용하여 업데이트 된 구성 요소의 DOM에서 사후 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ea898b33c2a437dd96438a1f46ae35d27a088e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didTransition&lt;/code&gt; action is fired after a transition has successfully been completed. This occurs after the normal model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;afterModel&lt;/code&gt;, &lt;code&gt;setupController&lt;/code&gt;) have resolved. The &lt;code&gt;didTransition&lt;/code&gt; action has no arguments, however, it can be useful for tracking page views or resetting state on the controller.</source>
          <target state="translated">&lt;code&gt;didTransition&lt;/code&gt; 의 전환이 성공적으로 완료 한 후 작업이 시작됩니다. 이는 일반적인 모델 후크 ( &lt;code&gt;beforeModel&lt;/code&gt; , &lt;code&gt;model&lt;/code&gt; , &lt;code&gt;afterModel&lt;/code&gt; , &lt;code&gt;setupController&lt;/code&gt; )가 해결 된 후에 발생합니다 . &lt;code&gt;didTransition&lt;/code&gt; 에 작용하지만, 그 컨트롤러의 상태를 페이지 뷰를 추적 또는 재설정에 유용 할 수있는 인자가 없다.</target>
        </trans-unit>
        <trans-unit id="d29eb3566c4cfb0d03f10d6c75bd7952980a0abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; event</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 이벤트</target>
        </trans-unit>
        <trans-unit id="3dc3d2be3a232d5f74fd199e8ed0506d40b409b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; property us useful for displaying error messages to the user.</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 속성을 사용자에게 오류 메시지를 표시하는 우리에게 유용하다.</target>
        </trans-unit>
        <trans-unit id="115d726ddd808f785aca1eceaa420a26f06ecae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; function is passed in by the calling object. This is a pattern known as &lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;closure actions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 함수는 호출 객체에 의해 전달된다. 이것은 &lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;클로저 액션으로&lt;/a&gt; 알려진 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="387361e1d1ae1eef1a52fa056d048c8cd9b110ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll()&lt;/code&gt; method is used to retrieve all records for a given type.</source>
          <target state="translated">&lt;code&gt;findAll()&lt;/code&gt; 메소드는 주어진 유형에 대한 모든 기록을 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="602c663ac51ac56be167a8f4fb8f2bd27b6e2b2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findAll&lt;/code&gt; 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce7f071cf50d33d185134e7eba5ac98888f204a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findBelongsTo&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">&lt;code&gt;findBelongsTo&lt;/code&gt; 의 방법은 원래 지정된 URL에 아약스 (HTTP GET) 요청을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f44dcd4f85b2dd0552451d53e497afcda8a7a1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findHasMany&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">&lt;code&gt;findHasMany&lt;/code&gt; 의 방법은 원래 지정된 URL에 아약스 (HTTP GET) 요청을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae10eeaf2c63ca125251ac98e9be799c680141ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findMany&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findMany&lt;/code&gt; 의 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a08ab933ff65b656dd2d84e9309be457ddf1cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord()&lt;/code&gt; method is invoked when the store is asked for a record that has not previously been loaded. In response to &lt;code&gt;findRecord()&lt;/code&gt; being called, you should query your persistence layer for a record with the given ID. The &lt;code&gt;findRecord&lt;/code&gt; method should return a promise that will resolve to a JavaScript object that will be normalized by the serializer.</source>
          <target state="translated">&lt;code&gt;findRecord()&lt;/code&gt; 저장소가 이전에로드되지 않은 레코드에 대한 요구 될 때 메서드가 호출됩니다. 에 대한 응답으로 &lt;code&gt;findRecord()&lt;/code&gt; 는 지정된 ID를 가진 레코드에 대한 당신의 영속 계층을 쿼리해야 호출되고. &lt;code&gt;findRecord&lt;/code&gt; 의 방법은 시리얼 라이저에 의해 정규화됩니다 자바 스크립트 객체에 해결할 약속을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a203cdf205b6bed873c25d04719c09b1c068376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method makes an Ajax request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법에 의해 계산 된 URL에 Ajax 요청하게 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d296cef402c6e9fdee3e60b6eab8186006e33659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always resolve its promise with the same object for a given type and &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법은 항상 지정된 형태와의 동일한 개체와의 약속 해결할 &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8946fd1a72779985021b67a58d0554338af6fd98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always return a &lt;strong&gt;promise&lt;/strong&gt; that will be resolved with the record.</source>
          <target state="translated">&lt;code&gt;findRecord&lt;/code&gt; 의 방법은 항상 반환 &lt;strong&gt;약속&lt;/strong&gt; 기록으로 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="70a1277075e83917b1e91129c777128de706c278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; properties are read from the context (the application controller in this case), and rendered inside the &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML tag.</source>
          <target state="translated">&lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 이라는 속성 컨텍스트 (이 경우, 프로그램 제어기)로부터 판독하고, 내부 렌더링 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML 태그.</target>
        </trans-unit>
        <trans-unit id="e2cd1e74db759e699d89efeb874150a69a9ce052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;generateIdForRecord()&lt;/code&gt; method will be invoked with the requesting store as the first parameter and the newly created record as the second parameter:</source>
          <target state="translated">&lt;code&gt;generateIdForRecord()&lt;/code&gt; 메소드는 첫번째 파라미터로서 요청 저장소 및 상기 제 파라미터로서 새롭게 생성 된 레코드를 호출한다 :</target>
        </trans-unit>
        <trans-unit id="9d6dcd303e28c2f50e7fa209f969128e6c261668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash&lt;/code&gt; option uses the URL's anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a &lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;hashchange&lt;/a&gt; event existing in the browser.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 옵션은 응용 프로그램의 시작 상태를로드 할 URL의 앵커를 사용하고 당신이 주변에 이동 동기화를 유지합니다. 현재 이것은 브라우저에 존재 하는 &lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;해시 변경&lt;/a&gt; 이벤트 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="efb3ddd1dd864b1ccd297455ce4d0857982f5192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; attributes will be used if defined, and are optional.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 와 &lt;code&gt;namespace&lt;/code&gt; 속성이 정의 된 경우 사용하고, 선택적됩니다.</target>
        </trans-unit>
        <trans-unit id="726d76cd26c3550c4a16d511675ea50195fe236a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to.</source>
          <target state="translated">이 참조가 참조하는 레코드 의 &lt;code&gt;id&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e484f981133bd6e9e051ecd67de8179c1ab49e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to. Together, the &lt;code&gt;type()&lt;/code&gt; and &lt;code&gt;id()&lt;/code&gt; methods form a composite key for the identity map. This can be used to access the id of an async relationship without triggering a fetch that would normally happen if you attempted to use &lt;code&gt;record.get('relationship.id')&lt;/code&gt;.</source>
          <target state="translated">이 참조가 참조하는 레코드 의 &lt;code&gt;id&lt;/code&gt; 입니다. 이와 함께 &lt;code&gt;type()&lt;/code&gt; 와 &lt;code&gt;id()&lt;/code&gt; 메소드는 아이덴티티 맵 복합 키를 형성한다. 이것은 &lt;code&gt;record.get('relationship.id')&lt;/code&gt; 을 사용하려고 시도 할 때 일반적으로 발생하는 페치를 트리거하지 않고 비동기 관계의 ID에 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b8ddb4404d56063acf9b99af25e8cc6e7326302" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; helper allows you to conditionally render one of two branches, depending on the &quot;truthiness&quot; of a property. For example the following values are all falsey: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; or an empty array.</source>
          <target state="translated">는 &lt;code&gt;if&lt;/code&gt; 도우미는 조건부 속성의 &quot;truthiness&quot;에 따라 두 가지 중 하나를 렌더링 할 수 있습니다. 예를 들어, &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;&quot;&quot;&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 또는 빈 배열 값은 모두 false 입니다.</target>
        </trans-unit>
        <trans-unit id="7f533c5c4a9490cabd083312090b309dba8b8080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; route, which we've set up to redirect to the &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 우리가 설정 한 경로는 리디렉션하는 &lt;code&gt;rentals&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="a37a3988ddfb70864ed4f197d72873cd75421874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; template will be rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; in the &lt;code&gt;application&lt;/code&gt; template. If the user navigates to &lt;code&gt;/favorites&lt;/code&gt;, Ember will replace the &lt;code&gt;index&lt;/code&gt; template with the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 템플릿은로 표현 될 것이다 &lt;code&gt;{{outlet}}&lt;/code&gt; 에서 &lt;code&gt;application&lt;/code&gt; 템플릿. 사용자가 &lt;code&gt;/favorites&lt;/code&gt; 로 이동하면 Ember는 &lt;code&gt;index&lt;/code&gt; 템플릿을 &lt;code&gt;favorites&lt;/code&gt; 템플릿으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="894fed72e604e69d2c832ed37e77607f8aedfc96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isDone&lt;/code&gt; property of any of the objects in the &lt;code&gt;todos&lt;/code&gt; array changes.</source>
          <target state="translated">&lt;code&gt;todos&lt;/code&gt; 배열 에있는 모든 오브젝트 의 &lt;code&gt;isDone&lt;/code&gt; 특성이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="2e33c9e0c11bc81e1d1a61b55510989fd637ce87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key-up&lt;/code&gt; property will be bound to the &lt;code&gt;handleFilterEntry&lt;/code&gt; action.</source>
          <target state="translated">&lt;code&gt;key-up&lt;/code&gt; 속성은 바인딩됩니다 &lt;code&gt;handleFilterEntry&lt;/code&gt; 의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="936bd94b4aebf6a1e14654f35827f1ee229e7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; option is used to tell Ember how to determine if the array being iterated over with &lt;code&gt;{{#each}}&lt;/code&gt; has changed between renders. By helping Ember detect that some elements in the array are the same, DOM elements can be re-used, significantly improving rendering speed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 옵션이 배열의 존재가로 반복 처리 여부를 결정하는 방법 엠버에게 사용되는 &lt;code&gt;{{#each}}&lt;/code&gt; 이 렌더링 사이에 변경되었습니다. 배열의 일부 요소가 동일하다는 것을 Ember가 감지하면 DOM 요소를 재사용하여 렌더링 속도를 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f5fca5b000aac4891ae81f3df31b8436f67cee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper supports specifying query params using the &lt;code&gt;query-params&lt;/code&gt; subexpression helper.</source>
          <target state="translated">&lt;code&gt;link-to&lt;/code&gt; 사용하여 검색어 매개 변수 지정 도우미 지원 &lt;code&gt;query-params&lt;/code&gt; 표현식 도우미를.</target>
        </trans-unit>
        <trans-unit id="1769aac2882e47d76fb4a9a01749791965335a0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper takes into account query parameters when determining its &quot;active&quot; state, and will set the class appropriately. The active state is determined by calculating whether the query params end up the same after clicking a link. You don't have to supply all of the current, active query params for this to be true.</source>
          <target state="translated">&lt;code&gt;link-to&lt;/code&gt; 도우미는 &quot;활성&quot;상태를 결정할 때 계정 쿼리 매개 변수로 받아, 적절한 클래스를 설정합니다. 활성 상태는 링크를 클릭 한 후 쿼리 매개 변수가 동일한 지 여부를 계산하여 결정됩니다. 이것이 사실이기 위해 현재 활성화 된 쿼리 매개 변수를 모두 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce7461f1dc052dfdd78139e56ef3705e2ee872bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;live-updating-chart&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the &lt;code&gt;market-close-summary&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. If the value changes while the app is running, the component will be automatically swapped out accordingly. Note: You should not use this helper when you are consistently rendering the same component. In that case, use standard component syntax, for example:</source>
          <target state="translated">&lt;code&gt;live-updating-chart&lt;/code&gt; 경우 구성 요소가 추가됩니다 &lt;code&gt;isMarketOpen&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 그리고 &lt;code&gt;market-close-summary&lt;/code&gt; 하면 구성 요소가 추가됩니다 &lt;code&gt;isMarketOpen&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; . 앱이 실행되는 동안 값이 변경되면 그에 따라 구성 요소가 자동으로 교체됩니다. 참고 : 동일한 구성 요소를 일관되게 렌더링 할 때는이 도우미를 사용하지 마십시오. 이 경우 표준 구성 요소 구문을 사용하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="d5bb787fdea75d1b00a27bb3674ec987c8aaa6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; action is fired on the route when a route's &lt;code&gt;model&lt;/code&gt; hook returns a promise that is not already resolved. The current &lt;code&gt;Transition&lt;/code&gt; object is the first parameter and the route that triggered the loading event is the second parameter.</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; 경로의 경우 동작이 노선에 발사되는 &lt;code&gt;model&lt;/code&gt; 후크가 이미 해결되지 약속을 반환합니다. 현재 &lt;code&gt;Transition&lt;/code&gt; 객체는 첫 번째 매개 변수이고 loading 이벤트를 트리거 한 경로는 두 번째 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="62709da4cb7722dd75455fa1b4a1e73beda37c01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; event</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; 이벤트</target>
        </trans-unit>
        <trans-unit id="51f4b8a7cab225c00b8bad7fe9f237a843ec218c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;location&lt;/code&gt; property determines the type of URL's that your application will use.</source>
          <target state="translated">&lt;code&gt;location&lt;/code&gt; 속성은 URL의 형식이 응용 프로그램이 사용하는 것입니다 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9eb2d558c702885a649840fb36c05bc2fa210e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 또는 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 와 함께 사용되는 입력 요소 의 &lt;code&gt;max&lt;/code&gt; 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="761d8a8dfab983312074a19ca9afd183bd59ab2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 또는 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 와 함께 사용되는 입력 요소 의 &lt;code&gt;min&lt;/code&gt; 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="6a16647d6821ede1b677029aeacce468053baa77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;beforeModel&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks described in &lt;a href=&quot;../asynchronous-routing&quot;&gt;Asynchronous Routing&lt;/a&gt; each get called with a transition object. This makes it possible for destination routes to abort attempted transitions.</source>
          <target state="translated">&lt;code&gt;model&lt;/code&gt; , &lt;code&gt;beforeModel&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; 의 후크에 기재된 &lt;a href=&quot;../asynchronous-routing&quot;&gt;비동기 라우팅&lt;/a&gt; 전이 객체 호출을 각각 GET. 따라서 대상 경로에서 시도한 전환을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a07d77d0d198d3536ee44ea45215a0d56f6c718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moduleForComponent&lt;/code&gt; helper will find the component by name (&lt;code&gt;pretty-color&lt;/code&gt;) and its template (if available). Make sure to set &lt;code&gt;integration: true&lt;/code&gt; to enable integration test capability.</source>
          <target state="translated">&lt;code&gt;moduleForComponent&lt;/code&gt; 의 도우미 이름 (기준 구성 요소 찾을 수 &lt;code&gt;pretty-color&lt;/code&gt; )과 템플릿 (사용 가능한 경우). 통합 테스트 기능을 사용하려면 &lt;code&gt;integration: true&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="644ef1f7a187d6716007454db3fc278899d36342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper changes the &lt;code&gt;totalClicks&lt;/code&gt; value to what was provided as the action argument.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 도우미는 변경 &lt;code&gt;totalClicks&lt;/code&gt; 의 액션 인수로 제공 한 것과 값입니다.</target>
        </trans-unit>
        <trans-unit id="edbf9526f6f8f8b4f51d74862e43afb24dca9baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper lets you &lt;strong&gt;clearly specify&lt;/strong&gt; that a child &lt;code&gt;Component&lt;/code&gt; can update the (mutable) value passed to it, which will &lt;strong&gt;change the value of the parent component&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 도우미는 할 수 &lt;strong&gt;명확하게 지정&lt;/strong&gt; 아이 것을 &lt;code&gt;Component&lt;/code&gt; 됩니다 전달 된 (변경 가능) 값을 업데이트 할 수 있습니다 &lt;strong&gt;부모 요소의 값을 변경을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="47f4565230c7ebd7ee1ea8d2cea1cd329802f14d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper, when used with &lt;code&gt;action&lt;/code&gt;, will return a function that sets the value passed to &lt;code&gt;mut&lt;/code&gt; to its first argument. This works like any other closure action and interacts with the other features &lt;code&gt;action&lt;/code&gt; provides. As an example, we can create a button that increments a value passing the value directly to the &lt;code&gt;action&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 헬퍼 함께 사용했을 때 &lt;code&gt;action&lt;/code&gt; 값이 전달 세트 해당 함수 리턴 &lt;code&gt;mut&lt;/code&gt; 첫번째 인수한다. 이것은 다른 폐쇄 작업과 마찬가지로 작동하며 &lt;code&gt;action&lt;/code&gt; 제공 하는 다른 기능과 상호 작용 합니다. 예를 들어, 값을 직접 &lt;code&gt;action&lt;/code&gt; 전달하는 값을 증가시키는 버튼을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e89da7babb87da3e213ca546f7a89e9c5ec5c0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace&lt;/code&gt; property can be used to prefix requests with a specific url namespace.</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 속성은 특정의 URL 네임 스페이스와 요청을 접두사로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfed5d466aa02a365425fe10dfe05ec1cbdf595d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; command generates a project structure with the following files and directories:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 명령은 다음 파일과 디렉토리와 프로젝트 구조를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="ed24ef77b982f52329f6db5f8b171af6032be5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newValue&lt;/code&gt; parameter thus becomes the &lt;code&gt;target.value&lt;/code&gt; property of the event object, which is the value of the input field the user typed. (e.g 'Foo Fighters')</source>
          <target state="translated">따라서 &lt;code&gt;newValue&lt;/code&gt; 매개 변수 는 이벤트 오브젝트 의 &lt;code&gt;target.value&lt;/code&gt; 특성이되며 이는 사용자가 입력 한 입력 필드의 값입니다. (예 : '푸 파이터')</target>
        </trans-unit>
        <trans-unit id="3b9f3dead33374ca86a671206cb69b9ea69de17d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method is used to convert a payload received from your external data source into the normalized form &lt;code&gt;store.push()&lt;/code&gt; expects. You should override this method, munge the hash and return the normalized payload.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법은 정규화 된 형태로 외부 데이터 소스로부터 수신되는 페이로드를 변환하는 데 사용된다 &lt;code&gt;store.push()&lt;/code&gt; 기대한다. 이 방법을 재정의하고 해시를 제거하고 정규화 된 페이로드를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="20e85f3eb6d6503ba01eeae172d760d7f90937b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method will be called three times:</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법은 세 번 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="1d0fd3bcdefae28cf2e583c51b6f6f637f4b37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalizeResponse&lt;/code&gt; method is used to normalize a payload from the server to a JSON-API Document.</source>
          <target state="translated">&lt;code&gt;normalizeResponse&lt;/code&gt; 의 방법은 JSON-API 문서를 서버로부터 페이로드를 정규화하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="0c2db818043d2ecfecb9f10542f615aa9bab50e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;observes&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">는 &lt;code&gt;observes&lt;/code&gt; 할 때 자바 스크립트의 기능 프로토 타입의 확장을 사용할 수 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 기본값 인 true.</target>
        </trans-unit>
        <trans-unit id="0f03013d375dee1ad0017ee24be6c12bc6613607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;on&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 때 자바 스크립트의 기능 프로토 타입의 확장이 가능 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 기본값 인 true.</target>
        </trans-unit>
        <trans-unit id="297b35be5fa3a29b2bfdd9b1aca553208fd9387a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash is passed as second argument to a transforms' &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; method. This allows to configure a transformation and adapt the corresponding value, based on the config:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시는 변환 '두 번째 인수로서 건네 &lt;code&gt;serialize&lt;/code&gt; 및 &lt;code&gt;deserialize&lt;/code&gt; 방법. 이를 통해 구성을 기반으로 변환을 구성하고 해당 값을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48eca6e5279e14ea0ca6e2582655554ba9b2b05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partial&lt;/code&gt; helper renders another template without changing the template context:</source>
          <target state="translated">&lt;code&gt;partial&lt;/code&gt; 헬퍼 템플릿 컨텍스트를 변경하지 않고 다른 템플릿을 렌더링 :</target>
        </trans-unit>
        <trans-unit id="9dab6744a08664ce82b1d25a8cd8dabeafdb4d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; attribute of input element.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;pattern&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="beed0cd468b2c43cc334c3ee15857caebfa7e869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;person&lt;/code&gt; model we generated earlier didn't have any attributes. Let's add first and last name, as well as the birthday, using &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt;&lt;code&gt;DS.attr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 우리가 이전에 생성 된 모델은 어떤 속성을 가지고 있지 않았다. &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt; &lt;code&gt;DS.attr&lt;/code&gt; 을&lt;/a&gt; 사용하여 생일뿐만 아니라 이름과 성을 추가합시다 .</target>
        </trans-unit>
        <trans-unit id="c726fa5adf1c99c0bbb0555060826f16888f5c7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;primaryKey&lt;/code&gt; is used when serializing and deserializing data. Ember Data always uses the &lt;code&gt;id&lt;/code&gt; property to store the id of the record. The external source may not always follow this convention. In these cases it is useful to override the &lt;code&gt;primaryKey&lt;/code&gt; property to match the &lt;code&gt;primaryKey&lt;/code&gt; of your external store.</source>
          <target state="translated">&lt;code&gt;primaryKey&lt;/code&gt; 직렬화 및 역 직렬화 된 데이터를 할 때 사용된다. Ember Data는 항상 &lt;code&gt;id&lt;/code&gt; 속성을 사용 하여 레코드의 id를 저장합니다. 외부 소스가이 규칙을 항상 따르는 것은 아닙니다. 이 경우 무시하는 데 유용합니다 &lt;code&gt;primaryKey&lt;/code&gt; 일치하는 특성 &lt;code&gt;primaryKey&lt;/code&gt; 외부 저장소의를.</target>
        </trans-unit>
        <trans-unit id="1ddda9eaba646249c47555954c9e00b3441e3959" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;property&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; 때 자바 스크립트의 기능 프로토 타입의 확장이 가능 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; 기본이다.</target>
        </trans-unit>
        <trans-unit id="741ea22ea557846205bbcb6432415861ed43b265" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push()&lt;/code&gt; method is also important when working with complex endpoints. You may find your application has an endpoint that performs some business logic then creates several records. This likely does not map cleanly to Ember Data's existing &lt;code&gt;save()&lt;/code&gt; API which is structured around persisting a single record. Instead you should make your own custom AJAX request and push the resulting model data into the store so it can be accessed by other parts of your application.</source>
          <target state="translated">&lt;code&gt;push()&lt;/code&gt; 복합 엔드 포인트로 작업 할 때 방법도 중요하다. 애플리케이션에 일부 비즈니스 로직을 수행 한 다음 여러 레코드를 작성하는 엔드 포인트가있을 수 있습니다. 이것은 단일 레코드를 유지하도록 구성된 Ember Data의 기존 &lt;code&gt;save()&lt;/code&gt; API에 명확하게 매핑되지 않을 수 있습니다 . 대신 사용자 정의 AJAX 요청을 작성하고 결과 모델 데이터를 상점으로 푸시하여 애플리케이션의 다른 부분에서 액세스 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="aba7f7dcf3bc1a43f03c260d10824580744e938c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query()&lt;/code&gt; and &lt;code&gt;queryRecord()&lt;/code&gt; methods each take a &lt;code&gt;query&lt;/code&gt; argument that is serialized directly into the URL query string and the &lt;code&gt;include&lt;/code&gt; parameter may form part of that argument. For example:</source>
          <target state="translated">&lt;code&gt;query()&lt;/code&gt; 및 &lt;code&gt;queryRecord()&lt;/code&gt; 방법을 각각 가지고 &lt;code&gt;query&lt;/code&gt; 의 URL 쿼리 문자열에 직접 직렬화와입니다 인수 &lt;code&gt;include&lt;/code&gt; 매개 변수가 인수의 일부를 형성 할 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ae82990914385fed7743c850d721020c13355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query-params&lt;/code&gt; helper can be used to set query params on a link:</source>
          <target state="translated">&lt;code&gt;query-params&lt;/code&gt; 도우미는 링크를 설정 검색어 매개 변수에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a8fe29792accf52f26efa3e35355502b262e7a69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; argument is a simple JavaScript object that will be passed directly to the server as parameters.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 인수는 매개 변수로 서버에 직접 전달하는 간단한 자바 스크립트 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3bceeb7be0a9c6e0f887c2b26aab4a16695618f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac86f04028c107b848f45d261d4b4fb39028dabb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord()&lt;/code&gt; method is invoked when the store is asked for a single record through a query object.</source>
          <target state="translated">&lt;code&gt;queryRecord()&lt;/code&gt; 저장소가 쿼리 개체를 통해 단일 레코드를 요청하는 경우 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5f566f5912a6205cfc53d29bb1ff422d225d2210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">&lt;code&gt;queryRecord&lt;/code&gt; 의 방법에 의해 계산 된 URL에 아약스 (HTTP GET) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 , 그 결과 페이로드에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4ea793c0781cfc5c0cec6bad75f521580c0c469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; queue contains jobs meant for rendering, these will typically update the DOM.</source>
          <target state="translated">은 &lt;code&gt;render&lt;/code&gt; 대기열이 일반적으로 DOM을 업데이트합니다 렌더링에 대한 의미 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f84a235783d75983b71d54f1ff2d957db34aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rental_id&lt;/code&gt; will now be passed to the route.</source>
          <target state="translated">&lt;code&gt;rental_id&lt;/code&gt; 은 이제 경로로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2ab02947d511f36cd80dcd1ce1d3df5d48a3288d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootElement&lt;/code&gt; can be either a DOM element or a jQuery-compatible selector string. Note that &lt;em&gt;views appended to the DOM outside the root element will not receive events.&lt;/em&gt; If you specify a custom root element, make sure you only append views inside it!</source>
          <target state="translated">&lt;code&gt;rootElement&lt;/code&gt; 는 DOM 요소 또는 jQuery를 호환 선택 문자열이 될 수 있습니다. 참고 &lt;em&gt;보기가 이벤트를받을 수 없습니다 루트 요소 외부의 DOM에 추가. &lt;/em&gt;사용자 지정 루트 요소를 지정하면 그 안에보기 만 추가해야합니다!</target>
        </trans-unit>
        <trans-unit id="6cb53ef77e44dde0ccc9cdeab769f0e6ab2e0202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routerTransitions&lt;/code&gt; queue contains transition jobs in the router.</source>
          <target state="translated">&lt;code&gt;routerTransitions&lt;/code&gt; 의 큐는 라우터의 전환 작업을 포함한다.</target>
        </trans-unit>
        <trans-unit id="914db6574906c68800e0d33d2e398128993fa468" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; action handler would be called with a single argument containing the post model:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 액션 핸들러는 포스트 모델을 포함하는 단일 인수로 호출 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="df2eb6d01d9ec8f4cdf6e2424d4b714982ede9b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sender&lt;/code&gt; is the object that changed. The &lt;code&gt;key&lt;/code&gt; is the property that changes. The &lt;code&gt;value&lt;/code&gt; property is currently reserved and unused. The &lt;code&gt;rev&lt;/code&gt; is the last property revision of the object when it changed, which you can use to detect if the key value has really changed or not.</source>
          <target state="translated">&lt;code&gt;sender&lt;/code&gt; 변경된 것을 목적으로한다. &lt;code&gt;key&lt;/code&gt; 변경하는 속성입니다. &lt;code&gt;value&lt;/code&gt; 속성은 현재 예약 및 사용되지 않습니다. &lt;code&gt;rev&lt;/code&gt; 당신이 키 값이 정말 변경하거나하지 않은 경우 감지하는 데 사용할 수있는가 변경 객체의 마지막 속성 수정합니다.</target>
        </trans-unit>
        <trans-unit id="320d415a375ebee02086a1803913992fa35a52e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; keys support 3 values:</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 및 &lt;code&gt;deserialize&lt;/code&gt; 키는 3 개 값을 지원 :</target>
        </trans-unit>
        <trans-unit id="6f25c439a903f72adbb9b751611fc24318fc0bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; method is used when a record is saved in order to convert the record into the form that your external data source expects.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 레코드가 외부 데이터 소스가 예상하는 형태로 기록을 변환하기 위해 저장 될 때 방법이 사용된다.</target>
        </trans-unit>
        <trans-unit id="ca79fc713fd97bd184a81e559e72c3c10e563ff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function should accept two parameters, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The value returned from &lt;code&gt;set&lt;/code&gt; will be the new value of the property.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 함수는 두 개의 매개 변수를 받아 들여야 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; . &lt;code&gt;set&lt;/code&gt; 에서 반환 된 값은 속성의 새로운 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b783248728ef736c417d1b8a02ac7a76ba4c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setProps&lt;/code&gt; action directly sets one property, and calls the method to set the other. In our generated test, ember-cli already uses the &lt;code&gt;moduleFor&lt;/code&gt; helper to set up a test container:</source>
          <target state="translated">&lt;code&gt;setProps&lt;/code&gt; 의 작업은 직접 하나 개의 속성을 설정하고, 다른 설정하는 메소드를 호출합니다. 생성 된 테스트에서 ember-cli는 이미 &lt;code&gt;moduleFor&lt;/code&gt; 도우미를 사용하여 테스트 컨테이너를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a7a5bc8047dfc31a806acf70a107363435688016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signUp&lt;/code&gt; action is simply a function defined on the &lt;code&gt;actions&lt;/code&gt; hash of a component. Since the action is assigned to an inline handler, the function definition can define the event object as its first parameter.</source>
          <target state="translated">&lt;code&gt;signUp&lt;/code&gt; 작업은 단순히에 정의 된 함수 &lt;code&gt;actions&lt;/code&gt; 구성 요소의 해시. 조치가 인라인 핸들러에 지정되므로 함수 정의는 이벤트 오브젝트를 첫 번째 매개 변수로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905ce447cd074e63c0b217b907cdbd799228dbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; of the text field in characters.</source>
          <target state="translated">텍스트 필드 의 &lt;code&gt;size&lt;/code&gt; 문자)입니다.</target>
        </trans-unit>
        <trans-unit id="60ce209fb9d274970aad161ade621ac9ba4ac11c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; property is the application's &lt;code&gt;store&lt;/code&gt; that contains all records. It can be used to look up serializers for other model types that may be nested inside the payload response.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 속성은 응용 프로그램입니다 &lt;code&gt;store&lt;/code&gt; 모든 레코드를 포함합니다. 페이로드 응답 내에 중첩 될 수있는 다른 모델 유형의 직렬 변환기를 찾는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296139528fe79390dc0a604c903db62d7f189968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sync&lt;/code&gt; queue contains binding synchronization jobs.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; 큐 동기화 작업을 포함 바인딩.</target>
        </trans-unit>
        <trans-unit id="3ff37492a4d1b522cbb2957ffd8cce10aa8ee652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;todos&lt;/code&gt; property of the component is changed to a different array.</source>
          <target state="translated">구성 요소 의 &lt;code&gt;todos&lt;/code&gt; 특성이 다른 배열로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="131b771f6ba43c138d365e36164154f5cb2e8c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; attribute of the input element.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;type&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4c5bc75c3e6f8899fec6ea16cb876d5a2fdd47fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unbound&lt;/code&gt; helper only accepts a single argument, and it return an unbound value.</source>
          <target state="translated">&lt;code&gt;unbound&lt;/code&gt; 도우미는 하나의 인수를 받아, 그것은 언 바운드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efdf958209e8428c763eee6028027f027891e782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;updateRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP PUT) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updateRecord&lt;/code&gt; 의 방법은 기록을 직렬화에 의해 계산 된 URL에 아약스 (HTTP PUT) 요청합니다 &lt;code&gt;buildURL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1b6470eade078efa5a7597b68a9c894e7656a268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute of the input element. As the user inputs text, this property is updated live.</source>
          <target state="translated">입력 요소 의 &lt;code&gt;value&lt;/code&gt; 속성 사용자가 텍스트를 입력하면이 속성이 실시간으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="89d5c88cd2756f1f000db7d6ac6178bf03b70a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait&lt;/code&gt; helper is built into &lt;code&gt;registerAsyncHelper&lt;/code&gt; by default. You will not need to &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; - the wait behavior is provided for you.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 도우미에 내장되어 &lt;code&gt;registerAsyncHelper&lt;/code&gt; 기본적으로. &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; 을 반환 할 필요는 없습니다 . -대기 동작이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2a3d56e189d128908470bf74976b11ba03b8229c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;willTransition&lt;/code&gt; action is fired at the beginning of any attempted transition with a &lt;code&gt;Transition&lt;/code&gt; object as the sole argument. This action can be used for aborting, redirecting, or decorating the transition from the currently active routes.</source>
          <target state="translated">&lt;code&gt;willTransition&lt;/code&gt; 의 행동은 어떤 시도 전환의 시작 부분에 발사되는 &lt;code&gt;Transition&lt;/code&gt; 유일한 인수로 객체입니다. 이 동작은 현재 활성화 된 경로에서 전환을 중단, 리디렉션 또는 장식하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816958a0f032f49a594b1d8da2c79bf4235daf44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each}}&lt;/code&gt; helper loops over elements in a collection. It is an extension of the base Handlebars &lt;code&gt;{{#each}}&lt;/code&gt; helper. The default behavior of &lt;code&gt;{{#each}}&lt;/code&gt; is to yield its inner block once for every item in an array passing the item as the first block parameter.</source>
          <target state="translated">는 &lt;code&gt;{{#each}}&lt;/code&gt; 이 도우미는 컬렉션의 요소를 반복합니다. 기본 핸들 바 &lt;code&gt;{{#each}}&lt;/code&gt; 헬퍼 의 확장입니다 . &lt;code&gt;{{#each}}&lt;/code&gt; 의 기본 동작은 첫 번째 블록 매개 변수로 항목을 전달하는 배열의 모든 항목에 대해 내부 블록을 한 번 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c79d6054773867f3779b96924372f54a35225401" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{action}}&lt;/code&gt; helper provides a way to pass triggers for behavior (usually just a function) between components, and into components from controllers.</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 도우미 구성 요소 간의 동작에 대한 트리거 (대개 함수)를 통과하고, 컨트롤러의 구성 요소로 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2188ae955717f0311ee55bfeb274d37ec4fab50a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{component}}&lt;/code&gt; helper lets you add instances of &lt;code&gt;Ember.Component&lt;/code&gt; to a template. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt; for additional information on how a &lt;code&gt;Component&lt;/code&gt; functions. &lt;code&gt;{{component}}&lt;/code&gt;'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</source>
          <target state="translated">&lt;code&gt;{{component}}&lt;/code&gt; 도우미는 인스턴스에 추가 할 수 있습니다 &lt;code&gt;Ember.Component&lt;/code&gt; 을 템플릿으로. &lt;code&gt;Component&lt;/code&gt; 작동 방법에 대한 추가 정보는 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt; 를 참조하십시오 . &lt;code&gt;{{component}}&lt;/code&gt; 의 주요 용도는 애플리케이션 상태가 변경 될 때 렌더링되는 구성 요소 유형을 동적으로 변경하려는 경우에 사용됩니다. 이 도우미에는 인라인, 차단 및 중첩의 세 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb3abeccf1d3935a6c118b1810a1a10f67f5fd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{each-in}}&lt;/code&gt; helper loops over properties on an object.</source>
          <target state="translated">&lt;code&gt;{{each-in}}&lt;/code&gt; 객체의 속성을 통해 도우미 루프.</target>
        </trans-unit>
        <trans-unit id="3212095109428b4cbc3365440b62953596163903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper allows you to dynamically specify which property to bind, while the &lt;code&gt;{{mut}}&lt;/code&gt; helper allows the binding to be updated from the input. See the respective helper documentation for more detail.</source>
          <target state="translated">&lt;code&gt;{{get}}&lt;/code&gt; (가) 동안 도우미는 동적 바인딩 할 속성을 지정할 수 있습니다 &lt;code&gt;{{mut}}&lt;/code&gt; 도우미 바인딩은 입력에서 업데이트 할 수 있습니다. 자세한 내용은 해당 도우미 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b4f5775189e04e5beb9481aaf74caccbff888df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper can also respect mutable values itself. For example:</source>
          <target state="translated">&lt;code&gt;{{get}}&lt;/code&gt; 도우미는 변경 가능한 값 자체를 존중 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd0b47992fc4b78b9df9bbf1e6731c7ed45259f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{input}}&lt;/code&gt; helper lets you create an HTML &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; component. It causes an &lt;code&gt;Ember.TextField&lt;/code&gt; component to be rendered. For more info, see the &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt; docs and the &lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;templates guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{{input}}&lt;/code&gt; 도우미는 당신이 HTML 만들 수 있습니다 &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; 요소를. 그것은 발생 &lt;code&gt;Ember.TextField&lt;/code&gt; 의 컴포넌트가 렌더링된다. 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt; 문서 및 &lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;템플릿 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7acad9bb4a31001b61e35a4c0adf75c035da764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; Component</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 구성 요소</target>
        </trans-unit>
        <trans-unit id="3ea57e523caa15a38446ec50b9e79ddf92910c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component renders a link to the supplied &lt;code&gt;routeName&lt;/code&gt; passing an optionally supplied model to the route as its &lt;code&gt;model&lt;/code&gt; context of the route. The block for &lt;code&gt;{{link-to}}&lt;/code&gt; becomes the innerHTML of the rendered element:</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 요소가 제공하는 링크 렌더링 &lt;code&gt;routeName&lt;/code&gt; 그와 같은 경로를 선택적으로 공급 모델을 전달 &lt;code&gt;model&lt;/code&gt; 경로의 컨텍스트. &lt;code&gt;{{link-to}}&lt;/code&gt; 의 블록 은 렌더링 된 요소의 innerHTML이됩니다.</target>
        </trans-unit>
        <trans-unit id="e774d713fb0f90f4a303ddde2564100df64e2437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component takes one or two arguments:</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 구성 요소는 하나 개 또는 두 개의 인수를 :</target>
        </trans-unit>
        <trans-unit id="39dd886ddbed7524e4a83856c25fa9788916f62d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; helper will also add an &lt;code&gt;active&lt;/code&gt; class to the link that points to the currently active route.</source>
          <target state="translated">&lt;code&gt;{{link-to}}&lt;/code&gt; 도우미도 추가 할 것입니다 &lt;code&gt;active&lt;/code&gt; 이 점 현재 활성화 된 경로에 링크에 클래스를.</target>
        </trans-unit>
        <trans-unit id="90bfcd41e8565432c07cbbddf8858b5ba91f619a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{log}}&lt;/code&gt; helper also accepts primitive types such as strings or numbers.</source>
          <target state="translated">&lt;code&gt;{{log}}&lt;/code&gt; 도우미는 또한 문자열이나 숫자 등의 원시적 형을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="e201996bfd3ba8afd0712fffee879e9357d52b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{mount}}&lt;/code&gt; helper lets you embed a routeless engine in a template. Mounting an engine will cause an instance to be booted and its &lt;code&gt;application&lt;/code&gt; template to be rendered.</source>
          <target state="translated">&lt;code&gt;{{mount}}&lt;/code&gt; 도우미 템플릿에 routeless 엔진을 포함 할 수 있습니다. 엔진을 마운트하면 인스턴스가 부팅되고 해당 &lt;code&gt;application&lt;/code&gt; 템플릿이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="31eeebbd0adb9055cb1d8e00dfafd1d5331e5d95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{outlet}}&lt;/code&gt; helper lets you specify where a child route will render in your template. An important use of the &lt;code&gt;{{outlet}}&lt;/code&gt; helper is in your application's &lt;code&gt;application.hbs&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;{{outlet}}&lt;/code&gt; 도우미 아이 경로는 템플릿에 렌더링 위치를 지정할 수 있습니다. &lt;code&gt;{{outlet}}&lt;/code&gt; 헬퍼 의 중요한 사용법은 응용 프로그램의 &lt;code&gt;application.hbs&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ebbf8fe3922c7aefb3561c65af8dc306db37942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{unbound}}&lt;/code&gt; helper disconnects the one-way binding of a property, essentially freezing its value at the moment of rendering. For example, in this example the display of the variable &lt;code&gt;name&lt;/code&gt; will not change even if it is set with a new value:</source>
          <target state="translated">는 &lt;code&gt;{{unbound}}&lt;/code&gt; 도우미는 기본적으로 렌더링의 순간에 그 값을 동결, 속성의 결합 단방향 연결을 끊습니다. 예를 들어,이 예에서 변수 &lt;code&gt;name&lt;/code&gt; 의 표시 는 새 값으로 설정 되어도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c3bbef8d77a015f1b44f113e8413c77e1d8e3ae" translate="yes" xml:space="preserve">
          <source>The CLI &lt;code&gt;generate util&lt;/code&gt; command will create a utility file and a unit test. We'll delete the unit test since we don't want to test Google code.</source>
          <target state="translated">CLI &lt;code&gt;generate util&lt;/code&gt; 명령은 유틸리티 파일과 단위 테스트를 만듭니다. Google 코드를 테스트하고 싶지 않으므로 단위 테스트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="314686d9ca63241b41addc06dbaf29e1f9de2111" translate="yes" xml:space="preserve">
          <source>The CSS class name used for active classes can be customized for a single use of &lt;code&gt;{{link-to}}&lt;/code&gt; by passing an &lt;code&gt;activeClass&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;activeClass&lt;/code&gt; 옵션 을 전달하여 &lt;code&gt;{{link-to}}&lt;/code&gt; 의 단일 사용을 위해 활성 클래스에 사용되는 CSS 클래스 이름을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a18277d28224fe13bf61456994d23cdddba18d00" translate="yes" xml:space="preserve">
          <source>The CSS class to apply to &lt;code&gt;LinkComponent&lt;/code&gt;'s element when its &lt;code&gt;active&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; 속성이 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;LinkComponent&lt;/code&gt; 요소 에 적용 할 CSS 클래스 입니다 .</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">구성 요소 수명주기</target>
        </trans-unit>
        <trans-unit id="be34b5a31efa66b89e017638eee272b8df985bde" translate="yes" xml:space="preserve">
          <source>The DOM events for which the event dispatcher should listen.</source>
          <target state="translated">이벤트 디스패처가 청취해야하는 DOM 이벤트.</target>
        </trans-unit>
        <trans-unit id="16262c4e9109f80339ca991e19c44c9238c16f0c" translate="yes" xml:space="preserve">
          <source>The Data tab is kept in sync with the data loaded in your application. Any record additions, deletions, or changes are reflected immediately. If you have unsaved records, they will be displayed in green by clicking on the New pill.</source>
          <target state="translated">데이터 탭은 응용 프로그램에로드 된 데이터와 동기화되어 유지됩니다. 모든 레코드 추가, 삭제 또는 변경 사항이 즉시 반영됩니다. 저장하지 않은 기록이있는 경우 새 알약을 클릭하면 녹색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d52fbf4800c86d55bd033e9092c8b9094d06aa21" translate="yes" xml:space="preserve">
          <source>The DefaultResolver defines the default lookup rules to resolve container lookups before consulting the container for registered items:</source>
          <target state="translated">DefaultResolver는 등록 된 항목을 컨테이너에 문의하기 전에 컨테이너 조회를 해결하기위한 기본 조회 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c29711481fa25b48f2527c2fa7d8f0b8bed7a3b1" translate="yes" xml:space="preserve">
          <source>The Development Server</source>
          <target state="translated">개발 서버</target>
        </trans-unit>
        <trans-unit id="ed05a3cd2719814bf85e78b39e4626d5b1cd6abf" translate="yes" xml:space="preserve">
          <source>The Duration column displays the render time for a given template, including the template's children.</source>
          <target state="translated">Duration 열에는 템플릿의 자식을 포함하여 지정된 템플릿의 렌더링 시간이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ea15e43ed02f23a492330509b7d70ff1b380882" translate="yes" xml:space="preserve">
          <source>The ENV object contains three important keys:</source>
          <target state="translated">ENV 객체에는 세 가지 중요한 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f945314114021b149d52673626a64f4c3fb7096" translate="yes" xml:space="preserve">
          <source>The Ember Data store provides an interface for retrieving records of a single type.</source>
          <target state="translated">Ember 데이터 저장소는 단일 유형의 레코드를 검색하기위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="487c17cf393eda62f1f2c80da81270c64a1b3885" translate="yes" xml:space="preserve">
          <source>The Ember Inspector is a browser add-on designed to help you understand and debug your Ember applications. You can install it on &lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Google Chrome&lt;/a&gt;, &lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt; and &lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;other browsers&lt;/a&gt; (via a bookmarklet)</source>
          <target state="translated">Ember Inspector는 Ember 응용 프로그램을 이해하고 디버깅하는 데 도움이되도록 설계된 브라우저 애드온입니다. &lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Chromelet&lt;/a&gt; , &lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt; 및 &lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;기타 브라우저&lt;/a&gt; (북마크릿을 통해) 에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5ad72511f1a7b31a3a54993b2baf0d48b44720c" translate="yes" xml:space="preserve">
          <source>The Ember Router allows you to provide feedback that a route is loading, as well as when an error occurs in loading a route.</source>
          <target state="translated">Ember 라우터를 사용하면 경로를로드 할 때 오류가 발생할 때뿐만 아니라 경로가로드되고 있다는 피드백을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d259bb541551f92c36e45ba009a06cd16a1ca136" translate="yes" xml:space="preserve">
          <source>The Ember application is inside a sandboxed iframe with no url (if you are using JS Bin, follow &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;these steps&lt;/a&gt;.</source>
          <target state="translated">Ember 애플리케이션은 URL이없는 샌드 박스 iframe 안에 있습니다 (JS Bin을 사용하는 경우 &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;다음 단계를 수행하십시오)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6333e738da626887805c4ba5c1a1355ba0d71f" translate="yes" xml:space="preserve">
          <source>The Ember community values collaboration and building common tools that everyone relies on. If you're interested in deploying your app to production in a fast and reliable way, check out the &lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;Ember CLI Deploy&lt;/a&gt; addon.</source>
          <target state="translated">Ember 커뮤니티는 협업과 모든 사람이 사용하는 공통 도구 구축을 중요하게 생각합니다. 빠르고 안정적인 방식으로 프로덕션에 앱을 &lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;배포&lt;/a&gt; 하려면 Ember CLI Deploy 애드온을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd16b48b3b7627eda9a94aaf81db356a438f0ccb" translate="yes" xml:space="preserve">
          <source>The Ember router has four options to manage your application's URL: &lt;code&gt;history&lt;/code&gt;, which uses the HTML5 History API; &lt;code&gt;hash&lt;/code&gt;, which uses anchor-based URLs; &lt;code&gt;auto&lt;/code&gt;, which uses &lt;code&gt;history&lt;/code&gt; if supported by the user's browser, and falls back to &lt;code&gt;hash&lt;/code&gt; otherwise; and &lt;code&gt;none&lt;/code&gt;, which doesn't update the URL. By default, Ember CLI configures the router to use &lt;code&gt;auto&lt;/code&gt;. You can change this option in &lt;code&gt;config/environment.js&lt;/code&gt; under &lt;code&gt;ENV.locationType&lt;/code&gt;.</source>
          <target state="translated">Ember 라우터에는 애플리케이션의 URL을 관리하는 4 가지 옵션이 있습니다 : &lt;code&gt;history&lt;/code&gt; , HTML5 History API를 사용합니다. 앵커 기반 URL을 사용하는 &lt;code&gt;hash&lt;/code&gt; ; &lt;code&gt;auto&lt;/code&gt; 는 사용자 브라우저에서 지원하는 경우 &lt;code&gt;history&lt;/code&gt; 을 사용 하고 그렇지 않으면 &lt;code&gt;hash&lt;/code&gt; 로 폴백 합니다. 및 &lt;code&gt;none&lt;/code&gt; URL을 업데이트하지 않습니다. 기본적으로 Ember CLI는 라우터가 &lt;code&gt;auto&lt;/code&gt; 를 사용하도록 구성합니다 . &lt;code&gt;ENV.locationType&lt;/code&gt; 아래의 &lt;code&gt;config/environment.js&lt;/code&gt; 에서이 옵션을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7a78387322a36a85c1c5009f5fb0f7c35f76084" translate="yes" xml:space="preserve">
          <source>The Guides are intended to contain practical explanations of how to build Ember apps, focusing on the most widely-used features of Ember.js. For comprehensive documentation of every Ember feature and API, see the &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API documentation&lt;/a&gt;.</source>
          <target state="translated">이 안내서에는 Ember.js의 가장 널리 사용되는 기능을 중심으로 Ember 앱을 구축하는 방법에 대한 실제 설명이 포함되어 있습니다. 모든 Ember 기능 및 API에 대한 포괄적 인 설명서는 &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f275cf778b6d119ab020c3d01e5250ad0219426" translate="yes" xml:space="preserve">
          <source>The Guides begin with an explanation of how to get started with Ember, followed by a tutorial on how to build your first Ember app. If you're brand new to Ember, we recommend you start off by following along with these first two sections of the Guides.</source>
          <target state="translated">이 안내서는 Ember를 시작하는 방법에 대한 설명과 첫 번째 Ember 앱을 구축하는 방법에 대한 자습서로 시작합니다. Ember를 처음 사용하는 경우 가이드의 처음 두 섹션과 함께 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3c07d3314a98bd2f32c93ed811bdc5e03c2e9eb7" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;class&lt;/code&gt; attribute of a component's tag can be set by providing a &lt;code&gt;classNames&lt;/code&gt; property that is set to an array of strings:</source>
          <target state="translated">문자열 배열로 설정된 &lt;code&gt;classNames&lt;/code&gt; 속성을 제공하여 구성 요소 태그 의 HTML &lt;code&gt;class&lt;/code&gt; 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="712c891dbe91ea95b6ed85832f3affbadeaa1d8c" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the component's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM에서 컴포넌트 요소의 HTML &lt;code&gt;id&lt;/code&gt; 입니다. 이 값을 직접 제공 할 수 있지만 HTML과 마찬가지로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="77babb069a61a648d0e212eb50fbca403ad78359" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the view's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM에서보기 요소 의 HTML &lt;code&gt;id&lt;/code&gt; 입니다. 이 값을 직접 제공 할 수 있지만 HTML과 마찬가지로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ce9a853ceec8935a32736d2ed256b8ef580453" translate="yes" xml:space="preserve">
          <source>The HTML attribute section of a component's tag can be set by providing an &lt;code&gt;attributeBindings&lt;/code&gt; property set to an array of property names on the component. The return value of these properties will be used as the value of the component's HTML associated attribute:</source>
          <target state="translated">구성 요소 태그의 HTML 속성 섹션은 구성 요소의 특성 이름 배열에 &lt;code&gt;attributeBindings&lt;/code&gt; 특성 세트를 제공하여 설정할 수 있습니다 . 이러한 속성의 반환 값은 구성 요소의 HTML 관련 특성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ca8096b2b2a08769eef8f9d51a7c386381b928" translate="yes" xml:space="preserve">
          <source>The IDs will be passed as a URL-encoded Array of IDs, in this form:</source>
          <target state="translated">ID는 다음과 같은 형식으로 URL 인코딩 된 ID 배열로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c9440c491aa7e5a5571ef8d623370fad7dc61a99" translate="yes" xml:space="preserve">
          <source>The Inspector displays the parent objects and mixins that are composed into the chosen object, including the inherited properties.</source>
          <target state="translated">인스펙터는 상속 된 속성을 포함하여 선택된 객체로 구성된 상위 객체와 믹스 인을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="751510e2504c4b774d23cdd66c8c40b91042175d" translate="yes" xml:space="preserve">
          <source>The Inspector displays these routes:</source>
          <target state="translated">인스펙터는 다음 경로를 표시합니다 :</target>
        </trans-unit>
        <trans-unit id="690c38e1e0e3e9aad8aa3afc61469ec327e5aab8" translate="yes" xml:space="preserve">
          <source>The Inspector highlights the currently active routes. However, if your app has grown too large for this to be useful, you can use the &lt;code&gt;Current Route Only&lt;/code&gt; checkbox to hide all routes except the currently active ones.</source>
          <target state="translated">인스펙터는 현재 활성화 된 경로를 강조 표시합니다. 그러나 앱이 너무 커져 유용하지 않은 경우 &lt;code&gt;Current Route Only&lt;/code&gt; 확인란을 사용 하여 현재 활성화 된 경로를 제외한 모든 경로를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f30f50f616f12ec02246e464e631a2ca7d407d6d" translate="yes" xml:space="preserve">
          <source>The Inspector includes a panel that allows you to view and interact with your Ember objects. To open it, click on any Ember object. You can then view the object's properties.</source>
          <target state="translated">인스펙터에는 Ember 객체를보고 상호 작용할 수있는 패널이 있습니다. 그것을 열려면 Ember 객체를 클릭하십시오. 그런 다음 객체의 속성을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07f0c70b2f17b1a0937f0084ad1769ae1c7b677" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to look at all Promises created in your application. Click on the &lt;code&gt;Promises&lt;/code&gt; menu to start inspecting them.</source>
          <target state="translated">인스펙터는 어플리케이션에서 생성 된 모든 약속을 볼 수있는 방법을 제공합니다. &lt;code&gt;Promises&lt;/code&gt; 메뉴를 클릭하여 검사를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="62cf4d7c67083a3006feaede174affa0b51ea132" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to view a Promise's stack trace. Tracing Promises is disabled by default for performance reasons. To enable tracing, check the &lt;code&gt;Trace promise&lt;/code&gt; checkbox. You may want to reload to trace existing Promises.</source>
          <target state="translated">인스펙터는 Promise의 스택 트레이스를 볼 수있는 방법을 제공합니다. 성능상의 이유로 추적 약속은 기본적으로 비활성화되어 있습니다. 추적을 사용하려면 &lt;code&gt;Trace promise&lt;/code&gt; 확인란을 선택하십시오. 기존 약속을 추적하기 위해 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a817980043f7fb6f67f44a551dd1bc461d4d9f8e" translate="yes" xml:space="preserve">
          <source>The JSON API adapter will automatically send a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt;.</source>
          <target state="translated">JSON API 어댑터는 &lt;code&gt;GET&lt;/code&gt; 요청을 &lt;code&gt;/posts/1&lt;/code&gt; 로 자동 전송합니다 .</target>
        </trans-unit>
        <trans-unit id="010af95fc7f9a5c21dd89196b646d7c1093ea5b8" translate="yes" xml:space="preserve">
          <source>The JSON payload should be an object that contains the record inside a root property. For example, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts/1&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">JSON 페이로드는 루트 속성 내에 레코드가 포함 된 객체 여야합니다. 예를 들어 &lt;code&gt;/posts/1&lt;/code&gt; 에 대한 &lt;code&gt;GET&lt;/code&gt; 요청에 대한 JSON은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="01e0b389167fcbb21b9dfab152a2b6136aa145d1" translate="yes" xml:space="preserve">
          <source>The JSON returned should look like this:</source>
          <target state="translated">반환 된 JSON은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="04d2c141e4adc4849c1a9d91f7f144599c2898c1" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an ID to another record:</source>
          <target state="translated">JSON은 관계를 다른 레코드의 ID로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b9146885924e80940db37b81326f9209df93900" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an array of IDs and types:</source>
          <target state="translated">JSON은 관계를 ID 및 유형의 배열로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa6abe7bb9f4b0f9e54508fdc1d5224614314c01" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter uses JSON API conventions for building the url for a record and selecting the HTTP verb to use with a request. The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">JSONAPIAdapter는 JSON API 규칙을 사용하여 레코드의 URL을 작성하고 요청에 사용할 HTTP 동사를 선택합니다. 레코드 맵에서 수행 할 수있는 조치는 JSON API 어댑터의 다음 URL에 있습니다.</target>
        </trans-unit>
        <trans-unit id="319a4c20db8f22613ffca3673ffd0b4f116cbd53" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">JSONAPIAdapter는 2xx 제품군 ( &quot;성공&quot;)의 상태 코드와 304 ( &quot;수정되지 않음&quot;)의 응답이 성공한 것으로 간주합니다. 다른 상태 코드는 실패로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="487ab77d5dbd345e6346d5f74c302b58d482236b" translate="yes" xml:space="preserve">
          <source>The Model Hook</source>
          <target state="translated">모델 훅</target>
        </trans-unit>
        <trans-unit id="97c09292b53b45afc09c57770f7220ff9a4c953a" translate="yes" xml:space="preserve">
          <source>The NativeArray mixin contains the properties needed to make the native Array support Ember.MutableArray and all of its dependent APIs. Unless you have &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; set to false, this will be applied automatically. Otherwise you can apply the mixin at anytime by calling &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt;.</source>
          <target state="translated">NativeArray 믹스 인에는 네이티브 배열이 Ember.MutableArray 및 모든 종속 API를 지원하는 데 필요한 속성이 포함되어 있습니다. &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 또는 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; 를 false로 설정 하지 않으면 이 값이 자동으로 적용됩니다. 그렇지 않으면 &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt; 을 호출하여 언제든지 믹스 인을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f728d39e800e681d2478973af1aacfb873e272e4" translate="yes" xml:space="preserve">
          <source>The Parent Route</source>
          <target state="translated">부모 루트</target>
        </trans-unit>
        <trans-unit id="8e7bb3b57567e2227a221f010574edc6b4965cd1" translate="yes" xml:space="preserve">
          <source>The REST adapter allows your store to communicate with an HTTP server by transmitting JSON via XHR. Most Ember.js apps that consume a JSON API should use the REST adapter.</source>
          <target state="translated">REST 어댑터를 사용하면 상점이 XHR을 통해 JSON을 전송하여 상점이 HTTP 서버와 통신 할 수 있습니다. JSON API를 사용하는 대부분의 Ember.js 앱은 REST 어댑터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc6f2d961e0e8648bf62845bef00cfd62c181e1b" translate="yes" xml:space="preserve">
          <source>The REST adapter expects the JSON returned from your server to follow these conventions.</source>
          <target state="translated">REST 어댑터는 서버에서 리턴 된 JSON이 이러한 규칙을 따를 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="5ebe4d3849e4f0595a2c49dc9cebb6616874d70b" translate="yes" xml:space="preserve">
          <source>The REST adapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">REST 어댑터는 304 ( &quot;수정되지 않음&quot;)뿐만 아니라 2xx 제품군 ( &quot;성공&quot;)의 상태 코드로 응답이 성공한 것으로 간주합니다. 다른 상태 코드는 실패로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3172f22137802d4a8642cfa5668354ec4d3eeea5" translate="yes" xml:space="preserve">
          <source>The Router Pauses for Promises</source>
          <target state="translated">라우터가 약속을 위해 멈춤</target>
        </trans-unit>
        <trans-unit id="efc37914e3487c9ca3df5d1d763f3449e864fe55" translate="yes" xml:space="preserve">
          <source>The Router service is the public API that provides component/view layer access to the router.</source>
          <target state="translated">라우터 서비스는 라우터에 대한 컴포넌트 / 뷰 레이어 액세스를 제공하는 공개 API입니다.</target>
        </trans-unit>
        <trans-unit id="0c9d4cff939b6e9fcde57c63e9fa2dc698d186a0" translate="yes" xml:space="preserve">
          <source>The Routes tab displays a list of your application's routes.</source>
          <target state="translated">경로 탭에는 응용 프로그램의 경로 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="84729b1e90f85ba399f1de4cfa6c0e4c113086c4" translate="yes" xml:space="preserve">
          <source>The Run Loop</source>
          <target state="translated">런 루프</target>
        </trans-unit>
        <trans-unit id="c32cedc8b4658f5a2c9ec3fd3e53275c0943aca6" translate="yes" xml:space="preserve">
          <source>The SOLID principles of good design tell us that objects should have a single responsibility. The responsibility of a component should be presenting model data to the user, not fetching the model.</source>
          <target state="translated">우수한 디자인의 SOLID 원칙은 객체에 단일 책임이 있어야 함을 알려줍니다. 구성 요소의 책임은 모델을 가져 오지 않고 사용자에게 모델 데이터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2750c3a85432d63bf43d76ed414a487327be0ac0" translate="yes" xml:space="preserve">
          <source>The Store and a Single Source of Truth</source>
          <target state="translated">상점과 진실의 단일 출처</target>
        </trans-unit>
        <trans-unit id="9f42b50dcb01303923e39ca4b080e7c21fefec38" translate="yes" xml:space="preserve">
          <source>The URL can be set in a few ways:</source>
          <target state="translated">몇 가지 방법으로 URL을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bcc0cf43c5c46031ea589d18baa3c4b454de17b" translate="yes" xml:space="preserve">
          <source>The View Tree</source>
          <target state="translated">뷰 트리</target>
        </trans-unit>
        <trans-unit id="41ef7117b31fdc6690fac73d0b81e21453b46c57" translate="yes" xml:space="preserve">
          <source>The View Tree ignores components and inline views by default. To load these into the View Tree check the &lt;code&gt;Components&lt;/code&gt; and &lt;code&gt;All Views&lt;/code&gt; checkboxes.</source>
          <target state="translated">뷰 트리는 기본적으로 구성 요소 및 인라인 뷰를 무시합니다. 이를 뷰 트리에로드하려면 &lt;code&gt;Components&lt;/code&gt; 및 &lt;code&gt;All Views&lt;/code&gt; 확인란을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b3bb30d409dd94a905d7278b4f7300834afaa9d8" translate="yes" xml:space="preserve">
          <source>The WAI-ARIA role of the control represented by this view. For example, a button may have a role of type 'button', or a pane may have a role of type 'alertdialog'. This property is used by assistive software to help visually challenged users navigate rich web applications.</source>
          <target state="translated">이 뷰로 표시되는 컨트롤의 WAI-ARIA 역할. 예를 들어, 단추에는 'button'유형의 역할이 있거나 분할 창에 'alertdialog'유형의 역할이있을 수 있습니다. 이 속성은 시각 장애인이 풍부한 웹 응용 프로그램을 탐색 할 수 있도록 보조 소프트웨어에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="599db392fb52dd7a9d9ebf1a02ad877e6dc24952" translate="yes" xml:space="preserve">
          <source>The ability to consume a growing ecosystem of &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons&lt;/a&gt;.</source>
          <target state="translated">성장하는 &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons의&lt;/a&gt; 생태계를 소비하는 능력 .</target>
        </trans-unit>
        <trans-unit id="236eb25e1509b24135c459c63eaaa974644a72a7" translate="yes" xml:space="preserve">
          <source>The above code will allow you invoke the &lt;code&gt;sum()&lt;/code&gt; function as a &lt;code&gt;{{sum}}&lt;/code&gt; handlebars &quot;helper&quot; in your templates:</source>
          <target state="translated">위의 코드를 사용하면 템플릿에서 &lt;code&gt;{{sum}}&lt;/code&gt; 핸들 바 &quot;헬퍼&quot; 로 &lt;code&gt;sum()&lt;/code&gt; 함수 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17aff5f3819b34917a219ca60e2165bb9008b501" translate="yes" xml:space="preserve">
          <source>The above example contains two arguments:</source>
          <target state="translated">위의 예에는 두 가지 인수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f30b8685376aad3470d0d8bc20b92baa1adf445" translate="yes" xml:space="preserve">
          <source>The above example returns the original arguments (after your customizations) back to the parent class, so it can continue with its normal operations.</source>
          <target state="translated">위의 예제는 사용자 지정 후 원래 인수를 부모 클래스로 다시 반환하므로 정상적인 작업을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de72be9fc4a958c468aab5fce926f1c1d8e1f2a" translate="yes" xml:space="preserve">
          <source>The above example template will render a template named &quot;-nav&quot;, which has the same context as the parent template it's rendered into, so if the &quot;-nav&quot; template also referenced &lt;code&gt;{{foo}}&lt;/code&gt;, it would print the same thing as the &lt;code&gt;{{foo}}&lt;/code&gt; in the above example.</source>
          <target state="translated">위의 예제 템플릿은 렌더링 된 상위 템플릿과 동일한 컨텍스트를 가진 &quot;-nav&quot;라는 템플릿을 렌더링하므로 &quot;-nav&quot;템플릿도 &lt;code&gt;{{foo}}&lt;/code&gt; 를 참조 하면 &lt;code&gt;{{foo}}&lt;/code&gt; 위의 예이다.</target>
        </trans-unit>
        <trans-unit id="b5a49ec8b75cd43831c857a7b5a6f317839e3550" translate="yes" xml:space="preserve">
          <source>The above example will look up the value of &lt;code&gt;someTemplateName&lt;/code&gt; on the template context (e.g. a controller) and use that value as the name of the template to render. If the resolved value is falsy, nothing will be rendered. If &lt;code&gt;someTemplateName&lt;/code&gt; changes, the partial will be re-rendered using the new template name.</source>
          <target state="translated">위의 예제는 템플릿 컨텍스트 (예 : 컨트롤러) 에서 &lt;code&gt;someTemplateName&lt;/code&gt; 의 값을 찾고 해당 값을 렌더링 할 템플릿의 이름으로 사용합니다. 해결 된 값이 거짓이면 아무것도 렌더링되지 않습니다. 경우 &lt;code&gt;someTemplateName&lt;/code&gt; 이 변경 부분은 새 템플릿의 이름을 사용하여 렌더링 재됩니다.</target>
        </trans-unit>
        <trans-unit id="4a17372c1a6f0d338afcba08934ad438cff05188" translate="yes" xml:space="preserve">
          <source>The above example will print a list like this:</source>
          <target state="translated">위의 예는 다음과 같은 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14759cf8b76d4ce53586ecc24fe64560891c5d11" translate="yes" xml:space="preserve">
          <source>The above template and controller render as the following HTML:</source>
          <target state="translated">위의 템플릿과 컨트롤러는 다음 HTML로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="647c3ca2996d871bb4527f63fd867d23a1ddf4a8" translate="yes" xml:space="preserve">
          <source>The above template will render HTML like this:</source>
          <target state="translated">위의 템플릿은 다음과 같이 HTML을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="1b6db4d979bea0f132b8aecf3e051e28b2ff75cb" translate="yes" xml:space="preserve">
          <source>The above will result in the following HTML output:</source>
          <target state="translated">위의 결과는 다음과 같은 HTML 출력이됩니다.</target>
        </trans-unit>
        <trans-unit id="1f4cb9f31c2595e4f16286bd14d0a1224fdd7a4e" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;deleteUser&lt;/code&gt; is in quotes, since &lt;code&gt;system-preferences-editor&lt;/code&gt; is where the action is defined now. Quotes indicate that the action should be looked for in &lt;code&gt;actions&lt;/code&gt; local to that component, rather than in those that have been passed from a parent.</source>
          <target state="translated">&lt;code&gt;system-preferences-editor&lt;/code&gt; 가 조치가 정의 된 위치 이므로 &lt;code&gt;deleteUser&lt;/code&gt; 조치 는 따옴표로 묶습니다 . 인용 부호 는 상위에서 전달 된 것이 아니라 해당 구성 요소의 로컬 &lt;code&gt;actions&lt;/code&gt; 에서 조치 를 찾아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bc124545536eb0f1b78bc91d3e1823a25158f2d9" translate="yes" xml:space="preserve">
          <source>The action to trigger</source>
          <target state="translated">트리거 할 조치</target>
        </trans-unit>
        <trans-unit id="fffafad4245d122f1f8b1d4f82482f6c6e9972ee" translate="yes" xml:space="preserve">
          <source>The actions &quot;play&quot; and &quot;stop&quot; must be passed to this &lt;code&gt;play-button&lt;/code&gt; component:</source>
          <target state="translated">&quot;재생&quot;및 &quot;중지&quot;작업은이 &lt;code&gt;play-button&lt;/code&gt; 구성 요소 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b15d60efde70e42a8401dc81cb70c844a7ab5b07" translate="yes" xml:space="preserve">
          <source>The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">레코드 맵에서 수행 할 수있는 조치는 JSON API 어댑터의 다음 URL에 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f498285f596848fc23f04d9e51276702a760d4" translate="yes" xml:space="preserve">
          <source>The adapter is responsible for answering all of these questions. Whenever your app asks the store for a record that it doesn't have cached, it will ask the adapter for it. If you change a record and save it, the store will hand the record to the adapter to send the appropriate data to your server and confirm that the save was successful.</source>
          <target state="translated">어댑터는이 모든 질문에 대답 할 책임이 있습니다. 앱이 스토어에 캐시하지 않은 레코드를 요청할 때마다 어댑터가 요청합니다. 레코드를 변경하고 저장하면 저장소는 레코드를 어댑터에 전달하여 적절한 데이터를 서버로 보내고 저장이 완료되었음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ad248e90ac6d8ba6c4d90263b68bd3e56fc49c63" translate="yes" xml:space="preserve">
          <source>The adapter passes in &lt;code&gt;includeId: true&lt;/code&gt; when serializing a record for &lt;code&gt;createRecord&lt;/code&gt;, but not for &lt;code&gt;updateRecord&lt;/code&gt;.</source>
          <target state="translated">어댑터는 &lt;code&gt;createRecord&lt;/code&gt; 의 레코드가 아닌 &lt;code&gt;updateRecord&lt;/code&gt; 의 레코드를 직렬화 할 때 &lt;code&gt;includeId: true&lt;/code&gt; 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="efdf679155c7a3919c2945e73db79499e695fec9" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;container-debug-adapter:main&lt;/code&gt;.</source>
          <target state="translated">어댑터는 애플리케이션 컨테이너에 &lt;code&gt;container-debug-adapter:main&lt;/code&gt; 으로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="131e20e9576979fea3838369ca8bebc9bee71a7f" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;dataAdapter:main&lt;/code&gt;.</source>
          <target state="translated">어댑터는 애플리케이션 컨테이너에 &lt;code&gt;dataAdapter:main&lt;/code&gt; 으로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="de1f8ea65a9d062ad63b311606da2e19fac5c593" translate="yes" xml:space="preserve">
          <source>The advantage of an async helper is that it will not run until the last async helper has completed. All async helpers after it will wait for it complete before running.</source>
          <target state="translated">비동기 도우미의 장점은 마지막 비동기 도우미가 완료 될 때까지 실행되지 않는다는 것입니다. 모든 비동기 헬퍼는 실행하기 전에 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="132b17863e2451dad65a1fc69e5aa6a2e2be4784" translate="yes" xml:space="preserve">
          <source>The algorithm works this way:</source>
          <target state="translated">알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5ff582d708a589904a1b030c787773bd60458940" translate="yes" xml:space="preserve">
          <source>The alternative syntax, with prototype extensions, might look like:</source>
          <target state="translated">프로토 타입 확장이 포함 된 대체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c3682b20b3168f59d213bbd7233481e751bc3ef" translate="yes" xml:space="preserve">
          <source>The amount to decrement by. Defaults to 1</source>
          <target state="translated">감소 할 금액입니다. 기본값은 1</target>
        </trans-unit>
        <trans-unit id="5b7201edf1c359c10f638704266bcb43f6ade922" translate="yes" xml:space="preserve">
          <source>The amount to increment by. Defaults to 1</source>
          <target state="translated">증분 할 금액입니다. 기본값은 1</target>
        </trans-unit>
        <trans-unit id="ed509f29503bfd3d0043d389191e47926618eace" translate="yes" xml:space="preserve">
          <source>The application instance is passed to Ember's instance initializer hooks and it is added as the &quot;owner&quot; of each object that was instantiated by the application instance.</source>
          <target state="translated">응용 프로그램 인스턴스는 Ember의 인스턴스 이니셜 라이저 후크로 전달되며 응용 프로그램 인스턴스가 인스턴스화 한 각 객체의 &quot;소유자&quot;로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="355a1c859de0828ab927049176efde71ae67825a" translate="yes" xml:space="preserve">
          <source>The application route</source>
          <target state="translated">신청 경로</target>
        </trans-unit>
        <trans-unit id="bc69913b03727770065706d5ae763881554440df" translate="yes" xml:space="preserve">
          <source>The arguments to pass to the method</source>
          <target state="translated">메소드에 전달할 인수</target>
        </trans-unit>
        <trans-unit id="e850ec910ddafcfd153f778405adf847a5eaecec" translate="yes" xml:space="preserve">
          <source>The array represents the diff of the canonical state with the local state of the model. Note: if the model is created locally, the canonical state is empty since the adapter hasn't acknowledged the attributes yet:</source>
          <target state="translated">이 배열은 표준 상태와 모델의 로컬 상태의 차이를 나타냅니다. 참고 : 모델이 로컬로 작성된 경우 어댑터가 속성을 아직 인식하지 않았으므로 표준 상태는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7876ec17eeb81f6ca541bc1ef63a2af2ef9b1f5a" translate="yes" xml:space="preserve">
          <source>The attrs options object can use more specific instruction for extracting and serializing. When serializing, an option to embed &lt;code&gt;ids&lt;/code&gt;, &lt;code&gt;ids-and-types&lt;/code&gt; or &lt;code&gt;records&lt;/code&gt; can be set. When extracting the only option is &lt;code&gt;records&lt;/code&gt;.</source>
          <target state="translated">attrs 옵션 오브젝트는 추출 및 직렬화에 대해보다 구체적인 지시 사항을 사용할 수 있습니다. 직렬화 할 때 &lt;code&gt;ids&lt;/code&gt; , &lt;code&gt;ids-and-types&lt;/code&gt; 또는 &lt;code&gt;records&lt;/code&gt; 를 포함하는 옵션을 설정할 수 있습니다. 유일한 옵션을 추출 할 때는 &lt;code&gt;records&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="692cb52572458fcee0dcfc7ce5597337ffbedcc6" translate="yes" xml:space="preserve">
          <source>The block expression can then use block params to bind names to any yielded values for use in the block. This allows for template customization when using a component, where the markup is provided by the consuming template, but any event handling behavior implemented in the component is retained such as &lt;code&gt;click()&lt;/code&gt; handlers.</source>
          <target state="translated">그런 다음 블록 표현식은 블록 매개 변수를 사용하여 이름을 블록에 사용하기 위해 생성 된 값에 바인딩 할 수 있습니다. 이렇게하면 소비 템플릿에서 마크 업이 제공되는 구성 요소를 사용할 때 템플릿을 사용자 정의 할 수 있지만 &lt;code&gt;click()&lt;/code&gt; 핸들러 와 같이 구성 요소에 구현 된 모든 이벤트 처리 동작은 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="230b18f150ea432b7fc63ef20d6f97b9cd3ebdce" translate="yes" xml:space="preserve">
          <source>The block form of helpers allows you to control how the UI is created based on the values of properties. A third form of helper is called &quot;nested&quot;. For example here the concat helper will add &quot; Doe&quot; to a displayed name if the person has no last name:</source>
          <target state="translated">도우미의 블록 형식을 사용하면 속성 값을 기반으로 UI를 만드는 방법을 제어 할 수 있습니다. 도우미의 세 번째 형태는 &quot;중첩&quot;이라고합니다. 예를 들어, concat 도우미는성에 이름이없는 경우 표시된 이름에 &quot;Doe&quot;를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdafa2c9116008ccf0ab97418b925c097c3252ac" translate="yes" xml:space="preserve">
          <source>The blog post list scrolls to position a new post at the top of the viewport.</source>
          <target state="translated">블로그 게시물 목록이 스크롤되어 뷰포트 상단에 새 게시물이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="af6e26b49064e993b28a797e047db6b65613464e" translate="yes" xml:space="preserve">
          <source>The cached value of the computed property, if any</source>
          <target state="translated">계산 된 속성의 캐시 된 값 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="70f3ab63a321edca05f8d7fe826eff4a7da47248" translate="yes" xml:space="preserve">
          <source>The call made to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">Rails 백엔드를 사용하여 서버에 대한 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="939bb0a279b018152f9c264171bbf1c866b675ab" translate="yes" xml:space="preserve">
          <source>The call to the function &lt;code&gt;this.inject.service&lt;/code&gt;&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;injects&lt;/a&gt; the service we just registered into the context of the tests, so each test may access it through &lt;code&gt;this.get('mapsService')&lt;/code&gt;. In the example we assert that &lt;code&gt;calledWithLocation&lt;/code&gt; in our stub is set to the location we passed to the component.</source>
          <target state="translated">함수를 호출 &lt;code&gt;this.inject.service&lt;/code&gt; 의&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;주입 또는&lt;/a&gt; 각각의 테스트를 통해 액세스 할 수 있도록 다만, 시험의 컨텍스트에 등록 된 서비스 &lt;code&gt;this.get('mapsService')&lt;/code&gt; . 이 예에서는 스텁의 &lt;code&gt;calledWithLocation&lt;/code&gt; 이 컴포넌트에 전달한 위치로 설정되어 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="6165fe98748987844899c6930403c4c1ab5d19eb" translate="yes" xml:space="preserve">
          <source>The call to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">Rails 백엔드를 사용한 서버 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d0699b4fba58c3f4df0d8bbb8c406317b7efb2c" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature (all parameters are optional):</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다 (모든 매개 변수는 선택 사항 임).</target>
        </trans-unit>
        <trans-unit id="7db19daead06e2c546317e025647247b05e290f5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration.</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다. &lt;code&gt;item&lt;/code&gt; 은 반복에서 현재 항목입니다. &lt;code&gt;index&lt;/code&gt; 는 반복에서 현재 항목의 정수 색인입니다.</target>
        </trans-unit>
        <trans-unit id="e6388916ece31666bfa3bce621dc9190d0851704" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration. &lt;code&gt;array&lt;/code&gt; is the dependant array itself.</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다. &lt;code&gt;item&lt;/code&gt; 은 반복에서 현재 항목입니다. &lt;code&gt;index&lt;/code&gt; 는 반복에서 현재 항목의 정수 색인입니다. &lt;code&gt;array&lt;/code&gt; 는 종속 배열 자체입니다.</target>
        </trans-unit>
        <trans-unit id="747b58783f30aeed09a97bff68b7a7ed7e662bd5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature:</source>
          <target state="translated">제공하는 콜백 메소드에는 다음 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d86eb979382fa479d1f0e875f699adf9c61634f" translate="yes" xml:space="preserve">
          <source>The callback to execute</source>
          <target state="translated">실행할 콜백</target>
        </trans-unit>
        <trans-unit id="378f4ac8c5402e27d2f5c1371ff15299fb646fad" translate="yes" xml:space="preserve">
          <source>The callback will receive the current application as an argument.</source>
          <target state="translated">콜백은 현재 응용 프로그램을 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbb92bec845d62ef32b3b4db4795ff8fb8678df" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; can then modify the parent's value just by modifying its own property:</source>
          <target state="translated">그런 다음 자식 &lt;code&gt;Component&lt;/code&gt; 는 자체 속성을 수정하여 부모 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257db548c086357f7aead64fe919a39c98588cac" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; would invoke the action with the new click value:</source>
          <target state="translated">하위 &lt;code&gt;Component&lt;/code&gt; 는 새로운 클릭 값으로 조치를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="01b4ccc47f51a076e5b8b5bc1b2f43c46487fa20" translate="yes" xml:space="preserve">
          <source>The class of a model might be useful if you want to get a list of all the relationship names of the model, see &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt;&lt;code&gt;relationshipNames&lt;/code&gt;&lt;/a&gt; for example.</source>
          <target state="translated">모델의 모든 관계 이름 목록을 얻으려는 경우 모델 클래스가 유용 할 수 있습니다 ( 예 : &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt; &lt;code&gt;relationshipNames&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="48f539537c66e244c744c84eda7209879551eaf4" translate="yes" xml:space="preserve">
          <source>The code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence. The image demonstrates what that deprecation looks like when you run your tests.</source>
          <target state="translated">아래 코드는 발생시 예외를 발생시키기 위해 첫 번째 사용 중단이 설정된 사용 중단 워크 플로 파일입니다. 이미지는 테스트를 실행할 때 사용 중단이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="93cd13234a3187a294d47fbdde9fd0427c708c5b" translate="yes" xml:space="preserve">
          <source>The collection of functions, keyed by name, available on this &lt;code&gt;ActionHandler&lt;/code&gt; as action targets.</source>
          <target state="translated">이 &lt;code&gt;ActionHandler&lt;/code&gt; 에서 이름으로 키가 지정된 함수 콜렉션을 조치 대상으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d2bfcf3313d4bc0a7bda43e5de7a8ef0369007f" translate="yes" xml:space="preserve">
          <source>The command will generate the following output, showing that it created a single file called &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;.</source>
          <target state="translated">명령은 다음 출력을 생성하여 &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; 라는 단일 파일을 작성했음을 보여 줍니다 .</target>
        </trans-unit>
        <trans-unit id="1a6bdd19a4196300d3fed3ccaf29bc7c89c1afa5" translate="yes" xml:space="preserve">
          <source>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</source>
          <target state="translated">아래 구성 요소는 항목 목록을 가져 와서 화면에 표시합니다. 또한 선택된 항목을 나타내는 객체를 가져 와서 해당 항목에 대한 스크롤 상단을 선택하여 설정합니다.</target>
        </trans-unit>
        <trans-unit id="00924038d9acbd0206114498f918d95680c59534" translate="yes" xml:space="preserve">
          <source>The component should show details about the rental</source>
          <target state="translated">구성 요소에 대여에 대한 세부 사항이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="03d4f32bac2eee953b37844aa3ddbdccc1b00e16" translate="yes" xml:space="preserve">
          <source>The component should toggle the existence of a wide class on click, to expand and shrink the photo of the rental.</source>
          <target state="translated">구성 요소는 대여시 사진을 확대하거나 축소하기 위해 클릭시 와이드 클래스의 존재를 토글해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb8277dc02802176f96c31e5577dcf1f7ddceafa" translate="yes" xml:space="preserve">
          <source>The component template will have a button and a div that shows the confirmation dialog based on the value of &lt;code&gt;confirmShown&lt;/code&gt;.</source>
          <target state="translated">구성 요소 템플릿에는 &lt;code&gt;confirmShown&lt;/code&gt; 값을 기반으로 확인 대화 상자를 표시하는 단추와 div가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e02882f24ccee1b6087710e6540fa437584878" translate="yes" xml:space="preserve">
          <source>The component's element has been both created and inserted into the DOM.</source>
          <target state="translated">컴포넌트의 요소가 생성되어 DOM에 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4cc0a17e4b5e6b7c7ced86a1cc438b4160335bc6" translate="yes" xml:space="preserve">
          <source>The component's element is accessible via the component's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt;&lt;code&gt;$()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">컴포넌트의 요소는 컴포넌트의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt; &lt;code&gt;$()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f87081eb897d1fd3835c5c46606eabc3f8f40d2c" translate="yes" xml:space="preserve">
          <source>The computed macros expect you to use an array, so there is no need to use the &lt;code&gt;[]&lt;/code&gt; key in these cases. However, building your own custom computed property requires you to tell Ember.js that it is watching for array changes, which is where the &lt;code&gt;[]&lt;/code&gt; key comes in handy.</source>
          <target state="translated">계산 된 매크로는 배열을 사용해야하므로 이러한 경우에는 &lt;code&gt;[]&lt;/code&gt; 키 를 사용할 필요가 없습니다 . 그러나 사용자 정의 계산 속성을 만들려면 배열 변경을 감시하고 있음을 Ember.js에 알려 주어야합니다. 여기서 &lt;code&gt;[]&lt;/code&gt; 키가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="c04629937de1c7126ae68322907abae8ecd667fc" translate="yes" xml:space="preserve">
          <source>The container calls this object's &lt;code&gt;resolve&lt;/code&gt; method with the &lt;code&gt;fullName&lt;/code&gt; argument.</source>
          <target state="translated">컨테이너 는 &lt;code&gt;fullName&lt;/code&gt; 인수를 사용 하여이 객체의 &lt;code&gt;resolve&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dedba2d51f22aac0e2c4ffa20bbb5629c1192057" translate="yes" xml:space="preserve">
          <source>The container-debug-adapter which is used to list all models.</source>
          <target state="translated">모든 모델을 나열하는 데 사용되는 컨테이너 디버그 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="71bc08d35f4aa7dfc82186fc932b83df95fed7ce" translate="yes" xml:space="preserve">
          <source>The controller associated with this route.</source>
          <target state="translated">이 경로와 관련된 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="8b3eab1e8d1492edcda2af7cd55a05ab06f81f5f" translate="yes" xml:space="preserve">
          <source>The controller instance must already have been created, either through entering the associated route or using &lt;code&gt;generateController&lt;/code&gt;.</source>
          <target state="translated">연관된 경로를 입력하거나 &lt;code&gt;generateController&lt;/code&gt; 를 사용하여 컨트롤러 인스턴스가 이미 작성되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d996ccba50d2a03192ad84043d699c49c674c9d6" translate="yes" xml:space="preserve">
          <source>The controller receives a single property from the Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; which is the return value of the Route's &lt;code&gt;model()&lt;/code&gt; method.</source>
          <target state="translated">컨트롤러는 Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; Route의 &lt;code&gt;model()&lt;/code&gt; 메소드 의 반환 값인 단일 속성을받습니다 .</target>
        </trans-unit>
        <trans-unit id="9805ee9f09f7a6c9f18fe8f84f7390a97217c750" translate="yes" xml:space="preserve">
          <source>The controller's current model. When retrieving or modifying a controller's model, this property should be used instead of the &lt;code&gt;content&lt;/code&gt; property.</source>
          <target state="translated">컨트롤러의 현재 모델. 컨트롤러 모델을 검색하거나 수정할 때 &lt;code&gt;content&lt;/code&gt; 속성 대신이 속성을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="301f36390a7be64dbf55d036bcf24116fa60dea1" translate="yes" xml:space="preserve">
          <source>The copied object</source>
          <target state="translated">복사 된 객체</target>
        </trans-unit>
        <trans-unit id="dc497b43d9a73eae6ffff08e5aaad7d8aea85919" translate="yes" xml:space="preserve">
          <source>The current set of flags are defined below. If you want to add a new flag, in addition to the area below, you will also need to declare it in the &lt;code&gt;DS.Model&lt;/code&gt; class.</source>
          <target state="translated">현재 플래그 세트가 아래에 정의되어 있습니다. 아래 영역 외에 새 플래그를 추가하려면 &lt;code&gt;DS.Model&lt;/code&gt; 클래스 에서도 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0524bb6abfd181d72da352389fd69941fb6778cc" translate="yes" xml:space="preserve">
          <source>The currently active URL.</source>
          <target state="translated">현재 활성화 된 URL입니다.</target>
        </trans-unit>
        <trans-unit id="64c535e9f2e1008eed7eb1be8de9fd6230cf64a1" translate="yes" xml:space="preserve">
          <source>The currently active path.</source>
          <target state="translated">현재 활성 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e4b1d59e80066fe1a38250044448beb82d44ec54" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;serialize&lt;/code&gt; method will insert the model's &lt;code&gt;id&lt;/code&gt; into the route's dynamic segment (in this case, &lt;code&gt;:post_id&lt;/code&gt;) if the segment contains '_id'. If the route has multiple dynamic segments or does not contain '_id', &lt;code&gt;serialize&lt;/code&gt; will return &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt;</source>
          <target state="translated">세그먼트가 '_id'를 포함하는 경우 기본 &lt;code&gt;serialize&lt;/code&gt; 메소드는 모델의 &lt;code&gt;id&lt;/code&gt; 를 경로의 동적 세그먼트 (이 경우 &lt;code&gt;:post_id&lt;/code&gt; )에 삽입합니다. 경로에 동적 세그먼트가 여러 개 있거나 '_id'가 포함되어 있지 않으면 &lt;code&gt;serialize&lt;/code&gt; 는 &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9804540a4930794a37fbff41c2089e9b1c714b1" translate="yes" xml:space="preserve">
          <source>The default HTML tag name used for a component's DOM representation is &lt;code&gt;div&lt;/code&gt;. This can be customized by setting the &lt;code&gt;tagName&lt;/code&gt; property. The following component class:</source>
          <target state="translated">컴포넌트의 DOM 표현에 사용되는 기본 HTML 태그 이름은 &lt;code&gt;div&lt;/code&gt; 입니다. &lt;code&gt;tagName&lt;/code&gt; 속성 을 설정하여 사용자 지정할 수 있습니다 . 다음 컴포넌트 클래스 :</target>
        </trans-unit>
        <trans-unit id="ba661251bae2c58457a6583501ea31468be49e4e" translate="yes" xml:space="preserve">
          <source>The default adapter to use to communicate to a backend server or other persistence layer. This will be overridden by an application adapter if present.</source>
          <target state="translated">백엔드 서버 또는 기타 지속성 계층과 통신하는 데 사용되는 기본 어댑터입니다. 존재하는 경우 응용 프로그램 어댑터가이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d48ca495b259e7b4f0c08e2c8e0b6fc93859dce8" translate="yes" xml:space="preserve">
          <source>The default behavior for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt;&lt;code&gt;link-to&lt;/code&gt;&lt;/a&gt; is to add entries to the browser's history when transitioning between the routes. However, to replace the current entry in the browser's history you can use the &lt;code&gt;replace=true&lt;/code&gt; option:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt; &lt;code&gt;link-to&lt;/code&gt; &lt;/a&gt; 의 기본 동작 은 경로 간 전환시 브라우저 기록에 항목을 추가하는 것입니다. 그러나 브라우저 기록에서 현재 항목을 바꾸려면 &lt;code&gt;replace=true&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="028b9616eef359dc09d07d3be87a5ac87b8aea59" translate="yes" xml:space="preserve">
          <source>The default behavior is for lookup to return a singleton instance. The singleton is scoped to the container, allowing multiple containers to all have their own locally scoped singletons.</source>
          <target state="translated">기본 동작은 조회가 단일 인스턴스를 반환하는 것입니다. 싱글 톤은 컨테이너로 범위가 지정되므로 여러 컨테이너가 모두 로컬로 범위가 지정된 싱글 톤을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33cd28df250e1a3d71b927a14510954a829fa40c" translate="yes" xml:space="preserve">
          <source>The default implementation returns the records as a single group.</source>
          <target state="translated">기본 구현은 레코드를 단일 그룹으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6d55dd2f84ce398a6b7ca904972aeeb8f8ea5d4c" translate="yes" xml:space="preserve">
          <source>The default serialization would create a JSON object like:</source>
          <target state="translated">기본 직렬화는 다음과 같은 JSON 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9726fa72bad036507b0c7e1f772d49c8a42328a7" translate="yes" xml:space="preserve">
          <source>The denodified function inherits from the original function. It works in all environments, except IE 10 and below. Consequently all properties of the original function are available to you. However, any properties you change on the denodeified function won't be changed on the original function. Example:</source>
          <target state="translated">denodified 함수는 원래 함수에서 상속됩니다. IE 10 이하를 제외한 모든 환경에서 작동합니다. 결과적으로 원래 기능의 모든 속성을 사용할 수 있습니다. 그러나 denodeified 기능에서 변경 한 특성은 원래 기능에서 변경되지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a81bacb27ef7a7c4a59cca0a9ad3aa5799647431" translate="yes" xml:space="preserve">
          <source>The deprecation handler API was released in Ember 2.1. If you would like to leverage this API in a prior release of Ember you can install the &lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;ember-debug-handlers-polyfill&lt;/a&gt; addon into your project.</source>
          <target state="translated">지원 중단 처리기 API가 Ember 2.1에서 릴리스되었습니다. Ember의 이전 릴리스에서이 API를 활용하려면 &lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;ember-debug-handlers-polyfill&lt;/a&gt; 애드온을 프로젝트에 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d14be1f3c6637fd072ea31a6dbb848736f0f9b4c" translate="yes" xml:space="preserve">
          <source>The deserialized value</source>
          <target state="translated">역 직렬화 된 값</target>
        </trans-unit>
        <trans-unit id="61863b6efe342207f2c2beda0291c57e7b350c15" translate="yes" xml:space="preserve">
          <source>The easiest way to create a two-way binding is to use a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt;&lt;code&gt;computed.alias()&lt;/code&gt;&lt;/a&gt;, that specifies the path to another object.</source>
          <target state="translated">양방향 바인딩을 만드는 가장 쉬운 방법은 다른 객체의 경로를 지정 하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt; &lt;code&gt;computed.alias()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="51b9dfe652430a47b7813879322835fda06a5e1e" translate="yes" xml:space="preserve">
          <source>The easiest way to create an &lt;code&gt;Ember.Component&lt;/code&gt; is via a template. If you name a template &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt;, you will be able to use &lt;code&gt;{{my-foo}}&lt;/code&gt; in other templates, which will make an instance of the isolated component.</source>
          <target state="translated">&lt;code&gt;Ember.Component&lt;/code&gt; 를 생성하는 가장 쉬운 방법 은 템플릿을 이용하는 것 입니다. &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt; 템플리트 이름을 지정하면 다른 템플리트에서 &lt;code&gt;{{my-foo}}&lt;/code&gt; 를 사용 하여 격리 된 컴포넌트의 인스턴스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a90adc5ebc180395b92d51213f2e4db5db7c4d5" translate="yes" xml:space="preserve">
          <source>The ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing its findings.</source>
          <target state="translated">ember-cli-deprecation-workflow 애드온은 콘솔에서 사용 중단을 수집하고 결과를 나열하는 JavaScript 코드를 생성하는 명령을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c08d687a1f142539937b2a75e02478a1de2910c4" translate="yes" xml:space="preserve">
          <source>The enumerable API follows ECMAScript specifications as much as possible. This minimizes incompatibility with other libraries, and allows Ember.js to use the native browser implementations in arrays where available.</source>
          <target state="translated">열거 가능한 API는 가능한 ECMAScript 사양을 따릅니다. 이것은 다른 라이브러리와의 비 호환성을 최소화하고 Ember.js가 가능한 경우 기본 브라우저 구현을 배열로 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2f251a4ec622923c4684a280b97957e070d1f3fc" translate="yes" xml:space="preserve">
          <source>The event dispatcher is created by the application at initialization time and sets up event listeners on the DOM element described by the application's &lt;code&gt;rootElement&lt;/code&gt; property.</source>
          <target state="translated">이벤트 디스패처는 초기화시 응용 프로그램에 의해 작성되며 응용 프로그램의 &lt;code&gt;rootElement&lt;/code&gt; 특성에 의해 설명 된 DOM 요소에 이벤트 리스너를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="053c279c50f244b9eb896230e5a90c90796a9df5" translate="yes" xml:space="preserve">
          <source>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt;.</source>
          <target state="translated">위에서 설명한 이벤트 처리 예제는 하나의 이벤트 세트에 응답합니다. 내장 이벤트의 이름은 다음과 같습니다. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt; 를 사용하여 커스텀 이벤트를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b863b4625ecf29a56bcdfb71eee44abd26ee138c" translate="yes" xml:space="preserve">
          <source>The event type to be triggered.</source>
          <target state="translated">트리거 할 이벤트 유형.</target>
        </trans-unit>
        <trans-unit id="5e377f2c4a3dec86abf2ac3efcc334847d1f52b8" translate="yes" xml:space="preserve">
          <source>The exception to be raised.</source>
          <target state="translated">발생할 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2422f0ff43e6667a702a73460791a92f8d19db60" translate="yes" xml:space="preserve">
          <source>The feature to check</source>
          <target state="translated">확인하는 기능</target>
        </trans-unit>
        <trans-unit id="95787b699dfdd06e98ccefd8263560e2e6b5a8f1" translate="yes" xml:space="preserve">
          <source>The filterFunction is a function used to test records from the store to determine if they should be part of the record array.</source>
          <target state="translated">filterFunction은 상점에서 레코드를 테스트하여 레코드 배열의 일부 여야하는지 여부를 판별하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="62e163152ac939e91938ed4bba47c089f566a9f1" translate="yes" xml:space="preserve">
          <source>The final test should look as follows:</source>
          <target state="translated">최종 테스트는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="251b44a6daaf2e9098e7b6561f96f4b93ffee050" translate="yes" xml:space="preserve">
          <source>The find method is called on the model class with the value of the dynamic segment.</source>
          <target state="translated">find 메소드는 동적 세그먼트의 값으로 모델 클래스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c6ab5f4ba11276c830d14ace1931f03db22503d" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;model&lt;/code&gt;) was curried over, and the run-time argument (&lt;code&gt;event&lt;/code&gt;) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the &lt;code&gt;{{action}}&lt;/code&gt; helper, including other actions.</source>
          <target state="translated">첫 번째 인수 ( &lt;code&gt;model&lt;/code&gt; )가 커리되어 런타임 인수 ( &lt;code&gt;event&lt;/code&gt; )가 두 번째 인수가됩니다. 액션 호출은 각각 단순히 함수를 반환하기 때문에 이런 식으로 중첩 될 수 있습니다. 다른 조치를 포함하여 모든 함수를 &lt;code&gt;{{action}}&lt;/code&gt; 도우미에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed7c239cf4e865e182877517567062ddaf11cb4e" translate="yes" xml:space="preserve">
          <source>The first nested route to generate will be the index route. An index nested route works similarly to the base index route. It is the default route that renders when no route is provided. Therefore in our case, when we navigate to &lt;code&gt;/rentals&lt;/code&gt;, Ember will attempt to load the rentals index route as a nested route.</source>
          <target state="translated">생성 할 첫 번째 중첩 경로는 인덱스 경로입니다. 인덱스 중첩 경로는 기본 인덱스 경로와 유사하게 작동합니다. 경로가 제공되지 않을 때 렌더링되는 기본 경로입니다. 따라서이 경우 &lt;code&gt;/rentals&lt;/code&gt; 로 이동하면 Ember는 임대 인덱스 경로를 중첩 된 경로로로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="983c3b259f765a841e0ba8fde3f9e8cb7899878d" translate="yes" xml:space="preserve">
          <source>The first parameter is the name of the route which is used by default as the path name as well.</source>
          <target state="translated">첫 번째 매개 변수는 경로 이름으로 기본적으로 사용되는 경로의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9105fbebbf22cf85d2b2f209a6496fbe8783578b" translate="yes" xml:space="preserve">
          <source>The first parameter of the helper is the name of a component to render, as a string. So &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; is the same as using &lt;code&gt;{{blog-post}}&lt;/code&gt;.</source>
          <target state="translated">도우미의 첫 번째 매개 변수는 렌더링 할 구성 요소의 이름입니다 (문자열). 따라서 &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; 은 &lt;code&gt;{{blog-post}}&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d5209e6f0bdb73ab73f04317f2793d14718036b7" translate="yes" xml:space="preserve">
          <source>The first style of invocation is &lt;strong&gt;inline invocation&lt;/strong&gt;. This looks similar to displaying a property, but helpers accept arguments. For example:</source>
          <target state="translated">첫 번째 호출 스타일은 &lt;strong&gt;인라인 호출&lt;/strong&gt; 입니다. 이것은 속성을 표시하는 것과 비슷하지만 도우미가 인수를 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75890c317887371b09062eb2031229122ca2996b" translate="yes" xml:space="preserve">
          <source>The first thing we want to do in our new project is to remove the welcome screen. We do this by simply opening up the application template file located at &lt;code&gt;app/templates/application.hbs&lt;/code&gt;.</source>
          <target state="translated">새 프로젝트에서 가장 먼저 할 일은 시작 화면을 제거하는 것입니다. &lt;code&gt;app/templates/application.hbs&lt;/code&gt; 에있는 애플리케이션 템플릿 파일을 열면됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f64cb4a633c43e464c1ff818f86a7f51cbaf2da" translate="yes" xml:space="preserve">
          <source>The first time your application asks the store for a record, the store sees that it doesn't have a local copy and requests it from your adapter. Your adapter will go and retrieve the record from your persistence layer; typically, this will be a JSON representation of the record served from an HTTP server.</source>
          <target state="translated">응용 프로그램이 처음으로 상점에 레코드를 요청할 때 상점은 로컬 사본이없는 것을보고 어댑터에서이를 요청합니다. 어댑터는 지속성 계층에서 레코드를 검색합니다. 일반적으로 이는 HTTP 서버에서 제공되는 레코드의 JSON 표현입니다.</target>
        </trans-unit>
        <trans-unit id="bd9a731b8654e32704a346674674446e3d3a69b4" translate="yes" xml:space="preserve">
          <source>The flag status in the generated build is controlled by the &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt;&lt;code&gt;features.json&lt;/code&gt;&lt;/a&gt; file in the root of the Ember.js project. This file lists all new features and their current status.</source>
          <target state="translated">생성 된 빌드의 플래그 상태 는 Ember.js 프로젝트의 루트 에있는 &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt; &lt;code&gt;features.json&lt;/code&gt; &lt;/a&gt; 파일에 의해 제어됩니다 . 이 파일은 모든 새로운 기능과 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="eb3cef84c92085a6d2d883851701837207c0ed5e" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is currently loading data.</source>
          <target state="translated">&lt;code&gt;RecordArray&lt;/code&gt; 에 신호를 보내는 플래그 가 현재 데이터를로드 중입니다.</target>
        </trans-unit>
        <trans-unit id="53188ffd1056282eaa9b367801d327c2d664d389" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is finished loading data.</source>
          <target state="translated">&lt;code&gt;RecordArray&lt;/code&gt; 를 알리는 플래그가 데이터로드를 완료했습니다.</target>
        </trans-unit>
        <trans-unit id="39accfabc1616fbff84cfef1e2405eff54644354" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set via the helper:</source>
          <target state="translated">도우미를 통해 다음 HTML 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb79dc0afa03345796e1814d66f43dab53b2351b" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set:</source>
          <target state="translated">다음과 같은 HTML 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44fc4180b9b05e8989204eb9f584bb53e9d638f4" translate="yes" xml:space="preserve">
          <source>The following HTML would be rendered:</source>
          <target state="translated">다음 HTML이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0a3c7a9779e06c8201841fbe9265d91073f48e" translate="yes" xml:space="preserve">
          <source>The following chart is a visual representation of what takes place when the escape key is pressed in this scenario:</source>
          <target state="translated">다음 차트는이 시나리오에서 이스케이프 키를 눌렀을 때 발생하는 상황을 시각적으로 나타낸 것입니다.</target>
        </trans-unit>
        <trans-unit id="37c67db7954be266e8e6d6ff4e4e5081f2a3c808" translate="yes" xml:space="preserve">
          <source>The following code injects the &lt;code&gt;shopping-cart&lt;/code&gt; service on the &lt;code&gt;cart-contents&lt;/code&gt; component as the property &lt;code&gt;cart&lt;/code&gt;:</source>
          <target state="translated">다음 코드 는 &lt;code&gt;cart-contents&lt;/code&gt; 컴포넌트 에 &lt;code&gt;shopping-cart&lt;/code&gt; 서비스를 특성 &lt;code&gt;cart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729b7f0e23b374cb4e57a6cdd204d250859aaf3b" translate="yes" xml:space="preserve">
          <source>The following controller code:</source>
          <target state="translated">다음 컨트롤러 코드 :</target>
        </trans-unit>
        <trans-unit id="5f70fdd699bda0ef491d01141402f07249723c95" translate="yes" xml:space="preserve">
          <source>The following demonstrates how you can override both the scope and the query param URL key of a single controller query param property:</source>
          <target state="translated">다음은 단일 컨트롤러 쿼리 매개 변수 속성의 범위 및 쿼리 매개 변수 URL 키를 재정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c25fcb78f8ce32888e37289c4e3ec48b550205a2" translate="yes" xml:space="preserve">
          <source>The following equivalent default options will be applied when the Route calls &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">라우트 호출이 &lt;code&gt;render&lt;/code&gt; 될 때 다음과 같은 기본 옵션이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c4f56e0c501f86b7a8f875bd1a2f2ae5dfd1313" translate="yes" xml:space="preserve">
          <source>The following example creates a tag like &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt; 와 같은 태그를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1e094e921fd819fa5e76624b61faecd882472c2a" translate="yes" xml:space="preserve">
          <source>The following example creates markup like &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt; 과 같은 마크 업을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="afdab8293445b11ec924bd3e51d6a5d98083d81e" translate="yes" xml:space="preserve">
          <source>The following location types are currently available:</source>
          <target state="translated">현재 사용할 수있는 위치 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a04ae17d99bdb1ca3ff7d3f029873e55f621ebc" translate="yes" xml:space="preserve">
          <source>The format of your &lt;code&gt;links&lt;/code&gt; value will influence the final request URL via the &lt;code&gt;urlPrefix&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; 값 의 형식은 &lt;code&gt;urlPrefix&lt;/code&gt; 메소드 를 통해 최종 요청 URL에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="609b07ebd91a9564a1e401e69867af9f43852ebd" translate="yes" xml:space="preserve">
          <source>The full list of valid WAI-ARIA roles is available at: &lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http://www.w3.org/TR/wai-aria/roles#roles_categorization&lt;/a&gt;</source>
          <target state="translated">유효한 WAI-ARIA 역할의 전체 목록은 &lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http://www.w3.org/TR/wai-aria/roles#roles_categorization&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9511008deb941834774d3d5ef5d5eb87d148f334" translate="yes" xml:space="preserve">
          <source>The function of the subscription</source>
          <target state="translated">구독 기능</target>
        </trans-unit>
        <trans-unit id="b0cd84bb592c3813b530b12d48aa8e49154cd375" translate="yes" xml:space="preserve">
          <source>The function to be called.</source>
          <target state="translated">호출 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="082ed932b0ef334e05715d349323974d215f0f06" translate="yes" xml:space="preserve">
          <source>The function to be executed.</source>
          <target state="translated">실행될 기능.</target>
        </trans-unit>
        <trans-unit id="fb1e00c09e0f91fcfb54af8c8c11530f8722ad41" translate="yes" xml:space="preserve">
          <source>The function used to resolve the promise.</source>
          <target state="translated">약속을 해결하는 데 사용되는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="79464200d9e3ddbdb2fe8367a586a4583bb4305d" translate="yes" xml:space="preserve">
          <source>The globals provided by some assets (like &lt;code&gt;moment&lt;/code&gt; in the below example) can be used in your application without the need to &lt;code&gt;import&lt;/code&gt; them. Provide the asset path as the first and only argument.</source>
          <target state="translated">(같은 일부 자산을 제공하는 전역 &lt;code&gt;moment&lt;/code&gt; 예를 아래에)을 할 필요없이 응용 프로그램에서 사용할 수있는 &lt;code&gt;import&lt;/code&gt; 를. 자산 경로를 첫 번째이자 유일한 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="933a1192be634af8a21616acc066822633b90230" translate="yes" xml:space="preserve">
          <source>The goal of initializers should be to register dependencies and injections. This phase runs once. Because these initializers may load code, they are allowed to defer application readiness and advance it. If you need to access the container or store you should use an InstanceInitializer that will be run after all initializers and therefore after all code is loaded and the app is ready.</source>
          <target state="translated">이니셜 라이저의 목표는 의존성 및 주입을 등록하는 것입니다. 이 단계는 한 번만 실행됩니다. 이러한 이니셜 라이저는 코드를로드 할 수 있으므로 응용 프로그램 준비를 연기하고 진행할 수 있습니다. 컨테이너 또는 저장소에 액세스해야하는 경우 모든 초기화 프로그램 이후에 실행되므로 모든 코드가로드되고 앱이 준비된 후에 실행될 InstanceInitializer를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c39dbd4973fde26a84eeab934b9541d4d9d411" translate="yes" xml:space="preserve">
          <source>The handler function takes the following arguments:</source>
          <target state="translated">핸들러 함수는 다음 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9976137b5fc46c82802f55ca4a18f19ec76f045" translate="yes" xml:space="preserve">
          <source>The hash of enabled Canary features. Add to this, any canary features before creating your application.</source>
          <target state="translated">활성화 된 카나리아 기능의 해시. 응용 프로그램을 만들기 전에 모든 카나리아 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f1f5d4f4f7e10915f4694e587719c74a6240d5a1" translate="yes" xml:space="preserve">
          <source>The hash that you pass to the &lt;code&gt;meta()&lt;/code&gt; function will be saved on the computed property descriptor under the &lt;code&gt;_meta&lt;/code&gt; key. Ember runtime exposes a public API for retrieving these values from classes, via the &lt;code&gt;metaForProperty()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;meta()&lt;/code&gt; 함수에 전달한 해시 는 계산 된 속성 설명자에 &lt;code&gt;_meta&lt;/code&gt; 키 아래에 저장 됩니다. Ember 런타임은 &lt;code&gt;metaForProperty()&lt;/code&gt; 함수 를 통해 클래스에서 이러한 값을 검색하기위한 공개 API를 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="ca21eb1ac808b66726237aab6478d493b882f2e4" translate="yes" xml:space="preserve">
          <source>The helper allows some user events to send actions.</source>
          <target state="translated">도우미는 일부 사용자 이벤트가 작업을 보낼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9bc08f7454fc33317953aa1d0764e69128fbd18" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is send when the user presses the return key.</source>
          <target state="translated">도우미는 사용자 이벤트를 기반으로 여러 작업을 보낼 수 있습니다. action 특성은 사용자가 리턴 키를 누를 때 전송되는 조치를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="467dd7598d6007e1305b827d35702192c6fb827f" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is sent when the user presses the return key.</source>
          <target state="translated">도우미는 사용자 이벤트를 기반으로 여러 작업을 보낼 수 있습니다. action 특성은 사용자가 리턴 키를 누를 때 전송되는 조치를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fd3ae270075b46e8c72806c87f05194a68ec4531" translate="yes" xml:space="preserve">
          <source>The helper function</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="a7b07a977cc772121d830f7df8058bbfdf781828" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter.</source>
          <target state="translated">도우미 응용 프로그램은 항상 현재 응용 프로그램을 첫 번째 매개 변수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d352679de326e446da8bcf7ae02cdf1d2b388cc3" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter. Other parameters, such as assert, need to be provided when calling the helper. Helpers need to be registered prior to calling &lt;code&gt;startApp&lt;/code&gt;, but ember-cli will take care of it for you.</source>
          <target state="translated">도우미 응용 프로그램은 항상 현재 응용 프로그램을 첫 번째 매개 변수로 사용하여 호출됩니다. 도우미를 호출 할 때는 assert와 같은 다른 매개 변수를 제공해야합니다. &lt;code&gt;startApp&lt;/code&gt; 를 호출하기 전에 헬퍼를 등록해야 하지만 ember-cli가이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="20ee84ece384b1c7bf0a5f88c860139387c74bc6" translate="yes" xml:space="preserve">
          <source>The helper to remove.</source>
          <target state="translated">헬퍼를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d01c5bd098982ca73ec7c55be9abde28b9b34a69" translate="yes" xml:space="preserve">
          <source>The hierarchy of valid states that ship with ember data looks like this:</source>
          <target state="translated">불씨 데이터와 함께 제공되는 유효한 상태의 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6e2f5503b24777429c126a35c56b33d77b5055f" translate="yes" xml:space="preserve">
          <source>The id of the record in this belongsTo relationship.</source>
          <target state="translated">이 belongTo 관계의 레코드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="8d93476bc0286bac3afbab171f7e9f39fc33828a" translate="yes" xml:space="preserve">
          <source>The id of the record.</source>
          <target state="translated">레코드의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="71fe696ada77a1df388294168858e15ad016bb74" translate="yes" xml:space="preserve">
          <source>The index of the item to return.</source>
          <target state="translated">반환 할 항목의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="bf6c6f036f009d345c5f9f4a01b236f9acff2d54" translate="yes" xml:space="preserve">
          <source>The index to retrieve.</source>
          <target state="translated">검색 할 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="a59b1536c7b56b8fd58d1ea97c5500491fd87390" translate="yes" xml:space="preserve">
          <source>The initial URL to navigate to</source>
          <target state="translated">탐색 할 초기 URL</target>
        </trans-unit>
        <trans-unit id="6ec073e684d780eaf847bfcf50ff16099c381dae" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;if&lt;/code&gt; helper conditionally renders a single property or string.</source>
          <target state="translated">인라인이 &lt;code&gt;if&lt;/code&gt; 도우미 조건부 하나의 속성 또는 문자열을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="d6d29959063e476cd6d120667a761a34e0a62dbb" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;unless&lt;/code&gt; helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is falsy, the second argument will be displayed, otherwise, the third argument will be displayed</source>
          <target state="translated">도우미가 조건 적으로 단일 속성 또는 문자열을 렌더링 &lt;code&gt;unless&lt;/code&gt; 인라인 이 도우미는 삼항 연산자처럼 작동합니다. 첫 번째 속성이 거짓이면 두 번째 인수가 표시되고, 그렇지 않으면 세 번째 인수가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="875191874130e97e6feff5b21de2bc9eb0a9019c" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;checkbox&lt;/code&gt;.</source>
          <target state="translated">내부 클래스는 경우 텍스트 입력을 만드는 데 사용 &lt;code&gt;{{input}}&lt;/code&gt; 도우미가 함께 사용되는 &lt;code&gt;type&lt;/code&gt; 의 &lt;code&gt;checkbox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdad83afa3d51d43a413c1abadbd70ea9c1b3b9" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;text&lt;/code&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">내부 클래스 때 문자 입력을 만드는 데 사용 &lt;code&gt;{{input}}&lt;/code&gt; 헬퍼 함께 사용되는 &lt;code&gt;type&lt;/code&gt; 의 &lt;code&gt;text&lt;/code&gt; . 사용법에 대한 자세한 내용 은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d607ba34fe18795114b4f433109ab02b90bb0adf" translate="yes" xml:space="preserve">
          <source>The internal class used to create textarea element when the &lt;code&gt;{{textarea}}&lt;/code&gt; helper is used.</source>
          <target state="translated">&lt;code&gt;{{textarea}}&lt;/code&gt; 헬퍼가 사용될 때 textarea 요소를 작성하는 데 사용되는 내부 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="8d750dea4a93a39d4b9db6798a523e5e15dcbad1" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;{{if}}&lt;/code&gt; is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;{{unless}}&lt;/code&gt;&lt;/a&gt;, which can be used in the same three styles of invocation. For example, this template only shows an amount due when the user has not paid:</source>
          <target state="translated">&lt;code&gt;{{if}}&lt;/code&gt; 의 역 은 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;{{unless}}&lt;/code&gt; &lt;/a&gt; 이며, 동일한 세 가지 스타일의 호출에서 사용할 수 있습니다. 예를 들어,이 템플릿은 사용자가 지불하지 않았을 때의 금액 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d45de9e199e155b8777a207a094e041487a424da" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;detail&lt;/code&gt; provides a textual description of the problem. Alternatively, the key &lt;code&gt;title&lt;/code&gt; can be used for the same purpose.</source>
          <target state="translated">주요 &lt;code&gt;detail&lt;/code&gt; 은 문제점에 대한 텍스트 설명을 제공합니다. 또는 키 &lt;code&gt;title&lt;/code&gt; 을 같은 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b7555d5282e96bd6e24cc32840ea3424b4844f1" translate="yes" xml:space="preserve">
          <source>The key to observe</source>
          <target state="translated">관찰의 열쇠</target>
        </trans-unit>
        <trans-unit id="bda81920321dffb71626e245008601afdbbd6199" translate="yes" xml:space="preserve">
          <source>The key to set</source>
          <target state="translated">설정하는 열쇠</target>
        </trans-unit>
        <trans-unit id="a6ee319d67963224e6cc6a893a3f09344964cfb2" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this belongs-to relationship.</source>
          <target state="translated">Ember Data 링크는이 소속 관계를 가져 오거나 다시로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df6a49096075b75f24d4bda7b0d30a1279be1940" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this has-many relationship.</source>
          <target state="translated">Ember Data 링크는이 has-many 관계를 가져 오거나 다시로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4639de6bdd5d693c4936a26db0f36475d3d91c" translate="yes" xml:space="preserve">
          <source>The loading state of this array</source>
          <target state="translated">이 배열의 로딩 상태</target>
        </trans-unit>
        <trans-unit id="c19c7109c687fbc9fcd386c8c0b1f5cabb138c0a" translate="yes" xml:space="preserve">
          <source>The location in the cache has been &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt;&lt;code&gt;camelized&lt;/code&gt;&lt;/a&gt; (line 30), so that it may be used as a key to look up our element. This matches the behavior in &lt;code&gt;getMapElement&lt;/code&gt; when city has not yet been cached.</source>
          <target state="translated">캐시의 위치는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt; &lt;code&gt;camelized&lt;/code&gt; &lt;/a&gt; (30 행), 요소를 찾는 키로 사용될 수 있습니다. 도시가 아직 캐시되지 않은 경우 &lt;code&gt;getMapElement&lt;/code&gt; 의 동작과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="a788518ddcd9fbbee4defbf1d862f0e936c78c17" translate="yes" xml:space="preserve">
          <source>The mapped array.</source>
          <target state="translated">매핑 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="18d8bcb9bddd16b3086b442996831dcaa439d784" translate="yes" xml:space="preserve">
          <source>The meta data for the belongs-to relationship.</source>
          <target state="translated">소속 관계에 대한 메타 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="a85e08823b46b35e1ce946c3b00a085d8f560820" translate="yes" xml:space="preserve">
          <source>The meta information for the belongs-oo relationship.</source>
          <target state="translated">belongs-oo 관계에 대한 메타 정보.</target>
        </trans-unit>
        <trans-unit id="34f2833b8151391b99f9c680911406631b2b6fdd" translate="yes" xml:space="preserve">
          <source>The meta information for the has-many relationship.</source>
          <target state="translated">has-many 관계에 대한 메타 정보.</target>
        </trans-unit>
        <trans-unit id="49369103b0464b44493cf84cb646510c7e94536a" translate="yes" xml:space="preserve">
          <source>The method name to check for</source>
          <target state="translated">확인할 메소드 이름</target>
        </trans-unit>
        <trans-unit id="0263e067489f60c9e685cbc3d24f7b8e48689a36" translate="yes" xml:space="preserve">
          <source>The method to invoke</source>
          <target state="translated">호출하는 방법</target>
        </trans-unit>
        <trans-unit id="19540d3f9bb05ef81877198fb53c8953af81b641" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target at the time the method is invoked.</source>
          <target state="translated">호출 할 메소드입니다. 문자열을 전달하면 메서드가 호출 될 때 대상에서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="0de0091a090dc150acbc0fbf24a9397407d002b0" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target object at the time the scheduled item is invoked allowing you to change the target function.</source>
          <target state="translated">호출 할 메소드입니다. 문자열을 전달하면 예약 된 항목이 호출 될 때 대상 객체에서 해결되어 대상 기능을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3506db6058e732c49d0d84aa3928be98489273e0" translate="yes" xml:space="preserve">
          <source>The method to invoke. May be a function or a string. If you pass a string then it will be looked up on the passed target.</source>
          <target state="translated">호출 할 메소드입니다. 함수 또는 문자열 일 수 있습니다. 문자열을 전달하면 전달 된 대상에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d11f6516cbacb45fdea866478b595ee9ed7bf1d3" translate="yes" xml:space="preserve">
          <source>The methods likely to be overridden are:</source>
          <target state="translated">재정의 될 가능성이있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb3c70dade0bce9d1ab411df82e04ea62f4ddfac" translate="yes" xml:space="preserve">
          <source>The methods of this object are designed to be easy to override in a subclass. For example, you could enhance how a template is resolved like so:</source>
          <target state="translated">이 객체의 메소드는 서브 클래스에서 쉽게 오버라이드되도록 설계되었습니다. 예를 들어 템플릿을 다음과 같이 해결하는 방법을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9047c74c1590bc009ee5e6df824e3a60a2c8e26" translate="yes" xml:space="preserve">
          <source>The model class is determined from the segment (&lt;code&gt;post_id&lt;/code&gt;'s class is &lt;code&gt;App.Post&lt;/code&gt;)</source>
          <target state="translated">모델 클래스는 세그먼트에서 결정됩니다 ( &lt;code&gt;post_id&lt;/code&gt; 의 클래스는 &lt;code&gt;App.Post&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="5da58253b88e1c437a81d76ece8cc0c89fc0db69" translate="yes" xml:space="preserve">
          <source>The model class that all Ember Data records descend from. This is the public API of Ember Data models. If you are using Ember Data in your application, this is the class you should use. If you are working on Ember Data internals, you most likely want to be dealing with &lt;code&gt;InternalModel&lt;/code&gt;</source>
          <target state="translated">모든 Ember Data 레코드의 모델 클래스입니다. Ember Data 모델의 공개 API입니다. 응용 프로그램에서 Ember Data를 사용하는 경우이 클래스를 사용해야합니다. Ember Data 내부에서 작업하는 경우 &lt;code&gt;InternalModel&lt;/code&gt; 을 다루고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e351f80cd5556cb6da014791c372d237924a3b0" translate="yes" xml:space="preserve">
          <source>The model for the &lt;code&gt;post&lt;/code&gt; route is &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; 경로 의 모델 은 &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61a80d68a8a250e49493ed6f67e0f4faa9238b3d" translate="yes" xml:space="preserve">
          <source>The model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt;) of an error substate are not called. Only the &lt;code&gt;setupController&lt;/code&gt; method of the error substate is called with the &lt;code&gt;error&lt;/code&gt; as the model. See example below:</source>
          <target state="translated">오류 하위 상태 의 모델 후크 ( &lt;code&gt;beforeModel&lt;/code&gt; , &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; )는 호출되지 않습니다. 오류 하위 상태 의 &lt;code&gt;setupController&lt;/code&gt; 메소드 만 &lt;code&gt;error&lt;/code&gt; 를 모델로 호출 합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19ae229adfd578f13d92ff0a6a38ca5deaa02ad7" translate="yes" xml:space="preserve">
          <source>The model name.</source>
          <target state="translated">모델명.</target>
        </trans-unit>
        <trans-unit id="280c3aad18626cc5e1384613f6c69059889e22fc" translate="yes" xml:space="preserve">
          <source>The model's relationships as a map, keyed on the type of the relationship. The value of each entry is an array containing a descriptor for each relationship with that type, describing the name of the relationship as well as the type.</source>
          <target state="translated">관계 유형에 따라 맵으로 모델의 관계. 각 항목의 값은 해당 유형과의 각 관계에 대한 설명자를 포함하는 배열이며 관계 이름과 유형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0e3568f7b5ea35bae50803475ef2f179bff0fad" translate="yes" xml:space="preserve">
          <source>The modelClass represented by this record array.</source>
          <target state="translated">이 레코드 배열이 나타내는 modelClass</target>
        </trans-unit>
        <trans-unit id="06574cdcebf2b12553ee5033ae390a06647355df" translate="yes" xml:space="preserve">
          <source>The most common case for using the run loop is integrating with a non-Ember API that includes some sort of asynchronous callback. For example:</source>
          <target state="translated">실행 루프를 사용하는 가장 일반적인 경우는 일종의 비동기 콜백을 포함하는 비 Ember API와 통합하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cacb8b5741c18afe5abd31963d74c05c17355b34" translate="yes" xml:space="preserve">
          <source>The most common place you'll want to access &lt;code&gt;modelName&lt;/code&gt; is in your serializer's &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; method. For example, to change payload keys to underscore (instead of dasherized), you might use the following code:</source>
          <target state="translated">&lt;code&gt;modelName&lt;/code&gt; 에 액세스하려는 가장 일반적인 장소 는 시리얼 라이저의 &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; 메소드입니다. 예를 들어, 대시 보드 대신 페이로드 키를 밑줄로 변경하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4860165ddeb1c56516173150ded5daec90a22733" translate="yes" xml:space="preserve">
          <source>The name of a route. In this example, it would be &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;photos&lt;/code&gt;, or &lt;code&gt;photos.edit&lt;/code&gt;.</source>
          <target state="translated">경로의 이름입니다. 이 예에서는 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;photos&lt;/code&gt; 또는 &lt;code&gt;photos.edit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f70391ad509d6330a846870500a48929f3fe644d" translate="yes" xml:space="preserve">
          <source>The name of the controller to associate with this route.</source>
          <target state="translated">이 라우트와 연관시킬 컨트롤러의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8a0f4ba13feddd8f7a0fcb578c4a64ee25577bba" translate="yes" xml:space="preserve">
          <source>The name of the currently active route.</source>
          <target state="translated">현재 활성화 된 경로의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2d5cd10d5efb705d95ff6ef881164cb30052e176" translate="yes" xml:space="preserve">
          <source>The name of the event</source>
          <target state="translated">행사 명</target>
        </trans-unit>
        <trans-unit id="79193a57dbbc3246321cf5ba9ea7e09896c27a92" translate="yes" xml:space="preserve">
          <source>The name of the helper method to add.</source>
          <target state="translated">추가 할 헬퍼 메소드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0be317d734b30c2e8a916f8992d44b13a519d341" translate="yes" xml:space="preserve">
          <source>The name of the model type for this payload</source>
          <target state="translated">이 페이로드에 대한 모델 유형의 이름</target>
        </trans-unit>
        <trans-unit id="48937d3df342f8b3c9377985edf9ceb5b1837454" translate="yes" xml:space="preserve">
          <source>The name of the property to decrement</source>
          <target state="translated">감액 할 자산의 이름</target>
        </trans-unit>
        <trans-unit id="a664383b45acf8957aaf6e6f496db9828833977d" translate="yes" xml:space="preserve">
          <source>The name of the property to increment</source>
          <target state="translated">증분 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="8a46946ba08b63ffb9945d5218fd4eaab85e6281" translate="yes" xml:space="preserve">
          <source>The name of the property to retrieve</source>
          <target state="translated">검색 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="645bc5da9840b9064b59ef1eef330781affe8068" translate="yes" xml:space="preserve">
          <source>The name of the property to toggle</source>
          <target state="translated">토글 할 속성의 이름</target>
        </trans-unit>
        <trans-unit id="5fb100cec0ff90d54ebe800238fc00ef6238601d" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'</source>
          <target state="translated">스케줄 할 큐의 이름입니다. 기본 대기열은 'sync'및 'actions'입니다.</target>
        </trans-unit>
        <trans-unit id="4c90a724a69d75c22285140dd18e22630ce627af" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'.</source>
          <target state="translated">스케줄 할 큐의 이름입니다. 기본 대기열은 'sync'및 'actions'입니다.</target>
        </trans-unit>
        <trans-unit id="92bd55fef05773932c03eea0113227b4aea76072" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;id&quot;</source>
          <target state="translated">원격 유형의 이름입니다. &quot;link&quot;또는 &quot;id&quot;여야합니다.</target>
        </trans-unit>
        <trans-unit id="a7278ab5074a42a98d664c4226440fce451e40e3" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;ids&quot;</source>
          <target state="translated">원격 유형의 이름입니다. &quot;link&quot;또는 &quot;ids&quot;여야합니다.</target>
        </trans-unit>
        <trans-unit id="15f44cca7344c2cf48a11e2ee934769fefd135d2" translate="yes" xml:space="preserve">
          <source>The name of the route, defined by the router, is &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">라우터가 정의한 경로 이름은 &lt;code&gt;post&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a86bad24be595b560f010d3688c6353e6a3adf" translate="yes" xml:space="preserve">
          <source>The name of the route, dot-delimited.</source>
          <target state="translated">경로로 구분 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="289954f9d601b7db9c6b62df2307ce4028bd72f5" translate="yes" xml:space="preserve">
          <source>The name of the template to render minus the leading underscore.</source>
          <target state="translated">밑줄을 뺀 렌더링 할 템플릿의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="585502711f2ed284be4b7d4f4cbfdd64b80f43da" translate="yes" xml:space="preserve">
          <source>The name of the template to use by default when rendering this routes template.</source>
          <target state="translated">이 경로 템플릿을 렌더링 할 때 기본적으로 사용할 템플릿 이름입니다.</target>
        </trans-unit>
        <trans-unit id="66bd3365f2c2e07363112e9b122a98da62e8cf5e" translate="yes" xml:space="preserve">
          <source>The named arguments to the helper</source>
          <target state="translated">도우미에 대한 명명 된 주장</target>
        </trans-unit>
        <trans-unit id="a509b315f0cde9d1bc56906fc1ff01f0fa7cd5eb" translate="yes" xml:space="preserve">
          <source>The names are bound in the order that they are passed to &lt;code&gt;yield&lt;/code&gt; in the component template.</source>
          <target state="translated">이름은 구성 요소 템플릿에서 &lt;code&gt;yield&lt;/code&gt; 되도록 전달 된 순서대로 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="af735066725f72033af215f7de9ba3c390ea1309" translate="yes" xml:space="preserve">
          <source>The nested helper is called first returning &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; only if &lt;code&gt;isFueled&lt;/code&gt; is true. Then the inline expression is called, rendering the nested helper's value (&lt;code&gt;&quot;zoooom&quot;&lt;/code&gt;) only if &lt;code&gt;isFast&lt;/code&gt; is true.</source>
          <target state="translated">중첩 된 도우미는 &lt;code&gt;isFueled&lt;/code&gt; 가 true 인 경우에만 먼저 &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; 을 반환 합니다. 그런 다음 &lt;code&gt;isFast&lt;/code&gt; 가 true 인 경우에만 중첩 된 도우미 값 ( &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; )을 렌더링하여 인라인 표현식이 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1a53ba45425a490db9af03715c5bdb612eaf800" translate="yes" xml:space="preserve">
          <source>The nested keys &lt;code&gt;source.pointer&lt;/code&gt; detail which specific element of the request data was invalid.</source>
          <target state="translated">중첩 된 키 &lt;code&gt;source.pointer&lt;/code&gt; 는 요청 데이터의 특정 요소가 유효하지 않은 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6c12d2d252b58333d9ab6aaa11b78422d2a1172e" translate="yes" xml:space="preserve">
          <source>The new owner object of the object instance.</source>
          <target state="translated">객체 인스턴스의 새로운 소유자 객체.</target>
        </trans-unit>
        <trans-unit id="0086db850d74927843eccf283540af44ecddc2fe" translate="yes" xml:space="preserve">
          <source>The new property value</source>
          <target state="translated">새로운 속성 값</target>
        </trans-unit>
        <trans-unit id="7f13234869d6044bbe39065b2ac29afdf278e2d5" translate="yes" xml:space="preserve">
          <source>The normal behavior for a function defined in &lt;code&gt;actions&lt;/code&gt; does not receive the browser event as an argument. So, the function definition for the action cannot define an event parameter. The following example demonstrates the default behavior using an action.</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 정의 된 함수의 정상적인 동작 은 브라우저 이벤트를 인수로받지 않습니다. 따라서 조치에 대한 함수 정의는 이벤트 매개 변수를 정의 할 수 없습니다. 다음 예제는 조치를 사용하여 기본 작동을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba645aaa52d49d720b744b7458d92f0fa898b311" translate="yes" xml:space="preserve">
          <source>The normalized JSON format that Ember Data expects is a &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document with a couple of additional restrictions.</source>
          <target state="translated">Ember Data가 기대하는 정규화 된 JSON 형식 은 몇 가지 추가 제한 이있는 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; 문서입니다.</target>
        </trans-unit>
        <trans-unit id="7c8de9de7d8715fcd640ec12ea5f6988255f2d0e" translate="yes" xml:space="preserve">
          <source>The normalized JSON object that Ember Data expects a serializer to return looks like this:</source>
          <target state="translated">Ember Data가 serializer가 리턴 할 것으로 예상되는 정규화 된 JSON 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00b1abab6fd9ec65b4425bed0a462ed09048b6e0" translate="yes" xml:space="preserve">
          <source>The normalized payload</source>
          <target state="translated">정규화 된 페이로드</target>
        </trans-unit>
        <trans-unit id="a349a314b9df21dfbe3354d6dd9d45d18d122cff" translate="yes" xml:space="preserve">
          <source>The number of items that were added. If you pass `null` assumes 0.</source>
          <target state="translated">추가 된 항목 수 null을 전달하면 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2d2399ceba6066f06edc5df6a7ec02fa87dba439" translate="yes" xml:space="preserve">
          <source>The number of items that were removed. If you pass `null` assumes 0</source>
          <target state="translated">제거 된 항목 수입니다. null을 전달하면 0을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="91de528748ecbc74aef2c6d96b0c6e4f03f6131b" translate="yes" xml:space="preserve">
          <source>The number of items that will be added. If you pass `null` assumes 0.</source>
          <target state="translated">추가 할 항목 수입니다. null을 전달하면 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="975c27e833e6ea26acbcf63ae5b7ecc849744c75" translate="yes" xml:space="preserve">
          <source>The number of items that will be removed. If you pass `null` assumes 0</source>
          <target state="translated">제거 할 항목 수입니다. null을 전달하면 0을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="639768cbeb0d904ac01029f55e97c377a305a71d" translate="yes" xml:space="preserve">
          <source>The object containing named arguments is passed as the second argument to the helper function. Here is our example from above, updated to support the optional &lt;code&gt;sign&lt;/code&gt; option:</source>
          <target state="translated">명명 된 인수를 포함하는 객체는 도우미 함수에 두 번째 인수로 전달됩니다. 선택적 &lt;code&gt;sign&lt;/code&gt; 옵션 을 지원하도록 업데이트 된 위의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c51a687fc71aeecf9c4dd958d6df740581650633" translate="yes" xml:space="preserve">
          <source>The object observing the array.</source>
          <target state="translated">배열을 관찰하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1f67ed68402a22d74098c4257ec3b53cafc15f90" translate="yes" xml:space="preserve">
          <source>The object returned from &lt;code&gt;RSVP.defer&lt;/code&gt; is a plain object with three properties:</source>
          <target state="translated">&lt;code&gt;RSVP.defer&lt;/code&gt; 에서 반환 된 개체는 세 가지 속성을 가진 일반 개체입니다.</target>
        </trans-unit>
        <trans-unit id="dcce5060e65cd2c99b0f4c620ad0472078d080ff" translate="yes" xml:space="preserve">
          <source>The object stays intact until the end of the run loop at which point the &lt;code&gt;isDestroyed&lt;/code&gt; flag is set.</source>
          <target state="translated">&lt;code&gt;isDestroyed&lt;/code&gt; 플래그가 설정 되는 시점에서 실행 루프가 끝날 때까지 객체는 그대로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="95c8a20f0925b5bbf96fad0499bac57039d137a8" translate="yes" xml:space="preserve">
          <source>The object to add to the enumerable.</source>
          <target state="translated">열거 형에 추가 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3cf4a0d87f7ef69ab445296f735a615e0fc9dd1e" translate="yes" xml:space="preserve">
          <source>The object to assign into</source>
          <target state="translated">할당 할 객체</target>
        </trans-unit>
        <trans-unit id="8af03bf022efd9a0cec5228d3be213b9c85f758e" translate="yes" xml:space="preserve">
          <source>The object to check for the method</source>
          <target state="translated">메소드를 확인할 객체</target>
        </trans-unit>
        <trans-unit id="0955c243cfd3d12d78e568b378af83363f51f222" translate="yes" xml:space="preserve">
          <source>The object to clone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bee534497a07212f93576f4aad1e60752a86d9" translate="yes" xml:space="preserve">
          <source>The object to copy properties from</source>
          <target state="translated">속성을 복사 할 객체</target>
        </trans-unit>
        <trans-unit id="65d2fc606502a1327b27b00711f4cf8c80ff80d1" translate="yes" xml:space="preserve">
          <source>The object to merge into</source>
          <target state="translated">병합 할 객체</target>
        </trans-unit>
        <trans-unit id="e4f8472045258fdd0fca12c9ca54919b2134defc" translate="yes" xml:space="preserve">
          <source>The object to modify.</source>
          <target state="translated">수정할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="79abb60263af3837b02a264e27ebb51b2ad3b831" translate="yes" xml:space="preserve">
          <source>The object to remove from the enumerable.</source>
          <target state="translated">열거 가능한 객체에서 제거 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="01c87d6a0a7d961661808d6108688f7202e3182f" translate="yes" xml:space="preserve">
          <source>The object to retrieve from.</source>
          <target state="translated">검색 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2bb20788eae84e07081d526563f29dae4b083856" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
          <target state="translated">검색 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="85154a5e735c921ec2b690de03758de42871ced1" translate="yes" xml:space="preserve">
          <source>The object to set</source>
          <target state="translated">설정할 객체</target>
        </trans-unit>
        <trans-unit id="c3f77d96cdc8b56e6910e3df6d5a9f1c5613f0e4" translate="yes" xml:space="preserve">
          <source>The object to test</source>
          <target state="translated">테스트 할 객체</target>
        </trans-unit>
        <trans-unit id="2bf3733b3229286b376b10082612e1163e376d99" translate="yes" xml:space="preserve">
          <source>The object to which actions from the view should be sent.</source>
          <target state="translated">뷰에서 조치를 전송해야하는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="dd986381270f07f0062f1ef0c9b835aa255c1311" translate="yes" xml:space="preserve">
          <source>The objects to copy properties from</source>
          <target state="translated">속성을 복사 할 객체</target>
        </trans-unit>
        <trans-unit id="372e877cd43ae664673ebc043c2112a916e22b72" translate="yes" xml:space="preserve">
          <source>The observer object.</source>
          <target state="translated">관찰자 객체.</target>
        </trans-unit>
        <trans-unit id="711d7a87524d1dd84793229cd8b47d431d1d8180" translate="yes" xml:space="preserve">
          <source>The options passed into the &lt;code&gt;DS.attr&lt;/code&gt; function when the attribute is declared on the model is also available in the transform.</source>
          <target state="translated">모델에서 속성이 선언 될 때 &lt;code&gt;DS.attr&lt;/code&gt; 함수에 전달 된 옵션 도 변환에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f866c519a5e8c630cd9a5e6dd63f20316368ea" translate="yes" xml:space="preserve">
          <source>The options to be passed to jQuery.Event.</source>
          <target state="translated">jQuery.Event에 전달할 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="56c3cd7a661678595c73eb270a9318b5eac13978" translate="yes" xml:space="preserve">
          <source>The other major benefit to the above approach is that &lt;code&gt;run.next&lt;/code&gt; introduces an element of non-determinism, which can make things much harder to test, due to its reliance on &lt;code&gt;setTimeout&lt;/code&gt;; it's much harder to guarantee the order of scheduled operations when they are scheduled outside of the current run loop, i.e. with &lt;code&gt;run.next&lt;/code&gt;.</source>
          <target state="translated">위의 접근 방식의 다른 주요 이점은 &lt;code&gt;run.next&lt;/code&gt; 가 비 결정적 요소를 도입하여 &lt;code&gt;setTimeout&lt;/code&gt; 에 의존하기 때문에 테스트하기가 훨씬 어려워진다는 것입니다 . 현재 실행 루프 외부에서 예약 된 경우 (예 : &lt;code&gt;run.next&lt;/code&gt; ) 예약 된 작업의 순서를 보장하는 것이 훨씬 어렵 습니다 .</target>
        </trans-unit>
        <trans-unit id="c14211cb494d4ea352d68e2ab9fb3c84186d8bce" translate="yes" xml:space="preserve">
          <source>The other one is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;&lt;code&gt;replaceWith()&lt;/code&gt;&lt;/a&gt; which works the same way as &lt;code&gt;transitionTo()&lt;/code&gt;. The only difference between them is how they manage history. &lt;code&gt;replaceWith()&lt;/code&gt; substitutes the current route entry and replaces it with that of the route we are redirecting to, while &lt;code&gt;transitionTo()&lt;/code&gt; leaves the entry for the current route and creates a new one for the redirection.</source>
          <target state="translated">다른 하나는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt; &lt;code&gt;replaceWith()&lt;/code&gt; &lt;/a&gt; 이며 &lt;code&gt;transitionTo()&lt;/code&gt; 와 같은 방식으로 작동합니다 . 그들 사이의 유일한 차이점은 그들이 역사를 관리하는 방법입니다. &lt;code&gt;replaceWith()&lt;/code&gt; 는 현재 경로 항목을 대체하고 경로를 리디렉션하려는 경로의 항목으로 바꿉니다. &lt;code&gt;transitionTo()&lt;/code&gt; 는 현재 경로에 대한 항목을 남겨두고 리디렉션을위한 새 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="acc6d06fca4a644df1fa4d9b90eb32abb2585f8e" translate="yes" xml:space="preserve">
          <source>The output of the above would be:</source>
          <target state="translated">위의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ab0c6bf981d7228ae87a74eeb932536510cc267" translate="yes" xml:space="preserve">
          <source>The parameter supplied to &lt;code&gt;partial&lt;/code&gt; can also be a path to a property containing a template name, e.g.:</source>
          <target state="translated">&lt;code&gt;partial&lt;/code&gt; 에 제공되는 매개 변수 는 템플릿 이름이 포함 된 속성의 경로 일 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="efd37fb222c7e149dff6b49705240fe10a539217" translate="yes" xml:space="preserve">
          <source>The parameters can be referred to just like named parameters:</source>
          <target state="translated">매개 변수는 명명 된 매개 변수와 같이 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a227f12b3522d68730e7b36f0fc78aec0552a35a" translate="yes" xml:space="preserve">
          <source>The parameters can then be referred to by enumerating over the list:</source>
          <target state="translated">그런 다음 목록을 열거하여 매개 변수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fc8fe2689da3394272f78c6f0c5ad6c77884c6" translate="yes" xml:space="preserve">
          <source>The parent engine instance.</source>
          <target state="translated">부모 엔진 인스턴스</target>
        </trans-unit>
        <trans-unit id="c4808789947bb1b66c38cf5e3bcb54bc1949343c" translate="yes" xml:space="preserve">
          <source>The passed in hash</source>
          <target state="translated">해시로 전달</target>
        </trans-unit>
        <trans-unit id="15aed930cca97a392fc79410e1ca9b8700445feb" translate="yes" xml:space="preserve">
          <source>The passed value</source>
          <target state="translated">전달 된 값</target>
        </trans-unit>
        <trans-unit id="91af4f77ef8ac669f3229c88e3020c84a9befbfd" translate="yes" xml:space="preserve">
          <source>The path to the 'from' side of the binding. Must be relative to obj or a global path.</source>
          <target state="translated">바인딩의 '보낸 사람'쪽의 경로입니다. obj 또는 전역 경로에 상대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9f763dddcc9c776652d4d1ccb6796bf300cbcd8" translate="yes" xml:space="preserve">
          <source>The path to the 'to' side of the binding. Must be relative to obj.</source>
          <target state="translated">바인딩의 'to'쪽에 대한 경로입니다. obj에 상대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3646b2c1a754bb29df7ef8518480d66f2cd86f09" translate="yes" xml:space="preserve">
          <source>The positional arguments to the helper</source>
          <target state="translated">도우미에 대한 위치 주장</target>
        </trans-unit>
        <trans-unit id="9b2ab9413880d940f49d12c1781a196be650c645" translate="yes" xml:space="preserve">
          <source>The post's comments would then be available in your template as &lt;code&gt;model.comments&lt;/code&gt;.</source>
          <target state="translated">그런 다음 게시물의 댓글은 템플릿에서 &lt;code&gt;model.comments&lt;/code&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8884e5a83dfe81deaf4fd5eb5cc8081003657de6" translate="yes" xml:space="preserve">
          <source>The primary purpose of this class is to create hooks that can be implemented by an adapter for various test frameworks.</source>
          <target state="translated">이 클래스의 주요 목적은 다양한 테스트 프레임 워크에 대한 어댑터로 구현할 수있는 후크를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c9ce1bc115a79248bbaed83eaf438de9db2bc44" translate="yes" xml:space="preserve">
          <source>The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">약속과 상호 작용하는 주요 방법은 &lt;code&gt;then&lt;/code&gt; 메소드를 사용하여 약속의 최종 가치 또는 약속을 이행 할 수없는 이유를 받도록 콜백을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59d128dbc75fda5894fb5dea6412a07651640a9e" translate="yes" xml:space="preserve">
          <source>The process of removing the feature flags from the resulting build output is handled by &lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt;&lt;code&gt;defeatureify&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 빌드 출력에서 ​​기능 플래그를 제거하는 프로세스는 &lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt; &lt;code&gt;defeatureify&lt;/code&gt; &lt;/a&gt; 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="291f652ab49a4eb74576b1a1bb6950593d5373e8" translate="yes" xml:space="preserve">
          <source>The promise whose fulfillment value is being proxied by this object.</source>
          <target state="translated">이행 목표가이 목표에 의해 프록시되고있는 약속.</target>
        </trans-unit>
        <trans-unit id="cc7758b607302e53a0da31210b9497cab24a954d" translate="yes" xml:space="preserve">
          <source>The property key to be notified about.</source>
          <target state="translated">통지 할 프로퍼티 키.</target>
        </trans-unit>
        <trans-unit id="11ef23efc9663b08bd99db214c95e5dc5d1cd5ea" translate="yes" xml:space="preserve">
          <source>The property key to retrieve</source>
          <target state="translated">검색 할 속성 키</target>
        </trans-unit>
        <trans-unit id="841185ba10823f766df7d71131c49e92c5b6ee9e" translate="yes" xml:space="preserve">
          <source>The property key to set</source>
          <target state="translated">설정할 속성 키</target>
        </trans-unit>
        <trans-unit id="37b81ff8e5f127d9996f4e45ec5e0deebeaf6ce8" translate="yes" xml:space="preserve">
          <source>The property path to set</source>
          <target state="translated">설정할 속성 경로</target>
        </trans-unit>
        <trans-unit id="fb6eddea047f11a03af1d5ee0f7e00977dfd358c" translate="yes" xml:space="preserve">
          <source>The property to retrieve</source>
          <target state="translated">검색 할 속성</target>
        </trans-unit>
        <trans-unit id="8611964c338d3f650ff1f5dffbfb19d6cfa92a6b" translate="yes" xml:space="preserve">
          <source>The property to set</source>
          <target state="translated">설정할 속성</target>
        </trans-unit>
        <trans-unit id="34a11ee7cca8e3277193e578a732c953c3658ceb" translate="yes" xml:space="preserve">
          <source>The property value or the defaultValue.</source>
          <target state="translated">특성 값 또는 defaultValue</target>
        </trans-unit>
        <trans-unit id="bb368158afde88e0d072275a3061843e6612c710" translate="yes" xml:space="preserve">
          <source>The property value or undefined.</source>
          <target state="translated">특성 값 또는 정의되지 않은.</target>
        </trans-unit>
        <trans-unit id="19f5671dd388019c1e7b9993c2e1610d92a167e3" translate="yes" xml:space="preserve">
          <source>The provided controller will be one resolved based on the name of this route.</source>
          <target state="translated">제공된 컨트롤러는이 경로의 이름에 따라 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="43f2ede5675faaa434d556fbe9e5fc7a71392d4b" translate="yes" xml:space="preserve">
          <source>The purpose of the Ember Instrumentation module is to provide efficient, general-purpose instrumentation for Ember.</source>
          <target state="translated">Ember Instrumentation 모듈의 목적은 Ember를위한 효율적인 범용 계측기를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="423ed4fcc7c2521ed4d18b49830304fce9133a79" translate="yes" xml:space="preserve">
          <source>The real value of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; comes from being able to dynamically pick the component being rendered. Below is an example of using the helper as a means of choosing different components for displaying different kinds of posts:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt; 의 실제 가치는 렌더링 할 구성 요소를 동적으로 선택할 수 있다는 데 있습니다. 다음은 다른 종류의 게시물을 표시하기 위해 다른 구성 요소를 선택하는 수단으로 도우미를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="94d0b948c12d2a0e9c041073d0e9e25cd67c32bc" translate="yes" xml:space="preserve">
          <source>The record passed as the first parameter is where you should stash state about the record if needed; you should never store data on the state object itself.</source>
          <target state="translated">첫 번째 매개 변수로 전달 된 레코드는 필요한 경우 레코드에 대해 상태를 숨겨야하는 위치입니다. 상태 객체 자체에 데이터를 저장해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0e847eeb0e7b887a5ab5a982823e0c83a639d123" translate="yes" xml:space="preserve">
          <source>The reduced value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e588a2c9e2c86b51f204f41c83c576f838e6536" translate="yes" xml:space="preserve">
          <source>The relationship descriptor argument is an object with the following properties.</source>
          <target state="translated">관계 설명자 인수는 다음과 같은 속성을 가진 개체입니다.</target>
        </trans-unit>
        <trans-unit id="f282f5d1355901b15ca747b3a5ab165ce7bc1457" translate="yes" xml:space="preserve">
          <source>The reload behavior is configured either via the passed &lt;code&gt;options&lt;/code&gt; hash or the result of the adapter's &lt;code&gt;shouldReloadRecord&lt;/code&gt;.</source>
          <target state="translated">재로드 동작은 전달 된 &lt;code&gt;options&lt;/code&gt; 해시 또는 어댑터의 &lt;code&gt;shouldReloadRecord&lt;/code&gt; 결과를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="db525ceb99e1840957b4e97df93348fb6ea8f6f3" translate="yes" xml:space="preserve">
          <source>The request is made through the adapters' &lt;code&gt;queryRecord&lt;/code&gt;:</source>
          <target state="translated">요청은 어댑터의 &lt;code&gt;queryRecord&lt;/code&gt; 를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="41441812d681fe9fb5a2b27e3821d50566b0e53f" translate="yes" xml:space="preserve">
          <source>The resolver instance of the application being debugged. This property will be injected on creation.</source>
          <target state="translated">디버깅중인 응용 프로그램의 리졸버 인스턴스입니다. 이 속성은 생성시 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="473773a9f0ae3a524717a98bf2bff757a44c072d" translate="yes" xml:space="preserve">
          <source>The resulting template render logic would be:</source>
          <target state="translated">결과 템플릿 렌더링 로직은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64e24c1771c3d34bfc6f390eb86af08b179c758c" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;then&lt;/code&gt; is itself a promise. This second, 'downstream' promise is resolved with the return value of the first promise's fulfillment or rejection handler, or rejected if the handler throws an exception.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 의 반환 가치 는 그 자체가 약속입니다. 이 두 번째 '다운 스트림'약속은 첫 번째 약속 이행 또는 거부 처리기의 반환 값으로 해결되거나 처리기가 예외를 throw하면 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8d20833918be8aaca0fedabee7a9e43ef5581cff" translate="yes" xml:space="preserve">
          <source>The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will be copied over to the fulfilled object and marked with state 'fulfilled'.</source>
          <target state="translated">리턴 된 약속은 &lt;code&gt;promises&lt;/code&gt; 객체 인수 와 동일한 키 이름을 가진 해시로 이행됩니다 . 개체의 값 중 하나라도 약속이 아니면 이행 된 개체로 복사되고 상태가 '완료 됨'으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8735a66c3c58858c4137385dfcf321c94c6cd283" translate="yes" xml:space="preserve">
          <source>The returned value is placed where the &lt;code&gt;{{}}&lt;/code&gt; is called. The above style is called &quot;inline&quot;. A second style of helper usage is called &quot;block&quot;. For example:</source>
          <target state="translated">리턴 된 값은 &lt;code&gt;{{}}&lt;/code&gt; 이 (가) 호출 되는 곳에 있습니다. 위의 스타일을 &quot;인라인&quot;이라고합니다. 도우미 사용의 두 번째 스타일을 &quot;차단&quot;이라고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e2e21dc44f676bf1bd060e0463dcf7e7e820d3a" translate="yes" xml:space="preserve">
          <source>The root DOM element of the Application. This can be specified as an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램의 루트 DOM 요소 요소 또는 &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery 호환 선택기 문자열&lt;/a&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eecac9c9d2d99121f7c3692d02975aa4bfbc76ff" translate="yes" xml:space="preserve">
          <source>The root object of the transform.</source>
          <target state="translated">변환의 루트 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1bb1190332a9040ced62948350a42acdb8d03375" translate="yes" xml:space="preserve">
          <source>The route defined above will by default use the &lt;code&gt;blog-post.js&lt;/code&gt; route handler, the &lt;code&gt;blog-post.hbs&lt;/code&gt; template, and be referred to as &lt;code&gt;blog-post&lt;/code&gt; in any &lt;code&gt;{{link-to}}&lt;/code&gt; helpers.</source>
          <target state="translated">위에 정의 된 경로는 기본적으로 &lt;code&gt;blog-post.js&lt;/code&gt; 경로 핸들러 인 &lt;code&gt;blog-post.hbs&lt;/code&gt; 템플릿을 사용하며 &lt;code&gt;{{link-to}}&lt;/code&gt; 헬퍼 에서 &lt;code&gt;blog-post&lt;/code&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="1547b257edc696cf9d97b9973174fdd903d969e5" translate="yes" xml:space="preserve">
          <source>The route handler then typically does two things:</source>
          <target state="translated">그런 다음 경로 처리기는 일반적으로 두 가지 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5a25dcb793cf10fb01f14c9659469d0ea089350c" translate="yes" xml:space="preserve">
          <source>The route that triggered the loading event</source>
          <target state="translated">로딩 이벤트를 트리거 한 경로</target>
        </trans-unit>
        <trans-unit id="40ef35919f724f529657ab517634c7e128df098d" translate="yes" xml:space="preserve">
          <source>The route will then set the return value from the &lt;code&gt;model&lt;/code&gt; hook as the &lt;code&gt;model&lt;/code&gt; property of the controller. You will then be able to access the controller's &lt;code&gt;model&lt;/code&gt; property in your template:</source>
          <target state="translated">그런 다음 경로는 &lt;code&gt;model&lt;/code&gt; 후크 의 반환 값을 컨트롤러 의 &lt;code&gt;model&lt;/code&gt; 속성으로 설정합니다. 그런 다음 템플릿에서 컨트롤러의 &lt;code&gt;model&lt;/code&gt; 속성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9055510d33898a55dfaabcdf80c77508cc19202" translate="yes" xml:space="preserve">
          <source>The router considers any object with a &lt;code&gt;then()&lt;/code&gt; method defined on it to be a promise.</source>
          <target state="translated">라우터는 정의 된 &lt;code&gt;then()&lt;/code&gt; 메소드가 있는 오브젝트를 약속으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="20ae5f1ef171342e36f277fd6cd573513d476f32" translate="yes" xml:space="preserve">
          <source>The run loop API calls that &lt;em&gt;schedule&lt;/em&gt; work, i.e. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt;&lt;code&gt;run.schedule&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt;&lt;code&gt;run.scheduleOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;run.once&lt;/code&gt;&lt;/a&gt; have the property that they will approximate a run loop for you if one does not already exist. These automatically created run loops we call &lt;em&gt;autoruns&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt; &lt;code&gt;run.schedule&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt; &lt;code&gt;run.scheduleOnce&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;run.once&lt;/code&gt; &lt;/a&gt; 작업 을 &lt;em&gt;예약&lt;/em&gt; 하는 실행 루프 API 호출 은 실행 루프가없는 경우 사용자를 위해 실행 루프와 비슷한 속성을 갖습니다. 이 자동으로 생성 실행 루프 우리는 전화 &lt;em&gt;가 자동 실행을&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aab8740741c5d7b401984a17e059a4e0f2aa2178" translate="yes" xml:space="preserve">
          <source>The same applies to &lt;code&gt;belongsTo&lt;/code&gt; relationships:</source>
          <target state="translated">&lt;code&gt;belongsTo&lt;/code&gt; 관계 에도 동일하게 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="79f91cf22c7dca84c509c4f77da4cb434629965b" translate="yes" xml:space="preserve">
          <source>The same rules apply to arrays of primitives.</source>
          <target state="translated">프리미티브 배열에도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd7b8fd9eac5480b43026cdd22b54a66a4559b81" translate="yes" xml:space="preserve">
          <source>The scroll happens on &lt;code&gt;didRender&lt;/code&gt;, where it will scroll the component's container to the element with the selected class name.</source>
          <target state="translated">스크롤은 &lt;code&gt;didRender&lt;/code&gt; 에서 발생하며 , 여기서 컴포넌트의 컨테이너를 선택된 클래스 이름을 가진 요소로 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="0d4cba2063c093b6e0028f97cd82cdeaa6816998" translate="yes" xml:space="preserve">
          <source>The second parameter is the optional options hash. Available options are:</source>
          <target state="translated">두 번째 매개 변수는 선택적 옵션 해시입니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b090381a04a9e48621d42bb0bf53fa4cba4f1e4" translate="yes" xml:space="preserve">
          <source>The semantic version</source>
          <target state="translated">시맨틱 버전</target>
        </trans-unit>
        <trans-unit id="5f38bd2b1df14793a918cfb86c695e7bb1738385" translate="yes" xml:space="preserve">
          <source>The serialized value</source>
          <target state="translated">직렬화 된 값</target>
        </trans-unit>
        <trans-unit id="1441caa2180aa5deaa1d21c6c8bad5b37a9eaf47" translate="yes" xml:space="preserve">
          <source>The serializer properly converts the blog request payload into a blog post model object.</source>
          <target state="translated">직렬 변환기는 블로그 요청 페이로드를 블로그 게시물 모델 오브젝트로 올바르게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c14938d7774e56e262de01aeb6eb9013ddc6fc80" translate="yes" xml:space="preserve">
          <source>The setup is largely similar to how Ember works out-of-the-box. Normally, Ember will boot a default instance for your Application on &quot;DOM ready&quot;. However, you can customize this behavior by disabling &lt;code&gt;autoboot&lt;/code&gt;.</source>
          <target state="translated">설정은 Ember가 기본적으로 작동하는 방식과 거의 유사합니다. 일반적으로 Ember는 &quot;DOM ready&quot;에서 애플리케이션의 기본 인스턴스를 부팅합니다. 그러나 &lt;code&gt;autoboot&lt;/code&gt; 를 비활성화하여이 동작을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44bd33d4e5c5dbd425e1b01d352cce7c15b457b1" translate="yes" xml:space="preserve">
          <source>The sorted array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbcdf9dc99641ff8f9df51339a76d30dd24a554" translate="yes" xml:space="preserve">
          <source>The starting index in the array that did change.</source>
          <target state="translated">변경된 배열의 시작 색인입니다.</target>
        </trans-unit>
        <trans-unit id="edab6dfda8b0a675cd3b277a658515192ee54ac2" translate="yes" xml:space="preserve">
          <source>The starting index in the array that will change.</source>
          <target state="translated">변경 될 배열의 시작 색인입니다.</target>
        </trans-unit>
        <trans-unit id="565a8bbec3976cbbd11685d7a0db28bb110f442f" translate="yes" xml:space="preserve">
          <source>The store contains all of the data for records loaded from the server. It is also responsible for creating instances of &lt;code&gt;DS.Model&lt;/code&gt; that wrap the individual data for a record, so that they can be bound to in your Handlebars templates.</source>
          <target state="translated">저장소에는 서버에서로드 된 레코드에 대한 모든 데이터가 포함됩니다. 또한 핸들 바 템플릿에 바인딩 될 수 있도록 레코드의 개별 데이터를 랩핑하는 &lt;code&gt;DS.Model&lt;/code&gt; 인스턴스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="bd1641cbe5dc00ca11bff91f0a9e4a4c7d1b52e6" translate="yes" xml:space="preserve">
          <source>The store object is available in controllers and routes using &lt;code&gt;this.get('store')&lt;/code&gt;.</source>
          <target state="translated">상점 오브젝트는 &lt;code&gt;this.get('store')&lt;/code&gt; 를 사용하여 제어기 및 라우트에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b1269778250371106783075e2d9ba12e8b0581" translate="yes" xml:space="preserve">
          <source>The store provides multiple ways to create new record objects. They have some subtle differences in their use which are detailed below:</source>
          <target state="translated">저장소는 새 레코드 개체를 만드는 여러 가지 방법을 제공합니다. 사용 방법에 미묘한 차이점이 있으며 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c599c05627277afc6c6ecc983a68b24eda3344" translate="yes" xml:space="preserve">
          <source>The store then takes that JSON, initializes the record with the JSON data, and resolves the promise returned to your application with the newly-loaded record.</source>
          <target state="translated">그런 다음 상점은 해당 JSON을 가져 와서 JSON 데이터로 레코드를 초기화하고 새로로드 된 레코드로 애플리케이션에 리턴 된 약속을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="41b68f114ba57e357ad03f70aa549d7262c8caa5" translate="yes" xml:space="preserve">
          <source>The store will automatically cache records for you. If a record had already been loaded, asking for it a second time will always return the same object instance. This minimizes the number of round-trips to the server, and allows your application to render its UI to the user as fast as possible.</source>
          <target state="translated">상점은 자동으로 레코드를 캐시합니다. 레코드가 이미로드 된 경우 다시 요청하면 항상 동일한 객체 인스턴스가 반환됩니다. 이를 통해 서버로의 왕복 횟수를 최소화하고 응용 프로그램에서 UI를 사용자에게 최대한 빨리 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01207237cd4ccf3b900d21e60db5b725e70f8924" translate="yes" xml:space="preserve">
          <source>The store will call &lt;code&gt;findMany&lt;/code&gt; instead of multiple &lt;code&gt;findRecord&lt;/code&gt; requests to find multiple records at once if coalesceFindRequests is true.</source>
          <target state="translated">coalesceFindRequests가 true 인 경우 상점은 여러 개의 &lt;code&gt;findRecord&lt;/code&gt; 요청 대신 &lt;code&gt;findMany&lt;/code&gt; 를 호출 하여 한 번에 여러 레코드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2f69dc65e213b2fb8cdb1b7cbc4e005ab648a25" translate="yes" xml:space="preserve">
          <source>The store's &lt;code&gt;push()&lt;/code&gt; method is a low level API which accepts a JSON API document with a few important differences from the JSON API document that the JSONAPISerializer accepts. The type name in the JSON API document must match the type name of the model exactly (In the example above the type is &lt;code&gt;album&lt;/code&gt; because the model is defined in &lt;code&gt;app/models/album.js&lt;/code&gt;). Attributes and relationship names must match the casing of the properties defined on the Model class.</source>
          <target state="translated">상점의 &lt;code&gt;push()&lt;/code&gt; 메소드는 JSONAPISerializer가 허용하는 JSON API 문서와 몇 가지 중요한 차이점이있는 JSON API 문서를 승인하는 저수준 API입니다. JSON API 문서의 유형 이름은 모델의 유형 이름과 정확히 일치해야합니다 (위의 예 에서 모델은 &lt;code&gt;app/models/album.js&lt;/code&gt; 에 정의되어 있기 때문에 유형은 &lt;code&gt;album&lt;/code&gt; 임 ). 속성 및 관계 이름은 Model 클래스에 정의 된 속성의 케이스와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba2337f1b869281822cbec365330fc6ed3a87eb9" translate="yes" xml:space="preserve">
          <source>The string to camelize.</source>
          <target state="translated">camelize 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6562d656544896269e6510021a24eb0fe047f8cd" translate="yes" xml:space="preserve">
          <source>The string to dasherize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827deb88bf3cf7b323e93ba14d05290d5e8a6b48" translate="yes" xml:space="preserve">
          <source>The string to decamelize.</source>
          <target state="translated">디카 멜화할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8aef10dc78a1b6b0b047d67f1b41e8c2eacf1322" translate="yes" xml:space="preserve">
          <source>The string to format</source>
          <target state="translated">형식화 할 문자열</target>
        </trans-unit>
        <trans-unit id="2b0b9ffa844d16267c8115855979ed48b6d4bc64" translate="yes" xml:space="preserve">
          <source>The string to format.</source>
          <target state="translated">서식을 지정할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8bb5d2b6d14eab5fb11c8b4cd7eded396880eafd" translate="yes" xml:space="preserve">
          <source>The string to split</source>
          <target state="translated">분할 할 문자열</target>
        </trans-unit>
        <trans-unit id="504f1fdddf0d3ae9e6968c1488e9aaed471044e1" translate="yes" xml:space="preserve">
          <source>The string to underscore.</source>
          <target state="translated">밑줄을 표시 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6b2ca2bba7cfc3b3d4f9eb164041ee4b3f478da7" translate="yes" xml:space="preserve">
          <source>The string values provided for the template name, and controller will eventually pass through to the resolver for lookup. See Ember.Resolver for how these are mapped to JavaScript objects in your application. The template to render into needs to be related to either the current route or one of its ancestors.</source>
          <target state="translated">템플릿 이름 및 컨트롤러에 제공된 문자열 값은 결국 조회를 위해 리졸버로 전달됩니다. 애플리케이션에서 JavaScript 객체에 매핑되는 방법은 Ember.Resolver를 참조하십시오. 렌더링 할 템플릿은 현재 경로 또는 조상 중 하나와 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c15310baae72447d4757eb2e55e534acbbc316b" translate="yes" xml:space="preserve">
          <source>The target object to invoke</source>
          <target state="translated">호출 할 대상 객체</target>
        </trans-unit>
        <trans-unit id="de10ba709439df9674dd354fe1c515eac06ba807" translate="yes" xml:space="preserve">
          <source>The target object to use</source>
          <target state="translated">사용할 대상 객체</target>
        </trans-unit>
        <trans-unit id="54d029f20e1dadec96b103ccc865dfcca39add60" translate="yes" xml:space="preserve">
          <source>The target of the method to invoke.</source>
          <target state="translated">호출 할 메소드의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="e2ed41e561ef82bfe2b3a4d933412915eae9db07" translate="yes" xml:space="preserve">
          <source>The target of the subscription</source>
          <target state="translated">구독 대상</target>
        </trans-unit>
        <trans-unit id="4ceffd13443beb5575ab1e4483fbd512664207b4" translate="yes" xml:space="preserve">
          <source>The template contains an &lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; helper that renders as a text field, in which the user can type a pattern to filter the list of cities used in a search. The &lt;code&gt;value&lt;/code&gt; property of the &lt;code&gt;input&lt;/code&gt; will be kept in sync with the &lt;code&gt;value&lt;/code&gt; property in the component.</source>
          <target state="translated">템플릿에는 텍스트 필드로 렌더링 되는 &lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt; 도우미가 포함되어 있으며, 사용자는 검색에 사용 된 도시 목록을 필터링하기 위해 패턴을 입력 할 수 있습니다. &lt;code&gt;value&lt;/code&gt; 의 속성 &lt;code&gt;input&lt;/code&gt; 와 동기화를 유지한다 &lt;code&gt;value&lt;/code&gt; 컴포넌트의 속성.</target>
        </trans-unit>
        <trans-unit id="d74f4833f85af93d253619500c9b82c2db0b7e23" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each-in}}&lt;/code&gt; block is repeated once for each key in the passed object. The first block parameter (&lt;code&gt;category&lt;/code&gt; in the above example) is the key for this iteration, while the second block parameter (&lt;code&gt;products&lt;/code&gt;) is the actual value of that key.</source>
          <target state="translated">전달 된 객체의 각 키에 &lt;code&gt;{{#each-in}}&lt;/code&gt; 블록 내부의 템플릿 이 한 번 반복됩니다. 첫 번째 블록 매개 변수 ( 위 예제에서 &lt;code&gt;category&lt;/code&gt; )가이 반복의 키인 반면, 두 번째 블록 매개 변수 ( &lt;code&gt;products&lt;/code&gt; )는 해당 키의 실제 값입니다.</target>
        </trans-unit>
        <trans-unit id="722bc70d44379d1b5cfee1e8ad82e651eaf53bd8" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each}}&lt;/code&gt; block will be repeated once for each item in the array, with the each item set to the &lt;code&gt;person&lt;/code&gt; block param.</source>
          <target state="translated">&lt;code&gt;{{#each}}&lt;/code&gt; 블록 내부의 템플릿 은 배열의 각 항목마다 한 번씩 반복되며 각 항목은 &lt;code&gt;person&lt;/code&gt; 블록 매개 변수로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e14b256b8bf613a58dde6fd95e9abcd1338adcd7" translate="yes" xml:space="preserve">
          <source>The test locates the results of the search by finding elements with a class of &lt;code&gt;listing&lt;/code&gt;, which we gave to our &lt;code&gt;rental-listing&lt;/code&gt; component in the &lt;a href=&quot;../simple-component&quot;&gt;&quot;Building a Simple Component&quot;&lt;/a&gt; section of the tutorial.</source>
          <target state="translated">이 테스트의 클래스 요소를 찾아 검색 결과를 찾아 &lt;code&gt;listing&lt;/code&gt; 우리가 우리에게 준, &lt;code&gt;rental-listing&lt;/code&gt; 에서 구성 요소 &lt;a href=&quot;../simple-component&quot;&gt;&quot;건물 간단한 구성 요소&quot;&lt;/a&gt; 자습서의 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a64607c214ef37d87d8ad67e76908fa5af07f02" translate="yes" xml:space="preserve">
          <source>The test verifies that after filling in the search input with &quot;Seattle&quot;, the rental list reduces from 3 to 1, and the item displayed shows &quot;Seattle&quot; as the location.</source>
          <target state="translated">테스트는 &quot;시애틀&quot;로 검색 입력을 채운 후 대여 목록이 3에서 1로 감소하고 표시되는 항목에 &quot;시애틀&quot;이 위치로 표시되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="89d72c69007c893df81d99979fa6b2e66b8f23a3" translate="yes" xml:space="preserve">
          <source>The test would call the &lt;code&gt;calc&lt;/code&gt; method and assert it gets back the correct value.</source>
          <target state="translated">테스트는 &lt;code&gt;calc&lt;/code&gt; 메소드를 호출 하고 올바른 값을 얻도록합니다.</target>
        </trans-unit>
        <trans-unit id="9e4b46dc9e309d54bfec19901f419a3f701c4206" translate="yes" xml:space="preserve">
          <source>The third context of the &lt;code&gt;{{action}}&lt;/code&gt; helper can be called &quot;element space&quot;. For example:</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 헬퍼 의 세 번째 컨텍스트를 &quot;요소 공간&quot;이라고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d7a55f997fe0c18460ae452e7f09adc66aa219" translate="yes" xml:space="preserve">
          <source>The third form of helper usage is &lt;strong&gt;block invocation&lt;/strong&gt;. Use block helpers to render only part of a template. Block invocation of a helper can be recognized by the &lt;code&gt;#&lt;/code&gt; before the helper name, and the closing &lt;code&gt;{{/&lt;/code&gt; double curly brace at the end of the invocation.</source>
          <target state="translated">도우미 사용의 세 번째 형태는 &lt;strong&gt;블록 호출&lt;/strong&gt; 입니다. 블록 도우미를 사용하여 템플릿의 일부만 렌더링합니다. 헬퍼의 블록 호출은 헬퍼 이름 앞 의 &lt;code&gt;#&lt;/code&gt; 로 , 그리고 호출의 끝에 닫는 &lt;code&gt;{{/&lt;/code&gt; 이중 중괄호 로 인식 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="944b09433ee6559023c1be9d8df4b25f0ac83680" translate="yes" xml:space="preserve">
          <source>The third parameter is a function, which can be used to nest routes. Nested routes, by default, will have the parent route tree's route name and path prepended to it's own.</source>
          <target state="translated">세 번째 매개 변수는 라우트를 중첩하는 데 사용할 수있는 함수입니다. 기본적으로 중첩 된 경로는 상위 경로 트리의 경로 이름과 경로 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="147526a2a9e7840b61e7afb24045b79c209cc65d" translate="yes" xml:space="preserve">
          <source>The type. e.g. &quot;model&quot;, &quot;controller&quot;, &quot;route&quot;.</source>
          <target state="translated">유형. &quot;모델&quot;, &quot;컨트롤러&quot;, &quot;경로&quot;.</target>
        </trans-unit>
        <trans-unit id="4f039fe10b59dfaf945a628a511ceac52bce6aa9" translate="yes" xml:space="preserve">
          <source>The updateRecord method is expected to return a promise that will resolve with the serialized record. This allows the backend to inform the Ember Data store the current state of this record after the update. If it is not possible to return a serialized record the updateRecord promise can also resolve with &lt;code&gt;undefined&lt;/code&gt; and the Ember Data store will assume all of the updates were successfully applied on the backend.</source>
          <target state="translated">updateRecord 메소드는 직렬화 된 레코드로 해결할 약속을 리턴 할 것으로 예상됩니다. 이를 통해 업데이트 후 백엔드가 Ember 데이터 저장소에이 레코드의 현재 상태를 알릴 수 있습니다. 직렬화 된 레코드를 반환 할 수없는 경우 updateRecord 약속은 &lt;code&gt;undefined&lt;/code&gt; 해결 될 수 있으며 Ember 데이터 저장소는 모든 업데이트가 백엔드에 성공적으로 적용된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="51de670ab53c3db59ec8a0666e66364d58ad96c2" translate="yes" xml:space="preserve">
          <source>The user changes the URL manually, such as by clicking the back button or by editing the address bar.</source>
          <target state="translated">사용자는 뒤로 단추를 클릭하거나 주소 표시 줄을 편집하여 URL을 수동으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5351613497c3004771812d248a543cbdc66656b3" translate="yes" xml:space="preserve">
          <source>The user clicks a link within the app.</source>
          <target state="translated">사용자는 앱 내에서 링크를 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="9921d7f5710f25509ee88606a85dee5d311bd63d" translate="yes" xml:space="preserve">
          <source>The user loads the app for the first time.</source>
          <target state="translated">사용자가 처음으로 앱을로드합니다.</target>
        </trans-unit>
        <trans-unit id="74e880123198891577360a791645732bdf32b1e5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;isWide&lt;/code&gt; comes from our component's JavaScript file, in this case &lt;code&gt;rental-listing.js&lt;/code&gt;. Since we want the image to be smaller at first, we will set the property to start as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;isWide&lt;/code&gt; 의 가치는 컴포넌트의 JavaScript 파일 (이 경우 &lt;code&gt;rental-listing.js&lt;/code&gt; ) 에서 비롯됩니다 . 처음에는 이미지를 작게 만들고 싶기 때문에 속성을 &lt;code&gt;false&lt;/code&gt; 로 시작하도록 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d23a5a16f505fa5c0bc4c22ed6862d2f7cf30588" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;my-controller-name&lt;/code&gt; must match the name of the Route that renders it. So a Route named &lt;code&gt;blog-post&lt;/code&gt; would have a matching Controller named &lt;code&gt;blog-post&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my-controller-name&lt;/code&gt; 의 값은이 를 렌더링하는 Route의 이름과 일치해야합니다. 따라서 &lt;code&gt;blog-post&lt;/code&gt; 라는 경로는 blog-post 라는 일치하는 컨트롤러를 갖 &lt;code&gt;blog-post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1f47d5724e57f16f4762fa4b7b499056b744cd" translate="yes" xml:space="preserve">
          <source>The value to be returned.</source>
          <target state="translated">반환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="04a60bcf4638b39535e993d6cbd42eae6ce46172" translate="yes" xml:space="preserve">
          <source>The value to return if the property value is undefined</source>
          <target state="translated">특성 값이 정의되지 않은 경우 리턴 할 값</target>
        </trans-unit>
        <trans-unit id="9571ab424dffa7c5f376c7c97c04d87fb698a99b" translate="yes" xml:space="preserve">
          <source>The value to set</source>
          <target state="translated">설정할 값</target>
        </trans-unit>
        <trans-unit id="cc012a4e9d5bd52a06928e9abc8926ab3ec9e9e2" translate="yes" xml:space="preserve">
          <source>The value to set or `null`.</source>
          <target state="translated">설정할 값 또는 'null'입니다.</target>
        </trans-unit>
        <trans-unit id="66ed92b099921e39838f582833afc6fe6e27756e" translate="yes" xml:space="preserve">
          <source>Then it checks for the presence of a type-specific instance method of the form &lt;code&gt;resolve[Type]&lt;/code&gt; and calls it if it exists. For example if it was resolving 'template:post', it would call the &lt;code&gt;resolveTemplate&lt;/code&gt; method.</source>
          <target state="translated">그런 다음 &lt;code&gt;resolve[Type]&lt;/code&gt; 인스턴스 메소드가 있는지 확인하고 존재하는 경우이를 호출합니다. 예를 들어 'template : post'를 해결하는 경우 &lt;code&gt;resolveTemplate&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="124bbec613e0740a2add94968e72e7ab45cd285a" translate="yes" xml:space="preserve">
          <source>Then make sure the &quot;Display the Tomster icon when a site runs Ember.js&quot; checkbox is checked.</source>
          <target state="translated">그런 다음 &quot;사이트에서 Ember.js를 실행할 때 Tomster 아이콘 표시&quot;확인란이 선택되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0963cd90e4c018ee024de78af4821e7b2fb93a50" translate="yes" xml:space="preserve">
          <source>Then our &lt;code&gt;system-preferences-editor&lt;/code&gt; template passes its local &lt;code&gt;deleteUser&lt;/code&gt; action into the &lt;code&gt;user-profile&lt;/code&gt; as that component's &lt;code&gt;deleteCurrentUser&lt;/code&gt; property.</source>
          <target state="translated">그런 다음 &lt;code&gt;system-preferences-editor&lt;/code&gt; 템플릿은 해당 로컬 &lt;code&gt;deleteUser&lt;/code&gt; 작업을 해당 구성 요소의 &lt;code&gt;deleteCurrentUser&lt;/code&gt; 속성 으로 &lt;code&gt;user-profile&lt;/code&gt; 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="b94c945aa553087e491135e87e7caa5e6c5b7883" translate="yes" xml:space="preserve">
          <source>Then you can use the &lt;code&gt;surge&lt;/code&gt; command to deploy your application. Note you will also need to rename index.html to 200.html to enable Ember's client-side routing.</source>
          <target state="translated">그런 다음 &lt;code&gt;surge&lt;/code&gt; 명령을 사용 하여 응용 프로그램을 배포 할 수 있습니다. Ember의 클라이언트 측 라우팅을 활성화하려면 index.html의 이름을 200.html로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="0d901353d4e943cc8e0760df4cb86a77339d4096" translate="yes" xml:space="preserve">
          <source>Then you can use the attributes in the component exactly as if they had been passed in like &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt; 와 같이 전달 된 것처럼 구성 요소의 속성을 정확하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c92853aa810fa69277504403a7af77504ee617b3" translate="yes" xml:space="preserve">
          <source>Then you could test that the relationship is wired up correctly with this test.</source>
          <target state="translated">그런 다음이 테스트와의 관계가 올바르게 연결되었는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aaeabca116411bcf4c1a7398dff6575fb20c9cb" translate="yes" xml:space="preserve">
          <source>There are a few things to note about the &lt;code&gt;didInsertElement()&lt;/code&gt; hook:</source>
          <target state="translated">&lt;code&gt;didInsertElement()&lt;/code&gt; 후크에 대해 몇 가지주의 할 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a72425f5f9b4159f6c94de9e4fbddbb71a0684" translate="yes" xml:space="preserve">
          <source>There are also a number of hooks that you might find useful to define across-the-board rules for your payload. These rules will be useful if your server is consistent, or if you're building an adapter for an infrastructure service, like Firebase, and want to encode service conventions.</source>
          <target state="translated">페이로드에 대한 전체 규칙을 정의하는 데 유용한 여러 가지 후크도 있습니다. 이 규칙은 서버가 일관성이 있거나 Firebase와 같은 인프라 서비스 용 어댑터를 구축하고 서비스 규칙을 인코딩하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="578096648c11d6a69dd22171bb32ab27d9d7328e" translate="yes" xml:space="preserve">
          <source>There are many other reasons you probably want to have the last word on whether a user can or cannot access a certain page. Ember allows you to control that access with a combination of hooks and methods in your route.</source>
          <target state="translated">사용자가 특정 페이지에 액세스 할 수 있는지 여부에 대한 마지막 단어를 갖고 싶은 다른 많은 이유가 있습니다. Ember를 사용하면 경로에 후크와 메소드를 조합하여 액세스를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e116b7284a783a93524c56507c577f15c7f8f3a" translate="yes" xml:space="preserve">
          <source>There are some typical properties for &lt;code&gt;JSONAPI&lt;/code&gt; payload:</source>
          <target state="translated">&lt;code&gt;JSONAPI&lt;/code&gt; 페이로드 에는 몇 가지 일반적인 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa40a8819696a1f893c91e0074003303e8e955ba" translate="yes" xml:space="preserve">
          <source>There are three contexts an action helper can be used in. The first two contexts to discuss are attribute context, and Handlebars value context.</source>
          <target state="translated">액션 헬퍼가 사용될 수있는 컨텍스트는 세 가지가 있습니다. 논의 할 처음 두 컨텍스트는 속성 컨텍스트와 핸들 바 값 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="eb35d84a7b28ef37fc1f3ad04e7b79de4e7986bd" translate="yes" xml:space="preserve">
          <source>There are three different classifications of tests that you will need: &lt;strong&gt;Acceptance&lt;/strong&gt;, &lt;strong&gt;Unit&lt;/strong&gt;, and &lt;strong&gt;Integration&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;승인&lt;/strong&gt; , &lt;strong&gt;단위&lt;/strong&gt; 및 &lt;strong&gt;통합의&lt;/strong&gt; 세 가지 테스트 분류가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7367662dcdee81e54f51c21bbee10f32226fbf53" translate="yes" xml:space="preserve">
          <source>There are times when dealing with promises that it seems like any errors are being 'swallowed', and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, &lt;code&gt;RSVP&lt;/code&gt; has a solution for this problem built in.</source>
          <target state="translated">약속을 다룰 때 어떤 오류가 '삼키는'것처럼 보이고 적절하게 제기되지 않는 것처럼 보일 때가 있습니다. 이로 인해 특정 문제가 발생한 위치를 추적하기가 매우 어렵습니다. 다행히 &lt;code&gt;RSVP&lt;/code&gt; 에는이 문제에 대한 해결책이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cfec86f1ebe6d62f3d92a60b1b8d46e0ac4e6e" translate="yes" xml:space="preserve">
          <source>There are two types of initializers: application initializers and application instance initializers.</source>
          <target state="translated">이니셜 라이저에는 응용 프로그램 이니셜 라이저와 응용 프로그램 인스턴스 이니셜 라이저의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c93293573cc4730e6f6925ce1aadc37cf558354" translate="yes" xml:space="preserve">
          <source>There is also a &lt;em&gt;tight coupling&lt;/em&gt; between your application's UI and the network code. If the url or the format of the JSON payload changes, it is likely to break all of your UI components in ways that are hard to track down.</source>
          <target state="translated">또한 응용 프로그램의 UI와 네트워크 코드간에 &lt;em&gt;긴밀한 연결&lt;/em&gt; 이 있습니다. URL 또는 JSON 페이로드 형식이 변경되면 추적하기 어려운 방식으로 모든 UI 구성 요소가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d05d80fad77d5b9ca545ded611a63131b8dfe96" translate="yes" xml:space="preserve">
          <source>There is also a way to share data within your blog post component with the content it is wrapping. In our blog post component we want to provide a way for the user to configure what type of style they want to write their post in. We will give them the option to specify either &lt;code&gt;markdown-style&lt;/code&gt; or &lt;code&gt;html-style&lt;/code&gt;.</source>
          <target state="translated">블로그 게시물 구성 요소 내에서 데이터를 줄 바꿈하는 내용과 공유하는 방법도 있습니다. 블로그 게시물 구성 요소에서 사용자가 게시물을 작성하려는 스타일 유형을 구성 할 수있는 방법을 제공하고자합니다. &lt;code&gt;markdown-style&lt;/code&gt; 또는 &lt;code&gt;html-style&lt;/code&gt; 스타일 중 하나를 지정할 수있는 옵션을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6bce1dba6eb8d20d25b8d3b47eeeb56679f7d843" translate="yes" xml:space="preserve">
          <source>There is an option of not embedding JSON in the serialized payload by using serialize: 'ids'. If you do not want the relationship sent at all, you can use &lt;code&gt;serialize: false&lt;/code&gt;.</source>
          <target state="translated">serialize : 'ids'를 사용하여 직렬화 된 페이로드에 JSON을 포함하지 않는 옵션이 있습니다. 관계를 전혀 보내지 않으려면 &lt;code&gt;serialize: false&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c0962f2c7df03fd0ed2a6aa0f4eb2fdab83af0e" translate="yes" xml:space="preserve">
          <source>Therefore, if this function is comparing some numeric values, simple &lt;code&gt;itemA - itemB&lt;/code&gt; or &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; can be used instead of series of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">따라서이 함수가 일부 숫자 값을 비교하는 &lt;code&gt;if&lt;/code&gt; 일련의 if 대신 간단한 &lt;code&gt;itemA - itemB&lt;/code&gt; 또는 &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c0660d5302de3d7014b6613e931596da4023437" translate="yes" xml:space="preserve">
          <source>These are both languages that compile to JavaScript. You're able to write your code using the syntax they offer and when ready you compile your TypeScript or CoffeeScript into JavaScript.</source>
          <target state="translated">이들은 모두 JavaScript로 컴파일되는 언어입니다. 제공하는 구문을 사용하여 코드를 작성할 수 있으며 준비가되면 TypeScript 또는 CoffeeScript를 JavaScript로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f634da40a54ec867094862d4220f2487fe12f5b" translate="yes" xml:space="preserve">
          <source>These commands run your tests using &lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt; to make testing multiple browsers very easy. You can configure Testem using the &lt;code&gt;testem.js&lt;/code&gt; file in your application root.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt; 을 사용하여 테스트를 실행하여 여러 브라우저를 매우 쉽게 테스트합니다. 응용 프로그램 루트에서 &lt;code&gt;testem.js&lt;/code&gt; 파일을 사용하여 Testem을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ac140f85fac47671e02dda468bad7f3d465b715" translate="yes" xml:space="preserve">
          <source>These functions will be invoked when a matching &lt;code&gt;{{action}}&lt;/code&gt; is triggered from within a template and the application's current route is this route.</source>
          <target state="translated">템플릿 내에서 일치하는 &lt;code&gt;{{action}}&lt;/code&gt; 이 (가) 트리거되고 애플리케이션의 현재 경로가이 경로 인 경우 이러한 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f000050ca0200e805c16a0913f8c1fad925ae6a7" translate="yes" xml:space="preserve">
          <source>These tips will help you identify problems early so they can be addressed systematically, rather than in a last-minute scramble.</source>
          <target state="translated">이 팁을 통해 문제를 조기에 파악할 수 있으므로 마지막 순간이 아닌 체계적으로 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb68b862cfa676cabebaff85159658805baa3a42" translate="yes" xml:space="preserve">
          <source>Third-party APIs.</source>
          <target state="translated">타사 API.</target>
        </trans-unit>
        <trans-unit id="ddfb0ac04a55327aee053575597c9dda63adb165" translate="yes" xml:space="preserve">
          <source>Third-party JavaScript not available as an addon or Bower package should be placed in the &lt;code&gt;vendor/&lt;/code&gt; folder in your project.</source>
          <target state="translated">애드온 또는 Bower 패키지로 사용할 수없는 타사 JavaScript는 프로젝트 의 &lt;code&gt;vendor/&lt;/code&gt; 폴더에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ffb1109d5b126cb0663125d9dacbb7624bde715" translate="yes" xml:space="preserve">
          <source>Third-party assets that are not added via &lt;code&gt;import()&lt;/code&gt; will not be present in the final build.</source>
          <target state="translated">&lt;code&gt;import()&lt;/code&gt; 를 통해 추가되지 않은 타사 자산 은 최종 빌드에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="452f64b3ac568069b0d3fb42cc4172b03c430605" translate="yes" xml:space="preserve">
          <source>This API allows you to provide a reference with new data. The simplest usage of this API is similar to &lt;code&gt;store.push&lt;/code&gt;: you provide a normalized hash of data and the object represented by the reference will update.</source>
          <target state="translated">이 API를 사용하면 새 데이터에 대한 참조를 제공 할 수 있습니다. 이 API의 가장 간단한 사용법은 &lt;code&gt;store.push&lt;/code&gt; 와 유사 합니다. 정규화 된 데이터 해시를 제공하면 참조로 표시되는 객체가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="37ffc8f135d22f0957ffebde87903095e52c78e0" translate="yes" xml:space="preserve">
          <source>This Ember.js hook allows an object to be notified when a property is defined.</source>
          <target state="translated">이 Ember.js 후크를 사용하면 속성이 정의 될 때 객체에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b8e36a48ff33ef3a57b6d9dd97582f0dfd4fca" translate="yes" xml:space="preserve">
          <source>This adapter does not make any assumptions as to the format of the &lt;code&gt;errors&lt;/code&gt; object. It will simply be passed along as is, wrapped in an instance of &lt;code&gt;DS.InvalidError&lt;/code&gt; or &lt;code&gt;DS.AdapterError&lt;/code&gt;. The serializer can interpret it afterwards.</source>
          <target state="translated">이 어댑터는 &lt;code&gt;errors&lt;/code&gt; 오브젝트 의 형식에 대한 가정을하지 않습니다 . &lt;code&gt;DS.InvalidError&lt;/code&gt; 또는 &lt;code&gt;DS.AdapterError&lt;/code&gt; 인스턴스에 래핑 된 그대로 그대로 전달됩니다 . 시리얼 라이저는 나중에 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2124edee9f5095f02b332c56318c024bf9499a" translate="yes" xml:space="preserve">
          <source>This adapter is designed around the idea that the JSON exchanged with the server should be conventional.</source>
          <target state="translated">이 어댑터는 서버와 교환 된 JSON이 기존이어야한다는 아이디어를 중심으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="853904908c1556303a04442689a343ac7e65fed7" translate="yes" xml:space="preserve">
          <source>This adapter will extend the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;&lt;code&gt;JSONAPIAdapter&lt;/code&gt;&lt;/a&gt; base class from Ember Data:</source>
          <target state="translated">이 어댑터는 Ember Data에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt; &lt;code&gt;JSONAPIAdapter&lt;/code&gt; &lt;/a&gt; 기본 클래스를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="3d5dbdc061173e19b17b6f110fb18cfb4cd22c55" translate="yes" xml:space="preserve">
          <source>This affects query param behavior in two ways:</source>
          <target state="translated">이는 두 가지 방법으로 쿼리 매개 변수 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="9236129e7ad8572a6f3cfa7ce7b534bcdc1773a8" translate="yes" xml:space="preserve">
          <source>This allows ember-testing to play nicely with other asynchronous events, such as an application that is waiting for a CSS3 transition or an IndexDB transaction. The waiter runs periodically after each async helper (i.e. &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;andThen&lt;/code&gt;, &lt;code&gt;visit&lt;/code&gt;, etc) has executed, until the returning result is truthy. After the waiters finish, the next async helper is executed and the process repeats.</source>
          <target state="translated">이를 통해 ember-testing은 CSS3 전환 또는 IndexDB 트랜잭션을 기다리는 애플리케이션과 같은 다른 비동기 이벤트와 잘 작동합니다. 웨이터는 각 비동기 도우미 (즉, 후 주기적으로 실행 &lt;code&gt;click&lt;/code&gt; , &lt;code&gt;andThen&lt;/code&gt; , &lt;code&gt;visit&lt;/code&gt; 돌아 오는 결과가 truthy 때까지, 실행 된, 등). 웨이터가 완료되면 다음 비동기 도우미가 실행되고 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="d63f6d895f9dbaa7a1f0c7f4aab7d30d5d8234cc" translate="yes" xml:space="preserve">
          <source>This allows the original method to continue operating as it normally would.</source>
          <target state="translated">이렇게하면 원래 방법이 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="283d55de2d3a0d1c60968c365e7a92f311d2ac8a" translate="yes" xml:space="preserve">
          <source>This allows you to do whatever kind of munging you need, and is especially useful if your server is inconsistent and you need to do munging differently for many different kinds of responses.</source>
          <target state="translated">이를 통해 필요한 종류의 뭉치를 수행 할 수 있으며, 서버가 일치하지 않고 여러 종류의 응답에 대해 다르게 뭉개 야하는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fd87b224bfacdd8f67d689202e0b6d11b295e8ca" translate="yes" xml:space="preserve">
          <source>This allows you to perform asynchronous setup logic and defer booting your application until the setup has finished.</source>
          <target state="translated">이를 통해 비동기 설정 논리를 수행하고 설정이 완료 될 때까지 응용 프로그램 부팅을 연기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cdde2b5de75dbd9f848f898dbadf64aaba67fae" translate="yes" xml:space="preserve">
          <source>This argument will become the model context of the linked route:</source>
          <target state="translated">이 인수는 연결된 경로의 모델 컨텍스트가됩니다.</target>
        </trans-unit>
        <trans-unit id="941f661a9bdc6020b125f022848bfff58eb9c9a2" translate="yes" xml:space="preserve">
          <source>This behavior extends to object creation as well. Continuing the above example:</source>
          <target state="translated">이 동작은 객체 생성까지 확장됩니다. 위의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="53fa6c0fd3b00088bf6ab65b06527f4d9856bb1d" translate="yes" xml:space="preserve">
          <source>This behavior is not available during object &lt;code&gt;create&lt;/code&gt; calls. It is only available at &lt;code&gt;extend&lt;/code&gt; time.</source>
          <target state="translated">오브젝트 &lt;code&gt;create&lt;/code&gt; 호출 중에는이 동작을 사용할 수 없습니다 . &lt;code&gt;extend&lt;/code&gt; 시간 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b10353972c333adf35b656d7d67ecb6081d088a1" translate="yes" xml:space="preserve">
          <source>This behaviour can be easily customized by extending this method.</source>
          <target state="translated">이 방법을 확장하면이 동작을 쉽게 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7087d2aa7e0c9dbae55ad8456ac0ed7c2474bcbd" translate="yes" xml:space="preserve">
          <source>This behaviour is similar to &lt;code&gt;link-to&lt;/code&gt;, which also lets you opt into a &lt;code&gt;replaceState&lt;/code&gt; transition via &lt;code&gt;replace=true&lt;/code&gt;.</source>
          <target state="translated">이 동작은 &lt;code&gt;link-to&lt;/code&gt; 와 유사하며 &lt;code&gt;replace=true&lt;/code&gt; 를 통해 &lt;code&gt;replaceState&lt;/code&gt; 전환을 선택할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="646b88b52695fd5b351e17ed4f20ebf3a312b1da" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation has completed.</source>
          <target state="translated">이 콜백은 비동기 작업이 완료 될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3decb642e6ed5fe3151ae228c0dab60ea9dbcb" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation is about to start.</source>
          <target state="translated">이 콜백은 비동기 작업이 시작될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6e4f6495a0bfd49c0b770ee29b970fcdc0b8a129" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring the &lt;code&gt;rootURL&lt;/code&gt; property on &lt;code&gt;ENV&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 에서 &lt;code&gt;rootURL&lt;/code&gt; 속성을 구성하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="592e84b1e0b4e61032446b865d26f0c9377deab5" translate="yes" xml:space="preserve">
          <source>This can be done on the result of a &lt;code&gt;store.query()&lt;/code&gt; call:</source>
          <target state="translated">이것은 &lt;code&gt;store.query()&lt;/code&gt; 호출 결과에서 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f869a4e4a76d784deb8c0310fd8160dedadf6c" translate="yes" xml:space="preserve">
          <source>This class can also be useful as a layer to transform the contents of an array, as they are accessed. This can be done by overriding &lt;code&gt;objectAtContent&lt;/code&gt;:</source>
          <target state="translated">이 클래스는 액세스 할 때 배열의 내용을 변환하는 레이어로 유용 할 수 있습니다. &lt;code&gt;objectAtContent&lt;/code&gt; 를 재정 의하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c735fa315afadd4e939bc22605b4168dc7fd925" translate="yes" xml:space="preserve">
          <source>This class can be extended by a custom resolver implementer to override some of the methods with library-specific code.</source>
          <target state="translated">이 클래스는 사용자 정의 리졸버 구현 자에 의해 확장되어 라이브러리 특정 코드로 일부 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3106dd228ae8524f2463f5eb418ced8f6f5d8666" translate="yes" xml:space="preserve">
          <source>This class implements the methods defined by Ember.Test.Adapter for the QUnit testing framework.</source>
          <target state="translated">이 클래스는 QUnit 테스트 프레임 워크를 위해 Ember.Test.Adapter에 의해 정의 된 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="320b5810ffa80935692e4a814095e9bb406c7d7d" translate="yes" xml:space="preserve">
          <source>This class will be extended by a persistence library which will override some of the methods with library-specific code.</source>
          <target state="translated">이 클래스는 라이브러리 특정 코드로 일부 메소드를 대체하는 지속성 라이브러리로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="674eb11f18e5896906fc06f889797fc9a66d2250" translate="yes" xml:space="preserve">
          <source>This code example uses the latest features in JavaScript, some of which you may not be familiar with. Learn more with this &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;overview of the newest JavaScript features&lt;/a&gt;.</source>
          <target state="translated">이 코드 예제는 JavaScript의 최신 기능을 사용하지만 일부는 익숙하지 않을 수 있습니다. &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;최신 JavaScript 기능에 대한 개요를&lt;/a&gt; 자세히 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="0fc86456128b2bec3fcb1e1970d2427a1fdb6365" translate="yes" xml:space="preserve">
          <source>This component would render the following:</source>
          <target state="translated">이 구성 요소는 다음을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="e42d35491e18c0eb8d5095f19ff074a10aab3fc5" translate="yes" xml:space="preserve">
          <source>This computed property would return a map describing these relationships, like this:</source>
          <target state="translated">이 계산 된 속성은 다음과 같이 이러한 관계를 설명하는 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec813caf1f669a427b25e6f09bf93ba65ce6c773" translate="yes" xml:space="preserve">
          <source>This creates a route file at &lt;code&gt;app/routes/route-name.js&lt;/code&gt;, a template for the route at &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt;, and a unit test file at &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt;. It also adds the route to the router.</source>
          <target state="translated">이렇게하면 &lt;code&gt;app/routes/route-name.js&lt;/code&gt; 에 경로 파일 , &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt; 에 경로 템플릿 , &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt; 단위 테스트 파일이 생성됩니다 . JS . 또한 라우터에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="91ce519eb8ba59c7f3b8c3662743cb9f43554cc3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;fullName&lt;/code&gt; to be a computed property, with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; as the properties it depends on. The first time you access the &lt;code&gt;fullName&lt;/code&gt; property, the function will be called and the results will be cached. Subsequent access of &lt;code&gt;fullName&lt;/code&gt; will read from the cache without calling the function. Changing any of the dependent properties causes the cache to invalidate, so that the computed function runs again on the next access.</source>
          <target state="translated">이는 &lt;code&gt;fullName&lt;/code&gt; 을 계산 된 특성으로 선언 하며, &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 을 종속 특성으로 사용합니다. &lt;code&gt;fullName&lt;/code&gt; 속성에 처음 액세스하면 함수가 호출되고 결과가 캐시됩니다. &lt;code&gt;fullName&lt;/code&gt; 에 대한 후속 액세스 는 함수를 호출하지 않고 캐시에서 읽습니다. 종속 특성을 변경하면 캐시가 무효화되어 계산 된 기능이 다음 액세스에서 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31bb2006f39cafcc9484e2a81a9f308f7180aef7" translate="yes" xml:space="preserve">
          <source>This defines a new &lt;code&gt;Person&lt;/code&gt; class with a &lt;code&gt;say()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;say()&lt;/code&gt; 메소드 로 새로운 &lt;code&gt;Person&lt;/code&gt; 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="116d968a917da2cb6719f721c279bfccee4349ce" translate="yes" xml:space="preserve">
          <source>This defines a new subclass of Ember.Object: &lt;code&gt;Person&lt;/code&gt;. It contains one method: &lt;code&gt;say()&lt;/code&gt;.</source>
          <target state="translated">이것은 Ember.Object의 새로운 서브 클래스를 정의합니다 : &lt;code&gt;Person&lt;/code&gt; . 여기에는 &lt;code&gt;say()&lt;/code&gt; 메소드가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4af4dccef2a80a69c041a6f95a959661b8e03a9" translate="yes" xml:space="preserve">
          <source>This doesn't usually affect application code because computed properties are almost always observed at the same time as they are fetched. For example, you get the value of a computed property, put it in DOM (or draw it with D3), and then observe it so you can update the DOM once the property changes.</source>
          <target state="translated">계산 된 속성은 거의 항상 페치되는 것과 동시에 관찰되므로 응용 프로그램 코드에는 영향을 미치지 않습니다. 예를 들어 계산 된 속성의 값을 가져 와서 DOM에 넣거나 D3으로 그리면 속성이 변경되면 DOM을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784b0ed31150b193e479ab80ab41ebf62f83f1ec" translate="yes" xml:space="preserve">
          <source>This error would then be returned by an adapter's &lt;code&gt;handleResponse&lt;/code&gt; method:</source>
          <target state="translated">이 오류는 어댑터의 &lt;code&gt;handleResponse&lt;/code&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6170d3568edf87d92c7c80728ddd942353f0af6" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 이벤트는 라우터가이 경로를 완전히 종료하면 트리거됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b0c96e516f34305bd6b72b775ae4db9e3545500" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 이벤트는 라우터가 경로에 들어 오면 트리거됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cab4a8f298d62a398a20d8205ec2eba83599f69c" translate="yes" xml:space="preserve">
          <source>This example of a post model has many comments:</source>
          <target state="translated">이 포스트 모델 예제에는 많은 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe7ed9c19bb8a7f1cbe6b019c963a036d9478fe" translate="yes" xml:space="preserve">
          <source>This example of an author model belongs to a post model:</source>
          <target state="translated">이 저자 모델의 예는 포스트 모델에 속합니다.</target>
        </trans-unit>
        <trans-unit id="7ccc911768f0da88e6ef9f3cf49eef3b432ed969" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;=&amp;gt;&lt;/code&gt; function syntax, which is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;new ES2015 syntax for callback functions&lt;/a&gt; that provides a lexical &lt;code&gt;this&lt;/code&gt;. If this syntax is new, think of it as a function that has the same &lt;code&gt;this&lt;/code&gt; as the context it is defined in.</source>
          <target state="translated">이 예제는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 함수 구문을 사용하는데 , 이것은 어휘 &lt;code&gt;this&lt;/code&gt; 을 제공하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;콜백 함수&lt;/a&gt; 를 위한 새로운 ES2015 구문입니다 . 이 구문이 새로운 경우, 동일한 갖는 함수로 생각 &lt;code&gt;this&lt;/code&gt; 그것에서 정의되는 컨텍스트있다.</target>
        </trans-unit>
        <trans-unit id="ff609b107eeeef59c10a02a7f765526a45b3b82b" translate="yes" xml:space="preserve">
          <source>This example will create a &lt;code&gt;posts&lt;/code&gt; property on the &lt;code&gt;post&lt;/code&gt; controller that looks up the &lt;code&gt;posts&lt;/code&gt; controller in the container, making it easy to reference other controllers. This is functionally equivalent to:</source>
          <target state="translated">이 예는 만듭니다 &lt;code&gt;posts&lt;/code&gt; 상의 특성 &lt;code&gt;post&lt;/code&gt; 위로 보이는 컨트롤러 &lt;code&gt;posts&lt;/code&gt; 컨테이너의 컨트롤러는, 쉽게 다른 컨트롤러를 참조 할 수있게합니다. 이것은 기능적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49855cd9123878194ff56a8b6fd54aa27e05b647" translate="yes" xml:space="preserve">
          <source>This example will create an &lt;code&gt;authManager&lt;/code&gt; property on the application route that looks up the &lt;code&gt;auth&lt;/code&gt; service in the container, making it easily accessible in the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">이 예제는 컨테이너에서 &lt;code&gt;auth&lt;/code&gt; 서비스 를 조회하는 애플리케이션 라우트에 &lt;code&gt;authManager&lt;/code&gt; 특성을 작성 하여 &lt;code&gt;model&lt;/code&gt; 후크 에서 쉽게 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="6567df05d4a192c48cd4c99f719e2addb19ced5a" translate="yes" xml:space="preserve">
          <source>This example would create the font file in &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt; 에 글꼴 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="487dfa2fb498fbeeecec5ffef779e77c25b4bf73" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual concatenated property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">이 기능은 Ember 객체 모델 전체에서 사용할 수 있지만 일반적인 앱 개발자는 자주 사용하지 않을 수 있습니다. 속성의 동작에 대한 기대치가 변경되므로 각 개별 연결된 속성의 사용법을 올바르게 문서화해야합니다 (사용자가 하위 클래스의 속성을 재정의 할 수 있다고 오인하지 않도록).</target>
        </trans-unit>
        <trans-unit id="0e9e3a7edaabb385dc159a68dfa2582b6dd6bf05" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual merged property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">이 기능은 Ember 객체 모델 전체에서 사용할 수 있지만 일반적인 앱 개발자는 자주 사용하지 않을 수 있습니다. 속성의 동작에 대한 기대치가 변경되므로 병합 된 각 개별 속성의 사용법을 올바르게 문서화해야합니다 (사용자가 하위 클래스의 속성을 재정의 할 수 있다고 오인하지 않도록).</target>
        </trans-unit>
        <trans-unit id="d8a914b8d45890e4d1608c302453e2c8af0f22d0" translate="yes" xml:space="preserve">
          <source>This feature is backed by &lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt; and &lt;a href=&quot;http://caniuse.com/&quot;&gt;Can I Use&lt;/a&gt;. These websites track usage stats of browsers, so you can use complex queries based on the user base of every browser.</source>
          <target state="translated">이 기능에 의해 백업됩니다 &lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt; 및 &lt;a href=&quot;http://caniuse.com/&quot;&gt;수 있습니까 사용&lt;/a&gt; . 이러한 웹 사이트는 브라우저의 사용 통계를 추적하므로 모든 브라우저의 사용자 기반에 따라 복잡한 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecc77b26d29bca9f5a5a76e216f7aa3707d9f628" translate="yes" xml:space="preserve">
          <source>This function should return negative number (e.g. &lt;code&gt;-1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come before &lt;code&gt;itemB&lt;/code&gt;. It should return positive number (e.g. &lt;code&gt;1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come after &lt;code&gt;itemB&lt;/code&gt;. If the &lt;code&gt;itemA&lt;/code&gt; and &lt;code&gt;itemB&lt;/code&gt; are equal this function should return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;itemA&lt;/code&gt; 가 &lt;code&gt;itemB&lt;/code&gt; 앞에 오면 음수 (예 : &lt;code&gt;-1&lt;/code&gt; )를 반환 해야합니다 . &lt;code&gt;itemA&lt;/code&gt; 가 &lt;code&gt;itemB&lt;/code&gt; 뒤에 올 때 양수 (예 : &lt;code&gt;1&lt;/code&gt; )를 반환 해야합니다 . 는 IF &lt;code&gt;itemA&lt;/code&gt; 및 &lt;code&gt;itemB&lt;/code&gt; 은 동일한 기능이 돌려 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f30316f73cbc0d1bc15eef0cddcc2f8521c3da8f" translate="yes" xml:space="preserve">
          <source>This function takes an optional 2nd argument that will become the &quot;this&quot; value for the callback. If this argument is passed then the 3rd argument becomes the function.</source>
          <target state="translated">이 함수는 콜백의 &quot;this&quot;값이 될 선택적 두 번째 인수를 사용합니다. 이 인수가 전달되면 세 번째 인수가 함수가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4f4cb957931dcfb537731cc8f27357bfd707b9e" translate="yes" xml:space="preserve">
          <source>This generates the following HTML:</source>
          <target state="translated">다음과 같은 HTML이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b56834d4d36dbad6e5fe72083562d1d2e8904eaf" translate="yes" xml:space="preserve">
          <source>This generates this file:</source>
          <target state="translated">이 파일을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="acffd8287f5f7fa62edb1b3b419955bbdbbac080" translate="yes" xml:space="preserve">
          <source>This gives you the flexibility to compute a value &lt;em&gt;before&lt;/em&gt; it is passed in as an argument or an attribute of another.</source>
          <target state="translated">이를 통해 인수 또는 다른 속성으로 전달 &lt;em&gt;되기 전에&lt;/em&gt; 값을 유연하게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fcb44dfac184e5f4739827479344f6a392ecca" translate="yes" xml:space="preserve">
          <source>This guide doesn't intend to fully delve into all the different ways promises can be used, but if you'd like a more thorough introduction, take a look at the readme for &lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt;, the promise library that Ember uses.</source>
          <target state="translated">이 안내서는 약속이 사용될 수있는 모든 다른 방법을 완전히 탐구하지는 않겠지 만보다 철저한 소개를 원한다면 Ember가 사용하는 약속 라이브러리 인 &lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt; 에 대한 추가 정보를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="e0e66094f6d943792b41d17683719c61a494f26d" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to build a simple app using Ember from scratch.</source>
          <target state="translated">이 안내서는 Ember를 사용하여 처음부터 간단한 앱을 작성하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="30d220e5292c20d9ac340b310df750f8c7cfdd17" translate="yes" xml:space="preserve">
          <source>This happens if you are using a version of Ember &amp;lt; 1.3.</source>
          <target state="translated">Ember &amp;lt;1.3 버전을 사용하는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="02c316553c03e6bb16963930257b1149ad1c5f21" translate="yes" xml:space="preserve">
          <source>This has the effect of providing a default template when using a component in the non-block form but providing yielded values for use with block params when using a block expression.</source>
          <target state="translated">이는 비 블록 형태의 구성 요소를 사용할 때 기본 템플릿을 제공하지만 블록 표현식을 사용할 때 블록 매개 변수와 함께 사용할 수있는 값을 제공하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d69577f3c578c6eabf0c4658463bd74f9978c696" translate="yes" xml:space="preserve">
          <source>This helper can later be called without arguments because it will be called with &lt;code&gt;app&lt;/code&gt; as the first parameter.</source>
          <target state="translated">이 도우미는 나중에 &lt;code&gt;app&lt;/code&gt; 없이 첫 번째 매개 변수로 호출되므로 인수없이 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9980bdea2787a4277e138ccf5100590320a94254" translate="yes" xml:space="preserve">
          <source>This helper has two forms, block and inline.</source>
          <target state="translated">이 도우미에는 블록과 인라인의 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="78766705ae99c240131efc47a151aeeb110c957c" translate="yes" xml:space="preserve">
          <source>This helper returns a new property descriptor that wraps the passed computed property function. You can use this helper to define properties with mixins or via &lt;code&gt;Ember.defineProperty()&lt;/code&gt;.</source>
          <target state="translated">이 도우미는 전달 된 계산 된 속성 함수를 래핑하는 새로운 속성 설명자를 반환합니다. 이 헬퍼를 사용하여 mixin 또는 &lt;code&gt;Ember.defineProperty()&lt;/code&gt; 를 통해 속성을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10ab382783ea15303c4f3ab1e310527699744871" translate="yes" xml:space="preserve">
          <source>This helper will output a value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">이 도우미는 &lt;code&gt;6&lt;/code&gt; 값을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="6c987e5674d133f7c1af95e69f41a85eb2745738" translate="yes" xml:space="preserve">
          <source>This hook defers the readiness of the application, so that you can start the app when your tests are ready to run. It also sets the router's location to 'none', so that the window's location will not be modified (preventing both accidental leaking of state between tests and interference with your testing framework). &lt;code&gt;setupForTesting&lt;/code&gt; should only be called after setting a custom &lt;code&gt;router&lt;/code&gt; class (for example &lt;code&gt;App.Router = Router.extend(&lt;/code&gt;).</source>
          <target state="translated">이 후크는 응용 프로그램의 준비 상태를 지연시켜 테스트를 실행할 준비가되었을 때 앱을 시작할 수 있도록합니다. 또한 라우터의 위치를 ​​'없음'으로 설정하여 창의 위치가 수정되지 않도록합니다 (테스트 사이에 실수로 상태가 누출되거나 테스트 프레임 워크와의 간섭이 발생하지 않도록 함). &lt;code&gt;setupForTesting&lt;/code&gt; 은 사용자 정의 &lt;code&gt;router&lt;/code&gt; 클래스를 설정 한 후에 만 ​​호출해야합니다 (예 : &lt;code&gt;App.Router = Router.extend(&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="9f3850932b6cdc771f8eba24e4c0356c191dabae" translate="yes" xml:space="preserve">
          <source>This hook follows the asynchronous/promise semantics described in the documentation for &lt;code&gt;beforeModel&lt;/code&gt;. In particular, if a promise returned from &lt;code&gt;model&lt;/code&gt; fails, the error will be handled by the &lt;code&gt;error&lt;/code&gt; hook on &lt;code&gt;Ember.Route&lt;/code&gt;.</source>
          <target state="translated">이 후크는 &lt;code&gt;beforeModel&lt;/code&gt; 문서에 설명 된 비동기 / 약속 시맨틱을 따릅니다 . 특히, &lt;code&gt;model&lt;/code&gt; 에서 반환 된 약속 이 실패하면 오류는 &lt;code&gt;Ember.Route&lt;/code&gt; 의 &lt;code&gt;error&lt;/code&gt; 후크에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8ee41feb9ddc3fa7957fac4385c3669d97c9aa0" translate="yes" xml:space="preserve">
          <source>This hook is called after this route's model has resolved. It follows identical async/promise semantics to &lt;code&gt;beforeModel&lt;/code&gt; but is provided the route's resolved model in addition to the &lt;code&gt;transition&lt;/code&gt;, and is therefore suited to performing logic that can only take place after the model has already resolved.</source>
          <target state="translated">이 라우트는이 경로의 모델이 해결 된 후에 호출됩니다. &lt;code&gt;beforeModel&lt;/code&gt; 과 동일한 비동기 / 약속 시맨틱을 따르지만 &lt;code&gt;transition&lt;/code&gt; 외에도 경로의 해석 된 모델이 제공 되므로 모델이 이미 해석 된 후에 만 ​​수행 할 수있는 논리를 수행하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="eabb2494e26202e5215d9e0f9642c252667f7896" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 후크는 라우터가이 경로를 완전히 종료 할 때 실행됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab287814fce6cc5b5c9f8e315d84a3c408dbd520" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">이 훅은 라우터가 경로에 들어갈 때 실행됩니다. 라우트 모델이 변경되면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ed5112cc8742b9d70e3846b62e3c7a4f35140f1" translate="yes" xml:space="preserve">
          <source>This hook is provided the current &lt;code&gt;transition&lt;/code&gt; attempt as a parameter, which can be used to &lt;code&gt;.abort()&lt;/code&gt; the transition, save it for a later &lt;code&gt;.retry()&lt;/code&gt;, or retrieve values set on it from a previous hook. You can also just call &lt;code&gt;this.transitionTo&lt;/code&gt; to another route to implicitly abort the &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">이 후크는 현재 제공되는 &lt;code&gt;transition&lt;/code&gt; 하는데 사용될 수있는 매개 변수로서 시도 &lt;code&gt;.abort()&lt;/code&gt; 이후의 저장을 위해 천이를 &lt;code&gt;.retry()&lt;/code&gt; 또는 이전 후크에서 설정 값을 검색한다. &lt;code&gt;this.transitionTo&lt;/code&gt; 를 다른 경로로 호출 하여 &lt;code&gt;transition&lt;/code&gt; 을 암시 적으로 중단 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03eecee84bea910e6f484a02d840e085770096a0" translate="yes" xml:space="preserve">
          <source>This hook is the first of the route entry validation hooks called when an attempt is made to transition into a route or one of its children. It is called before &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;afterModel&lt;/code&gt;, and is appropriate for cases when:</source>
          <target state="translated">이 후크는 경로 또는 하위 경로 중 하나로 전환하려고 할 때 호출되는 첫 번째 경로 항목 유효성 검증 후크입니다. &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; 전에 호출 되며 다음과 같은 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="77e8a262fef81666b48b6131a8b3be017a044f7d" translate="yes" xml:space="preserve">
          <source>This hook passes the class being set up, as well as the key and value being defined. So, for example, when the user does this:</source>
          <target state="translated">이 후크는 설정중인 키와 값뿐만 아니라 설정중인 클래스를 전달합니다. 예를 들어, 사용자가이를 수행 할 때 :</target>
        </trans-unit>
        <trans-unit id="b11aa29d15777ceef5c81c577245a76748891249" translate="yes" xml:space="preserve">
          <source>This hook would be called with &quot;parent&quot; as the key and the computed property returned by &lt;code&gt;DS.belongsTo&lt;/code&gt; as the value.</source>
          <target state="translated">이 후크는 &quot;parent&quot;를 키로 사용하고 &lt;code&gt;DS.belongsTo&lt;/code&gt; 가 값을 반환하는 계산 된 속성으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc7a1f064649acf207da18e9b59a14b7d7c2ed5" translate="yes" xml:space="preserve">
          <source>This illustrates that once you change a query param, it is stored and tied to the model loaded into the route.</source>
          <target state="translated">이는 쿼리 매개 변수를 변경하면 쿼리 매개 변수가 저장되고 경로에로드 된 모델에 연결되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="94954009755f7b62385acf4ff8569cb1a9193610" translate="yes" xml:space="preserve">
          <source>This implementation groups together records that have the same base URL but differing ids. For example &lt;code&gt;/comments/1&lt;/code&gt; and &lt;code&gt;/comments/2&lt;/code&gt; will be grouped together because we know findMany can coalesce them together as &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt;</source>
          <target state="translated">이 구현은 기본 URL은 동일하지만 ID가 다른 레코드를 그룹화합니다. 예를 들어 &lt;code&gt;/comments/1&lt;/code&gt; 과 &lt;code&gt;/comments/2&lt;/code&gt; 는 findMany가 &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt; 로 통합 할 수 있으므로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="cc9ad364e420bf1a681684a934117cc1159d58e2" translate="yes" xml:space="preserve">
          <source>This injects the shopping cart service into the component and makes it available as the &lt;code&gt;cart&lt;/code&gt; property.</source>
          <target state="translated">이렇게하면 장바구니 서비스가 구성 요소에 주입되어 &lt;code&gt;cart&lt;/code&gt; 속성으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="918384a3831377bfd82a1b852b04244ee7f5702c" translate="yes" xml:space="preserve">
          <source>This injects the test helpers into the &lt;code&gt;helperContainer&lt;/code&gt; object. If an object is provided it will be used as the helperContainer. If &lt;code&gt;helperContainer&lt;/code&gt; is not set it will default to &lt;code&gt;window&lt;/code&gt;. If a function of the same name has already been defined it will be cached (so that it can be reset if the helper is removed with &lt;code&gt;unregisterHelper&lt;/code&gt; or &lt;code&gt;removeTestHelpers&lt;/code&gt;).</source>
          <target state="translated">그러면 테스트 헬퍼가 &lt;code&gt;helperContainer&lt;/code&gt; 오브젝트에 주입 됩니다. 객체가 제공되면 helperContainer로 사용됩니다. 경우 &lt;code&gt;helperContainer&lt;/code&gt; 이 설정되지 않은이 기본값이됩니다 &lt;code&gt;window&lt;/code&gt; . 동일한 이름의 함수가 이미 정의되어 있으면 캐시됩니다 ( &lt;code&gt;unregisterHelper&lt;/code&gt; 또는 &lt;code&gt;removeTestHelpers&lt;/code&gt; 로 도우미를 제거하면 재설정 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="f723a6881e5d6d4df77092077259b1e266ea97bd" translate="yes" xml:space="preserve">
          <source>This is a concept that typically means providing JavaScript which tests for features that are missing (prototypes not defined, etc) and &quot;fills&quot; them by providing an implementation.</source>
          <target state="translated">이것은 일반적으로 누락 된 기능 (정의되지 않은 프로토 타입 등)을 테스트하고 구현을 제공하여 &quot;채우는&quot;JavaScript를 제공한다는 개념입니다.</target>
        </trans-unit>
        <trans-unit id="b176511dc82a11995524ba7ee6d3eaf35d75f683" translate="yes" xml:space="preserve">
          <source>This is a container for an assortment of testing related functionality:</source>
          <target state="translated">다음은 다양한 테스트 관련 기능을위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="822a2e55a49b0a3ce1602c9de4a12deec4027902" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.all&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.all&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="a49db288a4492f38be2239b9a4aecd51132e4df3" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.race&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.race&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="c5311bad197bc2e95ae7fce155d89195d60075c0" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.reject&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.reject&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="302b1ad84c9db80e1b5c3df3fe7952f0681a2eae" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt; 의 편리한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="4971ebf34a654ca424132ff11439c59713fb5e6b" translate="yes" xml:space="preserve">
          <source>This is a great way to use the parent context to load something that you want. Using &lt;code&gt;paramsFor&lt;/code&gt; will also give you the query params defined on that route's controller. This method could also be used to look up the current route's parameters from an action or another method on the route, and in that case we have a shortcut: &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt;.</source>
          <target state="translated">이것은 부모 컨텍스트를 사용하여 원하는 것을로드하는 좋은 방법입니다. &lt;code&gt;paramsFor&lt;/code&gt; 를 사용하면 해당 경로의 컨트롤러에 정의 된 쿼리 매개 변수도 제공됩니다. 이 메소드는 액션이나 라우트의 다른 메소드에서 현재 라우트의 매개 변수를 찾는 데 사용될 수 있으며,이 경우 바로 가기 &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="55cd0539422e5b82b20c0cc8f62bbdbb7052339e" translate="yes" xml:space="preserve">
          <source>This is a helper to be used in conjunction with the link-to helper. It will supply url query parameters to the target route.</source>
          <target state="translated">이것은 링크 헬퍼와 함께 사용되는 헬퍼입니다. URL 쿼리 매개 변수를 대상 경로에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05915bea473f3b9dca751ce1d38f16283b7858bd" translate="yes" xml:space="preserve">
          <source>This is a more semantically meaningful alias of &lt;code&gt;computed.oneWay&lt;/code&gt;, whose name is somewhat ambiguous as to which direction the data flows.</source>
          <target state="translated">이것은 의미 적으로 의미가있는 &lt;code&gt;computed.oneWay&lt;/code&gt; 의 별칭 으로, 데이터가 어느 방향으로 흐르는 지에 대한 이름이 다소 모호합니다.</target>
        </trans-unit>
        <trans-unit id="46a94c8f55595ad1f21083bd7fb3718a4dbf03a0" translate="yes" xml:space="preserve">
          <source>This is a stamp for the Ember Inspector to differentiate between the versions to be able to support older versions too.</source>
          <target state="translated">이것은 Ember Inspector가 이전 버전도 지원할 수 있도록 버전을 구별하기위한 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="ec2df623b6ecc9f4e570340c54e42cd3266c977a" translate="yes" xml:space="preserve">
          <source>This is actually used internally by the &lt;code&gt;keyEvent&lt;/code&gt; helper like so:</source>
          <target state="translated">이것은 실제로 다음과 같이 &lt;code&gt;keyEvent&lt;/code&gt; 도우미에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="308ba443f81e87e775aa3ae34fbf288a703e8c5c" translate="yes" xml:space="preserve">
          <source>This is an interface class that exists purely to document the available options; you do not need to construct it manually. Simply pass a regular JavaScript object containing the desired options into methods that require one of these options object:</source>
          <target state="translated">사용 가능한 옵션을 문서화하기 위해 존재하는 인터페이스 클래스입니다. 수동으로 구성 할 필요가 없습니다. 원하는 옵션이 포함 된 일반 JavaScript 객체를 다음 옵션 객체 중 하나가 필요한 메소드에 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="306dec7bd8c7954e508c1735c09535d1dd8b815e" translate="yes" xml:space="preserve">
          <source>This is especially useful when you depend on properties of an object, since it allows you to replace:</source>
          <target state="translated">다음과 같이 바꿀 수 있기 때문에 객체의 속성에 의존 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c46a6c0ebb4282802f95e4e63e750434a46d6914" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to the &lt;code&gt;format-currency&lt;/code&gt; example above. You can think of the function version as a shorthand for the longer class form if it does not require dependency injection.</source>
          <target state="translated">이것은 위 의 &lt;code&gt;format-currency&lt;/code&gt; 예 와 정확히 동일합니다 . 의존성 주입이 필요하지 않으면 함수 버전을 더 긴 클래스 양식의 속기라고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80b9a9d98da12b68b0c4b2e6f44b4b81fb921c26" translate="yes" xml:space="preserve">
          <source>This is generally used internally from the acceptance/integration test infrastructure.</source>
          <target state="translated">이는 일반적으로 수락 / 통합 테스트 인프라에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a02623baf101f6c1f72c8f3ddff6f2d7a7b7ddbb" translate="yes" xml:space="preserve">
          <source>This is guaranteed to work because the parent route is loaded. But if you tried to do &lt;code&gt;paramsFor&lt;/code&gt; on a sibling route, you wouldn't have the results you expected.</source>
          <target state="translated">부모 경로가로드되었으므로 작동합니다. 그러나 형제 루트에서 &lt;code&gt;paramsFor&lt;/code&gt; 를 시도 하면 예상 한 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa36d77986525618ad7065da5d31723d28369a95" translate="yes" xml:space="preserve">
          <source>This is most often used as the return value for the helper functions (see 'click', 'fillIn','visit',etc). However, there is a method to register a test helper which utilizes this method without the need to actually call &lt;code&gt;wait()&lt;/code&gt; in your helpers.</source>
          <target state="translated">도우미 함수의 반환 값으로 가장 많이 사용됩니다 ( 'click', 'fillIn', 'visit'등 참조). 그러나 헬퍼에서 실제로 &lt;code&gt;wait()&lt;/code&gt; 를 호출 할 필요없이이 메소드를 사용하는 테스트 헬퍼를 등록하는 메소드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e012518624cc2f89b04d821689a88883b2eadb7c" translate="yes" xml:space="preserve">
          <source>This is not an Ember application</source>
          <target state="translated">이것은 Ember 애플리케이션이 아닙니다</target>
        </trans-unit>
        <trans-unit id="c62cbb1d5e63e1e37b85a51686c003fd0001230a" translate="yes" xml:space="preserve">
          <source>This is not just a performance optimization. If an attribute has not changed, it is important not to clobber the element's &quot;hidden state&quot;. For example, if you set an input's &lt;code&gt;value&lt;/code&gt; to the same value as before, it will clobber selection state and cursor position. In other words, setting an attribute is not &lt;strong&gt;always&lt;/strong&gt; idempotent.</source>
          <target state="translated">이것은 단지 성능 최적화가 아닙니다. 속성이 변경되지 않은 경우 요소의 &quot;숨겨진 상태&quot;를 방해하지 않는 것이 중요합니다. 당신이 입력의 설정 예를 들어, &lt;code&gt;value&lt;/code&gt; 이전과 동일한 값으로,이 선택 상태 및 커서 위치를 소지품 것입니다. 다시 말해, 속성 설정이 &lt;strong&gt;항상&lt;/strong&gt; dem 등한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="bfe703d974f911cefa2119330aa9316aad45d5a9" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. If your object supports retrieving the value of an array item using &lt;code&gt;get()&lt;/code&gt; (i.e. &lt;code&gt;myArray.get(0)&lt;/code&gt;), then you do not need to implement this method yourself.</source>
          <target state="translated">이것은 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하기 위해 구현해야하는 기본 요소 중 하나입니다 . 객체가 &lt;code&gt;get()&lt;/code&gt; (예 : &lt;code&gt;myArray.get(0)&lt;/code&gt; )을 사용하여 배열 항목의 값 검색을 지원 하면이 메소드를 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9a9fd73a9f803dbe1cc43144f590d9b54349043" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. You should replace amt objects started at idx with the objects in the passed array. You should also call &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하기 위해 구현해야하는 기본 요소 중 하나입니다 . idx에서 시작한 amt 객체를 전달 된 배열의 객체로 바꿔야합니다. &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt; 도 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f356f63243afe37729165e88f111f35dc1627c0e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for polymorphic relationships where records don't share the same table and the &lt;code&gt;id&lt;/code&gt; is not enough information.</source>
          <target state="translated">레코드가 동일한 테이블을 공유하지 않고 &lt;code&gt;id&lt;/code&gt; 가 충분한 정보가 아닌 다형성 관계에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="202d339791e806b1e70147736eb9208a5f3911be" translate="yes" xml:space="preserve">
          <source>This is primarily used when syncing bindings, which may try to update after an object has been destroyed.</source>
          <target state="translated">이것은 바인딩을 동기화 할 때 주로 사용되며, 객체가 파괴 된 후에 업데이트를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daeaceef80ff296a12644de6285774c59ae74c52" translate="yes" xml:space="preserve">
          <source>This is the core method used to register an observer for a property.</source>
          <target state="translated">이것은 속성에 대한 관찰자를 등록하는 데 사용되는 핵심 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bac9760d303007d38afed39bbecd73ad9b39f5bb" translate="yes" xml:space="preserve">
          <source>This is the element that will be passed to the Application's, &lt;code&gt;eventDispatcher&lt;/code&gt;, which sets up the listeners for event delegation. Every view in your application should be a child of the element you specify here.</source>
          <target state="translated">이것은 이벤트 위임을위한 리스너를 설정 하는 응용 프로그램 &lt;code&gt;eventDispatcher&lt;/code&gt; 로 전달 될 요소입니다 . 응용 프로그램의 모든 뷰는 여기에 지정한 요소의 자식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="decc32c6cf9850c53e2f6bac9e782138a3406ae1" translate="yes" xml:space="preserve">
          <source>This is the extent to which Ember.js enhances native prototypes. We have carefully weighed the tradeoffs involved with changing these prototypes, and recommend that most Ember.js developers use them. These extensions significantly reduce the amount of boilerplate code that must be typed.</source>
          <target state="translated">이것은 Ember.js가 기본 프로토 타입을 향상시키는 정도입니다. 우리는 이러한 프로토 타입 변경과 관련된 트레이드 오프를 신중하게 검토했으며 대부분의 Ember.js 개발자가이 프로토 타입을 사용하도록 권장합니다. 이러한 확장은 입력해야하는 상용구 코드의 양을 크게 줄입니다.</target>
        </trans-unit>
        <trans-unit id="94928a1a6bed0b1e582ca40e9000c55b3eb6631f" translate="yes" xml:space="preserve">
          <source>This is the handler for the special array content property. If you get this property, it will return this. If you set this property to a new array, it will replace the current content.</source>
          <target state="translated">이것은 특별한 배열 내용 속성의 핸들러입니다. 이 속성을 가져 오면이를 반환합니다. 이 속성을 새 배열로 설정하면 현재 내용이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="dada04f5800d31f549425491d1886c63a016bd11" translate="yes" xml:space="preserve">
          <source>This is typically a paid service you can use to get great performance for your app. Many CDNs act as caching proxies to your origin server; some require you to upload your assets to them. They give you a URL for each resource in your app. This URL will resolve differently for folks depending on where they're browsing.</source>
          <target state="translated">일반적으로 앱의 성능을 높이기 위해 사용할 수있는 유료 서비스입니다. 많은 CDN은 오리진 서버에 프록시를 캐싱하는 역할을합니다. 일부는 자산을 업로드해야합니다. 앱의 각 리소스에 대한 URL을 제공합니다. 이 URL은 사용자가 탐색하는 위치에 따라 다르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="9029cd114fa0d3c8586307b8eff931586da2bfe7" translate="yes" xml:space="preserve">
          <source>This is useful if you have a good sense of what records the user will need next. When they click on a link, instead of waiting for a network request to finish, Ember.js can render the new template immediately. It feels instantaneous.</source>
          <target state="translated">다음에 사용자에게 필요한 레코드가 무엇인지 잘 알고있는 경우에 유용합니다. 링크를 클릭하면 네트워크 요청이 완료되기를 기다리는 대신 Ember.js가 새 템플릿을 즉시 렌더링 할 수 있습니다. 순간적으로 느낀다.</target>
        </trans-unit>
        <trans-unit id="9c0e2a474431ea68ddf5ecf51a7ea34a70a0a409" translate="yes" xml:space="preserve">
          <source>This is useful in many ways, as the controller specified will be:</source>
          <target state="translated">지정된 컨트롤러는 다음과 같이 여러 가지 방법으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6ade33abb6fdd45e411d88ae2ac98039f0bf103b" translate="yes" xml:space="preserve">
          <source>This is why all Ember's test helpers are wrapped in code that ensures Ember is back in a synchronized state when it makes its assertions. It saves you from having to wrap everything in code that does that, and it makes it easier to read your tests because there's less boilerplate in them.</source>
          <target state="translated">그렇기 때문에 모든 Ember의 테스트 헬퍼가 코드로 감싸 져있어 Ember가 어설 션을 만들 때 동기화 상태로 돌아갑니다. 이를 통해 모든 것을 코드로 감싸지 않아도되며, 상용구가 적기 때문에 테스트를보다 쉽게 ​​읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="373629a051fd9d6a82479c3fb955dcff38bff20a" translate="yes" xml:space="preserve">
          <source>This list of attributes is inherited from the component's superclasses, as well.</source>
          <target state="translated">이 속성 목록은 구성 요소의 수퍼 클래스에서도 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="9d2978c3cf092adf7f085027707c1fa11a58cc84" translate="yes" xml:space="preserve">
          <source>This list of properties is inherited from the component's superclasses as well.</source>
          <target state="translated">이 속성 목록은 구성 요소의 수퍼 클래스에서도 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5f23b5212bb7243dee0fb723c49f54d8ba342c" translate="yes" xml:space="preserve">
          <source>This may be helpful for keeping links active for:</source>
          <target state="translated">다음에 대한 링크를 활성 상태로 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="627b891473247bd5815547809011482806305c21" translate="yes" xml:space="preserve">
          <source>This method allows you to push a payload containing top-level collections of records organized per type.</source>
          <target state="translated">이 방법을 사용하면 유형별로 구성된 최상위 레코드 모음이 포함 된 페이로드를 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9e9c872a5cfd75bae202c4ea4839d24085215a" translate="yes" xml:space="preserve">
          <source>This method also takes a hash of boot-time configuration options for customizing the instance's behavior. See the documentation on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">이 방법은 또한 인스턴스 동작을 사용자 정의하기 위해 부팅시 구성 옵션의 해시를 사용합니다. 자세한 내용은 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3f7722b1918a033bfc704ab024b6e1cf5c8659" translate="yes" xml:space="preserve">
          <source>This method can be overridden to set up and render additional or alternative templates.</source>
          <target state="translated">추가 또는 대체 템플릿을 설정하고 렌더링하기 위해이 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75131c915bde03ba240c1d475bfd5896ca45f619" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records.</source>
          <target state="translated">이 방법을 사용하면 새로운 레코드를 푸시하고 기존 레코드를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6b399d017a3f3f52b041707517412999041988" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records. You can push in more than one type of object at once. All objects should be in the format expected by the serializer.</source>
          <target state="translated">이 방법을 사용하면 새로운 레코드를 푸시하고 기존 레코드를 업데이트 할 수 있습니다. 한 번에 여러 유형의 객체를 밀어 넣을 수 있습니다. 모든 객체는 시리얼 라이저가 예상하는 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b02dc4cad6cf02610e6058c95d7caebe5eb539eb" translate="yes" xml:space="preserve">
          <source>This method can be used when it is certain that the server will return a single object for the primary data.</source>
          <target state="translated">이 메소드는 서버가 기본 데이터에 대한 단일 오브젝트를 리턴 할 것으로 확신 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a10777d9035c12a3fcba90767411843e07f906" translate="yes" xml:space="preserve">
          <source>This method delegates a query to the adapter. This is the one place where adapter-level semantics are exposed to the application.</source>
          <target state="translated">이 메소드는 조회를 어댑터에 위임합니다. 이것은 어댑터 레벨 시맨틱이 애플리케이션에 노출되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="7ae3f2f0c751efc8927d65bfd222cb31c552601f" translate="yes" xml:space="preserve">
          <source>This method delegates to a more specific normalize method based on the &lt;code&gt;requestType&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;requestType&lt;/code&gt; 에 따라보다 구체적인 normalize 메소드를 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="a25d67dc575ed0fba225af931e94045db1b5a8f9" translate="yes" xml:space="preserve">
          <source>This method expects normalized &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document. This means you have to follow &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API specification&lt;/a&gt; with few minor adjustments:</source>
          <target state="translated">이 방법에는 정규화 된 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; 문서가 필요합니다. 즉, 약간만 조정 하면 &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API 사양&lt;/a&gt; 을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="7df7b83c336ab5cbac360f1c5c272ebe13752bdd" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record array.</source>
          <target state="translated">이 방법이 &lt;em&gt;단지&lt;/em&gt; 매장 캐시 기록 배열을 반환 할 때 매장 조사했다.</target>
        </trans-unit>
        <trans-unit id="e8062e08f7c0f7fcdf86622114e1823949507341" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record.</source>
          <target state="translated">이 방법이 &lt;em&gt;유일한&lt;/em&gt; 저장소가 캐시 기록을 반환 할 때 상점에 의해 확인.</target>
        </trans-unit>
        <trans-unit id="3509ace1db000a92db88fe8a1836ad0b7713cbb8" translate="yes" xml:space="preserve">
          <source>This method is called via the container's resolver method. It parses the provided &lt;code&gt;fullName&lt;/code&gt; and then looks up and returns the appropriate template or class.</source>
          <target state="translated">이 메소드는 컨테이너의 리졸버 메소드를 통해 호출됩니다. 제공된 &lt;code&gt;fullName&lt;/code&gt; 을 구문 분석 한 후 적절한 템플리트 또는 클래스를 찾아 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ce28964f15279cf3d730ef68345532b784ce703" translate="yes" xml:space="preserve">
          <source>This method is called when &lt;code&gt;transitionTo&lt;/code&gt; is called with a context in order to populate the URL.</source>
          <target state="translated">이 메소드는 URL을 채우기 위해 컨텍스트로 &lt;code&gt;transitionTo&lt;/code&gt; 를 호출 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0c4ee83b8e7fbb139652d78dd5741771d80faf6" translate="yes" xml:space="preserve">
          <source>This method is called when you call &lt;code&gt;query&lt;/code&gt; on the store.</source>
          <target state="translated">이 메소드는 상점에서 &lt;code&gt;query&lt;/code&gt; 를 호출 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="13a7fe79d0533fe9608f31da98b7023d71e69453" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">이 메소드는 현재 라우트 및 &lt;code&gt;model&lt;/code&gt; 후크에서 제공 한 모델에 대한 컨트롤러와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbedcce78155921a2bf55755fabf12698cc38674" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook. By default, it renders the route's template, configured with the controller for the route.</source>
          <target state="translated">이 메소드는 현재 라우트 및 &lt;code&gt;model&lt;/code&gt; 후크에서 제공 한 모델에 대한 컨트롤러와 함께 호출됩니다 . 기본적으로 경로에 대한 컨트롤러로 구성된 경로 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c6d0b6398b87777d58312eba81fe646f7810a695" translate="yes" xml:space="preserve">
          <source>This method is generally very similar to calling &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; or &lt;code&gt;object.key = value&lt;/code&gt;, except that it provides support for computed properties, the &lt;code&gt;setUnknownProperty()&lt;/code&gt; method and property observers.</source>
          <target state="translated">이 메소드는 일반적으로 계산 된 특성, &lt;code&gt;setUnknownProperty()&lt;/code&gt; 메소드 및 특성 관찰자를 지원한다는 점을 제외하고는 &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; 또는 &lt;code&gt;object.key = value&lt;/code&gt; 호출과 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="74bd84dac410bdb6c99add62a62d5417953e7c5c" translate="yes" xml:space="preserve">
          <source>This method is handy for performing intermediate transitions on the way to a final destination route, and is called internally by the default implementations of the &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;loading&lt;/code&gt; handlers.</source>
          <target state="translated">이 방법은 최종 목적지 경로로가는 도중에 중간 전환을 수행하는 데 편리하며 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;loading&lt;/code&gt; 핸들러 의 기본 구현에 의해 내부적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa05443efe853cc3f28766f6d6fb9fe7a13a6090" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record after the &lt;code&gt;store.findRecord&lt;/code&gt; method resolves a cached record.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findRecord&lt;/code&gt; 메소드가 캐시 된 레코드를 분석 한 후 상점이 레코드를 다시로드해야하는지 여부를 판별하기 위해 상점에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ba3f4183468eab98d1908948e41cd0eef07925e8" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record array after the &lt;code&gt;store.findAll&lt;/code&gt; method resolves with a cached record array.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findAll&lt;/code&gt; 메소드가 캐시 된 레코드 배열로 분석 된 후 저장소가 레코드 배열을 다시로드해야하는지 여부를 판별하기 위해 저장소에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0dc1d4e602a3dbc746be228073f7c5e9072291ae" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record from the adapter when a record is requested by &lt;code&gt;store.findRecord&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store.findRecord&lt;/code&gt; 가 레코드를 요청할 때 저장소가 어댑터에서 레코드를 다시로드해야하는지 여부를 판별하기 위해 저장소에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8ce64195ca8b7e509dff95556cc7ab216203e10e" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload all records from the adapter when records are requested by &lt;code&gt;store.findAll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;store.findAll&lt;/code&gt; 에서 레코드를 요청할 때 저장소에서 어댑터에서 모든 레코드를 다시로드해야하는지 여부를 판별하기 위해 저장소에서이 메소드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="726a13d031eb08fa1d97022da145454908c66cf3" translate="yes" xml:space="preserve">
          <source>This method is used to convert each JSON root key in the payload into a modelName that it can use to look up the appropriate model for that part of the payload.</source>
          <target state="translated">이 메소드는 페이로드의 각 JSON 루트 키를 페이로드의 해당 부분에 적합한 모델을 찾는 데 사용할 수있는 modelName으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5bbd7f853651246ca39c9ea5a7bd46d3c9d051" translate="yes" xml:space="preserve">
          <source>This method is usually similar to using &lt;code&gt;object[keyName]&lt;/code&gt; or &lt;code&gt;object.keyName&lt;/code&gt;, however it supports both computed properties and the unknownProperty handler.</source>
          <target state="translated">이 메소드는 일반적으로 &lt;code&gt;object[keyName]&lt;/code&gt; 또는 &lt;code&gt;object.keyName&lt;/code&gt; 사용과 유사 하지만 계산 된 특성과 unknownProperty 핸들러를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b114921bcf8d16e2e444b824deee9fc587f6fb2a" translate="yes" xml:space="preserve">
          <source>This method makes a request for one record, where the &lt;code&gt;id&lt;/code&gt; is not known beforehand (if the &lt;code&gt;id&lt;/code&gt; is known, use &lt;a href=&quot;#method_findRecord&quot;&gt;&lt;code&gt;findRecord&lt;/code&gt;&lt;/a&gt; instead).</source>
          <target state="translated">이 메소드는 &lt;code&gt;id&lt;/code&gt; 를 미리 알 수없는 하나의 레코드를 요청 합니다 ( &lt;code&gt;id&lt;/code&gt; 가 알려진 경우 &lt;a href=&quot;#method_findRecord&quot;&gt; &lt;code&gt;findRecord&lt;/code&gt; 를&lt;/a&gt; 대신 사용 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="fe413c14bf4da8f3d5f53d8ded6cddab3dfd4a8c" translate="yes" xml:space="preserve">
          <source>This method normalizes a modelName into the format Ember Data uses internally.</source>
          <target state="translated">이 메소드는 modelName을 Ember Data가 내부적으로 사용하는 형식으로 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="08631e46477a7a941a13e8472a1d4934d0dfbb83" translate="yes" xml:space="preserve">
          <source>This method performs an HTTP &lt;code&gt;GET&lt;/code&gt; request with the id provided as part of the query string.</source>
          <target state="translated">이 메소드 는 쿼리 문자열의 일부로 제공된 ID 로 HTTP &lt;code&gt;GET&lt;/code&gt; 요청을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="7856b76816169cfe893ef391554413f9b77a695b" translate="yes" xml:space="preserve">
          <source>This method provides a way to read an element's attribute and also update the last value Ember knows about at the same time. This makes setting an attribute idempotent.</source>
          <target state="translated">이 방법은 요소의 속성을 읽고 동시에 Ember가 알고있는 마지막 값을 업데이트하는 방법을 제공합니다. 이것은 속성을 dem 등원으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1be81e576abbc9f8bf07bfebbb5d7035d8f905c9" translate="yes" xml:space="preserve">
          <source>This method receives the &lt;code&gt;store&lt;/code&gt;, the Model class for the request, the payload, the id of the record request (or &lt;code&gt;null&lt;/code&gt; if there is no id associated with the request), and the request type (a string with the possible values of: &lt;code&gt;'findRecord'&lt;/code&gt;, &lt;code&gt;'queryRecord'&lt;/code&gt;, &lt;code&gt;'findAll'&lt;/code&gt;, &lt;code&gt;'findBelongsTo'&lt;/code&gt;, &lt;code&gt;'findHasMany'&lt;/code&gt;, &lt;code&gt;'findMany'&lt;/code&gt;, &lt;code&gt;'query'&lt;/code&gt;, &lt;code&gt;'createRecord'&lt;/code&gt;, &lt;code&gt;'deleteRecord'&lt;/code&gt;, and &lt;code&gt;'updateRecord'&lt;/code&gt;) as arguments.</source>
          <target state="translated">이 메소드는 &lt;code&gt;store&lt;/code&gt; , 요청의 Model 클래스, 페이로드, 레코드 요청의 ID (또는 요청 과 연관된 ID가없는 경우 &lt;code&gt;null&lt;/code&gt; ) 및 요청 유형 (가능한 값이 &lt;code&gt;'findRecord'&lt;/code&gt; 문자열 ' 을 수신합니다. ' findRecord ' , &lt;code&gt;'queryRecord'&lt;/code&gt; , &lt;code&gt;'findAll'&lt;/code&gt; , &lt;code&gt;'findBelongsTo'&lt;/code&gt; , &lt;code&gt;'findHasMany'&lt;/code&gt; , &lt;code&gt;'findMany'&lt;/code&gt; , &lt;code&gt;'query'&lt;/code&gt; , &lt;code&gt;'createRecord'&lt;/code&gt; , &lt;code&gt;'deleteRecord'&lt;/code&gt; 및 &lt;code&gt;'updateRecord'&lt;/code&gt; )를 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83cfea1ccac994b0f515944e96fac8ec32c2f20c" translate="yes" xml:space="preserve">
          <source>This method returns a filtered array that contains all of the known records for a given type in the store.</source>
          <target state="translated">이 메소드는 상점에서 주어진 유형에 대해 알려진 모든 레코드를 포함하는 필터링 된 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a6a5fc1791645c2940034d3812b1b516a3835b0" translate="yes" xml:space="preserve">
          <source>This method returns a manager which can be used for introspection of the factory's class or for the creation of factory instances with initial properties. The manager is an object with the following properties:</source>
          <target state="translated">이 메소드는 팩토리 클래스의 내부 검사 또는 초기 특성이있는 팩토리 인스턴스 작성에 사용할 수있는 관리자를 리턴합니다. 관리자는 다음과 같은 속성을 가진 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b23b68987e06baaee9d2d14013a12d56a2d0b3b3" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which is resolved with an &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt;&lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;&lt;/a&gt; once the server returns.</source>
          <target state="translated">이 메소드는 서버를 리턴 하면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt; &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; &lt;/a&gt; 로 해결되는 promise를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eed4c7cdb29f6c03f0723f0629feb07c3656376e" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which resolves with the found record.</source>
          <target state="translated">이 메소드는 검색된 약속으로 해결되는 약속을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a9ee61f9f9c7e39cc14b2113ef18411dc61a4eca" translate="yes" xml:space="preserve">
          <source>This method returns a record for a given type and id combination.</source>
          <target state="translated">이 메소드는 주어진 유형 및 ID 조합에 대한 레코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5addfbbe95b2a58af44bf1bdcf2499db95fe3c02" translate="yes" xml:space="preserve">
          <source>This method returns true if a record for a given modelName and id is already loaded in the store. Use this function to know beforehand if a findRecord() will result in a request or that it will be a cache hit.</source>
          <target state="translated">주어진 modelName 및 id에 대한 레코드가 이미 저장소에로드 된 경우이 메소드는 true를 리턴합니다. findRecord ()로 인해 요청이 발생하는지 또는 캐시 적중인지 미리 알려면이 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="29ad6b6ad91ee119d75a9bab0ee8ae0631edf987" translate="yes" xml:space="preserve">
          <source>This method should be returned by async helpers such as &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;wait&lt;/code&gt; 와 같은 비동기 헬퍼가 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df6dcf687152ce38d873a2ff72a1326ba3f69cb3" translate="yes" xml:space="preserve">
          <source>This method should be used when an event may be called multiple times but the action should only be called once when the event is done firing. A common example is for scroll events where you only want updates to happen once scrolling has ceased.</source>
          <target state="translated">이 메소드는 이벤트가 여러 번 호출 될 수있을 때 사용해야하지만 이벤트가 실행 된 경우 조치는 한 번만 호출되어야합니다. 일반적인 예는 스크롤이 중지 된 후에 만 ​​업데이트를 수행하려는 스크롤 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="1b7af68bf1d14a0a7494d03c440d73e28a4b7190" translate="yes" xml:space="preserve">
          <source>This method unloads all records in the store. It schedules unloading to happen during the next run loop.</source>
          <target state="translated">이 메소드는 상점에서 모든 레코드를 언로드합니다. 다음 실행 루프 중에 언로드가 발생하도록 스케줄합니다.</target>
        </trans-unit>
        <trans-unit id="f68e595b779d29ca69cd56edd16cad0978ac86aa" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/people/1/group&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 부모 레코드 및 &lt;code&gt;/people/1/group&lt;/code&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="90e07dd7b94be524253c05e8e1714813e05bd28a" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/posts/1/comments&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 부모 레코드 및 &lt;code&gt;/posts/1/comments&lt;/code&gt; 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="105f0e895ac617988c6c362e0f459352f9da2718" translate="yes" xml:space="preserve">
          <source>This method will only be called if content is non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 content가 &lt;code&gt;null&lt;/code&gt; 이외의 경우에만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="657150ab50b85204bae3030b7eec6fc817ac1dfb" translate="yes" xml:space="preserve">
          <source>This method will synchronously return the record if it is available in the store, otherwise it will return &lt;code&gt;null&lt;/code&gt;. A record is available if it has been fetched earlier, or pushed manually into the store.</source>
          <target state="translated">이 메소드는 레코드가 상점에서 사용 가능한 경우 동 기적으로 레코드를 리턴하고, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다. 레코드를 이전에 가져 오거나 상점으로 수동으로 푸시 한 경우 레코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d308bedb05bb7d9b40bb5a78f093cc80094bac4" translate="yes" xml:space="preserve">
          <source>This method works much like the more generic &lt;code&gt;find()&lt;/code&gt; method.</source>
          <target state="translated">이 메소드는보다 일반적인 &lt;code&gt;find()&lt;/code&gt; 메소드 와 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="28c70fd4104148a561dcde3c0978e4acb10eaa64" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findAll('ticket')&lt;/code&gt; you will always get a list of tickets that are no more than 20 minutes old. In case a cached version is more than 20 minutes old, &lt;code&gt;findAll&lt;/code&gt; will not resolve until you fetched the latest versions.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;store.findAll('ticket')&lt;/code&gt; 을 수행 할 때마다 20 분 이하의 티켓 목록을 항상 얻을 수 있습니다. 캐시 된 버전이 20 분 이상 지난 경우 &lt;code&gt;findAll&lt;/code&gt; 은 최신 버전을 가져올 때까지 해결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2678263a74a0b565310ba1599428e1ae18b8c295" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findRecord('ticket',
id)&lt;/code&gt; you will always get a ticket that is no more than 20 minutes old. In case the cached version is more than 20 minutes old, &lt;code&gt;findRecord&lt;/code&gt; will not resolve until you fetched the latest version.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;store.findRecord('ticket', id)&lt;/code&gt; 를 수행 할 때마다 항상 20 분 이하의 티켓을 얻을 수 있습니다. 캐시 된 버전이 20 분 이상 지난 경우 &lt;code&gt;findRecord&lt;/code&gt; 는 최신 버전을 가져올 때까지 해결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec834c3e944edee230a4909331939d62bcbb6301" translate="yes" xml:space="preserve">
          <source>This mixin allows for Ember objects to subscribe to and emit events.</source>
          <target state="translated">이 믹스 인을 사용하면 Ember 객체가 이벤트를 구독하고 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf4568e2d4c8f66ef058891e43df4c9d7beb31a" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying array-like objects. These methods can be applied only to a collection that keeps its items in an ordered set. It builds upon the Array mixin and adds methods to modify the array. One concrete implementations of this class include ArrayProxy.</source>
          <target state="translated">이 믹스 인은 배열과 유사한 객체를 수정하기위한 API를 정의합니다. 이러한 메소드는 항목을 순서가 지정된 세트로 유지하는 콜렉션에만 적용 할 수 있습니다. Array 믹스 인을 기반으로하고 배열을 수정하는 메소드를 추가합니다. 이 클래스의 구체적인 구현에는 ArrayProxy가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9ab29a7ae181e083871bfe59c6eb5fa8dee6de" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying generic enumerables. These methods can be applied to an object regardless of whether it is ordered or unordered.</source>
          <target state="translated">이 믹스 인은 일반 열거 형을 수정하기위한 API를 정의합니다. 이러한 방법은 순서에 관계없이 객체에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505b5abe483be3c71930f0a0c5dfa5e8fc1384e" translate="yes" xml:space="preserve">
          <source>This mixin defines the common interface implemented by enumerable objects in Ember. Most of these methods follow the standard Array iteration API defined up to JavaScript 1.8 (excluding language-specific features that cannot be emulated in older versions of JavaScript).</source>
          <target state="translated">이 믹스 인은 Ember에서 열거 가능한 객체로 구현 된 공통 인터페이스를 정의합니다. 이러한 메소드의 대부분은 JavaScript 1.8까지 정의 된 표준 Array iteration API를 따릅니다 (이전 버전의 JavaScript에서는 에뮬레이션 할 수없는 언어 별 기능 제외).</target>
        </trans-unit>
        <trans-unit id="a9d0130ce13b8d50b5ddf38e1dae3ada3564de2d" translate="yes" xml:space="preserve">
          <source>This mixin implements Observer-friendly Array-like behavior. It is not a concrete implementation, but it can be used up by other classes that want to appear like arrays.</source>
          <target state="translated">이 믹스 인은 관찰자 친화적 인 배열과 유사한 동작을 구현합니다. 구체적인 구현은 아니지만 배열처럼 보이고 싶은 다른 클래스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d8916c9cfd84a7db880c63d8afc0d632f773b4d" translate="yes" xml:space="preserve">
          <source>This mixin is applied automatically to the Array class on page load, so you can use any of these methods on simple arrays. If Array already implements one of these methods, the mixin will not override them.</source>
          <target state="translated">이 믹스 인은 페이지로드시 Array 클래스에 자동으로 적용되므로 간단한 배열에서 이러한 메소드를 사용할 수 있습니다. Array가 이러한 메소드 중 하나를 이미 구현 한 경우 mixin은 해당 메소드를 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="763268c55e99fe8d5e6cfe80a692c9e9a1ec4278" translate="yes" xml:space="preserve">
          <source>This mixin provides properties and property observing functionality, core features of the Ember object model.</source>
          <target state="translated">이 믹스 인은 Ember 객체 모델의 핵심 기능인 속성 및 속성 관찰 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="16c6c4f7af60f66230f7ffba2118c188148ccc3d" translate="yes" xml:space="preserve">
          <source>This namespace contains all Ember methods and functions. Future versions of Ember may overwrite this namespace and therefore, you should avoid adding any new properties.</source>
          <target state="translated">이 네임 스페이스에는 모든 Ember 메서드 및 함수가 포함됩니다. 이후 버전의 Ember는이 네임 스페이스를 덮어 쓸 수 있으므로 새 속성을 추가하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0f1fb8cd697c512e05d5434c4202f674808490" translate="yes" xml:space="preserve">
          <source>This one command will create a new directory called &lt;code&gt;ember-quickstart&lt;/code&gt; and set up a new Ember application inside of it. Out of the box, your application will include:</source>
          <target state="translated">이 명령은 &lt;code&gt;ember-quickstart&lt;/code&gt; 라는 새 디렉토리를 만들고 그 안에 새 Ember 응용 프로그램을 설정합니다. 즉시 사용 가능한 응용 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d1ae48e7202427b88a954866fa91e5d3ebf6ba4" translate="yes" xml:space="preserve">
          <source>This only works on primitive data types, e.g. Strings, Numbers, etc.</source>
          <target state="translated">이것은 문자열, 숫자 등과 같은 기본 데이터 유형에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="308984791a98ba4402203e44b8c501a854c6be67" translate="yes" xml:space="preserve">
          <source>This option logs all the lookups that are done to the console. Custom objects you've created yourself have a tick, and Ember generated ones don't.</source>
          <target state="translated">이 옵션은 콘솔에 대한 모든 조회를 기록합니다. 직접 만든 커스텀 객체에는 진드기가 있고 Ember는 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="864837a696f2c980e81e10f2eb17aa9ee09a9e87" translate="yes" xml:space="preserve">
          <source>This pause-on-promise behavior is extremely valuable for when you need to guarantee that a route's data has fully loaded before displaying a new template.</source>
          <target state="translated">이 약속시 일시 중지 동작은 새 템플릿을 표시하기 전에 경로 데이터가 완전히로드되었는지 확인해야 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="68b70d5b5dbc2ccc714f22b801fc4c2b2e2527d0" translate="yes" xml:space="preserve">
          <source>This prevents the reverse flow, and also throws an exception when it occurs.</source>
          <target state="translated">이렇게하면 역류가 방지되고 예외가 발생할 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f188f197791f50828cb93afbcf35a833dccb3e89" translate="yes" xml:space="preserve">
          <source>This property can be specified as either an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">이 속성은 요소 또는 &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery 호환 선택기 문자열&lt;/a&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="259eb851af0e49aa172ab983617f64d1b8524d4e" translate="yes" xml:space="preserve">
          <source>This property contains the testing helpers for the current application. These are created once you call &lt;code&gt;injectTestHelpers&lt;/code&gt; on your &lt;code&gt;Ember.Application&lt;/code&gt; instance. The included helpers are also available on the &lt;code&gt;window&lt;/code&gt; object by default, but can be used from this object on the individual application also.</source>
          <target state="translated">이 속성에는 현재 응용 프로그램의 테스트 도우미가 포함됩니다. &lt;code&gt;Ember.Application&lt;/code&gt; 인스턴스 에서 &lt;code&gt;injectTestHelpers&lt;/code&gt; 를 호출하면 생성 됩니다. 포함 된 도우미는 기본적으로 &lt;code&gt;window&lt;/code&gt; 개체 에서도 사용할 수 있지만 개별 응용 프로그램의이 개체에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="880b36e1d1b71d83f727290b52d71974b054fd06" translate="yes" xml:space="preserve">
          <source>This property holds the &lt;code&gt;DS.AdapterError&lt;/code&gt; object with which last adapter operation was rejected.</source>
          <target state="translated">이 특성은 마지막 어댑터 조작이 거부 된 &lt;code&gt;DS.AdapterError&lt;/code&gt; 오브젝트를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="c2672723b4000e8dc3a4be8a1dec2e30fc2e556d" translate="yes" xml:space="preserve">
          <source>This property indicates whether or not this application is currently in testing mode. This is set when &lt;code&gt;setupForTesting&lt;/code&gt; is called on the current application.</source>
          <target state="translated">이 특성은이 애플리케이션이 현재 테스트 모드인지 여부를 나타냅니다. 현재 애플리케이션에서 &lt;code&gt;setupForTesting&lt;/code&gt; 이 호출 될 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d61da15319a8f6d477ea54281d1f750de320a8d" translate="yes" xml:space="preserve">
          <source>This property must be specified upon creation, and should not be changed once created.</source>
          <target state="translated">이 특성은 작성시 지정해야하며 일단 작성되면 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb254d7e44a7f93fba2ee853638d58a655e0c55" translate="yes" xml:space="preserve">
          <source>This property overrides the default property defined in &lt;code&gt;Ember.Enumerable&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 에 정의 된 기본 속성보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="9773d501349ee6511de2ee684d6598a19311be0d" translate="yes" xml:space="preserve">
          <source>This property would contain the following:</source>
          <target state="translated">이 속성에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d20b59f6a96b6617ee0085cdddc214c8c3d28af2" translate="yes" xml:space="preserve">
          <source>This removes all helpers that have been registered, and resets and functions that were overridden by the helpers.</source>
          <target state="translated">이렇게하면 등록 된 모든 도우미가 제거되고 도우미가 재정의 한 재설정 및 기능이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b7c25a3f2e20075045c10f4cbaf58f922adbe5" translate="yes" xml:space="preserve">
          <source>This results in the creation of a model file and a test file:</source>
          <target state="translated">결과적으로 모델 파일과 테스트 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3d2448d5cbbd2264adc36cdc0345ffb2188196cb" translate="yes" xml:space="preserve">
          <source>This returns a string that represents how the reference will be looked up when it is loaded. If the relationship has a link it will use the &quot;link&quot; otherwise it defaults to &quot;id&quot;.</source>
          <target state="translated">참조가로드 될 때 참조를 찾는 방법을 나타내는 문자열을 반환합니다. 관계에 링크가있는 경우 &quot;link&quot;를 사용하고 그렇지 않으면 기본값은 &quot;id&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f4a77f92e2016358406f536036ee528d0389ad89" translate="yes" xml:space="preserve">
          <source>This returns a thenable tailored for testing. It catches failed &lt;code&gt;onSuccess&lt;/code&gt; callbacks and invokes the &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; callback in the last chained then.</source>
          <target state="translated">그러면 테스트에 맞게 조정 가능한 결과가 반환됩니다. 실패한 &lt;code&gt;onSuccess&lt;/code&gt; 콜백을 포착 하고 마지막 체인에서 &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; 콜백을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="50faf92dba9f3a4835092fca1ed3e0228234be67" translate="yes" xml:space="preserve">
          <source>This returns the objects at the specified indexes, using &lt;code&gt;objectAt&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;objectAt&lt;/code&gt; 를 사용하여 지정된 인덱스의 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f1e3aaaf80637b6eaa622e8df1944a99aa521731" translate="yes" xml:space="preserve">
          <source>This route is part of every application, so you don't need to specify it in your &lt;code&gt;app/router.js&lt;/code&gt;.</source>
          <target state="translated">이 경로는 모든 애플리케이션의 일부이므로 &lt;code&gt;app/router.js&lt;/code&gt; 에서 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="03d7bba0ebc44c5b5992d770552d3d3655e4353b" translate="yes" xml:space="preserve">
          <source>This router creates a route for &lt;code&gt;/posts&lt;/code&gt; and for &lt;code&gt;/posts/new&lt;/code&gt;. When a user visits &lt;code&gt;/posts&lt;/code&gt;, they'll simply see the &lt;code&gt;posts.hbs&lt;/code&gt; template. (Below, &lt;a href=&quot;#toc_index-routes&quot;&gt;index routes&lt;/a&gt; explains an important addition to this.) When the user visits &lt;code&gt;posts/new&lt;/code&gt;, they'll see the &lt;code&gt;posts/new.hbs&lt;/code&gt; template rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; of the &lt;code&gt;posts&lt;/code&gt; template.</source>
          <target state="translated">이 라우터는 &lt;code&gt;/posts&lt;/code&gt; 및 &lt;code&gt;/posts/new&lt;/code&gt; 에 대한 경로를 만듭니다 . 사용자가 &lt;code&gt;/posts&lt;/code&gt; 를 방문 하면 &lt;code&gt;posts.hbs&lt;/code&gt; 템플릿을 보게 됩니다. (아래, &lt;a href=&quot;#toc_index-routes&quot;&gt;인덱스 노선&lt;/a&gt; 이에 중요한 추가에 대해 설명합니다.) 사용자가 방문의 경우에는 &lt;code&gt;posts/new&lt;/code&gt; , 그들이 볼 수 &lt;code&gt;posts/new.hbs&lt;/code&gt; 에 렌더링 템플릿 &lt;code&gt;{{outlet}}&lt;/code&gt; 의 &lt;code&gt;posts&lt;/code&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="2682ff7e745a9f583a877a94603b3a194f20069b" translate="yes" xml:space="preserve">
          <source>This section covers some more advanced features of the router and its capability for handling complex async logic within your app.</source>
          <target state="translated">이 섹션에서는 라우터의 고급 기능과 앱 내에서 복잡한 비동기 로직을 ​​처리하는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7d03de60bffa51d324cefb82c172247484bdd27e" translate="yes" xml:space="preserve">
          <source>This separation of concerns not only clarifies the architecture of your app, it can also improve its efficiency. This is particularly true when your app needs to be booted repeatedly during testing and / or server-rendering (e.g. via &lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt;). The configuration of a single &lt;code&gt;Application&lt;/code&gt; can be done once and shared among multiple stateful &lt;code&gt;ApplicationInstance&lt;/code&gt; instances. These instances can be discarded once they're no longer needed (e.g. when a test has run or FastBoot request has finished).</source>
          <target state="translated">이러한 관심의 분리는 앱의 아키텍처를 명확하게 할뿐만 아니라 효율성을 향상시킬 수 있습니다. 테스트 및 / 또는 서버 렌더링 중에 (예 : &lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt; 를 통해 ) 앱을 반복적으로 부팅해야하는 경우 특히 그렇습니다 . 단일 &lt;code&gt;Application&lt;/code&gt; 의 구성은 한 번 수행하고 여러 상태 저장 &lt;code&gt;ApplicationInstance&lt;/code&gt; 인스턴스 간에 공유 할 수 있습니다 . 이러한 인스턴스는 더 이상 필요하지 않은 경우 (예 : 테스트가 실행되었거나 FastBoot 요청이 완료된 경우) 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789aeba7e703a9b9f8a1615849db9c70a791d7f5" translate="yes" xml:space="preserve">
          <source>This serializer expects this &lt;code&gt;errors&lt;/code&gt; object to be an Array similar to the following, compliant with the JSON-API specification:</source>
          <target state="translated">이 시리얼 라이저는이 &lt;code&gt;errors&lt;/code&gt; 객체가 JSON-API 사양을 준수하는 다음과 유사한 배열 일 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8c0ec823dbba7a7a2ed2b41b55cb5e08ee937a" translate="yes" xml:space="preserve">
          <source>This serializer normalizes a JSON API payload that looks like:</source>
          <target state="translated">이 시리얼 라이저는 다음과 같은 JSON API 페이로드를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="6ae149f60b66b9e03410e34d8b8dd68ba195fe2d" translate="yes" xml:space="preserve">
          <source>This serializer will generate JSON that looks like this:</source>
          <target state="translated">이 시리얼 라이저는 다음과 같은 JSON을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a037d496c03267daf854fbff115ff2ed3892a36d" translate="yes" xml:space="preserve">
          <source>This sets up a binding between the &lt;code&gt;category&lt;/code&gt; query param in the URL, and the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;. In other words, once the &lt;code&gt;articles&lt;/code&gt; route has been entered, any changes to the &lt;code&gt;category&lt;/code&gt; query param in the URL will update the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;, and vice versa. Note that you can't bind &lt;code&gt;queryParams&lt;/code&gt; to computed properties, they have to be values.</source>
          <target state="translated">URL 의 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수와 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 특성 사이에 바인딩이 설정됩니다 . 즉, &lt;code&gt;articles&lt;/code&gt; 경로가 입력되면 URL 의 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수를 변경하면 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 속성 이 업데이트 되고 그 반대의 경우도 마찬가지입니다. &lt;code&gt;queryParams&lt;/code&gt; 를 계산 된 특성에 바인드 할 수 없으며 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c4fca12a79c237845effaba4d5f11c49b9077507" translate="yes" xml:space="preserve">
          <source>This setup allows you to run the routing layer of your Ember app in a server environment using Node.js and completely disable rendering. This allows you to simulate and discover the resources (i.e. AJAX requests) needed to fulfill a given request and eagerly &quot;push&quot; these resources to the client.</source>
          <target state="translated">이 설정을 사용하면 Node.js를 사용하여 서버 환경에서 Ember 앱의 라우팅 계층을 실행하고 렌더링을 완전히 비활성화 할 수 있습니다. 이를 통해 주어진 요청을 이행하는 데 필요한 자원 (예 : AJAX 요청)을 시뮬레이션하고 발견하고 이러한 자원을 클라이언트에 &quot;푸시&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02dd78ab18220d6a23d424669cd9bfd4688435b6" translate="yes" xml:space="preserve">
          <source>This setup allows you to run your Ember app in a server environment using Node.js and render its content into static HTML for SEO purposes.</source>
          <target state="translated">이 설정을 사용하면 Node.js를 사용하여 서버 환경에서 Ember 앱을 실행하고 SEO 목적으로 해당 컨텐츠를 정적 HTML로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc8bfa537605301181bc268ec1121a0fff7f530" translate="yes" xml:space="preserve">
          <source>This shows the literal string &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; to the user, rather than the text in bold as you probably intended. We can tell Ember not to escape the return value (that is, that it is &lt;em&gt;safe&lt;/em&gt;) by using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt;&lt;code&gt;htmlSafe&lt;/code&gt;&lt;/a&gt; string utility:</source>
          <target state="translated">원하는대로 굵게 표시된 텍스트 대신 리터럴 문자열 &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; 가 사용자에게 표시됩니다. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt; &lt;code&gt;htmlSafe&lt;/code&gt; &lt;/a&gt; 문자열 유틸리티를 사용하여 Ember에게 반환 값 (즉, &lt;em&gt;안전함&lt;/em&gt; ) 을 이스케이프 처리하지 않도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14461f490d3629183001df3471224dbd1beb7332" translate="yes" xml:space="preserve">
          <source>This snippet says &quot;take the &lt;code&gt;userDidDeleteAccount&lt;/code&gt; action from the parent and make it available on the child component as the property &lt;code&gt;onConfirm&lt;/code&gt;.&quot; Note the use here of the &lt;code&gt;action&lt;/code&gt; helper, which serves to return the function named &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; that we are passing to the component.</source>
          <target state="translated">이 스 니펫은 &quot; 부모로부터 &lt;code&gt;userDidDeleteAccount&lt;/code&gt; 조치를 취하고 이를 하위 구성 요소에서 &lt;code&gt;onConfirm&lt;/code&gt; 특성으로 사용 가능하게하십시오 &quot;라고 말합니다 . 컴포넌트에 전달하는 &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; 라는 함수를 리턴 하는 &lt;code&gt;action&lt;/code&gt; 헬퍼 의 사용에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="10aa9c950fe3b173b7fe0ffb80e1c78f6a244f66" translate="yes" xml:space="preserve">
          <source>This synchronous behavior can also lead to observers being fired multiple times when observing multiple properties:</source>
          <target state="translated">이 동기 동작으로 인해 여러 속성을 관찰 할 때 관찰자가 여러 번 발사 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca7bb302863b1f3661818e192c30d8b7af3c091" translate="yes" xml:space="preserve">
          <source>This syntax offers the convenience to add a class if a property is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 구문은 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 클래스를 추가하는 편의성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="eee93099eea962e7715594aebb65f2ee2649df43" translate="yes" xml:space="preserve">
          <source>This template would display all properties on the &lt;code&gt;user&lt;/code&gt; object in a list:</source>
          <target state="translated">이 템플릿은 &lt;code&gt;user&lt;/code&gt; 객체의 모든 속성을 목록으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="afccb08d1ac5974f56f2db8b4c4a83dee7fac93b" translate="yes" xml:space="preserve">
          <source>This time when we setup our &lt;code&gt;moduleFor&lt;/code&gt; we need to pass an options object as our third argument that has the controller's &lt;code&gt;needs&lt;/code&gt;.</source>
          <target state="translated">이번에는 &lt;code&gt;moduleFor&lt;/code&gt; 을 설정할 때 옵션 객체를 컨트롤러의 &lt;code&gt;needs&lt;/code&gt; 가있는 세 번째 인수로 전달 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="320e20ec08a17dd14b114fefba162280a1a8e762" translate="yes" xml:space="preserve">
          <source>This way the &lt;code&gt;{{action}}&lt;/code&gt; will fire when clicking with the alt key pressed down.</source>
          <target state="translated">이렇게 하면 alt 키를 누른 상태에서 클릭 할 때 &lt;code&gt;{{action}}&lt;/code&gt; 이 (가) 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e963dddd92986a8f66f2f216766871bc0c689a3c" translate="yes" xml:space="preserve">
          <source>This way the action will fire when clicking with the alt key pressed down. Alternatively, supply &quot;any&quot; to the &lt;code&gt;allowedKeys&lt;/code&gt; option to accept any combination of modifier keys.</source>
          <target state="translated">이렇게하면 alt 키를 누른 상태에서 클릭 할 때 작업이 시작됩니다. 또는, 수정 자 키 조합을 허용 하려면 &lt;code&gt;allowedKeys&lt;/code&gt; 옵션에 &quot;any&quot;를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="bedb78f365050fbd4069b91241e79e0fffc66905" translate="yes" xml:space="preserve">
          <source>This will be set to the Application instance when it is created.</source>
          <target state="translated">응용 프로그램 인스턴스를 만들 때이 인스턴스가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d2a0761856747c7bdf1757594db900c323b0ab" translate="yes" xml:space="preserve">
          <source>This will bind checked state of this checkbox to the value of &lt;code&gt;isEmberized&lt;/code&gt; -- if either one changes, it will be reflected in the other.</source>
          <target state="translated">그러면이 확인란의 확인 된 상태가 &lt;code&gt;isEmberized&lt;/code&gt; 값에 바인딩 됩니다. 둘 중 하나가 변경되면 다른 쪽에도 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="25e3b1918ed474cee33c724ea48d9dc47b998531" translate="yes" xml:space="preserve">
          <source>This will call the &lt;code&gt;targetAction&lt;/code&gt; method on the &lt;code&gt;targetObject&lt;/code&gt; whenever the value of the &lt;code&gt;propertyKey&lt;/code&gt; changes.</source>
          <target state="translated">&lt;code&gt;propertyKey&lt;/code&gt; 값이 변경 될 때마다 &lt;code&gt;targetObject&lt;/code&gt; 에서 &lt;code&gt;targetAction&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1112ad430de08e3a9e5b258697086fe3531f93eb" translate="yes" xml:space="preserve">
          <source>This will cause changes to the &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;category&lt;/code&gt; property to update the &lt;code&gt;articles_category&lt;/code&gt; query param, and vice versa.</source>
          <target state="translated">이는 변경의 원인이됩니다 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 업데이트하는 특성 &lt;code&gt;articles_category&lt;/code&gt; 의 쿼리 PARAM를, 그리고 그 반대를 반대.</target>
        </trans-unit>
        <trans-unit id="01abb5b2dee8f3eadfbf27cf12dc694c82c9b0fa" translate="yes" xml:space="preserve">
          <source>This will combine the values of the enumerator into a single value. It is a useful way to collect a summary value from an enumeration. This corresponds to the &lt;code&gt;reduce()&lt;/code&gt; method defined in JavaScript 1.8.</source>
          <target state="translated">열거 자의 값을 단일 값으로 결합합니다. 열거 형에서 요약 값을 수집하는 유용한 방법입니다. 이것은 JavaScript 1.8에 정의 된 &lt;code&gt;reduce()&lt;/code&gt; 메소드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="4d8eee678a37c71d0c8bd12462d3862f9e24bd5a" translate="yes" xml:space="preserve">
          <source>This will create a new &lt;code&gt;comment&lt;/code&gt; record and save it to the server. Ember Data will also update the blogPost to include our newly created comment in its &lt;code&gt;comments&lt;/code&gt; relationship.</source>
          <target state="translated">새로운 &lt;code&gt;comment&lt;/code&gt; 레코드 가 생성 되어 서버에 저장됩니다. Ember Data는 새로 작성된 의견을 &lt;code&gt;comments&lt;/code&gt; 관계 에 포함하도록 blogPost를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="33c9e6435e1c4f883e5e4bdb72fe6185866b3577" translate="yes" xml:space="preserve">
          <source>This will create two files, our helper and its related test:</source>
          <target state="translated">그러면 도우미와 관련 테스트라는 두 개의 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="06a61beff59c9a238e101b8d830b62a3ba3f1d36" translate="yes" xml:space="preserve">
          <source>This will display the result of &lt;code&gt;this.get('foo.item1')&lt;/code&gt; when index is 1, and &lt;code&gt;this.get('foo.item2')&lt;/code&gt; when index is 2, etc.</source>
          <target state="translated">이 결과 표시 &lt;code&gt;this.get('foo.item1')&lt;/code&gt; 인덱스가 1 인 경우와 &lt;code&gt;this.get('foo.item2')&lt;/code&gt; 인덱스가 2 인 경우 등에</target>
        </trans-unit>
        <trans-unit id="a9259ca0bb82d89e48df977ef1e42ddeb57457e8" translate="yes" xml:space="preserve">
          <source>This will generate the following file:</source>
          <target state="translated">다음 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="906404e31e56fa309043de215463e96251e5794e" translate="yes" xml:space="preserve">
          <source>This will only work if the record has already finished loading.</source>
          <target state="translated">레코드로드가 이미 완료된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d8d929b9d0335a3ed5cf736b11bdf433272222ee" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/#/posts/new&lt;/code&gt;.</source>
          <target state="translated">그러면 posts.new URL &lt;code&gt;/#/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="29fb1351e61c41fb104416f7850a8b5069cdd3f6" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt; for modern browsers that support the &lt;code&gt;history&lt;/code&gt; api or &lt;code&gt;/#/posts/new&lt;/code&gt; for older ones, like Internet Explorer 9 and below.</source>
          <target state="translated">그러면 Internet Explorer 9 이하와 같이 이전 API를 위해 &lt;code&gt;history&lt;/code&gt; API 또는 &lt;code&gt;/#/posts/new&lt;/code&gt; 를 지원하는 최신 브라우저 의 경우 posts.new URL &lt;code&gt;/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ef38bf8c063d320ef5caf31e346a8a11963ad798" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt;.</source>
          <target state="translated">그러면 posts.new URL &lt;code&gt;/posts/new&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="a594b83e2729c4c06fe483d9931d88196c8ca620" translate="yes" xml:space="preserve">
          <source>This will tell the JSON API adapter that requests for &lt;code&gt;formula&lt;/code&gt; should go to &lt;code&gt;/formulae/1&lt;/code&gt; instead of &lt;code&gt;/formulas/1&lt;/code&gt;, and that requests for &lt;code&gt;advice&lt;/code&gt; should go to &lt;code&gt;/advice/1&lt;/code&gt; instead of &lt;code&gt;/advices/1&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 JSON API 어댑터에 &lt;code&gt;formula&lt;/code&gt; 요청 이 &lt;code&gt;/formulae/1&lt;/code&gt; 대신 &lt;code&gt;/formulas/1&lt;/code&gt; 로 이동하고 &lt;code&gt;advice&lt;/code&gt; 요청 은 &lt;code&gt;/advices/1&lt;/code&gt; 대신 &lt;code&gt;/advice/1&lt;/code&gt; 로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="388cb66fb1ec711f83c1701450ba620236ebbe6b" translate="yes" xml:space="preserve">
          <source>This will use the primitive &lt;code&gt;replace()&lt;/code&gt; method to insert an object at the specified index.</source>
          <target state="translated">프리미티브 &lt;code&gt;replace()&lt;/code&gt; 메소드를 사용하여 지정된 인덱스에 객체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="43bffd1dffcb32d458aa58f02d05febe38e1f4a7" translate="yes" xml:space="preserve">
          <source>This works great for the &lt;code&gt;list-of-drafts&lt;/code&gt; component. However, your app is likely made up of many different components. On another page you may want a component to display the number of drafts. You may be tempted to copy and paste your existing &lt;code&gt;willRender&lt;/code&gt; code into the new component.</source>
          <target state="translated">이것은 &lt;code&gt;list-of-drafts&lt;/code&gt; 구성 요소에 효과적 입니다. 그러나 앱은 여러 구성 요소로 구성되어있을 수 있습니다. 다른 페이지에서 구성 요소가 초안 수를 표시하도록 할 수 있습니다. 기존 &lt;code&gt;willRender&lt;/code&gt; 코드 를 복사 하여 새 구성 요소에 붙여 넣으려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14da4507e84203e01b9ae7da382b3a00aaae7fdc" translate="yes" xml:space="preserve">
          <source>This would render this HTML when no title is passed to the component:</source>
          <target state="translated">제목이 구성 요소에 전달되지 않으면이 HTML을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8336ed0cc011aca5ef8d79b9105deaab281f7bb6" translate="yes" xml:space="preserve">
          <source>This would render this HTML:</source>
          <target state="translated">이것은이 HTML을 렌더링합니다 :</target>
        </trans-unit>
        <trans-unit id="84006ec1fbe089f93f04790646a82cbef861bb3e" translate="yes" xml:space="preserve">
          <source>Thus when the div is clicked, the action on that context is called. Because the &lt;code&gt;actionFunction&lt;/code&gt; is just a function, closure actions can be passed between components and still execute in the correct context.</source>
          <target state="translated">따라서 div를 클릭하면 해당 컨텍스트에 대한 조치가 호출됩니다. &lt;code&gt;actionFunction&lt;/code&gt; 은 함수일 뿐이 므로 클로저 조치는 구성 요소간에 전달되어 올바른 컨텍스트에서 계속 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="777fb441ed8a221e3154f33948c533e6c0b3cd66" translate="yes" xml:space="preserve">
          <source>Thus, many of Ember's built-in helpers (as well as your custom helpers) can be used in nested form.</source>
          <target state="translated">따라서 많은 Ember의 내장 헬퍼 (및 사용자 정의 헬퍼)는 중첩 된 형태로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc09fd602f6d10a4673777c6b4fc42a255573839" translate="yes" xml:space="preserve">
          <source>Thus, the output of these combined helpers is &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">따라서 이러한 결합 된 헬퍼의 출력은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8708c4922aad6bc5f7d4fb439f5a35edf457ec9" translate="yes" xml:space="preserve">
          <source>Timer information for use in canceling, see `run.cancel`.</source>
          <target state="translated">취소에 사용되는 타이머 정보는`run.cancel`을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad8314f52b2f4c62535401de872ed1002612344d" translate="yes" xml:space="preserve">
          <source>Timer object to cancel</source>
          <target state="translated">취소 할 타이머 객체</target>
        </trans-unit>
        <trans-unit id="d393dc0e4b2a5c2cc44ef7e4ef9df6956f16e16f" translate="yes" xml:space="preserve">
          <source>To access a service, you can inject it in any container-resolved object such as a component or another service using the &lt;code&gt;Ember.inject.service&lt;/code&gt; function. There are two ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed, the service is loaded based on the name of the variable key. You can load the shopping cart service with no arguments like below.</source>
          <target state="translated">서비스에 액세스하기 위해 &lt;code&gt;Ember.inject.service&lt;/code&gt; 기능을 사용하여 컴포넌트 또는 다른 서비스와 같은 컨테이너 해결 오브젝트에 서비스를 삽입 할 수 있습니다 . 이 기능을 사용하는 방법은 두 가지가 있습니다. 인수없이 호출하거나 등록 된 서비스 이름을 전달할 수 있습니다. 인수가 전달되지 않으면 변수 키의 이름을 기반으로 서비스가로드됩니다. 다음과 같은 인수없이 장바구니 서비스를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4e497b4d36c647d22f988a7c0708a0614aef99" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;category&lt;/code&gt; query parameter that will filter out all the articles that haven't been categorized as popular we'd specify &lt;code&gt;'category'&lt;/code&gt; as one of &lt;code&gt;controller:article&lt;/code&gt;'s &lt;code&gt;queryParams&lt;/code&gt;:</source>
          <target state="translated">인기있는 카테고리로 분류되지 않은 모든 기사를 필터링 하는 &lt;code&gt;category&lt;/code&gt; 쿼리 매개 변수 를 추가하려면 &lt;code&gt;controller:article&lt;/code&gt; 's &lt;code&gt;queryParams&lt;/code&gt; 중 하나로 &lt;code&gt;'category'&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="64b4906525b4bd262e5a9d0ce454f20e5241165a" translate="yes" xml:space="preserve">
          <source>To add a new helper, create a file with the name of the helper you want (e.g. &lt;code&gt;format-currency.js&lt;/code&gt;) in your application's &lt;code&gt;helpers&lt;/code&gt; directory. You can also have Ember generate the file for you from the command line:</source>
          <target state="translated">새 도우미를 추가하려면 응용 프로그램의 &lt;code&gt;helpers&lt;/code&gt; 디렉토리에 원하는 도우미 이름 (예 : &lt;code&gt;format-currency.js&lt;/code&gt; ) 으로 파일을 만듭니다 . 명령 행에서 Ember가 파일을 생성하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf70d0371c2fbff368e75db67c4c62218610aa5" translate="yes" xml:space="preserve">
          <source>To add an object to an enumerable, use the &lt;code&gt;addObject()&lt;/code&gt; method. This method will only add the object to the enumerable if the object is not already present and is of a type supported by the enumerable.</source>
          <target state="translated">열거 가능 객체에 객체를 추가하려면 &lt;code&gt;addObject()&lt;/code&gt; 메서드를 사용하십시오 . 이 메서드는 객체가 존재하지 않고 열거 형에서 지원하는 유형 인 경우에만 열거 형에 객체를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="612437c7a9dd2aab848343a115ff82b4a3a49077" translate="yes" xml:space="preserve">
          <source>To add an observer for a property, call:</source>
          <target state="translated">속성에 대한 관찰자를 추가하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="64f77ec9361b31e70af01b3aeed99d505520fad8" translate="yes" xml:space="preserve">
          <source>To add functions and properties to instances of a constructor by extending the constructor's prototype see &lt;code&gt;reopen&lt;/code&gt;</source>
          <target state="translated">생성자의 프로토 타입을 확장하여 생성자의 인스턴스에 함수와 속성을 추가하려면 &lt;code&gt;reopen&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbc1d24b350815efa8e5ebb0581fbf2701efa8fd" translate="yes" xml:space="preserve">
          <source>To add functions and properties to the constructor itself, see &lt;code&gt;reopenClass&lt;/code&gt;</source>
          <target state="translated">생성자 자체에 함수와 속성을 추가하려면 &lt;code&gt;reopenClass&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e1f6f236f185a772efb6540307b2e949361e3c1" translate="yes" xml:space="preserve">
          <source>To add new events to be listened to:</source>
          <target state="translated">청취 할 새 이벤트를 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dd74399dd3c625fbe38e2a7a93a9e1356892dc03" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;willTransition&lt;/code&gt; event to continue bubbling to the parent route, use &lt;code&gt;return true;&lt;/code&gt;. When the &lt;code&gt;willTransition&lt;/code&gt; method has a return value of &lt;code&gt;true&lt;/code&gt; then the parent route's &lt;code&gt;willTransition&lt;/code&gt; method will be fired, enabling &quot;bubbling&quot; behavior for the event.</source>
          <target state="translated">&lt;code&gt;willTransition&lt;/code&gt; 이벤트가 상위 경로로 버블 링을 계속 하도록하려면 &lt;code&gt;return true;&lt;/code&gt; 사용하십시오 . . 때 &lt;code&gt;willTransition&lt;/code&gt; 의 방법의 반환 값이 &lt;code&gt;true&lt;/code&gt; 다음 상위 경로의 &lt;code&gt;willTransition&lt;/code&gt; 의 방법이 발사됩니다 가능을 이벤트에 대한 동작을 &quot;버블 링&quot;.</target>
        </trans-unit>
        <trans-unit id="f55c6421e541207d1e25237aa0749707b6d2ce1f" translate="yes" xml:space="preserve">
          <source>To allow the user to widen the image, we will need to add an action that toggles the value of &lt;code&gt;isWide&lt;/code&gt;. Let's call this action &lt;code&gt;toggleImageSize&lt;/code&gt;</source>
          <target state="translated">사용자가 이미지를 넓히려면 &lt;code&gt;isWide&lt;/code&gt; 값을 전환하는 작업을 추가해야합니다 . 이 동작을 &lt;code&gt;toggleImageSize&lt;/code&gt; 라고 하겠습니다</target>
        </trans-unit>
        <trans-unit id="3893ea84ac6eb7bbc9a0aae0f524ff440385112a" translate="yes" xml:space="preserve">
          <source>To annotate computed properties, use the &lt;code&gt;Ember.computed()&lt;/code&gt; method to wrap the function:</source>
          <target state="translated">계산 된 속성에 주석을 &lt;code&gt;Ember.computed()&lt;/code&gt; 메서드를 사용하여 함수를 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="8fe75361f7d4d895b287bf14c5b819b85797d1a1" translate="yes" xml:space="preserve">
          <source>To avoid this behavior, it is encouraged to initialize those arrays and object properties during &lt;code&gt;init()&lt;/code&gt;. Doing so ensures each instance will be unique.</source>
          <target state="translated">이 동작을 피하려면 &lt;code&gt;init()&lt;/code&gt; 동안 해당 배열과 객체 속성을 초기화하는 것이 좋습니다 . 그렇게하면 각 인스턴스가 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="7023afe6c467f1d9d8a77531b4eee7ffb2d113e8" translate="yes" xml:space="preserve">
          <source>To begin, let's generate our new component. We'll call this component &lt;code&gt;list-filter&lt;/code&gt;, since all we want our component to do is filter the list of rentals based on input.</source>
          <target state="translated">먼저 새 컴포넌트를 생성 해 봅시다. 이 컴포넌트를 &lt;code&gt;list-filter&lt;/code&gt; 라고 부릅니다. 컴포넌트 가 원하는 것은 입력을 기준으로 대여 목록을 필터링하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2041c7e5184639b6652b147ff7731d4861370040" translate="yes" xml:space="preserve">
          <source>To browse addons, visit the &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; website. It catalogs and categorizes Ember addons that have been published to NPM and assigns them a score based on a variety of criteria.</source>
          <target state="translated">애드온을 찾아 보려면 &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; 웹 사이트를 방문하십시오 . NPM에 게시 된 Ember 애드온을 카탈로그로 분류하고 다양한 기준에 따라 점수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5d2de65aa264859c42ccec965b16380ce611d54d" translate="yes" xml:space="preserve">
          <source>To change the format of the data that is sent to the backend store, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt;&lt;code&gt;serialize()&lt;/code&gt;&lt;/a&gt; hook. Let's say that we have this JSON API response from Ember Data:</source>
          <target state="translated">백엔드 저장소로 전송되는 데이터 형식을 변경하려면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt; &lt;code&gt;serialize()&lt;/code&gt; &lt;/a&gt; 후크를 사용할 수 있습니다 . Ember Data의 JSON API 응답이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8147260956e1d80c68ae4385b8dfaf8e846f2a9f" translate="yes" xml:space="preserve">
          <source>To check that rentals are listed with an automated test, we will create a test to visit the index route and check that the results show 3 listings.</source>
          <target state="translated">대여가 자동 테스트와 함께 나열되어 있는지 확인하기 위해 인덱스 경로를 방문하고 결과에 3 개의 목록이 표시되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="1f8255d58ff45b69a2cfcbdef10d629721ba8fc6" translate="yes" xml:space="preserve">
          <source>To clear the currently logged Promises, click on the clear icon on the top left of the tab.</source>
          <target state="translated">현재 기록 된 약속을 지우려면 탭 왼쪽 위에있는 지우기 아이콘을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="29f27b12694ecb81b431f0d90751a5300c28c856" translate="yes" xml:space="preserve">
          <source>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to &lt;a href=&quot;http://localhost:4200/tests&quot;&gt;&lt;code&gt;http://localhost:4200/tests&lt;/code&gt;&lt;/a&gt;. If your test suite isn't fully covering your app's functionality, you may also manually exercise functionality within your app where needed. Once you've exercised the app to your satisfaction, run the following command within your browser console: &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt;. This will print to the console JavaScript code, which you should then copy to a new file in your project called &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt;</source>
          <target state="translated">지원 중단을 수집하려면 먼저 개발 서버를 시작하고 &lt;a href=&quot;http://localhost:4200/tests&quot;&gt; &lt;code&gt;http://localhost:4200/tests&lt;/code&gt; 로&lt;/a&gt; 이동하여 브라우저 내 테스트 스위트를 실행하십시오 . 테스트 스위트가 앱의 기능을 완전히 다루지 않는 경우 필요한 경우 앱 내에서 수동으로 기능을 연습 할 수도 있습니다. 앱을 만족스럽게 연습 한 후 브라우저 콘솔 내에서 &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt; 명령을 실행하십시오 . 그러면 콘솔 JavaScript 코드로 인쇄 된 다음 프로젝트의 &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt; 라는 새 파일로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="3175b38418b12c2d580746cc8cc19dc3a953fab7" translate="yes" xml:space="preserve">
          <source>To create a class-based helper, rather than exporting a simple function, you should export a subclass of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper&lt;/code&gt;&lt;/a&gt;. Helper classes must contain a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt;&lt;code&gt;compute&lt;/code&gt;&lt;/a&gt; method that behaves the same as the function passed to &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt;&lt;code&gt;Ember.Helper.helper&lt;/code&gt;&lt;/a&gt;. In order to access a service, you must first inject it into the class-based helper. Once added, you can call the service's methods or access its properties from within the &lt;code&gt;compute()&lt;/code&gt; method.</source>
          <target state="translated">간단한 함수를 내 보내지 않고 클래스 기반 도우미를 만들려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper&lt;/code&gt; &lt;/a&gt; 하위 클래스를 내 보내야 합니다. 헬퍼 클래스는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt; &lt;code&gt;Ember.Helper.helper&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수와 동일하게 동작 하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt; &lt;code&gt;compute&lt;/code&gt; &lt;/a&gt; 메소드를 포함해야합니다 . 서비스에 액세스하려면 먼저 클래스 기반 도우미에 서비스를 주입해야합니다. 추가 한 후에는 서비스의 메소드를 호출하거나 &lt;code&gt;compute()&lt;/code&gt; 메소드 에서 해당 특성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="483b244a408fb90428d0b9a44c7fe6d9ad8692be" translate="yes" xml:space="preserve">
          <source>To create a custom error to signal a specific error state in communicating with an external API, extend the &lt;code&gt;DS.AdapterError&lt;/code&gt;. For example if the external API exclusively used HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; to indicate it was closed for maintenance:</source>
          <target state="translated">외부 API와 통신 할 때 특정 오류 상태를 알리는 사용자 정의 오류를 작성하려면 &lt;code&gt;DS.AdapterError&lt;/code&gt; 를 확장하십시오 . 예를 들어 외부 API가 HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; 독점적으로 사용 하여 유지 보수를 위해 닫 혔음 을 표시하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5f58871b9ab756fa7fbfd2a0634d267d3a4ce8ae" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt; that has a relationship with a &lt;code&gt;User&lt;/code&gt; record:</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 레코드 와 관계가있는 &lt;code&gt;Post&lt;/code&gt; 의 새 인스턴스를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e61e0cae04fd9ad56d0c4c5698e8faa32a1f269" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt;:</source>
          <target state="translated">(A)의 새 인스턴스를 만들려면 &lt;code&gt;Post&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7fa82787ae3f63115905a224cbbd4da31001a607" translate="yes" xml:space="preserve">
          <source>To create a new project using Ember CLI, use the &lt;code&gt;new&lt;/code&gt; command. In preparation for the tutorial in the next section, you can make an app called &lt;code&gt;super-rentals&lt;/code&gt;.</source>
          <target state="translated">Ember CLI를 사용하여 새 프로젝트를 만들려면 &lt;code&gt;new&lt;/code&gt; 명령을 사용하십시오 . 다음 섹션의 튜토리얼을 준비하면서 &lt;code&gt;super-rentals&lt;/code&gt; 라는 앱을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0507bf8200bc0fc65ea17fae004600ec931bee74" translate="yes" xml:space="preserve">
          <source>To create an acceptance test, run &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">승인 테스트를 작성하려면 &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6546ce366ebc2a0397c0ab3926caf7dfba659cf6" translate="yes" xml:space="preserve">
          <source>To create an index nested route, run the following command:</source>
          <target state="translated">인덱스 중첩 경로를 만들려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f16533be33b27f3dabd74f1c1a59b9369d04e94e" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes a specific response from the server, use one of the many specific &lt;code&gt;normalizeResponse&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 가 서버의 특정 응답을 정규화하는 방법을 사용자 정의하려면 많은 특정 &lt;code&gt;normalizeResponse&lt;/code&gt; 후크 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efffbb69cac955b484ca11b4daebd1d8a4b7475b" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes the whole server response, use the &lt;code&gt;normalizeResponse&lt;/code&gt; hook.</source>
          <target state="translated">&lt;code&gt;JSONSerializer&lt;/code&gt; 가 전체 서버 응답을 정규화하는 방법을 사용자 정의하려면 &lt;code&gt;normalizeResponse&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f903926c89b490fde43d23a09ec470fcb5dc60" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes your id, attributes or relationships, use the &lt;code&gt;extractId&lt;/code&gt;, &lt;code&gt;extractAttributes&lt;/code&gt; and &lt;code&gt;extractRelationships&lt;/code&gt; hooks.</source>
          <target state="translated">방법을 사용자 정의하려면 &lt;code&gt;JSONSerializer&lt;/code&gt; 가 귀하의 ID, 속성이나 관계를 정상화, 사용 &lt;code&gt;extractId&lt;/code&gt; , &lt;code&gt;extractAttributes&lt;/code&gt; 및 &lt;code&gt;extractRelationships&lt;/code&gt; 의 후크를.</target>
        </trans-unit>
        <trans-unit id="ba373f1b978a32c09a08e1c1a2055e76267a7a9f" translate="yes" xml:space="preserve">
          <source>To customize how a single record is normalized, use the &lt;code&gt;normalize&lt;/code&gt; hook.</source>
          <target state="translated">단일 레코드의 정규화 방법을 사용자 정의하려면 &lt;code&gt;normalize&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="896f7618df1a2c5ae15b21da0d539bcce0c86fef" translate="yes" xml:space="preserve">
          <source>To customize metadata extraction, check out the documentation for your serializer.</source>
          <target state="translated">메타 데이터 추출을 사용자 정의하려면 직렬 변환기 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d00f2a82ea97d7698e61579522a38bad982a0f6f" translate="yes" xml:space="preserve">
          <source>To declare a many-to-many relationship between two models, use &lt;code&gt;DS.hasMany&lt;/code&gt;:</source>
          <target state="translated">두 모델 사이의 다 대다 관계를 선언하려면 &lt;code&gt;DS.hasMany&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f384718df6203efdfa0de22885112131e57b9ef5" translate="yes" xml:space="preserve">
          <source>To declare a one-to-many relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt; in combination with &lt;code&gt;DS.hasMany&lt;/code&gt;, like this:</source>
          <target state="translated">두 모델 간의 일대 다 관계를 사용 선언하려면 &lt;code&gt;DS.belongsTo&lt;/code&gt; 와 함께 &lt;code&gt;DS.hasMany&lt;/code&gt; 이 등을 :</target>
        </trans-unit>
        <trans-unit id="fd45271172de2827aec0b66ded46c1526981e4f0" translate="yes" xml:space="preserve">
          <source>To declare a one-to-one relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt;:</source>
          <target state="translated">두 모델간에 일대일 관계를 선언하려면 &lt;code&gt;DS.belongsTo&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="22bb95d7016d3a82a771c01b24a90740704cb355" translate="yes" xml:space="preserve">
          <source>To define a Controller, run:</source>
          <target state="translated">컨트롤러를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="537f62c13bb7ffd878dfd54110b3a5a612606ee8" translate="yes" xml:space="preserve">
          <source>To define a component, run:</source>
          <target state="translated">구성 요소를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="284d1b21151d2a0f19c15e660bf3d35370f288b5" translate="yes" xml:space="preserve">
          <source>To define a new Ember &lt;em&gt;class&lt;/em&gt;, call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt;&lt;code&gt;Ember.Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">새로운 Ember &lt;em&gt;클래스&lt;/em&gt; 를 정의하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt; &lt;code&gt;Ember.Object&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt; &lt;code&gt;extend()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="820da85f7f75fe525eb448c437bc45950e1f888d" translate="yes" xml:space="preserve">
          <source>To define a route, run</source>
          <target state="translated">경로를 정의하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e7d7b2d08cd1de85998600ba46809350abc299b9" translate="yes" xml:space="preserve">
          <source>To deploy an Ember application simply transfer the output from &lt;code&gt;ember build&lt;/code&gt; to a web server. This can be done with standard Unix file transfer tools such as &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;scp&lt;/code&gt;. There are also services that will let you deploy easily.</source>
          <target state="translated">Ember 애플리케이션을 배포하려면 단순히 엠버 &lt;code&gt;ember build&lt;/code&gt; 의 출력을 웹 서버 로 전송하십시오 . 이것은 &lt;code&gt;rsync&lt;/code&gt; 또는 &lt;code&gt;scp&lt;/code&gt; 와 같은 표준 Unix 파일 전송 도구를 사용하여 수행 할 수 있습니다 . 쉽게 배포 할 수있는 서비스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="065fd99d1476baffa1b82c4b08460d031141cb32" translate="yes" xml:space="preserve">
          <source>To deploy to the same URL after making changes, perform the same steps, reusing the same domain as before.</source>
          <target state="translated">변경 후 동일한 URL에 배포하려면 이전과 동일한 도메인을 재사용하여 동일한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6734a6e5bb3c4c06ddac515519b73ca33307818c" translate="yes" xml:space="preserve">
          <source>To disable bubbling with closure style actions you must create your own wrapper helper that makes use of &lt;code&gt;event.stopPropagation()&lt;/code&gt;:</source>
          <target state="translated">클로저 스타일 액션으로 버블 링을 비활성화하려면 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 사용하는 자체 래퍼 도우미를 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="03d431777776d94843205036e89382929b67b7df" translate="yes" xml:space="preserve">
          <source>To disable bubbling, pass &lt;code&gt;bubbles=false&lt;/code&gt; to the helper:</source>
          <target state="translated">버블 링을 비활성화하려면 &lt;code&gt;bubbles=false&lt;/code&gt; 를 도우미에게 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="83f92bbd711ff46b48c7b3053ad6815ca742a2e1" translate="yes" xml:space="preserve">
          <source>To dispatch an action on specific events, such as &lt;code&gt;enter&lt;/code&gt; or &lt;code&gt;key-press&lt;/code&gt;, use the following</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; 또는 &lt;code&gt;key-press&lt;/code&gt; 와 같은 특정 이벤트에 대한 조치를 전달하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53be2d3cee464dda29e541bcc47ec4c0a39972d4" translate="yes" xml:space="preserve">
          <source>To do so, run the following command:</source>
          <target state="translated">이렇게하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0711a711e6a702ee3f035ad582cb0f83d0ea3111" translate="yes" xml:space="preserve">
          <source>To do so, simply set the &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; flag to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이렇게하려면 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 플래그를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="642b3e926c752f7b1f53ecb9a54d25f0d597ad8b" translate="yes" xml:space="preserve">
          <source>To do that, replace occurrences of &lt;code&gt;/list-rentals&lt;/code&gt; in the generated test with &lt;code&gt;/&lt;/code&gt;. The test will start our app at the base url, &lt;code&gt;http://localhost:4200/&lt;/code&gt;, and then do a basic check that the page has finished loading and that the url is what we want it to be.</source>
          <target state="translated">이를 위해의 발생 교체 &lt;code&gt;/list-rentals&lt;/code&gt; 로 생성 된 테스트에서 &lt;code&gt;/&lt;/code&gt; . 테스트는 기본 URL &lt;code&gt;http://localhost:4200/&lt;/code&gt; 에서 앱을 시작한 다음 페이지로드가 완료되었고 URL이 원하는 것인지 기본 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1df522ee440a55de68e6a9dd8378f737af37e593" translate="yes" xml:space="preserve">
          <source>To do that, we modify our route as follows:</source>
          <target state="translated">이를 위해 다음과 같이 경로를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="077ff282e23889aeeea0b97f0141bf14b2b23e54" translate="yes" xml:space="preserve">
          <source>To do that, we'll use a &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt;&lt;code&gt;{{link-to}}&lt;/code&gt;&lt;/a&gt; helper that Ember provides that makes it easy to link between our routes. Let's adjust our &lt;code&gt;about.hbs&lt;/code&gt; file:</source>
          <target state="translated">이를 위해 Ember에서 제공 하는 &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt; &lt;code&gt;{{link-to}}&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 경로를 쉽게 연결할 수 있습니다. &lt;code&gt;about.hbs&lt;/code&gt; 파일을 조정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="d87c2ae1d29eef6f28426678419f6574ae578e14" translate="yes" xml:space="preserve">
          <source>To embed the &lt;code&gt;ids&lt;/code&gt; for a related object (using a hasMany relationship):</source>
          <target state="translated">hasMany 관계를 사용하여 관련 오브젝트 의 &lt;code&gt;ids&lt;/code&gt; 를 임베드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7b266ec9d9020d51490a793b222a2e15e77408c1" translate="yes" xml:space="preserve">
          <source>To embed the relationship as a collection of objects with &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; keys, set &lt;code&gt;ids-and-types&lt;/code&gt; for the related object.</source>
          <target state="translated">행을 가진 객체의 컬렉션으로서 포함 관계 &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 키 세트 &lt;code&gt;ids-and-types&lt;/code&gt; 관련 개체를.</target>
        </trans-unit>
        <trans-unit id="d4dbe3553d2c10be5b18402a6280f709c7557952" translate="yes" xml:space="preserve">
          <source>To enable support for data attributes an attribute binding must be added to the component, e.g. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;&lt;code&gt;Ember.LinkComponent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;&lt;code&gt;Ember.TextField&lt;/code&gt;&lt;/a&gt; for the specific attribute:</source>
          <target state="translated">데이터 속성을 지원하려면 특정 속성에 대해 속성 바인딩을 컴포넌트에 추가해야합니다 (예 : &lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt; &lt;code&gt;Ember.LinkComponent&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt; &lt;code&gt;Ember.TextField&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5f57bc075f6cf1a9892170f5cc300d7a2ec2da" translate="yes" xml:space="preserve">
          <source>To enable the Tomster icon to show up in the URL bar whenever you are visiting a site that uses Ember visit &lt;code&gt;about:addons&lt;/code&gt;.</source>
          <target state="translated">Ember를 사용하는 사이트를 방문 할 때마다 URL 막대에 Tomster 아이콘이 표시되도록하려면 &lt;code&gt;about:addons&lt;/code&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="52c2b2d458eaa991122169345b898417f6372aad" translate="yes" xml:space="preserve">
          <source>To enable this mode you can set:</source>
          <target state="translated">이 모드를 활성화하려면 다음을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d3e54ffc59a679009cd71018fbf20dc2908c33d0" translate="yes" xml:space="preserve">
          <source>To enumerate all the values of an enumerable object, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 객체의 모든 값을 열거하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt; &lt;code&gt;forEach()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e247d282c81bce4351bac12e80aee643f2064371" translate="yes" xml:space="preserve">
          <source>To facilitate pluralizing model names when generating route urls Ember Data comes bundled with &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt;, an ActiveSupport::Inflector compatible library for inflecting words between plural and singular forms. Irregular or uncountable pluralizations can be specified via &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt;. A common way to do this is:</source>
          <target state="translated">경로 URL을 생성 할 때 모델 이름을 다원화하기 위해 Ember Data는 &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt; 와 함께 번들로 제공됩니다. Ember Inflector 는 ActiveSupport :: Inflector 호환 라이브러리로, 복수형과 단수형 사이의 단어를 반영합니다. 불규칙하거나 셀 수없는 복수형은 &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt; 를 통해 지정할 수 있습니다 . 이를 수행하는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89387035491e2b9779d432c33ff0f9bc1db9ee30" translate="yes" xml:space="preserve">
          <source>To facilitate this, Ember provides the &lt;code&gt;@each&lt;/code&gt; key illustrated below:</source>
          <target state="translated">이를 용이하게하기 위해 Ember는 아래에 설명 된 &lt;code&gt;@each&lt;/code&gt; 키를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d181f0d9ef256075afc193e940cb2778cc125a3c" translate="yes" xml:space="preserve">
          <source>To fetch an instantiated factory from the running application you can call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</source>
          <target state="translated">실행중인 응용 프로그램에서 인스턴스화 된 팩토리를 가져 오려면 응용 프로그램 인스턴스 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt; 메서드를 호출 할 수 있습니다 . 이 메소드는 문자열을 사용하여 팩토리를 식별하고 적절한 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8d1f23fd8117e1414f047abb53730ce2c42e57e9" translate="yes" xml:space="preserve">
          <source>To filter the logs, type a query in the search box.</source>
          <target state="translated">로그를 필터링하려면 검색 상자에 쿼리를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c9e9ecb077e7d53718dabf283948eae57a0fe4" translate="yes" xml:space="preserve">
          <source>To find out whether at least one item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt;&lt;code&gt;any()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 항목 중 적어도 하나의 항목이 어떤 조건과 일치하는지 확인하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt; &lt;code&gt;any()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c63511432e85445a8b4de943b86b4ff86b52bda" translate="yes" xml:space="preserve">
          <source>To find out whether every item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt;&lt;code&gt;every()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">열거 가능한 모든 항목이 특정 조건과 일치하는지 확인하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt; &lt;code&gt;every()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06062dde08f65defee01d144c5693a07b8897c5e" translate="yes" xml:space="preserve">
          <source>To find the elements that have a class called &lt;code&gt;listing&lt;/code&gt;, we'll use a test helper called &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;find&lt;/a&gt;. The &lt;code&gt;find&lt;/code&gt; function returns the elements that match the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS selector&lt;/a&gt;. In this case it will return an array of all the elements with a class called &lt;code&gt;listing&lt;/code&gt;.</source>
          <target state="translated">라는 클래스가있는 요소를 찾으려면 &lt;code&gt;listing&lt;/code&gt; , 우리라는 테스트 도우미 사용합니다 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;찾기&lt;/a&gt; . &lt;code&gt;find&lt;/code&gt; 함수는 주어진 일치하는 요소를 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS 선택기를&lt;/a&gt; . 이 경우 &lt;code&gt;listing&lt;/code&gt; 이라는 클래스를 가진 모든 요소의 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2fd9f8a52de87bee0c288eaed67d1f195e5f6ddf" translate="yes" xml:space="preserve">
          <source>To fix this add a file called '.htaccess' to the root folder of your website. Add these lines:</source>
          <target state="translated">이 문제를 해결하려면 웹 사이트의 루트 폴더에 '.htaccess'라는 파일을 추가하십시오. 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dc22e48a36a2fa58e492a5c1d7190654605ab3b1" translate="yes" xml:space="preserve">
          <source>To get around these problems, you should make use of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;Ember.run.once()&lt;/code&gt;&lt;/a&gt;. This will ensure that any processing you need to do only happens once, and happens in the next run loop once all bindings are synchronized:</source>
          <target state="translated">이러한 문제를 해결하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;Ember.run.once()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다. 이렇게하면 필요한 처리가 한 번만 수행되고 모든 바인딩이 동기화되면 다음 실행 루프에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c5c7f3992c8b26c72a8ca9516e0759dd90b734e" translate="yes" xml:space="preserve">
          <source>To get different &lt;em&gt;pages&lt;/em&gt; of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.</source>
          <target state="translated">다른 &lt;em&gt;페이지&lt;/em&gt; 의 데이터 를 얻으 려면 오프셋을 10 씩 증분 변경하면됩니다. 지금까지는 좋습니다. 그러나 얼마나 많은 데이터 페이지가 있는지 어떻게 알 수 있습니까? 서버는 총 레코드 수를 메타 데이터로 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a4e5cc694d3be2b7e400ea560253d1f71eaa5c" translate="yes" xml:space="preserve">
          <source>To get multiple properties at once, call &lt;code&gt;Ember.getProperties&lt;/code&gt; with an object followed by a list of strings or an array:</source>
          <target state="translated">한 번에 여러 속성을 가져 오려면 개체와 문자열 목록 또는 배열을 사용하여 &lt;code&gt;Ember.getProperties&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="52ae9585ef4ff335f0b0a68e5513ed3dbe6488ec" translate="yes" xml:space="preserve">
          <source>To get started, let's generate a helper for &lt;code&gt;rental-property-type&lt;/code&gt;:</source>
          <target state="translated">시작하려면 &lt;code&gt;rental-property-type&lt;/code&gt; 대한 도우미를 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="73b15a2e4a984f27699d34f68a905af2183041a0" translate="yes" xml:space="preserve">
          <source>To get the most use out of a component, it is important to understand these lifecycle methods.</source>
          <target state="translated">구성 요소를 최대한 활용하려면 이러한 수명주기 방법을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8e28feb25417f98b442624123c65f66c40e988f2" translate="yes" xml:space="preserve">
          <source>To get the values of multiple properties at once, call &lt;code&gt;getProperties&lt;/code&gt; with a list of strings or an array:</source>
          <target state="translated">여러 속성의 값을 한 번에 얻으려면 문자열 목록이나 배열을 사용하여 &lt;code&gt;getProperties&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7806e1c587e05f08b69393f6478019cb19942b1e" translate="yes" xml:space="preserve">
          <source>To handle this function call you need to modify the &lt;code&gt;people-list&lt;/code&gt; component file to add the function to be called. In the component, add an &lt;code&gt;actions&lt;/code&gt; object with a &lt;code&gt;showPerson&lt;/code&gt; function that alerts the first argument.</source>
          <target state="translated">이 함수 호출을 처리하려면 &lt;code&gt;people-list&lt;/code&gt; 구성 요소 파일을 수정하여 호출 할 함수 를 추가해야합니다. 컴포넌트 에서 첫 번째 인수를 알리는 &lt;code&gt;showPerson&lt;/code&gt; 함수를 사용 하여 &lt;code&gt;actions&lt;/code&gt; 오브젝트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5416b7eb8dce5acb1c8efef4e78276fe44c883b2" translate="yes" xml:space="preserve">
          <source>To have your route do something beyond render a template with the same name, you'll need to create a route handler. The following guides will explore the different features of route handlers. For more information on routes, see the API documentation for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;the router&lt;/a&gt; and for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;route handlers&lt;/a&gt;.</source>
          <target state="translated">같은 이름으로 템플릿을 렌더링하는 것 이상의 경로를 만들려면 경로 처리기를 만들어야합니다. 다음 가이드는 경로 핸들러의 다양한 기능을 살펴 봅니다. 라우트에 대한 자세한 정보 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;는 라우터&lt;/a&gt; 및 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;라우트 핸들러에&lt;/a&gt; 대한 API 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37017a8822c89a19516c602dcc48cbd220d1dbfb" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;filter&lt;/code&gt; function to do the actual filter of rentals by city, we'll create a &lt;code&gt;rentals&lt;/code&gt; controller. &lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;Controllers&lt;/a&gt; contain actions and properties available to the template of its corresponding route. In our case we want to generate a controller called &lt;code&gt;rentals&lt;/code&gt;. Ember will know that a controller with the name of &lt;code&gt;rentals&lt;/code&gt; will apply to the route with the same name.</source>
          <target state="translated">도시별로 실제 임대를 필터링 하는 &lt;code&gt;filter&lt;/code&gt; 기능 을 구현하기 위해 &lt;code&gt;rentals&lt;/code&gt; 컨트롤러를 만듭니다 . &lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;컨트롤러&lt;/a&gt; 에는 해당 경로의 템플릿에 사용 가능한 작업 및 속성이 포함됩니다. 우리의 경우 &lt;code&gt;rentals&lt;/code&gt; 이라는 컨트롤러를 생성하려고합니다 . Ember는 &lt;code&gt;rentals&lt;/code&gt; 이름을 가진 컨트롤러가 동일한 이름을 가진 경로에 적용될 것임을 알 것입니다.</target>
        </trans-unit>
        <trans-unit id="db39c8ec99de08b269bbe4798a73309f9f804b4b" translate="yes" xml:space="preserve">
          <source>To improve the network performance of your application, you can optimize your adapter by overriding these lower-level methods:</source>
          <target state="translated">응용 프로그램의 네트워크 성능을 향상시키기 위해 다음과 같은 하위 레벨 방법을 대체하여 어댑터를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cdcf89a4a448babacd6de864831466ba71fbff2" translate="yes" xml:space="preserve">
          <source>To iterate over a list of items, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper. The first argument to this helper is the array to be iterated, and the value being iterated is yielded as a block param. Block params are only available inside the block of their helper.</source>
          <target state="translated">항목 목록을 반복하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt; 도우미를 사용하십시오. 이 헬퍼에 대한 첫 번째 인수는 반복 될 배열이며, 반복되는 값은 블록 매개 변수로 나타납니다. 블록 매개 변수는 도우미 블록 내에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f24d5f6782acbbef958bb70776badee1ad078d" translate="yes" xml:space="preserve">
          <source>To learn more about the events Ember components use, see &lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;components/handling-events&lt;/a&gt;.</source>
          <target state="translated">Ember 구성 요소가 사용하는 이벤트에 대한 자세한 내용은 &lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;components / handling-events를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1d4e80f03459d1f52f2363e1225daa9d4f187cf" translate="yes" xml:space="preserve">
          <source>To limit the test to validating only its own behavior and not the service, we'll take advantage of the registration API to register a stub maps service. That way when Ember injects the map service into the component, it uses our fake service instead of the real one.</source>
          <target state="translated">서비스가 아닌 자체 동작 만 검증하도록 테스트를 제한하기 위해 등록 API를 활용하여 스텁 맵 서비스를 등록합니다. 이렇게하면 Ember가 맵 서비스를 컴포넌트에 삽입 할 때 실제 서비스 대신 가짜 서비스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="77755e062047f1b190e24cc4c004d477b633a1d4" translate="yes" xml:space="preserve">
          <source>To load a model for the &lt;code&gt;favorite-posts&lt;/code&gt; route, you would use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt;&lt;code&gt;model()&lt;/code&gt;&lt;/a&gt; hook in the &lt;code&gt;favorite-posts&lt;/code&gt; route handler:</source>
          <target state="translated">&lt;code&gt;favorite-posts&lt;/code&gt; 라우트에 대한 모델을로드하려면 &lt;code&gt;favorite-posts&lt;/code&gt; 라우트 핸들러 에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt; &lt;code&gt;model()&lt;/code&gt; &lt;/a&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f654c2cf3da300af867e72e2bd26f7caf007cd2a" translate="yes" xml:space="preserve">
          <source>To make the most out of the guides, you should have a working knowledge of:</source>
          <target state="translated">가이드를 최대한 활용하려면 다음에 대한 실무 지식이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c0de715ec4bdc05fe56d9fee36be46b5f31b2be4" translate="yes" xml:space="preserve">
          <source>To make your own custom class enumerable, you need two items:</source>
          <target state="translated">자신 만의 커스텀 클래스를 열거 가능하게하려면 두 가지 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1c466dfb41d5e397019aa3e58144514a595ced70" translate="yes" xml:space="preserve">
          <source>To match multiple routes 'space-separate' the routes:</source>
          <target state="translated">여러 경로를 '공간 분리'하여 경로를 일치 시키려면 :</target>
        </trans-unit>
        <trans-unit id="13060a627addc391f25235a99ca3db1518034089" translate="yes" xml:space="preserve">
          <source>To measure components and templates that are rendered on initial application boot, click on the &quot;Reload&quot; button at the top. This button ensures that the Inspector starts measuring render times when your app boots.</source>
          <target state="translated">초기 응용 프로그램 부팅시 렌더링되는 구성 요소 및 템플릿을 측정하려면 상단의 &quot;재로드&quot;버튼을 클릭하십시오. 이 버튼을 사용하면 앱이 부팅 될 때 인스펙터가 렌더링 시간을 측정하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dc09e7ab0122ed1f10aad8febf2686e9ee8f8063" translate="yes" xml:space="preserve">
          <source>To normalize only a single model, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt;&lt;code&gt;normalize()&lt;/code&gt;&lt;/a&gt; hook similarly.</source>
          <target state="translated">단일 모델 만 정규화하려면 normalize &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt; &lt;code&gt;normalize()&lt;/code&gt; &lt;/a&gt; 후크를 유사하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b36d9c0d96220aa91e734666c278c544e5c33712" translate="yes" xml:space="preserve">
          <source>To open the Inspector, click on the new bookmark. Safari blocks popups by default, so you'll need to enable popups before using the bookmarklet.</source>
          <target state="translated">인스펙터를 열려면 새 북마크를 클릭하십시오. Safari는 기본적으로 팝업을 차단하므로 책갈피를 사용하기 전에 팝업을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e32951622e512a5e2dbbf6daeb91928456978164" translate="yes" xml:space="preserve">
          <source>To override this method with a custom one, make sure to call &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; with your pre-processed data.</source>
          <target state="translated">이 메소드를 사용자 정의 메소드로 대체하려면 사전 처리 된 데이터로 &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="643424ccbff431db940e6db1682aad8fbb931a53" translate="yes" xml:space="preserve">
          <source>To override this option for your entire application, see &quot;Overriding Application-wide Defaults&quot;.</source>
          <target state="translated">전체 응용 프로그램에 대해이 옵션을 재정의하려면 &quot;응용 프로그램 전체 기본값 재정의&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7b7de1f5b2acd114aa92dfc71c79109066e6419" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments to a helper, add them as a space-separated list after the helper name:</source>
          <target state="translated">도우미에 여러 인수를 전달하려면 도우미 이름 뒤에 공백으로 구분 된 목록으로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="782db8348bb156313d7ba95741850dae22fcade0" translate="yes" xml:space="preserve">
          <source>To prevent Ember from setting up a listener for a default event, specify the event name with a &lt;code&gt;null&lt;/code&gt; value in the &lt;code&gt;customEvents&lt;/code&gt; property:</source>
          <target state="translated">Ember가 기본 이벤트에 대한 리스너를 설정하지 못하게하려면 &lt;code&gt;customEvents&lt;/code&gt; 특성 에 이벤트 이름을 &lt;code&gt;null&lt;/code&gt; 값으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ad2dcdf74eb53253ee43f5d7112c03d7ee0c5cc" translate="yes" xml:space="preserve">
          <source>To prevent default events from being listened to:</source>
          <target state="translated">기본 이벤트가 수신되지 않도록하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d140dc02f52e1fafe21fbb1f3e0a87899ed55913" translate="yes" xml:space="preserve">
          <source>To prevent setting an attribute altogether, use &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the return value of the &lt;code&gt;attributeBindings&lt;/code&gt; monitored property:</source>
          <target state="translated">속성을 모두 설정하지 못하게하려면 &lt;code&gt;attributeBindings&lt;/code&gt; 모니터링 되는 속성 의 반환 값으로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88949b439b77da8a131b94c8c49c2264eabd59cf" translate="yes" xml:space="preserve">
          <source>To protect your application from cross-site scripting attacks (XSS), Ember automatically escapes any value you return from a helper so that the browser will not interpret it as HTML.</source>
          <target state="translated">XSS (Cross-Site Scripting Attack)로부터 응용 프로그램을 보호하기 위해 Ember는 브라우저에서 HTML로 해석하지 않도록 도우미에서 반환 한 값을 자동으로 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="410e671fa5ad1d60ce482717f4854a77655715ac" translate="yes" xml:space="preserve">
          <source>To provide a &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; to the above template, properties must be added to the application controller. If you are following along with an Ember CLI application, you may need to create this file:</source>
          <target state="translated">위의 템플릿에 &lt;code&gt;firstName&lt;/code&gt; 과 &lt;code&gt;lastName&lt;/code&gt; 을 제공하려면 응용 프로그램 컨트롤러에 속성을 추가해야합니다. Ember CLI 애플리케이션을 따라가는 경우이 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="29f27a0e8e02bfdfa170f1d9c3e3d514551a7d10" translate="yes" xml:space="preserve">
          <source>To push a record into the store, call the store's &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">상점으로 레코드를 푸시하려면 상점의 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt; &lt;code&gt;push()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a185e83c481228539f24bb1c09c6b0245f73852" translate="yes" xml:space="preserve">
          <source>To remove a &lt;code&gt;belongsTo&lt;/code&gt; relationship, we can set it to &lt;code&gt;null&lt;/code&gt;, which will also remove it from the &lt;code&gt;hasMany&lt;/code&gt; side:</source>
          <target state="translated">&lt;code&gt;belongsTo&lt;/code&gt; 관계 를 제거하기 위해 ,이를 &lt;code&gt;null&lt;/code&gt; 로 설정 하면 &lt;code&gt;hasMany&lt;/code&gt; 측에서도 제거됩니다 :</target>
        </trans-unit>
        <trans-unit id="432349a69d598accb34ee2c2bc3e7748a2394e9f" translate="yes" xml:space="preserve">
          <source>To remove an object from an enumerable, use the &lt;code&gt;removeObject()&lt;/code&gt; method. This will only remove the object if it is present in the enumerable, otherwise this method has no effect.</source>
          <target state="translated">열거 가능 객체에서 객체를 제거하려면 &lt;code&gt;removeObject()&lt;/code&gt; 메서드를 사용하십시오 . 열거 형에 개체가있는 경우에만 개체를 ​​제거합니다. 그렇지 않으면이 방법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d9de26d22f9d5fddcc6b008df4be9a302d40e54" translate="yes" xml:space="preserve">
          <source>To represent the children as IDs:</source>
          <target state="translated">자녀를 ID로 나타내려면</target>
        </trans-unit>
        <trans-unit id="96baf3260095c6e999a09f07d2439de39521a921" translate="yes" xml:space="preserve">
          <source>To represent the children relationship as a URL:</source>
          <target state="translated">하위 관계를 URL로 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="61b2e6985c9d49eab39fc6b2473ca71648f4f595" translate="yes" xml:space="preserve">
          <source>To run a subset of your tests by title use the &lt;code&gt;--filter&lt;/code&gt; option. Quickly test your current work &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt;, or only run a certain type of test &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt;. When using QUnit it is possible to exclude tests by adding an exclamation point to the beginning of the filter &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt;.</source>
          <target state="translated">제목별로 테스트의 하위 세트를 실행하려면 &lt;code&gt;--filter&lt;/code&gt; 옵션을 사용하십시오 . 현재 작업 &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt; 빠르게 테스트 하거나 특정 유형의 테스트 &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt; 만 실행하십시오 . QUnit을 사용할 때 필터 &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt; 의 시작 부분에 느낌표를 추가하여 테스트를 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1886972c9e7e9a4f558bbcd67fc568ef5594acf6" translate="yes" xml:space="preserve">
          <source>To see a list of libraries used in your application, click on the &lt;code&gt;Info&lt;/code&gt; menu. This view displays the libraries used, along with their version.</source>
          <target state="translated">응용 프로그램에 사용 된 라이브러리 목록을 보려면 &lt;code&gt;Info&lt;/code&gt; 메뉴를 클릭하십시오 . 이보기에는 사용 된 라이브러리와 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3f95548b425d3595dc1e5a7a281f78a35f8f4c" translate="yes" xml:space="preserve">
          <source>To see how a template was rendered by Ember, click on the template in the View Tree. If you're using Chrome or Firefox, you'll be sent to the Elements panel with that DOM element selected.</source>
          <target state="translated">Ember가 템플릿을 렌더링 한 방법을 보려면 뷰 트리에서 템플릿을 클릭하십시오. Chrome 또는 Firefox를 사용하는 경우 해당 DOM 요소가 선택된 요소 패널로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e44b68c60f76b61bbdf60c921597a9cf8aad1469" translate="yes" xml:space="preserve">
          <source>To see the full list of computed property macros, have a look at &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;the API documentation&lt;/a&gt;</source>
          <target state="translated">계산 된 속성 매크로의 전체 목록을 보려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;API 설명서를&lt;/a&gt; 살펴보십시오</target>
        </trans-unit>
        <trans-unit id="10d1aa4aa9fe506d80116cddb13e609d02185dad" translate="yes" xml:space="preserve">
          <source>To set the component up to receive parameters this way, you need to set the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt;&lt;code&gt;positionalParams&lt;/code&gt;&lt;/a&gt; attribute in your component class.</source>
          <target state="translated">이런 방식으로 구성 요소가 매개 변수를 받도록 설정하려면 구성 요소 클래스에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt; &lt;code&gt;positionalParams&lt;/code&gt; &lt;/a&gt; 특성 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="844e0103c86e1064d969400e55f8cbd4212c42ec" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer then define and configure embedded relationships.</source>
          <target state="translated">임베디드 레코드를 설정하려면 직렬 변환기를 확장 할 때 믹스 인을 포함시킨 후 임베디드 관계를 정의하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="7823165518baac275622086e0a64947c8412aa36" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer, then define and configure embedded (model) relationships.</source>
          <target state="translated">임베디드 레코드를 설정하려면 직렬 변환기를 확장 할 때 믹스 인을 포함시킨 후 임베디드 (모델) 관계를 정의하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="04b6c1283408d9d9cea206ac24ad417174a73fb9" translate="yes" xml:space="preserve">
          <source>To show an error from the server related to the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; properties your adapter could return a promise that rejects with a &lt;code&gt;DS.InvalidError&lt;/code&gt; object that looks like this:</source>
          <target state="translated">&lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;content&lt;/code&gt; 특성 과 관련된 서버의 오류를 표시하기 위해 어댑터는 다음과 같은 &lt;code&gt;DS.InvalidError&lt;/code&gt; 오브젝트로 거부되는 약속을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d22fb46ffa697dab0c28d5708fe886c943fb273" translate="yes" xml:space="preserve">
          <source>To show something on every page, we can use the application template (which we edited earlier). Let's open it again (&lt;code&gt;/app/templates/application.hbs&lt;/code&gt;) and replace its contents with the following:</source>
          <target state="translated">모든 페이지에 무언가를 보여주기 위해, 우리는 이전에 편집 한 응용 프로그램 템플릿을 사용할 수 있습니다. 다시 열고 ( &lt;code&gt;/app/templates/application.hbs&lt;/code&gt; ) 내용을 다음과 같이 바꾸자 :</target>
        </trans-unit>
        <trans-unit id="ce4f53072b200771a6bd1a485f9c6358e79dc97f" translate="yes" xml:space="preserve">
          <source>To show the basic setup of an Ember application, we'll walk through building an app for a property rental site called Super Rentals. We'll start with a homepage, an about page and a contact page.</source>
          <target state="translated">Ember 애플리케이션의 기본 설정을 보여주기 위해 Super Rentals라는 부동산 임대 사이트 용 앱을 작성하는 과정을 안내합니다. 홈페이지, 정보 페이지 및 연락처 페이지로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="1c27517c0e2be0e963976ab64dbcdf375c7c6419" translate="yes" xml:space="preserve">
          <source>To specify that a parameter is mutable, when invoking the child &lt;code&gt;Component&lt;/code&gt;:</source>
          <target state="translated">하위 &lt;code&gt;Component&lt;/code&gt; 를 호출 할 때 매개 변수를 변경할 수 있도록 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ca79710a45c8aed09d51d44e598c3593126facf" translate="yes" xml:space="preserve">
          <source>To stub the location service in your test, create a local stub object that extends &lt;code&gt;Ember.Service&lt;/code&gt;, and register the stub as the service your tests need in the beforeEach function. In this case we initially force location to New York.</source>
          <target state="translated">테스트에서 위치 서비스를 스텁하려면 &lt;code&gt;Ember.Service&lt;/code&gt; 를 확장하는 로컬 스텁 오브젝트를 작성하고 테스트가 beforeEach 함수에서 필요한 서비스로 스텁을 등록하십시오. 이 경우 처음에 위치를 뉴욕으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="83c3a034dda372c47a7e55506b94a499dd11f2f5" translate="yes" xml:space="preserve">
          <source>To successfully extract and serialize embedded records the model relationships must be setup correcty. See the &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;defining relationships&lt;/a&gt; section of the &lt;strong&gt;Defining Models&lt;/strong&gt; guide page.</source>
          <target state="translated">임베드 된 레코드를 추출하고 직렬화하려면 모델 관계를 올바르게 설정해야합니다. 참고 항목 &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;정의 관계&lt;/a&gt; 의 섹션 &lt;strong&gt;정의 모델&lt;/strong&gt; 가이드 페이지를.</target>
        </trans-unit>
        <trans-unit id="d6f5b7a5feba70d7bbd8e7ea599c7843b8360f83" translate="yes" xml:space="preserve">
          <source>To support &lt;code&gt;Ember.Array&lt;/code&gt; in your own class, you must override two primitives to use it: &lt;code&gt;length()&lt;/code&gt; and &lt;code&gt;objectAt()&lt;/code&gt;.</source>
          <target state="translated">자신의 클래스에서 &lt;code&gt;Ember.Array&lt;/code&gt; 를 지원하려면 &lt;code&gt;length()&lt;/code&gt; 와 &lt;code&gt;objectAt()&lt;/code&gt; 두 가지 기본 요소를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="284156262ec009225218096a34db99fe111eef94" translate="yes" xml:space="preserve">
          <source>To tell the application which rental we want to access, we need to replace the &lt;code&gt;show&lt;/code&gt; route path with the ID of the rental listing. We also want to simplify the URL so that it looks more like this: &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt;.</source>
          <target state="translated">애플리케이션에 액세스하려는 임대를 알려주려면 &lt;code&gt;show&lt;/code&gt; 경로 경로를 임대 목록의 ID 로 바꿔야합니다 . 또한 &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt; 과 같이 URL을 단순화하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="eb8bdc2ee12cbad5bed5fddb2deaabca492791bd" translate="yes" xml:space="preserve">
          <source>To test it, we create an instance of our class &lt;code&gt;SomeThing&lt;/code&gt; as defined above, call the &lt;code&gt;testMethod&lt;/code&gt; method and assert that the internal state is correct as a result of the method call.</source>
          <target state="translated">이를 테스트하기 위해 위에서 정의 &lt;code&gt;SomeThing&lt;/code&gt; 클래스의 인스턴스를 작성 하고 &lt;code&gt;testMethod&lt;/code&gt; 메소드를 호출 한 후 메소드 호출의 결과로 내부 상태가 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5469506e055e796f8450fa42672d0e80ba255641" translate="yes" xml:space="preserve">
          <source>To trace a Promise, click on the &lt;code&gt;Trace&lt;/code&gt; button next to the label, which will send the Promise stack trace to the console.</source>
          <target state="translated">Promise를 추적하려면 레이블 옆 에있는 &lt;code&gt;Trace&lt;/code&gt; (추적) 버튼을 클릭 하면 Promise 스택 추적이 콘솔로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="81efb30747bfc7cc6e140692ae70701b93384146" translate="yes" xml:space="preserve">
          <source>To trigger this event:</source>
          <target state="translated">이 이벤트를 트리거하려면</target>
        </trans-unit>
        <trans-unit id="48d77718e1db6d457932cf1dfee14241b04544bc" translate="yes" xml:space="preserve">
          <source>To use a tag other than &lt;code&gt;div&lt;/code&gt;, subclass &lt;code&gt;Ember.Component&lt;/code&gt; and assign it a &lt;code&gt;tagName&lt;/code&gt; property. This property can be any valid HTML5 tag name as a string.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 이외의 태그를 사용하려면 &lt;code&gt;Ember.Component&lt;/code&gt; 를 서브 클래스로 만들고 &lt;code&gt;tagName&lt;/code&gt; 속성을 지정하십시오 . 이 속성은 문자열로 유효한 HTML5 태그 이름이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a10e85d71bb02f30ffa65660d976a2614878268" translate="yes" xml:space="preserve">
          <source>To use it in your application you will need to define a &lt;code&gt;serializer:application&lt;/code&gt; that extends the &lt;code&gt;JSONSerializer&lt;/code&gt;.</source>
          <target state="translated">애플리케이션에서 사용하려면 &lt;code&gt;JSONSerializer&lt;/code&gt; 를 확장 하는 &lt;code&gt;serializer:application&lt;/code&gt; 을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac55d23e3de772ab700ee1e89d91af6e27bd4d1" translate="yes" xml:space="preserve">
          <source>To use it, pass the conditional value to the &lt;code&gt;if&lt;/code&gt; helper, using the block form to wrap the section of template you want to conditionally render. Like so:</source>
          <target state="translated">이를 사용하려면 조건부로 렌더링하려는 템플리트의 섹션을 랩 양식으로 랩핑하여 조건부 값을 &lt;code&gt;if&lt;/code&gt; 헬퍼에 전달하십시오 . 이렇게 :</target>
        </trans-unit>
        <trans-unit id="d4ed92f3e127472a3aa889d5c0b4781b9d9a78db" translate="yes" xml:space="preserve">
          <source>To use our new Ember Data Model object, we need to update the &lt;code&gt;model&lt;/code&gt; function we &lt;a href=&quot;../model-hook&quot;&gt;previously defined&lt;/a&gt; in our route handler. Delete the hard-coded JavaScript Array, and replace it with the following call to the &lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store service&lt;/a&gt;. The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;store service&lt;/a&gt; is injected into all routes and components in Ember. It is the main interface you use to interact with Ember Data. In this case, call the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;findAll&lt;/code&gt;&lt;/a&gt; function on the store and provide it with the name of your newly created rental model class.</source>
          <target state="translated">새로운 Ember Data Model 객체를 사용하려면 &lt;a href=&quot;../model-hook&quot;&gt;이전&lt;/a&gt; 에 경로 처리기에서 정의한 &lt;code&gt;model&lt;/code&gt; 함수 를 업데이트해야 합니다. 하드 코딩 된 JavaScript 배열을 삭제하고 &lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store 서비스에&lt;/a&gt; 대한 다음 호출로 바꿉니다 . &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;저장소 서비스는&lt;/a&gt; 엠버의 모든 경로와 구성 요소로 주입된다. Ember Data와 상호 작용하는 데 사용하는 기본 인터페이스입니다. 이 경우 상점 에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;findAll&lt;/code&gt; &lt;/a&gt; 함수를 호출하고 새로 작성된 임대 모델 클래스의 이름을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bd3b7a10987c576e4b3e5ef0d1eb55854bd669" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;format-currency&lt;/code&gt; helper, you call it using curly braces in your template:</source>
          <target state="translated">서식 &lt;code&gt;format-currency&lt;/code&gt; 도우미 를 사용하려면 템플릿에서 중괄호를 사용하여 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ff265ce4f656a5022fc0eb3e3b6a48bcf6f66b72" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;meta&lt;/code&gt; data outside of the &lt;code&gt;model&lt;/code&gt; hook, you need to return it:</source>
          <target state="translated">&lt;code&gt;model&lt;/code&gt; 후크 외부 에서 &lt;code&gt;meta&lt;/code&gt; 데이터 를 사용하려면 메타 데이터 를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c97e84d6c7f8dbcc0f576804dd9a172f8ea4443" translate="yes" xml:space="preserve">
          <source>To use the Inspector with the &lt;code&gt;file://&lt;/code&gt; protocol, visit &lt;code&gt;chrome://extensions&lt;/code&gt; in Chrome and check the &quot;Allow access to file URLs&quot; checkbox:</source>
          <target state="translated">Inspector를 &lt;code&gt;file://&lt;/code&gt; 프로토콜 과 함께 사용하려면 Chrome에서 &lt;code&gt;chrome://extensions&lt;/code&gt; 를 방문 하여 &quot;파일 URL에 대한 액세스 허용&quot;확인란을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5b4b9b0f7d1081e76bebbad8d407bc61b550eeac" translate="yes" xml:space="preserve">
          <source>To use the block form, add a &lt;code&gt;#&lt;/code&gt; character to the beginning of the component name, then make sure to add a closing tag.</source>
          <target state="translated">블록 형식을 사용하려면 구성 요소 이름의 시작 부분에 &lt;code&gt;#&lt;/code&gt; 문자를 추가 한 다음 닫는 태그를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2b34f2fce983b8f7e66aeba0dcd54687c1641fe4" translate="yes" xml:space="preserve">
          <source>To use url building, include the mixin when extending an adapter, and call &lt;code&gt;buildURL&lt;/code&gt; where needed. The default behaviour is designed for RESTAdapter.</source>
          <target state="translated">URL 작성을 사용하려면 어댑터를 확장 할 때 믹스 인을 포함시키고 필요한 경우 &lt;code&gt;buildURL&lt;/code&gt; 을 호출 하십시오 . 기본 작동은 RESTAdapter를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b06bc5d392cd3c4ae056891cbe7f6e4fea87f456" translate="yes" xml:space="preserve">
          <source>To utilize an &lt;code&gt;event&lt;/code&gt; object as a function parameter:</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; 객체를 함수 매개 변수로 활용하려면 :</target>
        </trans-unit>
        <trans-unit id="c8e7168cd76584331b5822b4bec75e170927b9af" translate="yes" xml:space="preserve">
          <source>To verify that your installation was successful, run:</source>
          <target state="translated">성공적으로 설치되었는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c45291da01a2d21f8e4e871bb2b3b252689cfbd" translate="yes" xml:space="preserve">
          <source>To view the list of deprecations in an app, click on the &lt;code&gt;Deprecations&lt;/code&gt; menu.</source>
          <target state="translated">앱에서 지원 중단 목록을 보려면 지원 &lt;code&gt;Deprecations&lt;/code&gt; 메뉴를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc6b3697807941cf644d0c3ddef26bebd3c914d3" translate="yes" xml:space="preserve">
          <source>Together, the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; properties form a composite key for the identity map.</source>
          <target state="translated">이와 함께 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 속성은 신원지도에 대한 복합 키를 형성한다.</target>
        </trans-unit>
        <trans-unit id="212af41073666530ad8bf245becce259a0964242" translate="yes" xml:space="preserve">
          <source>Toolbar</source>
          <target state="translated">Toolbar</target>
        </trans-unit>
        <trans-unit id="c201b38fdebbb9bb45b78e75ce5a39c7cd55dd3a" translate="yes" xml:space="preserve">
          <source>Total number of errors.</source>
          <target state="translated">총 오류 수</target>
        </trans-unit>
        <trans-unit id="feca6ac147fe6946560ac4f3352301d8cb402e31" translate="yes" xml:space="preserve">
          <source>Touch events:</source>
          <target state="translated">터치 이벤트 :</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="ee9a7401cfdf77cbfcfa276345967663f2ed541e" translate="yes" xml:space="preserve">
          <source>Transforms are not required. If you do not specify a transform name Ember Data will do no additional processing of the value.</source>
          <target state="translated">변환이 필요하지 않습니다. 변환 이름을 지정하지 않으면 Ember Data는 값을 추가로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ead496f48fa5f6d2d96f52143b2d7c60b4140d3" translate="yes" xml:space="preserve">
          <source>Transition</source>
          <target state="translated">Transition</target>
        </trans-unit>
        <trans-unit id="3a38dd0e80493ddad0a8b9fc31e36c252b5d7258" translate="yes" xml:space="preserve">
          <source>Transition Plans</source>
          <target state="translated">전환 계획</target>
        </trans-unit>
        <trans-unit id="58d6d64ea8820023309981d51b607f7cb4f0da7e" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. The route may be either a single route or route path:</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 경로는 단일 경로 또는 경로 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1b0e501d34e708fc9cc731a2b3c2033acc8b08" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionTo&lt;/code&gt; in all other respects. See 'transitionTo' for additional information regarding multiple models.</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 새 항목을 추가하지 않고 현재 기록 항목을 대체합니다. 그 외에도 다른 모든 점에서 &lt;code&gt;transitionTo&lt;/code&gt; 와 동일 합니다. 여러 모델에 대한 추가 정보는 'transitionTo'를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3817345cd736105fd19da678c761e0ee0dc1d3d6" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionToRoute&lt;/code&gt; in all other respects.</source>
          <target state="translated">가능한 경우 현재 URL을 바꾸면서 다른 경로로 전환하십시오. 새 항목을 추가하지 않고 현재 기록 항목을 대체합니다. 그 외에는 다른 모든 측면에서 &lt;code&gt;transitionToRoute&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f9fbe2b3f5c5cd05ac457782cac8426ace4067da" translate="yes" xml:space="preserve">
          <source>Transition the application into another route. The route may be either a single route or route path:</source>
          <target state="translated">응용 프로그램을 다른 경로로 전환하십시오. 경로는 단일 경로 또는 경로 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09485928bf975e30a09112e580ae8b87390ef25d" translate="yes" xml:space="preserve">
          <source>Transition to a nested route</source>
          <target state="translated">내포 된 경로로 전환</target>
        </trans-unit>
        <trans-unit id="2e8d1954c6e263dec2af78024bacfdd651c85cb4" translate="yes" xml:space="preserve">
          <source>Transitioning After the Model is Known</source>
          <target state="translated">모델을 알고 난 후 전환</target>
        </trans-unit>
        <trans-unit id="8eeb89d7f7b67faed7cc1a366a765420b6ef9289" translate="yes" xml:space="preserve">
          <source>Transitioning Before the Model is Known</source>
          <target state="translated">모델을 알기 전에 전환</target>
        </trans-unit>
        <trans-unit id="b867dfc8d8f207f8f4c1fbcb4af23d1d9288622d" translate="yes" xml:space="preserve">
          <source>Transpile</source>
          <target state="translated">Transpile</target>
        </trans-unit>
        <trans-unit id="7be9134d32caa15cd71ab9ecd34dc5705a1ebaf0" translate="yes" xml:space="preserve">
          <source>Treating a function like a property is useful because they can work with bindings, just like any other property.</source>
          <target state="translated">함수를 속성처럼 취급하는 것은 다른 속성과 마찬가지로 바인딩으로 작업 할 수 있기 때문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b82a6a604ce871413a50334f0f8ba973ba15b4b" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to false.</source>
          <target state="translated">대기 간격의 후행 가장자리 대신 리딩에서 함수를 트리거합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="6bd621dbfc252949948e1fe15e02e3b79027c1b3" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to true.</source>
          <target state="translated">대기 간격의 후행 가장자리 대신 리딩에서 함수를 트리거합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="a2759c77b24ab94668e8d1b8b501df3aeb5de2d0" translate="yes" xml:space="preserve">
          <source>Triggering Changes with Actions</source>
          <target state="translated">동작으로 변경 트리거</target>
        </trans-unit>
        <trans-unit id="05c0c58fbbc9f0cf9c0bb880afe8c0b49d825dcd" translate="yes" xml:space="preserve">
          <source>Triggers a fetch for the backing entity based on its &lt;code&gt;remoteType&lt;/code&gt; (see &lt;code&gt;remoteType&lt;/code&gt; definitions per reference type).</source>
          <target state="translated">&lt;code&gt;remoteType&lt;/code&gt; 을 기준으로 백업 엔티티의 페치를 트리거합니다 (참조 &lt;code&gt;remoteType&lt;/code&gt; 정의 참조).</target>
        </trans-unit>
        <trans-unit id="1f7ec6fd588f66e0f74bc20fe04496819936427e" translate="yes" xml:space="preserve">
          <source>Triggers a named action on the &lt;code&gt;ActionHandler&lt;/code&gt;. Any parameters supplied after the &lt;code&gt;actionName&lt;/code&gt; string will be passed as arguments to the action target function.</source>
          <target state="translated">&lt;code&gt;ActionHandler&lt;/code&gt; 에서 이름 지정된 조치를 트리거합니다 . &lt;code&gt;actionName&lt;/code&gt; 문자열 다음에 제공된 모든 매개 변수 는 조치 대상 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="caf81df837a77ea1a1597867231d2fd92f696d66" translate="yes" xml:space="preserve">
          <source>Triggers a named event for the object. Any additional arguments will be passed as parameters to the functions that are subscribed to the event.</source>
          <target state="translated">객체의 명명 된 이벤트를 트리거합니다. 추가 인수는 이벤트를 구독하는 함수에 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b37a90c35c25e5423f4922a95a3be6ba46a762f1" translate="yes" xml:space="preserve">
          <source>Triggers a reload of the value in this relationship. If the remoteType is &lt;code&gt;&quot;link&quot;&lt;/code&gt; Ember Data will use the relationship link to reload the relationship. Otherwise it will reload the record by its id.</source>
          <target state="translated">이 관계에서 값의 재로드를 트리거합니다. remoteType이 &lt;code&gt;&quot;link&quot;&lt;/code&gt; 인 경우 Ember Data는 관계 링크를 사용하여 관계를 다시로드합니다. 그렇지 않으면 ID로 레코드를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="90ab4ebeae51b5fd454cba0691dd4c85d5df4631" translate="yes" xml:space="preserve">
          <source>Triggers the given DOM event on the element identified by the provided selector. Example:</source>
          <target state="translated">제공된 선택기로 식별 된 요소에서 지정된 DOM 이벤트를 트리거합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b3c7ae9f5129772a579c1a689085b260b5f7a672" translate="yes" xml:space="preserve">
          <source>Triggers the given event, e.g. &lt;code&gt;blur&lt;/code&gt;, &lt;code&gt;dblclick&lt;/code&gt; on the element identified by the provided selector.</source>
          <target state="translated">제공된 선택기로 식별 된 요소 에서 주어진 이벤트 (예 : &lt;code&gt;blur&lt;/code&gt; , &lt;code&gt;dblclick&lt;/code&gt; ) 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="88ede053a62e801fe94c3f39f9283bc95d7953b4" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;didTransition&lt;/code&gt; hook.</source>
          <target state="translated">라우터 수준 &lt;code&gt;didTransition&lt;/code&gt; 후크를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="fd1c5125e97b8ef7401e3054a46c338003dc15f5" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;willTransition&lt;/code&gt; hook.</source>
          <target state="translated">라우터 레벨 &lt;code&gt;willTransition&lt;/code&gt; 훅을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="3afd3167184bdb3baea996bf37e014fc89cdadc8" translate="yes" xml:space="preserve">
          <source>Turn on resolver resolution logging</source>
          <target state="translated">확인자 해결 로깅 설정</target>
        </trans-unit>
        <trans-unit id="171dc559b8c86e4b5f59e4b10965ed25793a055c" translate="yes" xml:space="preserve">
          <source>Tweaking the Default JSON</source>
          <target state="translated">기본 JSON 조정</target>
        </trans-unit>
        <trans-unit id="59ae438323ad843da4c143e3db72fa92cf8f29ed" translate="yes" xml:space="preserve">
          <source>Typical Example:</source>
          <target state="translated">전형적인 예 :</target>
        </trans-unit>
        <trans-unit id="1016393aae80d0b7e8ffa293c223fee10559838d" translate="yes" xml:space="preserve">
          <source>Typically, most models are loaded from and saved to a server that uses a database to store data. Usually you will send JSON representations of models back and forth to an HTTP server that you have written. However, Ember makes it easy to use other durable storage, such as saving to the user's hard disk with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt;, or hosted storage solutions that let you avoid writing and hosting your own servers.</source>
          <target state="translated">일반적으로 대부분의 모델은 데이터베이스를 사용하여 데이터를 저장하는 서버에서로드 및 저장됩니다. 일반적으로 모델의 JSON 표현을 작성한 HTTP 서버로주고받습니다. 그러나 Ember를 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt; 를 사용하여 사용자의 하드 디스크에 저장하거나 자체 서버를 작성하거나 호스팅하지 않아도 되는 호스팅 된 스토리지 솔루션 과 같은 다른 내구성있는 스토리지를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f00d1a5e9139be33f8866b6b8f269ded268029" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;model&lt;/code&gt; hook should return an &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt; record, but it can also return any &lt;a href=&quot;https://www.promisejs.org/&quot;&gt;promise&lt;/a&gt; object (Ember Data records are promises), or a plain JavaScript object or array. Ember will wait until the data finishes loading (until the promise is resolved) before rendering the template.</source>
          <target state="translated">일반적으로 &lt;code&gt;model&lt;/code&gt; 후크는 &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember 데이터&lt;/a&gt; 레코드를 반환해야 하지만 모든 &lt;a href=&quot;https://www.promisejs.org/&quot;&gt;약속&lt;/a&gt; 개체 (Ember 데이터 레코드는 약속) 또는 일반 JavaScript 개체 또는 배열을 반환 할 수도 있습니다 . Ember는 템플릿을 렌더링하기 전에 데이터로드가 완료 될 때까지 (약속이 해결 될 때까지) 기다립니다.</target>
        </trans-unit>
        <trans-unit id="90f6a780943179d8b1aae6e03c66f89fa92e7702" translate="yes" xml:space="preserve">
          <source>Typically, the application object is the only global variable. All other classes in your app should be properties on the &lt;code&gt;Ember.Application&lt;/code&gt; instance, which highlights its first role: a global namespace.</source>
          <target state="translated">일반적으로 응용 프로그램 개체는 유일한 전역 변수입니다. 앱의 다른 모든 클래스는 &lt;code&gt;Ember.Application&lt;/code&gt; 인스턴스의 속성이어야하며 , 첫 번째 역할은 글로벌 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9a9cecfe60e474fbd88d57ddf86af2698a9750c5" translate="yes" xml:space="preserve">
          <source>Typos, missing words, and code samples with errors are all considered documentation bugs. If you spot one of them, or want to otherwise improve the existing guides, we are happy to help you help us!</source>
          <target state="translated">오타, 누락 된 단어 및 오류가있는 코드 샘플은 모두 문서 버그로 간주됩니다. 그 중 하나를 발견하거나 기존 가이드를 개선하려는 경우 도움을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="9d57875196c613785a1eee010c55223a0f1aa821" translate="yes" xml:space="preserve">
          <source>UI</source>
          <target state="translated">UI</target>
        </trans-unit>
        <trans-unit id="56ec268e73f8f2ff103ef53a9916b081ba7f3172" translate="yes" xml:space="preserve">
          <source>UI stands for User Interface and is essentially what the user sees and interacts with on a device. In terms of the web, the UI is generally composed of a series of pages containing visual elements such as buttons and icons that a user can interact with to perform a specific function.</source>
          <target state="translated">UI는 사용자 인터페이스를 나타내며 본질적으로 사용자가 장치에서보고 상호 작용하는 것입니다. 웹과 관련하여 UI는 일반적으로 사용자가 특정 기능을 수행하기 위해 상호 작용할 수있는 버튼 및 아이콘과 같은 시각적 요소를 포함하는 일련의 페이지로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2a78301c31a5cdf1806010201d9c88a248b6e24f" translate="yes" xml:space="preserve">
          <source>URL Conventions</source>
          <target state="translated">URL 규칙</target>
        </trans-unit>
        <trans-unit id="1d0b24ed134011a2aa230bdbb865f186a7f4281a" translate="yes" xml:space="preserve">
          <source>Unbound:</source>
          <target state="translated">Unbound:</target>
        </trans-unit>
        <trans-unit id="adcff83915dac1afac720f25d1f1be8c41ff4bd5" translate="yes" xml:space="preserve">
          <source>Unconsumed Computed Properties Do Not Trigger Observers</source>
          <target state="translated">소비되지 않은 계산 된 속성은 관찰자를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2cf9e638539bf147e1afc2be86aae23bea12dca" translate="yes" xml:space="preserve">
          <source>Unfortunately we don't have control over the Firefox review process, so if you need the latest Inspector version, download and install it manually from &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">안타깝게도 Firefox 검토 프로세스를 제어 할 수 없으므로 최신 검사기 버전이 필요한 경우 &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt; 에서 수동으로 다운로드하여 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cac43b24a13e42d8cce322b40984d5b87556749" translate="yes" xml:space="preserve">
          <source>Unfortunately, the app will now make two separate requests for the same information. Not only is the redundant data fetching costly in terms of wasted bandwidth and affecting the perceived speed of your app, it's easy for the two values to get out-of-sync. You yourself have probably used a web application where the list of items gets out of sync with the counter in a toolbar, leading to a frustrating and inconsistent experience.</source>
          <target state="translated">불행히도 앱은 이제 동일한 정보에 대해 두 개의 별도 요청을합니다. 불필요한 데이터 반입은 대역폭 낭비 및 앱의 인식 속도에 영향을 줄뿐만 아니라 두 값이 동기화되지 않는 것이 쉽습니다. 자신이 항목 목록이 도구 모음의 카운터와 동기화되지 않아서 실망스럽고 일관되지 않은 경험이있는 웹 응용 프로그램을 사용했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="435a0121b4b4da7be6794568d5ff9daf201cc903" translate="yes" xml:space="preserve">
          <source>Unit Testing Basics</source>
          <target state="translated">단위 테스트 기본 사항</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="93ff14f84e553511a6d925afc2fd312d4a69fdf2" translate="yes" xml:space="preserve">
          <source>Unit testing a Service</source>
          <target state="translated">서비스 단위 테스트</target>
        </trans-unit>
        <trans-unit id="e953abafc0e9309d7c5083375c031969ba683421" translate="yes" xml:space="preserve">
          <source>Unit testing controllers is very simple using the unit test helper which is part of the ember-qunit framework.</source>
          <target state="translated">단위 테스트 컨트롤러는 ember-qunit 프레임 워크의 일부인 단위 테스트 도우미를 사용하면 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4f2e8408bfaa4887c87ced8532981f549a2f0ac1" translate="yes" xml:space="preserve">
          <source>Unit tests are generally used to test a small piece of code and ensure that it is doing what was intended. Unlike acceptance tests, they are narrow in scope and do not require the Ember application to be running.</source>
          <target state="translated">단위 테스트는 일반적으로 작은 코드를 테스트하고 의도 한대로 작동하는지 확인하는 데 사용됩니다. 승인 테스트와 달리 범위는 좁으며 Ember 응용 프로그램을 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb68db7729e7a12b83a5c5895b39431e1671922d" translate="yes" xml:space="preserve">
          <source>Unit tests are used to test isolated chunks of functionality, or &quot;units&quot;. They can be written against any isolated application logic.</source>
          <target state="translated">단위 테스트는 분리 된 기능 덩어리 또는 &quot;단위&quot;를 테스트하는 데 사용됩니다. 격리 된 응용 프로그램 논리에 대해 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17909e26819874f7405577d82491e99531963e55" translate="yes" xml:space="preserve">
          <source>Unit tests use the function called &lt;code&gt;this.subject&lt;/code&gt; to instantiate the object to test, and lets the test pass in initial values as arguments. In our case we are passing in our fake map utility object in the first test, and passing a cache object for the second test.</source>
          <target state="translated">단위 테스트는 &lt;code&gt;this.subject&lt;/code&gt; 라는 함수를 사용하여 테스트 할 객체를 인스턴스화하고 테스트가 초기 값을 인수로 전달하도록합니다. 우리의 경우 첫 번째 테스트에서 가짜 맵 유틸리티 개체를 전달하고 두 번째 테스트를 위해 캐시 개체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="699a683faaa9485bee8084684b0d1eae07aa0ba1" translate="yes" xml:space="preserve">
          <source>Unknown Properties</source>
          <target state="translated">알 수없는 속성</target>
        </trans-unit>
        <trans-unit id="e645e94764f04f4c7f3e561913a7d9a2e676183b" translate="yes" xml:space="preserve">
          <source>Unless you have specific needs for &lt;code&gt;CoreView&lt;/code&gt;, you will use &lt;code&gt;Ember.Component&lt;/code&gt; in your applications.</source>
          <target state="translated">&lt;code&gt;CoreView&lt;/code&gt; 에 대한 특정 요구가 없으면 응용 프로그램에서 &lt;code&gt;Ember.Component&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="f1dc9a4536b97fe5b5d22858d040db7f2f7b9e35" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt;, which require a dash in the name to follow the Custom Element spec, helper names can be single or multi-word. If your helper's name is multi-word, it should be dasherized as the examples on this page.</source>
          <target state="translated">사용자 정의 요소 스펙을 따르기 위해 이름에 대시가 필요한 &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt; 와 달리 도우미 이름은 단일 단어 또는 여러 단어 일 수 있습니다. 도우미 이름이 여러 단어 인 경우이 페이지의 예와 같이 대시 형식으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ba71c17b8be5769afabb31b692ab4883feaae70" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.Enumerable,&lt;/code&gt; this mixin defines methods specifically for collections that provide index-ordered access to their contents. When you are designing code that needs to accept any kind of Array-like object, you should use these methods instead of Array primitives because these will properly notify observers of changes to the array.</source>
          <target state="translated">&lt;code&gt;Ember.Enumerable,&lt;/code&gt; 과 달리 , 이 믹스 인은 컨텐츠에 인덱스 순서로 액세스 할 수있는 콜렉션에 대한 메소드를 정의합니다. 모든 종류의 Array와 같은 객체를 수용해야하는 코드를 디자인 할 때는 Array 프리미티브 대신 이러한 메소드를 사용해야합니다.이 메소드는 관찰자에게 어레이의 변경 사항을 올바르게 알리기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c2346a7015c8d7f54cbe428fcb6f3328b3d12eff" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.typeOf&lt;/code&gt; this method returns true even if the passed object is not formally an array but appears to be array-like (i.e. implements &lt;code&gt;Ember.Array&lt;/code&gt;)</source>
          <target state="translated">달리 &lt;code&gt;Ember.typeOf&lt;/code&gt; 전달 된 객체가 공식적으로 배열이 아니라 나타나는 경우이 메소드는 true를 반환 심지어는 배열처럼되고 (즉, 구현 &lt;code&gt;Ember.Array&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="48f1b9ff4d1a0458244d8e86c4b05ccfa10f68f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RSVP.all&lt;/code&gt; or &lt;code&gt;RSVP.hash&lt;/code&gt;, which implement a fail-fast method, but like &lt;code&gt;RSVP.allSettled&lt;/code&gt;, &lt;code&gt;hashSettled&lt;/code&gt; waits until all the constituent promises have returned and then shows you all the results with their states and values/reasons. This is useful if you want to handle multiple promises' failure states together as a set.</source>
          <target state="translated">달리 &lt;code&gt;RSVP.all&lt;/code&gt; 또는 &lt;code&gt;RSVP.hash&lt;/code&gt; , 페일 빠른 방법을 구현하지만, 같은 &lt;code&gt;RSVP.allSettled&lt;/code&gt; , &lt;code&gt;hashSettled&lt;/code&gt; 다음 쇼 당신에게 자신의 상태와 가치 / 이유 모든 결과를 모든 구성 약속이 반환 될 때까지 대기합니다. 여러 약속의 실패 상태를 집합으로 함께 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9bee6d6d59812dc43ec15a1949e4a9aea2e5d664" translate="yes" xml:space="preserve">
          <source>Unlike callbacks, promises are great composable primitives.</source>
          <target state="translated">콜백과 달리 약속은 훌륭한 컴포저 블 프리미티브입니다.</target>
        </trans-unit>
        <trans-unit id="e43318987c768f8fb9f16d1a9218b08aab2bb57f" translate="yes" xml:space="preserve">
          <source>Unlike most other frameworks that include some sort of binding implementation, bindings in Ember.js can be used with any object. That said, bindings are most often used within the Ember framework itself, and for most problems Ember app developers face, computed properties are the appropriate solution.</source>
          <target state="translated">바인딩 구현이 포함 된 대부분의 다른 프레임 워크와 달리 Ember.js의 바인딩은 모든 객체와 함께 사용할 수 있습니다. 즉, 바인딩은 Ember 프레임 워크 자체 내에서 가장 자주 사용되며, Ember 앱 개발자들이 직면하는 대부분의 문제에 대해 계산 된 속성이 적절한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="17e1fed215e92f510045ef5c63c8abbeeddb605f" translate="yes" xml:space="preserve">
          <source>Unlike the other route handlers we've made so far, the &lt;code&gt;index&lt;/code&gt; route is special: it does NOT require an entry in the router's mapping. We'll learn more about why the entry isn't required later on when we look at &lt;a href=&quot;../subroutes&quot;&gt;nested routes&lt;/a&gt; in Ember.</source>
          <target state="translated">지금까지 만든 다른 경로 처리기와 달리 &lt;code&gt;index&lt;/code&gt; 경로는 특별합니다. 라우터 매핑에 항목을 입력 할 필요가 없습니다. 나중에 Ember 에서 &lt;a href=&quot;../subroutes&quot;&gt;중첩 된 경로&lt;/a&gt; 를 볼 때 입력이 필요하지 않은 이유에 대해 자세히 알아볼 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0a31d24114be4656ec50e863002c0179157848ce" translate="yes" xml:space="preserve">
          <source>Unloads the record from the store. This will cause the record to be destroyed and freed up for garbage collection.</source>
          <target state="translated">상점에서 레코드를 언로드합니다. 이로 인해 레코드가 삭제되고 가비지 수집을 위해 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="43070cef7aeb427607d411dd1ba9004d00927bf7" translate="yes" xml:space="preserve">
          <source>Unregister a factory.</source>
          <target state="translated">공장 등록을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="4f9491f2acb9ac489a58e64c4620334de6474d19" translate="yes" xml:space="preserve">
          <source>Unshift an object to start of array. Works just like &lt;code&gt;unshift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">배열의 시작을 위해 개체의 이동을 해제하십시오. &lt;code&gt;unshift()&lt;/code&gt; 처럼 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="164f698a644916b960657c8f2ff6769690a513d0" translate="yes" xml:space="preserve">
          <source>Up to this point, we've generated four top level routes.</source>
          <target state="translated">지금까지 4 개의 최상위 경로를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="1cfa49d59018eef26ef97632e877b7882570010a" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;postRecord.save()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;postRecord.save()&lt;/code&gt; 업데이트</target>
        </trans-unit>
        <trans-unit id="ac2e17800a0ab0d112375860107fae65bea51067" translate="yes" xml:space="preserve">
          <source>Update URL with &lt;code&gt;replaceState&lt;/code&gt; instead</source>
          <target state="translated">대신 &lt;code&gt;replaceState&lt;/code&gt; 로 URL 업데이트</target>
        </trans-unit>
        <trans-unit id="f40768a6e2c45ddd1db6d9752d413302ad8b03c7" translate="yes" xml:space="preserve">
          <source>Update the content of the integration test to the following to fix it:</source>
          <target state="translated">통합 테스트의 컨텐츠를 다음으로 업데이트하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="af48d19b99946eb85b1c250ae52baaf10a9733dd" translate="yes" xml:space="preserve">
          <source>Updates to the property of an attribute binding will result in automatic update of the HTML attribute in the component's rendered HTML representation. &lt;code&gt;attributeBindings&lt;/code&gt; is a concatenated property. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">속성 바인딩의 속성을 업데이트하면 구성 요소의 렌더링 된 HTML 표현에서 HTML 속성이 자동으로 업데이트됩니다. &lt;code&gt;attributeBindings&lt;/code&gt; 는 연결된 속성입니다. 연결된 속성에 대한 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85553080c5bd51708efff543f11a80f132dd3bad" translate="yes" xml:space="preserve">
          <source>Updates to the value of a class name binding will result in automatic update of the HTML &lt;code&gt;class&lt;/code&gt; attribute in the component's rendered HTML representation. If the value becomes &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the class name will be removed. Both &lt;code&gt;classNames&lt;/code&gt; and &lt;code&gt;classNameBindings&lt;/code&gt; are concatenated properties. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">클래스 이름 바인딩 값을 업데이트 하면 구성 요소의 렌더링 된 HTML 표현에서 HTML &lt;code&gt;class&lt;/code&gt; 특성이 자동으로 업데이트됩니다 . 값이 &lt;code&gt;false&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 않으면 클래스 이름이 제거됩니다. 두 &lt;code&gt;classNames&lt;/code&gt; 과 &lt;code&gt;classNameBindings&lt;/code&gt; 은 연결된 속성입니다. 연결된 속성에 대한 자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a89fee8955539e6cbec654a32c63f6e50462e63" translate="yes" xml:space="preserve">
          <source>Updating Existing Records</source>
          <target state="translated">기존 레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="e5b09343b2238bb74ea50d37eff3231b6eb0978f" translate="yes" xml:space="preserve">
          <source>Updating Records</source>
          <target state="translated">레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="a3c251798976c1a4eaea1b25759d885d99218eb3" translate="yes" xml:space="preserve">
          <source>Updating the Model Hook</source>
          <target state="translated">모델 후크 업데이트</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="5babfd7f28c97261be5d747a98ff927af4a35448" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt; to get the JSON representation of a record.</source>
          <target state="translated">&lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt; 를 사용 하여 레코드의 JSON 표현을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="79babe4a58b3c5377a30d47b99f3a166cc374c1c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;store.findAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type:</source>
          <target state="translated">주어진 유형에 대한 모든 레코드를 검색 하려면 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;store.findAll()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eeddfe464eb2a59d11d65139e6a152e23204fe3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;store.findRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID. This will return a promise that fulfills with the requested record:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;store.findRecord()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 유형 및 ID별로 레코드를 검색하십시오. 요청 된 레코드를 충족시키는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdebe1f775b156e00e0b7192c360b92d672f22ea" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt;&lt;code&gt;store.peekAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type that are already loaded into the store, without making a network request:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt; &lt;code&gt;store.peekAll()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 네트워크 요청없이 상점에 이미로드 된 지정된 유형의 모든 레코드를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="b6be3a24df2cc3843f7fe4f0b083c1f949820c19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt;&lt;code&gt;store.peekRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID, without making a network request. This will return the record only if it is already present in the store:</source>
          <target state="translated">네트워크 요청없이 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt; &lt;code&gt;store.peekRecord()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 유형 및 ID별로 레코드를 검색하십시오. 상점에 이미 존재하는 경우에만 레코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="00e000124add0ce9217af1c895a1ba1b021e403c" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded author</source>
          <target state="translated">게시 모델에 사용자 지정 (유형) 직렬 변환기를 사용하여 포함 된 작성자 구성</target>
        </trans-unit>
        <trans-unit id="2822b36d55ca0f281fdd5caf6ce712c478b4c480" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded comments</source>
          <target state="translated">포스트 모델에 사용자 정의 (유형) 직렬 변환기를 사용하여 포함 된 주석을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="18a2f23148493346b4dfeba036baa75787a6bab3" translate="yes" xml:space="preserve">
          <source>Use of Observable Methods and Properties</source>
          <target state="translated">관찰 가능한 방법 및 속성 사용</target>
        </trans-unit>
        <trans-unit id="97fdbc8ed53b640b746052deb57d44ffe6c429d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{hash}}&lt;/code&gt; helper to create a hash to pass as an option to your components. This is specially useful for contextual components where you can just yield a hash:</source>
          <target state="translated">사용 &lt;code&gt;{{hash}}&lt;/code&gt; 컴포넌트에 옵션으로 전달하는 해시를 생성하는 도우미. 해시를 생성 할 수있는 상황에 맞는 구성 요소에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e7ccd90e8cfeff420ef08923c36a50e99640cd2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{with}}&lt;/code&gt; helper when you want to alias a property to a new name. This is helpful for semantic clarity as it allows you to retain default scope or to reference a property from another &lt;code&gt;{{with}}&lt;/code&gt; block.</source>
          <target state="translated">속성을 새 이름으로 별칭 지정 하려면 &lt;code&gt;{{with}}&lt;/code&gt; 도우미를 사용하십시오 . 기본 범위를 유지하거나 다른 &lt;code&gt;{{with}}&lt;/code&gt; 블록 에서 속성을 참조 할 수 있으므로 의미를 명확하게하는 데 도움이 됩니다.</target>
        </trans-unit>
        <trans-unit id="b101cb1e03e8a43550840a8c7fd20af20f00b55b" translate="yes" xml:space="preserve">
          <source>Use the tips described in &lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt; to inspect models and controllers. See below for templates and components.</source>
          <target state="translated">&lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 에 설명 된 팁을 사용하여 모델 및 컨트롤러를 검사하십시오. 템플릿 및 구성 요소는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7830b0609b9584de5bbebc9de314d759ef55371b" translate="yes" xml:space="preserve">
          <source>Use this instead of the built-in &lt;code&gt;typeof&lt;/code&gt; to get the type of an item. It will return the same result across all browsers and includes a bit more detail. Here is what will be returned:</source>
          <target state="translated">기본 제공 &lt;code&gt;typeof&lt;/code&gt; 대신 이것을 사용 하여 항목 유형을 가져옵니다. 모든 브라우저에서 동일한 결과를 반환하며 조금 더 자세하게 포함되어 있습니다. 반환되는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c645581e547e78cc873442313071c5e0586bcb0f" translate="yes" xml:space="preserve">
          <source>Use this to defer readiness until some condition is true.</source>
          <target state="translated">일부 조건이 충족 될 때까지 준비 상태를 연기하려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="306cbcab821af23dfb473fbf6d987c353799e01a" translate="yes" xml:space="preserve">
          <source>Use with Ember.Component</source>
          <target state="translated">Ember.Component와 함께 사용</target>
        </trans-unit>
        <trans-unit id="542d6ad86b7eee775bf26a301d712477fe03a84b" translate="yes" xml:space="preserve">
          <source>Used this way, the &lt;code&gt;{{action}}&lt;/code&gt; helper provides a useful shortcut for registering an HTML element in a template for a single DOM event and forwarding that interaction to the template's context (controller or component). If the context of a template is a controller, actions used this way will bubble to routes when the controller does not implement the specified action. Once an action hits a route, it will bubble through the route hierarchy.</source>
          <target state="translated">이러한 방식으로 사용되는 &lt;code&gt;{{action}}&lt;/code&gt; 도우미는 단일 DOM 이벤트의 템플리트에 HTML 요소를 등록하고 해당 상호 작용을 템플리트의 컨텍스트 (컨트롤러 또는 컴포넌트)로 전달하는 데 유용한 단축키를 제공합니다. 템플릿의 컨텍스트가 컨트롤러 인 경우 컨트롤러가 지정된 작업을 구현하지 않으면이 방법으로 사용 된 작업이 라우팅됩니다. 액션이 라우트에 도달하면 라우트 계층을 통해 버블 링됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7c0d10b10d1e9407fe7fd091a42e7426902b37" translate="yes" xml:space="preserve">
          <source>Used to allow ember-testing to communicate with a specific testing framework.</source>
          <target state="translated">엠버 테스트가 특정 테스트 프레임 워크와 통신하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2522c403a71c0acbdd066953587aaea739ffa591" translate="yes" xml:space="preserve">
          <source>Used to determine when this &lt;code&gt;LinkComponent&lt;/code&gt; is active.</source>
          <target state="translated">이 &lt;code&gt;LinkComponent&lt;/code&gt; 가 활성화 된 시기를 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e06eb9fc01574fd7225f291066780d472903fee4" translate="yes" xml:space="preserve">
          <source>Used to get the latest version of all of the records in this array from the adapter.</source>
          <target state="translated">이 어레이에있는 모든 레코드의 최신 버전을 어댑터에서 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b625a63d0e499059d2ca14c82e5df7615a107612" translate="yes" xml:space="preserve">
          <source>Used to register callbacks to be fired whenever &lt;code&gt;App.injectTestHelpers&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;App.injectTestHelpers&lt;/code&gt; 가 호출 될 때마다 발생하는 콜백을 등록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb7f2badb8e4d94f6c7118903ad2f323f4cc77e3" translate="yes" xml:space="preserve">
          <source>User/session authentication.</source>
          <target state="translated">사용자 / 세션 인증.</target>
        </trans-unit>
        <trans-unit id="16bc4c4d7d89c3b988308786cd8619cfd3a339a8" translate="yes" xml:space="preserve">
          <source>Uses:</source>
          <target state="translated">Uses:</target>
        </trans-unit>
        <trans-unit id="9b8970c914983383f99e53ae30acfba6c7f27456" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HashLocation&lt;/code&gt; results in URLs with a &lt;code&gt;#&lt;/code&gt; (hash sign) separating the server side URL portion of the URL from the portion that is used by Ember.</source>
          <target state="translated">&lt;code&gt;HashLocation&lt;/code&gt; 을 사용하면 URL 의 서버 측 URL 부분과 Ember에서 사용하는 부분을 분리 하는 &lt;code&gt;#&lt;/code&gt; (해시 기호)가있는 URL이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e374626d7a0702cc9f9268ad2fdcfaaf4d3ebb8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HistoryLocation&lt;/code&gt; results in URLs that are indistinguishable from a standard URL. This relies upon the browser's &lt;code&gt;history&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;HistoryLocation&lt;/code&gt; 을 사용 하면 표준 URL과 구별 할 수없는 URL이 생성됩니다. 이것은 브라우저의 &lt;code&gt;history&lt;/code&gt; API에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="b274154b8cd2e420cefe87ab03d519a29e9efd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;NoneLocation&lt;/code&gt; causes Ember to not store the applications URL state in the actual URL. This is generally used for testing purposes, and is one of the changes made when calling &lt;code&gt;App.setupForTesting()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NoneLocation&lt;/code&gt; 을 사용 하면 Ember가 애플리케이션 URL 상태를 실제 URL에 저장하지 않습니다. 이것은 일반적으로 테스트 목적으로 사용되며 &lt;code&gt;App.setupForTesting()&lt;/code&gt; 호출 할 때 변경되는 것 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="60d8d1f0299627d742dc7cc43fee81d677009b4e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;denodeify&lt;/code&gt; makes it easier to compose asynchronous operations instead of using callbacks. For example, instead of:</source>
          <target state="translated">사용 &lt;code&gt;denodeify&lt;/code&gt; 은 쉽게 대신 콜백을 사용하는 비동기 작업을 구성 할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="f5822b7870a8d5523c5615715941fb03bf4b2289" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;get()&lt;/code&gt; 과 &lt;code&gt;set()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8109d0339990f1783cd0634fdca5b574393894cb" translate="yes" xml:space="preserve">
          <source>Using Block Params</source>
          <target state="translated">블록 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="74f837326f24cf10cc05302b64d55360b8652855" translate="yes" xml:space="preserve">
          <source>Using BuildURLMixin</source>
          <target state="translated">BuildURLMixin 사용</target>
        </trans-unit>
        <trans-unit id="e8517af265fabf196c410cce740af7a7b6bec59d" translate="yes" xml:space="preserve">
          <source>Using Embedded Records</source>
          <target state="translated">내장 레코드 사용</target>
        </trans-unit>
        <trans-unit id="165fcfc43ecaff89929b038e0b256dd0b70e6794" translate="yes" xml:space="preserve">
          <source>Using Ember Data</source>
          <target state="translated">Ember 데이터 사용</target>
        </trans-unit>
        <trans-unit id="fb2881f07ad66266580a01fb816b0dce10a1a576" translate="yes" xml:space="preserve">
          <source>Using Ember Enumeration with Other Libraries</source>
          <target state="translated">다른 라이브러리와 함께 Ember 열거 형 사용</target>
        </trans-unit>
        <trans-unit id="32288de7b5b629b3ca02d918cfe820a4ecaf3608" translate="yes" xml:space="preserve">
          <source>Using Ember helpers</source>
          <target state="translated">Ember 헬퍼 사용하기</target>
        </trans-unit>
        <trans-unit id="ca7a4602a2a74d46f96031f6b4efa287c3f5c2c8" translate="yes" xml:space="preserve">
          <source>Using a helper to get a property dynamically</source>
          <target state="translated">도우미를 사용하여 속성을 동적으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="9059eac12c500c79a5a3d1134418440b0c07e282" translate="yes" xml:space="preserve">
          <source>Using a string instead of an array allows for an arbitrary number of parameters:</source>
          <target state="translated">배열 대신 문자열을 사용하면 임의의 수의 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7f18de2a8e24c22728aa51e8b3f677f7daf728" translate="yes" xml:space="preserve">
          <source>Using an Application Instance Within an Instance Initializer</source>
          <target state="translated">인스턴스 이니셜 라이저 내에서 애플리케이션 인스턴스 사용</target>
        </trans-unit>
        <trans-unit id="34b9681fe55a7ecfb5a0c7ea34a9b1845ae5fc03" translate="yes" xml:space="preserve">
          <source>Using an identity map is important because it ensures that changes you make in one part of your UI are propagated to other parts of the UI. It also means that you don't have to manually keep records in sync&amp;mdash;you can ask for a record by ID and not have to worry about whether other parts of your application have already asked for and loaded it.</source>
          <target state="translated">아이디 맵을 사용하는 것은 UI의 한 부분에서 변경 한 내용이 UI의 다른 부분으로 전파되도록하기 때문에 중요합니다. 또한 수동으로 레코드를 동기화 할 필요가 없음을 의미합니다. ID별로 레코드를 요청할 수 있으며 응용 프로그램의 다른 부분에서 이미 요청하고로드했는지에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fad29eae11c2c19b66190933f6cc057fc210083" translate="yes" xml:space="preserve">
          <source>Using jQuery to simulate user click events might lead to unexpected test results as the action can potentially be called twice.</source>
          <target state="translated">jQuery를 사용하여 사용자 클릭 이벤트를 시뮬레이션하면 조치가 두 번 호출 될 수 있으므로 예상치 않은 테스트 결과가 발생할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
