<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="dd53739e37c74c8b6af3c2762424c20a33a7a208" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;format-currency&lt;/code&gt; helper that takes an integer count of cents and turns it into formatted dollars.</source>
          <target state="translated">정수 센트를 가져 와서 서식이 지정된 달러로 변환 하는 &lt;code&gt;format-currency&lt;/code&gt; 도우미를 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="4b2703dcd1f2ced6d41299af63d335c82cc175ac" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;people-list&lt;/code&gt; component that we can use in multiple places to show a list of people.</source>
          <target state="translated">여러 장소에서 사람 목록을 표시하는 데 사용할 수 있는 &lt;code&gt;people-list&lt;/code&gt; 구성 요소를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="50681b0bf964a4527a84e6e7e538f4ce2d598997" translate="yes" xml:space="preserve">
          <source>Let's create the &lt;code&gt;toggleImageSize&lt;/code&gt; function and toggle the &lt;code&gt;isWide&lt;/code&gt; property on our component:</source>
          <target state="translated">&lt;code&gt;toggleImageSize&lt;/code&gt; 함수를 만들고 컴포넌트 에서 &lt;code&gt;isWide&lt;/code&gt; 속성을 토글 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="7b5c19d97e452ebeedb9123f50a533fb95f01188" translate="yes" xml:space="preserve">
          <source>Let's customize the &lt;code&gt;shopping-cart&lt;/code&gt; initializer to inject a &lt;code&gt;cart&lt;/code&gt; property into all the routes in your application:</source>
          <target state="translated">&lt;code&gt;shopping-cart&lt;/code&gt; 초기화 프로그램을 사용자 정의 하여 애플리케이션의 모든 경로에 &lt;code&gt;cart&lt;/code&gt; 특성 을 삽입 하십시오.</target>
        </trans-unit>
        <trans-unit id="e4575ed0bbc0fbaa9b5b0685f53318a958fa4b64" translate="yes" xml:space="preserve">
          <source>Let's define the structure of a rental object using the same attributes for our rental that we &lt;a href=&quot;../model-hook&quot;&gt;previously used&lt;/a&gt; in our hard-coded array of JavaScript objects - &lt;em&gt;title&lt;/em&gt;, &lt;em&gt;owner&lt;/em&gt;, &lt;em&gt;city&lt;/em&gt;, &lt;em&gt;property type&lt;/em&gt;, &lt;em&gt;image&lt;/em&gt;, &lt;em&gt;bedrooms&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt;. Define attributes by giving them the result of the function &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt;&lt;code&gt;DS.attr()&lt;/code&gt;&lt;/a&gt;. For more information on Ember Data Attributes, read the section called &lt;a href=&quot;https://guides.emberjs.com/models/defining-models/#toc_defining-attributes&quot;&gt;Defining Attributes&lt;/a&gt; in the guides.</source>
          <target state="translated">&lt;a href=&quot;../model-hook&quot;&gt;이전&lt;/a&gt; 에 하드 코딩 된 JavaScript 객체 배열 ( &lt;em&gt;제목&lt;/em&gt; , &lt;em&gt;소유자&lt;/em&gt; , &lt;em&gt;도시&lt;/em&gt; , &lt;em&gt;부동산 유형&lt;/em&gt; , &lt;em&gt;이미지&lt;/em&gt; , &lt;em&gt;침실&lt;/em&gt; 및 &lt;em&gt;설명)&lt;/em&gt; 에서 사용한 것과 동일한 속성을 사용하여 임대 객체의 구조를 정의 해 보겠습니다 . &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt; &lt;code&gt;DS.attr()&lt;/code&gt; &lt;/a&gt; 함수의 결과를 제공하여 속성을 정의하십시오 . Ember 데이터 속성에 대한 자세한 내용 은 가이드에서 &lt;a href=&quot;https://guides.emberjs.com/models/defining-models/#toc_defining-attributes&quot;&gt;속성 정의&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b2774cf0be3cfdf91e6720844b3fc03268684b" translate="yes" xml:space="preserve">
          <source>Let's explore these concepts using an example of a route displaying a blog post. Presume a &lt;code&gt;BlogPost&lt;/code&gt; model that is presented in a &lt;code&gt;blog-post&lt;/code&gt; template.</source>
          <target state="translated">블로그 게시물을 표시하는 경로의 예를 사용하여 이러한 개념을 살펴 보겠습니다. &lt;code&gt;blog-post&lt;/code&gt; 템플리트로 제공되는 블로그 &lt;code&gt;BlogPost&lt;/code&gt; 모델을 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="26db41f1383be1d219153569142445a93005ef0d" translate="yes" xml:space="preserve">
          <source>Let's generate a &lt;code&gt;rental-listing&lt;/code&gt; component that will manage the behavior for each of our rentals. A dash is required in every component name to avoid conflicting with a possible HTML element, so &lt;code&gt;rental-listing&lt;/code&gt; is acceptable but &lt;code&gt;rental&lt;/code&gt; isn't.</source>
          <target state="translated">각 임대의 행동을 관리 할 &lt;code&gt;rental-listing&lt;/code&gt; 구성 요소를 생성 해 봅시다 . 가능한 HTML 요소와 충돌을 피하기 위해 모든 구성 요소 이름에 대시가 필요하므로 &lt;code&gt;rental-listing&lt;/code&gt; 은 허용되지만 &lt;code&gt;rental&lt;/code&gt; 는 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e94e8c5fcbcdfe2fafa8482c52537ded890590a" translate="yes" xml:space="preserve">
          <source>Let's get started creating our service by generating it through Ember CLI, which will create the service file, as well as a unit test for it.</source>
          <target state="translated">Ember CLI를 통해 서비스를 생성하여 서비스 생성을 시작하겠습니다. 서비스 파일 및 서비스 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="59c42fa1c4186808938dbdaa530634247e143009" translate="yes" xml:space="preserve">
          <source>Let's implement &lt;code&gt;double-clickable&lt;/code&gt; such that when it is clicked, an alert is displayed:</source>
          <target state="translated">&lt;code&gt;double-clickable&lt;/code&gt; 할 때 경고가 표시되도록 더블 클릭 가능을 구현합시다 :</target>
        </trans-unit>
        <trans-unit id="80eba8bfca1ed78a5a3f72b4b1cdba111f9f76a2" translate="yes" xml:space="preserve">
          <source>Let's initialize our date picker by overriding the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; &lt;/a&gt; 메서드를 재정 의하여 날짜 선택기를 초기화 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="dfd8f43342f0e8e597ce5606445945b700d097d0" translate="yes" xml:space="preserve">
          <source>Let's look at a similar example that is optimized in Ember, starting with a &lt;code&gt;User&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 객체로 시작하여 Ember에서 최적화 된 유사한 예제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5fffb3b327aecf1a41680d27190812818f0ca4fd" translate="yes" xml:space="preserve">
          <source>Let's look at a simple example of how a component can use an action to communicate with its parent.</source>
          <target state="translated">구성 요소가 동작을 사용하여 부모와 통신하는 방법에 대한 간단한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f75a786fdb113fbc8a0687ed269e046e9fa4fe3b" translate="yes" xml:space="preserve">
          <source>Let's look at the parent component's JavaScript file. In this example, imagine we have a parent component called &lt;code&gt;user-profile&lt;/code&gt; that shows the user's profile to them.</source>
          <target state="translated">부모 컴포넌트의 JavaScript 파일을 봅시다. 이 예에서는 &lt;code&gt;user-profile&lt;/code&gt; 을 보여주는 user-profile 이라는 부모 구성 요소가 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="1b66cbb003165185944800edb660d32eca31d034" translate="yes" xml:space="preserve">
          <source>Let's look at what happens if you request a record that the store already has in its cache.</source>
          <target state="translated">상점이 이미 캐시에 가지고있는 레코드를 요청하면 어떻게되는지 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="590b9c6d802434b51a5191db38e2d406a9e971ad" translate="yes" xml:space="preserve">
          <source>Let's make sure everything is working properly. &lt;code&gt;cd&lt;/code&gt; into the application directory &lt;code&gt;ember-quickstart&lt;/code&gt; and start the development server by typing:</source>
          <target state="translated">모든 것이 제대로 작동하는지 확인하십시오. 응용 프로그램 디렉토리 &lt;code&gt;ember-quickstart&lt;/code&gt; 로 &lt;code&gt;cd&lt;/code&gt; 하고 다음 을 입력하여 개발 서버를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="aab21dd37a2f939f20050faef347b0ec430a0362" translate="yes" xml:space="preserve">
          <source>Let's now implement the helper. Helpers are functions that take one or more inputs and return a single output that should be put into the HTML.</source>
          <target state="translated">이제 헬퍼를 구현해 봅시다. 헬퍼는 하나 이상의 입력을 받아 HTML에 넣어야하는 단일 출력을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f6b204ac311c4ee4a0d190f78f5606bfd6113ee7" translate="yes" xml:space="preserve">
          <source>Let's open &lt;code&gt;app/routes/rentals.js&lt;/code&gt; and return an array of rental objects from the &lt;code&gt;model&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;app/routes/rentals.js&lt;/code&gt; 를 열고 &lt;code&gt;model&lt;/code&gt; 함수 에서 대여 객체 배열을 반환 합니다 :</target>
        </trans-unit>
        <trans-unit id="d86ec598cd6b2af3f7fafff3f4e673d6c0cecb5b" translate="yes" xml:space="preserve">
          <source>Let's say we wanted to add a feature that would allow the user to toggle the display of the body section. To implement this, we would first modify our template to show the body only if the value of a new &lt;code&gt;isExpanded&lt;/code&gt; property is true.</source>
          <target state="translated">사용자가 본문 섹션의 표시를 전환 할 수있는 기능을 추가하려고한다고 가정 해 보겠습니다. 이를 구현하기 위해 먼저 새로운 &lt;code&gt;isExpanded&lt;/code&gt; 속성 값 이 true 인 경우에만 본문을 표시하도록 템플릿을 수정 합니다.</target>
        </trans-unit>
        <trans-unit id="18b2e4d7e3967cf6832dddd4b5cc115648948c9c" translate="yes" xml:space="preserve">
          <source>Let's see these core concepts in action by building a property rental application in the next lesson.</source>
          <target state="translated">다음 레슨에서 부동산 임대 애플리케이션을 구축하여 이러한 핵심 개념이 실제로 적용되는 것을 보도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f9bb85bb04d6e37a3d55dd2f9946f3e2bc2fae4c" translate="yes" xml:space="preserve">
          <source>Let's start by adding a &lt;code&gt;div&lt;/code&gt; element to the component template. This &lt;code&gt;div&lt;/code&gt; will act as a place for the 3rd party map API to render the map to.</source>
          <target state="translated">컴포넌트 템플릿에 &lt;code&gt;div&lt;/code&gt; 요소를 추가하여 시작하겠습니다 . 이 &lt;code&gt;div&lt;/code&gt; 는 타사지도 API가지도를 렌더링하는 장소 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="56d73e58f7a22994e9e7d10b8e3ff51f512b440e" translate="yes" xml:space="preserve">
          <source>Let's start by building our &quot;about&quot; page.</source>
          <target state="translated">&quot;정보&quot;페이지를 만들어 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0fb162b35ef315066c948b1304b9311aee16c4db" translate="yes" xml:space="preserve">
          <source>Let's start by creating an object that has a &lt;code&gt;computedFoo&lt;/code&gt; computed property based on a &lt;code&gt;foo&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 속성을 기반으로 &lt;code&gt;computedFoo&lt;/code&gt; 계산 속성 이있는 객체를 만들어 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="ff7832d81c62993788fb20c37421c44bad0995e9" translate="yes" xml:space="preserve">
          <source>Let's start by looking at the changes to our Router (&lt;code&gt;app/router.js&lt;/code&gt;).</source>
          <target state="translated">라우터의 변경 사항 ( &lt;code&gt;app/router.js&lt;/code&gt; )을 살펴 보도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c2aa48423894ccede7d5d25c64e916771df1a170" translate="yes" xml:space="preserve">
          <source>Let's start by testing the helper by showing a simple unit test and then move on to testing with integration tests afterwards.</source>
          <target state="translated">간단한 단위 테스트를 표시하여 도우미 테스트부터 시작한 다음 통합 테스트를 사용한 테스트로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="565635cdbaba1baa8ed4a8401c8fea01e1ad7667" translate="yes" xml:space="preserve">
          <source>Let's take a look at the folders and files Ember CLI generates.</source>
          <target state="translated">Ember CLI가 생성하는 폴더와 파일을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e1a879debe45fb25e88e56e0a9a4d2687e8b6e70" translate="yes" xml:space="preserve">
          <source>Let's take it step by step.</source>
          <target state="translated">단계별로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="043c80933b2a6a5bd8843f4d18a90fa90152c0fc" translate="yes" xml:space="preserve">
          <source>Let's update our &lt;code&gt;rental-listing&lt;/code&gt; component template to use our new helper and pass in &lt;code&gt;rental.propertyType&lt;/code&gt;:</source>
          <target state="translated">하자 갱신 우리의 &lt;code&gt;rental-listing&lt;/code&gt; 에 우리의 새로운 도우미를 사용하여 전달하는 구성 요소 템플릿 &lt;code&gt;rental.propertyType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="606a02e2fcda6a8a8667006df471f3c99bd32864" translate="yes" xml:space="preserve">
          <source>Let's update the default test to contain the scenarios we want to verify:</source>
          <target state="translated">확인하려는 시나리오를 포함하도록 기본 테스트를 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="670783028da291a6a49d5996e531bc96807e06e5" translate="yes" xml:space="preserve">
          <source>Let's use Ember's route generator to start our &lt;code&gt;about&lt;/code&gt; route.</source>
          <target state="translated">하자의 사용 엠버의 경로 생성기는 우리의 시작 &lt;code&gt;about&lt;/code&gt; 경로를.</target>
        </trans-unit>
        <trans-unit id="1c89369985b54e2bd39755237a790278e410475d" translate="yes" xml:space="preserve">
          <source>Let's use the &lt;code&gt;{{if}}&lt;/code&gt; helper to show our current rental image larger only when &lt;code&gt;isWide&lt;/code&gt; is set to true, by setting the element class name to &lt;code&gt;wide&lt;/code&gt;. We'll also add some text to indicate that the image can be clicked on, and wrap both with an anchor element, giving it the &lt;code&gt;image&lt;/code&gt; class name so that our test can find it.</source>
          <target state="translated">요소 클래스 이름을 &lt;code&gt;wide&lt;/code&gt; 로 설정하여 &lt;code&gt;isWide&lt;/code&gt; 가 true로 설정된 경우에만 &lt;code&gt;{{if}}&lt;/code&gt; 도우미를 사용하여 현재 대여 이미지를 더 크게 표시해 보겠습니다 . 또한 이미지를 클릭 할 수 있음을 나타내는 텍스트를 추가하고 앵커 요소로 둘 다 감싸서 &lt;code&gt;image&lt;/code&gt; 클래스 이름을 지정하여 테스트에서 찾을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="89d849f40b52e102654d51fd7d92dff536022969" translate="yes" xml:space="preserve">
          <source>Let's use the creation of a TinyMCE component as an example. Currently, TinyMCE provides a setup configuration option we can use to do some processing after the TinyMCE instance is initialized but before it is actually rendered. We can use that setup option to do some additional setup for our component. The component itself could look something like the following:</source>
          <target state="translated">TinyMCE 컴포넌트 생성을 예로 들어 봅시다. 현재 TinyMCE는 TinyMCE 인스턴스가 초기화 된 후 실제로 렌더링되기 전에 일부 처리를 수행하는 데 사용할 수있는 설정 구성 옵션을 제공합니다. 해당 설정 옵션을 사용하여 컴포넌트에 대한 추가 설정을 수행 할 수 있습니다. 구성 요소 자체는 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67eb54f6056cb9b4a29c6a56cd99c5c9161ed991" translate="yes" xml:space="preserve">
          <source>Let's use the pressing of the escape key as an example. If you wanted to invoke a controller action when a user presses the escape key while on your field, you would use the &lt;code&gt;escape-press&lt;/code&gt; attribute on your field like so:</source>
          <target state="translated">이스케이프 키 누름을 예로 들어 봅시다. 사용자가 필드에서 이스케이프 키를 누를 때 제어기 조치를 호출하려면 다음 과 같이 필드 에서 &lt;code&gt;escape-press&lt;/code&gt; 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0946f7fd87cca9c49382d10b9e9e28288b447771" translate="yes" xml:space="preserve">
          <source>Let's use this hook to cleanup our date picker and event listener from above:</source>
          <target state="translated">이 후크를 사용하여 날짜 선택기 및 이벤트 리스너를 위에서 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="20e7c26e92650cd8cc308c911a7985599ad92d4f" translate="yes" xml:space="preserve">
          <source>Let's work through what we want to do on the home page. We want our application to:</source>
          <target state="translated">홈페이지에서 우리가하고 싶은 일을 봅시다. 우리는 우리의 어플리케이션이</target>
        </trans-unit>
        <trans-unit id="635a95b002cf836140f8bfffc7a9737eb04db8de" translate="yes" xml:space="preserve">
          <source>Lets add some protective code to ensure our results do not get out of sync with our filter input. To do this we'll simply provide the filter text to the filter function, so that when the results come back we can compare the original filter value with the current filter value. We will update the results on screen only if the original filter value and the current filter value are the same.</source>
          <target state="translated">결과가 필터 입력과 동기화되지 않도록 보호 코드를 추가 할 수 있습니다. 이를 위해 단순히 필터 텍스트를 필터 함수에 제공하여 결과가 다시 나오면 원래 필터 값과 현재 필터 값을 비교할 수 있습니다. 원래 필터 값과 현재 필터 값이 동일한 경우에만 화면에서 결과를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="bc44f6fd03fb10139ad97676e11707e10e54b58c" translate="yes" xml:space="preserve">
          <source>Lets begin by opening the component integration test created when we generated our &lt;code&gt;list-filter&lt;/code&gt; component, &lt;code&gt;tests/integration/components/list-filter-test.js&lt;/code&gt;. Remove the default test, and create a new test that verifies that by default, the component will list all items.</source>
          <target state="translated">&lt;code&gt;list-filter&lt;/code&gt; 구성 요소, &lt;code&gt;tests/integration/components/list-filter-test.js&lt;/code&gt; 를 생성 할 때 생성 된 구성 요소 통합 테스트를 열어 보자 . 기본 테스트를 제거하고 기본적으로 구성 요소가 모든 항목을 나열하는지 확인하는 새 테스트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c885b189d5463a9de5e3e50647d490118201ec4c" translate="yes" xml:space="preserve">
          <source>Libraries on top of Ember can add initializers, like so:</source>
          <target state="translated">Ember 위에있는 라이브러리는 다음과 같이 이니셜 라이저를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="945316ced7cc6b53c759ff6f262d52bfcb61c767" translate="yes" xml:space="preserve">
          <source>Library Info</source>
          <target state="translated">도서관 정보</target>
        </trans-unit>
        <trans-unit id="c4a417c6c7ec6f5a4f9e827b354dbb85f2e88f9b" translate="yes" xml:space="preserve">
          <source>Library authors can customize how any object will display in the Inspector. By defining a &lt;code&gt;_debugInfo&lt;/code&gt; method, an object can tell the Inspector how it should be rendered. For an example on how to customize an object's properties, see &lt;a href=&quot;https://github.com/emberjs/data/blob/f1be2af71d7402d034bc034d9502733647cad295/packages/ember-data/lib/system/debug/debug_info.js&quot;&gt;Ember Data's customization&lt;/a&gt;.</source>
          <target state="translated">라이브러리 작성자는 개체가 관리자에 표시되는 방식을 사용자 정의 할 수 있습니다. &lt;code&gt;_debugInfo&lt;/code&gt; 메소드 를 정의 하면 객체가 인스펙터에게 렌더링 방법을 알릴 수 있습니다. 객체의 속성을 사용자 정의하는 방법에 대한 예는 &lt;a href=&quot;https://github.com/emberjs/data/blob/f1be2af71d7402d034bc034d9502733647cad295/packages/ember-data/lib/system/debug/debug_info.js&quot;&gt;Ember Data의 사용자 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8226bf9e9b956346502b16db50675cd108dd1920" translate="yes" xml:space="preserve">
          <source>Life Without Prototype Extension</source>
          <target state="translated">시제품 연장없는 생활</target>
        </trans-unit>
        <trans-unit id="57ec013a3d266c6865a25d72a7960cd8d6bed640" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Examples</source>
          <target state="translated">수명주기 후크 예</target>
        </trans-unit>
        <trans-unit id="ec7756d2056b7d20b67e5f847928e2cf4a83f1d6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;find&lt;/code&gt;, but throws an error if the element selector returns no results.</source>
          <target state="translated">마찬가지로 &lt;code&gt;find&lt;/code&gt; 있지만, 요소의 선택이 더 결과를 반환하지 않는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0ff675c379589d88041784c63e59222fb0ad141" translate="yes" xml:space="preserve">
          <source>Like any Ember object, a service is initialized and can have properties and methods of its own. Below, the shopping cart service manages an items array that represents the items currently in the shopping cart.</source>
          <target state="translated">다른 Ember 객체와 마찬가지로 서비스는 초기화되며 고유 한 속성과 메서드를 가질 수 있습니다. 아래에서 쇼핑 카트 서비스는 현재 쇼핑 카트에있는 항목을 나타내는 항목 배열을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="f24ff1b32ab054733196fb79b66cf78f2352602e" translate="yes" xml:space="preserve">
          <source>Like any helper, the &lt;code&gt;unbound&lt;/code&gt; helper can accept a nested helper expression. This allows for custom helpers to be rendered unbound:</source>
          <target state="translated">도우미와 마찬가지로 &lt;code&gt;unbound&lt;/code&gt; 도우미는 중첩 도우미 식을 허용 할 수 있습니다. 이를 통해 커스텀 헬퍼를 언 바운드로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07aa5990e7980b9aa614cd12afffc38c4f316c64" translate="yes" xml:space="preserve">
          <source>Like normal attributes, actions can be a property on the component; the only difference is that the property is set to a function that knows how to trigger behavior.</source>
          <target state="translated">일반적인 속성과 마찬가지로 작업은 구성 요소의 속성 일 수 있습니다. 유일한 차이점은 속성이 동작을 트리거하는 방법을 알고있는 함수로 설정되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2cac3e8601ae552602a520670e5074a8519074e" translate="yes" xml:space="preserve">
          <source>Like other helpers, the &lt;code&gt;{{#each}}&lt;/code&gt; helper is bound. If a new item is added to or removed from the iterated array, the DOM will be updated without having to write any additional code. That said, Ember requires that you use &lt;a href=&quot;https://guides.emberjs.com/object-model/enumerables/#toc_use-of-observable-methods-and-properties&quot;&gt;special methods&lt;/a&gt; to update bound arrays. Also be aware that &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#toc_specifying-keys&quot;&gt;using the &lt;code&gt;key&lt;/code&gt; option with an each helper&lt;/a&gt; can improve re-render performance when an array is replaced with another containing similar items.</source>
          <target state="translated">다른 도우미와 마찬가지로 &lt;code&gt;{{#each}}&lt;/code&gt; 도우미가 바인딩됩니다. 반복 된 배열에 새 항목이 추가되거나 제거되면 추가 코드를 작성하지 않고도 DOM이 업데이트됩니다. 즉, Ember는 바인딩 된 배열을 업데이트하기 위해 &lt;a href=&quot;https://guides.emberjs.com/object-model/enumerables/#toc_use-of-observable-methods-and-properties&quot;&gt;특별한 방법&lt;/a&gt; 을 사용해야 합니다. 또한 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#toc_specifying-keys&quot;&gt;각 도우미와 함께 &lt;/a&gt; &lt;code&gt;key&lt;/code&gt; 옵션 을 사용하면 어레이가 유사한 항목을 포함하는 다른 것으로 교체 될 때 다시 렌더링 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5368091bb8913e46aa5ac099e90ff00c3876dcb1" translate="yes" xml:space="preserve">
          <source>Like the filtering methods, the &lt;code&gt;every()&lt;/code&gt; and &lt;code&gt;any()&lt;/code&gt; methods have analogous &lt;code&gt;isEvery()&lt;/code&gt; and &lt;code&gt;isAny()&lt;/code&gt; methods.</source>
          <target state="translated">필터링 메소드와 마찬가지로 &lt;code&gt;every()&lt;/code&gt; 및 &lt;code&gt;any()&lt;/code&gt; 메소드에는 유사한 &lt;code&gt;isEvery()&lt;/code&gt; 및 &lt;code&gt;isAny()&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace18740b81dab0322b75335cffde9805b53a9b6" translate="yes" xml:space="preserve">
          <source>Likewise, if you try to call &lt;code&gt;get&lt;/code&gt; on a property whose value is &lt;code&gt;undefined&lt;/code&gt;, the &lt;code&gt;unknownProperty()&lt;/code&gt; method will be called on the object. If this method returns any value other than &lt;code&gt;undefined&lt;/code&gt;, it will be returned instead. This allows you to implement &quot;virtual&quot; properties that are not defined upfront.</source>
          <target state="translated">마찬가지로, 값이 &lt;code&gt;undefined&lt;/code&gt; 인 속성에 대해 &lt;code&gt;get&lt;/code&gt; 을 호출하려고 하면 객체 에서 &lt;code&gt;unknownProperty()&lt;/code&gt; 메서드가 호출됩니다. 이 메소드가 &lt;code&gt;undefined&lt;/code&gt; 이외의 다른 값을 리턴하면 대신 리턴됩니다. 이를 통해 미리 정의되지 않은 &quot;가상&quot;속성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c5555cae22b7bb9706107a4ca1a41e719e438c" translate="yes" xml:space="preserve">
          <source>Link to contact information</source>
          <target state="translated">연락처 정보에 연결</target>
        </trans-unit>
        <trans-unit id="74076a27ecfcb330397619467fbee055750ed67b" translate="yes" xml:space="preserve">
          <source>Link to information about the company</source>
          <target state="translated">회사 정보에 ​​대한 링크</target>
        </trans-unit>
        <trans-unit id="5d77a7c8983578d904111c3bee72bdf79449008b" translate="yes" xml:space="preserve">
          <source>LinkComponent</source>
          <target state="translated">LinkComponent</target>
        </trans-unit>
        <trans-unit id="ac4a62a01d54a4764c6d144461d6c9e37e4819d1" translate="yes" xml:space="preserve">
          <source>LinkComponent.rel</source>
          <target state="translated">LinkComponent.rel</target>
        </trans-unit>
        <trans-unit id="940de94ebf96b39d03d62b9606182c5b87b78db6" translate="yes" xml:space="preserve">
          <source>Linking to a Specific Rental</source>
          <target state="translated">특정 임대료에 연결</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="90f76386e11d7ad585627bc493ee7aedded009f6" translate="yes" xml:space="preserve">
          <source>Links beginning with &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;http://&lt;/code&gt;, &lt;code&gt;https://&lt;/code&gt;, will be used as is, with no further manipulation.</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; , &lt;code&gt;http://&lt;/code&gt; , &lt;code&gt;https://&lt;/code&gt; 로 시작하는 링크 는 추가 조작없이 그대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cf37ddbb4833e091bc4ad70d9b2018056400b70" translate="yes" xml:space="preserve">
          <source>Links beginning with a single &lt;code&gt;/&lt;/code&gt; will have the current adapter's &lt;code&gt;host&lt;/code&gt; value prepended to it.</source>
          <target state="translated">단일 &lt;code&gt;/&lt;/code&gt; 으로 시작하는 링크 에는 현재 어댑터의 &lt;code&gt;host&lt;/code&gt; 값이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="f7264df21b6806560320b80c6b7fbb6558a5eb0e" translate="yes" xml:space="preserve">
          <source>Links with no beginning &lt;code&gt;/&lt;/code&gt; will have a parentURL prepended to it, via the current adapter's &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">시작 &lt;code&gt;/&lt;/code&gt; 이 없는 링크 는 현재 어댑터의 &lt;code&gt;buildURL&lt;/code&gt; 을 통해 부모 URL 앞에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="66bf4d535a1ef04e79b6cdc89f1a06627656f756" translate="yes" xml:space="preserve">
          <source>Linter, linting</source>
          <target state="translated">린터, 보풀</target>
        </trans-unit>
        <trans-unit id="bbba5a3d0f934d3dca2995dd3e4663bd1ec20aff" translate="yes" xml:space="preserve">
          <source>Linux users can use &lt;a href=&quot;https://nodejs.org/en/download/package-manager/&quot;&gt;this guide for Node.js installation on Linux&lt;/a&gt;.</source>
          <target state="translated">Linux 사용자는 Linux &lt;a href=&quot;https://nodejs.org/en/download/package-manager/&quot;&gt;에서 Node.js 설치에이 안내서를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29b74ca8265c653c34364f3d4acd28cd24128388" translate="yes" xml:space="preserve">
          <source>List of objects defining filters. The object should have a `name` and `desc` property.</source>
          <target state="translated">필터를 정의하는 객체 목록. 객체는`name`과`desc` 속성을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="00607eeb7342e3f04724c5834e4e2e8f7c2f6ff1" translate="yes" xml:space="preserve">
          <source>List the available rentals</source>
          <target state="translated">사용 가능한 대여 목록</target>
        </trans-unit>
        <trans-unit id="d03c2905c8cd553f3f1f729734fe9cef1280d14a" translate="yes" xml:space="preserve">
          <source>Listed below are the component lifecycle hooks in order of execution according to render scenario.</source>
          <target state="translated">아래는 렌더 시나리오에 따라 실행 순서에 따른 구성 요소 수명주기 후크입니다.</target>
        </trans-unit>
        <trans-unit id="02afd43a11c4310cdd19459b87081ef2af547ad3" translate="yes" xml:space="preserve">
          <source>Loading / Error Substates</source>
          <target state="translated">로드 / 오류 하위 상태</target>
        </trans-unit>
        <trans-unit id="0989b580dabe8ed18a9790d54605768f7b2e7f15" translate="yes" xml:space="preserve">
          <source>Loads a record in a belongs to relationship if it is not already loaded. If the relationship is already loaded this method does not trigger a new load.</source>
          <target state="translated">아직로드되지 않은 경우 관계에 속하는 레코드를로드합니다. 관계가 이미로드 된 경우이 메소드는 새로드를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ed570ef8b28d2a9d4b5544de5723875a7b30ab7" translate="yes" xml:space="preserve">
          <source>Loads a route, sets up any controllers, and renders any templates associated with the route as though a real user had triggered the route change while using your app.</source>
          <target state="translated">앱을 사용하는 동안 실제 사용자가 경로 변경을 트리거 한 것처럼 경로를로드하고 컨트롤러를 설정하며 경로와 연결된 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8b618c79a59fd45e8d69fc13ceb218d48e4542b0" translate="yes" xml:space="preserve">
          <source>Loads the relationship if it is not already loaded. If the relationship is already loaded this method does not trigger a new load.</source>
          <target state="translated">관계가 아직로드되지 않은 경우로드합니다. 관계가 이미로드 된 경우이 메소드는 새로드를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b0da20d6e4d3578fde73b0982ef39086f18d71" translate="yes" xml:space="preserve">
          <source>Location API</source>
          <target state="translated">위치 API</target>
        </trans-unit>
        <trans-unit id="3c20cc766b3ed4cefd9c0f4868560b2be809f67b" translate="yes" xml:space="preserve">
          <source>Log generated controller</source>
          <target state="translated">로그 생성 컨트롤러</target>
        </trans-unit>
        <trans-unit id="5d5c719cb08629876124bf7f8b02dda0475b8203" translate="yes" xml:space="preserve">
          <source>Log object bindings</source>
          <target state="translated">로그 객체 바인딩</target>
        </trans-unit>
        <trans-unit id="603c2cf3c52217f421f3b823673b4e845405e05d" translate="yes" xml:space="preserve">
          <source>Log router transitions</source>
          <target state="translated">로그 라우터 전환</target>
        </trans-unit>
        <trans-unit id="aa00341e83ed481f80d9005fae06dbb9d29b533e" translate="yes" xml:space="preserve">
          <source>Log view lookups</source>
          <target state="translated">로그 뷰 조회</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="f2e14633e86adb02560262087e31589175004916" translate="yes" xml:space="preserve">
          <source>Logging.</source>
          <target state="translated">Logging.</target>
        </trans-unit>
        <trans-unit id="1bfaba86c08ed86838f22fb60cceb822f0b9db4c" translate="yes" xml:space="preserve">
          <source>Mac users often prefer to install Node using &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;. After installing Homebrew, run &lt;code&gt;brew install node&lt;/code&gt; to install Node.js. Alternatively, installer packages are available directly from &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&lt;/a&gt;.</source>
          <target state="translated">Mac 사용자는 종종 &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew를&lt;/a&gt; 사용하여 노드를 설치하는 것을 선호합니다 . Homebrew를 설치 한 후 &lt;code&gt;brew install node&lt;/code&gt; 를 실행 하여 Node.js를 설치하십시오. 또는 설치 프로그램 패키지는 &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&lt;/a&gt; 에서 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2443f268bec1ac71f9689a446f93b5003aeaf34" translate="yes" xml:space="preserve">
          <source>Make sure the &quot;Display the Tomster&quot; checkbox is checked.</source>
          <target state="translated">&quot;Toster 표시&quot;체크 상자가 체크되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6ad226711cb1283574db1e4c496932d2f5407750" translate="yes" xml:space="preserve">
          <source>Make sure the Inspector is active when you call this method.</source>
          <target state="translated">이 메소드를 호출 할 때 인스펙터가 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5be8b4e32ecc791ac6bd4b6f06d2b9e2c830fcde" translate="yes" xml:space="preserve">
          <source>Make sure to use these accessor methods; otherwise, computed properties won't recalculate, observers won't fire, and templates won't update.</source>
          <target state="translated">이러한 접근 자 메서드를 사용해야합니다. 그렇지 않으면 계산 된 속성이 다시 계산되지 않고 관찰자가 실행되지 않으며 템플릿이 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a10cf5cb44c73808cbd9b0ee95ade42559077f79" translate="yes" xml:space="preserve">
          <source>Make sure you are testing performance on real devices. Simulated mobile environments on a desktop computer give an optimistic-at-best representation of what your real world performance will be like. The more operating systems and hardware configurations you test, the more confident you can be.</source>
          <target state="translated">실제 장치에서 성능을 테스트하고 있는지 확인하십시오. 데스크탑 컴퓨터에서 시뮬레이션 된 모바일 환경은 실제 성능이 어떤지에 대해 낙관적이며 최상의 표현을 제공합니다. 테스트 할 운영 체제 및 하드웨어 구성이 많을수록 자신감을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b28eac87396cdc54aabf1394e488ee8f47ac04" translate="yes" xml:space="preserve">
          <source>Make sure you list these dependencies so Ember knows when to update bindings that connect to a computed property. Changing a dependency will not immediately trigger an update of the computed property, but will instead clear the cache so that it is updated when the next &lt;code&gt;get&lt;/code&gt; is called on the property.</source>
          <target state="translated">Ember가 계산 된 속성에 연결하는 바인딩을 업데이트 할시기를 알 수 있도록 이러한 종속성을 나열해야합니다. 종속성을 변경하면 계산 된 속성의 업데이트가 즉시 트리거되지 않지만 대신 캐시에서 다음 &lt;code&gt;get&lt;/code&gt; 이 호출 될 때 업데이트되도록 캐시 가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="d867490c5d6df24c478defa0929214c97994571f" translate="yes" xml:space="preserve">
          <source>Makes a method available via an additional name.</source>
          <target state="translated">추가 이름을 통해 메소드를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="c324510651548eb44cd83c2afb3351e2d31a161e" translate="yes" xml:space="preserve">
          <source>Making Google Maps Available</source>
          <target state="translated">Google지도 사용 가능</target>
        </trans-unit>
        <trans-unit id="6b2c35fea089f0887b25b17735fb5a1d326a2654" translate="yes" xml:space="preserve">
          <source>Making Updates to the Rendered DOM with &lt;code&gt;didRender&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;didRender&lt;/code&gt; 를 사용하여 렌더링 된 DOM 업데이트</target>
        </trans-unit>
        <trans-unit id="70bfaf1566829005270d36f38f0ffe1bc5723469" translate="yes" xml:space="preserve">
          <source>Making changes to Ember Data records is as simple as setting the attribute you want to change:</source>
          <target state="translated">Ember Data 레코드를 변경하는 것은 변경하려는 속성을 설정하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="dcaec0425116cb667caf4bac2560e1cc169c5402" translate="yes" xml:space="preserve">
          <source>Managing Dependencies</source>
          <target state="translated">종속성 관리</target>
        </trans-unit>
        <trans-unit id="af5b5bc4db6b9a07519c515c5725d7ebc1a458e9" translate="yes" xml:space="preserve">
          <source>Many computed properties have dependencies on other properties. For example, in the above example, the &lt;code&gt;fullName&lt;/code&gt; property depends on &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; to determine its value. You can tell Ember about these dependencies like this:</source>
          <target state="translated">많은 계산 속성이 다른 속성에 종속됩니다. 예를 들어 위 예제에서 &lt;code&gt;fullName&lt;/code&gt; 속성은 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 에 따라 값을 결정합니다. 다음과 같은 종속성에 대해 Ember에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65b31bc269a60f245ce759ee19932b6d67fae66e" translate="yes" xml:space="preserve">
          <source>Many of the common HTML properties you would want to use like &lt;code&gt;class&lt;/code&gt;, and &lt;code&gt;rel&lt;/code&gt; will work. When adding class names, Ember will also apply the standard &lt;code&gt;ember-view&lt;/code&gt; and possibly &lt;code&gt;active&lt;/code&gt; class names.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 와 같은 일반적인 HTML 속성 중 많은 것들이 사용 되며 &lt;code&gt;rel&lt;/code&gt; 이 작동합니다. 클래스 이름을 추가 할 때 Ember는 표준 &lt;code&gt;ember-view&lt;/code&gt; 및 가능한 &lt;code&gt;active&lt;/code&gt; 클래스 이름 도 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="6b961b379063852ca79321587bc3a8c0ab661545" translate="yes" xml:space="preserve">
          <source>Many other libraries provide some kind of iterator or enumeration like facility. This is often where the most common API conflicts occur. Ember's API is designed to be as friendly as possible with other libraries by implementing only methods that mostly correspond to the JavaScript 1.8 API.</source>
          <target state="translated">다른 많은 라이브러리는 일종의 반복자 또는 기능과 같은 열거를 제공합니다. 가장 일반적인 API 충돌이 발생하는 경우가 종종 있습니다. Ember의 API는 대부분 JavaScript 1.8 API에 해당하는 메소드 만 구현하여 다른 라이브러리와 최대한 친숙하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2ca19e6e187118e63e97c39edbdf6a65e72c04c2" translate="yes" xml:space="preserve">
          <source>Many servers, such as Rails and PHP, will automatically convert this URL-encoded array into an Array for you on the server-side. If you want to encode the IDs, differently, just override this (one-line) method.</source>
          <target state="translated">Rails 및 PHP와 같은 많은 서버는이 URL 인코딩 배열을 서버 측 배열로 자동 변환합니다. ID를 다르게 인코딩하려면이 (한 줄) 방법을 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1bee9fefa75d1483e8070e9750032eef28ff759d" translate="yes" xml:space="preserve">
          <source>Many-To-Many</source>
          <target state="translated">Many-To-Many</target>
        </trans-unit>
        <trans-unit id="c883031b9ab452aff47320db2b5868dd27dd5be3" translate="yes" xml:space="preserve">
          <source>Many-to-Many</source>
          <target state="translated">Many-to-Many</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="510afa932a8af5b85329d8ebc5ac4856e95f63ef" translate="yes" xml:space="preserve">
          <source>Map a controller's property to a different query param key</source>
          <target state="translated">컨트롤러의 속성을 다른 쿼리 매개 변수 키에 매핑</target>
        </trans-unit>
        <trans-unit id="a89a789ab5fcdfe6e7cedcf5a3677beb9a16fe8f" translate="yes" xml:space="preserve">
          <source>Maps all of the items in the enumeration to another value, returning a new array. This method corresponds to &lt;code&gt;map()&lt;/code&gt; defined in JavaScript 1.6.</source>
          <target state="translated">열거의 모든 항목을 다른 값으로 매핑하여 새 배열을 반환합니다. 이 메소드 는 JavaScript 1.6에 정의 된 &lt;code&gt;map()&lt;/code&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="fbe8601461d7ed761fcd5a028a86fa5c4bf1934e" translate="yes" xml:space="preserve">
          <source>Mark a string as safe for unescaped output with Ember templates. If you return HTML from a helper, use this function to ensure Ember's rendering layer does not escape the HTML.</source>
          <target state="translated">Ember 템플릿으로 이스케이프되지 않은 출력에 대해 문자열을 안전한 것으로 표시하십시오. 도우미에서 HTML을 반환하는 경우이 함수를 사용하여 Ember의 렌더링 레이어가 HTML을 이스케이프하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8384f3697cae9999b84d6bff001ae61ca3ac5e" translate="yes" xml:space="preserve">
          <source>Marks the record as deleted but does not save it. You must call &lt;code&gt;save&lt;/code&gt; afterwards if you want to persist it. You might use this method if you want to allow the user to still &lt;code&gt;rollbackAttributes()&lt;/code&gt; after a delete was made.</source>
          <target state="translated">레코드를 삭제 된 것으로 표시하지만 저장하지는 않습니다. &lt;code&gt;save&lt;/code&gt; 나중에 저장을 호출해야 합니다. 삭제 후 사용자가 여전히 &lt;code&gt;rollbackAttributes()&lt;/code&gt; 를 허용하도록하려면이 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef56709ca6a20c8e16b3f6b056dde8c7b15f5b0" translate="yes" xml:space="preserve">
          <source>Measure performance from the beginning, and keep testing as your app develops.</source>
          <target state="translated">처음부터 성능을 측정하고 앱이 개발됨에 따라 테스트를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="8c2479a17e803025649242a9474178042dc135a9" translate="yes" xml:space="preserve">
          <source>Merge the contents of two objects together into the first object.</source>
          <target state="translated">두 객체의 내용을 첫 번째 객체로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="ea9fc818037e4c1eb523043b8c97a427dff9ed43" translate="yes" xml:space="preserve">
          <source>Metadata associated with the request for async hasMany relationships.</source>
          <target state="translated">비동기 요청과 관련된 메타 데이터에는 많은 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd0b54a13118c5e57a4f231ed1e30a46262760c" translate="yes" xml:space="preserve">
          <source>Method Implementation</source>
          <target state="translated">방법 구현</target>
        </trans-unit>
        <trans-unit id="fb4e599fda756443d7e1a45a5e3f433bc0cffb30" translate="yes" xml:space="preserve">
          <source>Method to call to remove all observers</source>
          <target state="translated">모든 관찰자를 제거하기 위해 호출하는 메소드</target>
        </trans-unit>
        <trans-unit id="f3f9a4f8e75f8f8fc949764d8a4323ec811afdd7" translate="yes" xml:space="preserve">
          <source>Method to call to remove all observers.</source>
          <target state="translated">모든 관찰자를 제거하기 위해 호출하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="3382975c2f98c7ed302504a43959793238b27e2b" translate="yes" xml:space="preserve">
          <source>Method to invoke. May be a function or a string. If you pass a string then it will be looked up on the passed target.</source>
          <target state="translated">호출 할 메소드입니다. 함수 또는 문자열 일 수 있습니다. 문자열을 전달하면 전달 된 대상에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="16e8c90b05ca8f10c04dfc691ff732fb574a0479" translate="yes" xml:space="preserve">
          <source>Mirage works by overriding the JavaScript code that makes network requests and instead returns the JSON you specify. We should note that this means you will not see any network requests in your development tools but will instead see the JSON logged in your console. Our update to &lt;code&gt;mirage/config.js&lt;/code&gt; configures Mirage so that whenever Ember Data makes a GET request to &lt;code&gt;/api/rentals&lt;/code&gt;, Mirage will return this JavaScript object as JSON and no network request is actually made. We also specified a &lt;code&gt;namespace&lt;/code&gt; of &lt;code&gt;/api&lt;/code&gt; in our mirage configuration. Without this change, navigation to &lt;code&gt;/rentals&lt;/code&gt; in our application would conflict with Mirage.</source>
          <target state="translated">Mirage는 네트워크 요청을하는 JavaScript 코드를 재정 의하여 지정한 JSON을 반환합니다. 이는 개발 도구에 네트워크 요청이 표시되지 않고 콘솔에 JSON이 기록되어 있음을 의미합니다. &lt;code&gt;mirage/config.js&lt;/code&gt; 에 대한 업데이트는 Mirage를 구성하여 Ember Data가 &lt;code&gt;/api/rentals&lt;/code&gt; 에 GET 요청을 할 때마다 Mirage가이 JavaScript 객체를 JSON으로 반환하고 실제로 네트워크 요청이 이루어지지 않도록합니다. 또한 Mirage 구성에서 &lt;code&gt;/api&lt;/code&gt; 라는 &lt;code&gt;namespace&lt;/code&gt; 를 지정했습니다 . 이 변경이 없으면 응용 프로그램에서 &lt;code&gt;/rentals&lt;/code&gt; 로 이동하면 Mirage와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="1d21f12330d03b94dcb1cd6e01f79b79236abc39" translate="yes" xml:space="preserve">
          <source>Missing Promises</source>
          <target state="translated">약속 누락</target>
        </trans-unit>
        <trans-unit id="c0dcb865ad81a32e522b11fd1e33bae685e88709" translate="yes" xml:space="preserve">
          <source>Mixed</source>
          <target state="translated">Mixed</target>
        </trans-unit>
        <trans-unit id="8acb4f1a53ad0e32454267c61a794bb3188be2c6" translate="yes" xml:space="preserve">
          <source>Mixin</source>
          <target state="translated">Mixin</target>
        </trans-unit>
        <trans-unit id="7f1fa61246876b33a612f1bb51874527379a609d" translate="yes" xml:space="preserve">
          <source>Mobile Devices</source>
          <target state="translated">모바일 기기</target>
        </trans-unit>
        <trans-unit id="817f9d67353c530f2c6d64063a80813debd1618f" translate="yes" xml:space="preserve">
          <source>Model Relationships</source>
          <target state="translated">모델 관계</target>
        </trans-unit>
        <trans-unit id="631fcdbb4433fd9a49c55ac2973f6d77e0d68f1d" translate="yes" xml:space="preserve">
          <source>Model-specific adapters can be created by putting your adapter class in an &lt;code&gt;app/adapters/&lt;/code&gt; + &lt;code&gt;model-name&lt;/code&gt; + &lt;code&gt;.js&lt;/code&gt; file of the application.</source>
          <target state="translated">어댑터 클래스를 &lt;code&gt;app/adapters/&lt;/code&gt; 의 app / adapters / + &lt;code&gt;model-name&lt;/code&gt; + &lt;code&gt;.js&lt;/code&gt; 파일 에 넣어 모델 별 어댑터를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3798f81c7b6fecad2cbfec741314f8a66c0eca3" translate="yes" xml:space="preserve">
          <source>Models</source>
          <target state="translated">Models</target>
        </trans-unit>
        <trans-unit id="aa3797a25b7cc382220d5723004f9b4aa101aa91" translate="yes" xml:space="preserve">
          <source>Models are objects that represent the underlying data that your application presents to the user. Different apps will have very different models, depending on what problems they're trying to solve.</source>
          <target state="translated">모델은 응용 프로그램이 사용자에게 제공하는 기본 데이터를 나타내는 개체입니다. 해결하려는 문제에 따라 앱마다 모델이 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="019afea3eb207ecfb59621840f4278d323f8e988" translate="yes" xml:space="preserve">
          <source>Models define the type of data that will be provided by your server. For example, a &lt;code&gt;Person&lt;/code&gt; model might have a &lt;code&gt;firstName&lt;/code&gt; attribute that is a string, and a &lt;code&gt;birthday&lt;/code&gt; attribute that is a date:</source>
          <target state="translated">모델은 서버에서 제공 할 데이터 유형을 정의합니다. 예를 들어, &lt;code&gt;Person&lt;/code&gt; 모델 에는 문자열 인 &lt;code&gt;firstName&lt;/code&gt; 속성과 날짜 인 &lt;code&gt;birthday&lt;/code&gt; 속성이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8840b4d964096eecdc906427cdbaf361ea0eb171" translate="yes" xml:space="preserve">
          <source>Models don't have any data themselves, they define the attributes, relationships and behavior of specific instances, which are called &lt;strong&gt;records&lt;/strong&gt;.</source>
          <target state="translated">모델에는 데이터 자체가 없으며, &lt;strong&gt;레코드&lt;/strong&gt; 라고하는 특정 인스턴스의 속성, 관계 및 동작을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5b1d06fa82763ab47944cd44ffa1f0114d490583" translate="yes" xml:space="preserve">
          <source>Models represent persistent state.</source>
          <target state="translated">모델은 지속적 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="829196320118f53e8a87ca0f181c1208424d33f7" translate="yes" xml:space="preserve">
          <source>Models tend to be &lt;em&gt;persistent&lt;/em&gt;. That means the user does not expect model data to be lost when they close their browser window. To make sure no data is lost, if the user makes changes to a model, you need to store the model data somewhere that it will not be lost.</source>
          <target state="translated">모델은 &lt;em&gt;지속적인&lt;/em&gt; 경향이 있습니다 . 즉, 사용자는 브라우저 창을 닫을 때 모델 데이터가 손실 될 것으로 예상하지 않습니다. 데이터가 손실되지 않도록하려면 사용자가 모델을 변경 한 경우 모델 데이터가 손실되지 않는 위치에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="becbba5666aa6f8e8151efb9c6a064c94e791551" translate="yes" xml:space="preserve">
          <source>Models, records, adapters and the store are the core concepts you should understand to get the most out of Ember Data. The following sections go into more depth about each of these concepts, and how to use them together.</source>
          <target state="translated">모델, 레코드, 어댑터 및 상점은 Ember Data를 최대한 활용하기 위해 이해해야 할 핵심 개념입니다. 다음 섹션에서는 이러한 각 개념과 함께 사용하는 방법에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e33dda3590ab9e1e10e3d376c68eb2ddf127a98d" translate="yes" xml:space="preserve">
          <source>Modern application asset management (including concatenation, minification, and versioning).</source>
          <target state="translated">최신 애플리케이션 자산 관리 (연결, 축소 및 버전 관리 포함)</target>
        </trans-unit>
        <trans-unit id="4dc51b6f068ce224674bf3d77da2de0c1a9aa6fa" translate="yes" xml:space="preserve">
          <source>Modifying the action's first parameter</source>
          <target state="translated">조치의 첫 번째 매개 변수 수정</target>
        </trans-unit>
        <trans-unit id="d60ceaa995b9a7096628c7dee8145d8ce19d1838" translate="yes" xml:space="preserve">
          <source>Module:</source>
          <target state="translated">Module:</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="39760d15e024ca9e9dbb9f88fa69744a42526bab" translate="yes" xml:space="preserve">
          <source>More documentation about &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; are below.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 에 대한 추가 문서 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a59199bd069e71ebec2691e36709a71e3b09cb6" translate="yes" xml:space="preserve">
          <source>More general than decamelize. Returns the lower_case_and_underscored form of a string.</source>
          <target state="translated">decamelize보다 더 일반적입니다. lower_case_and_underscored 형식의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55272c5128cb978d842fea14f3de880b35c70fcf" translate="yes" xml:space="preserve">
          <source>Most Ember.js applications will only have a single &lt;code&gt;DS.Store&lt;/code&gt; that is automatically created by their &lt;code&gt;Ember.Application&lt;/code&gt;.</source>
          <target state="translated">대부분의 Ember.js 응용 프로그램은 단일해야합니다 &lt;code&gt;DS.Store&lt;/code&gt; 자동으로 만들어집니다 &lt;code&gt;Ember.Application&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="43ad4a5b784abcbbce3b199f0ed3a3291fc39b60" translate="yes" xml:space="preserve">
          <source>Most browsers support at least ES5, and some even have ES6 (also known as ES2015) support. You can check each browser's support (including yours) here:</source>
          <target state="translated">대부분의 브라우저는 최소한 ES5를 지원하며 일부는 ES6 (ES2015라고도 함) 지원을 제공합니다. 여기에서 각 브라우저의 지원 (귀하의 지원)을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7be23ccab1061cd0bab7344d8b6ec95b5a61502e" translate="yes" xml:space="preserve">
          <source>Most templates in an Ember codebase are instantly familiar, and look like any fragment of HTML. For example:</source>
          <target state="translated">Ember 코드베이스의 대부분의 템플릿은 즉시 친숙하며 HTML 조각처럼 보입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e640b670a6bf70395bf924c1c54b5e4ad8cb46d5" translate="yes" xml:space="preserve">
          <source>Most traditional REST-like HTTP APIs will not use this method. Instead, the ID of the record will be set by the server, and your adapter will update the store with the new ID when it calls &lt;code&gt;didCreateRecord()&lt;/code&gt;. Only implement this method if you intend to generate record IDs on the client-side.</source>
          <target state="translated">대부분의 기존 REST 유사 HTTP API는이 방법을 사용하지 않습니다. 대신, 레코드의 ID가 서버에 의해 설정되며 어댑터는 &lt;code&gt;didCreateRecord()&lt;/code&gt; 호출 할 때 새 ID로 상점을 업데이트합니다 . 클라이언트 측에서 레코드 ID를 생성하려는 경우에만이 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="ee7f1ca589520f1cb0e1adb76c8c5be4f8dbe4c3" translate="yes" xml:space="preserve">
          <source>Mouse events</source>
          <target state="translated">마우스 이벤트</target>
        </trans-unit>
        <trans-unit id="b96500fb0aaaecea42972538de1579921015f914" translate="yes" xml:space="preserve">
          <source>Mouse events:</source>
          <target state="translated">마우스 이벤트 :</target>
        </trans-unit>
        <trans-unit id="624f9b2fa33d8646c194683a6d7fb00f33f859c5" translate="yes" xml:space="preserve">
          <source>Move jobs from &lt;code&gt;CURRENT_QUEUE&lt;/code&gt; into &lt;code&gt;WORK_QUEUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CURRENT_QUEUE&lt;/code&gt; 에서 &lt;code&gt;WORK_QUEUE&lt;/code&gt; (으) 로 작업 이동</target>
        </trans-unit>
        <trans-unit id="7f1408efe0b6e95b82adc5c6940f59fe1a42275e" translate="yes" xml:space="preserve">
          <source>Move on to the &lt;a href=&quot;../hbs-helper&quot;&gt;next page&lt;/a&gt; for the next feature, or continue on here to test what you just wrote.</source>
          <target state="translated">다음 기능으로 이동하려면 &lt;a href=&quot;../hbs-helper&quot;&gt;다음 페이지&lt;/a&gt; 로 이동 하거나 방금 작성한 내용을 테스트하려면 여기를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e023c96f99c12b700a944b69a5398f51a87bdf" translate="yes" xml:space="preserve">
          <source>Moving around our site is a bit of a pain right now, so let's make that easier. We'll put a link to the contact page on the about page, and a corresponding link to the about page on the contact page.</source>
          <target state="translated">우리 사이트를 돌아 다니는 것은 지금 약간의 고통이므로, 더 쉽게 만들어 봅시다. 정보 페이지의 연락처 페이지에 대한 링크와 연락처 페이지의 정보 페이지에 대한 해당 링크를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="3d79d467d10ff9f72b3957527d9055f1f2344c6b" translate="yes" xml:space="preserve">
          <source>Much like how our application's &lt;code&gt;index&lt;/code&gt; route doesn't appear in our Router, &lt;code&gt;index&lt;/code&gt; routes on sub-routes won't explicitly appear in the Router either. Ember knows that the default action is to take the user to the &lt;code&gt;index&lt;/code&gt; route. However, you can add the &lt;code&gt;index&lt;/code&gt; route if you want to customize it. For example, you can modify the &lt;code&gt;index&lt;/code&gt; route's path by specifying &lt;code&gt;this.route('index', { path: '/custom-path'})&lt;/code&gt;.</source>
          <target state="translated">애플리케이션의 &lt;code&gt;index&lt;/code&gt; 라우트가 라우터에 나타나지 않는 것과 마찬가지로 서브 라우트의 &lt;code&gt;index&lt;/code&gt; 라우트도 라우터에 명시 적으로 나타나지 않습니다. Ember는 기본 동작이 사용자를 &lt;code&gt;index&lt;/code&gt; 경로 로 이동시키는 것임을 알고 있습니다 . 그러나 &lt;code&gt;index&lt;/code&gt; 경로를 사용자 정의하려는 경우 색인 경로를 추가 할 수 있습니다 . 예를 들어 &lt;code&gt;this.route('index', { path: '/custom-path'})&lt;/code&gt; 를 지정 하여 &lt;code&gt;index&lt;/code&gt; 경로의 경로를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0892f97ba890bdd37e0b0d9f6b4dec5bbe6b06" translate="yes" xml:space="preserve">
          <source>Much of the power of promises comes from the fact that they can be chained together to perform sequential asynchronous operations:</source>
          <target state="translated">약속의 힘의 대부분은 순차적 비동기 작업을 수행하기 위해 서로 연결될 수 있다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="28a601b1de7007639b3f9e108f2a1ef5c64fd42c" translate="yes" xml:space="preserve">
          <source>Multi-word route names are conventionally dasherized, such as:</source>
          <target state="translated">여러 단어 경로 이름은 일반적으로 다음과 같이 대시 형식입니다.</target>
        </trans-unit>
        <trans-unit id="78340660db0f24ef38760b67cbbddc4412bcd4c1" translate="yes" xml:space="preserve">
          <source>Multi-word route names that break this convention, such as:</source>
          <target state="translated">이 규칙을 위반하는 여러 단어 경로 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="3b38834946b176dd5d95ff88c4d70d97548594fa" translate="yes" xml:space="preserve">
          <source>Multiple Dependent Keys</source>
          <target state="translated">다중 종속 키</target>
        </trans-unit>
        <trans-unit id="b8d5b89d2e964353c630f9ded89e04d3e86caaf0" translate="yes" xml:space="preserve">
          <source>Multiple Models</source>
          <target state="translated">여러 모델</target>
        </trans-unit>
        <trans-unit id="12cbb2ffc194012d392a1c4993f0c9984dfd0981" translate="yes" xml:space="preserve">
          <source>Multiple Models Example</source>
          <target state="translated">여러 모델 예</target>
        </trans-unit>
        <trans-unit id="d6553f22af5154a8bd1c4ad52c108a92da650f3c" translate="yes" xml:space="preserve">
          <source>Multiple dependents on the same object</source>
          <target state="translated">동일한 객체에 대한 여러 부양 가족</target>
        </trans-unit>
        <trans-unit id="ffac1ed7d498ee17123d25a206c3251a5fdeee0f" translate="yes" xml:space="preserve">
          <source>Multiple models can be returned through an &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html#method_hash&quot;&gt;RSVP.hash&lt;/a&gt;. The &lt;code&gt;RSVP.hash&lt;/code&gt; takes parameters that return promises, and when all parameter promises resolve, then the &lt;code&gt;RSVP.hash&lt;/code&gt; promise resolves. For example:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html#method_hash&quot;&gt;RSVP.hash를&lt;/a&gt; 통해 여러 모델을 반환 할 수 있습니다 . &lt;code&gt;RSVP.hash&lt;/code&gt; 는 돌려 약속 매개 변수를 때, 그리고 모든 매개 변수의 약속의 해결은 다음 &lt;code&gt;RSVP.hash&lt;/code&gt; 의 약속 해결합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c3482c9f462fff40115cc375f0938294535d352" translate="yes" xml:space="preserve">
          <source>Multiple models will be applied last to first recursively up the route tree.</source>
          <target state="translated">루트 트리에서 재귀 적으로 처음에 여러 모델이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fe2c0eff1698d461f5e41a286301db51f73fef1" translate="yes" xml:space="preserve">
          <source>Multiple operations scheduled with &lt;code&gt;run.next&lt;/code&gt; will coalesce into the same later run loop, along with any other operations scheduled by &lt;code&gt;run.later&lt;/code&gt; that expire right around the same time that &lt;code&gt;run.next&lt;/code&gt; operations will fire.</source>
          <target state="translated">로 예정 다중 작업 &lt;code&gt;run.next&lt;/code&gt; 은 가 예약 한 다른 작업과 함께 같은 나중에 실행 루프에 병합됩니다 &lt;code&gt;run.later&lt;/code&gt; 바로 주변과 동시에 만료 &lt;code&gt;run.next&lt;/code&gt; 작업이 발사됩니다.</target>
        </trans-unit>
        <trans-unit id="02209f8602f7d7995fe4c193c3f7d7b587ad5ab3" translate="yes" xml:space="preserve">
          <source>Multiple relationships can be requested using an &lt;code&gt;include&lt;/code&gt; parameter consisting of a comma-separated list (without white-space) while nested relationships can be specified using a dot-separated sequence of relationship names. So to request both the post's comments and the authors of those comments the request would look like this:</source>
          <target state="translated">쉼표로 구분 된 목록 (공백없이)으로 구성된 &lt;code&gt;include&lt;/code&gt; 매개 변수를 사용하여 여러 관계를 요청할 수 있으며 , 중첩 된 관계 이름은 점으로 구분 된 관계 이름 시퀀스를 사용하여 지정할 수 있습니다. 따라서 게시물의 의견과 해당 의견의 작성자 모두를 요청하려면 다음과 같이 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="b1257af504d574f79a9e631c64fb0753d98ae623" translate="yes" xml:space="preserve">
          <source>Multiple relationships can be requested using an &lt;code&gt;include&lt;/code&gt; parameter consisting of a comma-separated list (without white-space) while nested relationships can be specified using a dot-separated sequence of relationship names. So to request both the posts' comments and the authors of those comments the request would look like this:</source>
          <target state="translated">쉼표로 구분 된 목록 (공백없이)으로 구성된 &lt;code&gt;include&lt;/code&gt; 매개 변수를 사용하여 여러 관계를 요청할 수 있으며 , 중첩 된 관계 이름은 점으로 구분 된 관계 이름 시퀀스를 사용하여 지정할 수 있습니다. 따라서 게시물의 의견과 해당 의견의 작성자 모두를 요청하려면 요청은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="702d485741e89433e6e857322e216f0b9ae4a268" translate="yes" xml:space="preserve">
          <source>Must be truthy for the assertion to pass. If falsy, an exception will be thrown.</source>
          <target state="translated">주장이 통과하려면 진실해야합니다. 거짓 인 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d3267ee70dd314e7858273af7bdce38d29cc032" translate="yes" xml:space="preserve">
          <source>MutableArray</source>
          <target state="translated">MutableArray</target>
        </trans-unit>
        <trans-unit id="b34428639511f271396957f0dadabc146059f39f" translate="yes" xml:space="preserve">
          <source>MutableEnumerable</source>
          <target state="translated">MutableEnumerable</target>
        </trans-unit>
        <trans-unit id="444db15bd436aba203a5f5249e2de3679767da5f" translate="yes" xml:space="preserve">
          <source>NOTE: For performance reasons, you cannot declare methods or computed properties during &lt;code&gt;create&lt;/code&gt;. You should instead declare methods and computed properties when using &lt;code&gt;extend&lt;/code&gt;.</source>
          <target state="translated">참고 : 성능상의 이유로 &lt;code&gt;create&lt;/code&gt; 동안 메서드 나 계산 된 속성을 선언 할 수 없습니다 . 대신 &lt;code&gt;extend&lt;/code&gt; 사용시 메소드 및 계산 된 특성을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc4154a7358ac4c037dceca9b28d5e787994cdb5" translate="yes" xml:space="preserve">
          <source>NOTE: If you do override &lt;code&gt;init&lt;/code&gt; for a framework class like &lt;code&gt;Ember.View&lt;/code&gt;, be sure to call &lt;code&gt;this._super(...arguments)&lt;/code&gt; in your &lt;code&gt;init&lt;/code&gt; declaration! If you don't, Ember may not have an opportunity to do important setup work, and you'll see strange behavior in your application.</source>
          <target state="translated">참고 : &lt;code&gt;Ember.View&lt;/code&gt; 와 같은 프레임 워크 클래스에 대해 &lt;code&gt;init&lt;/code&gt; 를 재정의하는 경우 &lt;code&gt;init&lt;/code&gt; 선언 에서 &lt;code&gt;this._super(...arguments)&lt;/code&gt; 를 호출하십시오 ! 그렇지 않으면 Ember가 중요한 설정 작업을 수행 할 기회가 없을 수 있으며 응용 프로그램에 이상한 동작이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f1955b8da16f9aa4c86eaa507166aa1db45a4ada" translate="yes" xml:space="preserve">
          <source>NOTE: The alias should not reuse a name from the bound property path.</source>
          <target state="translated">참고 : 별칭은 바인딩 된 속성 경로의 이름을 재사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="translated">명명 된 인수</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="1da3a41b20375b2f1b43865d0bbcd472ab17276d" translate="yes" xml:space="preserve">
          <source>Namespace for injection helper methods.</source>
          <target state="translated">주입 헬퍼 메소드의 네임 스페이스.</target>
        </trans-unit>
        <trans-unit id="447fb7bdde41273609f10df97bcb34cfc64373fe" translate="yes" xml:space="preserve">
          <source>Namespaced attributes (e.g. &lt;code&gt;xlink:href&lt;/code&gt;) are supported, but have to be mapped, since &lt;code&gt;:&lt;/code&gt; is not a valid character for properties in Javascript:</source>
          <target state="translated">네임 스페이스 특성 (예 &lt;code&gt;xlink:href&lt;/code&gt; 이후), 지원되지만 매핑 할 수있다 &lt;code&gt;:&lt;/code&gt; 자바 스크립트의 속성에 대한 유효한 문자가되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="0194361330bfd11c031b2f9a21891a7b0c91227e" translate="yes" xml:space="preserve">
          <source>Native arrays will no longer implement the functionality needed to observe them. If you disable prototype extension and attempt to use native arrays with things like a template's &lt;code&gt;{{#each}}&lt;/code&gt; helper, Ember.js will have no way to detect changes to the array and the template will not update as the underlying array changes.</source>
          <target state="translated">기본 배열은 더 이상 관찰에 필요한 기능을 구현하지 않습니다. 프로토 타입 확장을 비활성화하고 템플릿의 &lt;code&gt;{{#each}}&lt;/code&gt; 헬퍼 와 같은 기본 배열을 사용하려고하면 Ember.js는 배열의 변경을 감지 할 방법이 없으며 기본 배열이 변경 될 때 템플릿이 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2ad1cc0d104518d7f977f6281c3fcd146fbd3d7" translate="yes" xml:space="preserve">
          <source>NativeArray</source>
          <target state="translated">NativeArray</target>
        </trans-unit>
        <trans-unit id="f03a4f8a865506a656451836ba3d745b0e85935f" translate="yes" xml:space="preserve">
          <source>Navigating the Inspector</source>
          <target state="translated">인스펙터 탐색</target>
        </trans-unit>
        <trans-unit id="f5f74a08b7244da0d1e71c555988da0c10984a2a" translate="yes" xml:space="preserve">
          <source>Navigating with Links and the {{link-to}} Helper</source>
          <target state="translated">링크 및 {{link-to}} 도우미를 사용하여 탐색</target>
        </trans-unit>
        <trans-unit id="fbdea6bea0c2482852e3f2071895d1585ec8e658" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">중첩 된 &lt;code&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f39bf32df616d09a91ab62108acfaade500b9df8" translate="yes" xml:space="preserve">
          <source>Nested Helpers</source>
          <target state="translated">중첩 된 도우미</target>
        </trans-unit>
        <trans-unit id="d7217f3faabc627d5f38d65ad54b2ccfdec8cc27" translate="yes" xml:space="preserve">
          <source>Nested Route with Query String Example</source>
          <target state="translated">쿼리 문자열이 포함 된 중첩 경로 예</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">중첩 경로</target>
        </trans-unit>
        <trans-unit id="412558433783fdb3414d06e750eef597720539fc" translate="yes" xml:space="preserve">
          <source>Nested Usage</source>
          <target state="translated">중첩 된 사용법</target>
        </trans-unit>
        <trans-unit id="e165e036879af1052e8bdc5248b80fa0f1e05752" translate="yes" xml:space="preserve">
          <source>Nested relationships can be specified in the &lt;code&gt;include&lt;/code&gt; parameter as a dot-separated sequence of relationship names. So to request both the post's comments and the authors of those comments the request would look like this:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 매개 변수 에 내포 된 관계는 점으로 구분 된 관계 이름 순서로 지정할 수 있습니다 . 따라서 게시물의 의견과 해당 의견의 작성자 모두를 요청하려면 다음과 같이 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="3c887b79e918144869d1815b78826218b269b1e7" translate="yes" xml:space="preserve">
          <source>Nesting built-in helpers</source>
          <target state="translated">중첩 된 내장 헬퍼</target>
        </trans-unit>
        <trans-unit id="0a6f6b6b3aa81f4339caf3807d89ac25f55b20e0" translate="yes" xml:space="preserve">
          <source>New CP syntax RFC</source>
          <target state="translated">새로운 CP 구문 RFC</target>
        </trans-unit>
        <trans-unit id="b7923e40f58719cc79ac4b24075ea07f4e514c24" translate="yes" xml:space="preserve">
          <source>New array with specified slice</source>
          <target state="translated">지정된 슬라이스를 가진 새로운 배열</target>
        </trans-unit>
        <trans-unit id="33d942259592ddfbc46880fa0a69c8975fc1398b" translate="yes" xml:space="preserve">
          <source>New computed syntax explained in &quot;Ember 1.12 released&quot;</source>
          <target state="translated">&quot;Ember 1.12 릴리스&quot;에 설명 된 새로운 계산 구문</target>
        </trans-unit>
        <trans-unit id="a6fffbbf5a5a931d1edec274552843e555a9575b" translate="yes" xml:space="preserve">
          <source>New features are added to Ember.js within conditional statements.</source>
          <target state="translated">조건문 내에서 Ember.js에 새로운 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="803ecd92179c0dd3c69731cdda3a859bd14900b2" translate="yes" xml:space="preserve">
          <source>Next let's look at testing logic found within an object's method. In this case the &lt;code&gt;testMethod&lt;/code&gt; method alters some internal state of the object (by updating the &lt;code&gt;foo&lt;/code&gt; property).</source>
          <target state="translated">다음으로 객체의 메소드 내에서 발견 된 테스트 로직을 살펴 보자. 이 경우 &lt;code&gt;testMethod&lt;/code&gt; 메소드는 &lt;code&gt;foo&lt;/code&gt; 특성 을 업데이트하여 오브젝트의 일부 내부 상태를 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="e6d2115d3a8d9cff7fd04e688c7081d086bf8c63" translate="yes" xml:space="preserve">
          <source>Next we use &lt;code&gt;this.subject()&lt;/code&gt; to get an instance of the &lt;code&gt;PostsController&lt;/code&gt; and write a test to check the action. &lt;code&gt;this.subject()&lt;/code&gt; is a helper method from the &lt;code&gt;ember-qunit&lt;/code&gt; library that returns a singleton instance of the module set up using &lt;code&gt;moduleFor&lt;/code&gt;.</source>
          <target state="translated">다음으로 &lt;code&gt;this.subject()&lt;/code&gt; 를 사용 하여 &lt;code&gt;PostsController&lt;/code&gt; 의 인스턴스를 얻고 테스트를 작성하여 동작을 확인합니다. &lt;code&gt;this.subject()&lt;/code&gt; 로부터 헬퍼 메소드 인 &lt;code&gt;ember-qunit&lt;/code&gt; 모듈의 단일 인스턴스를 사용하여 설정 반환 라이브러리 &lt;code&gt;moduleFor&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4fcc0bdd99f88cb81ef0b1774094121f146d3dd1" translate="yes" xml:space="preserve">
          <source>Next, in the child component we will implement the logic to confirm that the user wants to take the action they indicated by clicking the button:</source>
          <target state="translated">다음으로, 하위 컴포넌트에서 사용자가 버튼을 클릭하여 표시된 조치를 취하고 있는지 확인하는 논리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d40ada7307cf0a9c838ea79345644c54523ae5fb" translate="yes" xml:space="preserve">
          <source>Next, update the component to append the map output to the &lt;code&gt;div&lt;/code&gt; element we created.</source>
          <target state="translated">그런 다음 구성 요소를 업데이트하여 생성 한 &lt;code&gt;div&lt;/code&gt; 요소에 맵 출력을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7d19405fca795913088d60133cbb443100ac674" translate="yes" xml:space="preserve">
          <source>Next, we can update the template for our show route (&lt;code&gt;app/templates/rentals/show.hbs&lt;/code&gt;) and list the information for our rental.</source>
          <target state="translated">다음으로, 쇼 경로 ( &lt;code&gt;app/templates/rentals/show.hbs&lt;/code&gt; ) 의 템플릿을 업데이트하고 대여 정보를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4983c90fa60bc1ce9b9cbde2c331eec343b491" translate="yes" xml:space="preserve">
          <source>Next, we want to edit our &lt;code&gt;show&lt;/code&gt; route to retrieve the requested rental:</source>
          <target state="translated">다음으로 우리는 &lt;code&gt;show&lt;/code&gt; 요청 된 대여를 검색하기 위해 쇼 경로를 합니다.</target>
        </trans-unit>
        <trans-unit id="eb92e1d792e18cf5b9e39f3b1be27814a2469e18" translate="yes" xml:space="preserve">
          <source>Next, we will want to create a sub-route that will list information for a specific rental. To do this, we will need to update a couple of files. To find a specific rental, we will want to use Ember Data's &lt;code&gt;findRecord&lt;/code&gt; function &lt;a href=&quot;https://guides.emberjs.com/models/finding-records/&quot;&gt;(see &quot;Finding Records&quot; for more details)&lt;/a&gt;. The &lt;code&gt;findRecord&lt;/code&gt; function requires that we search by a unique key.</source>
          <target state="translated">다음으로 특정 임대에 대한 정보를 나열하는 하위 경로를 만들려고합니다. 이렇게하려면 몇 개의 파일을 업데이트해야합니다. 특정 임대를 찾으려면 Ember Data의 &lt;code&gt;findRecord&lt;/code&gt; 기능 을 사용 하려고 합니다 &lt;a href=&quot;https://guides.emberjs.com/models/finding-records/&quot;&gt;(자세한 내용은 &quot;레코드 찾기&quot;참조)&lt;/a&gt; . 그만큼 &lt;code&gt;findRecord&lt;/code&gt; 의 기능은 우리가 고유 키로 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="72fd14162a8fc6d22cf491834da27111df0b38b5" translate="yes" xml:space="preserve">
          <source>Next, we'll add the call to render the component to show the cities we've provided above.</source>
          <target state="translated">다음으로 위에서 제공 한 도시를 표시하기 위해 구성 요소를 렌더링하는 호출을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c121b18448e09b0ec7e3e82982b599fd9f5138e7" translate="yes" xml:space="preserve">
          <source>Next, we'll update the template using the component to use the block form:</source>
          <target state="translated">다음으로 블록 형식을 사용하도록 구성 요소를 사용하여 템플릿을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="6238b29303602319e16359dcf2e606b1c95d24d7" translate="yes" xml:space="preserve">
          <source>No documented items</source>
          <target state="translated">문서화 된 항목이 없습니다</target>
        </trans-unit>
        <trans-unit id="9f80f5f1ae4b98a019524e97caf59f7371e4c299" translate="yes" xml:space="preserve">
          <source>No matter how the URL gets set, the first thing that happens is that the Ember router maps the URL to a route handler.</source>
          <target state="translated">URL 설정 방법에 관계없이 가장 먼저 발생하는 일은 Ember 라우터가 URL을 경로 처리기에 매핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36d42b52bca7ec360e2ec2fd821e5d1d54eeed7e" translate="yes" xml:space="preserve">
          <source>Node.js and npm</source>
          <target state="translated">Node.js와 npm</target>
        </trans-unit>
        <trans-unit id="0bf1b177f41054dc701a64cbc840b3185281c706" translate="yes" xml:space="preserve">
          <source>NoneLocation</source>
          <target state="translated">NoneLocation</target>
        </trans-unit>
        <trans-unit id="2b92c9cfcc2262b2f6c3b43f6b3500b694ae1ee6" translate="yes" xml:space="preserve">
          <source>Normal arguments are useful for passing data to be transformed into helper functions. However, because the order in which you pass arguments matters, it is usually best not to have helpers take more than one or two of them.</source>
          <target state="translated">일반 인수는 데이터를 도우미 함수로 변환 할 때 유용합니다. 그러나 인수를 전달하는 순서가 중요하기 때문에 일반적으로 도우미가 한두 가지 이상을 가져 가지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c758641d7044d0875a095185bfa3bfff0989861e" translate="yes" xml:space="preserve">
          <source>Normalize the record and recursively normalize/extract all the embedded records while pushing them into the store as they are encountered</source>
          <target state="translated">레코드를 정규화하고 모든 내장 레코드를 재발 적으로 정규화 / 추출합니다.</target>
        </trans-unit>
        <trans-unit id="507e2c4b6bfe50777b8493cb99f3d2061997fa17" translate="yes" xml:space="preserve">
          <source>Normalizes a part of the JSON payload returned by the server. You should override this method, munge the hash and call super if you have generic normalization to do.</source>
          <target state="translated">서버에서 반환 한 JSON 페이로드의 일부를 정규화합니다. 일반 정규화를 수행하려면이 메소드를 대체하고 해시를 제거하고 super를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="93184070eecd1992aa3ceffecf5d7e446dd037ad" translate="yes" xml:space="preserve">
          <source>Normalizing adapter responses</source>
          <target state="translated">어댑터 응답 정규화</target>
        </trans-unit>
        <trans-unit id="36175f91b69faec22cd1a2cefc739e08dcc8e5d5" translate="yes" xml:space="preserve">
          <source>Normally you should not need to invoke this method yourself. However if you are implementing raw event handlers when interfacing with other libraries or plugins, you should probably wrap all of your code inside this call.</source>
          <target state="translated">일반적으로이 메소드를 직접 호출 할 필요는 없습니다. 그러나 다른 라이브러리 또는 플러그인과 인터페이스 할 때 원시 이벤트 핸들러를 구현하는 경우이 호출 내에 모든 코드를 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="4468565835878ef17cd4b55bc5caa9b1777c240f" translate="yes" xml:space="preserve">
          <source>Normally, Ember's component model is &quot;write-only&quot;. The component takes a bunch of attributes that it got passed in, and uses them to render its template.</source>
          <target state="translated">일반적으로 Ember의 컴포넌트 모델은 &quot;쓰기 전용&quot;입니다. 컴포넌트는 전달 된 많은 속성을 가져 와서 템플릿을 렌더링하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7e6a52c08a7259c6321ad9e83e1ba7332c71dcf" translate="yes" xml:space="preserve">
          <source>Normally, applications will use the &lt;code&gt;RESTSerializer&lt;/code&gt; by implementing the &lt;code&gt;normalize&lt;/code&gt; method.</source>
          <target state="translated">일반적으로 애플리케이션은 &lt;code&gt;normalize&lt;/code&gt; 메소드 를 구현하여 &lt;code&gt;RESTSerializer&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fc8af1aedfdbf84e674633bf407822f6539d0133" translate="yes" xml:space="preserve">
          <source>Not all APIs follow the conventions that the &lt;code&gt;JSONAPISerializer&lt;/code&gt; uses with a data namespace and sideloaded relationship records. Some legacy APIs may return a simple JSON payload that is just the requested resource or an array of serialized records. The &lt;code&gt;JSONSerializer&lt;/code&gt; is a serializer that ships with Ember Data that can be used alongside the &lt;code&gt;RESTAdapter&lt;/code&gt; to serialize these simpler APIs.</source>
          <target state="translated">모든 API가 &lt;code&gt;JSONAPISerializer&lt;/code&gt; 가 데이터 네임 스페이스 및 사이드로드 된 관계 레코드와 함께 사용 하는 규칙을 따르는 것은 아닙니다 . 일부 레거시 API는 요청 된 리소스 또는 일련 화 된 레코드 배열 인 간단한 JSON 페이로드를 반환 할 수 있습니다. &lt;code&gt;JSONSerializer&lt;/code&gt; 는 함께 사용할 수있는 엠버 데이터와 함께 제공하는 시리얼입니다 &lt;code&gt;RESTAdapter&lt;/code&gt; 는 이 간단한 API를 직렬화.</target>
        </trans-unit>
        <trans-unit id="ffb02f7d9bf0cc53a282a795dbaa82e1fca2c00b" translate="yes" xml:space="preserve">
          <source>Not all combinations of the supported options are valid. See the documentation on &lt;code&gt;Ember.Application#visit&lt;/code&gt; for the supported configurations.</source>
          <target state="translated">지원되는 옵션의 모든 조합이 유효한 것은 아닙니다. 지원되는 구성 에 &lt;code&gt;Ember.Application#visit&lt;/code&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9023fcc452af3baa532d621308c25e1e7a89cfd0" translate="yes" xml:space="preserve">
          <source>Not all options need to be passed to &lt;code&gt;render&lt;/code&gt;. Default values will be used based on the name of the route specified in the router or the Route's &lt;code&gt;controllerName&lt;/code&gt; and &lt;code&gt;templateName&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 하기 위해 모든 옵션을 전달할 필요는 없습니다 . 라우터에 지정된 경로 이름 또는 경로의 &lt;code&gt;controllerName&lt;/code&gt; 및 &lt;code&gt;templateName&lt;/code&gt; 속성 에 따라 기본값이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ba9a00d7a0449cb290ce3ad1120d3aa3636a895" translate="yes" xml:space="preserve">
          <source>Not to be confused with Shadow DOM. The concept of a virtual DOM means abstracting your code (or in our case, Ember) away from using the browser's DOM in favor of a &quot;virtual&quot; DOM that can easily be accessed for read/writes or even serialized.</source>
          <target state="translated">Shadow DOM과 혼동하지 마십시오. 가상 DOM의 개념은 읽기 / 쓰기 또는 직렬화를 위해 쉽게 액세스 할 수있는 &quot;가상&quot;DOM을 위해 브라우저의 DOM을 사용하지 않도록 코드 (또는이 경우 Ember)를 추상화하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8cdf5c376933ccf1cfee5b424cfd3739a998e8c7" translate="yes" xml:space="preserve">
          <source>Not to be confused with Virtual DOM. Shadow DOM is still a work in progress, but basically a proposed way to have an &quot;isolated&quot; DOM encapsulated within your app's DOM.</source>
          <target state="translated">Virtual DOM과 혼동하지 마십시오. Shadow DOM은 여전히 ​​진행중인 작업이지만 기본적으로 앱의 DOM 내에 &quot;격리 된&quot;DOM을 캡슐화하도록 제안 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9e207619ed228ed5f64d1d93956ce95d0f0e4129" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@each&lt;/code&gt; only works one level deep. You cannot use nested forms like &lt;code&gt;todos.@each.owner.name&lt;/code&gt; or &lt;code&gt;todos.@each.owner.@each.name&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;@each&lt;/code&gt; 은 단 하나 수준의 깊이를 작동합니다. &lt;code&gt;todos.@each.owner.name&lt;/code&gt; 또는 &lt;code&gt;todos.@each.owner.@each.name&lt;/code&gt; 과 같은 중첩 양식을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b78a2d350219decae3de8dbd9a934a76cc3210ab" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;deleteCurrentUser&lt;/code&gt; is no longer in quotes here as opposed to &lt;a href=&quot;#toc_passing-the-action-to-the-component&quot;&gt;previously&lt;/a&gt;. Quotes are used to initially pass the action down the component tree, but at every subsequent level you are instead passing the actual function reference (without quotes) in the action helper.</source>
          <target state="translated">참고 &lt;code&gt;deleteCurrentUser&lt;/code&gt; 는 반대로 여기에 인용 부호로 더 이상 &lt;a href=&quot;#toc_passing-the-action-to-the-component&quot;&gt;이전에&lt;/a&gt; . 따옴표는 처음에 컴포넌트 트리 아래로 조치를 전달하는 데 사용되지만 이후의 모든 레벨에서 조치 도우미의 실제 함수 참조 (따옴표없이)를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d657c22ecaee4c7aa7dc607d48a3471b79573dbd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;frozenCopy()&lt;/code&gt; will only work if you also implement &lt;code&gt;Ember.Freezable&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;frozenCopy()&lt;/code&gt; 당신은 또한 구현하는 경우에만 작동합니다 &lt;code&gt;Ember.Freezable&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f6e566c79c98a818eb2e7a547fefdc2888a15607" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;species&lt;/code&gt; and &lt;code&gt;createPerson&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; valid on the &lt;code&gt;tom&lt;/code&gt; and &lt;code&gt;yehuda&lt;/code&gt; variables. They are only valid on &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">주의 &lt;code&gt;species&lt;/code&gt; 과 &lt;code&gt;createPerson&lt;/code&gt; 가 있습니다 &lt;em&gt;하지&lt;/em&gt; 상의 유효한 &lt;code&gt;tom&lt;/code&gt; 과 &lt;code&gt;yehuda&lt;/code&gt; 변수. 이들은 &lt;code&gt;Person&lt;/code&gt; 에서만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="06970be1fcab9740b07ebf6451f16d6c3ba5f22e" translate="yes" xml:space="preserve">
          <source>Note that Ember's default &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;JSON API adapter&lt;/a&gt; does not provide the functionality needed to support &lt;code&gt;queryRecord()&lt;/code&gt; directly as it relies on REST request definitions that return result data in the form of an array.</source>
          <target state="translated">Ember의 기본 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;JSON API 어댑터&lt;/a&gt; 는 배열 형식으로 결과 데이터를 리턴하는 REST 요청 정의에 의존하므로 &lt;code&gt;queryRecord()&lt;/code&gt; 직접 지원하는 데 필요한 기능을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b8f582b0e70af7be068ecb7c92ee2cd1ea0f779d" translate="yes" xml:space="preserve">
          <source>Note that JSON-API also allows for object-level errors to be placed in an object with pointer &lt;code&gt;data&lt;/code&gt;, signifying that the problem cannot be traced to a specific attribute:</source>
          <target state="translated">JSON-API를 사용하면 포인터 수준의 &lt;code&gt;data&lt;/code&gt; 가있는 객체에 객체 수준 오류를 배치 할 수 있으므로 문제를 특정 속성으로 추적 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32b55a648a9226930f8a0dc87f4729a007906a54" translate="yes" xml:space="preserve">
          <source>Note that Mixins are created with &lt;code&gt;Ember.Mixin.create&lt;/code&gt;, not &lt;code&gt;Ember.Mixin.extend&lt;/code&gt;.</source>
          <target state="translated">Mixins은 &lt;code&gt;Ember.Mixin.create&lt;/code&gt; 가 아니라 &lt;code&gt;Ember.Mixin.extend&lt;/code&gt; 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="56b757d1d62e955259b537c65a5b0f0df274acce" translate="yes" xml:space="preserve">
          <source>Note that actions may be attached to any element of the DOM, but not all respond to the &lt;code&gt;click&lt;/code&gt; event. For example, if an action is attached to an &lt;code&gt;a&lt;/code&gt; link without an &lt;code&gt;href&lt;/code&gt; attribute, or to a &lt;code&gt;div&lt;/code&gt;, some browsers won't execute the associated function. If it's really needed to define actions over such elements, a CSS workaround exists to make them clickable, &lt;code&gt;cursor: pointer&lt;/code&gt;. For example:</source>
          <target state="translated">액션은 DOM의 모든 요소에 첨부 될 수 있지만 &lt;code&gt;click&lt;/code&gt; 이벤트에 모두 응답하는 것은 아닙니다 . 조치가 부착되는 경우, 예를 들어 없이 링크 &lt;code&gt;href&lt;/code&gt; 특성, 또는에 &lt;code&gt;div&lt;/code&gt; 일부 브라우저 연관된 기능을 실행하지 않을 것이다. 이러한 요소에 대한 조치를 정의해야하는 경우 CSS 조치가 존재하여 해당 요소를 클릭 가능하게 만들 수 있습니다 . &lt;code&gt;cursor: pointer&lt;/code&gt; . 예를 들면 다음과 같습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0e6cdf5e195bb9b233c0037678ccb4b71a62dca" translate="yes" xml:space="preserve">
          <source>Note that although you can pass optional arguments these will not be considered when looking for duplicates. New arguments will replace previous calls.</source>
          <target state="translated">선택적 인수를 전달할 수 있지만 중복을 찾을 때는 고려되지 않습니다. 새로운 주장은 이전의 전화를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c9855a05b5c5c77b57064406fd84a06bcd0a8dc0" translate="yes" xml:space="preserve">
          <source>Note that an Array can change even if it does not implement this mixin. For example, one might implement a SparseArray that cannot be directly modified, but if its underlying enumerable changes, it will change also.</source>
          <target state="translated">이 믹스 인을 구현하지 않아도 Array는 변경 될 수 있습니다. 예를 들어 직접 수정할 수없는 SparseArray를 구현할 수 있지만 기본 열거 가능한 변경 사항도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3521e07c4a5492836c834d2874a2f36b14039567" translate="yes" xml:space="preserve">
          <source>Note that an Enumerable can change even if it does not implement this mixin. For example, a MappedEnumerable cannot be directly modified but if its underlying enumerable changes, it will change also.</source>
          <target state="translated">Enumerable은이 믹스 인을 구현하지 않더라도 변경할 수 있습니다. 예를 들어 MappedEnumerable은 직접 수정할 수 없지만 기본 열거 가능한 변경 사항이 있으면 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="924886ebe747f409911384465b52739f93291a0f" translate="yes" xml:space="preserve">
          <source>Note that an optional parameter can be sent to a record's &lt;code&gt;send()&lt;/code&gt; method, which will be passed as the second parameter to the event handler.</source>
          <target state="translated">선택적 매개 변수는 레코드의 &lt;code&gt;send()&lt;/code&gt; 메소드 로 전송 될 수 있으며 ,이 매개 변수는 두 번째 매개 변수로 이벤트 핸들러에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="33c0dee324e64567f69ae25ca1d96c1e702d98c2" translate="yes" xml:space="preserve">
          <source>Note that at this point of the tutorial, the data is still provided by the &lt;code&gt;app/routes/rentals.js&lt;/code&gt; file. We will make use of the mirage data we set up here in the upcoming section called &lt;a href=&quot;../ember-data&quot;&gt;Using Ember Data&lt;/a&gt;.</source>
          <target state="translated">학습서의 현재 시점에서 데이터는 여전히 &lt;code&gt;app/routes/rentals.js&lt;/code&gt; 파일에 의해 제공됩니다 . 다음에 &lt;a href=&quot;../ember-data&quot;&gt;Ember Data 사용하기&lt;/a&gt; 섹션에서 설정 한 mirage 데이터를 사용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1e9fe44fe234ff341d449b15a171ed9251b8aad4" translate="yes" xml:space="preserve">
          <source>Note that because it's just a filter, the result will contain any locally created records of the type, however, it will not make a request to the backend to retrieve additional records. If you would like to request all the records from the backend please use &lt;a href=&quot;#method_findAll&quot;&gt;store.findAll&lt;/a&gt;.</source>
          <target state="translated">필터 일 뿐이므로 결과적으로 로컬로 생성 된 유형의 레코드가 포함되지만 백엔드에 추가 레코드를 검색하도록 요청하지는 않습니다. 백엔드에서 모든 레코드를 요청하려면 &lt;a href=&quot;#method_findAll&quot;&gt;store.findAll을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0838905b21f58bd42b79e4b1f7728fbd5f10b750" translate="yes" xml:space="preserve">
          <source>Note that bindings don't update immediately. Ember waits until all of your application code has finished running before synchronizing changes, so you can change a bound property as many times as you'd like without worrying about the overhead of syncing bindings when values are transient.</source>
          <target state="translated">바인딩은 즉시 업데이트되지 않습니다. Ember는 변경 사항을 동기화하기 전에 모든 응용 프로그램 코드의 실행이 끝날 때까지 대기하므로 값이 일시적 일 때 바인딩 동기화의 오버 헤드에 대해 걱정하지 않고 원하는만큼 바인딩 된 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958456bed5d43bbdc211b8f3e852be80e1eafc1d" translate="yes" xml:space="preserve">
          <source>Note that destruction is scheduled for the end of the run loop and does not happen immediately. It will set an isDestroying flag immediately.</source>
          <target state="translated">소멸은 실행 루프의 끝으로 예정되어 있으며 즉시 발생하지 않습니다. isDestroying 플래그를 즉시 설정합니다.</target>
        </trans-unit>
        <trans-unit id="02fedd1822a65dfaf8b470cacfe5d1ddfd042c45" translate="yes" xml:space="preserve">
          <source>Note that embedded records will serialize with the serializer for their model instead of the serializer in which they are defined.</source>
          <target state="translated">임베드 된 레코드는 모델이 정의 된 직렬 변환기 대신 직렬 변환기와 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf60f3cfbf501d3dcffb7089a351e863fd21b98" translate="yes" xml:space="preserve">
          <source>Note that for curly components (&lt;code&gt;{{my-component}}&lt;/code&gt;) the bindings are already mutable, making the &lt;code&gt;mut&lt;/code&gt; unnecessary.</source>
          <target state="translated">곱슬 컴포넌트 ( &lt;code&gt;{{my-component}}&lt;/code&gt; )의 경우 바인딩이 이미 변경 가능하므로 &lt;code&gt;mut&lt;/code&gt; 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="8fa797c14ae391330eeeed89571db0017aff4300" translate="yes" xml:space="preserve">
          <source>Note that for performance reasons, while calling &lt;code&gt;create()&lt;/code&gt; you cannot redefine an instance's computed properties and should not redefine existing or define new methods. You should only set simple properties when calling &lt;code&gt;create()&lt;/code&gt;. If you need to define or redefine methods or computed properties, create a new subclass and instantiate that.</source>
          <target state="translated">성능상의 이유로 &lt;code&gt;create()&lt;/code&gt; 를 호출하는 동안 인스턴스의 계산 된 속성을 재정의 할 수 없으며 기존 메서드를 재정의하거나 새 메서드를 정의해서는 안됩니다. &lt;code&gt;create()&lt;/code&gt; 호출 할 때 간단한 속성 만 설정해야합니다 . 메소드 또는 계산 된 특성을 정의하거나 재정의해야하는 경우 새 서브 클래스를 작성하고 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="3fce3689a0766225ec48133f04e1b60a1d8c9390" translate="yes" xml:space="preserve">
          <source>Note that for routes with dynamic segments, this hook is not always executed. If the route is entered through a transition (e.g. when using the &lt;code&gt;link-to&lt;/code&gt; Handlebars helper or the &lt;code&gt;transitionTo&lt;/code&gt; method of routes), and a model context is already provided this hook is not called.</source>
          <target state="translated">동적 세그먼트가있는 경로의 경우이 후크가 항상 실행되는 것은 아닙니다. 경로가 전환을 통해 입력 된 경우 (예 : &lt;code&gt;link-to&lt;/code&gt; 핸들 핸들 도우미 또는 경로 의 &lt;code&gt;transitionTo&lt;/code&gt; 메소드를 사용하는 경우) 모델 컨텍스트가 이미 제공된 경우이 후크가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40e020d503512efc885004b76ea4846ffd6830fc" translate="yes" xml:space="preserve">
          <source>Note that here, we are using the ES6 shorthand method definition syntax: &lt;code&gt;model()&lt;/code&gt; is the same as writing &lt;code&gt;model: function()&lt;/code&gt;.</source>
          <target state="translated">여기서는 ES6 속기 메소드 정의 구문을 사용합니다. &lt;code&gt;model()&lt;/code&gt; 은 &lt;code&gt;model: function()&lt;/code&gt; 작성과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="afeb106af344e9d52a516511d31b13a986723101" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;propertyKey&lt;/code&gt; is a computed property, the observer will be called when any of the property dependencies are changed, even if the resulting value of the computed property is unchanged. This is necessary because computed properties are not computed until &lt;code&gt;get&lt;/code&gt; is called.</source>
          <target state="translated">경우 유의 &lt;code&gt;propertyKey&lt;/code&gt; 가 계산 속성 인 속성 종속성 중 하나가 변경 될 때, 관찰자가 계산 된 특성의 결과 값이 변하지 않더라도, 호출된다. &lt;code&gt;get&lt;/code&gt; 이 호출 될 때까지 계산 된 속성이 계산되지 않기 때문에이 작업이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="3feff379f3ec37882e3c4043a045e926ad0b8051" translate="yes" xml:space="preserve">
          <source>Note that if the object itself is &lt;code&gt;undefined&lt;/code&gt;, this method will throw an error.</source>
          <target state="translated">객체 자체가 &lt;code&gt;undefined&lt;/code&gt; 인 경우이 메소드는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="540f116cbff565163df0174c504c06f99d5cfbf7" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &quot;this&quot; on the context. This is a good way to give your iterator function access to the current object.</source>
          <target state="translated">콜백 외에도 컨텍스트에서 &quot;this&quot;로 설정 될 선택적 대상 객체를 전달할 수도 있습니다. 이것은 iterator 함수에 현재 객체에 대한 액세스 권한을 부여하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5c955a4684ca89b99f35640968f2c4ee63c05c39" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &lt;code&gt;this&lt;/code&gt; on the context.</source>
          <target state="translated">콜백 이외에, 당신은 또한로 설정됩니다 옵션 대상 객체 통과 할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 상황에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43847d45892775735670813b1ca175dda47767b" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &lt;code&gt;this&lt;/code&gt; on the context. This is a good way to give your iterator function access to the current object.</source>
          <target state="translated">콜백 이외에, 당신은 또한로 설정됩니다 옵션 대상 객체 통과 할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 상황에 있습니다. 이것은 iterator 함수에 현재 객체에 대한 액세스 권한을 부여하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f2e78eacf4a6f2eb923292be3495f30dd476f1f2" translate="yes" xml:space="preserve">
          <source>Note that it is traditional but not required to prefix localized string keys with an underscore or other character so you can easily identify localized strings.</source>
          <target state="translated">현지화 된 문자열 키 앞에 밑줄이나 다른 문자를 붙이는 것이 일반적이지만 필수는 아니므로 현지화 된 문자열을 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a511380c7d51e6b8aa92a6d9dbd7dd96985267fc" translate="yes" xml:space="preserve">
          <source>Note that like the native &lt;code&gt;Array.every&lt;/code&gt;, &lt;code&gt;isEvery&lt;/code&gt; will return true when called on any empty enumerable.</source>
          <target state="translated">네이티브 같은 것을 참고 &lt;code&gt;Array.every&lt;/code&gt; , &lt;code&gt;isEvery&lt;/code&gt; 는 빈 열거 호출 할 때 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="3cbb28c77f6e351fc1928e6220e782dc362a1b2a" translate="yes" xml:space="preserve">
          <source>Note that mixins extend a constructor's prototype so arrays and object literals defined as properties will be shared amongst objects that implement the mixin. If you want to define a property in a mixin that is not shared, you can define it either as a computed property or have it be created on initialization of the object.</source>
          <target state="translated">믹스 인은 생성자의 프로토 타입을 확장하므로 속성으로 정의 된 배열과 객체 리터럴은 믹스 인을 구현하는 객체간에 공유됩니다. 공유되지 않은 믹스 인에서 속성을 정의하려는 경우 계산 된 속성으로 정의하거나 객체를 초기화 할 때 속성을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0915ee7945263956963defb8eed8d82042531b8" translate="yes" xml:space="preserve">
          <source>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</source>
          <target state="translated">순서는 같은 유형 (예 : 응용 프로그램 또는 응용 프로그램 인스턴스)의 이니셜 라이저에만 적용됩니다. 응용 프로그램 이니셜 라이저는 항상 응용 프로그램 인스턴스 이니셜 라이저보다 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a01853252476693e8ba50c063c6d95f4b2768ee1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;admin&lt;/code&gt; is now not included in the payload.</source>
          <target state="translated">점을 유의 &lt;code&gt;admin&lt;/code&gt; 이제 페이로드에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e181bf43f632a621775995506d04b89a64308a3a" translate="yes" xml:space="preserve">
          <source>Note that the Ember.Array mixin also incorporates the &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin. All &lt;code&gt;Ember.Array&lt;/code&gt;-like objects are also enumerable.</source>
          <target state="translated">Ember.Array 믹스 인에는 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 믹스 인도 포함되어 있습니다. 모든 &lt;code&gt;Ember.Array&lt;/code&gt; 와 유사한 객체도 열거 가능합니다.</target>
        </trans-unit>
        <trans-unit id="464a4e1a39f9e9d238321f795ebad418f97d241c" translate="yes" xml:space="preserve">
          <source>Note that the hash is an empty object with no prototype chain, therefore common methods like &lt;code&gt;toString&lt;/code&gt; are not available in the resulting hash. If you need to use such a method, you can use the &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; approach:</source>
          <target state="translated">해시는 프로토 타입 체인이없는 빈 객체이므로 결과 해시에서는 &lt;code&gt;toString&lt;/code&gt; 과 같은 일반적인 방법을 사용할 수 없습니다. 이러한 방법을 사용해야하는 경우 &lt;code&gt;call&lt;/code&gt; 또는 &lt;code&gt;apply&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc9566b0898e72178820bea560bb816fc27b12cd" translate="yes" xml:space="preserve">
          <source>Note that the object root can be pluralized for both a single-object response and an array response: the REST adapter is not strict on this. Further, if the HTTP server responds to a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt; (e.g. the response to a &lt;code&gt;findRecord&lt;/code&gt; query) with more than one object in the array, Ember Data will only display the object with the matching ID.</source>
          <target state="translated">단일 오브젝트 응답 및 배열 응답 모두에 대해 오브젝트 루트를 복수화 할 수 있습니다. REST 어댑터는 이에 엄격하지 않습니다. 또한 HTTP 서버 가 배열에서 둘 이상의 객체 로 &lt;code&gt;/posts/1&lt;/code&gt; 에 대한 &lt;code&gt;GET&lt;/code&gt; 요청 (예 : &lt;code&gt;findRecord&lt;/code&gt; 쿼리에 대한 응답)에 응답하면 Ember Data는 일치하는 ID를 가진 객체 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7279e9a3c8ff0311e3ca69d4c929ddaff389ce17" translate="yes" xml:space="preserve">
          <source>Note that the type is &lt;code&gt;&quot;post&quot;&lt;/code&gt; to match the post model and the &lt;code&gt;relatedPosts&lt;/code&gt; relationship in the document matches the &lt;code&gt;relatedPosts: hasMany('post')&lt;/code&gt; on the model.</source>
          <target state="translated">형식은 게시 모델과 일치하는 &lt;code&gt;&quot;post&quot;&lt;/code&gt; 이며 문서 의 &lt;code&gt;relatedPosts&lt;/code&gt; 관계는 모델 의 &lt;code&gt;relatedPosts: hasMany('post')&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="651d898d00f66933a50a90cbb6374067806121e6" translate="yes" xml:space="preserve">
          <source>Note that there are often alternatives to using &lt;code&gt;run.next&lt;/code&gt;. For instance, if you'd like to schedule an operation to happen after all DOM element operations have completed within the current run loop, you can make use of the &lt;code&gt;afterRender&lt;/code&gt; run loop queue (added by the &lt;code&gt;ember-views&lt;/code&gt; package, along with the preceding &lt;code&gt;render&lt;/code&gt; queue where all the DOM element operations happen).</source>
          <target state="translated">&lt;code&gt;run.next&lt;/code&gt; 사용에 대한 대안이 종종 있습니다. 예를 들어, 모든 DOM 요소 작업이 현재 실행 루프 내에서 완료된 후 작업이 발생하도록 예약하려면 &lt;code&gt;afterRender&lt;/code&gt; 실행 루프 큐 ( &lt;code&gt;ember-views&lt;/code&gt; 패키지 에 의해 추가됨 )와 모든 DOM 요소 작업이 발생하는 &lt;code&gt;render&lt;/code&gt; 대기열).</target>
        </trans-unit>
        <trans-unit id="378ebd8cb4393b5003287ca8dc8a822623b4efce" translate="yes" xml:space="preserve">
          <source>Note that this use of &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is unrelated to the &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; that is defined as an option on &lt;code&gt;DS.attr&lt;/code&gt; as part of defining a model while working with the &lt;code&gt;ActiveModelSerializer&lt;/code&gt;. Nevertheless, using &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; as an option to &lt;code&gt;DS.attr&lt;/code&gt; is not a valid way to setup embedded records.</source>
          <target state="translated">의 사용은주의 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 받는 관련이 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 에 옵션으로 정의되는 &lt;code&gt;DS.attr&lt;/code&gt; 와 함께 작업하는 동안 모델을 정의의 일부로서 &lt;code&gt;ActiveModelSerializer&lt;/code&gt; . 그럼에도 불구하고 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 를 &lt;code&gt;DS.attr&lt;/code&gt; 에 대한 옵션으로 사용하는 것은 임베디드 레코드를 설정하는 올바른 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f0d39521c8d3386b3a34e9ced91037feeb0a7b2a" translate="yes" xml:space="preserve">
          <source>Note that this will cause &lt;code&gt;model&lt;/code&gt; hooks to fire even on routes that were provided a model object when the route was initially entered.</source>
          <target state="translated">이로 인해 경로를 처음 입력했을 때 모델 객체가 제공된 경로에서도 &lt;code&gt;model&lt;/code&gt; 후크가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad6b52ecb990cca8134262cdb224e497f1a00b0" translate="yes" xml:space="preserve">
          <source>Note that unlike the other methods, this method does not allow you to pass a target object to set as this for the callback. It's part of the spec. Sorry.</source>
          <target state="translated">다른 메소드와 달리이 메소드를 사용하면 콜백에 대해 대상 오브젝트를 전달하여이를 설정할 수 없습니다. 사양의 일부입니다. 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="eb8695c270f1bbdd1d483514b31345a7b00a6573" translate="yes" xml:space="preserve">
          <source>Note that we've changed the title from a hard-coded string (&quot;List of Scientists&quot;) to a dynamic property (&lt;code&gt;{{title}}&lt;/code&gt;). We've also renamed &lt;code&gt;scientist&lt;/code&gt; to the more-generic &lt;code&gt;person&lt;/code&gt;, decreasing the coupling of our component to where it's used.</source>
          <target state="translated">제목이 하드 코딩 된 문자열 ( &quot;List of Scientists&quot;)에서 동적 속성 ( &lt;code&gt;{{title}}&lt;/code&gt; )으로 변경되었습니다. 또한 &lt;code&gt;scientist&lt;/code&gt; 를보다 일반적인 &lt;code&gt;person&lt;/code&gt; 개명 하여 구성 요소의 사용 위치를 줄였습니다.</target>
        </trans-unit>
        <trans-unit id="b5bce60538daed2815d21c307bbe23abc78831ea" translate="yes" xml:space="preserve">
          <source>Note that you cannot use &lt;code&gt;attr&lt;/code&gt; to define an attribute of &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;attr&lt;/code&gt; 을 사용하여 &lt;code&gt;id&lt;/code&gt; 속성을 정의 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb46a8ed0ed5ba9c5b246982b813cc010e7976e" translate="yes" xml:space="preserve">
          <source>Note that you will not generally apply this mixin to classes yourself, but you will use the features provided by this module frequently, so it is important to understand how to use it.</source>
          <target state="translated">일반적으로이 믹스 인을 클래스에 직접 적용하지는 않지만이 모듈에서 제공하는 기능을 자주 사용하므로 사용 방법을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b0597a69e13b4e14adaa25db22b7f0f4898ba79d" translate="yes" xml:space="preserve">
          <source>Note that, for polymorphism to work, Ember Data expects a &quot;type&quot; declaration polymorphic type via the reserved &lt;code&gt;type&lt;/code&gt; property on the model. Confused? See the API response below.</source>
          <target state="translated">다형성이 작동하기 위해 Ember Data는 모델 의 예약 된 &lt;code&gt;type&lt;/code&gt; 속성을 통해 &quot;유형&quot;선언 다형성 유형을 예상합니다 . 혼란 스러운가? 아래 API 응답을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1de6c308dc4f6fc162197eb2bbe65e4c36374d2" translate="yes" xml:space="preserve">
          <source>Note that, with default settings, &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; will always re-fetch all the records in the background even if &lt;code&gt;shouldReloadAll&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. You can override &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; if this does not suit your use case.</source>
          <target state="translated">그 참고 기본 설정으로, &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; 은 항상 경우에도 백그라운드에서 모든 레코드를 다시 가져옵니다 &lt;code&gt;shouldReloadAll&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; . 사용 사례에 맞지 않으면 &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; 을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d35e47cdfb2862962cfbd80e030c1179e5271e2" translate="yes" xml:space="preserve">
          <source>Note that, with default settings, &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; will always re-fetch the records in the background even if &lt;code&gt;shouldReloadRecord&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. You can override &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; if this does not suit your use case.</source>
          <target state="translated">그 참고 기본 설정으로, &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; 은 항상 경우에도 백그라운드에서 기록을 다시 가져옵니다 &lt;code&gt;shouldReloadRecord&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; . 사용 사례에 맞지 않으면 &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; 를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7b0d071a0586986d448b602cae0e1b1e36d11b" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;defaultSerializer&lt;/code&gt; serializer has a lower priority than a model specific serializer (i.e. &lt;code&gt;PostSerializer&lt;/code&gt;) or the &lt;code&gt;application&lt;/code&gt; serializer.</source>
          <target state="translated">메모 &lt;code&gt;defaultSerializer&lt;/code&gt; 의 시리얼이 모델 특정 시리얼 라이저 (즉,보다 낮은 우선 순위가 &lt;code&gt;PostSerializer&lt;/code&gt; ) 또는 &lt;code&gt;application&lt;/code&gt; 시리얼을.</target>
        </trans-unit>
        <trans-unit id="ba6d28dc5630809cf305ce67605b5bd4a3c6f88f" translate="yes" xml:space="preserve">
          <source>Note: A route with a dynamic segment will always have its &lt;code&gt;model&lt;/code&gt; hook called when it is entered via the URL. If the route is entered through a transition (e.g. when using the &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;link-to&lt;/a&gt; Handlebars helper), and a model context is provided (second argument to &lt;code&gt;link-to&lt;/code&gt;), then the hook is not executed. If an identifier (such as an id or slug) is provided instead then the model hook will be executed.</source>
          <target state="translated">참고 : 동적 세그먼트가있는 경로 는 URL을 통해 입력 될 때 항상 &lt;code&gt;model&lt;/code&gt; 후크가 호출됩니다. 경로가 전환을 통해 입력되고 (예 : &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;링크&lt;/a&gt; 핸들 핸들 도우미 를 사용하는 경우 ) 모델 컨텍스트가 제공되는 경우 ( &lt;code&gt;link-to&lt;/code&gt; 두 번째 인수 ) 후크가 실행되지 않습니다. 식별자 (예 : 아이디 또는 슬러그)가 대신 제공되면 모델 후크가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3702f2df2efc5cbf72a1cc1e1abb9bfc0930161f" translate="yes" xml:space="preserve">
          <source>Note: Although an &lt;code&gt;Application&lt;/code&gt; serves as the primary registry for an app, each &lt;code&gt;ApplicationInstance&lt;/code&gt; can also serve as a registry. Instance-level registrations are useful for providing instance-level customizations, such as A/B testing of a feature.</source>
          <target state="translated">참고 : &lt;code&gt;Application&lt;/code&gt; 은 앱의 기본 레지스트리 역할을 하지만 각 &lt;code&gt;ApplicationInstance&lt;/code&gt; 는 레지스트리 역할을 할 수도 있습니다. 인스턴스 레벨 등록은 기능의 A / B 테스트와 같은 인스턴스 레벨 사용자 정의를 제공하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ecc03da2a0a560ac7c30c7b597fc46f4cada8d2" translate="yes" xml:space="preserve">
          <source>Note: If using ember-cli, this value is defaulted to &lt;code&gt;auto&lt;/code&gt; by the &lt;code&gt;locationType&lt;/code&gt; setting of &lt;code&gt;/config/environment.js&lt;/code&gt;</source>
          <target state="translated">참고 : ember-cli를 사용하는 경우이 값은 &lt;code&gt;/config/environment.js&lt;/code&gt; 의 &lt;code&gt;locationType&lt;/code&gt; 설정에 의해 기본값이 &lt;code&gt;auto&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4f5b5d130fcc7f35759471b87f796a64ba0bf18" translate="yes" xml:space="preserve">
          <source>Note: Requests coalescing rely on URL building strategy. So if you override &lt;code&gt;buildURL&lt;/code&gt; in your app &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; more likely should be overridden as well in order for coalescing to work.</source>
          <target state="translated">참고 : 통합 요청은 URL 작성 전략에 의존합니다. 따라서 앱 &lt;code&gt;buildURL&lt;/code&gt; 에서 buildURL 을 재정의하면 통합이 작동하기 위해 &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="855ed88d13b422515a3bdb028bbb0822265999aa" translate="yes" xml:space="preserve">
          <source>Note: When creating a new record using any of the above methods Ember Data will update &lt;code&gt;DS.RecordArray&lt;/code&gt;s such as those returned by &lt;code&gt;store#peekAll()&lt;/code&gt; or &lt;code&gt;store#findAll()&lt;/code&gt;. This means any data bindings or computed properties that depend on the RecordArray will automatically be synced to include the new or updated record values.</source>
          <target state="translated">참고 : 위의 방법 중 하나를 사용하여 새 레코드를 만들면 Ember Data는 &lt;code&gt;store#peekAll()&lt;/code&gt; 또는 &lt;code&gt;store#findAll()&lt;/code&gt; 반환 한 것과 같은 &lt;code&gt;DS.RecordArray&lt;/code&gt; 를 업데이트 합니다. 이는 RecordArray에 의존하는 모든 데이터 바인딩 또는 계산 된 속성이 자동으로 동기화되어 새로운 또는 업데이트 된 레코드 값을 포함 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6ce211ff969df1a3d4d36731e89acfcb795675c6" translate="yes" xml:space="preserve">
          <source>Note: the primary use case for &lt;code&gt;store.queryRecord&lt;/code&gt; is when a single record is queried and the &lt;code&gt;id&lt;/code&gt; is not known beforehand. In all other cases &lt;code&gt;store.query&lt;/code&gt; and using the first item of the array is likely the preferred way:</source>
          <target state="translated">참고 : &lt;code&gt;store.queryRecord&lt;/code&gt; 의 기본 사용 사례 는 단일 레코드를 쿼리하고 &lt;code&gt;id&lt;/code&gt; 를 미리 알 수없는 경우입니다. 다른 모든 경우 &lt;code&gt;store.query&lt;/code&gt; 와 배열의 첫 번째 항목을 사용하는 것이 선호되는 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac43534a384c67ff6a3d194bed22cd1673c95c8" translate="yes" xml:space="preserve">
          <source>Notice that below we &quot;wrap&quot; our rentals markup inside the open and closing mentions of &lt;code&gt;list-filter&lt;/code&gt; on lines 12 and 20. This is an example of the &lt;a href=&quot;https://guides.emberjs.com/components/wrapping-content-in-a-component&quot;&gt;&lt;strong&gt;block form&lt;/strong&gt;&lt;/a&gt; of a component, which allows a Handlebars template to be rendered &lt;em&gt;inside&lt;/em&gt; the component's template wherever the &lt;code&gt;{{yield}}&lt;/code&gt; expression appears.</source>
          <target state="translated">우리는 &quot;랩&quot;우리 렌털 열기 내부 마크 업과 폐쇄 중 언급 이하 알 &lt;code&gt;list-filter&lt;/code&gt; 라인 (12)과 (20)이의 예는 &lt;a href=&quot;https://guides.emberjs.com/components/wrapping-content-in-a-component&quot;&gt;&lt;strong&gt;블록 형태&lt;/strong&gt;&lt;/a&gt; 핸들 바 템플릿을 렌더링 할 수있는 구성 요소의 &lt;em&gt;내부&lt;/em&gt; 구성 요소의 템플릿 &lt;code&gt;{{yield}}&lt;/code&gt; 식이 나타나는 곳에</target>
        </trans-unit>
        <trans-unit id="ba2989c0bbd0d56ad53f312f0472d002b5558820" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;positionalParams&lt;/code&gt; property is added to the class as a static variable via &lt;code&gt;reopenClass&lt;/code&gt;. Positional params are always declared on the component class and cannot be changed while an application runs.</source>
          <target state="translated">알 &lt;code&gt;positionalParams&lt;/code&gt; 재산권 통해 정적 변수로 클래스 추가 &lt;code&gt;reopenClass&lt;/code&gt; . 위치 매개 변수는 항상 구성 요소 클래스에서 선언되며 응용 프로그램이 실행되는 동안 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="22e1e0dd72c3b66a39bb942d9e6c86134bfd19d0" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;then&lt;/code&gt; function called on the result of calling the &lt;code&gt;filter&lt;/code&gt; function. The code expects the &lt;code&gt;filter&lt;/code&gt; function to return a promise. A &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.Promise.html&quot;&gt;promise&lt;/a&gt; is a JavaScript object that represents the result of an asynchronous function. A promise may or may not be executed at the time you receive it. To account for this, it provides functions, like &lt;code&gt;then&lt;/code&gt; that let you give it code it will run when it eventually does receive a result.</source>
          <target state="translated">통지 &lt;code&gt;then&lt;/code&gt; 호출의 결과에 호출 된 함수 &lt;code&gt;filter&lt;/code&gt; 기능을. 이 코드는 &lt;code&gt;filter&lt;/code&gt; 함수가 약속을 반환 할 것으로 예상합니다 . &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.Promise.html&quot;&gt;약속은&lt;/a&gt; 비동기 함수의 결과를 나타내는 JavaScript 객체입니다. 약속을받을 때 약속이 실행되거나 실행되지 않을 수 있습니다. 이를 설명하기 위해 결과를 수신 할 때 실행될 코드 &lt;code&gt;then&lt;/code&gt; 제공하는 기능 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9730ce26ccf4f5b2837b3367e2458b83d31d5800" translate="yes" xml:space="preserve">
          <source>Now a malicious user simply needs to set their &lt;code&gt;firstName&lt;/code&gt; to a string containing HTML (like a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that sends private customer data to their server, for example) and every user in that chat room has been compromised.</source>
          <target state="translated">이제 악의적 인 사용자는 &lt;code&gt;firstName&lt;/code&gt; 을 HTML (예 : 개인 고객 데이터를 서버로 보내는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그)이 포함 된 문자열 로 설정하기 만하면 해당 채팅방의 모든 사용자가 손상되었습니다.</target>
        </trans-unit>
        <trans-unit id="aed6bbb86311e08883196ef682fc7e18211c1a0d" translate="yes" xml:space="preserve">
          <source>Now both integration test scenarios should pass. You can verify this by starting up our test suite by typing &lt;code&gt;ember t -s&lt;/code&gt; at the command line.</source>
          <target state="translated">이제 두 통합 테스트 시나리오를 모두 통과해야합니다. 명령 행에 &lt;code&gt;ember t -s&lt;/code&gt; 를 입력하여 테스트 스위트를 시작하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f599c9023b4f51e1268c2391d3d70cb4d82d8142" translate="yes" xml:space="preserve">
          <source>Now browse to &lt;code&gt;localhost:4200/rentals/grand-old-mansion&lt;/code&gt; and you should see the information listed for that specific rental.</source>
          <target state="translated">이제 &lt;code&gt;localhost:4200/rentals/grand-old-mansion&lt;/code&gt; 으로 이동하면 해당 특정 임대에 대한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c097506f308ce3211348990a741b341f9e9c584" translate="yes" xml:space="preserve">
          <source>Now imagine we have the following template and route:</source>
          <target state="translated">이제 다음과 같은 템플릿과 경로가 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="f2091523f465fab3ba86b01fc47f04eb9b8fc8b8" translate="yes" xml:space="preserve">
          <source>Now implement the service as follows. Note that we check if a map already exists for the given location and use that one, otherwise we call a Google Maps utility to create one.</source>
          <target state="translated">이제 다음과 같이 서비스를 구현하십시오. 지정된 위치에 대해지도가 이미 있는지 확인하고 해당 위치를 사용합니다. 그렇지 않으면 Google지도 유틸리티를 호출하여지도를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d5f166005bc10a443ff98a919b8aa3d2fcc4e964" translate="yes" xml:space="preserve">
          <source>Now in our &lt;code&gt;rentals.hbs&lt;/code&gt; template, let's replace the old HTML markup within our &lt;code&gt;{{#each}}&lt;/code&gt; loop with our new &lt;code&gt;rental-listing&lt;/code&gt; component:</source>
          <target state="translated">이제 &lt;code&gt;rentals.hbs&lt;/code&gt; 템플릿에서 &lt;code&gt;{{#each}}&lt;/code&gt; 루프 내의 기존 HTML 마크 업을 새로운 &lt;code&gt;rental-listing&lt;/code&gt; 구성 요소로 바꾸겠습니다 .</target>
        </trans-unit>
        <trans-unit id="fa74a5445ac21a141ea80fae8c137247dd31ba9d" translate="yes" xml:space="preserve">
          <source>Now in our browser we should see that the first rental property is listed as &quot;Standalone&quot;, while the other two are listed as &quot;Community&quot;.</source>
          <target state="translated">이제 브라우저에서 첫 번째 임대 부동산은 &quot;독립형&quot;으로 표시되고 다른 두 부동산은 &quot;커뮤니티&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="02f78c37e1d7493e21b1b94978d032932bbcb8df" translate="yes" xml:space="preserve">
          <source>Now in the browser when a scientist's name is clicked, this function is called and the person's name is alerted.</source>
          <target state="translated">이제 과학자의 이름을 클릭하면 브라우저에서이 기능이 호출되고 사람의 이름이 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="ed29b70e455c078562a5f430d4dbd6281287bd7b" translate="yes" xml:space="preserve">
          <source>Now let's add code that simulates a visitor arriving on our homepage, clicking one of our links and then visiting a new page.</source>
          <target state="translated">이제 방문자가 홈페이지에 도착하여 링크 중 하나를 클릭 한 다음 새 페이지를 방문하는 것을 시뮬레이트하는 코드를 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="c09d33d498277510cb65c5bde600e541b65944ec" translate="yes" xml:space="preserve">
          <source>Now let's create a test which will call &lt;code&gt;levelUp&lt;/code&gt; on the player when they are level 4 to assert that the &lt;code&gt;levelName&lt;/code&gt; changes. We will use &lt;code&gt;moduleForModel&lt;/code&gt;:</source>
          <target state="translated">이제 호출 테스트 생성 할 수 &lt;code&gt;levelUp&lt;/code&gt; 그들이 주장 레벨 4 그 때 플레이어에 &lt;code&gt;levelName&lt;/code&gt; 의 변경. 우리는 &lt;code&gt;moduleForModel&lt;/code&gt; 을 사용할 것이다 :</target>
        </trans-unit>
        <trans-unit id="37fd2a1099f983eece52ae774c4e471341b866db" translate="yes" xml:space="preserve">
          <source>Now let's create another route with contact details for the company. Once again, we'll start by generating a route:</source>
          <target state="translated">이제 회사의 연락처 정보가 포함 된 다른 경로를 만들어 보겠습니다. 다시 한번, 라우트를 생성하는 것으로 시작하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="311e7c28de846f6b4798420c4a5a9e440da7f54c" translate="yes" xml:space="preserve">
          <source>Now let's render our component using the &lt;code&gt;render&lt;/code&gt; function. The &lt;code&gt;render&lt;/code&gt; function allows us to pass a template string, so that we can declare the component in the same way we do in our templates. Since we set the &lt;code&gt;rentalObj&lt;/code&gt; variable to our local scope, we can access it as part of our render string.</source>
          <target state="translated">이제 &lt;code&gt;render&lt;/code&gt; 함수를 사용하여 컴포넌트를 렌더링 해 봅시다 . &lt;code&gt;render&lt;/code&gt; 기능은 우리가 우리의 템플릿에서와 같은 방법으로 구성 요소를 선언 할 수 있습니다 그래서, 템플릿 문자열을 전달 할 수 있습니다. &lt;code&gt;rentalObj&lt;/code&gt; 변수를 로컬 범위로 설정 했으므로 렌더 문자열의 일부로 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae22d53ed6893c6b12aeed6c790fd45587cc8f49" translate="yes" xml:space="preserve">
          <source>Now let's tell Ember how to turn that array of strings into HTML. Open the &lt;code&gt;scientists&lt;/code&gt; template and add the following code to loop through the array and print it:</source>
          <target state="translated">이제 문자열 배열을 HTML로 바꾸는 방법을 Ember에게 알려 드리겠습니다. &lt;code&gt;scientists&lt;/code&gt; 템플릿을 열고 다음 코드를 추가하여 배열을 반복하여 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7f913783707682a29aebe4955714ed5c947732a8" translate="yes" xml:space="preserve">
          <source>Now let's test that the map component is relying on our service to provide map elements.</source>
          <target state="translated">이제지도 구성 요소가 서비스에 의존하여지도 요소를 제공하는지 테스트 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="96f7e41a4cd747d58701a050ee081913d14c9b5e" translate="yes" xml:space="preserve">
          <source>Now let's write a test that sets a property on our &lt;code&gt;post&lt;/code&gt; model in the &lt;code&gt;PostController&lt;/code&gt; that would be available on the &lt;code&gt;CommentsController&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;CommentsController&lt;/code&gt; 에서 사용할 수 있는 &lt;code&gt;PostController&lt;/code&gt; 의 &lt;code&gt;post&lt;/code&gt; 모델에 속성을 설정하는 테스트를 작성해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="c9f9ed10a2412df54c18588a43c8397490d4ba61" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;ember server&lt;/code&gt; (or &lt;code&gt;ember serve&lt;/code&gt;, or even &lt;code&gt;ember s&lt;/code&gt; for short) on your command line to start the Ember development server and then go to &lt;a href=&quot;http://localhost:4200/about&quot;&gt;&lt;code&gt;http://localhost:4200/about&lt;/code&gt;&lt;/a&gt; to see our new page in action!</source>
          <target state="translated">이제 명령 행에서 &lt;code&gt;ember server&lt;/code&gt; (또는 &lt;code&gt;ember serve&lt;/code&gt; 또는 짧게 &lt;code&gt;ember s&lt;/code&gt; )를 실행하여 Ember 개발 서버를 시작한 다음 &lt;a href=&quot;http://localhost:4200/about&quot;&gt; &lt;code&gt;http://localhost:4200/about&lt;/code&gt; &lt;/a&gt; 으로 이동하여 새 페이지가 실제로 작동하는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="84b050c16846a3214fdf9d603f7c5b69acbc94b6" translate="yes" xml:space="preserve">
          <source>Now run the tests by typing &lt;code&gt;ember test --server&lt;/code&gt; in the command line (or &lt;code&gt;ember t -s&lt;/code&gt; for short).</source>
          <target state="translated">이제 명령 행에 &lt;code&gt;ember test --server&lt;/code&gt; 를 입력하여 테스트를 실행하십시오 (또는 짧게 &lt;code&gt;ember t -s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="34b197a6f48a8ab8f16c6e0063a35905a4b87cee" translate="yes" xml:space="preserve">
          <source>Now run your test suite with the CLI command, &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">이제 CLI 명령 &lt;code&gt;ember test --server&lt;/code&gt; 로 테스트 스위트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e32163bdf7a676f31ff681bf9c67e518f8ae20d2" translate="yes" xml:space="preserve">
          <source>Now that our API is ready to return individual rentals, we can generate our &lt;code&gt;show&lt;/code&gt; sub-route. Much like generating our &lt;code&gt;rentals&lt;/code&gt; route, we will use &lt;code&gt;ember g&lt;/code&gt; to create a nested route.</source>
          <target state="translated">API가 개별 대여를 반환 할 준비가되었으므로 &lt;code&gt;show&lt;/code&gt; 하위 경로를 생성 할 수 있습니다 . &lt;code&gt;rentals&lt;/code&gt; 경로를 생성하는 것과 마찬가지로 &lt;code&gt;ember g&lt;/code&gt; 를 사용하여 중첩 경로를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="390b956f83716b5d2b619a143ece53c88d58057b" translate="yes" xml:space="preserve">
          <source>Now that we are able to generate a map element, we will implement a maps service that will keep a reference to the Map object we create, and attach the map to an element in our application</source>
          <target state="translated">이제 맵 요소를 생성 할 수 있으므로 생성 한 Map 객체에 대한 참조를 유지하고 응용 프로그램의 요소에 맵을 연결하는 맵 서비스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e29152200d11c3493e21bf49ce8fe2f07316838b" translate="yes" xml:space="preserve">
          <source>Now that we are returning all of our rentals to the nested route's model, we will also move the rental list markup from our main route template to our nested route index template.</source>
          <target state="translated">이제 모든 렌탈을 내포 된 루트의 모델로 반환하므로 렌탈 목록 마크 업을 기본 라우트 템플릿에서 내포 된 라우트 인덱스 템플릿으로 옮길 것입니다.</target>
        </trans-unit>
        <trans-unit id="74ca8a47289101b4d71bc8a893d38054ad494e17" translate="yes" xml:space="preserve">
          <source>Now that we can load pages for individual rentals, we'll add a link (using the &lt;code&gt;link-to&lt;/code&gt; helper) within our &lt;code&gt;rental-listing&lt;/code&gt; component to navigate to individual pages. Here, the &lt;code&gt;link-to&lt;/code&gt; helper takes the route name and the rental model object as arguments. When you pass an object as second argument into the &lt;code&gt;link-to&lt;/code&gt; block helper, it will by default &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;serialize&lt;/a&gt; the object to the ID of the model into the URL. Alternately, you may just pass &lt;code&gt;rental.id&lt;/code&gt; for clarity.</source>
          <target state="translated">개별 대여에 대한 페이지를로드 할 수 &lt;code&gt;link-to&lt;/code&gt; 되었으므로 &lt;code&gt;rental-listing&lt;/code&gt; 구성 요소 내에 링크를 사용하여 링크 를 추가 하여 개별 페이지로 이동합니다. 여기에서 &lt;code&gt;link-to&lt;/code&gt; 헬퍼는 경로 이름과 렌탈 모델 객체를 인수로 사용합니다. &lt;code&gt;link-to&lt;/code&gt; 블록 도우미에 객체를 두 번째 인수로 전달하면 기본적으로 객체가 모델의 ID로 URL에 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;직렬화&lt;/a&gt; 됩니다. 또는 명확성을 위해 &lt;code&gt;rental.id&lt;/code&gt; 를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f51bc732dd5d0541e4168611797a812b626f2f08" translate="yes" xml:space="preserve">
          <source>Now that we have the maps API available to the application, we can create our map utility. Utility files can be generated using Ember CLI.</source>
          <target state="translated">애플리케이션에 사용 가능한 maps API가 있으므로 맵 유틸리티를 작성할 수 있습니다. 유틸리티 파일은 Ember CLI를 사용하여 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e52876f40ef26dc44f65cd5da56d10b2128afb" translate="yes" xml:space="preserve">
          <source>Now that we have various pages in our application, let's walk through how to build tests for them.</source>
          <target state="translated">애플리케이션에 다양한 페이지가 있으므로 테스트를 빌드하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6188cec92e3b92a3cd3573bff0b61954c555c273" translate="yes" xml:space="preserve">
          <source>Now that we've created a new component for filtering a list, we want to create a test to verify it. Let's use a &lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;component integration test&lt;/a&gt; to verify our component behavior, similar to &lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;how we tested our rental listing component earlier&lt;/a&gt;.</source>
          <target state="translated">목록 필터링을위한 새 구성 요소를 만들었으므로이를 확인하기위한 테스트를 만들려고합니다. &lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;대여 목록 구성 요소를 이전에 테스트 한 방식&lt;/a&gt; 과 유사한 구성 &lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;요소 통합 테스트&lt;/a&gt; 를 사용하여 구성 요소 동작을 검증 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="22d276eb5319d347792a8180152b4cf12d2f8003" translate="yes" xml:space="preserve">
          <source>Now that we've got the &lt;code&gt;scientists&lt;/code&gt; template rendering, let's give it some data to render. We do that by specifying a &lt;em&gt;model&lt;/em&gt; for that route, and we can specify a model by editing &lt;code&gt;app/routes/scientists.js&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;scientists&lt;/code&gt; 템플릿 렌더링을 얻었 으므로 렌더링 할 데이터를 제공하겠습니다. 해당 경로에 대한 &lt;em&gt;모델&lt;/em&gt; 을 지정하여이를 수행하고 &lt;code&gt;app/routes/scientists.js&lt;/code&gt; 를 편집하여 모델을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="409a5bf3323ebbf783bca40b618202511ed25e9c" translate="yes" xml:space="preserve">
          <source>Now that we've tested that the &lt;code&gt;list-filter&lt;/code&gt; component behaves as expected, let's test that the page itself also behaves properly with an acceptance test. We'll verify that a user visiting the rentals page can enter text into the search field and narrow the list of rentals by city.</source>
          <target state="translated">이제 &lt;code&gt;list-filter&lt;/code&gt; 구성 요소가 예상대로 작동하는지 테스트 했으므로 승인 테스트를 통해 페이지 자체도 올바르게 작동하는지 테스트 해 보겠습니다. 대여 페이지를 방문하는 사용자가 검색 필드에 텍스트를 입력하고 도시별로 임대 목록을 좁힐 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e9f934b876c6d18b3147c025ed6401410b05147e" translate="yes" xml:space="preserve">
          <source>Now that we've written our application and verified that it works in development, it's time to get it ready to deploy to our users.</source>
          <target state="translated">이제 애플리케이션을 작성하고 개발에 적용되는지 확인 했으므로 이제 사용자에게 배포 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb98077b823bffbec7d94fef2fd368d976bda3cd" translate="yes" xml:space="preserve">
          <source>Now the same template above renders the following HTML:</source>
          <target state="translated">위의 동일한 템플릿은 다음 HTML을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="751cdc42f9ac3dfa5f8f1d9e4ef15bfaddd5edf2" translate="yes" xml:space="preserve">
          <source>Now the value passed into the helper has its HTML escaped, but the trusted &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags that we want to wrap the value in are &lt;em&gt;not&lt;/em&gt; escaped. A malicious user setting their &lt;code&gt;firstName&lt;/code&gt; to something containing HTML would see this:</source>
          <target state="translated">이제 헬퍼에 전달 된 값은 HTML 이스케이프되었지만 값을 래핑하려는 신뢰할 수있는 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 태그는 이스케이프 &lt;em&gt;되지 않습니다&lt;/em&gt; . 악의적 인 사용자가 &lt;code&gt;firstName&lt;/code&gt; 을 HTML을 포함하는 것으로 설정 하면 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6b5009f8b7a2901d3d319dd17092db9a1ed606" translate="yes" xml:space="preserve">
          <source>Now visiting the root route at &lt;code&gt;/&lt;/code&gt; will result in the &lt;code&gt;/rentals&lt;/code&gt; URL loading.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 에 루트 경로를 방문하면 &lt;code&gt;/rentals&lt;/code&gt; URL 이로 드됩니다.</target>
        </trans-unit>
        <trans-unit id="6c6c7e593ed0c850f3e8190fef9191b81f3e28da" translate="yes" xml:space="preserve">
          <source>Now we are listing rentals, and verifying it with an acceptance test. This leaves us with 2 remaining acceptance test failures (and 1 eslint failure):</source>
          <target state="translated">이제 렌탈을 나열하고 수락 테스트로 확인합니다. 이로 인해 2 번의 승인 테스트 실패 (및 1 개의 eslint 실패)가 남습니다.</target>
        </trans-unit>
        <trans-unit id="7108a8b8c763bba0f7398042020329fed4eaf6cc" translate="yes" xml:space="preserve">
          <source>Now we can add functionality that will show the image of a rental when requested by the user.</source>
          <target state="translated">이제 사용자가 요청할 때 대여 이미지를 표시하는 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa9210fe58ffde8b4dcc9ff4b51a5ca9f882a82" translate="yes" xml:space="preserve">
          <source>Now we can move on to an integration test. Integration testing helpers is done with the &lt;code&gt;moduleForComponent&lt;/code&gt; helpers, as shown in &lt;a href=&quot;../unit-testing-basics&quot;&gt;Testing Components&lt;/a&gt;.</source>
          <target state="translated">이제 통합 테스트로 넘어갈 수 있습니다. 통합 테스트 헬퍼는 &lt;a href=&quot;../unit-testing-basics&quot;&gt;컴포넌트 테스트에&lt;/a&gt; 표시된대로 &lt;code&gt;moduleForComponent&lt;/code&gt; 헬퍼를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4adfea733a9bf47405887104fee15db7d39c58a6" translate="yes" xml:space="preserve">
          <source>Now we need to define a computed property of our category-filtered array that the &lt;code&gt;articles&lt;/code&gt; template will render:</source>
          <target state="translated">이제 &lt;code&gt;articles&lt;/code&gt; 템플릿이 렌더링 할 카테고리 필터링 배열의 계산 된 속성을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="54e5a7d11514449fe0aca845de95725d318042b5" translate="yes" xml:space="preserve">
          <source>Now we need to make it so that the &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; action defined in the parent component &lt;code&gt;user-profile&lt;/code&gt; can be triggered from within &lt;code&gt;button-with-confirmation&lt;/code&gt;. We'll do this by passing the action to the child component in exactly the same way that we pass other properties. This is possible since actions are simply functions, just like any other method on a component, and they can therefore be passed from one component to another like this:</source>
          <target state="translated">이제 부모 구성 요소 &lt;code&gt;user-profile&lt;/code&gt; 에 정의 된 &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; 작업을 &lt;code&gt;button-with-confirmation&lt;/code&gt; 내에서 트리거 할 수 있도록해야 합니다. 우리는 다른 속성을 전달하는 것과 같은 방식으로 자식 구성 요소에 작업을 전달하여이 작업을 수행합니다. 동작은 구성 요소의 다른 방법과 마찬가지로 단순히 기능이므로 다음과 같이 한 구성 요소에서 다른 구성 요소로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638d79b6dc710ae90d1be166135c3fd4850c0c22" translate="yes" xml:space="preserve">
          <source>Now we've implemented our action, but we have not told Ember when we want this action to be triggered, which is the next step.</source>
          <target state="translated">이제 우리는 액션을 구현했지만이 액션을 트리거 할 때 Ember에 알리지 않았습니다 (다음 단계).</target>
        </trans-unit>
        <trans-unit id="8266b5a5c3d0155af7d2420da1952fd4bf225240" translate="yes" xml:space="preserve">
          <source>Now when the &lt;code&gt;system-preferences-editor&lt;/code&gt; handles the delete action, it receives only the user's account &lt;code&gt;id&lt;/code&gt; string.</source>
          <target state="translated">이제 &lt;code&gt;system-preferences-editor&lt;/code&gt; 가 삭제 조치를 처리 할 때 사용자의 계정 &lt;code&gt;id&lt;/code&gt; 문자열 만 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="24e0f7c85a3653f2f8783ca8850aaea9de98c648" translate="yes" xml:space="preserve">
          <source>Now when we click the image or the &lt;code&gt;View Larger&lt;/code&gt; link in our browser, we see our image show larger. When we click the enlarged image again, we see it smaller.</source>
          <target state="translated">이제 브라우저에서 이미지 또는 &lt;code&gt;View Larger&lt;/code&gt; 링크를 클릭하면 이미지가 더 크게 표시됩니다. 확대 된 이미지를 다시 클릭하면 더 작아집니다.</target>
        </trans-unit>
        <trans-unit id="5d245f0aef23eeedd834fcade7b3ff3025ac6d19" translate="yes" xml:space="preserve">
          <source>Now when we go to &lt;a href=&quot;http://localhost:4200/contact&quot;&gt;&lt;code&gt;http://localhost:4200/contact&lt;/code&gt;&lt;/a&gt;, we'll see our contact page.</source>
          <target state="translated">이제 &lt;a href=&quot;http://localhost:4200/contact&quot;&gt; &lt;code&gt;http://localhost:4200/contact&lt;/code&gt; &lt;/a&gt; 로 이동하면 연락처 페이지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ce9483b052b5784076ba5b335a0118e44ab1c9e9" translate="yes" xml:space="preserve">
          <source>Now when you confirm deletion, the action goes straight to the &lt;code&gt;system-preferences-editor&lt;/code&gt; to be handled in its local context.</source>
          <target state="translated">이제 삭제를 확인하면 작업이 로컬 환경에서 처리되도록 &lt;code&gt;system-preferences-editor&lt;/code&gt; 로 바로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="61a8b0d0ff011a9764ca1ad939461500c43c3744" translate="yes" xml:space="preserve">
          <source>Now, define your new controller like so:</source>
          <target state="translated">이제 다음과 같이 새 컨트롤러를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fd3bbdfb6ab9a0619b9f651b994843f728f190" translate="yes" xml:space="preserve">
          <source>Now, let's add a list of available rentals to the rentals page we've just created.</source>
          <target state="translated">이제 방금 만든 대여 페이지에 사용 가능한 대여 목록을 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a53ad0647104e578d8de2040723dfe077ba174b5" translate="yes" xml:space="preserve">
          <source>Now, let's switch over to our rentals page template. We can use the model attribute to display our list of rentals. Here, we'll use another common Handlebars helper called &lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt;&lt;code&gt;{{each}}&lt;/code&gt;&lt;/a&gt;. This helper will let us loop through each of the rental objects in our model:</source>
          <target state="translated">이제 대여 페이지 템플릿으로 전환하겠습니다. 모델 속성을 사용하여 대여 목록을 표시 할 수 있습니다. 여기서는 &lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt; &lt;code&gt;{{each}}&lt;/code&gt; &lt;/a&gt; 라는 다른 일반적인 핸들 바 도우미를 사용 합니다. 이 도우미를 사용하면 모델의 각 임대 개체를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15795f7ce89f935cc441a35c4b6d01a3b8f097c4" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;onConfirm&lt;/code&gt; in the child component to invoke the action on the parent:</source>
          <target state="translated">이제 하위 컴포넌트에서 &lt;code&gt;onConfirm&lt;/code&gt; 을 사용 하여 상위에서 조치를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a74da24790015ebe84e057ae755a540ac6ffaa" translate="yes" xml:space="preserve">
          <source>Now, we can use the &lt;code&gt;{{blog-post}}&lt;/code&gt; component and pass it properties in another template:</source>
          <target state="translated">이제 &lt;code&gt;{{blog-post}}&lt;/code&gt; 컴포넌트를 사용하여 다른 템플릿에 속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf62c9f4192c9e36113ca42781fc9263390a9ef" translate="yes" xml:space="preserve">
          <source>Now, we'll add our corresponding link to the contact page so we can move back and forth between &lt;code&gt;about&lt;/code&gt; and &lt;code&gt;contact&lt;/code&gt;:</source>
          <target state="translated">이제 연락처 페이지에 해당 링크를 추가하여 &lt;code&gt;about&lt;/code&gt; 과 &lt;code&gt;contact&lt;/code&gt; 사이 를 앞뒤로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b6222fa9f13976ca7ad6beffaa5b6d82e8a9acf" translate="yes" xml:space="preserve">
          <source>Now, when the user visits &lt;code&gt;/about&lt;/code&gt;, Ember will render the &lt;code&gt;about&lt;/code&gt; template. Visiting &lt;code&gt;/favs&lt;/code&gt; will render the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">이제 사용자가 &lt;code&gt;/about&lt;/code&gt; 방문 하면 Ember가 &lt;code&gt;about&lt;/code&gt; 템플릿 을 렌더링합니다 . &lt;code&gt;/favs&lt;/code&gt; 를 방문 하면 &lt;code&gt;favorites&lt;/code&gt; 템플릿 이 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="88edc4776d403507658bee878ccdd72f1066d6fc" translate="yes" xml:space="preserve">
          <source>Number of elements that should be removed from the array, starting at *idx*.</source>
          <target state="translated">* idx *에서 시작하여 배열에서 제거해야하는 요소 수</target>
        </trans-unit>
        <trans-unit id="0da649b10044d0f71d7a6905e9b6d63659072ba9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to space out requests.</source>
          <target state="translated">요청 간격을 밀리 초 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="76f886e5f43af44774fe994d2bf9d8f584ccf233" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait.</source>
          <target state="translated">기다리는 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="c96f8cfa04b2401642b632ab99c696e7b056b4c9" translate="yes" xml:space="preserve">
          <source>Number|Property</source>
          <target state="translated">Number|Property</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="046bbc130ff7274f6d64607d913605fb2889bf35" translate="yes" xml:space="preserve">
          <source>Object Inspector</source>
          <target state="translated">객체 검사기</target>
        </trans-unit>
        <trans-unit id="e1513401bdad97eeec26a0df3ad83cdcfa1ea677" translate="yes" xml:space="preserve">
          <source>Object Root</source>
          <target state="translated">객체 루트</target>
        </trans-unit>
        <trans-unit id="a7b77dbe50791d31096e5af54a26e5c31a19b936" translate="yes" xml:space="preserve">
          <source>Object containing values to use within the new class</source>
          <target state="translated">새 클래스 내에서 사용할 값을 포함하는 객체</target>
        </trans-unit>
        <trans-unit id="6b304869b69598961a9d35b37c6fa6c60971f424" translate="yes" xml:space="preserve">
          <source>Object | DS.AdapterError</source>
          <target state="translated">객체 | DS.AdapterError</target>
        </trans-unit>
        <trans-unit id="43710f2ae099d35ce837e6f0eaa732de92f07067" translate="yes" xml:space="preserve">
          <source>Object...</source>
          <target state="translated">Object...</target>
        </trans-unit>
        <trans-unit id="509eaa966f59106fc4885b0bd87f377320887ef2" translate="yes" xml:space="preserve">
          <source>ObjectProxy</source>
          <target state="translated">ObjectProxy</target>
        </trans-unit>
        <trans-unit id="b6ab519ee4828e64cb84e7da4b0494d126262ccd" translate="yes" xml:space="preserve">
          <source>Objects are considered Array-like if any of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하면 객체는 배열과 같은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1f91056b2f2c5a87fefcf8263cdce9940569716e" translate="yes" xml:space="preserve">
          <source>Objects in Ember</source>
          <target state="translated">Ember의 객체</target>
        </trans-unit>
        <trans-unit id="ea0a98c632b2c1b78a2d3889fe6a012055812ca8" translate="yes" xml:space="preserve">
          <source>Object|Function</source>
          <target state="translated">Object|Function</target>
        </trans-unit>
        <trans-unit id="d9008046621fd4aa468204fcfd6ca159f07a8852" translate="yes" xml:space="preserve">
          <source>Object|Promise</source>
          <target state="translated">Object|Promise</target>
        </trans-unit>
        <trans-unit id="c231f0cfa191393d14a834365263558785e900ee" translate="yes" xml:space="preserve">
          <source>Object|String</source>
          <target state="translated">Object|String</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="307932fe3fc8a6a623482336122238a18d63c345" translate="yes" xml:space="preserve">
          <source>Observable Equivalent</source>
          <target state="translated">관찰 가능한 동등 물</target>
        </trans-unit>
        <trans-unit id="03ec7d08aec77b2156c9347f0082c5eed203b4e0" translate="yes" xml:space="preserve">
          <source>Observer Methods</source>
          <target state="translated">관찰자 방법</target>
        </trans-unit>
        <trans-unit id="20c17cb09007fd332a06112b65f303ed65335037" translate="yes" xml:space="preserve">
          <source>Observer methods have the following signature:</source>
          <target state="translated">관찰자 메소드에는 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="translated">Observers</target>
        </trans-unit>
        <trans-unit id="853a6ea1725e790242a53c8b71d88a3606114195" translate="yes" xml:space="preserve">
          <source>Observers / Binding</source>
          <target state="translated">관찰자 / 바인딩</target>
        </trans-unit>
        <trans-unit id="0ba30584277e971c04f0d982aa5c093fa641ac6a" translate="yes" xml:space="preserve">
          <source>Observers and asynchrony</source>
          <target state="translated">관찰자와 비동기</target>
        </trans-unit>
        <trans-unit id="dd121fa26be2df8672e845b1537510d9b314c5cd" translate="yes" xml:space="preserve">
          <source>Observers and object initialization</source>
          <target state="translated">관찰자와 객체 초기화</target>
        </trans-unit>
        <trans-unit id="e736f6b09fdaa953337c6d536a1450f9f94c9a91" translate="yes" xml:space="preserve">
          <source>Observers are annotated using &lt;code&gt;Ember.observer()&lt;/code&gt;:</source>
          <target state="translated">관찰자는 &lt;code&gt;Ember.observer()&lt;/code&gt; 사용하여 주석이 달립니다 :</target>
        </trans-unit>
        <trans-unit id="3077946aa34d8ec8d2b52fd810a985c5b86ca007" translate="yes" xml:space="preserve">
          <source>Observers in Ember are currently synchronous. This means that they will fire as soon as one of the properties they observe changes. Because of this, it is easy to introduce bugs where properties are not yet synchronized:</source>
          <target state="translated">Ember의 옵저버는 현재 동기식입니다. 즉, 속성이 변경되는 즉시 발사됩니다. 이로 인해 속성이 아직 동기화되지 않은 버그가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0dcd8db6908df157727f62893615213904a58453" translate="yes" xml:space="preserve">
          <source>Observers never fire until after the initialization of an object is complete.</source>
          <target state="translated">객체의 초기화가 완료 될 때까지 관찰자는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5999f9bc2923f92d05e5b16aa536ea236796646" translate="yes" xml:space="preserve">
          <source>Observers should contain behavior that reacts to changes in another property. Observers are especially useful when you need to perform some behavior after a binding has finished synchronizing.</source>
          <target state="translated">관찰자는 다른 속성의 변경에 반응하는 동작을 포함해야합니다. 관찰자는 바인딩 동기화가 완료된 후 일부 동작을 수행해야 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2e48525b5f6912ad099b4ea5d21fef8fb5a4b87c" translate="yes" xml:space="preserve">
          <source>Observing Property Changes</source>
          <target state="translated">속성 변경 관찰</target>
        </trans-unit>
        <trans-unit id="49abd5a03a91a7274230eb2dc93800125ce2b2dc" translate="yes" xml:space="preserve">
          <source>Occasionally you may want to prevent the app from initializing during setup. This could enable extra configuration, or enable asserting prior to the app becoming ready.</source>
          <target state="translated">경우에 따라 설정 중에 앱이 초기화되지 않도록 할 수 있습니다. 이를 통해 추가 구성을 활성화하거나 앱이 준비되기 전에 어설 션을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ff2f4ac5135f40e96e90d7929e9e452ea04a10c" translate="yes" xml:space="preserve">
          <source>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action's completion.</source>
          <target state="translated">종종 작업은 서버에 대한 아약스 요청과 같은 비동기 작업을 수행합니다. 액션은 부모 컴포넌트에 의해 전달 될 수있는 함수이므로 호출 될 때 값을 반환 할 수 있습니다. 가장 일반적인 시나리오는 구성 요소가 조치 완료를 처리 할 수 ​​있도록 조치가 약속을 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="89cb7859835dee6ef77b5791366871c69a2d100f" translate="yes" xml:space="preserve">
          <source>Often times, your components will just encapsulate certain snippets of Handlebars templates that you find yourself using over and over. In those cases, you do not need to write any JavaScript at all. Define the Handlebars template as described above and use the component that is created.</source>
          <target state="translated">종종 구성 요소는 사용자가 반복해서 사용하는 특정 핸들 바 템플릿 스 니펫을 캡슐화합니다. 이 경우 JavaScript를 전혀 작성할 필요가 없습니다. 위에서 설명한대로 핸들 바 템플리트를 정의하고 작성된 컴포넌트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5aaf5caa5b49b93e7119e86a70d536ce6664ca8a" translate="yes" xml:space="preserve">
          <source>Often you'll want to have a template that displays inside another template. For example, in a blogging application, instead of going from a list of blog posts to creating a new post, you might want to have the post creation page display next to the list.</source>
          <target state="translated">종종 다른 템플릿 안에 표시되는 템플릿을 원할 것입니다. 예를 들어, 블로깅 애플리케이션에서 블로그 게시물 목록에서 새 게시물 작성으로 이동하는 대신 목록 옆에 게시물 작성 페이지가 표시되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62bb97c24abd34d344b7c7e101be577c8280b132" translate="yes" xml:space="preserve">
          <source>Often, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers. The &lt;code&gt;wait&lt;/code&gt; helper is designed to handle these scenarios, by providing a hook to ensure assertions are made after all Ajax requests and timers are complete.</source>
          <target state="translated">구성 요소와 상호 작용하면 종종 HTTP 요청 또는 타이머와 같은 비동기 동작이 발생합니다. &lt;code&gt;wait&lt;/code&gt; 도우미는 모든 Ajax 요청 및 타이머가 완료 후에 주장이 만들어진 보장하기 위해 후크를 제공함으로써, 이러한 시나리오를 처리하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="50ea8ddf844ede9c0ec44349c06ad04be2998925" translate="yes" xml:space="preserve">
          <source>Often, services connect to third party APIs that are not desirable to include in automated tests. To stub these services we simply have to register a stub service that implements the same API, but does not have the dependencies that are problematic for the test suite.</source>
          <target state="translated">종종 서비스는 자동화 된 테스트에 포함되지 않는 타사 API에 연결됩니다. 이러한 서비스를 스텁하려면 동일한 API를 구현하지만 테스트 스위트에 문제가되는 종속성이없는 스텁 서비스를 등록하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce500ec9eb2726f6b12a95aabe734c404cd89eb" translate="yes" xml:space="preserve">
          <source>Often, the relationships in Ember Data applications will have an inverse. For example, imagine the following models are defined:</source>
          <target state="translated">종종 Ember Data 어플리케이션의 관계는 반대가됩니다. 예를 들어, 다음 모델이 정의되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1f047d78b062689ec81f8220591ae2637824e50" translate="yes" xml:space="preserve">
          <source>Often, you'll want a template to display data from a model. Loading the appropriate model is one job of a route.</source>
          <target state="translated">종종 템플릿에서 모델의 데이터를 표시하기를 원할 것입니다. 적절한 모델을로드하는 것은 라우트 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2c3ffdb1abb5aafa99ed88d09e01065a059a00a9" translate="yes" xml:space="preserve">
          <source>On Component Destroy</source>
          <target state="translated">구성 요소 파괴</target>
        </trans-unit>
        <trans-unit id="7871fb44d093405668420a934d855c398825b852" translate="yes" xml:space="preserve">
          <source>On Initial Render</source>
          <target state="translated">초기 렌더링시</target>
        </trans-unit>
        <trans-unit id="3b81a353de54248fb63ae86d5a82b1a0e405029d" translate="yes" xml:space="preserve">
          <source>On Mac and Linux, you can improve file watching performance by installing &lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt;.</source>
          <target state="translated">Mac 및 Linux에서는 &lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt; 을 설치하여 파일 시청 성능을 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58e13e632d3a342d5053b03478a93981c741b85e" translate="yes" xml:space="preserve">
          <source>On Re-Render</source>
          <target state="translated">리 렌더에서</target>
        </trans-unit>
        <trans-unit id="79702120c7c021f8b09ee1afda618cd0df787a69" translate="yes" xml:space="preserve">
          <source>On a belongsTo relationship:</source>
          <target state="translated">belongsTo 관계에서 :</target>
        </trans-unit>
        <trans-unit id="eb43fdb147dc2a32fcd7a2f1655715ba70c1d257" translate="yes" xml:space="preserve">
          <source>On a class-based helper, it may be useful to force a recomputation of that helpers value. This is akin to &lt;code&gt;rerender&lt;/code&gt; on a component.</source>
          <target state="translated">클래스 기반 헬퍼에서는 해당 헬퍼 값의 재 계산을 강제하는 것이 유용 할 수 있습니다. 이것은 컴포넌트에서 다시 &lt;code&gt;rerender&lt;/code&gt; 하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6861bce269e523e12d7da65c6da77edffe736f32" translate="yes" xml:space="preserve">
          <source>On all newer browsers, you only need to use this method to retrieve properties if the property might not be defined on the object and you want to respect the &lt;code&gt;unknownProperty&lt;/code&gt; handler. Otherwise you can ignore this method.</source>
          <target state="translated">모든 최신 브라우저에서는이 메소드를 사용하여 오브젝트에 특성이 정의되지 &lt;code&gt;unknownProperty&lt;/code&gt; 핸들러 를 존중하려는 경우 특성을 검색하기 만하면 됩니다. 그렇지 않으면이 방법을 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="aeba23ad12f082d9bc5f8ea964d08e7ff1c2466b" translate="yes" xml:space="preserve">
          <source>On an Apache server, the rewrite engine (mod-rewrite) must be enabled in order for Ember routing to work properly. If you upload your dist folder, going to your main URL works, but when you try to go to a route such as '{main URL}/example' and it returns 404, your server has not been configured for &quot;friendly&quot; URLs.</source>
          <target state="translated">Apache 서버에서 Ember 라우팅이 제대로 작동하려면 다시 쓰기 엔진 (mod-rewrite)이 활성화되어 있어야합니다. dist 폴더를 업로드하면 기본 URL로 이동해도 '{main URL} / example'과 같은 경로로 이동하여 404를 반환하면 서버가 &quot;친숙한&quot;URL로 구성되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9188633f146f1828663d4971118211e9bc5e119" translate="yes" xml:space="preserve">
          <source>On each call to the &lt;code&gt;normalize&lt;/code&gt; method, the third parameter (&lt;code&gt;prop&lt;/code&gt;) is always one of the keys that were in the original payload or in the result of another normalization as &lt;code&gt;normalizeResponse&lt;/code&gt;.</source>
          <target state="translated">받는 각 호출에 &lt;code&gt;normalize&lt;/code&gt; 방법에있어서, 세번째 파라미터 ( &lt;code&gt;prop&lt;/code&gt; ) 항상 원래의 페이로드 또는 다른 정규화 결과에 있던 키 중 하나이다 &lt;code&gt;normalizeResponse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c9c6f59e26d3f950eadfc25af534272ba19cb77" translate="yes" xml:space="preserve">
          <source>On success, the request promise will be resolved with the full response payload.</source>
          <target state="translated">성공하면 요청 약속은 전체 응답 페이로드로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="78f324f1e8f3f3b4f5bff5c1b66a78f5e0759ff5" translate="yes" xml:space="preserve">
          <source>On the left side of each Guides page is a table of contents, organized into sections that can be expanded to show the topics they cover. Both the sections and the topics within each section are ordered from basic to advanced concepts.</source>
          <target state="translated">각 안내서 페이지의 왼쪽에는 주제를 보여주기 위해 확장 할 수있는 섹션으로 구성된 목차가 있습니다. 섹션과 각 섹션의 주제는 기본 개념에서 고급 개념으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="e32c960456f9b43f9166f605a702a559006007ce" translate="yes" xml:space="preserve">
          <source>Once a factory is registered, it can be &quot;injected&quot; where it is needed.</source>
          <target state="translated">공장이 등록되면 필요한 곳에 &quot;주사&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdec5004fb5c33e3b2c477c863020702ae402501" translate="yes" xml:space="preserve">
          <source>Once injected into a component, a service can also be used in the template. Note &lt;code&gt;cart&lt;/code&gt; being used below to get data from the cart.</source>
          <target state="translated">구성 요소에 주입 한 후에는 템플릿에서 서비스를 사용할 수도 있습니다. 참고 &lt;code&gt;cart&lt;/code&gt; 카트에서 데이터를 얻기 위해 아래의 사용.</target>
        </trans-unit>
        <trans-unit id="ccee3bf08a6536ea2be6c885ed850fbb3a399af9" translate="yes" xml:space="preserve">
          <source>Once inside the &lt;code&gt;articles&lt;/code&gt; route, any changes to the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt; will cause the URL to update the query param. By default, a query param property change won't cause a full router transition (i.e. it won't call &lt;code&gt;model&lt;/code&gt; hooks and &lt;code&gt;setupController&lt;/code&gt;, etc.); it will only update the URL.</source>
          <target state="translated">&lt;code&gt;articles&lt;/code&gt; 경로에 들어가면 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; 속성을 변경 하면 URL이 쿼리 매개 변수를 업데이트합니다. 기본적으로 쿼리 매개 변수 속성 변경으로 인해 전체 라우터 전환이 발생하지 않습니다 (예 : &lt;code&gt;model&lt;/code&gt; 후크 및 &lt;code&gt;setupController&lt;/code&gt; 등을 호출하지 않음 ). URL 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="457d77836a439fdff49c3b23b258781eb29f6526" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab at the far right.</source>
          <target state="translated">설치되면 Ember 응용 프로그램으로 이동하여 개발자 도구를 열고 맨 오른쪽 의 &lt;code&gt;Ember&lt;/code&gt; 탭을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4986dfc0d963c8eec63b7840ddbc1ff83a864a8" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab.</source>
          <target state="translated">설치되면 Ember 응용 프로그램으로 이동하여 개발자 도구를 열고 &lt;code&gt;Ember&lt;/code&gt; 탭을 클릭 하십시오.</target>
        </trans-unit>
        <trans-unit id="164742e39c4ca64cff90a3cf61eb5e20c381b0f7" translate="yes" xml:space="preserve">
          <source>Once installed, the addon works in 3 steps:</source>
          <target state="translated">애드온이 설치되면 3 단계로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cd5d0a583c546e922e7dd07f13b00126893c9cbb" translate="yes" xml:space="preserve">
          <source>Once loaded, a service will persist until the application exits.</source>
          <target state="translated">일단로드되면 응용 프로그램이 종료 될 때까지 서비스가 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7473ccb2808c3e1202cafe608e15eb9e87bf60" translate="yes" xml:space="preserve">
          <source>Once open, remove the component labeled &lt;code&gt;{{welcome-page}}&lt;/code&gt;. The application should now be a completely blank canvas to build our application on.</source>
          <target state="translated">열면 &lt;code&gt;{{welcome-page}}&lt;/code&gt; 라는 구성 요소를 제거하십시오 . 이제 응용 프로그램을 빌드하기 위해 응용 프로그램이 완전히 빈 캔버스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1eca8732180d60ac42bab4f21f28e52ea9a48daf" translate="yes" xml:space="preserve">
          <source>Once rendered an element's &lt;code&gt;elementId&lt;/code&gt; is considered immutable and you should never change it. If you need to compute a dynamic value for the &lt;code&gt;elementId&lt;/code&gt;, you should do this when the component or element is being instantiated:</source>
          <target state="translated">렌더링 된 요소의 &lt;code&gt;elementId&lt;/code&gt; 는 변경할 수없는 것으로 간주되므로 절대 변경해서는 안됩니다. &lt;code&gt;elementId&lt;/code&gt; 에 대한 동적 값을 계산해야하는 경우 컴포넌트 또는 요소가 인스턴스화 될 때이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4267347d40eb36c6cbbed253186fd37bf3007beb" translate="yes" xml:space="preserve">
          <source>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</source>
          <target state="translated">베타주기가 완료되면 다음 안정 릴리스에는 베타주기 동안 활성화 된 모든 기능이 포함됩니다. 이 시점에서 기능 플래그가 카나리아 및 향후 베타 분기에서 제거되고 해당 기능이 프레임 워크의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="56051bb2517e89df5d91846d46bbeb555a7edbb5" translate="yes" xml:space="preserve">
          <source>Once the main transition into &lt;code&gt;slow-model&lt;/code&gt; completes, the &lt;code&gt;loading&lt;/code&gt; route will be exited and the transition to &lt;code&gt;slow-model&lt;/code&gt; will continue.</source>
          <target state="translated">&lt;code&gt;slow-model&lt;/code&gt; 로의 기본 전환이 완료되면 &lt;code&gt;loading&lt;/code&gt; 경로가 종료되고 &lt;code&gt;slow-model&lt;/code&gt; 의 전환 이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="d59a62a3f97ccc2bfdeef6fc089edaeadc6ceb33" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">일단 프록시 약속이 확정되면 이것은 &lt;code&gt;false&lt;/code&gt; 이 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4398fd5039ae29bd335437e10b017a202f1021a5" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">일단 프록시 약속이 확정되면 이것은 &lt;code&gt;true&lt;/code&gt; 이 될 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="4688c68d00bda5e6b4d6f0282ecb2274e65f3aa4" translate="yes" xml:space="preserve">
          <source>Once the request to the server returns with a JSON payload for the requested record, the adapter resolves the promise it returned to the store with the JSON.</source>
          <target state="translated">서버에 대한 요청이 요청 된 레코드에 대한 JSON 페이로드와 함께 리턴되면 어댑터는 JSON으로 상점에 리턴 된 약속을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="a7341d0efec76622cf31b57420e0efd9cc42ff86" translate="yes" xml:space="preserve">
          <source>Once the stub service is registered the test simply needs to check that the stub data that is being returned from the service is reflected in the component output.</source>
          <target state="translated">스텁 서비스가 등록되면 테스트는 단순히 서비스에서 리턴되는 스텁 데이터가 컴포넌트 출력에 반영되는지 확인하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f0dda9c0cb3a268c5b42422c783a5ad7cd0e1d9" translate="yes" xml:space="preserve">
          <source>Once we create this &quot;button with confirmation&quot; component, we want to be able to reuse it all over our application.</source>
          <target state="translated">이 &quot;확인 버튼&quot;구성 요소를 만든 후에는 응용 프로그램 전체에서 재사용 할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="9fbeae9a67f6bd9c4e25f14b9f726db44131dc7a" translate="yes" xml:space="preserve">
          <source>Once we have a new project in place, we can confirm everything is working by starting the Ember development server:</source>
          <target state="translated">새 프로젝트가 완성되면 Ember 개발 서버를 시작하여 모든 것이 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b19ac1ee33b1618505282400756773afbf338c" translate="yes" xml:space="preserve">
          <source>Once yielded, the data can be accessed by the wrapped content by referencing the &lt;code&gt;post&lt;/code&gt; variable. Now a component called &lt;code&gt;markdown-style&lt;/code&gt; will be rendered in &lt;code&gt;{{post.body}}&lt;/code&gt;.</source>
          <target state="translated">일단 산출되면, &lt;code&gt;post&lt;/code&gt; 변수 를 참조하여 랩핑 된 컨텐츠가 데이터에 액세스 할 수 있습니다 . 이제 &lt;code&gt;markdown-style&lt;/code&gt; 이라는 컴포넌트 가 &lt;code&gt;{{post.body}}&lt;/code&gt; 에 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="be2dc254dc6c7464981de655c454c5b817215603" translate="yes" xml:space="preserve">
          <source>Once you call this method, any time the key's value is set, your observer will be notified. Note that the observers are triggered any time the value is set, regardless of whether it has actually changed. Your observer should be prepared to handle that.</source>
          <target state="translated">이 메소드를 호출하면 키 값이 설정 될 때마다 관찰자에게 알립니다. 옵저버는 실제로 변경되었는지 여부에 관계없이 값이 설정 될 때마다 트리거됩니다. 관찰자는이를 처리 할 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e423cbca6b9df549f466352ce6ab4bd43120115" translate="yes" xml:space="preserve">
          <source>Once you have an understanding of Ember Data, you will have a much better way to manage the complexity of data loading in your application. This will allow your code to evolve without becoming a mess.</source>
          <target state="translated">Ember Data에 대해 이해하고 나면 애플리케이션에서 데이터로드의 복잡성을 관리하는 훨씬 더 좋은 방법을 갖게됩니다. 이렇게하면 코드가 혼란없이 진화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7879c2db8a502cf08ab955e6b7189ce9ea7ec40" translate="yes" xml:space="preserve">
          <source>Once you have built your &lt;code&gt;deprecation-workflow.js&lt;/code&gt; file and your deprecations are silenced, you can begin to work on deprecations one by one at your own leisure. To find deprecations, you can change the handler value of that message to either &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;log&lt;/code&gt;. Throw will throw an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail. Choosing to log will simply log a warning to the console as before. These settings give you some flexibility on how you want to go about fixing the deprecations.</source>
          <target state="translated">&lt;code&gt;deprecation-workflow.js&lt;/code&gt; 파일 을 빌드 하고 더 이상 사용되지 않는 기능이 비활성화되면 여가 시간에 하나씩 더 이상 사용되지 않는 작업을 시작할 수 있습니다. 지원 중단을 찾으려면 해당 메시지의 핸들러 값을 &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;log&lt;/code&gt; 로 변경할 수 있습니다 . 지원 중단이 발생하면 Throw에서 실제 예외가 발생하므로 사용 중단 된 기능을 사용하는 테스트가 실패합니다. 로그를 선택하면 이전과 마찬가지로 콘솔에 경고가 기록됩니다. 이 설정은 지원 중단 수정 방법에 대한 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="297de7e31394aa2c72d2a09e3d3842f25dc27bdc" translate="yes" xml:space="preserve">
          <source>Once you have defined a class, you can create new &lt;em&gt;instances&lt;/em&gt; of that class by calling its &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt;&lt;code&gt;create()&lt;/code&gt;&lt;/a&gt; method. Any methods, properties and computed properties you defined on the class will be available to instances:</source>
          <target state="translated">클래스를 정의한 후에 는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt; &lt;code&gt;create()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 해당 클래스의 새 &lt;em&gt;인스턴스&lt;/em&gt; 를 작성할 수 있습니다 . 클래스에서 정의한 모든 메서드, 속성 및 계산 된 속성을 인스턴스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae78f9453ab89e2b98b40a513549fd747f33aca" translate="yes" xml:space="preserve">
          <source>Once you have defined a route with a dynamic segment, Ember will extract the value of the dynamic segment from the URL for you and pass them as a hash to the &lt;code&gt;model&lt;/code&gt; hook as the first argument:</source>
          <target state="translated">동적 세그먼트로 경로를 정의하면 Ember가 URL에서 동적 세그먼트의 값을 추출 하여 첫 번째 인수로 &lt;code&gt;model&lt;/code&gt; 후크에 해시로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="37dc9e0949005db31c3bef8749a046174ea22093" translate="yes" xml:space="preserve">
          <source>Once you have these two methods implemented, apply the &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin to your class and you will be able to enumerate the contents of your object like any other collection.</source>
          <target state="translated">이 두 가지 방법을 구현 한 후에는 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 믹스 인을 클래스에 적용하면 다른 컬렉션과 마찬가지로 객체의 내용을 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d318d88b083e6a740e5695fcce549c330e442a4c" translate="yes" xml:space="preserve">
          <source>Once you've installed Ember CLI via npm, you will have access to a new &lt;code&gt;ember&lt;/code&gt; command in your terminal. You can use the &lt;code&gt;ember new&lt;/code&gt; command to create a new application.</source>
          <target state="translated">npm을 통해 Ember CLI를 설치하면 터미널에서 새로운 &lt;code&gt;ember&lt;/code&gt; 명령에 액세스 할 수 있습니다 . &lt;code&gt;ember new&lt;/code&gt; 명령을 사용하여 새 응용 프로그램을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae22ba23783545c09734f8348d02996c94f94d2" translate="yes" xml:space="preserve">
          <source>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;Specifying a Route's Model&lt;/a&gt; guide.</source>
          <target state="translated">스토리지에서 모델을로드하면 구성 요소는 모델 데이터를 사용자가 상호 작용할 수있는 UI로 변환하는 방법을 알고 있습니다. 구성 요소가 모델 데이터를 가져 오는 방법에 대한 자세한 내용은 배관 모델 &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;지정&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="946fb83a5b5f0d85f4cd4d0947e1d59cebfd37a1" translate="yes" xml:space="preserve">
          <source>Once you've removed deprecations that you may not need to immediately address, you may still be left with many deprecations. Also, your remaining deprecations may only occur in very specific scenarios that are not obvious. How then should you go about finding and fixing these? This is where the &lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-deprecation-workflow&lt;/a&gt; addon can be extremely helpful.</source>
          <target state="translated">즉시 처리 할 필요가없는 사용 중단을 삭제 한 후에도 더 이상 사용되지 않을 수 있습니다. 또한 나머지 지원 중단은 분명하지 않은 매우 구체적인 시나리오에서만 발생할 수 있습니다. 그렇다면 어떻게 찾아서 고쳐야합니까? 이것은 &lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-deprecation-workflow&lt;/a&gt; 애드온이 매우 도움이 될 수있는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="7d393feab7e66d7efa30902c007f830f56512202" translate="yes" xml:space="preserve">
          <source>One benefit of the above approach compared to using &lt;code&gt;run.next&lt;/code&gt; is that you will be able to perform DOM/CSS operations before unprocessed elements are rendered to the screen, which may prevent flickering or other artifacts caused by delaying processing until after rendering.</source>
          <target state="translated">&lt;code&gt;run.next&lt;/code&gt; 를 사용하는 것과 비교하여 위의 접근 방식의 한 가지 이점은 처리되지 않은 요소가 화면에 렌더링되기 전에 DOM / CSS 작업을 수행 할 수있어 렌더링 후까지 처리 지연으로 인한 깜박임 또는 기타 아티팩트를 방지 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2017e7fd0f2a575b1a1bb39b33094a703f7dc923" translate="yes" xml:space="preserve">
          <source>One common example is when overriding the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook in one of Ember-Data's serializers.</source>
          <target state="translated">한 가지 일반적인 예는 Ember-Data의 직렬 변환기 중 하나에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt; 후크를 재정의하는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="ef72e13fa9c7abd23262b84daf45e66eae37d8b2" translate="yes" xml:space="preserve">
          <source>One common way of building web applications is to tightly couple user interface elements to data fetching. For example, imagine you are writing the admin section of a blogging app, which has a feature that lists the drafts for the currently logged in user.</source>
          <target state="translated">웹 응용 프로그램을 구축하는 일반적인 방법 중 하나는 사용자 인터페이스 요소를 데이터 가져 오기에 밀접하게 연결하는 것입니다. 예를 들어, 현재 로그인 한 사용자의 초안을 나열하는 기능이있는 블로그 앱의 관리자 섹션을 작성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1fd57542548476a402566a40e7028672d63f27fb" translate="yes" xml:space="preserve">
          <source>One detail to keep in mind is that both branches of the &lt;code&gt;if&lt;/code&gt; helper will be evaluated, so if you have &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt;, &lt;code&gt;expensive-operation&lt;/code&gt; will always calculate.</source>
          <target state="translated">명심해야 할 한 가지 세부 사항은 &lt;code&gt;if&lt;/code&gt; 도우미 의 두 분기가 모두 평가되므로 &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt; 이면 &lt;code&gt;expensive-operation&lt;/code&gt; 이 항상 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="921f9a649da7d3ee552d9bb46da95892c7504e20" translate="yes" xml:space="preserve">
          <source>One downside to returning a cached record is you may find the state of the data has changed since it was first loaded into the store's identity map. In order to prevent this stale data from being a problem for long, Ember Data will automatically make a request in the background each time a cached record is returned from the store. When the new data comes in, the record is updated, and if there have been changes to the record since the initial render, the template is re-rendered with the new information.</source>
          <target state="translated">캐시 된 레코드를 리턴하는 한 가지 단점은 데이터가 상점의 ID 맵에 처음로드 된 이후 데이터 상태가 변경되었음을 발견 할 수 있다는 것입니다. 이 오래된 데이터가 오랫동안 문제가되지 않도록하기 위해 Ember Data는 캐시 된 레코드가 상점에서 리턴 될 때마다 백그라운드에서 자동으로 요청합니다. 새 데이터가 들어 오면 레코드가 업데이트되고 초기 렌더링 이후 레코드가 변경된 경우 템플릿은 새 정보로 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6e9d09355e2e6fdfee3fc6889b073f2cc7d11f" translate="yes" xml:space="preserve">
          <source>One job of a route handler is rendering the appropriate template to the screen.</source>
          <target state="translated">경로 처리기의 한 작업은 적절한 템플릿을 화면에 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="023b2e22d9619644336d8abd002c12ec4e3957f7" translate="yes" xml:space="preserve">
          <source>One nice thing about this model is that if you try to set a value to the same thing as last time, Ember (through HTMLBars) will avoid doing any work on the DOM.</source>
          <target state="translated">이 모델의 한 가지 좋은 점은 지난번과 동일한 값을 설정하려고하면 HTML 막대를 통해 Ember가 DOM에서 작업하는 것을 피할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c25bd1df98cee9098780b27f236f384e2f2dd2d" translate="yes" xml:space="preserve">
          <source>One of the major issues in testing web applications is that all code is event-driven and therefore has the potential to be asynchronous (i.e. output can happen out of sequence from input). This has the ramification that code can be executed in any order.</source>
          <target state="translated">웹 응용 프로그램 테스트의 주요 문제 중 하나는 모든 코드가 이벤트 중심이므로 비 동기화 될 가능성이 있다는 것입니다 (즉, 출력이 입력에서 순서가 잘못 될 수 있음). 이것은 코드가 어떤 순서로든 실행될 수 있다는 파급 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22cb0dab0dc2d88fe000d648a9d5f8ff6c7e07a" translate="yes" xml:space="preserve">
          <source>One of the methods is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;&lt;code&gt;transitionTo()&lt;/code&gt;&lt;/a&gt;. Calling &lt;code&gt;transitionTo()&lt;/code&gt; from a route or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt;&lt;code&gt;transitionToRoute()&lt;/code&gt;&lt;/a&gt; from a controller will stop any transitions currently in progress and start a new one, functioning as a redirect. &lt;code&gt;transitionTo()&lt;/code&gt; behaves exactly like the &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;link-to&lt;/a&gt; helper.</source>
          <target state="translated">메소드 중 하나는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt; &lt;code&gt;transitionTo()&lt;/code&gt; &lt;/a&gt; 입니다. 호출 &lt;code&gt;transitionTo()&lt;/code&gt; 경로 또는에서 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt; &lt;code&gt;transitionToRoute()&lt;/code&gt; &lt;/a&gt; 컨트롤러에서 것은 리디렉션 역할, 새로운 하나를 현재 진행중인 모든 전환을 중지하고 시작합니다. &lt;code&gt;transitionTo()&lt;/code&gt; 는 &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;링크&lt;/a&gt; 헬퍼 와 똑같이 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="3d247fef3beb6617e410a9310b1691023a273f3f" translate="yes" xml:space="preserve">
          <source>One of the responsibilities of a route is to load a model.</source>
          <target state="translated">경로의 책임 중 하나는 모델을로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc339cc993a1d0dfdea6070d19f55e3e10babcc4" translate="yes" xml:space="preserve">
          <source>One or more Mixin classes</source>
          <target state="translated">하나 이상의 믹스 인 클래스</target>
        </trans-unit>
        <trans-unit id="a4387dcdd8c21d687d201ae902808eab655aaeb6" translate="yes" xml:space="preserve">
          <source>One property can be mapped on to another by placing a &quot;:&quot; between the source property and the destination property:</source>
          <target state="translated">소스 속성과 대상 속성 사이에 &quot;:&quot;을 배치하여 한 속성을 다른 속성에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd8ba8819277c241acfb17d9b513165c7a86664" translate="yes" xml:space="preserve">
          <source>One scenario would be to camelCase the meta keys of your payload. The example below shows how this could be done using &lt;code&gt;normalizeArrayResponse&lt;/code&gt; and &lt;code&gt;extractRelationship&lt;/code&gt;.</source>
          <target state="translated">하나의 시나리오는 페이로드의 메타 키를 camelCase하는 것입니다. 아래 예제는 &lt;code&gt;normalizeArrayResponse&lt;/code&gt; 및 &lt;code&gt;extractRelationship&lt;/code&gt; 을 사용하여이를 수행하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="aa8da0e5204ecf2e3129f7e87c21cf719d86102c" translate="yes" xml:space="preserve">
          <source>One way to think about the store is as a cache of all of the records that have been loaded by your application. If a route or a controller in your app asks for a record, the store can return it immediately if it is in the cache. Otherwise, the store must ask the adapter to load it, which usually means a trip over the network to retrieve it from the server.</source>
          <target state="translated">저장소를 생각하는 한 가지 방법은 응용 프로그램에서로드 한 모든 레코드의 캐시입니다. 앱의 경로 또는 컨트롤러가 레코드를 요청하면 저장소가 캐시에 있으면 즉시 해당 레코드를 반환 할 수 있습니다. 그렇지 않으면, 상점은 어댑터에로드를 요청해야합니다. 이는 일반적으로 서버에서 검색하기 위해 네트워크를 통한 여행을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="206de582d9e42728271567f32cef1d2caa66c410" translate="yes" xml:space="preserve">
          <source>One-To-Many</source>
          <target state="translated">One-To-Many</target>
        </trans-unit>
        <trans-unit id="72ed6317b3c29cc659bd9726d64c0704e0a987b4" translate="yes" xml:space="preserve">
          <source>One-To-One</source>
          <target state="translated">One-To-One</target>
        </trans-unit>
        <trans-unit id="e8edf93e5fc748fcefb10c45b67f1fe2105f8341" translate="yes" xml:space="preserve">
          <source>One-Way Bindings</source>
          <target state="translated">단방향 바인딩</target>
        </trans-unit>
        <trans-unit id="a888cbb9d1975f7a372576caffb7acdfc8b16b4f" translate="yes" xml:space="preserve">
          <source>One-to-Many</source>
          <target state="translated">One-to-Many</target>
        </trans-unit>
        <trans-unit id="a2cab38603c3673e0e2b0a47873e43f0dbfdffa8" translate="yes" xml:space="preserve">
          <source>One-to-One</source>
          <target state="translated">One-to-One</target>
        </trans-unit>
        <trans-unit id="f2b45396a05b9e6a742a38dba57faf9bcaacbc0e" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;http://localhost:4200&quot;&gt;&lt;code&gt;http://localhost:4200&lt;/code&gt;&lt;/a&gt; in your browser of choice. You should see an Ember welcome page and not much else. Congratulations! You just created and booted your first Ember app.</source>
          <target state="translated">열기 &lt;a href=&quot;http://localhost:4200&quot;&gt; &lt;code&gt;http://localhost:4200&lt;/code&gt; &lt;/a&gt; 선택의 여지가 귀하의 브라우저한다. 당신은 Ember 환영 페이지를 볼 것입니다. 축하합니다! 첫 번째 Ember 앱을 만들고 부팅했습니다.</target>
        </trans-unit>
        <trans-unit id="2f97601478ddfa30694a21e0aee77ce407626778" translate="yes" xml:space="preserve">
          <source>Open our existing acceptance test, &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;, and implement the test labeled &quot;should filter the list of rentals by city&quot;.</source>
          <target state="translated">기존의 승인 테스트 ( &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; )를 열고 &quot;도시 별 임대 목록을 필터링해야합니다&quot;라고 표시된 테스트를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="0cc801dfb3bc3822b07222ee8a7d8dcfc04c59ec" translate="yes" xml:space="preserve">
          <source>Open the newly-created template in &lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; and add the following HTML:</source>
          <target state="translated">&lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; 에서 새로 작성된 템플리트를 열고 다음 HTML을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="bd792fbd2875bdf3718df2a36075e5b668af82a7" translate="yes" xml:space="preserve">
          <source>Opening an issue or pull request to &lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;the GitHub repository&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;GitHub 리포지토리에&lt;/a&gt; 대한 이슈 또는 풀 요청 열기</target>
        </trans-unit>
        <trans-unit id="c1dd165afc95895bd90768a2a8a39ca08acf8783" translate="yes" xml:space="preserve">
          <source>Opening that file will reveal some initial code that will try to go to the &lt;code&gt;list-rentals&lt;/code&gt; route and verify that the route is loaded. The initial code is there to help us build our first acceptance test.</source>
          <target state="translated">해당 파일을 열면 &lt;code&gt;list-rentals&lt;/code&gt; 경로 로 이동 하여 경로가로드되었는지 확인하는 초기 코드가 표시됩니다 . 첫 번째 코드는 첫 번째 승인 테스트를 작성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="68394f0bdcf1b11a4905c9738f7ac23b35d3aca2" translate="yes" xml:space="preserve">
          <source>Opening the template for this route reveals an outlet underneath the route's general page information. At the bottom of the template, you'll notice an &lt;code&gt;{{outlet}}&lt;/code&gt; helper. This is where the active nested route will be rendered.</source>
          <target state="translated">이 경로의 템플릿을 열면 경로의 일반 페이지 정보 아래에 콘센트가 나타납니다. 템플릿 하단에 &lt;code&gt;{{outlet}}&lt;/code&gt; 도우미가 있습니다. 여기에서 활성 중첩 경로가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="84c592e4f2dcd576f7dfcf84d3f2fab2e7d1c377" translate="yes" xml:space="preserve">
          <source>Operations performed in initializers should be kept as lightweight as possible to minimize delays in loading your application. Although advanced techniques exist for allowing asynchrony in application initializers (i.e. &lt;code&gt;deferReadiness&lt;/code&gt; and &lt;code&gt;advanceReadiness&lt;/code&gt;), these techniques should generally be avoided. Any asynchronous loading conditions (e.g. user authorization) are almost always better handled in your application route's hooks, which allows for DOM interaction while waiting for conditions to resolve.</source>
          <target state="translated">이니셜 라이저에서 수행되는 작업은 응용 프로그램로드 지연을 최소화하기 위해 가능한 한 가볍게 유지해야합니다. 응용 프로그램 이니셜 라이저에서 비동기를 허용하는 고급 기술 (예 : &lt;code&gt;deferReadiness&lt;/code&gt; 및 &lt;code&gt;advanceReadiness&lt;/code&gt; )이 있지만 이러한 기술은 일반적으로 피해야합니다. 모든 비동기 로딩 조건 (예 : 사용자 권한 부여)은 거의 항상 응용 프로그램 경로의 후크에서 더 잘 처리되므로 조건이 해결되기를 기다리는 동안 DOM 상호 작용이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="245a923eb00420b9baa12f359835e88308f803dd" translate="yes" xml:space="preserve">
          <source>Opting into a full transition</source>
          <target state="translated">완전한 전환을 선택</target>
        </trans-unit>
        <trans-unit id="66b8b140d34ca56fe840cbf56dad53e263eb6056" translate="yes" xml:space="preserve">
          <source>Optional arguments to be passed to the queued method.</source>
          <target state="translated">대기중인 메소드에 전달할 선택적 인수입니다.</target>
        </trans-unit>
        <trans-unit id="7174acae61247527fa92ec0872c03eec9cf98de5" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass on</source>
          <target state="translated">전달할 선택적 인수</target>
        </trans-unit>
        <trans-unit id="f4fa0c5292f62f88297e792835dcb8ffe325cd65" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass to the timeout.</source>
          <target state="translated">시간 종료에 전달할 선택적 인수.</target>
        </trans-unit>
        <trans-unit id="a00dbf5de4ed7db7948c3423669d8aeb01e9edd2" translate="yes" xml:space="preserve">
          <source>Optional array of actions (listeners).</source>
          <target state="translated">선택적 조치 배열 (리스너).</target>
        </trans-unit>
        <trans-unit id="a7f4c5eb44535d1e4f3e27873e7fffaf8af0087e" translate="yes" xml:space="preserve">
          <source>Optional array of parameters to interpolate into string.</source>
          <target state="translated">문자열에 삽입 할 선택적 매개 변수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6c4f35334f92330cec8db7b3c2ec6ce4d524729c" translate="yes" xml:space="preserve">
          <source>Optional hash of configuration options including `willChange` and `didChange` option.</source>
          <target state="translated">`willChange` 및`didChange` 옵션을 포함한 구성 옵션의 선택적 해시.</target>
        </trans-unit>
        <trans-unit id="2f6b7a5c6a5652ddfb412d45674a61749417b985" translate="yes" xml:space="preserve">
          <source>Optional meta to lookup listeners</source>
          <target state="translated">리스너 리스너에 대한 선택적 메타</target>
        </trans-unit>
        <trans-unit id="844e0186eb00638ab699a19704bf6b6030a59426" translate="yes" xml:space="preserve">
          <source>Optional parameters for each listener.</source>
          <target state="translated">각 리스너에 대한 선택적 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="6f066f2da230be0f98eac3487bbb5312285fcf7e" translate="yes" xml:space="preserve">
          <source>Optionally supply a model for the route in question. The model will be serialized into the URL using the &lt;code&gt;serialize&lt;/code&gt; hook of the route:</source>
          <target state="translated">선택적으로 해당 경로에 대한 모델을 제공하십시오. 모델은 경로 의 &lt;code&gt;serialize&lt;/code&gt; 후크를 사용하여 URL로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4afb26fd74d5f6e8ea7cbf72fa7921df56de5e90" translate="yes" xml:space="preserve">
          <source>Optionally you can pass a type which unload all records for a given type.</source>
          <target state="translated">선택적으로 주어진 유형에 대한 모든 레코드를 언로드하는 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d707d47d0d151fe2e1d8731df65d7ece3ccb76af" translate="yes" xml:space="preserve">
          <source>Optionally, a model type used to determine which serializer will be used</source>
          <target state="translated">선택적으로 사용할 직렬 변환기를 결정하는 데 사용되는 모델 유형</target>
        </trans-unit>
        <trans-unit id="136ae3638c2d9288aced04a9905490f376059e3b" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started. Once this resolves, the array with which the promise resolves, is updated automatically so it contains all the records in the store:</source>
          <target state="translated">선택적으로 &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 백그라운드 재로드가 시작됩니다. 이 문제가 해결되면 약속이 해결되는 배열이 자동으로 업데이트되어 저장소의 모든 레코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f76ca3aa52e342e9e499538412c709f9fc9c6c82" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started, which updates the records' data, once it is available:</source>
          <target state="translated">선택적으로 &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 백그라운드 다시로드가 시작되어 레코드 데이터가 사용 가능 해지면 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="056a298f55d85765827346a51abdb7d167ab8056" translate="yes" xml:space="preserve">
          <source>Options for `Ember.deprecate`.</source>
          <target state="translated">`Ember.deprecate` 옵션.</target>
        </trans-unit>
        <trans-unit id="d84522ef4b97044a7b5036fbf48e647677689781" translate="yes" xml:space="preserve">
          <source>Or if you pass it an array with names it returns the parameters as a hash:</source>
          <target state="translated">또는 이름이있는 배열을 전달하면 매개 변수를 해시로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37cdfe0b0058fe4edf3c475c18fb07ae927c2616" translate="yes" xml:space="preserve">
          <source>Or on a hasMany relationship:</source>
          <target state="translated">또는 hasMany 관계에서 :</target>
        </trans-unit>
        <trans-unit id="64e13784e0e5fc4499c58a28e19a3b279f630bc2" translate="yes" xml:space="preserve">
          <source>Or perhaps you might want to boot two instances of your app on the same page for a split-screen multiplayer experience:</source>
          <target state="translated">또는 분할 화면 멀티 플레이어 경험을 위해 동일한 페이지에서 두 개의 앱 인스턴스를 부팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50016e626900570663ecf9226b2c2f188c840413" translate="yes" xml:space="preserve">
          <source>Or, assign an action to an inline event handler in the template (which creates a closure action and does receive the event object as an argument).</source>
          <target state="translated">또는 템플리트의 인라인 이벤트 핸들러에 조치를 지정하십시오 (폐쇄 조치를 작성하고 이벤트 오브젝트를 인수로 수신함).</target>
        </trans-unit>
        <trans-unit id="a4cc74f7b298a6159af4768c4304193189c80184" translate="yes" xml:space="preserve">
          <source>Order of Lifecycle Hooks Called</source>
          <target state="translated">호출 된 수명주기 후크</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="f6011263f2c8df7e6d5838c01886ff0ab127d426" translate="yes" xml:space="preserve">
          <source>Organize records into groups, each of which is to be passed to separate calls to &lt;code&gt;findMany&lt;/code&gt;.</source>
          <target state="translated">레코드를 그룹으로 구성하십시오. 각 그룹은 &lt;code&gt;findMany&lt;/code&gt; 에 대한 별도의 호출로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c2df0e1900518adaa51b92719f7b922310675ba" translate="yes" xml:space="preserve">
          <source>Other Assets</source>
          <target state="translated">기타 자산</target>
        </trans-unit>
        <trans-unit id="d3a5d50dac3d2fd3be1db7f31ed808c7f8a1ff9f" translate="yes" xml:space="preserve">
          <source>Other assets</source>
          <target state="translated">기타 자산</target>
        </trans-unit>
        <trans-unit id="05b2c2f5c7ef214490e816d188da36da6aead3a8" translate="yes" xml:space="preserve">
          <source>Other than these two restrictions, Ember Data's normalized JSON object follows the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; specification.</source>
          <target state="translated">이 두 가지 제한 외에도 Ember Data의 정규화 된 JSON 객체는 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; 사양을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="0a59ae439add2f420237329f253278208031489d" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;filterByCity&lt;/code&gt; function is going to pretend to be the action function for our component, that does the actual filtering of the rental list.</source>
          <target state="translated">우리 &lt;code&gt;filterByCity&lt;/code&gt; 의 기능은 임대 목록의 실제 필터링을 수행 우리의 구성 요소에 대한 작업 기능, 척 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d2352d7289d1df632f9cdd6e7d02d2ec6a168ab" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;rentals&lt;/code&gt; route is going to serve multiple functions. From our &lt;a href=&quot;../acceptance-test&quot;&gt;acceptance tests&lt;/a&gt;, we've shown that we want our users to be able to browse and search rentals, as well as see detailed information for individual rentals. To satisfy that requirement, we are going to make use of Ember's &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;nested route capability&lt;/a&gt;.</source>
          <target state="translated">우리의 &lt;code&gt;rentals&lt;/code&gt; 노선은 여러 기능을 제공 할 것입니다. 우리에서 &lt;a href=&quot;../acceptance-test&quot;&gt;수용 테스트&lt;/a&gt; , 우리는 우리가 아니라 개인 대여에 대한 자세한 정보를 볼 우리의 사용자가 검색 및 대여를 검색 할 수있는 것을 보여 주었다. 이 요구 사항을 충족시키기 위해 Ember의 &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;중첩 된 경로 기능&lt;/a&gt; 을 사용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ceabe1dbf5cc8df0bb7eda712f95c063f04ae06b" translate="yes" xml:space="preserve">
          <source>Our app needs a single function, &lt;code&gt;createMap&lt;/code&gt;, which makes use of &lt;code&gt;google.maps.Map&lt;/code&gt; to create our map element, &lt;code&gt;google.maps.Geocoder&lt;/code&gt; to lookup the coordinates of our location, and &lt;code&gt;google.maps.Marker&lt;/code&gt; to pin our map based on the resolved location.</source>
          <target state="translated">앱 에는 &lt;code&gt;google.maps.Map&lt;/code&gt; 을 사용하여지도 요소 인 &lt;code&gt;google.maps.Geocoder&lt;/code&gt; 를 사용하여 위치의 좌표를 조회하고 &lt;code&gt;google.maps.Marker&lt;/code&gt; 를 사용하여지도를 고정 하는 단일 함수 인 &lt;code&gt;createMap&lt;/code&gt; 이 필요 합니다. 해결 된 위치.</target>
        </trans-unit>
        <trans-unit id="e07b0dd7549ed8c27ea39867fe2f2d1988667c3e" translate="yes" xml:space="preserve">
          <source>Our app should behave now as before, with the addition of an image for each rental item.</source>
          <target state="translated">우리의 응용 프로그램은 각 대여 항목에 대한 이미지를 추가하여 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a20c7d31e256f685e6854e8af9656af5d1a7698" translate="yes" xml:space="preserve">
          <source>Our component integration test will test two different behaviors:</source>
          <target state="translated">구성 요소 통합 테스트는 두 가지 동작을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="cae96a04e9b7056dc33933f973849aed2afc24ae" translate="yes" xml:space="preserve">
          <source>Our goal is to help you avoid that mess and come up to speed as fast as possible; you can consider us your internet friend.</source>
          <target state="translated">우리의 목표는 그러한 혼란을 피하고 가능한 빨리 속도를 내도록 돕는 것입니다. 당신은 우리에게 당신의 인터넷 친구를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939816c45abd273d6565fd8a68842401b6e05c49" translate="yes" xml:space="preserve">
          <source>Our launched Chrome web browser now shows 10 successful tests. If you toggle the box labeled &quot;Hide passed tests&quot;, you should see our successful acceptance test, along with 9 passing ESLint tests. Ember tests each file you create for syntax issues (known as &quot;linting&quot;) using &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;.</source>
          <target state="translated">출시 된 Chrome 웹 브라우저는 이제 10 번의 성공적인 테스트를 보여줍니다. &quot;통과 테스트 숨기기&quot;상자를 토글하면 9 개의 통과 ESLint 테스트와 함께 성공적인 합격 테스트가 표시됩니다. Ember는 ESLint를 사용하여 생성 한 각 파일에서 구문 문제 ( &quot;linting&quot;이라고 함)를 &lt;a href=&quot;http://eslint.org/&quot;&gt;테스트&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb08f510a40d4531dddec319cee316e84226d5d3" translate="yes" xml:space="preserve">
          <source>Our list-filter component takes a function as an argument, used to find the list of matching rentals based on the filter string provided by the user. We provide an action function by setting it to the local scope of our test by calling &lt;code&gt;this.on&lt;/code&gt;.</source>
          <target state="translated">우리의 목록 필터 구성 요소는 사용자가 제공 한 필터 문자열을 기준으로 일치하는 대여 목록을 찾는 데 사용되는 함수를 인수로 사용합니다. &lt;code&gt;this.on&lt;/code&gt; 을 호출하여 테스트의 로컬 범위로 설정하여 액션 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b06b1f865cc2e950e72d8ef25f106bf2e0d12435" translate="yes" xml:space="preserve">
          <source>Our new &lt;code&gt;rental-listing&lt;/code&gt; component will manage how a user sees and interacts with a rental. To start, let's move the rental display details for a single rental from the &lt;code&gt;rentals.hbs&lt;/code&gt; template into &lt;code&gt;rental-listing.hbs&lt;/code&gt; and add the image field:</source>
          <target state="translated">새로운 &lt;code&gt;rental-listing&lt;/code&gt; 구성 요소는 사용자가 대여를보고 상호 작용하는 방식을 관리합니다. 시작하려면 단일 임대에 대한 임대 표시 세부 사항을 &lt;code&gt;rentals.hbs&lt;/code&gt; 템플리트에서 &lt;code&gt;rental-listing.hbs&lt;/code&gt; 로 이동 하고 이미지 필드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="29373ffd294040aafa4cf834c59c8d7e6c803a1c" translate="yes" xml:space="preserve">
          <source>Our new helper starts out with some boilerplate code from the generator:</source>
          <target state="translated">우리의 새로운 도우미는 발전기의 상용구 코드로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a349524a1f4aadac769db82fd11c98cb24360fc6" translate="yes" xml:space="preserve">
          <source>Our new route is nested within our &lt;code&gt;rentals&lt;/code&gt; route. This tells Ember that it is a sub-route and will be accessed through &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt;.</source>
          <target state="translated">우리의 새로운 경로는 우리의 &lt;code&gt;rentals&lt;/code&gt; 경로 내에 중첩되어 있습니다. 이것은 Ember에게 하위 경로이며 &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt; 를 통해 액세스 할 수 있음을 알려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="4f76189ba851aa52d8190127cc50d8974b28cd36" translate="yes" xml:space="preserve">
          <source>Our primary focus with mirage will be in the &lt;code&gt;config.js&lt;/code&gt; file, which is where we can define our API endpoints and our data. We will be following the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API specification&lt;/a&gt; which requires our data to be formatted a certain way. Let's configure Mirage to send back our rentals that we had defined above by updating &lt;code&gt;mirage/config.js&lt;/code&gt;:</source>
          <target state="translated">mirage의 주요 초점 은 API 엔드 포인트 및 데이터를 정의 할 수 있는 &lt;code&gt;config.js&lt;/code&gt; 파일에 있습니다. 우리는 다음과 같은 것이다 &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API 사양&lt;/a&gt; 우리의 데이터를 필요로하는 특정한 방식으로 포맷 할 수 있습니다. &lt;code&gt;mirage/config.js&lt;/code&gt; 를 업데이트하여 위에서 정의한 렌탈을 다시 보내도록 Mirage를 구성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1b24e7c85fa3198f703161c3ddef40fe3394011b" translate="yes" xml:space="preserve">
          <source>Our test fills out &quot;Seattle&quot; as the search criteria in the search field, and then sends a &lt;code&gt;keyup&lt;/code&gt; event to the same field with a code of &lt;code&gt;69&lt;/code&gt; (the &lt;code&gt;e&lt;/code&gt; key) to simulate a user typing.</source>
          <target state="translated">테스트에서는 검색 필드에서 검색 기준으로 &quot;시애틀&quot;을 &lt;code&gt;keyup&lt;/code&gt; 다음 사용자 입력을 시뮬레이트하기 위해 코드 &lt;code&gt;69&lt;/code&gt; ( &lt;code&gt;e&lt;/code&gt; 키)를 사용 하여 동일한 필드에 키업 이벤트를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="78d0fbfeeac956fe03189a14212a32e505b7af40" translate="yes" xml:space="preserve">
          <source>Outputting their name and age.</source>
          <target state="translated">그들의 이름과 나이를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7f785f12de428c659f4e7bcaf5ae3019791cd9ca" translate="yes" xml:space="preserve">
          <source>Outside of class definitions</source>
          <target state="translated">클래스 정의 외부</target>
        </trans-unit>
        <trans-unit id="6448c99bf69eeb2ba6848557375b741d43c476bb" translate="yes" xml:space="preserve">
          <source>Override this function when writing a class-based helper.</source>
          <target state="translated">클래스 기반 헬퍼를 작성할 때이 함수를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="e7118e866bd2fbc9b87fc7380712b78a5ce41ae2" translate="yes" xml:space="preserve">
          <source>Override this method with your testing framework's false assertion. This function is called whenever an exception occurs causing the testing promise to fail.</source>
          <target state="translated">테스트 프레임 워크의 잘못된 주장으로이 방법을 재정의하십시오. 이 함수는 예외가 발생하여 테스트 약속이 실패 할 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="78724f610daa7d335490afd0afef134897e80478" translate="yes" xml:space="preserve">
          <source>Override this to call your framework's methods that handle async operations.</source>
          <target state="translated">비동기 작업을 처리하는 프레임 워크의 메서드를 호출하려면이를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="6d464e9e96aeb92e00f8be7c60b6ca811e20cee2" translate="yes" xml:space="preserve">
          <source>Override to implement teardown.</source>
          <target state="translated">테어 다운을 구현하도록 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="72f33b6fd8ce9f99ebb8295cb19dd840fcca6242" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; in order to clear any cached instances of the unregistered factory.</source>
          <target state="translated">등록되지 않은 팩토리의 캐시 된 인스턴스를 지우려면 &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="e441b8e9bc7405861b187f25fbe7e852d75948a0" translate="yes" xml:space="preserve">
          <source>Overriding Application-wide Defaults</source>
          <target state="translated">응용 프로그램 전체 기본값 무시</target>
        </trans-unit>
        <trans-unit id="fff1ab70d9215d47433358aa873ef34fdced6c34" translate="yes" xml:space="preserve">
          <source>Overriding Parent Class Methods</source>
          <target state="translated">부모 클래스 메서드 재정의</target>
        </trans-unit>
        <trans-unit id="bfaaaf32788c2fd06d3c8e0c98eb03bc280e18a2" translate="yes" xml:space="preserve">
          <source>Overriding attributes</source>
          <target state="translated">속성 무시</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="8e19661733745ef4b2adef80a34cf5d1556477ae" translate="yes" xml:space="preserve">
          <source>Pagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:</source>
          <target state="translated">페이지 매김은 메타 데이터를 사용하는 일반적인 예입니다. 한 번에 표시 할 수있는 것보다 훨씬 많은 게시물이있는 블로그를 상상해보십시오. 다음과 같이 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="53b2b4d9664c2f7ba6c736b20cc936678a185b0b" translate="yes" xml:space="preserve">
          <source>Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</source>
          <target state="translated">Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e82d2ab7546c96cb9a5574e03456855e889721d" translate="yes" xml:space="preserve">
          <source>Part of what makes components so useful is that they let you take complete control of a section of the DOM. This allows for direct DOM manipulation, listening and responding to browser events, and using 3rd party JavaScript libraries in your Ember app.</source>
          <target state="translated">컴포넌트를 유용하게 만드는 요소 중 하나는 DOM 섹션을 완전히 제어 할 수 있다는 것입니다. 이를 통해 직접적인 DOM 조작, 브라우저 이벤트 청취 및 응답, Ember 앱에서 타사 JavaScript 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd681d8590147352e763485982ff52042383b47" translate="yes" xml:space="preserve">
          <source>Passing Arguments</source>
          <target state="translated">인수 전달</target>
        </trans-unit>
        <trans-unit id="1e7148ce0c1621aba30d240c1c19ad8aaf313466" translate="yes" xml:space="preserve">
          <source>Passing Properties to a Component</source>
          <target state="translated">컴포넌트에 속성 전달</target>
        </trans-unit>
        <trans-unit id="d7b6892060d3ef827e6332e1ab8d7813ce2e7481" translate="yes" xml:space="preserve">
          <source>Passing functions with the action helper</source>
          <target state="translated">액션 헬퍼로 함수 전달</target>
        </trans-unit>
        <trans-unit id="8b910b718628891639ad10590baddf47ec63bfe2" translate="yes" xml:space="preserve">
          <source>Passing the Action to the Component</source>
          <target state="translated">구성 요소에 조치 전달</target>
        </trans-unit>
        <trans-unit id="bc9542bcb8c51a85721c7d88e5203af136f9bb1f" translate="yes" xml:space="preserve">
          <source>Path Customization</source>
          <target state="translated">경로 사용자 정의</target>
        </trans-unit>
        <trans-unit id="356cd3bf86420c7cad5947142df308e6e29392c9" translate="yes" xml:space="preserve">
          <source>Pathname customization</source>
          <target state="translated">경로 이름 사용자 정의</target>
        </trans-unit>
        <trans-unit id="4d370c50b556b5821596079c3ed48ddf2fbe93ad" translate="yes" xml:space="preserve">
          <source>Pauses the current test - this is useful for debugging while testing or for test-driving. It allows you to inspect the state of your application at any point. Example (The test will pause before clicking the button):</source>
          <target state="translated">현재 테스트를 일시 중지합니다. 이는 테스트 중 디버깅 또는 테스트 드라이빙에 유용합니다. 언제든지 응용 프로그램의 상태를 검사 할 수 있습니다. 예 (버튼을 클릭하기 전에 테스트가 일시 중지됨) :</target>
        </trans-unit>
        <trans-unit id="4946af784e3408745353f1accc2c18f8c0f6d02d" translate="yes" xml:space="preserve">
          <source>Perform a synchronous transition into another route without attempting to resolve promises, update the URL, or abort any currently active asynchronous transitions (i.e. regular transitions caused by &lt;code&gt;transitionTo&lt;/code&gt; or URL changes).</source>
          <target state="translated">약속을 해결하거나 URL을 업데이트하거나 현재 활성화 된 비동기 전환 (즉, &lt;code&gt;transitionTo&lt;/code&gt; 또는 URL 변경으로 인한 규칙적인 전환)을 시도하지 않고 다른 경로로 동기 전환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="f12c5f85d68b2c1cf86b757e8d7188dc87be03b5" translate="yes" xml:space="preserve">
          <source>Persisting Records</source>
          <target state="translated">지속 기록</target>
        </trans-unit>
        <trans-unit id="7681a0376373e3089f3cc1d9cb621f731b425cd6" translate="yes" xml:space="preserve">
          <source>Picking different components to render in response to the data allows you to have different template and behavior for each case. The &lt;code&gt;{{component}}&lt;/code&gt; helper is a powerful tool for improving code modularity.</source>
          <target state="translated">데이터에 응답하여 렌더링 할 다른 구성 요소를 선택하면 각 사례마다 다른 템플릿과 동작을 가질 수 있습니다. &lt;code&gt;{{component}}&lt;/code&gt; 도우미 코드의 모듈화를 개선하기위한 강력한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e1a35f314bf2633bdff792cb61a30fd24db73276" translate="yes" xml:space="preserve">
          <source>Planning Your App</source>
          <target state="translated">앱 계획</target>
        </trans-unit>
        <trans-unit id="10ab891c24a563405b3a70b1ca34ebe464adb253" translate="yes" xml:space="preserve">
          <source>Please note: This is not for normal usage, and should be used sparingly.</source>
          <target state="translated">참고 : 이것은 정상적인 사용을위한 것이 아니며 드물게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="651987c8f13c93d564a719b93607cd420d73a63f" translate="yes" xml:space="preserve">
          <source>Please note: any property changes made during this event will have no effect on object observers.</source>
          <target state="translated">참고 :이 이벤트 중에 변경된 속성은 개체 관찰자에게 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97a8fb33f7301b7d070bb6b9b6f5697d38d45f2d" translate="yes" xml:space="preserve">
          <source>Pluralization Customization</source>
          <target state="translated">복수화 사용자 정의</target>
        </trans-unit>
        <trans-unit id="861260cecd797e42301015d1972945d6ccce6883" translate="yes" xml:space="preserve">
          <source>Polyfill</source>
          <target state="translated">Polyfill</target>
        </trans-unit>
        <trans-unit id="989fc91d044783d05d714e433d3e90dca9bdf4da" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
          <target state="translated">Polymorphism</target>
        </trans-unit>
        <trans-unit id="b60b227dfc72ce2592d5e011bdf46ba68f6f3eeb" translate="yes" xml:space="preserve">
          <source>Polymorphism is a powerful concept which allows a developer to abstract common functionality into a base class. Consider the following example: a user with multiple payment methods. They could have a linked PayPal account, and a couple credit cards on file.</source>
          <target state="translated">다형성은 개발자가 공통 기능을 기본 클래스로 추상화 할 수있는 강력한 개념입니다. 다음 예를 고려하십시오. 여러 지불 방법을 가진 사용자. 그들은 연결된 PayPal 계정과 파일에 신용 카드 몇 개를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb4bbf7cc3d4bc42049240fc08ab58851cd946a" translate="yes" xml:space="preserve">
          <source>Pop object from array or nil if none are left. Works just like &lt;code&gt;pop()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">배열에서 팝 객체 또는 남아 있지 않으면 nil. &lt;code&gt;pop()&lt;/code&gt; 처럼 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="dc996b0d24beeb1d3c79bbc55469c48d769e7cfb" translate="yes" xml:space="preserve">
          <source>Positional Params</source>
          <target state="translated">위치 매개 변수</target>
        </trans-unit>
        <trans-unit id="f2684504bc0f6384c84c477f8be4a0311c5832d7" translate="yes" xml:space="preserve">
          <source>Preloading</source>
          <target state="translated">Preloading</target>
        </trans-unit>
        <trans-unit id="4b1fb7e1484b0ba94928623eb8f36f404667ac59" translate="yes" xml:space="preserve">
          <source>Preventing Transitions via &lt;code&gt;willTransition&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;willTransition&lt;/code&gt; 을 통한 전환 방지</target>
        </trans-unit>
        <trans-unit id="d802d61c8a7392e75323ae02de35b9864c66709a" translate="yes" xml:space="preserve">
          <source>Preventing and Retrying Transitions</source>
          <target state="translated">전환 방지 및 재시도</target>
        </trans-unit>
        <trans-unit id="5013daf65503f91d54eccc1797b76d7e4dcd2880" translate="yes" xml:space="preserve">
          <source>Previously, in the &lt;a href=&quot;../routes-and-templates&quot;&gt;Routes and Templates tutorial&lt;/a&gt;, we set up a &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">이전에는 &lt;a href=&quot;../routes-and-templates&quot;&gt;라우트 및 템플리트 학습서&lt;/a&gt; 에서 &lt;code&gt;rentals&lt;/code&gt; 경로를 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="f9baaec4106faea48eaf7fcd6f074b9e97eaf3ab" translate="yes" xml:space="preserve">
          <source>Process all the jobs sequentially in &lt;code&gt;WORK_QUEUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WORK_QUEUE&lt;/code&gt; 에서 모든 작업을 순차적으로 처리</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="eb5d6e800790dcdd19447fac47669042de50dde8" translate="yes" xml:space="preserve">
          <source>Promise Example;</source>
          <target state="translated">약속 예;</target>
        </trans-unit>
        <trans-unit id="7763424e70cdeb92b8efa1ce1e7ab2fb3c67f143" translate="yes" xml:space="preserve">
          <source>Promise States and Filtering</source>
          <target state="translated">약속 상태 및 필터링</target>
        </trans-unit>
        <trans-unit id="5ea8f6f7f55aefad94d6f37edf953a84817d34aa" translate="yes" xml:space="preserve">
          <source>Promise objects represent the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise&amp;rsquo;s eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">약속 개체는 결국 비동기 작업의 결과를 나타냅니다. 약속과 상호 작용하는 주요 방법은 &lt;code&gt;then&lt;/code&gt; 메소드를 사용하여 약속의 최종 가치 또는 약속을 이행 할 수없는 이유를 받도록 콜백을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="46847c5528bf36a862876e82e64f9301b7d8c435" translate="yes" xml:space="preserve">
          <source>Promise that resolves to the passed value.</source>
          <target state="translated">전달 된 값으로 확인되는 약속.</target>
        </trans-unit>
        <trans-unit id="f90fc3965e7f0b82d63fa7168a48a06bdbb2d8a7" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;Ember.ApplicationInstance, Error&amp;gt;</source>
          <target state="translated">약속 &amp;lt;Ember.ApplicationInstance, 오류&amp;gt;</target>
        </trans-unit>
        <trans-unit id="20dfb17fbcb83737eb52f26791ace1434823d825" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt;</source>
          <target state="translated">Promise&amp;lt;record&amp;gt;</target>
        </trans-unit>
        <trans-unit id="203fae2a257dd496efa85980bf0ba4c7773be142" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt; a promise for the value (record or relationship)</source>
          <target state="translated">약속 (기록) 가치에 대한 약속 (기록 또는 관계)</target>
        </trans-unit>
        <trans-unit id="1e8da2708d11a179d860eb37dfe66600b1bd2b46" translate="yes" xml:space="preserve">
          <source>PromiseProxyMixin</source>
          <target state="translated">PromiseProxyMixin</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="f44a75e9345297610dff0ce9a97e4b57b6b46aab" translate="yes" xml:space="preserve">
          <source>Promises A+ specifies that any exceptions that occur with a promise must be caught by the promises implementation and bubbled to the last handler. For this reason, it is recommended that you always specify a second rejection handler function to &lt;code&gt;then&lt;/code&gt;. However, &lt;code&gt;RSVP.rethrow&lt;/code&gt; will throw the exception outside of the promise, so it bubbles up to your console if in the browser, or domain/cause uncaught exception in Node. &lt;code&gt;rethrow&lt;/code&gt; will also throw the error again so the error can be handled by the promise per the spec.</source>
          <target state="translated">약속 A +는 약속과 함께 발생하는 모든 예외가 약속 구현에 의해 포착되어 마지막 처리기로 버블 링되도록 지정합니다. 따라서 항상 &lt;code&gt;then&lt;/code&gt; 두 번째 거부 처리기 함수를 지정하는 것이 좋습니다 . 그러나 &lt;code&gt;RSVP.rethrow&lt;/code&gt; 는 약속 외부에서 예외를 throw하므로 브라우저에 있으면 콘솔로, 또는 도메인에 도메인 / 원인이 발견되지 않으면 예외가 발생합니다. &lt;code&gt;rethrow&lt;/code&gt; 는 오류를 다시 발생시켜 스펙에 따라 약속에 따라 오류를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="216c902fd90fd7f61531c27c5a86d60085ec25e9" translate="yes" xml:space="preserve">
          <source>Promises Not Detected</source>
          <target state="translated">감지되지 않은 약속</target>
        </trans-unit>
        <trans-unit id="aaca97f965d2c31995d03cad0b27e350c3445416" translate="yes" xml:space="preserve">
          <source>Promises can also be said to &lt;em&gt;resolve&lt;/em&gt; a value. If this value is also a promise, then the original promise's settled state will match the value's settled state. So a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that rejects will itself reject, and a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that fulfills will itself fulfill.</source>
          <target state="translated">약속은 또한 가치 를 &lt;em&gt;해결&lt;/em&gt; 한다고 말할 수 있습니다 . 이 값이 약속 인 경우 원래 약속의 정산 상태는 값의 정산 상태와 일치합니다. 그러므로 거절 하는 약속을 &lt;em&gt;해결&lt;/em&gt; 하는 약속 자체는 거절하고, 성취 하는 약속을 &lt;em&gt;해결&lt;/em&gt; 하는 약속 자체는 성취 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f4ddbbce9b9a96df78d3c916a6239398660cebc" translate="yes" xml:space="preserve">
          <source>Promises generated by Ember are all labeled by default. You can also label your own RSVP Promises to find them in the Inspector's Promises tab. All RSVP methods can take a label as the final argument.</source>
          <target state="translated">Ember에 의해 생성 된 약속은 기본적으로 모두 레이블이 붙어 있습니다. 또한 자신의 RSVP 약속에 레이블을 지정하여 Inspector 's Promises 탭에서 찾을 수 있습니다. 모든 RSVP 메소드는 레이블을 최종 인수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="763b5a177da3472a739c49add6d1a21b1ef06c5d" translate="yes" xml:space="preserve">
          <source>Promises have different colors based on their state.</source>
          <target state="translated">약속의 상태에 따라 색상이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f72d01a967e01e14a4a0fa223b3309202aa7c45b" translate="yes" xml:space="preserve">
          <source>Promises shine when abstracting away asynchronous interactions such as &lt;code&gt;XMLHttpRequest&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 와 같은 비동기식 상호 작용을 추상화 할 때 빛을 발 합니다.</target>
        </trans-unit>
        <trans-unit id="9229a94589162572814117eb770a291cf02fddad" translate="yes" xml:space="preserve">
          <source>Promises that are fulfilled have a fulfillment value and are in the fulfilled state. Promises that are rejected have a rejection reason and are in the rejected state. A fulfillment value is never a thenable.</source>
          <target state="translated">이행되는 약속은 이행 가치를 가지며 이행 상태에 있습니다. 거부 된 약속에는 거부 사유가 있으며 거부 된 상태입니다. 이행 가치는 결코 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="03590df139443945075f2a3bc957119a024699ce" translate="yes" xml:space="preserve">
          <source>Promise|Object</source>
          <target state="translated">Promise|Object</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="536b9006793cf5c3c1070e09df19893db8668d7a" translate="yes" xml:space="preserve">
          <source>Properties and observers allow one object to observe changes to a property on another object. This is one of the fundamental ways that models, controllers and views communicate with each other in an Ember application.</source>
          <target state="translated">속성 및 관찰자는 한 개체가 다른 개체의 속성 변경을 관찰 할 수 있도록합니다. 이것은 Ember 응용 프로그램에서 모델, 컨트롤러 및 뷰가 서로 통신하는 기본 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="82033eb711807359e0eec9de4a43a4d74d92c987" translate="yes" xml:space="preserve">
          <source>Properties can be chained as well:</source>
          <target state="translated">속성도 연결할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5c379650924c833d1858287bc08588ceb832a8a0" translate="yes" xml:space="preserve">
          <source>Properties that are defined on the model but are omitted in the normalized JSON API document object will not be updated. Properties that are included in the normalized JSON API document object but not defined on the Model will be ignored.</source>
          <target state="translated">모델에 정의되어 있지만 정규화 된 JSON API 문서 오브젝트에서 생략 된 특성은 업데이트되지 않습니다. 정규화 된 JSON API 문서 객체에는 포함되어 있지만 모델에는 정의되지 않은 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d9e37b396787a5cb09465045bf0f0a4eab7185e" translate="yes" xml:space="preserve">
          <source>Property Observers</source>
          <target state="translated">부동산 관찰자</target>
        </trans-unit>
        <trans-unit id="3249cd85365c1d97e6d4a3239b88af5d064671ab" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument, and the list of modules and exports as the second.</source>
          <target state="translated">자산 경로를 첫 번째 인수로 제공하고 모듈 및 내보내기 목록을 두 번째 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7ccdfdc46e55a1f8f8e8698100457fdda15b9f" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument:</source>
          <target state="translated">자산 경로를 첫 번째 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="804a830ba49ef5270d658059a3cc0bf26f755759" translate="yes" xml:space="preserve">
          <source>Providing Markup to a Component</source>
          <target state="translated">구성 요소에 마크 업 제공</target>
        </trans-unit>
        <trans-unit id="5c9b1ac36b5021ea213e2a9b52e09401d0c16a5b" translate="yes" xml:space="preserve">
          <source>Proxies to the serializer's &lt;code&gt;serialize&lt;/code&gt; method.</source>
          <target state="translated">시리얼 라이저의 &lt;code&gt;serialize&lt;/code&gt; 메소드로 프록시합니다 .</target>
        </trans-unit>
        <trans-unit id="127bb9e4bb030d22e2337f3c5cdd29d2359e0a2d" translate="yes" xml:space="preserve">
          <source>ProxyMixin</source>
          <target state="translated">ProxyMixin</target>
        </trans-unit>
        <trans-unit id="c4a9924b7849758c869d4fd5e52d97bd8b26ff5e" translate="yes" xml:space="preserve">
          <source>Push some data for a given type into the store.</source>
          <target state="translated">주어진 유형에 대한 일부 데이터를 상점으로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="9536ee10c3ab2432a5e6558f3207239d0d2ea555" translate="yes" xml:space="preserve">
          <source>Push some raw data into the store.</source>
          <target state="translated">일부 원시 데이터를 상점으로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="9b601bad7a8b3234afd2de3a37d3cb2f2f119973" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array if it is not already present in the array.</source>
          <target state="translated">배열에 개체가 없으면 배열의 끝으로 개체를 밉니다.</target>
        </trans-unit>
        <trans-unit id="5a5340b1561d715113dc2d332842eae59747ca32" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array. Works just like &lt;code&gt;push()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">객체를 어레이의 끝으로 밉니다. &lt;code&gt;push()&lt;/code&gt; 처럼 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="700f90c6bd512a32dbfb55478282f3c7731cdb78" translate="yes" xml:space="preserve">
          <source>Pushing Records</source>
          <target state="translated">기록 밀기</target>
        </trans-unit>
        <trans-unit id="08491627624f56833d6474da961363d94fe64101" translate="yes" xml:space="preserve">
          <source>Pushing Records into the Store</source>
          <target state="translated">저장소로 레코드 푸시</target>
        </trans-unit>
        <trans-unit id="ba83f3a04b35edb4a33611352a88476fef56f328" translate="yes" xml:space="preserve">
          <source>QUnit example:</source>
          <target state="translated">QUnit 예 :</target>
        </trans-unit>
        <trans-unit id="c5aad12964a69eb6cc9ccef39e0f740e43015f0f" translate="yes" xml:space="preserve">
          <source>QUnit passes in an object called an &lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; to each test function. An &lt;code&gt;assert&lt;/code&gt; has functions, such as &lt;code&gt;equal()&lt;/code&gt;, that allow your test to check for conditions within the test environment. A test must have one passing assert to be successful.</source>
          <target state="translated">QUnit은 &lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; 라는 객체 를 각 테스트 기능에 전달합니다. &lt;code&gt;assert&lt;/code&gt; 과 같은 기능을 가지고있다 &lt;code&gt;equal()&lt;/code&gt; 테스트는 테스트 환경 내에서 조건을 확인 할 수 있습니다. 테스트에 성공하려면 하나의 합격 주장이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3229861d9c9111cf61a19e43da48ddbbd1b48efd" translate="yes" xml:space="preserve">
          <source>Query Parameters</source>
          <target state="translated">쿼리 매개 변수</target>
        </trans-unit>
        <trans-unit id="5139ef15ef3085f1688a1e87d332dfd36e0ceff6" translate="yes" xml:space="preserve">
          <source>Query param values are cast to the same datatype as the default value, e.g. a URL change from &lt;code&gt;/?page=3&lt;/code&gt; to &lt;code&gt;/?page=2&lt;/code&gt; will set &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;page&lt;/code&gt; property to the number &lt;code&gt;2&lt;/code&gt;, rather than the string &lt;code&gt;&quot;2&quot;&lt;/code&gt;. The same also applies to boolean default values. If the default value is an array, the string will be parsed using &lt;code&gt;JSON.parse&lt;/code&gt;.</source>
          <target state="translated">쿼리 PARAM 값은 기본값에서 예 URL 변경과 같은 데이터 형식으로 캐스팅된다 &lt;code&gt;/?page=3&lt;/code&gt; 에 &lt;code&gt;/?page=2&lt;/code&gt; 설정합니다 &lt;code&gt;controller:articles&lt;/code&gt; 의 &lt;code&gt;page&lt;/code&gt; 수에 속성을 &lt;code&gt;2&lt;/code&gt; 오히려 문자열보다, &lt;code&gt;&quot;2&quot;&lt;/code&gt; . 부울 기본값에도 동일하게 적용됩니다. 기본값이 배열이면 &lt;code&gt;JSON.parse&lt;/code&gt; 를 사용하여 문자열을 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="0aca39e962863236da8c92fd756de102fb200868" translate="yes" xml:space="preserve">
          <source>Query parameters are optional key-value pairs that appear to the right of the &lt;code&gt;?&lt;/code&gt; in a URL. For example, the following URL has two query params, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;page&lt;/code&gt;, with respective values &lt;code&gt;ASC&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">쿼리 매개 변수는 &lt;code&gt;?&lt;/code&gt; 의 오른쪽에 나타나는 선택적 키-값 쌍입니다 . URL에서. 예를 들어 다음 URL에는 &lt;code&gt;sort&lt;/code&gt; 및 &lt;code&gt;page&lt;/code&gt; 라는 두 개의 쿼리 매개 변수가 있으며 각각 &lt;code&gt;ASC&lt;/code&gt; 및 &lt;code&gt;2&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b0f8ce0e88182d09e5b36ad33c8efbb1f3a42a78" translate="yes" xml:space="preserve">
          <source>Query params allow for additional application state to be serialized into the URL that can't otherwise fit into the &lt;em&gt;path&lt;/em&gt; of the URL (i.e. everything to the left of the &lt;code&gt;?&lt;/code&gt;). Common use cases for query params include representing the current page number in a paginated collection, filter criteria, or sorting criteria.</source>
          <target state="translated">쿼리 매개 변수를 사용하면 URL &lt;em&gt;경로&lt;/em&gt; 에 맞지 않는 추가 응용 프로그램 상태를 URL에 직렬화 할 수 있습니다 (예 : &lt;code&gt;?&lt;/code&gt; 왼쪽에있는 모든 것 ). 쿼리 매개 변수의 일반적인 사용 사례에는 페이지 매김 모음, 필터 기준 또는 정렬 기준으로 현재 페이지 번호를 나타내는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b1782f7b18226435ee790bf1a339595b9fcaafce" translate="yes" xml:space="preserve">
          <source>Query params are declared on route-driven controllers. For example, to configure query params that are active within the &lt;code&gt;articles&lt;/code&gt; route, they must be declared on &lt;code&gt;controller:articles&lt;/code&gt;.</source>
          <target state="translated">쿼리 매개 변수는 경로 기반 컨트롤러에서 선언됩니다. 예를 들어, &lt;code&gt;articles&lt;/code&gt; 라우트 내에서 활성화 된 쿼리 매개 변수를 구성 하려면 &lt;code&gt;controller:articles&lt;/code&gt; 에서 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1e8c5f9eb6a51268771357d73e5c3d414ee77b7" translate="yes" xml:space="preserve">
          <source>Query params that require additional customization can be provided along with strings in the &lt;code&gt;queryParams&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;queryParams&lt;/code&gt; 배열의 문자열과 함께 추가 사용자 정의가 필요한 쿼리 매개 변수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84d51a6c79840a7e20e6f3b3c232167ddd101fdb" translate="yes" xml:space="preserve">
          <source>Querying for A Single Record</source>
          <target state="translated">단일 레코드 쿼리</target>
        </trans-unit>
        <trans-unit id="bab1721e2fbda766f83183971199264a105762c8" translate="yes" xml:space="preserve">
          <source>Querying for Multiple Records</source>
          <target state="translated">여러 레코드 쿼리</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">빠른 시작</target>
        </trans-unit>
        <trans-unit id="9e2ff6c5483cb39d97a402f850cb39e32d0c9dbc" translate="yes" xml:space="preserve">
          <source>RSVP</source>
          <target state="translated">RSVP</target>
        </trans-unit>
        <trans-unit id="cc85f8587031356b78b2448d63c222acc180e5f9" translate="yes" xml:space="preserve">
          <source>RSVP.EventTarget</source>
          <target state="translated">RSVP.EventTarget</target>
        </trans-unit>
        <trans-unit id="8c3018eec21a26738e481a8b5ea2b8b6ade95786" translate="yes" xml:space="preserve">
          <source>RSVP.Promise</source>
          <target state="translated">RSVP.Promise</target>
        </trans-unit>
        <trans-unit id="4e1ef1585228db21136c63e2c103fa2fc8cba9b0" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;any&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;any&amp;gt;</target>
        </trans-unit>
        <trans-unit id="02ed91fc301225e19af656a773481bbe02910c4f" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;undefined&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;undefined&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0e57c7077cfdd6dccd21781d8c00850d345148e3" translate="yes" xml:space="preserve">
          <source>Rather than create an arbitrary set of conventions, Ember Data is designed to work out of the box with &lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API&lt;/a&gt;. JSON API is a formal specification for building conventional, robust, and performant APIs that allow clients and servers to communicate model data.</source>
          <target state="translated">Ember Data는 임의의 규칙 집합을 생성하지 않고 &lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API&lt;/a&gt; 와 함께 기본적 으로 작동하도록 설계되었습니다 . JSON API는 클라이언트와 서버가 모델 데이터와 통신 할 수 있도록하는 강력하고 성능이 뛰어난 기존 API를 빌드하기위한 공식 사양입니다.</target>
        </trans-unit>
        <trans-unit id="20a3458f1862c89f455c490634fb5f573475fbc2" translate="yes" xml:space="preserve">
          <source>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</source>
          <target state="translated">다양한 런 루프 스케줄링 기능을 내부적으로 호출하는 더 높은 수준의 앱 코드를 작성하는 대신 커버를 제거하고 원시 런 루프 상호 작용을 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="02143f2c5abf0fcc77c1815c31c2586f2ab77a8d" translate="yes" xml:space="preserve">
          <source>Re-route to the existing url</source>
          <target state="translated">기존 URL로 다시 라우팅</target>
        </trans-unit>
        <trans-unit id="c853a28871d264d43a0d86e34fdf1c1f3e7482f4" translate="yes" xml:space="preserve">
          <source>Readonly Nested Data</source>
          <target state="translated">읽기 전용 중첩 데이터</target>
        </trans-unit>
        <trans-unit id="b129f9f5e547d2585b00b80301e33d0ccd886142" translate="yes" xml:space="preserve">
          <source>Record States and Filtering</source>
          <target state="translated">기록 상태 및 필터링</target>
        </trans-unit>
        <trans-unit id="779639f77d26423e55093890463c73df4117f2b4" translate="yes" xml:space="preserve">
          <source>RecordReference</source>
          <target state="translated">RecordReference</target>
        </trans-unit>
        <trans-unit id="e51c55255be9007d473b3c04b4553c2a27d6f03b" translate="yes" xml:space="preserve">
          <source>Records</source>
          <target state="translated">Records</target>
        </trans-unit>
        <trans-unit id="09f48f492f46fd16811c910592ad171170771ab8" translate="yes" xml:space="preserve">
          <source>Records in Ember Data are persisted on a per-instance basis. Call &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; on any instance of &lt;code&gt;DS.Model&lt;/code&gt; and it will make a network request.</source>
          <target state="translated">Ember Data의 레코드는 인스턴스별로 유지됩니다. &lt;code&gt;DS.Model&lt;/code&gt; 의 모든 인스턴스에서 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 네트워크 요청이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93f89c3ab4a799a6a0aab99eb1bb7100ea88724d" translate="yes" xml:space="preserve">
          <source>Records that already exist on the backend are updated using the HTTP &lt;code&gt;PATCH&lt;/code&gt; verb.</source>
          <target state="translated">백엔드에 이미 존재하는 레코드는 HTTP &lt;code&gt;PATCH&lt;/code&gt; 동사를 사용하여 업데이트 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f7c32c0b4917effc40dd0a0959efa8e648135b6" translate="yes" xml:space="preserve">
          <source>Records without an &lt;code&gt;id&lt;/code&gt; property are not considered embedded records, model instances must have an &lt;code&gt;id&lt;/code&gt; property to be used with Ember Data.</source>
          <target state="translated">없이 기록 &lt;code&gt;id&lt;/code&gt; 속성이 포함 된 기록으로 간주되지 않습니다, 모델 인스턴스가 있어야합니다 &lt;code&gt;id&lt;/code&gt; 엠버 데이터로 사용되는 속성을.</target>
        </trans-unit>
        <trans-unit id="5ac9a9807e12ead40a070a8626218b2274db6816" translate="yes" xml:space="preserve">
          <source>Recovering from Rejection</source>
          <target state="translated">거절에서 회복</target>
        </trans-unit>
        <trans-unit id="60e22121bdd0bc71cdb2bae2a3aa577006b2eae9" translate="yes" xml:space="preserve">
          <source>Redirecting</source>
          <target state="translated">Redirecting</target>
        </trans-unit>
        <trans-unit id="6bfa4764dfd3c083f396267379ee172ae1854a8d" translate="yes" xml:space="preserve">
          <source>Refer to documentation for &lt;code&gt;beforeModel&lt;/code&gt; for a description of transition-pausing semantics when a promise is returned from this hook.</source>
          <target state="translated">이 후크에서 약속이 리턴 될 때 전이 일시 정지 시맨틱에 대한 설명은 &lt;code&gt;beforeModel&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99f62095529c6af5ce3c4c2976cf5e8e543250eb" translate="yes" xml:space="preserve">
          <source>References to other records should be done by ID. For example, if you have a model with a &lt;code&gt;hasMany&lt;/code&gt; relationship:</source>
          <target state="translated">다른 기록에 대한 언급은 ID로 수행해야합니다. 예를 들어, &lt;code&gt;hasMany&lt;/code&gt; 관계 가있는 모델이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="69f6bad51245a7a68b6a5d503ecf8f42a933df09" translate="yes" xml:space="preserve">
          <source>Reflexive Relations</source>
          <target state="translated">재귀 관계</target>
        </trans-unit>
        <trans-unit id="6224a939ef652c56dddd065c6b6575aface1416e" translate="yes" xml:space="preserve">
          <source>Refresh the model on this route and any child routes, firing the &lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks in a similar fashion to how routes are entered when transitioning in from other route. The current route params (e.g. &lt;code&gt;article_id&lt;/code&gt;) will be passed in to the respective model hooks, and if a different model is returned, &lt;code&gt;setupController&lt;/code&gt; and associated route hooks will re-fire as well.</source>
          <target state="translated">다른 경로에서 전환 할 때 경로가 입력되는 방식과 유사한 방식으로 &lt;code&gt;beforeModel&lt;/code&gt; , &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;afterModel&lt;/code&gt; 후크 를 실행하여이 경로 및 모든 하위 경로에서 모델을 새로 고칩니다 . 현재 경로 매개 변수 (예 : &lt;code&gt;article_id&lt;/code&gt; )가 해당 모델 후크로 전달되고 다른 모델이 리턴되면 &lt;code&gt;setupController&lt;/code&gt; 및 연관된 경로 후크도 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5db4fe93ba98fe1b576309acf2388052f2a36a" translate="yes" xml:space="preserve">
          <source>RegExp</source>
          <target state="translated">RegExp</target>
        </trans-unit>
        <trans-unit id="06b326b8df4964d11fe7f98ffc257e678212ac9e" translate="yes" xml:space="preserve">
          <source>Regardless of how the URL becomes set, the Ember router then maps the current URL to one or more route handlers. A route handler can do several things:</source>
          <target state="translated">URL 설정 방식에 관계없이 Ember 라우터는 현재 URL을 하나 이상의 경로 처리기에 매핑합니다. 라우트 핸들러는 여러 가지 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ef3793fbf15d676e0da171536ccb7a8b55c72a" translate="yes" xml:space="preserve">
          <source>Regardless of the serializer used, this metadata is extracted from the response. You can then read it with &lt;code&gt;.get('meta')&lt;/code&gt;.</source>
          <target state="translated">사용 된 시리얼 라이저에 관계없이이 메타 데이터는 응답에서 추출됩니다. 그런 다음 &lt;code&gt;.get('meta')&lt;/code&gt; 으로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="580b18a39e5b39765415c0eed123af6da265aa11" translate="yes" xml:space="preserve">
          <source>Register options for a particular factory.</source>
          <target state="translated">특정 공장에 대한 옵션을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="6291ba0522621d5582aa26e4decc87be7d141a60" translate="yes" xml:space="preserve">
          <source>Register/Unregister additional test helpers.</source>
          <target state="translated">추가 테스트 도우미를 등록 / 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="57ac94516e6ba3226fa58ffc652e3e7312c91e5d" translate="yes" xml:space="preserve">
          <source>Registered factories are &lt;strong&gt;instantiated&lt;/strong&gt; by having &lt;code&gt;create&lt;/code&gt; called on them. Additionally they are &lt;strong&gt;singletons&lt;/strong&gt;, each time they are looked up they return the same instance.</source>
          <target state="translated">등록 된 팩토리는 &lt;code&gt;create&lt;/code&gt; 호출 을 통해 &lt;strong&gt;인스턴스화&lt;/strong&gt; 됩니다 . 또한 그들은 &lt;strong&gt;singleton&lt;/strong&gt; 이며, 조회 할 때마다 동일한 인스턴스를 반환합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63c9b0772d57be72a0c5d903431a873fcdb8a6f2" translate="yes" xml:space="preserve">
          <source>Registering Already Instantiated Objects</source>
          <target state="translated">이미 인스턴스화 된 객체 등록</target>
        </trans-unit>
        <trans-unit id="4e4aa5ae30460fc62431c4dbebe42f4477bbe300" translate="yes" xml:space="preserve">
          <source>Registering Singletons vs. Non-Singletons</source>
          <target state="translated">싱글 톤과 비 싱글 톤 등록</target>
        </trans-unit>
        <trans-unit id="aba41c3a5d53b4b36fb1b8a0fdb902b0488d3a7a" translate="yes" xml:space="preserve">
          <source>Registering a Library</source>
          <target state="translated">도서관 등록</target>
        </trans-unit>
        <trans-unit id="0803d3a3d9f15e36c86ae2132d20124795a72459" translate="yes" xml:space="preserve">
          <source>Registers a factory that can be used for dependency injection (with &lt;code&gt;inject&lt;/code&gt;) or for service lookup. Each factory is registered with a full name including two parts: &lt;code&gt;type:name&lt;/code&gt;.</source>
          <target state="translated">의존성 주입 ( &lt;code&gt;inject&lt;/code&gt; 사용 ) 또는 서비스 검색에 사용할 수있는 팩토리를 등록합니다 . 각 팩토리는 &lt;code&gt;type:name&lt;/code&gt; 의 두 부분을 포함한 전체 이름으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f7e42ab82b7c92882f8e66014048c4f809e7e13" translate="yes" xml:space="preserve">
          <source>Registration keys have two segments split by a colon (&lt;code&gt;:&lt;/code&gt;). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the &lt;code&gt;index&lt;/code&gt; template has the key &lt;code&gt;template:index&lt;/code&gt;. Ember has several built-in factory types, such as &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;route&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, and &lt;code&gt;component&lt;/code&gt;.</source>
          <target state="translated">등록 키는 콜론으로 분할 두 개의 세그먼트가 ( &lt;code&gt;:&lt;/code&gt; ). 첫 번째 세그먼트는 프레임 워크 팩토리 유형이고 두 번째 세그먼트는 특정 팩토리의 이름입니다. 따라서 &lt;code&gt;index&lt;/code&gt; 템플릿에는 key &lt;code&gt;template:index&lt;/code&gt; 키가 있습니다. Ember에는 &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;route&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;component&lt;/code&gt; 와 같은 몇 가지 기본 제공 공장 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74bb08da802a694a3d25bf4c3835ded58d2f6fc6" translate="yes" xml:space="preserve">
          <source>RegistryProxy</source>
          <target state="translated">RegistryProxy</target>
        </trans-unit>
        <trans-unit id="0a580368138bbedf511a06592637b0c30c98bec4" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin</source>
          <target state="translated">RegistryProxyMixin</target>
        </trans-unit>
        <trans-unit id="63a6a6ef6785a3cb9c1352a24ea4357d90e0f58f" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin  (private)</source>
          <target state="translated">RegistryProxyMixin (비공개)</target>
        </trans-unit>
        <trans-unit id="0db97526891b25965235d31bf6cc3d8269a10d30" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin is used to provide public access to specific registry functionality.</source>
          <target state="translated">RegistryProxyMixin은 특정 레지스트리 기능에 대한 공개 액세스를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5b133edab536327af2bd039bb8a3451c0c686b" translate="yes" xml:space="preserve">
          <source>Rejected model promises halt transitions, but because promises are chainable, you can catch promise rejects within the &lt;code&gt;model&lt;/code&gt; hook itself and convert them into fulfills that won't halt the transition.</source>
          <target state="translated">거부 된 모델 약속은 전환을 중단하지만 약속은 체인 가능하므로 &lt;code&gt;model&lt;/code&gt; 후크 자체 에서 약속 거부를 포착 하여 전환을 중단시키지 않는 이행으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229981dd1dc44fcc3bf72493583bb63fa236cecf" translate="yes" xml:space="preserve">
          <source>Relationships</source>
          <target state="translated">Relationships</target>
        </trans-unit>
        <trans-unit id="7ebee1cc4a1ef9624d817353b136be3fe22ab7fc" translate="yes" xml:space="preserve">
          <source>Relationships are usually represented by ids to the record in the relationship. The related records can then be sideloaded in the response under a key for the type.</source>
          <target state="translated">관계는 일반적으로 관계의 레코드에 ID로 표시됩니다. 그런 다음 관련 키를 유형 키 아래의 응답으로 사이드로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4abfee2fa163eac14a7ded7bb1fdab42b33f49a" translate="yes" xml:space="preserve">
          <source>Relationships as Promises</source>
          <target state="translated">약속으로서의 관계</target>
        </trans-unit>
        <trans-unit id="282e0c1116f45802ea510d978c4bb1aaeda3e638" translate="yes" xml:space="preserve">
          <source>Reload the record from the adapter.</source>
          <target state="translated">어댑터에서 레코드를 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="b9032b6f32f6e2281f4ae7c18e28a848286c6415" translate="yes" xml:space="preserve">
          <source>Reloading</source>
          <target state="translated">Reloading</target>
        </trans-unit>
        <trans-unit id="4d8114b387125160739c4384d9e4a3715ae113c8" translate="yes" xml:space="preserve">
          <source>Reloads all of the records in the manyArray. If the manyArray holds a relationship that was originally fetched using a links url Ember Data will revisit the original links url to repopulate the relationship.</source>
          <target state="translated">manyArray의 모든 레코드를 다시로드합니다. manyArray가 링크 URL을 사용하여 원래 가져온 관계를 보유하는 경우 Ember Data는 원래 링크 URL을 다시 방문하여 관계를 다시 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="d6324829793579791ae457de1efbafabdce16f68" translate="yes" xml:space="preserve">
          <source>Reloads the record if it is already loaded. If the record is not loaded it will load the record via &lt;code&gt;store.findRecord&lt;/code&gt;</source>
          <target state="translated">레코드가 이미로드 된 경우 다시로드합니다. 레코드가로드되지 않은 경우 &lt;code&gt;store.findRecord&lt;/code&gt; 를 통해 레코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="5bd1485c9bed37c1cf2bf2094bc180edee39e981" translate="yes" xml:space="preserve">
          <source>Reloads this has-many relationship.</source>
          <target state="translated">이 많은 관계를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="f4276922880097708e01378b7c926ae47b0ca730" translate="yes" xml:space="preserve">
          <source>Relying on autoruns is not a rigorous or efficient way to use the run loop. Wrapping event handlers manually are preferred.</source>
          <target state="translated">자동 실행에 의존하는 것은 런 루프를 사용하는 엄격하거나 효율적인 방법이 아닙니다. 이벤트 핸들러를 수동으로 랩핑하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4656fc9d7b003300b618f2b5e454b26fe556d1b6" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;{{firstName}}&lt;/code&gt; and &lt;code&gt;{{lastName}}&lt;/code&gt; are bound data. That means if the value of one of those properties changes, the DOM will be updated automatically.</source>
          <target state="translated">그 기억 &lt;code&gt;{{firstName}}&lt;/code&gt; 과 &lt;code&gt;{{lastName}}&lt;/code&gt; 바인딩 된 데이터를. 즉, 해당 속성 중 하나의 값이 변경되면 DOM이 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="685e29f4b662e2c0f1a0744e653894d1da2671ad" translate="yes" xml:space="preserve">
          <source>Remember that &lt;em&gt;only events&lt;/em&gt; should ever cause a state transition. You should never call &lt;code&gt;transitionTo()&lt;/code&gt; from outside a state's event handler. If you are tempted to do so, create a new event and send that to the state manager.</source>
          <target state="translated">기억 &lt;em&gt;이벤트 만&lt;/em&gt; 적 상태 전이를 야기한다. 상태 이벤트 핸들러 외부에서 &lt;code&gt;transitionTo()&lt;/code&gt; 를 호출하면 안됩니다 . 그렇게하려는 유혹을 받으면 새로운 이벤트를 만들어이를 상태 관리자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2772f3979b8490dfd9afc9103221e01e92eba84f" translate="yes" xml:space="preserve">
          <source>Remove a previously added helper method.</source>
          <target state="translated">이전에 추가 한 도우미 메소드를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6c924c7cc754f0fab9bce280a8c42f9e3cff21cd" translate="yes" xml:space="preserve">
          <source>Remove all elements from the array. This is useful if you want to reuse an existing array without having to recreate it.</source>
          <target state="translated">배열에서 모든 요소를 ​​제거하십시오. 기존 배열을 다시 만들지 않고 재사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f6355dee47de1f32bf6f9799d78b6fee6bcd492e" translate="yes" xml:space="preserve">
          <source>Remove all occurrences of an object in the array.</source>
          <target state="translated">배열에서 객체의 모든 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="152c1eaa085138cfa9d77a0942ce9534a3d76fe7" translate="yes" xml:space="preserve">
          <source>Remove an event listener</source>
          <target state="translated">이벤트 리스너 제거</target>
        </trans-unit>
        <trans-unit id="4aa91b51bc12a3f5d89e5b53340b91ffc806cb11" translate="yes" xml:space="preserve">
          <source>Remove an object at the specified index using the &lt;code&gt;replace()&lt;/code&gt; primitive method. You can pass either a single index, or a start and a length.</source>
          <target state="translated">&lt;code&gt;replace()&lt;/code&gt; 프리미티브 메소드를 사용하여 지정된 인덱스에서 오브젝트를 제거하십시오 . 단일 인덱스 또는 시작과 길이를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8553b7b30d27bd6e52896284d645032511283c5" translate="yes" xml:space="preserve">
          <source>Remove an observer you have previously registered on this object. Pass the same key, target, and method you passed to &lt;code&gt;addObserver()&lt;/code&gt; and your target will no longer receive notifications.</source>
          <target state="translated">이전에이 객체에 등록한 관찰자를 제거하십시오. &lt;code&gt;addObserver()&lt;/code&gt; 전달한 것과 동일한 키, 대상 및 메소드를 전달하면 대상이 더 이상 알림을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fff707f00d08e1f5dfe2689260813207706b7e3" translate="yes" xml:space="preserve">
          <source>Removes an array observer from the object if the observer is current registered. Calling this method multiple times with the same object will have no effect.</source>
          <target state="translated">관찰자가 현재 등록되어 있으면 객체에서 배열 관찰자를 제거합니다. 동일한 객체로이 메소드를 여러 번 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="18f9a7bd887e2ad04e12b6586614eadc5a5bf73f" translate="yes" xml:space="preserve">
          <source>Removes each object in the passed enumerable from the receiver.</source>
          <target state="translated">전달 된 열거 형의 각 객체를 수신자에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="53ebb1fef0864af0278ae31f4ac0ec30dc3e82ad" translate="yes" xml:space="preserve">
          <source>Removing Objects</source>
          <target state="translated">객체 제거</target>
        </trans-unit>
        <trans-unit id="6d84c2db53b8c4b4553001a5c3d3b995a8fc5d9b" translate="yes" xml:space="preserve">
          <source>Removing Relationships</source>
          <target state="translated">관계 제거</target>
        </trans-unit>
        <trans-unit id="041f6ca8e2d2dc5b856e1d078db74ba2885f4518" translate="yes" xml:space="preserve">
          <source>Rendering Performance</source>
          <target state="translated">렌더링 성능</target>
        </trans-unit>
        <trans-unit id="0985a0ecfabc2231124bd8de762617aaeafd5bd5" translate="yes" xml:space="preserve">
          <source>Rendering a Template</source>
          <target state="translated">템플릿 렌더링</target>
        </trans-unit>
        <trans-unit id="3bf2cfd82c10e27a15ca73d1aff040c4b9aabd81" translate="yes" xml:space="preserve">
          <source>Renders the view again. This will work regardless of whether the view is already in the DOM or not. If the view is in the DOM, the rendering process will be deferred to give bindings a chance to synchronize.</source>
          <target state="translated">뷰를 다시 렌더링합니다. 뷰가 이미 DOM에 있는지 여부에 관계없이 작동합니다. 뷰가 DOM에 있으면 렌더링 프로세스가 지연되어 바인딩에 동기화 할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90fcf58a93bf37c133e53c27b59ac552b7f86095" translate="yes" xml:space="preserve">
          <source>Reopening Classes and Instances</source>
          <target state="translated">클래스와 인스턴스 다시 열기</target>
        </trans-unit>
        <trans-unit id="68fd737319a0b0cb58525f439e8f98a23d49c821" translate="yes" xml:space="preserve">
          <source>Replace all the receiver's content with content of the argument. If argument is an empty array receiver will be cleared.</source>
          <target state="translated">수신자의 모든 내용을 인수의 내용으로 교체하십시오. 인수가 빈 배열 인 경우, 리시버가 클리어됩니다.</target>
        </trans-unit>
        <trans-unit id="12205427cfdf5328a7ffdc0d916e8bdc2aeef4ed" translate="yes" xml:space="preserve">
          <source>Replacement for &lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; The only difference is this uses an instance of &lt;code&gt;Ember.Test.Promise&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; 의 교체 유일한 차이점은 &lt;code&gt;Ember.Test.Promise&lt;/code&gt; 인스턴스를 사용 한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="38df34ec5043e01b14b58ab782972627050d5e4e" translate="yes" xml:space="preserve">
          <source>Replaces underscores, spaces, or camelCase with dashes.</source>
          <target state="translated">밑줄, 공백 또는 camelCase를 대시로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="551c187c4562e07235299d81c81fb5553d3be6b8" translate="yes" xml:space="preserve">
          <source>Replacing history entries</source>
          <target state="translated">히스토리 항목 교체</target>
        </trans-unit>
        <trans-unit id="db33df2b86e0548c5026c0e2feca083dd46c73b8" translate="yes" xml:space="preserve">
          <source>Reporting a problem</source>
          <target state="translated">문제보고</target>
        </trans-unit>
        <trans-unit id="5a3259ad102284e341592f2a49ccbc5935cfc92a" translate="yes" xml:space="preserve">
          <source>Represents a list of records whose membership is determined by the store. As records are created, loaded, or modified, the store evaluates them to determine if they should be part of the record array.</source>
          <target state="translated">상점에서 멤버십을 판별 한 레코드 목록을 나타냅니다. 레코드가 작성,로드 또는 수정 될 때 저장소는 레코드를 평가하여 레코드 배열의 일부 여야하는지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="97471577bb242ec38248e3746d99aa261e14fdfd" translate="yes" xml:space="preserve">
          <source>Represents an ordered list of records whose order and membership is determined by the adapter. For example, a query sent to the adapter may trigger a search on the server, whose results would be loaded into an instance of the &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;.</source>
          <target state="translated">어댑터가 주문 및 멤버십을 판별하는 정렬 된 레코드 목록을 나타냅니다. 예를 들어, 어댑터로 전송 된 쿼리는 서버에서 검색을 트리거 할 수 있으며 그 결과는 &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; 의 인스턴스에로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="f983e24377129faa7d20942c23e23254dfe09a06" translate="yes" xml:space="preserve">
          <source>Represents the URL of the root of the application, often '/'. This prefix is assumed on all routes defined on this router.</source>
          <target state="translated">응용 프로그램 루트의 URL (대개 '/')을 나타냅니다. 이 접두사는이 라우터에 정의 된 모든 경로에서 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="99a531ee74a48c9f139d54302917c31212c36e9a" translate="yes" xml:space="preserve">
          <source>Represents the model's class name as a string. This can be used to look up the model's class name through &lt;code&gt;DS.Store&lt;/code&gt;'s modelFor method.</source>
          <target state="translated">모델의 클래스 이름을 문자열로 나타냅니다. 이것은 &lt;code&gt;DS.Store&lt;/code&gt; 의 modelFor 메소드를 통해 모델의 클래스 이름을 찾는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a446bfa5dd57c064db5b7db62b9216d2d4fe7f6" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;/person/1&lt;/code&gt;. Requests for &lt;code&gt;user-profile&lt;/code&gt; would now target &lt;code&gt;/user_profile/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 대한 요청 은 이제 &lt;code&gt;/person/1&lt;/code&gt; 을 대상으로 합니다. &lt;code&gt;user-profile&lt;/code&gt; 요청 은 이제 &lt;code&gt;/user_profile/1&lt;/code&gt; 을 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e23fb7f5045063dea88f661c92bdf8761f6d2db8" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 대한 요청 은 이제 &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt; 을 대상으로 합니다 .</target>
        </trans-unit>
        <trans-unit id="dbed8372b111ece5b7dea26366e56a504eeb78ba" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 요청 은 이제 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 을 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="39adf7b336b15481b1d246e2d2e38d4faf23c063" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; 모델에 대한 요청 은 이제 &lt;code&gt;/api/1/people/1&lt;/code&gt; 을 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="b5a6ae7596913135d59e602a8445cd7c591187b4" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;/api/1/post/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; 모델에 대한 요청 은 이제 &lt;code&gt;/api/1/post/&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="47352f3ca02fa7dd1203791432c99adf3ee88922" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/post/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; 모델에 대한 요청 은 이제 &lt;code&gt;https://api.example.com/post/&lt;/code&gt; 를 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="507eba662c0bdfc5e6dcd2e527c591cbe849d43c" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 모델에 대한 요청 은 이제 &lt;code&gt;/api/1/people/1&lt;/code&gt; 을 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="c77ddbd00374e8cd6c0cc4272b91fdfbb3d601e3" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 모델에 대한 요청 은 이제 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 을 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="7d1ce0dbae3dcf8f899bd4893d4663dda4cf2c7d" translate="yes" xml:space="preserve">
          <source>Rerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed, you can proceed with enhancing your application without the sea of deprecation warnings clouding your log.</source>
          <target state="translated">워크 플로우 파일을 업데이트 할 때 테스트 스위트를 다시 실행하면 더 이상 사용되지 않는지 검증해야합니다. 완료되면 사용 중단 경고가 로그에 흐리게 표시되지 않고 애플리케이션 향상을 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1459337c0ecc835d1d2041391957329cf96ed92d" translate="yes" xml:space="preserve">
          <source>Reset the application. This is typically used only in tests. It cleans up the application in the following order:</source>
          <target state="translated">응용 프로그램을 재설정하십시오. 이것은 일반적으로 테스트에서만 사용됩니다. 다음 순서로 응용 프로그램을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="9799189643ce709a24fb886e74561834ed7c1a6f" translate="yes" xml:space="preserve">
          <source>Resetting Presentation State on Attribute Change with &lt;code&gt;didUpdateAttrs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;didUpdateAttrs&lt;/code&gt; 를 사용 하여 속성 변경시 프리젠 테이션 상태 재설정</target>
        </trans-unit>
        <trans-unit id="14de0ea979680e88715bf0fb25e6a27c36244df1" translate="yes" xml:space="preserve">
          <source>Responding to Browser Events</source>
          <target state="translated">브라우저 이벤트에 응답</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="5dd10def5c86f482d9171ac3d500c6b0ae25364b" translate="yes" xml:space="preserve">
          <source>Resumes a test paused by &lt;code&gt;pauseTest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pauseTest&lt;/code&gt; 에 의해 일시 중지 된 테스트를 다시 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="c136ec01ad8662f631bfe9cf5dd76daebe9695f1" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from an Object, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Object에서 속성 값을 검색하거나 속성이 &lt;code&gt;undefined&lt;/code&gt; 를 반환하는 경우 기본값을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="97f8358f1a7527129a6026137d59d3b142bea4da" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from the object.</source>
          <target state="translated">객체에서 속성 값을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c2507d71833d1926fc8ca2bfcba6650b2356a523" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">속성 값 또는 속성이 &lt;code&gt;undefined&lt;/code&gt; 를 반환하는 경우 기본값을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="c9b109a01cbb856b78796ff1f23e3ed037d6d59e" translate="yes" xml:space="preserve">
          <source>Retrieving Multiple Records</source>
          <target state="translated">여러 레코드 검색</target>
        </trans-unit>
        <trans-unit id="f585070c87519f1f46d5aa282e338ef3ef4cffe8" translate="yes" xml:space="preserve">
          <source>Retrieving Related Model Records</source>
          <target state="translated">관련 모델 레코드 검색</target>
        </trans-unit>
        <trans-unit id="5763b513c21e726fa47e619aeec98e7a63c47120" translate="yes" xml:space="preserve">
          <source>Retrieving Related Records</source>
          <target state="translated">관련 레코드 검색</target>
        </trans-unit>
        <trans-unit id="3ea11ae149c9ff5b4ef4d8e06d23a82d3df6baab" translate="yes" xml:space="preserve">
          <source>Retrieving a Single Record</source>
          <target state="translated">단일 레코드 검색</target>
        </trans-unit>
        <trans-unit id="9cd9632ea5c6744340a949d9498150ea0dd8d956" translate="yes" xml:space="preserve">
          <source>Return a specific registered option for a particular factory.</source>
          <target state="translated">특정 팩토리에 대해 등록 된 특정 옵션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29ebe6c216062fb1ce4cf798a7f1e3baeab920a9" translate="yes" xml:space="preserve">
          <source>Return registered options for a particular factory.</source>
          <target state="translated">특정 팩토리에 대해 등록 된 옵션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26b22776384430c648a6b859ff17b84f59ea040d" translate="yes" xml:space="preserve">
          <source>Return the new cumulative value.</source>
          <target state="translated">새로운 누적 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="edee4fec8219eea58f41fb844b109d44f9727045" translate="yes" xml:space="preserve">
          <source>Return the registered options for all factories of a type.</source>
          <target state="translated">유형의 모든 팩토리에 대해 등록 된 옵션을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3f2c37eae2ce5f96df692aaeedf57af072ef9d9e" translate="yes" xml:space="preserve">
          <source>Return to Step 1</source>
          <target state="translated">1 단계로 돌아 가기</target>
        </trans-unit>
        <trans-unit id="86661c3a6c5cd6befa4e37cc90df459f0d9bf691" translate="yes" xml:space="preserve">
          <source>Return value from invoking the passed function. Please note, when called within an existing loop, no return value is possible.</source>
          <target state="translated">전달 된 함수를 호출하여 값을 반환합니다. 기존 루프 내에서 호출되면 반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="19e15fef1135e42fb3ddbd944fd5ba42b4c44461" translate="yes" xml:space="preserve">
          <source>Return values from a component with &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 있는 구성 요소의 값 반환</target>
        </trans-unit>
        <trans-unit id="f303cd37013bf328626e038174b28974872e0cbc" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;DS.InvalidError&lt;/code&gt; from this method will cause the record to transition into the &lt;code&gt;invalid&lt;/code&gt; state and make the &lt;code&gt;errors&lt;/code&gt; object available on the record. When returning an &lt;code&gt;DS.InvalidError&lt;/code&gt; the store will attempt to normalize the error data returned from the server using the serializer's &lt;code&gt;extractErrors&lt;/code&gt; method.</source>
          <target state="translated">이 메소드에서 &lt;code&gt;DS.InvalidError&lt;/code&gt; 를 리턴 하면 레코드가 &lt;code&gt;invalid&lt;/code&gt; 상태 로 전환되고 레코드 에서 &lt;code&gt;errors&lt;/code&gt; 오브젝트를 사용할 수있게됩니다. &lt;code&gt;DS.InvalidError&lt;/code&gt; 를 반환하면 저장소는 serializer의 &lt;code&gt;extractErrors&lt;/code&gt; 메서드를 사용하여 서버에서 반환 된 오류 데이터를 정규화하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="85b812af2c70b17fb4a0e4704404e2e2663bc781" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for any item in the enumeration.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 전달 기능을 열거의 모든 항목에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ca1e9e1279673b31d55774d9185dc03beed7b19" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for every item in the enumeration. This corresponds with the &lt;code&gt;every()&lt;/code&gt; method in JavaScript 1.6.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 전달 기능을 열거의 모든 항목에 대해 true를 반환합니다. 이것은 JavaScript 1.6 의 &lt;code&gt;every()&lt;/code&gt; 메소드 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="48e8bff0730db4951905ce3907f251ae28d439c0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the array. This method is a Polyfill for ES 2016 Array.includes. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, searches from the index of &lt;code&gt;this.length + startAt&lt;/code&gt; by asc.</source>
          <target state="translated">전달 된 객체를 배열에서 찾을 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이 방법은 Poly 2016 for ES 2016 어레이입니다. &lt;code&gt;startAt&lt;/code&gt; 인수가 제공 되지 않으면 검색 시작 위치는 0입니다. 음수이면 &lt;code&gt;this.length + startAt&lt;/code&gt; 의해 this.length + startAt 의 색인에서 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="97d2d4c6d57998537e2ece3978bd7eda8781ffbc" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the enumerable.</source>
          <target state="translated">전달 된 객체를 열거 형에서 찾을 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5e0cff20c4e03c114bb589de045dad56c4977ab9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for all items in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">전달 된 속성이 열거 가능한 모든 항목의 두 번째 인수 값으로 확인되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이 방법은 콜백을 사용하는 것보다 더 간단하고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="785710d311908f0da91ca0999d02fda0b1b3f90e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for any item in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">전달 된 속성이 열거 가능한 항목의 두 번째 인수 값으로 확인되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이 방법은 콜백을 사용하는 것보다 더 간단하고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="125bbdbd31c014a3c75ab73874ead547c5f9f32b" translate="yes" xml:space="preserve">
          <source>Returns a consistent type for the passed object.</source>
          <target state="translated">전달 된 객체의 일관된 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5e31a7796519c4db2aefafeb16832aabfafcd9e" translate="yes" xml:space="preserve">
          <source>Returns a copy of the array with all &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; elements removed.</source>
          <target state="translated">모든 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 요소가 제거 된 배열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b92287589187fde80aa3c9745f11bf4566c0019" translate="yes" xml:space="preserve">
          <source>Returns a hash containing the parameters of an ancestor route.</source>
          <target state="translated">상위 경로의 매개 변수를 포함하는 해시를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2703351044d1524246ab647abe9d450da6a2453f" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this component's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer. For example, calling &lt;code&gt;component.$('li')&lt;/code&gt; will return a jQuery object containing all of the &lt;code&gt;li&lt;/code&gt; elements inside the DOM element of this component.</source>
          <target state="translated">이 컴퍼넌트의 요소의 jQuery 객체를 돌려줍니다. 선택자 문자열을 전달하면이 메소드는 현재 요소를 버퍼로 사용하여 jQuery 객체를 반환합니다. 예를 들어 &lt;code&gt;component.$('li')&lt;/code&gt; 를 호출 하면이 컴포넌트의 DOM 요소 내에있는 모든 &lt;code&gt;li&lt;/code&gt; 요소를 포함하는 jQuery 객체가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a47cf2c5ff6ea84daf5839f6f90517c7d1d2ada" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this view's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer.</source>
          <target state="translated">이 뷰의 요소에 대한 jQuery 객체를 반환합니다. 선택자 문자열을 전달하면이 메소드는 현재 요소를 버퍼로 사용하여 jQuery 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="926fcdedb193ee950b728d011e0592df4e16f0a0" translate="yes" xml:space="preserve">
          <source>Returns a new array that is a slice of the receiver. This implementation uses the observable array methods to retrieve the objects for the new slice.</source>
          <target state="translated">수신자의 슬라이스 인 새 배열을 리턴합니다. 이 구현은 Observable 배열 메소드를 사용하여 새 슬라이스의 오브젝트를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f490c002b2bf76e65c1ef0218a8c11e0b2f0ba00" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only items containing a unique property value. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">고유 한 속성 값을 포함하는 항목 만 포함하는 새로운 열거 가능 항목을 반환합니다. 기본 구현은 수신기 유형에 관계없이 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bdd3af7ab7b2da54382d05f7328e37ab891fb2d3" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only unique values. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">고유 한 값만 포함하는 새로운 열거 가능을 반환합니다. 기본 구현은 수신기 유형에 관계없이 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31c2891af58e7eda6b60e3cadcd876d663730e1c" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that excludes the passed value. The default implementation returns an array regardless of the receiver type. If the receiver does not contain the value it returns the original enumerable.</source>
          <target state="translated">전달 된 값을 제외하고 열거 가능한 새 열거 형을 반환합니다. 기본 구현은 수신기 유형에 관계없이 배열을 반환합니다. 수신자가 값을 포함하지 않으면 원래 열거 가능한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79b5522f2b1ae4f90cc466e02013320e2a3ad2b8" translate="yes" xml:space="preserve">
          <source>Returns a polymorphic relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">JSON-API &quot;관계 객체&quot;형식의 다형성 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da5d72f3f51387291e0c92700f8ccbb22c667d59" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been fulfilled, or rejected if any of them become rejected. The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will simply be copied over to the fulfilled object.</source>
          <target state="translated">주어진 약속이 모두 이행되거나 약속이 거부되면 거부 된 약속을 반환합니다. 리턴 된 약속은 &lt;code&gt;promises&lt;/code&gt; 객체 인수 와 동일한 키 이름을 가진 해시로 이행됩니다 . 객체의 값이 약속이 아닌 경우, 이행 된 객체로 단순히 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="82c815d0ca08ef29364305f689eaaae5497c95e1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled, or rejected if the passed parameters are invalid.</source>
          <target state="translated">주어진 모든 약속이 해결되거나 전달 된 매개 변수가 유효하지 않은 경우 거부되는 약속을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6d3f9c4b4397f9ef81ee1535035150e16652f8d6" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled. The return promise is fulfilled with an array of the states of the promises passed into the &lt;code&gt;promises&lt;/code&gt; array argument.</source>
          <target state="translated">주어진 약속이 모두 정산되면 이행되는 약속을 반환합니다. 반환 약속은 &lt;code&gt;promises&lt;/code&gt; 배열 인수에 전달 된 약속 상태의 배열로 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6e385587e066b24048df3bceae7d07c05eb9136" translate="yes" xml:space="preserve">
          <source>Returns a relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">JSON-API &quot;관계 객체&quot;로 형식화 된 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52a97236412e0d9a5ce17c93a028e57570cea2e1" translate="yes" xml:space="preserve">
          <source>Returns a special object that can be used to observe individual properties on the array. Just get an equivalent property on this object and it will return an enumerable that maps automatically to the named key on the member objects.</source>
          <target state="translated">배열의 개별 속성을 관찰하는 데 사용할 수있는 특수 객체를 반환합니다. 이 객체에서 동등한 속성을 얻으면 멤버 객체의 명명 된 키에 자동으로 매핑되는 열거 가능 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1bb9132b749d70b8d6303a10f424698c9fb0eed" translate="yes" xml:space="preserve">
          <source>Returns a string representation which attempts to provide more information than Javascript's &lt;code&gt;toString&lt;/code&gt; typically does, in a generic way for all Ember objects.</source>
          <target state="translated">모든 Ember 객체에 대해 일반적인 방식으로 Javascript의 &lt;code&gt;toString&lt;/code&gt; 보다 일반적으로 더 많은 정보를 제공하려는 문자열 표현을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1baffde3c198a82c1a9f24fd1699b9537bf5a9f0" translate="yes" xml:space="preserve">
          <source>Returns a unique id for the object. If the object does not yet have a guid, one will be assigned to it. You can call this on any object, &lt;code&gt;Ember.Object&lt;/code&gt;-based or not, but be aware that it will add a &lt;code&gt;_guid&lt;/code&gt; property.</source>
          <target state="translated">객체의 고유 한 ID를 반환합니다. 개체에 아직 guid가없는 경우 개체가 할당됩니다. &lt;code&gt;Ember.Object&lt;/code&gt; 기반의 객체이든 아니든 모든 객체에서 이것을 호출 할 수 있지만, &lt;code&gt;_guid&lt;/code&gt; 속성 이 추가 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1f4ec976109d986b5a79d48479eb69b877f9ce1c" translate="yes" xml:space="preserve">
          <source>Returns an array mapped to the specified key.</source>
          <target state="translated">지정된 키에 매핑 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b64d16ac418315ac651a71cfd903dcf3f4c1950a" translate="yes" xml:space="preserve">
          <source>Returns an array mapped via the callback</source>
          <target state="translated">콜백을 통해 매핑 된 배열을 반환</target>
        </trans-unit>
        <trans-unit id="829d878e18002574178651ec68a61b50ed634687" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration that the passed function returns true for. This method corresponds to &lt;code&gt;filter()&lt;/code&gt; defined in JavaScript 1.6.</source>
          <target state="translated">전달 된 함수가 true를 반환하는 열거의 모든 항목이 포함 된 배열을 반환합니다. 이 메소드 는 JavaScript 1.6에 정의 된 &lt;code&gt;filter()&lt;/code&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c71aa9a7da9062c13eb9514b5d81794253550ff0" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration where the passed function returns false. This method is the inverse of filter().</source>
          <target state="translated">전달 된 함수가 false를 반환하는 열거 형의 모든 항목이 포함 된 배열을 반환합니다. 이 메소드는 filter ()의 반대입니다.</target>
        </trans-unit>
        <trans-unit id="78ff059f5f0f8f4ba1bb336fa61257c52bc1e554" translate="yes" xml:space="preserve">
          <source>Returns an array with just the items with the matched property. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">속성이 일치하는 항목 만있는 배열을 반환합니다. 목표 값과 함께 선택적 두 번째 인수를 전달할 수 있습니다. 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 로 평가되는 모든 속성과 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="f5d725514851c9b11eac282307b62e805938ccc7" translate="yes" xml:space="preserve">
          <source>Returns an array with the items that do not have truthy values for key. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to false.</source>
          <target state="translated">key에 대해 정확한 값이없는 항목이 포함 된 배열을 반환합니다. 목표 값과 함께 선택적 두 번째 인수를 전달할 수 있습니다. 그렇지 않으면 false로 평가되는 모든 속성과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1a3670a2d50cfc92881b423c60b1f1c2575feb6e" translate="yes" xml:space="preserve">
          <source>Returns an instance of the adapter for a given type. For example, &lt;code&gt;adapterFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonAdapter&lt;/code&gt;.</source>
          <target state="translated">주어진 유형에 대한 어댑터의 인스턴스를 리턴합니다. 예를 들어, &lt;code&gt;adapterFor('person')&lt;/code&gt; 은 &lt;code&gt;App.PersonAdapter&lt;/code&gt; 의 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="673a33da06126a5640a2ab9e96c90786fc9c52f9" translate="yes" xml:space="preserve">
          <source>Returns an instance of the serializer for a given type. For example, &lt;code&gt;serializerFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonSerializer&lt;/code&gt;.</source>
          <target state="translated">주어진 타입에 대한 시리얼 라이저의 인스턴스를 반환합니다. 예를 들어 &lt;code&gt;serializerFor('person')&lt;/code&gt; 은 &lt;code&gt;App.PersonSerializer&lt;/code&gt; 의 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="57c8785371bfdb428b7960568f1bb17a9b411222" translate="yes" xml:space="preserve">
          <source>Returns an object that can be used to provide an owner to a manually created instance.</source>
          <target state="translated">소유자를 수동으로 생성 한 인스턴스에 제공하는 데 사용할 수있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd2a4f6967074c15ba164a31f50b2fef12d1c233" translate="yes" xml:space="preserve">
          <source>Returns an object, whose keys are changed properties, and value is an [oldProp, newProp] array.</source>
          <target state="translated">키가 속성이 변경되고 값이 [oldProp, newProp] 배열 인 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb72d59dd2b98c9d1f57e9369a6432daa8505854" translate="yes" xml:space="preserve">
          <source>Returns errors for a given attribute</source>
          <target state="translated">주어진 속성에 대한 오류를 반환</target>
        </trans-unit>
        <trans-unit id="c53cee14bf3f2dd98c4f832e2cfc8603ac6576e6" translate="yes" xml:space="preserve">
          <source>Returns the Capitalized form of a string</source>
          <target state="translated">문자열의 대문자 형식을 반환합니다</target>
        </trans-unit>
        <trans-unit id="27bef32d6017037bf8ae7ec87140c840faa058d7" translate="yes" xml:space="preserve">
          <source>Returns the UpperCamelCase form of a string.</source>
          <target state="translated">문자열의 UpperCamelCase 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ea8d719e010027a981f551b7907ffaf6428b3c0" translate="yes" xml:space="preserve">
          <source>Returns the available classes a given type.</source>
          <target state="translated">사용 가능한 클래스에 지정된 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="559a00b1190b2d1cae3fc144a9dbab5ae67bb15d" translate="yes" xml:space="preserve">
          <source>Returns the cached value for a property, if one exists. This can be useful for peeking at the value of a computed property that is generated lazily, without accidentally causing it to be created.</source>
          <target state="translated">속성의 캐시 된 값이 있으면이를 반환합니다. 이는 실수로 생성되지 않고 느리게 생성 된 계산 된 속성 값을 엿보기에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7c90e8f44c4bb41743551254bcbc3f92e3bc124" translate="yes" xml:space="preserve">
          <source>Returns the cached value of a computed property, if it exists. This allows you to inspect the value of a computed property without accidentally invoking it if it is intended to be generated lazily.</source>
          <target state="translated">계산 된 속성의 캐시 된 값이 있으면이를 반환합니다. 이를 통해 계산 된 속성이 지연 생성되도록 의도 된 경우 실수로 호출하지 않고 계산 된 속성의 값을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4ee2b850450a7e973ddd1ed839152228fa5e24" translate="yes" xml:space="preserve">
          <source>Returns the controller of the current route, or a parent (or any ancestor) route in a route hierarchy.</source>
          <target state="translated">현재 라우트의 제어기 또는 라우트 계층의 상위 (또는 상위) 라우트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9725708a8c5defae2f7c0cd978776509197591b1" translate="yes" xml:space="preserve">
          <source>Returns the current DOM element for the view.</source>
          <target state="translated">뷰의 현재 DOM 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b98b32c89ebbfef46cceba77784cc4659c5bbd7e" translate="yes" xml:space="preserve">
          <source>Returns the current URL.</source>
          <target state="translated">현재 URL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="603c43d141eff0347fdae1c71f24b3fffbceee88" translate="yes" xml:space="preserve">
          <source>Returns the current path.</source>
          <target state="translated">현재 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f1aa9ae053c0edabb551d28c02b549a6462af84" translate="yes" xml:space="preserve">
          <source>Returns the currently active route name.</source>
          <target state="translated">현재 활성화 된 경로 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9fe31d2ca8c909a9d417483d744e509af227d01" translate="yes" xml:space="preserve">
          <source>Returns the first item in the array for which the callback returns true. This method works similar to the &lt;code&gt;filter()&lt;/code&gt; method defined in JavaScript 1.6 except that it will stop working on the array once a match is found.</source>
          <target state="translated">콜백이 true를 반환하는 배열의 첫 번째 항목을 반환합니다. 이 메소드 는 일치하는 것이 발견되면 배열에서 작업을 중지한다는 점을 제외하고 JavaScript 1.6에 정의 된 &lt;code&gt;filter()&lt;/code&gt; 메소드 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="2e59a22f6a7f2a23baf41260a3a174ae4dda651e" translate="yes" xml:space="preserve">
          <source>Returns the first item with a property matching the passed value. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전달 된 값과 일치하는 속성을 가진 첫 번째 항목을 반환합니다. 목표 값과 함께 선택적 두 번째 인수를 전달할 수 있습니다. 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 로 평가되는 모든 속성과 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="a5a026a77c75bacd53505cdcc6e9f209285cfdf2" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's first occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">주어진 객체의 첫 번째 색인을 반환합니다. &lt;code&gt;startAt&lt;/code&gt; 인수가 제공 되지 않으면 검색 할 시작 위치는 0입니다. 음수이면 배열의 끝에서 뒤로 계산됩니다. 일치하는 것이 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0b515aad064fd3b288bb9d89c67df97fc51d2b5" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's last occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the search starts from the last position. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">주어진 객체의 마지막 발생 색인을 반환합니다. &lt;code&gt;startAt&lt;/code&gt; 인수가 제공 되지 않으면 검색은 마지막 위치에서 시작합니다. 음수이면 배열의 끝에서 뒤로 계산됩니다. 일치하는 것이 없으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53b4efc0ec12b66bfb72581aacfd1278f1182232" translate="yes" xml:space="preserve">
          <source>Returns the lowerCamelCase form of a string.</source>
          <target state="translated">문자열의 lowerCamelCase 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9578d2b6bd478f1d1d2ab145665ede9e0378f6c2" translate="yes" xml:space="preserve">
          <source>Returns the model class for the particular &lt;code&gt;modelName&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;modelName&lt;/code&gt; 의 모델 클래스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0bab782f8ac9d0f882b41382a9b9eba4f7d1cced" translate="yes" xml:space="preserve">
          <source>Returns the object at the given &lt;code&gt;index&lt;/code&gt;. If the given &lt;code&gt;index&lt;/code&gt; is negative or is greater or equal than the array length, returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 의 객체를 돌려 줍니다. 주어진 &lt;code&gt;index&lt;/code&gt; 가 음수이거나 배열 길이보다 크거나 같으면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3f7b4ca85546523dc009d25cb0b789a874b05c9" translate="yes" xml:space="preserve">
          <source>Returns the resolved model of a parent (or any ancestor) route in a route hierarchy. During a transition, all routes must resolve a model object, and if a route needs access to a parent route's model in order to resolve a model (or just reuse the model from a parent), it can call &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; to retrieve it. If the ancestor route's model was a promise, its resolved result is returned.</source>
          <target state="translated">경로 계층 구조에서 상위 (또는 상위) 경로의 확인 된 모델을 반환합니다. 전환하는 동안 모든 경로는 모델 객체를 해석해야하며 모델을 해석하기 위해 (또는 상위에서 모델을 재사용하기 위해) 루트가 상위 경로의 모델에 액세스해야하는 경우 &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; 를 그것을 검색하십시오. 조상 경로의 모델이 약속 인 경우 해결 된 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a84d41130ac37df9542127b00978dea35fe64b87" translate="yes" xml:space="preserve">
          <source>Returns the resource's ID.</source>
          <target state="translated">자원의 ID를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="bf66565ff73540d9dd7fc00f9444426f536c7d08" translate="yes" xml:space="preserve">
          <source>Returns the resource's attributes formatted as a JSON-API &quot;attributes object&quot;.</source>
          <target state="translated">JSON-API &quot;속성 개체&quot;로 형식화 된 리소스 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="415b933c18c5478e404754280a5d65c8ca1940a0" translate="yes" xml:space="preserve">
          <source>Returns the resource's relationships formatted as a JSON-API &quot;relationships object&quot;.</source>
          <target state="translated">JSON-API &quot;관계 객체&quot;형식의 리소스 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afc70541a8fa4d9fce60946294448cc54071c811" translate="yes" xml:space="preserve">
          <source>Returns true if it is possible to catalog a list of available classes in the resolver for a given type.</source>
          <target state="translated">주어진 유형에 대해 리졸버에서 사용 가능한 클래스 목록을 카탈로그 할 수있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dbd27005b9eb80ac7f03ed6d41eccecffd320423" translate="yes" xml:space="preserve">
          <source>Returns true if the passed object is an array or Array-like.</source>
          <target state="translated">전달 된 객체가 배열 또는 배열과 같은 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2cbfc0edc2a1571a31104dc3ac6c9e8701099f18" translate="yes" xml:space="preserve">
          <source>Returns true if the passed value is null or undefined. This avoids errors from JSLint complaining about use of ==, which can be technically confusing.</source>
          <target state="translated">전달 된 값이 null이거나 정의되지 않은 경우 true를 반환합니다. 이것은 JSLint의 == 사용에 대해 불평하는 오류를 피하는데, 이는 기술적으로 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb7fd3ff2c053ac1f7adced8bb08e8be1c57f557" translate="yes" xml:space="preserve">
          <source>Reusing Route Context</source>
          <target state="translated">경로 컨텍스트 재사용</target>
        </trans-unit>
        <trans-unit id="f7a260f32f2ae28e993f2a321848e1adcfad19eb" translate="yes" xml:space="preserve">
          <source>Reverse objects in the array. Works just like &lt;code&gt;reverse()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">배열에서 객체를 반전시킵니다. &lt;code&gt;reverse()&lt;/code&gt; 와 동일하게 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="20bb4efd64b3d8c3fbab0cab5b9e525a3f5f3641" translate="yes" xml:space="preserve">
          <source>Route Handlers</source>
          <target state="translated">경로 처리기</target>
        </trans-unit>
        <trans-unit id="6dcf16e1c5d3e9fd2ae4a4d54c174448fe43e1b6" translate="yes" xml:space="preserve">
          <source>Router</source>
          <target state="translated">Router</target>
        </trans-unit>
        <trans-unit id="15507cd11e5f36e3bd1000cd0d459f39fb04d158" translate="yes" xml:space="preserve">
          <source>Router and Route Handlers</source>
          <target state="translated">라우터 및 경로 처리기</target>
        </trans-unit>
        <trans-unit id="eb04e4102ddcdddd2b4ad8996248c661dcd7e77f" translate="yes" xml:space="preserve">
          <source>RouterService</source>
          <target state="translated">RouterService</target>
        </trans-unit>
        <trans-unit id="a9d3b175c69e17dc9060b2a51d5088436b3d7c7d" translate="yes" xml:space="preserve">
          <source>RouterService  (public)</source>
          <target state="translated">RouterService (공개)</target>
        </trans-unit>
        <trans-unit id="bbe3002d2245379df83a5467ffff0fec18ef89e8" translate="yes" xml:space="preserve">
          <source>Routes and Templates</source>
          <target state="translated">경로 및 템플릿</target>
        </trans-unit>
        <trans-unit id="8987ca9f541ce3e64483abe2d701eb7b2b6a9540" translate="yes" xml:space="preserve">
          <source>Routes in this example application can now access the injected logger:</source>
          <target state="translated">이 예제 애플리케이션의 경로는 이제 삽입 된 로거에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64588f6aefa7085fb2efbbcac558cdfba1c74948" translate="yes" xml:space="preserve">
          <source>Routes without dynamic segments will always execute the model hook.</source>
          <target state="translated">동적 세그먼트가없는 경로는 항상 모델 후크를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="1442914c6ee08b64a917d4c330cde7b015a3686d" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;ember t -s&lt;/code&gt; to verify that our new test is passing. To find the new test, locate &quot;Integration | Component | rental listing&quot; in the &quot;Module&quot; field of the test UI.</source>
          <target state="translated">&lt;code&gt;ember t -s&lt;/code&gt; 를 실행하십시오. 를 하여 새 테스트가 통과했는지 확인 . 새 테스트를 찾으려면 테스트 UI의 &quot;모듈&quot;필드에서 &quot;통합 | 구성 요소 | 대여 목록&quot;을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2dbbc67840c5e39c504d798d6593f53821d2cc88" translate="yes" xml:space="preserve">
          <source>Run a function meant for debugging.</source>
          <target state="translated">디버깅을위한 기능을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="66a5ecdab45965e437f71333f302f2e5bab78442" translate="yes" xml:space="preserve">
          <source>Run in a full browser environment.</source>
          <target state="translated">완전한 브라우저 환경에서 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="edc3981913706bf02d5feb303f21804148ecbc99" translate="yes" xml:space="preserve">
          <source>Run the following command to install the addon:</source>
          <target state="translated">다음 명령을 실행하여 애드온을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6ff3e3092b35d4ef3929076640b57e0d508a29" translate="yes" xml:space="preserve">
          <source>Run the tests again using the command &lt;code&gt;ember t -s&lt;/code&gt;, and toggle &quot;Hide passed tests&quot; to show your new passing test.</source>
          <target state="translated">&lt;code&gt;ember t -s&lt;/code&gt; 명령을 사용하여 테스트를 다시 실행하고 &quot;통과 테스트 숨기기&quot;를 토글하여 새 통과 테스트를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="113d8c01f0ce1a9637e7e61d07f886f1ce894435" translate="yes" xml:space="preserve">
          <source>Run time, where we begin executing the application once everything has loaded.</source>
          <target state="translated">모든 것이로드되면 애플리케이션 실행을 시작하는 런타임.</target>
        </trans-unit>
        <trans-unit id="8cbc363f50b4971680e11de197253d5ebff17363" translate="yes" xml:space="preserve">
          <source>Run your tests with &lt;code&gt;ember test&lt;/code&gt; on the command-line. You can re-run your tests on every file-change with &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">명령 행에서 &lt;code&gt;ember test&lt;/code&gt; 로 테스트를 실행하십시오 . &lt;code&gt;ember test --server&lt;/code&gt; 를 사용하여 모든 파일 변경에서 테스트를 다시 실행할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="2ce92b8f8a607252af27b98ddec45308f2f8137b" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;ember test --server&lt;/code&gt; will now show 7 failing tests (out of 15). Each of the 6 tests we setup above will fail, plus one ESLint test will fail saying, &lt;code&gt;assert is defined but never used&lt;/code&gt;. The tests above fail because QUnit requires at least one check for a specific condition (known as an &lt;code&gt;assert&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ember test --server&lt;/code&gt; 를 실행 하면 이제 실패한 테스트 7 개가 표시됩니다 (15 개 중). 위에서 설정 한 6 가지 테스트는 각각 실패하고, 하나의 ESLint 테스트는 실패 &lt;code&gt;assert is defined but never used&lt;/code&gt; . QUnit이 특정 조건 ( &lt;code&gt;assert&lt;/code&gt; 이라고도 함)을 한 번 이상 확인해야하므로 위의 테스트는 실패합니다. .</target>
        </trans-unit>
        <trans-unit id="52d1f9fc84c72f964d3e2290880c642e3e33c2c8" translate="yes" xml:space="preserve">
          <source>Running this command generates three files: a component JavaScript file, a template, and a test file.</source>
          <target state="translated">이 명령을 실행하면 구성 요소 JavaScript 파일, 템플리트 및 테스트 파일의 세 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="42272791157160739ed302e320a2062a5ebaa316" translate="yes" xml:space="preserve">
          <source>Runs the passed target and method inside of a RunLoop, ensuring any deferred actions including bindings and views updates are flushed at the end.</source>
          <target state="translated">RunLoop 내에서 전달 된 대상 및 메소드를 실행하여 바인딩 및 뷰 업데이트를 포함한 지연된 조치가 마지막에 플러시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="429ee37aaa10a7c1e1dbc7f3832b6b87b1b491c2" translate="yes" xml:space="preserve">
          <source>SSR</source>
          <target state="translated">SSR</target>
        </trans-unit>
        <trans-unit id="3345733b5704ef652ed8eb46f076938ea03125bd" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;deleteRecord&lt;/code&gt;, but saves the record immediately.</source>
          <target state="translated">&lt;code&gt;deleteRecord&lt;/code&gt; 와 동일 하지만 레코드를 즉시 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4a7e069bd507c730311a8b251060b5b9997cb937" translate="yes" xml:space="preserve">
          <source>Sass/Less Comparison</source>
          <target state="translated">Sass / Less 비교</target>
        </trans-unit>
        <trans-unit id="25818b0851afccf72a718a0e15e8c5e40a99b3fc" translate="yes" xml:space="preserve">
          <source>Save the record and persist any changes to the record to an external source via the adapter.</source>
          <target state="translated">레코드를 저장하고 어댑터를 통해 레코드의 변경 사항을 외부 소스에 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="6db7e04098ce89e31bb81c3fc95a3a70f998a013" translate="yes" xml:space="preserve">
          <source>Save this template and switch back to the &lt;code&gt;scientists&lt;/code&gt; template. Replace all our old code with our new componentized version. Components look like HTML tags but instead of using angle brackets (&lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt;) they use double curly braces (&lt;code&gt;{{component}}&lt;/code&gt;).</source>
          <target state="translated">이 템플릿을 저장하고 &lt;code&gt;scientists&lt;/code&gt; 템플릿으로 다시 전환하십시오 . 이전의 모든 코드를 새로운 구성 요소 화 된 버전으로 교체하십시오. 컴포넌트는 HTML 태그처럼 보이지만 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; ) 대신 이중 중괄호 ( &lt;code&gt;{{component}}&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="75008fab400537d9213cc7b35f572e830001bbbb" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;ManyArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ManyArray&lt;/code&gt; 의 모든 레코드를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="df3feb104ba2e45607091340bd579e0e82e620de" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;RecordArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RecordArray&lt;/code&gt; 의 모든 레코드를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="3fe2b6866788c46de111214341e6e46e2056460c" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">API 네임 스페이스에 모델 유형을 말하고 다형성 &lt;code&gt;user&lt;/code&gt; 가있는 &lt;code&gt;post&lt;/code&gt; 모델 을 업데이트 할 때 다음 페이로드가 예상됩니다. 관계 .</target>
        </trans-unit>
        <trans-unit id="d136d61c474d3b91c7e154860b021ed3fbba6838" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">API 네임 스페이스에 모델 유형을 말하고 &lt;code&gt;post&lt;/code&gt; 을 업데이트 할 때 다음 페이로드가 예상됩니다. 모델 .</target>
        </trans-unit>
        <trans-unit id="ea662432dbe1c412446984e3028f23c30fe1a705" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">API 네임 스페이스에 모델 유형을 말하고 다형성 &lt;code&gt;user&lt;/code&gt; 가있는 &lt;code&gt;post&lt;/code&gt; 모델에 대해 다음 페이로드를 리턴합니다. 관계 .</target>
        </trans-unit>
        <trans-unit id="a903a2095a7bcdbfa11fb73fb67d71d335131cd8" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">API 네임 스페이스에 모델 유형을 말하고 &lt;code&gt;post&lt;/code&gt; 모델에 대해 다음 페이로드를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc16a7d79cd8b9582ffe6cf1c9f51f2a4e6b9968" translate="yes" xml:space="preserve">
          <source>Schedule a function to run one time during the current RunLoop. This is equivalent to calling &lt;code&gt;scheduleOnce&lt;/code&gt; with the &quot;actions&quot; queue.</source>
          <target state="translated">현재 RunLoop 중에 한 번만 실행되도록 함수를 예약하십시오. 이것은 &quot;actions&quot;큐로 &lt;code&gt;scheduleOnce&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2fa9c050bafdf85859c52a24173e46d2b0a60bfa" translate="yes" xml:space="preserve">
          <source>Schedules a function to run one time in a given queue of the current RunLoop. Calling this method with the same queue/target/method combination will have no effect (past the initial call).</source>
          <target state="translated">현재 RunLoop의 지정된 큐에서 함수가 한 번 실행되도록 예약합니다. 동일한 대기열 / 대상 / 방법 조합으로이 메소드를 호출해도 아무런 효과가 없습니다 (초기 호출을 지나서).</target>
        </trans-unit>
        <trans-unit id="415823adc474692ea63ccbfdd4bf9285fdf51e36" translate="yes" xml:space="preserve">
          <source>Schedules an item to run from within a separate run loop, after control has been returned to the system. This is equivalent to calling &lt;code&gt;run.later&lt;/code&gt; with a wait time of 1ms.</source>
          <target state="translated">제어가 시스템에 반환 된 후 별도의 실행 루프 내에서 항목이 실행되도록 예약합니다. 이것은 &lt;code&gt;run.later&lt;/code&gt; 를 호출하는 것과 같습니다.대기 시간이 1ms 인 .</target>
        </trans-unit>
        <trans-unit id="2da8e5963f5b139e60b530201737776279520ba2" translate="yes" xml:space="preserve">
          <source>Second value to compare</source>
          <target state="translated">비교할 두 번째 값</target>
        </trans-unit>
        <trans-unit id="fbb14676cc33f6f4135e4da0888670ea8bff400b" translate="yes" xml:space="preserve">
          <source>Second, attribute and relationship names in the JSON API document should exactly match the name and casing of the &lt;code&gt;DS.attr()&lt;/code&gt;, &lt;code&gt;DS.belongsTo()&lt;/code&gt; and &lt;code&gt;DS.hasMany()&lt;/code&gt;, properties defined on the Model.</source>
          <target state="translated">둘째, JSON API 문서의 속성 및 관계 이름 은 모델에 정의 된 &lt;code&gt;DS.attr()&lt;/code&gt; , &lt;code&gt;DS.belongsTo()&lt;/code&gt; 및 &lt;code&gt;DS.hasMany()&lt;/code&gt; 의 이름 및 대소 문자와 정확히 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2505c754e96c76956a7be1f711c7c15d871a6591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_findRecord&quot;&gt;findRecord&lt;/a&gt; if you would like to request this record from the backend.</source>
          <target state="translated">백엔드에서이 레코드를 요청하려면 &lt;a href=&quot;#method_findRecord&quot;&gt;findRecord를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6b7139c565ccba6b41646265abe63665bc0e0fb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt; to get an array of current records in the store, without waiting until a reload is finished.</source>
          <target state="translated">다시로드가 완료 될 때까지 기다리지 않고 상점에서 현재 레코드 배열을 가져 오려면 &lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="886ff4d1e817dd0f2c949c0a7b4ce296faa34a4f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt; to get the cached version of a record.</source>
          <target state="translated">캐시 된 버전의 레코드를 얻으려면 &lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61ccab3b58667205608bc05c31f4f4471dba3cbc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_query&quot;&gt;query&lt;/a&gt; to only get a subset of records from the server.</source>
          <target state="translated">서버에서 레코드의 서브 세트 만 가져 오려면 &lt;a href=&quot;#method_query&quot;&gt;조회&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46d9795971c80ea476d0b1500751d7a511c3ccff" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;Passing Properties to a Component&lt;/a&gt; for more.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;은 구성 요소&lt;/a&gt; 에 속성 전달을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3db6252e2ca3a79d9351ce05c47a2d29d1a3f0d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&quot;Event Names&quot;&lt;/a&gt; for a list of acceptable DOM event names.</source>
          <target state="translated">허용 가능한 DOM 이벤트 이름 목록은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&quot;이벤트 이름&quot;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8789001d899131f2e85e2f5f2831793db5bede0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt;, &lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt; , &lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65ead4fce2d577717cfc6277eb28eb28c8681b44" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;Ember.LinkComponent&lt;/a&gt; for a complete list of overrideable properties. Be sure to also check out inherited properties of &lt;code&gt;LinkComponent&lt;/code&gt;.</source>
          <target state="translated">재정의 가능한 속성의 전체 목록은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;Ember.LinkComponent&lt;/a&gt; 를 참조하십시오 . &lt;code&gt;LinkComponent&lt;/code&gt; 의 상속 된 속성도 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="045265cfa59bb6f41aaac98fec78959fdd19abe6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01062a6ca91683116a2e4f5f08c832a71f5fe8f8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt; for more info.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="857a99c53ed3cf0419cf7f9b690df0548804f0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt; for more info.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="881033150b0297e5f01d4a625bd73488021b52e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt; for how to set up localized string references.</source>
          <target state="translated">현지화 된 문자열 참조를 설정하는 방법 은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6112da6f0d617231dc4dbb1b45eeb398b827508d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e320b1d30f80cb3e78ed752a8fd867c8ef8c8dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">사용법에 대한 자세한 내용 은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="03d11afa96477f44a066fa485ba8101cf284b0ae" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt; for usage details.</source>
          <target state="translated">사용법에 대한 자세한 내용 은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="47faa79acc3c86a2306cd182fa2b1e0dd8b6cb51" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d084a39940c5ca6a3dc230b8703de366598062d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;templates guide&lt;/a&gt; for additional information on using &lt;code&gt;{{outlet}}&lt;/code&gt; in &lt;code&gt;application.hbs&lt;/code&gt;. You may also specify a name for the &lt;code&gt;{{outlet}}&lt;/code&gt;, which is useful when using more than one &lt;code&gt;{{outlet}}&lt;/code&gt; in a template:</source>
          <target state="translated">&lt;code&gt;application.hbs&lt;/code&gt; 에서 &lt;code&gt;{{outlet}}&lt;/code&gt; 사용에 대한 추가 정보는 &lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;템플리트 안내서&lt;/a&gt; 를 참조하십시오 . &lt;code&gt;{{outlet}}&lt;/code&gt; 의 이름을 지정할 수도 있습니다 . 이는 템플리트에서 둘 이상의 &lt;code&gt;{{outlet}}&lt;/code&gt; 을 사용할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="da7f7101e86e008a15c9fc249f9d10eeeb8ad692" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.observer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ember.observer&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb6d38f9f2619d3888781eee8439db883f2023dd" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.on&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ember.on&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5654e29a2f9b281a9e8375d997a1390c911e728" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;serialize&lt;/code&gt; for information on how to customize the serialized form of a record.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 된 레코드 양식을 사용자 정의하는 방법에 대한 정보는 직렬화 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c586195d203dee29ed62d91d26341ea7df6918eb" translate="yes" xml:space="preserve">
          <source>See Ember.Application.initializer for discussion on the usage of before and after.</source>
          <target state="translated">이전과 이후의 사용법에 대한 자세한 내용은 Ember.Application.initializer를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e38cd17e666018827e69a44432616458686394b7" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.catch.</source>
          <target state="translated">RSVP.Promise.catch를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="392314b527dfbd25d9b7ed433a5cad392661aecf" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.finally.</source>
          <target state="translated">RSVP.Promise.finally를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2192c68214bde1365823cd88f18083860287db7d" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.then.</source>
          <target state="translated">RSVP.Promise를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4f6b4832e77e568563e9f9654dc677db5ef2bd6" translate="yes" xml:space="preserve">
          <source>See all observers for an object, key</source>
          <target state="translated">객체, 키에 대한 모든 관찰자보기</target>
        </trans-unit>
        <trans-unit id="f44d1816a0f33954c0c1b606d935226b15a7a275" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65b6e8e3055ab3ad8943a84067c6dde10eeb6b38" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1131debc15fa7b2f9872d39240142f424b1f9d69" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember components&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember 컴포넌트&lt;/a&gt; 에 대해 더 알아보기</target>
        </trans-unit>
        <trans-unit id="3ba9f21e3fbfc35d0ad9d88b57d28f52f45794dc" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;텍스트 지원 작업&lt;/a&gt; 에 대해 더 알아보기</target>
        </trans-unit>
        <trans-unit id="d8d27c03873709d7fb4d40eef28f6d91b6c1accb" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;텍스트 지원 작업&lt;/a&gt; 에 대해 더 알아보기</target>
        </trans-unit>
        <trans-unit id="5aa5055098c1d7f1ee4bd170e24743c3af2dcaa6" translate="yes" xml:space="preserve">
          <source>See that we have used &lt;code&gt;moduleFor&lt;/code&gt;, one of the several unit-test helpers provided by Ember-Qunit. Test helpers provide us with some conveniences, such as the &lt;code&gt;subject&lt;/code&gt; function that handles lookup and instantiation for our object under test. Note that in a unit test you can customize the initialization of your object under test by passing to the &lt;code&gt;subject&lt;/code&gt; function an object containing the instance variables you would like to initialize. For example, to initialize the property 'foo' in our object under test, we would call &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</source>
          <target state="translated">Ember-Qunit이 제공하는 몇 가지 단위 테스트 헬퍼 중 하나 인 &lt;code&gt;moduleFor&lt;/code&gt; 를 사용 했는지 확인하십시오 . 테스트 헬퍼는 테스트 &lt;code&gt;subject&lt;/code&gt; 오브젝트의 조회 및 인스턴스화를 처리 하는 주제 기능 과 같은 몇 가지 편의를 제공합니다 . 단위 테스트에서는 초기화 하려는 인스턴스 변수를 포함하는 객체를 &lt;code&gt;subject&lt;/code&gt; 함수 에 전달하여 테스트중인 객체의 초기화를 사용자 정의 할 수 있습니다 . 예를 들어 테스트중인 객체에서 'foo'속성을 초기화하려면 &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae9382bccb52583673509854efe6c33c1551b8a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;routing guide&lt;/a&gt; for more information on how your &lt;code&gt;route&lt;/code&gt; interacts with the &lt;code&gt;{{outlet}}&lt;/code&gt; helper. Note: Your content &lt;strong&gt;will not render&lt;/strong&gt; if there isn't an &lt;code&gt;{{outlet}}&lt;/code&gt; for it.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;라우팅 가이드&lt;/a&gt; 방법에 대한 자세한 내용은 &lt;code&gt;route&lt;/code&gt; 와 상호 작용 &lt;code&gt;{{outlet}}&lt;/code&gt; 도우미. 참고 : &lt;code&gt;{{outlet}}&lt;/code&gt; 이 없으면 콘텐츠 &lt;strong&gt;가 렌더링&lt;/strong&gt; 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a57805751973ea57faaaae7c6e36d1170562cb5e" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;normalize&lt;/code&gt; documentation for more information.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;normalize&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="466a6e9c7a1e57a171042a7f153306f2eec6b51f" translate="yes" xml:space="preserve">
          <source>See the Handlebars documentation on &lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;block expressions&lt;/a&gt; for more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;블록 표현식에&lt;/a&gt; 대한 핸들 바 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f864ff30f39009bee652eeaa77b5d4e2cb3c219" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d1186a24f13f7ddf3bb7bc489fbe38dfa0116f7" translate="yes" xml:space="preserve">
          <source>See the documentation on &lt;code&gt;Ember.Applications&lt;/code&gt;'s &lt;code&gt;rootElement&lt;/code&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;Ember.Applications&lt;/code&gt; 의 &lt;code&gt;rootElement&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1adc341f4763a89fa8173df93fc2565a43324631" translate="yes" xml:space="preserve">
          <source>See the documentation on the &lt;code&gt;isBrowser&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt; and &lt;code&gt;rootElement&lt;/code&gt; properties on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;isBrowser&lt;/code&gt; 의 isBrowser , &lt;code&gt;document&lt;/code&gt; 및 &lt;code&gt;rootElement&lt;/code&gt; 속성에 대한 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1824d460f7c3833816d20ccdd7e4598d1c806c7e" translate="yes" xml:space="preserve">
          <source>See the list of event names at the end of this page. Any event can be defined as an event handler in your component.</source>
          <target state="translated">이 페이지 끝에있는 이벤트 이름 목록을 참조하십시오. 모든 이벤트는 구성 요소에서 이벤트 처리기로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a127955b9093eefeadddc3e86e6bc2ecfb11432" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/pluralize&quot;}}{{/crossLink}}</source>
          <target state="translated">{{#crossLink &quot;Ember.String / pluralize&quot;}} {{/ crossLink}} 참조</target>
        </trans-unit>
        <trans-unit id="b2ec09c4221cd9352fad5f335a19d089d3aff099" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/singularize&quot;}}{{/crossLink}}</source>
          <target state="translated">{{#crossLink &quot;Ember.String / singularize&quot;}} {{/ crossLink}} 참조</target>
        </trans-unit>
        <trans-unit id="4908850b77074857fa2902c9a0c51ac951c3d066" translate="yes" xml:space="preserve">
          <source>Send an event. The execution of suspended listeners is skipped, and once listeners are removed. A listener without a target is executed on the passed object. If an array of actions is not passed, the actions stored on the passed object are invoked.</source>
          <target state="translated">이벤트를 보내십시오. 일시 중단 된 리스너의 실행은 건너 뛰고 일단 리스너가 제거됩니다. 대상이없는 리스너는 전달 된 객체에서 실행됩니다. 조치 배열이 전달되지 않으면 전달 된 오브젝트에 저장된 조치가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a7cbd3195b0b1848a603028087345561cbdb3c83" translate="yes" xml:space="preserve">
          <source>Sending Actions</source>
          <target state="translated">액션 보내기</target>
        </trans-unit>
        <trans-unit id="090be3d6246540fa8c78341d0fd9ec8bb7d44ef7" translate="yes" xml:space="preserve">
          <source>Sending from the Console to the Inspector</source>
          <target state="translated">콘솔에서 인스펙터로 보내기</target>
        </trans-unit>
        <trans-unit id="064119347ce21be3830f42ad99fd305e6bb36ddb" translate="yes" xml:space="preserve">
          <source>Sending from the Inspector to the Console</source>
          <target state="translated">인스펙터에서 콘솔로 보내기</target>
        </trans-unit>
        <trans-unit id="37adf51f8e931f4ac6beffdc0bce4b8c9a345a4c" translate="yes" xml:space="preserve">
          <source>Sends a delete request for the record to the server.</source>
          <target state="translated">레코드 삭제 요청을 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="291d83532f286c48f65ce13d9158d367234e5871" translate="yes" xml:space="preserve">
          <source>Sends an action to the router, which will delegate it to the currently active route hierarchy per the bubbling rules explained under &lt;code&gt;actions&lt;/code&gt;.</source>
          <target state="translated">버블 링 규칙이 아래 설명에 따라 현재 활성화 된 경로 계층에 위임 할 라우터에 액션 전송 &lt;code&gt;actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21f60515d4413efa1948ac110388d426adab17c9" translate="yes" xml:space="preserve">
          <source>Serialize &lt;code&gt;belongsTo&lt;/code&gt; relationship when it is configured as an embedded object.</source>
          <target state="translated">임베디드 오브젝트로 구성된 경우 &lt;code&gt;belongsTo&lt;/code&gt; 관계를 직렬화하십시오 .</target>
        </trans-unit>
        <trans-unit id="77f5a897d372d976dbdf3ed3fd84a1f9fe2c636a" translate="yes" xml:space="preserve">
          <source>Serializes &lt;code&gt;hasMany&lt;/code&gt; relationships when it is configured as embedded objects.</source>
          <target state="translated">포함 된 개체로 구성된 &lt;code&gt;hasMany&lt;/code&gt; 관계를 serialize 합니다.</target>
        </trans-unit>
        <trans-unit id="859739a640dcccec7d3c89114d041ab46afff14a" translate="yes" xml:space="preserve">
          <source>Serializes the record and sends it to the server.</source>
          <target state="translated">레코드를 직렬화하여 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="aa92b22d8e89b667210a07e5334e64f079da918f" translate="yes" xml:space="preserve">
          <source>Serializes the record update and sends it to the server.</source>
          <target state="translated">레코드 업데이트를 직렬화하여 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="761efa682a827fca2803f8da4a302dc39dc2208e" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;belongsTo&lt;/code&gt; relationship removes the property that refers to the parent record</source>
          <target state="translated">&lt;code&gt;belongsTo&lt;/code&gt; 관계를 직렬화 하면 상위 레코드를 참조하는 특성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe4ca86767cc1bd91544bb1b9f91724e637ec8b" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;hasMany&lt;/code&gt; relationship does not remove the property that refers to the parent record.</source>
          <target state="translated">&lt;code&gt;hasMany&lt;/code&gt; 관계를 직렬화 해도 상위 레코드를 참조하는 특성이 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6798f213d4815c22490d46bda891a2bbd22a2a8" translate="yes" xml:space="preserve">
          <source>Serializing records</source>
          <target state="translated">레코드 직렬화</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">서버 측 렌더링</target>
        </trans-unit>
        <trans-unit id="d4b08fda9668f41846dc7fb238475372e5a87571" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering (also known as FastBoot)</source>
          <target state="translated">서버 측 렌더링 (FastBoot라고도 함)</target>
        </trans-unit>
        <trans-unit id="ddedf41976a8db9f179e56d77dad30a5828aa47a" translate="yes" xml:space="preserve">
          <source>Server-Side Resource Discovery</source>
          <target state="translated">서버 측 리소스 검색</target>
        </trans-unit>
        <trans-unit id="626629d0773ba5b8e704de2a8cf4d1b2671d6966" translate="yes" xml:space="preserve">
          <source>Server-backed API calls that may not fit Ember Data.</source>
          <target state="translated">Ember 데이터에 맞지 않을 수있는 서버 지원 API 호출.</target>
        </trans-unit>
        <trans-unit id="3788673593a9fb3cb0da7a56e2684739ac286fa2" translate="yes" xml:space="preserve">
          <source>Server-sent events or notifications.</source>
          <target state="translated">서버가 보낸 이벤트 또는 알림.</target>
        </trans-unit>
        <trans-unit id="acca64b83535b9a1dff37a13cd176f393be7c195" translate="yes" xml:space="preserve">
          <source>Servers</source>
          <target state="translated">Servers</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="8c95ce8ed53a712d7d11fe978a559e8aacdfb5cc" translate="yes" xml:space="preserve">
          <source>Services and Utilities</source>
          <target state="translated">서비스 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="973e47a9c7779d6a3f292ac37ac9d79ba9c45893" translate="yes" xml:space="preserve">
          <source>Services are useful for features that require shared state or persistent connections. Example uses of services might include:</source>
          <target state="translated">서비스는 공유 상태 또는 영구 연결이 필요한 기능에 유용합니다. 서비스 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44de33fce9e667d81467d696283b746a2b89ae0f" translate="yes" xml:space="preserve">
          <source>Services can be generated using Ember CLI's &lt;code&gt;service&lt;/code&gt; generator. For example, the following command will create the &lt;code&gt;ShoppingCart&lt;/code&gt; service:</source>
          <target state="translated">Ember CLI의 &lt;code&gt;service&lt;/code&gt; 생성기를 사용하여 서비스를 생성 할 수 있습니다 . 예를 들어 다음 명령은 &lt;code&gt;ShoppingCart&lt;/code&gt; 서비스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="f28ef67c082d95db9b197a590c7d6ac777b73ad0" translate="yes" xml:space="preserve">
          <source>Services must extend the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt;&lt;code&gt;Ember.Service&lt;/code&gt;&lt;/a&gt; base class:</source>
          <target state="translated">서비스는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt; &lt;code&gt;Ember.Service&lt;/code&gt; &lt;/a&gt; 기본 클래스를 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac2ee51eb0d899834a5e76d58a0d52b264a8975b" translate="yes" xml:space="preserve">
          <source>Set a list of properties on an object. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">개체의 속성 목록을 설정하십시오. 이러한 속성은 단일 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 및 &lt;code&gt;endPropertyChanges&lt;/code&gt; 일괄 처리 내에 설정 되므로 관찰자가 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="bb507d8cf4504dfd969277729f9d6cb3da94b46d" translate="yes" xml:space="preserve">
          <source>Set the value of a boolean property to the opposite of its current value.</source>
          <target state="translated">부울 속성 값을 현재 값과 반대로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="354b450dc637fea87122e449b4c6d64fd161d127" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value minus some amount.</source>
          <target state="translated">속성 값을 현재 값에서 일정량을 뺀 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a474206fc22982beb1518f159723d7d5b1a7bd6" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value plus some amount.</source>
          <target state="translated">속성 값을 현재 값에 약간 더한 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="022856defe2402ee0a7880769473d89d1b0fd118" translate="yes" xml:space="preserve">
          <source>Set this to provide an alternate class to &lt;code&gt;Ember.DefaultResolver&lt;/code&gt;</source>
          <target state="translated">대체 클래스를 &lt;code&gt;Ember.DefaultResolver&lt;/code&gt; 에 제공하려면 이것을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b2871131570de12ffc4fe0e0fa49f2aa7a81352e" translate="yes" xml:space="preserve">
          <source>Sets a list of properties at once. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">속성 목록을 한 번에 설정합니다. 이러한 속성은 단일 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 및 &lt;code&gt;endPropertyChanges&lt;/code&gt; 일괄 처리 내에 설정 되므로 관찰자가 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="e54a99e025defe6d81185356e0087e36fb02c41f" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;rel&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">&lt;code&gt;LinkComponent&lt;/code&gt; HTML 요소 의 &lt;code&gt;rel&lt;/code&gt; 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d5e1f88540ae2f1f6c34ad87101fb61aaa2e4704" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;tabindex&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">&lt;code&gt;LinkComponent&lt;/code&gt; HTML 요소 의 &lt;code&gt;tabindex&lt;/code&gt; 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2bdac2845cc69ea660701ca0222c09a0c44c26f0" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;target&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">&lt;code&gt;LinkComponent&lt;/code&gt; HTML 요소 의 &lt;code&gt;target&lt;/code&gt; 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fcf346b3d86476123ef32bd696299134f1d94520" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;title&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">&lt;code&gt;LinkComponent&lt;/code&gt; HTML 요소 의 &lt;code&gt;title&lt;/code&gt; 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b72787353f86d425923f841fb4aef6f74ac404b9" translate="yes" xml:space="preserve">
          <source>Sets the dependent keys on this computed property. Pass any number of arguments containing key paths that this computed property depends on.</source>
          <target state="translated">이 계산 된 속성에 종속 키를 설정합니다. 이 계산 된 속성이 의존하는 키 경로를 포함하는 여러 인수를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="8dcc21cc9416b36d9a48400e5dcfa0b900385d0e" translate="yes" xml:space="preserve">
          <source>Sets the provided key or path to the value.</source>
          <target state="translated">제공된 키 또는 경로를 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="871a5db89a47b1c8ac126c47ae45dbaed6801707" translate="yes" xml:space="preserve">
          <source>Sets the value of a property on an object, respecting computed properties and notifying observers and other listeners of the change. If the property is not defined but the object implements the &lt;code&gt;setUnknownProperty&lt;/code&gt; method then that will be invoked as well.</source>
          <target state="translated">계산 된 속성을 존중하고 관찰자와 다른 리스너에게 변경 사항을 알리는 객체의 속성 값을 설정합니다. 속성이 정의되지 않았지만 객체가 &lt;code&gt;setUnknownProperty&lt;/code&gt; 메서드를 구현하면이 메서드도 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="290a8a4289954bb2a5ee87f2331ca5e9d2142b2b" translate="yes" xml:space="preserve">
          <source>Sets the value on the named property for each member. This is more ergonomic than using other methods defined on this helper. If the object implements Ember.Observable, the value will be changed to &lt;code&gt;set(),&lt;/code&gt; otherwise it will be set directly. &lt;code&gt;null&lt;/code&gt; objects are skipped.</source>
          <target state="translated">각 멤버의 명명 된 속성 값을 설정합니다. 이 도우미에 정의 된 다른 방법을 사용하는 것보다 인체 공학적입니다. 객체가 Ember.Observable을 구현하면 값이 &lt;code&gt;set(),&lt;/code&gt; 으로 변경되고 , 그렇지 않으면 직접 설정됩니다. &lt;code&gt;null&lt;/code&gt; 오브젝트는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b425d7e560cd8c0761f98a652da8de1351923229" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sortQueryParams&lt;/code&gt; to a falsey value will respect the original order.</source>
          <target state="translated">&lt;code&gt;sortQueryParams&lt;/code&gt; 를 false 값으로 설정 하면 원래 순서가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da33b396a5b97cdc6b9f02bcd176c913528421e0" translate="yes" xml:space="preserve">
          <source>Setting Computed Properties</source>
          <target state="translated">계산 된 속성 설정</target>
        </trans-unit>
        <trans-unit id="b2159831f0f013e12890235b72b76c9ed8107ba6" translate="yes" xml:space="preserve">
          <source>Setting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.</source>
          <target state="translated">종속 속성을 설정하면 사용자가 만든 계산 속성 체인까지 모든 속성에 종속 된 계산 속성을 통해 변경 사항이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="5789f3a613624c39e98b0a04a128ab506fbe4ddc" translate="yes" xml:space="preserve">
          <source>Setting coalesceFindRequests to &lt;code&gt;true&lt;/code&gt; also works for &lt;code&gt;store.find&lt;/code&gt; requests and &lt;code&gt;belongsTo&lt;/code&gt; relationships accessed within the same runloop. If you set &lt;code&gt;coalesceFindRequests: true&lt;/code&gt;</source>
          <target state="translated">coalesceFindRequests를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 동일한 runloop 내에서 액세스 하는 &lt;code&gt;store.find&lt;/code&gt; 요청 및 &lt;code&gt;belongsTo&lt;/code&gt; 관계 에서도 작동합니다 . &lt;code&gt;coalesceFindRequests: true&lt;/code&gt; 를 설정 한 경우 : true</target>
        </trans-unit>
        <trans-unit id="afe29c914c9d854075bf9ebee96af7585fe24770" translate="yes" xml:space="preserve">
          <source>Setting properties on the component in &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; triggers a re-render, and for performance reasons, is not allowed.</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; &lt;/a&gt; 에서 구성 요소의 속성을 설정 하면 다시 렌더링이 트리거되며 성능상의 이유로 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f02aee210f24787a1e623ad68c0d1a1b060d3aeb" translate="yes" xml:space="preserve">
          <source>Setting query-params</source>
          <target state="translated">쿼리 매개 변수 설정</target>
        </trans-unit>
        <trans-unit id="3d7cc07cf937737b1517c6bf9374d4cc18998479" translate="yes" xml:space="preserve">
          <source>Setting up Data for the Nested Detail Route</source>
          <target state="translated">중첩 세부 경로에 대한 데이터 설정</target>
        </trans-unit>
        <trans-unit id="04b56454c3e76a73bcf804097a9d07a7e2424bf3" translate="yes" xml:space="preserve">
          <source>Setup callbacks to be fired when the test helpers are injected into your application.</source>
          <target state="translated">테스트 헬퍼가 애플리케이션에 삽입되면 설정 콜백이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd361ad8b078a558ea7b7da0dad0bbe6c028891" translate="yes" xml:space="preserve">
          <source>Several of the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt; macros utilize the &lt;code&gt;[]&lt;/code&gt; key to implement common use-cases. For instance, to create a computed property that mapped properties from an array, you could use &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map&lt;/a&gt; or build the computed property yourself:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt; 매크로 중 일부는 &lt;code&gt;[]&lt;/code&gt; 키를 사용하여 일반적인 사용 사례를 구현합니다. 예를 들어 배열에서 속성을 매핑하는 계산 된 속성을 만들려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map을&lt;/a&gt; 사용 하거나 계산 된 속성을 직접 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56671d09d11f94a0111d047a53973e69ddd5107c" translate="yes" xml:space="preserve">
          <source>Shadow DOM</source>
          <target state="translated">그림자 DOM</target>
        </trans-unit>
        <trans-unit id="a07efaea553500b80c6b1e25c2a1ad7f85b92746" translate="yes" xml:space="preserve">
          <source>Sharing Component Data with its Wrapped Content</source>
          <target state="translated">랩핑 된 컨텐츠와 구성 요소 데이터 공유</target>
        </trans-unit>
        <trans-unit id="5765ccb23e0fb8bade85df4ffb0d4efcfedb02e5" translate="yes" xml:space="preserve">
          <source>Shift an object from start of array or nil if none are left. Works just like &lt;code&gt;shift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">배열의 시작에서 객체를 이동하거나 아무것도 없으면 nil. &lt;code&gt;shift()&lt;/code&gt; 와 동일하게 작동 하지만 KVO 호환입니다.</target>
        </trans-unit>
        <trans-unit id="bcb7f8e893a6eec69601e5f12cb167564cd7ea66" translate="yes" xml:space="preserve">
          <source>Should I use controllers in my application? I've heard they're going away!</source>
          <target state="translated">어플리케이션에서 컨트롤러를 사용해야합니까? 그들이 사라지는 것을 들었습니다!</target>
        </trans-unit>
        <trans-unit id="6c4c063ccc2f6265cd6469510436e8100e2e23a9" translate="yes" xml:space="preserve">
          <source>Should actually retrieve the object at the specified index from the content. You can override this method in subclasses to transform the content item to something new.</source>
          <target state="translated">실제로 컨텐츠에서 지정된 인덱스의 오브젝트를 검색해야합니다. 서브 클래스에서이 메소드를 대체하여 컨텐츠 항목을 새로운 것으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3cbebe0c33c59b226e4d26667ceeeb607570eb4" translate="yes" xml:space="preserve">
          <source>Show more details for a selected rental</source>
          <target state="translated">선택한 대여에 대한 자세한 내용 표시</target>
        </trans-unit>
        <trans-unit id="63295e39bc7e2edd921e15de80cf52a0162dce6f" translate="yes" xml:space="preserve">
          <source>Show rentals on the home page</source>
          <target state="translated">홈페이지에 대여 표시</target>
        </trans-unit>
        <trans-unit id="a6df6bc849e9ed5bad5bd1b761e2d78888c983b9" translate="yes" xml:space="preserve">
          <source>Showing a property</source>
          <target state="translated">속성 표시</target>
        </trans-unit>
        <trans-unit id="5feabe6b60582bbf4b541103f30632fee297466c" translate="yes" xml:space="preserve">
          <source>Sideloaded Data</source>
          <target state="translated">사이드로드 된 데이터</target>
        </trans-unit>
        <trans-unit id="f5028052c614a640caa81611333680ece76b35e0" translate="yes" xml:space="preserve">
          <source>Silencing Deprecation Warnings During Compile</source>
          <target state="translated">컴파일 중 사용 중단 경고</target>
        </trans-unit>
        <trans-unit id="af61b24dae3801016bbf21366ede7ddbe142922e" translate="yes" xml:space="preserve">
          <source>Similar to how the default &lt;code&gt;loading&lt;/code&gt; event handlers are implemented, the default &lt;code&gt;error&lt;/code&gt; handlers will look for an appropriate error substate to enter, if one can be found.</source>
          <target state="translated">기본 &lt;code&gt;loading&lt;/code&gt; 이벤트 핸들러가 구현 되는 방식과 유사하게 기본 &lt;code&gt;error&lt;/code&gt; 핸들러는 적절한 오류 하위 상태 (있는 경우)를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="717acf41849b10523800fa58b23cc2b20a9ef6da" translate="yes" xml:space="preserve">
          <source>Similar to map, this specialized function returns the value of the named property on all items in the enumeration.</source>
          <target state="translated">map과 마찬가지로이 특수 함수는 열거의 모든 항목에 대해 명명 된 속성의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74e714802d7db3b86e903677715205f93a921c22" translate="yes" xml:space="preserve">
          <source>Similarly, if your backend store provides data in a format other than JSON API, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook. Using the same example as above, if the server provides data that looks like:</source>
          <target state="translated">마찬가지로 백엔드 저장소가 JSON API 이외의 형식으로 데이터를 제공하는 경우 &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt; 후크를 사용할 수 있습니다 . 서버가 다음과 같은 데이터를 제공하는 경우 위와 동일한 예를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e5ba23a2acdb58eae654126aeb02c16cfa736653" translate="yes" xml:space="preserve">
          <source>Similarly, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">마찬가지로 &lt;code&gt;/posts&lt;/code&gt; 에 대한 &lt;code&gt;GET&lt;/code&gt; 요청에 대한 JSON은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="5d072a0f490db522bd703110a84349b2f76d1d40" translate="yes" xml:space="preserve">
          <source>Simple Transition Example</source>
          <target state="translated">간단한 전환 예</target>
        </trans-unit>
        <trans-unit id="7b4ed4e4198e38ae80e5b6a6af9aeb8f248f3233" translate="yes" xml:space="preserve">
          <source>Simply converts the enumerable into a genuine array. The order is not guaranteed. Corresponds to the method implemented by Prototype.</source>
          <target state="translated">열거 형을 순정 배열로 변환하기 만하면됩니다. 주문이 보장되지 않습니다. 프로토 타입에 의해 구현 된 방법에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="fe202f68e7bb9a71a693a3787ee7684995266c8a" translate="yes" xml:space="preserve">
          <source>Simply define a template called &lt;code&gt;loading&lt;/code&gt; (and optionally a corresponding route) that Ember will transition to. The intermediate transition into the loading substate happens immediately (synchronously), the URL won't be updated, and, unlike other transitions, the currently active transition won't be aborted.</source>
          <target state="translated">Ember가 전환 할 &lt;code&gt;loading&lt;/code&gt; (및 선택적으로 해당 경로) 이라는 템플릿을 정의하면 됩니다. 로드 하위 상태로의 중간 전환은 즉시 (동기식으로) 발생하고 URL은 업데이트되지 않으며 다른 전환과 달리 현재 활성화 된 전환은 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97cf625e23a87e8fb775cd15dcb177e76da7d713" translate="yes" xml:space="preserve">
          <source>Simulates a key event type, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode on element found by the selector.</source>
          <target state="translated">선택기에서 찾은 요소에서 원하는 keyCode를 사용 하여 키 이벤트 유형 (예 : &lt;code&gt;keypress&lt;/code&gt; , &lt;code&gt;keydown&lt;/code&gt; , &lt;code&gt;keyup&lt;/code&gt; ) 을 시뮬레이션합니다 .</target>
        </trans-unit>
        <trans-unit id="9d573de332969d08498e24e616e22a931b37eb39" translate="yes" xml:space="preserve">
          <source>Simulates a key event, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode Example:</source>
          <target state="translated">원하는 keyCode 예제를 사용 하여 키 이벤트 (예 : &lt;code&gt;keypress&lt;/code&gt; , &lt;code&gt;keydown&lt;/code&gt; , &lt;code&gt;keyup&lt;/code&gt; ) 를 시뮬레이션합니다 .</target>
        </trans-unit>
        <trans-unit id="fe22422d207cd0772ccfa88aaa36392c7d87ecf6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;didUpdateAttrs&lt;/code&gt; is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</source>
          <target state="translated">렌더링 전에 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 가 호출 되므로 특정 속성이 변경 될 때이 후크를 사용하여 코드를 실행할 수 있습니다. 이 후크는 다시 렌더링하기 전에 그러나 속성이 변경된 후에 실행되므로 관찰자에 대한 효과적인 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b527d855f262ec89fbcbd6c18de1d551d43311d9" translate="yes" xml:space="preserve">
          <source>Since Ember addons are npm packages, &lt;code&gt;ember install&lt;/code&gt; installs them in the &lt;code&gt;node_modules&lt;/code&gt; directory, and makes an entry in &lt;code&gt;package.json&lt;/code&gt;. Be sure to restart your server after the addon has installed successfully. Restarting the server will incorporate the new CSS and refreshing the browser window will give you this:</source>
          <target state="translated">Ember 애드온은 npm 패키지이므로 &lt;code&gt;ember install&lt;/code&gt; 은 패키지를 &lt;code&gt;node_modules&lt;/code&gt; 디렉토리 에 설치하고 &lt;code&gt;package.json&lt;/code&gt; 에 항목을 만듭니다 . 애드온이 설치된 후 서버를 다시 시작해야합니다. 서버를 다시 시작하면 새로운 CSS가 통합되고 브라우저 창을 새로 고치면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5760823c11d76bb4f0f8aa397fbe539249ff2741" translate="yes" xml:space="preserve">
          <source>Since a JSON API Document can have meta defined in multiple locations you can use the specific serializer hooks if you need to customize the meta.</source>
          <target state="translated">JSON API 문서는 여러 위치에 메타를 정의 할 수 있으므로 메타를 사용자 정의해야하는 경우 특정 직렬 변환기 후크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3a256154d2dce95ced059699c91ae1f2f5c9d2c" translate="yes" xml:space="preserve">
          <source>Since a route's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt;&lt;code&gt;beforeModel()&lt;/code&gt;&lt;/a&gt; executes before the &lt;code&gt;model()&lt;/code&gt; hook, it's a good place to do a redirect if you don't need any information that is contained in the model.</source>
          <target state="translated">route의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt; &lt;code&gt;beforeModel()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;model()&lt;/code&gt; 후크 전에 실행되므로 모델 에 포함 된 정보가 필요하지 않은 경우 경로 재 지정을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1df2b7cd90ba8966b9e8733c80dc430ec4b6a752" translate="yes" xml:space="preserve">
          <source>Since our component is expecting the filter process to be asynchronous, we return promises from our filter, using &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember's RSVP library&lt;/a&gt;.</source>
          <target state="translated">컴포넌트가 필터 프로세스가 비동기식 일 것으로 예상하므로 &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember의 RSVP 라이브러리를&lt;/a&gt; 사용하여 필터에서 약속을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="410a75600d988e5e0052e587fd06ad0d2fe20811" translate="yes" xml:space="preserve">
          <source>Since our data is hard-coded in Mirage, we know that there is only one rental with a city name of &quot;Seattle&quot;, so we assert that the number of listings is one and that the location it displays is named, &quot;Seattle&quot;.</source>
          <target state="translated">우리 데이터는 Mirage에 하드 코딩되어 있으므로 도시 이름이 &quot;Seattle&quot;인 임대가 하나뿐이므로 목록 수는 하나이며 표시되는 위치는 &quot;Seattle&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ba722444287b7c4015475cc81a6d6d752afc68bd" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;didReceiveAttrs&lt;/code&gt; hook is called every time a component's attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</source>
          <target state="translated">이후 &lt;code&gt;didReceiveAttrs&lt;/code&gt; 의 훅이 구성 요소의 속성에 렌더링 또는 재 렌더링 여부를 업데이트 할 때마다 호출 효과적으로마다 속성 변경 실행되는 코드를 확보, 관찰자의 역할에, 당신은 후크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d7c278a30e6ec4d4f3023b775fa6840cb84e97" translate="yes" xml:space="preserve">
          <source>Since the specific &lt;code&gt;id&lt;/code&gt; of the &lt;code&gt;user&lt;/code&gt; is not known beforehand, we can use &lt;code&gt;queryRecord&lt;/code&gt; to get the user:</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 의 특정 &lt;code&gt;id&lt;/code&gt; 를 미리 알 수 &lt;code&gt;queryRecord&lt;/code&gt; 를 사용 하여 사용자를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51f0b4a52b8cebee35dc789d53b13ace54ffb771" translate="yes" xml:space="preserve">
          <source>Since there is no access to jQuery in the non-browser environment, you must also specify a DOM &lt;code&gt;Element&lt;/code&gt; object in the same &lt;code&gt;document&lt;/code&gt; for the &lt;code&gt;rootElement&lt;/code&gt; option (as opposed to a selector string like &lt;code&gt;&quot;body&quot;&lt;/code&gt;).</source>
          <target state="translated">비 브라우저 환경에서 jQuery를에 대한 액세스 권한이 없기 때문에, 당신은 또한 DOM 지정해야 &lt;code&gt;Element&lt;/code&gt; 같은에서 개체를 &lt;code&gt;document&lt;/code&gt; 에 대한 &lt;code&gt;rootElement&lt;/code&gt; 의 (같은 같은 선택 문자열에 반대 옵션 &lt;code&gt;&quot;body&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd76475c68e526debe88fcdc606730652138849e" translate="yes" xml:space="preserve">
          <source>Since we added &lt;code&gt;:rental_id&lt;/code&gt; to the &lt;code&gt;show&lt;/code&gt; path in our router, &lt;code&gt;rental_id&lt;/code&gt; is now available in our &lt;code&gt;model&lt;/code&gt; hook. When we call &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt;, Ember Data queries &lt;code&gt;/rentals/our-id&lt;/code&gt; using a HTTP GET request (&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;learn more about that here&lt;/a&gt;).</source>
          <target state="translated">라우터 의 &lt;code&gt;show&lt;/code&gt; 경로에 &lt;code&gt;:rental_id&lt;/code&gt; 를 추가 했으므로 이제 &lt;code&gt;model&lt;/code&gt; 후크 에서 &lt;code&gt;rental_id&lt;/code&gt; 를 사용할 수 있습니다 . 우리는 호출 할 때 &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt; , 엠버 데이터 쿼리 &lt;code&gt;/rentals/our-id&lt;/code&gt; HTTP를 GET 요청을 사용하여 ( &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;자세한 내용은 여기 그것에 대해 배울 수&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a193b3400008fcdd68f61cf30910ac15e02de1ad" translate="yes" xml:space="preserve">
          <source>Since we have already set up Ember Mirage in our development environment, Mirage will return the data we requested without actually making a network request.</source>
          <target state="translated">개발 환경에서 Ember Mirage를 이미 설정 했으므로 Mirage는 실제로 네트워크 요청을하지 않고도 요청한 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d50f255275c91b6d41ca18a9a609fd25ba369850" translate="yes" xml:space="preserve">
          <source>Since we haven't added any functionality to our application yet, we'll use this first test to get started on running tests in our app.</source>
          <target state="translated">아직 애플리케이션에 기능을 추가하지 않았으므로이 첫 번째 테스트를 사용하여 앱에서 테스트를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="59ca8024809d59f43c02b2a1ec4a73e4e2d23ac4" translate="yes" xml:space="preserve">
          <source>Since we want to remove this namespace, we can define a serializer for the application that will remove &quot;blog/&quot; from the payload key whenver it's encountered by Ember Data:</source>
          <target state="translated">이 네임 스페이스를 제거하고 싶기 때문에 Ember Data가 발견 할 때마다 페이로드 키에서 &quot;blog /&quot;를 제거하는 애플리케이션의 직렬 변환기를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="translated">테스트 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="de370e832d39727a0c5b9309d06edd07070c125e" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for: &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</source>
          <target state="translated">따라서 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 는 다음과 같은 약어입니다. &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b64ffe3c61fe82b2f00e41e184a5ff233a2011" translate="yes" xml:space="preserve">
          <source>So far in our example, the action we have passed to &lt;code&gt;button-with-confirmation&lt;/code&gt; is a function that accepts one argument, &lt;code&gt;messageType&lt;/code&gt;. Suppose we want to extend this by allowing &lt;code&gt;sendMessage&lt;/code&gt; to take a second argument, the actual text of the message the user is sending:</source>
          <target state="translated">지금까지의 예에서 &lt;code&gt;button-with-confirmation&lt;/code&gt; 전달한 작업 은 &lt;code&gt;messageType&lt;/code&gt; 인수 하나를 허용하는 함수입니다 . &lt;code&gt;sendMessage&lt;/code&gt; 가 사용자가 전송하는 메시지의 실제 텍스트 인 두 번째 인수를 사용 하도록 허용하여이를 확장한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="860179c222e257dfd377a3ba0841f6fa360f92ff" translate="yes" xml:space="preserve">
          <source>So far, our app is directly showing the user data from our Ember Data models. As our app grows, we will want to manipulate data further before presenting it to our users. For this reason, Ember offers Handlebars template helpers to decorate the data in our templates. Let's use a handlebars helper to allow our users to quickly see if a property is &quot;Standalone&quot; or part of a &quot;Community&quot;.</source>
          <target state="translated">지금까지 앱은 Ember 데이터 모델의 사용자 데이터를 직접 보여줍니다. 앱이 성장함에 따라 데이터를 사용자에게 제공하기 전에 데이터를 더 조작하고 싶을 것입니다. 이러한 이유로 Ember는 템플릿의 데이터를 꾸미는 핸들 바 템플릿 도우미를 제공합니다. 핸들 바 도우미를 사용하여 사용자가 속성이 &quot;독립형&quot;인지 또는 &quot;커뮤니티&quot;의 일부인지 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4beaba805d3a97bce58afc2f7cb86863c0470f86" translate="yes" xml:space="preserve">
          <source>So far, your application is listing data, but there is no way for the user to interact with the information. In web applications you often want to listen for user events like clicks or hovers. Ember makes this easy to do. First add an &lt;code&gt;action&lt;/code&gt; helper to the &lt;code&gt;li&lt;/code&gt; in your &lt;code&gt;people-list&lt;/code&gt; component.</source>
          <target state="translated">지금까지 애플리케이션이 데이터를 나열하고 있지만 사용자가 정보와 상호 작용할 수있는 방법이 없습니다. 웹 응용 프로그램에서는 종종 클릭 또는 호버와 같은 사용자 이벤트를 수신하려고합니다. Ember는 이것을 쉽게 해줍니다. 먼저 사용자 &lt;code&gt;people-list&lt;/code&gt; 구성 요소 의 &lt;code&gt;li&lt;/code&gt; 에 &lt;code&gt;action&lt;/code&gt; 헬퍼를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="82dbd01dbf5e166342277657acc79af70412fa18" translate="yes" xml:space="preserve">
          <source>So this change to &lt;code&gt;firstName&lt;/code&gt; was observed by &lt;code&gt;fullName&lt;/code&gt; computed property, which was itself observed by the &lt;code&gt;description&lt;/code&gt; property.</source>
          <target state="translated">따라서 &lt;code&gt;firstName&lt;/code&gt; 에 대한 이 변경 은 &lt;code&gt;fullName&lt;/code&gt; 계산 특성에 의해 관찰되었으며 &lt;code&gt;description&lt;/code&gt; 특성에 의해 관찰되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7c179ab2cf598954fd3d4e13b9ad80cb323f34c9" translate="yes" xml:space="preserve">
          <source>So too with JSON API. By using JSON API to interop between your Ember app and your server, you can entirely change your backend stack without breaking your frontend. And as you add apps for other platforms, such as iOS and Android, you will be able to leverage JSON API libraries for those platforms to easily consume the same API your Ember app uses.</source>
          <target state="translated">JSON API도 마찬가지입니다. JSON API를 사용하여 Ember 앱과 서버 사이의 상호 운용성을 통해 프론트 엔드를 중단하지 않고 백엔드 스택을 완전히 변경할 수 있습니다. 또한 iOS 및 Android와 같은 다른 플랫폼 용 앱을 추가 할 때 해당 플랫폼에 JSON API 라이브러리를 활용하여 Ember 앱에서 사용하는 것과 동일한 API를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b4ae5f1c58dc8bb8ea15838b3e9682246652530" translate="yes" xml:space="preserve">
          <source>So, how can we provide some visual feedback during the transition?</source>
          <target state="translated">전환 과정에서 어떻게 시각적 피드백을 제공 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fd7b7f2884ce4c1630ffc4f76897bd0d01d7ef54" translate="yes" xml:space="preserve">
          <source>So, if we want to display a purchase total we can pass the value into the template in cents:</source>
          <target state="translated">따라서 구매 총액을 표시하려면 값을 센트 단위로 템플릿에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="820ab04fe6d1513548b6823192b5113a17600f54" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;JSONAPIAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">일부 API에는 HTTP 헤더가 필요합니다 (예 : API 키 제공). &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 의 &lt;code&gt;headers&lt;/code&gt; 객체 에서 임의의 헤더를 키 / 값 쌍으로 설정할 수 있으며 Ember Data는 각 ajax 요청과 함께 헤더 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8b2ac0c846f9c6b1368c32fcb57645817bd2729e" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">일부 API에는 HTTP 헤더가 필요합니다 (예 : API 키 제공). &lt;code&gt;RESTAdapter&lt;/code&gt; 의 &lt;code&gt;headers&lt;/code&gt; 객체 에서 임의의 헤더를 키 / 값 쌍으로 설정할 수 있으며 Ember Data는 각 ajax 요청과 함께 헤더 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1ff79da2240d73d23b85815d98e514154e6babb3" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request. For dynamic headers see &lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;headers customization&lt;/a&gt;.</source>
          <target state="translated">일부 API에는 HTTP 헤더가 필요합니다 (예 : API 키 제공). &lt;code&gt;RESTAdapter&lt;/code&gt; 의 &lt;code&gt;headers&lt;/code&gt; 객체 에서 임의의 헤더를 키 / 값 쌍으로 설정할 수 있으며 Ember Data는 각 ajax 요청과 함께 헤더 를 보냅니다. 동적 헤더의 경우 &lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;헤더 사용자 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="589305bc3eb0d013e4fe10cb12d21b40cca5f01f" translate="yes" xml:space="preserve">
          <source>Some addons might conditionally include polyfills only if needed. Some linters may emit warnings when using features not yet fully supported in your targets. Some addons may even automatically prefix unsupported CSS properties.</source>
          <target state="translated">일부 애드온은 필요한 경우에만 폴리 필을 조건부로 포함 할 수 있습니다. 대상에서 아직 완전히 지원되지 않는 기능을 사용하면 일부 린터에 경고가 표시 될 수 있습니다. 일부 애드온은 지원되지 않는 CSS 속성을 자동으로 접두사로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a6dac8bf912ce569cbeab14f1bf531b4c08379" translate="yes" xml:space="preserve">
          <source>Some examples modifying that default behavior:</source>
          <target state="translated">기본 동작을 수정하는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="82534b5183631ee9d5eeba124dc1c2d8a8efa3a1" translate="yes" xml:space="preserve">
          <source>Some examples of how names are resolved:</source>
          <target state="translated">이름을 확인하는 방법에 대한 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="9d5184c34d7d66d58908b766bee8f66460408f46" translate="yes" xml:space="preserve">
          <source>Some models may have properties that are deeply nested objects of readonly data. The na&amp;iuml;ve solution would be to define models for each nested object and use &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; to recreate the nested relationship. However, since readonly data will never need to be updated and saved this often results in the creation of a great deal of code for very little benefit. An alternate approach is to define these relationships using an attribute with no transform (&lt;code&gt;DS.attr()&lt;/code&gt;). This makes it easy to access readonly values in computed properties and templates without the overhead of defining extraneous models.</source>
          <target state="translated">일부 모델에는 읽기 전용 데이터의 깊게 중첩 된 객체 인 속성이있을 수 있습니다. 순진한 솔루션은 중첩 된 각 객체에 대한 모델을 정의하고 &lt;code&gt;hasMany&lt;/code&gt; 및 &lt;code&gt;belongsTo&lt;/code&gt; 를 사용하여 중첩 된 관계를 다시 만드는 것입니다. 그러나 읽기 전용 데이터는 업데이트 및 저장 될 필요가 없기 때문에 이로 인해 많은 이점을 얻을 수있는 코드가 많이 생성됩니다. 다른 방법은 변환이없는 속성 ( &lt;code&gt;DS.attr()&lt;/code&gt; )을 사용하여 이러한 관계를 정의하는 것입니다 . 따라서 외부 모델을 정의하지 않고도 계산 된 속성 및 템플릿에서 읽기 전용 값에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c345287ac108fa43e40986e9e0b206ee82b4fe8" translate="yes" xml:space="preserve">
          <source>Some of Ember's test helpers are promises that wait for the run loop to empty before resolving. If your application has code that runs &lt;em&gt;outside&lt;/em&gt; a run loop, these will resolve too early and give erroneous test failures which are difficult to find. Disabling autoruns help you identify these scenarios and helps both your testing and your application!</source>
          <target state="translated">Ember의 테스트 헬퍼 중 일부는 해결하기 전에 실행 루프가 비기를 기다리는 약속입니다. 응용 프로그램 에 실행 루프 &lt;em&gt;외부&lt;/em&gt; 에서 실행 되는 코드가있는 경우 너무 일찍 해결되어 찾기 어려운 테스트 오류가 발생합니다. 자동 실행을 비활성화하면 이러한 시나리오를 식별하고 테스트와 응용 프로그램을 모두 도울 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="4979198f37570d49855015976a8e9dfdb6023e02" translate="yes" xml:space="preserve">
          <source>Some of the helpers we'll use commonly are:</source>
          <target state="translated">우리가 일반적으로 사용하는 도우미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3748e66aa53dcbbdabc1f3d7af1f40169fdff824" translate="yes" xml:space="preserve">
          <source>Some of the more common ways to report a problem with the guides are:</source>
          <target state="translated">가이드와 관련된 문제를보고하는 가장 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5337883a101c091bf437d743927429e7f9b3a8dc" translate="yes" xml:space="preserve">
          <source>Some of the reasons this may happen:</source>
          <target state="translated">이것이 발생할 수있는 몇 가지 이유 :</target>
        </trans-unit>
        <trans-unit id="822e1f477acc562b0e523818fa99c2731cc5d901" translate="yes" xml:space="preserve">
          <source>Some of these features that you'll learn about in the guides are:</source>
          <target state="translated">이 가이드에서 배우게 될 기능 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66952b6d0704d8bd5ed88829a1728002186d07f9" translate="yes" xml:space="preserve">
          <source>Some other event in the app causes the URL to change.</source>
          <target state="translated">앱의 다른 이벤트로 인해 URL이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="6662963cf7cb67b19d16e3797446e1a4df2164ae" translate="yes" xml:space="preserve">
          <source>Some properties are not only grouped by inheritance, but also by framework level semantics. For example, if you inspect an Ember Data model, you can see &lt;code&gt;Attributes&lt;/code&gt;, &lt;code&gt;Belongs To&lt;/code&gt;, &lt;code&gt;Has Many&lt;/code&gt;, and &lt;code&gt;Flags&lt;/code&gt; groups.</source>
          <target state="translated">일부 속성은 상속뿐만 아니라 프레임 워크 수준 시맨틱별로 그룹화됩니다. 예를 들어 Ember 데이터 모델을 검사하면 &lt;code&gt;Attributes&lt;/code&gt; , &lt;code&gt;Belongs To&lt;/code&gt; ,, &lt;code&gt;Has Many&lt;/code&gt; 및 &lt;code&gt;Flags&lt;/code&gt; 그룹을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="325238f44bc39a7d51558fbf18caf5277d0da375" translate="yes" xml:space="preserve">
          <source>Some reasons for customizing an Adapter include using &lt;code&gt;underscores_case&lt;/code&gt; in your urls, using a medium other than REST to communicate with your backend API or even using a &lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;local storage backend&lt;/a&gt;.</source>
          <target state="translated">어댑터를 사용자 정의하는 몇 가지 이유는 URL에 &lt;code&gt;underscores_case&lt;/code&gt; 를 사용하거나, REST 이외의 매체를 사용하여 백엔드 API와 통신하거나 &lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;로컬 스토리지 백엔드를&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2244f25ae871987e59d131e17c8c7397712981aa" translate="yes" xml:space="preserve">
          <source>Some routes always display the same model. For example, the &lt;code&gt;/photos&lt;/code&gt; route will always display the same list of photos available in the application. If your user leaves this route and comes back later, the model does not change.</source>
          <target state="translated">일부 경로는 항상 동일한 모델을 표시합니다. 예를 들어, &lt;code&gt;/photos&lt;/code&gt; 경로는 항상 응용 프로그램에서 사용 가능한 동일한 사진 목록을 표시합니다. 사용자가이 경로를 떠나 나중에 다시 돌아 오더라도 모델은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfada9d7be3abdb25489a10a3babdd4c487f5a91" translate="yes" xml:space="preserve">
          <source>Some specific examples of units tests are:</source>
          <target state="translated">단위 테스트의 몇 가지 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4c0047cd154d80ed200c3a10a6e33a060f165c8" translate="yes" xml:space="preserve">
          <source>Some times you might be working on a feature, but know that a certain test will fail so you might want to skip it. You can do it by using &lt;code&gt;skip&lt;/code&gt;:</source>
          <target state="translated">때로는 기능에 대한 작업을하고있을 수도 있지만 특정 테스트가 실패한다는 것을 알고 있으므로 건너 뛸 수 있습니다. &lt;code&gt;skip&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8353c07cd51f4950ee2ad76a1992e4ffb81690e" translate="yes" xml:space="preserve">
          <source>Some types of computed properties are very common. Ember provides a number of computed property macros, which are shorter ways of expressing certain types of computed property.</source>
          <target state="translated">일부 유형의 계산 속성은 매우 일반적입니다. Ember는 여러 유형의 계산 속성 매크로를 제공하는데, 이는 특정 유형의 계산 속성을 표현하는 더 짧은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="86c891d4cd8c7cba722589fb8d2aa6a1abb982b5" translate="yes" xml:space="preserve">
          <source>Sometimes a service may or may not exist, like when an initializer conditionally registers a service. Since normal injection will throw an error if the service doesn't exist, you must look up the service using Ember's &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt;&lt;code&gt;getOwner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이니셜 라이저가 서비스를 조건부로 등록하는 경우와 같이 서비스가 존재하거나 존재하지 않을 수 있습니다. 서비스가 존재하지 않으면 일반 주입에서 오류가 발생하므로 대신 Ember의 &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt; &lt;code&gt;getOwner&lt;/code&gt; &lt;/a&gt; 를 사용하여 서비스를 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3155e1aa9ca809aad16247d1dc430dba0afcf4d9" translate="yes" xml:space="preserve">
          <source>Sometimes controllers have dependencies on other controllers. This is accomplished by injecting one controller into another. For example, here are two simple controllers. The &lt;code&gt;CommentsController&lt;/code&gt; uses the &lt;code&gt;PostController&lt;/code&gt; via &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">때때로 컨트롤러는 다른 컨트롤러에 종속됩니다. 이것은 하나의 컨트롤러를 다른 컨트롤러에 주입하여 수행됩니다. 예를 들어 다음은 두 개의 간단한 컨트롤러입니다. &lt;code&gt;CommentsController&lt;/code&gt; 는 용도 &lt;code&gt;PostController&lt;/code&gt; 을 통해 &lt;code&gt;inject&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9e4d9e623bb94a60e9ac83b620b9d575221d6a19" translate="yes" xml:space="preserve">
          <source>Sometimes the parent component invoking an action has some context needed for the action that the child component doesn't. Consider, for example, the case where the &lt;code&gt;button-with-confirmation&lt;/code&gt; component we've defined is used within &lt;code&gt;send-message&lt;/code&gt;. The &lt;code&gt;sendMessage&lt;/code&gt; action that we pass to the child component may expect a message type parameter to be provided as an argument:</source>
          <target state="translated">때때로 액션을 호출하는 부모 컴포넌트는 자식 컴포넌트가하지 않는 액션에 필요한 컨텍스트를 가지고 있습니다. 예를 들어, 정의한 &lt;code&gt;button-with-confirmation&lt;/code&gt; 구성 요소가 &lt;code&gt;send-message&lt;/code&gt; 내에서 사용되는 경우를 고려하십시오 . &lt;code&gt;sendMessage&lt;/code&gt; 우리가 아이 컴퍼넌트에 전달한다는 조치는 메시지 유형 매개 변수는 인수로 제공 될 것으로 예상 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="b795927e172ff54b29fd66e4ef2233525e286ec2" translate="yes" xml:space="preserve">
          <source>Sometimes the value you want to propagate to a downstream promise can only be retrieved asynchronously. This can be achieved by returning a promise in the fulfillment or rejection handler. The downstream promise will then be pending until the returned promise is settled. This is called &lt;em&gt;assimilation&lt;/em&gt;.</source>
          <target state="translated">때로는 다운 스트림 약속으로 전파하려는 값을 비동기식으로 만 검색 할 수 있습니다. 이행 또는 거부 처리기에서 약속을 반환하면됩니다. 그러면 다운 스트림 약속은 반환 된 약속이 정산 될 때까지 보류됩니다. 이것을 &lt;em&gt;동화&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="fb6b416b736de5984855b00b7181426c6ea9cfe1" translate="yes" xml:space="preserve">
          <source>Sometimes we want to set relationships on already existing records. We can simply set a &lt;code&gt;belongsTo&lt;/code&gt; relationship:</source>
          <target state="translated">때로는 기존 레코드에 관계를 설정하려고합니다. 우리는 간단히 &lt;code&gt;belongsTo&lt;/code&gt; 관계 를 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e3938ef49fd1f00900f13ab44705cfe380190afd" translate="yes" xml:space="preserve">
          <source>Sometimes you don't care if properties of individual array items change. In this case use the &lt;code&gt;[]&lt;/code&gt; key instead of &lt;code&gt;@each&lt;/code&gt;. Computed properties dependent on an array using the &lt;code&gt;[]&lt;/code&gt; key will only update if items are added to or removed from the array, or if the array property is set to a different array. For example:</source>
          <target state="translated">개별 배열 항목의 속성이 변경 되더라도 신경 쓰지 않아도됩니다. 이 경우 &lt;code&gt;@each&lt;/code&gt; 대신 &lt;code&gt;[]&lt;/code&gt; 키를 사용하십시오 . &lt;code&gt;[]&lt;/code&gt; 키를 사용하여 배열에 종속 된 계산 된 속성 은 항목이 배열에 추가되거나 배열에서 제거되거나 배열 속성이 다른 배열로 설정된 경우에만 업데이트됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59593e85c482d9ccffbf9cb3f10447cbf9a7e137" translate="yes" xml:space="preserve">
          <source>Sometimes you have a computed property whose value depends on the properties of items in an array. For example, you may have an array of todo items, and want to calculate the incomplete todo's based on their &lt;code&gt;isDone&lt;/code&gt; property.</source>
          <target state="translated">때로는 배열에있는 항목의 속성에 따라 값이 달라지는 계산 된 속성이 있습니다. 예를 들어, 할 일 항목의 배열이 있고 &lt;code&gt;isDone&lt;/code&gt; 속성을 기반으로 불완전한 할 일을 계산하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416096650446b210755d175075d7e07b083b9ad1" translate="yes" xml:space="preserve">
          <source>Sometimes you need to fetch a model, but your route doesn't have the parameters, because it's a child route and the route directly above or a few levels above has the parameters that your route needs.</source>
          <target state="translated">경우에 따라 모델을 가져와야하지만 루트는 하위 경로이고 경로 바로 위 또는 일부 레벨에는 경로에 필요한 매개 변수가 있으므로 경로에 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="559f553ca9e321ad0a7cbfeb49c2a261a0036395" translate="yes" xml:space="preserve">
          <source>Sometimes you need to retain the &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">때때로 당신은 &lt;code&gt;this&lt;/code&gt; 유지해야 합니다 :</target>
        </trans-unit>
        <trans-unit id="069522e3125331b06bf7bf0225dd816607897fe7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to redirect a user to a different page than what they requested for.</source>
          <target state="translated">때로는 요청한 것과 다른 페이지로 사용자를 리디렉션하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2baef004d709137087990a2c9d850371fca71c1c" translate="yes" xml:space="preserve">
          <source>Sometimes, you may want to define a component that wraps content provided by other templates.</source>
          <target state="translated">때로는 다른 템플릿에서 제공하는 내용을 래핑하는 구성 요소를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="96659bf5510b1ddbf595565c481a37824bc493f8" translate="yes" xml:space="preserve">
          <source>Specifies how records can be filtered. Records returned will need to have a &lt;code&gt;filterValues&lt;/code&gt; property with a key for every name in the returned array.</source>
          <target state="translated">레코드를 필터링하는 방법을 지정합니다. 반환 된 레코드 에는 반환 된 배열의 모든 이름에 대한 키 가있는 &lt;code&gt;filterValues&lt;/code&gt; 속성 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="95f6dd8dc212ba5d85302c1420a17db8da9053f3" translate="yes" xml:space="preserve">
          <source>Specify a method that observes property changes.</source>
          <target state="translated">속성 변경을 관찰하는 방법을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="223591aeca04cad98919771b70c08a1289123a53" translate="yes" xml:space="preserve">
          <source>Specifying DOM event type</source>
          <target state="translated">DOM 이벤트 유형 지정</target>
        </trans-unit>
        <trans-unit id="9dc9de0aa5ed554b19547386f6cca49a1ec57918" translate="yes" xml:space="preserve">
          <source>Specifying Initializer Order</source>
          <target state="translated">이니셜 라이저 순서 지정</target>
        </trans-unit>
        <trans-unit id="5fdf0dd083e563032f5e6602ce7e005cc574889d" translate="yes" xml:space="preserve">
          <source>Specifying Keys</source>
          <target state="translated">키 지정</target>
        </trans-unit>
        <trans-unit id="35833528563ce69a1f68854f07be8e7aa16a509d" translate="yes" xml:space="preserve">
          <source>Specifying Query Parameters</source>
          <target state="translated">쿼리 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="7c35f3946da6ff79b8757a6ceb8ee8d49df16369" translate="yes" xml:space="preserve">
          <source>Specifying a Root URL</source>
          <target state="translated">루트 URL 지정</target>
        </trans-unit>
        <trans-unit id="3178f09d7674b2ba76416a9f78ffa51e9d2fdd63" translate="yes" xml:space="preserve">
          <source>Specifying a Route&amp;#x27;s Model</source>
          <target state="translated">경로 모델 지정</target>
        </trans-unit>
        <trans-unit id="0aab4ef25ec9e8d4b45fcc096abf64fe7a154c92" translate="yes" xml:space="preserve">
          <source>Specifying a Route's Model</source>
          <target state="translated">경로 모델 지정</target>
        </trans-unit>
        <trans-unit id="9d13a540e07e9718658fc51f3532a2a9665ff955" translate="yes" xml:space="preserve">
          <source>Specifying a Target</source>
          <target state="translated">대상 지정</target>
        </trans-unit>
        <trans-unit id="0576f645f0df389ae6ff04ea0100cb46c490b756" translate="yes" xml:space="preserve">
          <source>Specifying the Type of Event</source>
          <target state="translated">이벤트 유형 지정</target>
        </trans-unit>
        <trans-unit id="d91b92c60fdffefa96bc27ffdf887f5e281d0a13" translate="yes" xml:space="preserve">
          <source>Specifying the URL Type</source>
          <target state="translated">URL 유형 지정</target>
        </trans-unit>
        <trans-unit id="c69285edae5096eb75f15a92d92d9083fbcd550c" translate="yes" xml:space="preserve">
          <source>Specifying whitelisted modifier keys</source>
          <target state="translated">허용 된 수정 자 키 지정</target>
        </trans-unit>
        <trans-unit id="9d4fa9e78c183321cef3a8e36a830b3610a9a700" translate="yes" xml:space="preserve">
          <source>Splits a string into separate units separated by spaces, eliminating any empty strings in the process. This is a convenience method for split that is mostly useful when applied to the &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">문자열을 공백으로 구분 된 별도의 단위로 분할하여 프로세스에서 빈 문자열을 제거합니다. 이것은 분할에 대한 편리한 방법으로, &lt;code&gt;String.prototype&lt;/code&gt; 에 적용될 때 주로 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="0d1e61286aa50eb30bfbfd7083574b6c91fc2ff1" translate="yes" xml:space="preserve">
          <source>Standard CSS class names to apply to the view's outer element. This property automatically inherits any class names defined by the view's superclasses as well.</source>
          <target state="translated">뷰의 외부 요소에 적용 할 표준 CSS 클래스 이름입니다. 이 속성은 뷰의 수퍼 클래스에 의해 정의 된 모든 클래스 이름을 자동으로 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8d2e5c61163ac5addfc66cdf3663694e20d997c0" translate="yes" xml:space="preserve">
          <source>Standard Method</source>
          <target state="translated">표준 방법</target>
        </trans-unit>
        <trans-unit id="bbbc2d09acef9d54bec542a8902adc3b0bd87a72" translate="yes" xml:space="preserve">
          <source>Start by running &lt;code&gt;ember g controller rentals/index&lt;/code&gt; to create an index controller for our nested route.</source>
          <target state="translated">실행하여 시작 &lt;code&gt;ember g controller rentals/index&lt;/code&gt; 우리의 중첩 된 경로에 대한 인덱스 컨트롤러를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3689b34944e00b45a933d94ff2ffb05b06064e" translate="yes" xml:space="preserve">
          <source>Starting index in the array to replace. If idx &amp;gt;= length, then append to the end of the array.</source>
          <target state="translated">대체 할 배열의 인덱스 시작 idx&amp;gt; = length 인 경우 배열 끝에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="e2943b559f079da6407626d86e22f36963a935be" translate="yes" xml:space="preserve">
          <source>Statements like &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;unless&lt;/code&gt;&lt;/a&gt; are implemented as built-in helpers. Helpers can be invoked three ways, each of which is illustrated below with conditionals.</source>
          <target state="translated">문이 좋아하는 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;unless&lt;/code&gt; &lt;/a&gt; 내장에 도우미로 구현됩니다. 도우미는 세 가지 방법으로 호출 할 수 있으며 각 방법은 아래에 조건부와 함께 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1feba1e46ddf6c53b1adc00d9107a1d9ebc21a7" translate="yes" xml:space="preserve">
          <source>States are hierarchical and every state is a substate of the &lt;code&gt;RootState&lt;/code&gt;. For example, a record can be in the &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; state, then transition into the &lt;code&gt;root.deleted.inFlight&lt;/code&gt; state. If a child state does not implement an event handler, the state manager will attempt to invoke the event on all parent states until the root state is reached. The state hierarchy of a record is described in terms of a path string. You can determine a record's current state by getting the state's &lt;code&gt;stateName&lt;/code&gt; property:</source>
          <target state="translated">상태는 계층 적이며 모든 상태는 &lt;code&gt;RootState&lt;/code&gt; 의 하위 상태입니다 . 예를 들어, 레코드가있을 수 &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; 로 전환 한 후, 상태 &lt;code&gt;root.deleted.inFlight&lt;/code&gt; 의 상태. 하위 상태가 이벤트 핸들러를 구현하지 않으면 상태 관리자는 루트 상태에 도달 할 때까지 모든 상위 상태에서 이벤트를 호출하려고 시도합니다. 레코드의 상태 계층은 경로 문자열로 설명됩니다. 상태의 &lt;code&gt;stateName&lt;/code&gt; 속성 을 가져와 레코드의 현재 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00eb37c2ad8ac597d25ead8c96dc4b915e4541c5" translate="yes" xml:space="preserve">
          <source>Sticky Query Param Values</source>
          <target state="translated">고정 쿼리 매개 변수 값</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="f1666d2bcbc1f1662ac087a581ceacb42b38e437" translate="yes" xml:space="preserve">
          <source>Store createRecord() vs. push() vs. pushPayload()</source>
          <target state="translated">createRecord () 대 push () 및 pushPayload () 저장</target>
        </trans-unit>
        <trans-unit id="9c9e836e042084875f2706702835fd50f3d499b1" translate="yes" xml:space="preserve">
          <source>Storing and Retrying a Transition</source>
          <target state="translated">전환 저장 및 재시도</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="b3d17fda1094db33050217bb63ea9c24bd2b99dc" translate="yes" xml:space="preserve">
          <source>String or Function</source>
          <target state="translated">문자열 또는 함수</target>
        </trans-unit>
        <trans-unit id="1c9540a017269c9feb496d71189bffe50f7d5885" translate="yes" xml:space="preserve">
          <source>String...|Array</source>
          <target state="translated">String...|Array</target>
        </trans-unit>
        <trans-unit id="f0d3c25699981cc6a89aac831ec30d8b3c22399b" translate="yes" xml:space="preserve">
          <source>String.w()</source>
          <target state="translated">String.w()</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="5e2de559df2862cc71558e06f2eeae9cf0efe5c0" translate="yes" xml:space="preserve">
          <source>Strings will no longer have the convenience methods described in the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt;&lt;code&gt;Ember.String&lt;/code&gt; API reference&lt;/a&gt;. Instead, you can use the similarly-named methods of the &lt;code&gt;Ember.String&lt;/code&gt; object and pass the string to use as the first parameter:</source>
          <target state="translated">문자열은 더 이상 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt; &lt;code&gt;Ember.String&lt;/code&gt; API 참조에&lt;/a&gt; 설명 된 편리한 메소드를 갖지 않습니다 . 대신 비슷한 이름의 &lt;code&gt;Ember.String&lt;/code&gt; 객체 메서드 를 사용하고 첫 번째 매개 변수로 사용할 문자열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3524a89f0508fdccd88639d09b323af881a667b5" translate="yes" xml:space="preserve">
          <source>String|Function</source>
          <target state="translated">String|Function</target>
        </trans-unit>
        <trans-unit id="096cde0b9a1b5f451a441cdfbe8d57859fd850e0" translate="yes" xml:space="preserve">
          <source>String|Integer</source>
          <target state="translated">String|Integer</target>
        </trans-unit>
        <trans-unit id="7dffcf19da01173ef7755fae671bcdb375a056de" translate="yes" xml:space="preserve">
          <source>String|Number</source>
          <target state="translated">String|Number</target>
        </trans-unit>
        <trans-unit id="c54337b559e9f029d16387ab04f89b68d4a2d8c3" translate="yes" xml:space="preserve">
          <source>String|Number|Object</source>
          <target state="translated">String|Number|Object</target>
        </trans-unit>
        <trans-unit id="7510182a2f01b9f70534bd7ab87456330ddc7be5" translate="yes" xml:space="preserve">
          <source>String|Object</source>
          <target state="translated">String|Object</target>
        </trans-unit>
        <trans-unit id="baca1a7147855eb5795ff280775be4b9cf07d961" translate="yes" xml:space="preserve">
          <source>String|Property</source>
          <target state="translated">String|Property</target>
        </trans-unit>
        <trans-unit id="7087dd5b60a0e5d36d078de3709bb645d286db69" translate="yes" xml:space="preserve">
          <source>Stubbing Services</source>
          <target state="translated">스터 빙 서비스</target>
        </trans-unit>
        <trans-unit id="27aa4c7ccfa314309a981fe2957b63393d5fce5e" translate="yes" xml:space="preserve">
          <source>Stubbing Services in Acceptance Tests</source>
          <target state="translated">수락 테스트에서 스터 빙 서비스</target>
        </trans-unit>
        <trans-unit id="87fc913c19cccd1420f6549019e6ab07d2652eb8" translate="yes" xml:space="preserve">
          <source>Submitting a post without a title displays a red validation state on the field and gives the user text indicating that the title is required.</source>
          <target state="translated">제목없이 게시물을 제출하면 필드에 빨간색 유효성 검사 상태가 표시되고 제목이 필요함을 나타내는 텍스트가 사용자에게 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="6ef9815ada2a0398b68221d1261a977ff08f7246" translate="yes" xml:space="preserve">
          <source>Subscribe to a listener by using &lt;code&gt;Ember.subscribe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Ember.subscribe&lt;/code&gt; 를 사용하여 리스너를 구독 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7e7cd9296878731ca54a308b73da381671370f" translate="yes" xml:space="preserve">
          <source>Subscribes a function to a named event and then cancels the subscription after the first time the event is triggered. It is good to use &lt;code&gt;one&lt;/code&gt; when you only care about the first time an event has taken place.</source>
          <target state="translated">명명 된 이벤트에 함수를 구독 한 다음 이벤트가 처음 트리거 된 후 구독을 취소합니다. 사용하는 것이 좋다 &lt;code&gt;one&lt;/code&gt; 당신은 단지 이벤트가 일어난 것은 이번이 처음 관심을 때.</target>
        </trans-unit>
        <trans-unit id="1a236ce5c458753d003516cfdb6d3fbc2147baa0" translate="yes" xml:space="preserve">
          <source>Subscribes to a named event with given function.</source>
          <target state="translated">주어진 기능으로 명명 된 이벤트를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="21ff0eedd4b3be556de21a3ebae1bcf1865e815e" translate="yes" xml:space="preserve">
          <source>Success and failure</source>
          <target state="translated">성공과 실패</target>
        </trans-unit>
        <trans-unit id="d566bb22908b1ec9a9610a20f300bf499e0d3e6f" translate="yes" xml:space="preserve">
          <source>Supplying a model</source>
          <target state="translated">모델 공급</target>
        </trans-unit>
        <trans-unit id="307ad7bba7045cbdfbe8ab3762416f0cfe2eeea8" translate="yes" xml:space="preserve">
          <source>Supplying a tagName</source>
          <target state="translated">tagName 제공</target>
        </trans-unit>
        <trans-unit id="2a1281cd7b34a3b437d33cc93541bd5fe0eac5b8" translate="yes" xml:space="preserve">
          <source>Supplying an explicit dynamic segment value</source>
          <target state="translated">명시 적 동적 세그먼트 값 제공</target>
        </trans-unit>
        <trans-unit id="ac7e6f74b23299de001ce35020dda39ed87fccdf" translate="yes" xml:space="preserve">
          <source>Supplying multiple models</source>
          <target state="translated">여러 모델 공급</target>
        </trans-unit>
        <trans-unit id="3c4685eb55ed20aeb850f996709d097128114b51" translate="yes" xml:space="preserve">
          <source>Support for ES2015/ES6 JavaScript via the &lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt; project. This includes support for &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript modules&lt;/a&gt;, which are used throughout this guide.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt; 프로젝트 를 통해 ES2015 / ES6 JavaScript를 지원합니다 . 여기에는 이 안내서 전체에서 사용되는 &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript 모듈에&lt;/a&gt; 대한 지원이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2c0191bfc5d5b1bd1375a04ab5288df11a1e581" translate="yes" xml:space="preserve">
          <source>Supported Scenarios</source>
          <target state="translated">지원되는 시나리오</target>
        </trans-unit>
        <trans-unit id="f158e8ae8a0fd5a1bbca7308d27f425549f52faa" translate="yes" xml:space="preserve">
          <source>Supporting both block and non-block component usage in one template</source>
          <target state="translated">하나의 템플릿에서 블록 및 비 블록 구성 요소 사용 지원</target>
        </trans-unit>
        <trans-unit id="21d313eca972677af60300d5c32cdc508135a054" translate="yes" xml:space="preserve">
          <source>Supporting different editing styles will require different body components to provide special validation and highlighting. To load a different body component based on editing style, you can yield the component using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;component helper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt;&lt;code&gt;hash helper&lt;/code&gt;&lt;/a&gt;. Here, the appropriate component is assigned to a hash using nested helpers and yielded to the template. Notice &lt;code&gt;editStyle&lt;/code&gt; being used as an argument to the component helper.</source>
          <target state="translated">다른 편집 스타일을 지원하려면 특별한 검증 및 강조를 제공하기 위해 다른 바디 구성 요소가 필요합니다. 편집 스타일을 기반으로 다른 본문 구성 요소를로드하려면 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;component helper&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt; &lt;code&gt;hash helper&lt;/code&gt; &lt;/a&gt; 사용하여 구성 요소를 생성 할 수 있습니다 . 여기에서 중첩 된 도우미를 사용하여 적절한 구성 요소가 해시에 할당되고 템플릿으로 생성됩니다. 공지 사항 &lt;code&gt;editStyle&lt;/code&gt; 는 구성 요소 도우미에 대한 인수로 사용된다.</target>
        </trans-unit>
        <trans-unit id="870b6a43f9969937a6b78668e5f67b305829ac03" translate="yes" xml:space="preserve">
          <source>Suppose we have an object that has a property and a method observing that property.</source>
          <target state="translated">속성이있는 객체와 해당 속성을 관찰하는 메서드가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9675587d4669654928b069872d4f2938fc8dc804" translate="yes" xml:space="preserve">
          <source>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</source>
          <target state="translated">자주 사용하는 날짜 선택기 라이브러리를 Ember 프로젝트에 통합한다고 가정합니다. 일반적으로 타사 JS / jQuery 라이브러리에는 바인딩 할 DOM 요소가 필요합니다. 그렇다면 라이브러리를 초기화하고 연결하는 가장 좋은 곳은 어디입니까?</target>
        </trans-unit>
        <trans-unit id="20aeee9b0344b503f9d7a448f7aba7ca9a8c5cca" translate="yes" xml:space="preserve">
          <source>Synchronous Example</source>
          <target state="translated">동기 예</target>
        </trans-unit>
        <trans-unit id="495d2949869c7e350f566c1678a60431b1cc2fcf" translate="yes" xml:space="preserve">
          <source>Synchronous Helpers</source>
          <target state="translated">동기 헬퍼</target>
        </trans-unit>
        <trans-unit id="342d5495308e369e444baf3f33f246d0bcc29b75" translate="yes" xml:space="preserve">
          <source>Synchronous example:</source>
          <target state="translated">동기식 예 :</target>
        </trans-unit>
        <trans-unit id="d54e57d31e1997c6a23c5f4f4a2538763d613e21" translate="yes" xml:space="preserve">
          <source>Synchronous helpers are performed immediately when triggered.</source>
          <target state="translated">동기 헬퍼는 트리거 될 때 즉시 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7863003b76de30fb0d39d091532fa48c8ca6a75e" translate="yes" xml:space="preserve">
          <source>Tackling Deprecations</source>
          <target state="translated">지원 중단 문제</target>
        </trans-unit>
        <trans-unit id="1d6f3b9629d6275a16e909978a30680b410d16c9" translate="yes" xml:space="preserve">
          <source>Tag name for the view's outer element. The tag name is only used when an element is first created. If you change the &lt;code&gt;tagName&lt;/code&gt; for an element, you must destroy and recreate the view element.</source>
          <target state="translated">뷰의 외부 요소에 대한 태그 이름입니다. 태그 이름은 요소가 처음 생성 될 때만 사용됩니다. 요소 의 &lt;code&gt;tagName&lt;/code&gt; 을 변경 하면보기 요소를 삭제 한 후 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb8e3e9f7283008461ee747f3e130db27bb0a277" translate="yes" xml:space="preserve">
          <source>Take for example the following routes:</source>
          <target state="translated">다음 경로를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2c60cfa4ea62384dd026b50e8f6e0eed19938e00" translate="yes" xml:space="preserve">
          <source>Takes an ajax response, and returns the json payload or an error.</source>
          <target state="translated">ajax 응답을 가져 와서 json 페이로드 또는 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ab8aad230fdba67c86441e29f313daf20e0add73" translate="yes" xml:space="preserve">
          <source>TargetActionSupport</source>
          <target state="translated">TargetActionSupport</target>
        </trans-unit>
        <trans-unit id="d1e8254c86f37cbe15667c32cc8a8a8fff4cd1ef" translate="yes" xml:space="preserve">
          <source>Template compilation.</source>
          <target state="translated">템플릿 편집.</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f26dba0d688990ff76ff8c4eada0b9b5921db5b4" translate="yes" xml:space="preserve">
          <source>Templates are backed with a context. A context is an object from which Handlebars expressions read their properties. In Ember this is often a component. For templates rendered by a route (like &lt;code&gt;application.hbs&lt;/code&gt;), the context is a controller.</source>
          <target state="translated">템플릿은 컨텍스트와 함께 백업됩니다. 컨텍스트는 Handlebars 표현식이 해당 속성을 읽는 객체입니다. Ember에서 이것은 종종 컴포넌트입니다. 경로 ( &lt;code&gt;application.hbs&lt;/code&gt; 와 같은 )로 렌더링 된 템플릿의 경우 컨텍스트는 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="bca019d1b04ef7b9ee38e243a74a67fd82e673fa" translate="yes" xml:space="preserve">
          <source>Templates can also display properties provided to them from their context, which is either a component or a route's controller. For example:</source>
          <target state="translated">템플릿은 구성 요소 또는 경로의 컨트롤러 인 컨텍스트에서 제공되는 속성을 표시 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="517698063a175f12911d21c0535adc2e76938ecf" translate="yes" xml:space="preserve">
          <source>Templates manage the flow of an application's UI, and display state (through the DOM) to a user. For example, given a component with the property &quot;name&quot;, that component's template can use the name in several ways:</source>
          <target state="translated">템플릿은 응용 프로그램의 UI 흐름을 관리하고 DOM을 통해 사용자에게 상태를 표시합니다. 예를 들어, 속성이 &quot;name&quot;인 구성 요소가 제공된 경우 해당 구성 요소의 템플리트는 여러 가지 방법으로 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="51813b0814adc6202a7752710fd028f16f5bf477" translate="yes" xml:space="preserve">
          <source>Test Helpers</source>
          <target state="translated">테스트 도우미</target>
        </trans-unit>
        <trans-unit id="aed406fa903d6e94bc7feee88a130462ff9783a9" translate="yes" xml:space="preserve">
          <source>Test visiting our About and Contact pages</source>
          <target state="translated">정보 및 연락처 페이지 방문 테스트</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">테스트 동작</target>
        </trans-unit>
        <trans-unit id="06b38cb08494d08dd0969ccda46c766ca333f501" translate="yes" xml:space="preserve">
          <source>Testing Components</source>
          <target state="translated">구성 요소 테스트</target>
        </trans-unit>
        <trans-unit id="111ae9c10175e16d69526c94a465e0225d9f1710" translate="yes" xml:space="preserve">
          <source>Testing Computed Properties</source>
          <target state="translated">계산 된 속성 테스트</target>
        </trans-unit>
        <trans-unit id="91816ac28cf876440112f405559c1a49b916b2f0" translate="yes" xml:space="preserve">
          <source>Testing Controller Actions</source>
          <target state="translated">컨트롤러 동작 테스트</target>
        </trans-unit>
        <trans-unit id="bbdb40de641b7bd903d12a3a7d8dcdf9f0d4da40" translate="yes" xml:space="preserve">
          <source>Testing Controller Needs</source>
          <target state="translated">컨트롤러 요구 사항 테스트</target>
        </trans-unit>
        <trans-unit id="a3634a65dd330502bee5446e899329476bf7ded2" translate="yes" xml:space="preserve">
          <source>Testing Controllers</source>
          <target state="translated">테스트 컨트롤러</target>
        </trans-unit>
        <trans-unit id="fcc10e5ab4dd75f9eb46dbd24ec0395685a9aa13" translate="yes" xml:space="preserve">
          <source>Testing Frameworks</source>
          <target state="translated">테스트 프레임 워크</target>
        </trans-unit>
        <trans-unit id="e309e778695eab20a3a8bc01dba2b39e99684bfe" translate="yes" xml:space="preserve">
          <source>Testing Helpers</source>
          <target state="translated">헬퍼 테스트</target>
        </trans-unit>
        <trans-unit id="f487e84bdaccef5eb28911d350ffc027190e112c" translate="yes" xml:space="preserve">
          <source>Testing Models</source>
          <target state="translated">테스트 모델</target>
        </trans-unit>
        <trans-unit id="82df70ae5a532aff7c33f9b6a39a13c4ceb157d6" translate="yes" xml:space="preserve">
          <source>Testing Object Methods</source>
          <target state="translated">테스트 객체 메소드</target>
        </trans-unit>
        <trans-unit id="10598855856ed90e10e02c787702f60e5e73921b" translate="yes" xml:space="preserve">
          <source>Testing Observers</source>
          <target state="translated">관찰자 테스트</target>
        </trans-unit>
        <trans-unit id="c2719b0d81b37187b81d8b3c83b30f393e2ac71c" translate="yes" xml:space="preserve">
          <source>Testing Our Application As We Go</source>
          <target state="translated">응용 프로그램 테스트</target>
        </trans-unit>
        <trans-unit id="a6c9220ff39e33f54e9415c82938ea24da9ff5cf" translate="yes" xml:space="preserve">
          <source>Testing Relationships</source>
          <target state="translated">테스트 관계</target>
        </trans-unit>
        <trans-unit id="3beda4357979b576777318de0cd80c86b2eba9a4" translate="yes" xml:space="preserve">
          <source>Testing Routes</source>
          <target state="translated">테스트 경로</target>
        </trans-unit>
        <trans-unit id="48d04cd7bff00c397a2449e46bae4e190877dce0" translate="yes" xml:space="preserve">
          <source>Testing User Interaction</source>
          <target state="translated">사용자 상호 작용 테스트</target>
        </trans-unit>
        <trans-unit id="627445291b103d97223f554921c6a4122db19397" translate="yes" xml:space="preserve">
          <source>Testing is a core part of the Ember framework and its development cycle.</source>
          <target state="translated">테스트는 Ember 프레임 워크와 개발주기의 핵심 부분입니다.</target>
        </trans-unit>
        <trans-unit id="9829d58d7519decb98a016ef2876759597109cbf" translate="yes" xml:space="preserve">
          <source>Testing routes can be done both via acceptance or unit tests. Acceptance tests will likely provide better coverage for routes because routes are typically used to perform transitions and load data, both of which are tested more easily in full context rather than isolation.</source>
          <target state="translated">테스트 경로는 승인 또는 단위 테스트를 통해 수행 할 수 있습니다. 일반적으로 경로는 전이 및로드 데이터를 수행하는 데 사용되므로 경로를 더 잘 커버 할 수 있습니다. 둘 다 격리보다는 전체 컨텍스트에서 더 쉽게 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="c06feb4db18fe22ca99f672e2f6701eab0410aae" translate="yes" xml:space="preserve">
          <source>Tests can also be executed when you are running a local development server (started by running &lt;code&gt;ember server&lt;/code&gt;), at the &lt;code&gt;/tests&lt;/code&gt; URI which renders the &lt;code&gt;tests/index.html&lt;/code&gt; template. A word of caution using this approach: Tests run using &lt;code&gt;ember server&lt;/code&gt; have the environment configuration &lt;code&gt;development&lt;/code&gt;, whereas tests executed under &lt;code&gt;ember test --server&lt;/code&gt; are run with the configuration &lt;code&gt;test&lt;/code&gt;. This could cause differences in execution, such as which libraries are loaded and available. Therefore its recommended that you use &lt;code&gt;ember test --server&lt;/code&gt; for test execution.</source>
          <target state="translated">&lt;code&gt;tests/index.html&lt;/code&gt; 템플릿 을 렌더링하는 &lt;code&gt;/tests&lt;/code&gt; URI 에서 로컬 개발 서버 ( &lt;code&gt;ember server&lt;/code&gt; 실행으로 시작)를 실행할 때 테스트를 실행할 수도 있습니다 . 이 접근 방식을 사용할 때주의 할 점 : &lt;code&gt;ember server&lt;/code&gt; 사용하여 실행되는 테스트 에는 환경 구성 &lt;code&gt;development&lt;/code&gt; 이 있고 &lt;code&gt;ember test --server&lt;/code&gt; 에서 실행 된 &lt;code&gt;test&lt;/code&gt; 는 구성 테스트 로 실행됩니다 . 로드되어 사용 가능한 라이브러리와 같은 실행에 차이가 발생할 수 있습니다. 따라서 테스트 실행에 &lt;code&gt;ember test --server&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="397b6080e414f58dca5e208b2d6e35210d1b3660" translate="yes" xml:space="preserve">
          <source>Text Areas</source>
          <target state="translated">텍스트 영역</target>
        </trans-unit>
        <trans-unit id="dc7b11db79436bd2c512f4d9967fc73904ef80da" translate="yes" xml:space="preserve">
          <source>Text field</source>
          <target state="translated">텍스트 필드</target>
        </trans-unit>
        <trans-unit id="f9168144e4f6dc56ba8e02f8cb5754a06a331b7a" translate="yes" xml:space="preserve">
          <source>Text fields</source>
          <target state="translated">텍스트 필드</target>
        </trans-unit>
        <trans-unit id="6803da9ee11ff492530f9c8867cacf0bf23256dc" translate="yes" xml:space="preserve">
          <source>TextArea</source>
          <target state="translated">TextArea</target>
        </trans-unit>
        <trans-unit id="ed595662ad10d27de0f2faece995e2ca2b8e7012" translate="yes" xml:space="preserve">
          <source>TextField</source>
          <target state="translated">TextField</target>
        </trans-unit>
        <trans-unit id="18d077a1a2979a8d6bce31e5dbe43320be8e25bf" translate="yes" xml:space="preserve">
          <source>TextField.max</source>
          <target state="translated">TextField.max</target>
        </trans-unit>
        <trans-unit id="5f0b052f28a0bd79ca6d930fe4c63eb5ecf68887" translate="yes" xml:space="preserve">
          <source>TextField.min</source>
          <target state="translated">TextField.min</target>
        </trans-unit>
        <trans-unit id="18e5d205fad575a252d1a26dc2fa9ef4f4a1b761" translate="yes" xml:space="preserve">
          <source>TextField.size</source>
          <target state="translated">TextField.size</target>
        </trans-unit>
        <trans-unit id="5c2de3d7d34ecad27d764569b0d805502a88a8e0" translate="yes" xml:space="preserve">
          <source>TextField.type</source>
          <target state="translated">TextField.type</target>
        </trans-unit>
        <trans-unit id="27df24da0e29d9bd616074b4f3101aac223ebbe7" translate="yes" xml:space="preserve">
          <source>TextSupport</source>
          <target state="translated">TextSupport</target>
        </trans-unit>
        <trans-unit id="b3412c92e9c7c36dbce60a4d0caa17409de5decd" translate="yes" xml:space="preserve">
          <source>Thanks to its use of the &lt;em&gt;adapter pattern&lt;/em&gt;, Ember Data can be configured to work with many different kinds of backends. There is &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;an entire ecosystem of adapters&lt;/a&gt; that allow your Ember app to talk to different types of servers without you writing any networking code.</source>
          <target state="translated">&lt;em&gt;어댑터 패턴을&lt;/em&gt; 사용하여 Ember Data는 다양한 종류의 백엔드에서 작동하도록 구성 할 수 있습니다. 이 &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;어댑터의 전체 생태계&lt;/a&gt; 당신의 엠버 애플 리케이션은 당신이 어떤 네트워킹 코드를 작성하지 않고 서버의 서로 다른 종류의 이야기를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="318520d5f37197c6df1e09018c18e851802ae7ae" translate="yes" xml:space="preserve">
          <source>That being said, sometimes it is important to unit test your routes. For example, let's say we'd like to have an alert that can be triggered from anywhere within our application. The alert function &lt;code&gt;displayAlert&lt;/code&gt; should be put into the &lt;code&gt;ApplicationRoute&lt;/code&gt; because all actions and events bubble up to it from sub-routes and controllers.</source>
          <target state="translated">그러나 때때로 경로를 단위 테스트하는 것이 중요합니다. 예를 들어, 애플리케이션 내 어디에서나 트리거 될 수있는 경고를 원한다고 가정 해 봅시다. 모든 조치 및 이벤트가 서브 라우트 및 컨트롤러에서 버블 링되므로 경보 기능 &lt;code&gt;displayAlert&lt;/code&gt; 를 &lt;code&gt;ApplicationRoute&lt;/code&gt; 에 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a36f83caf5ff2b93a1e4e5fcdc3584558ac63704" translate="yes" xml:space="preserve">
          <source>That default configuration matches the wider set of browsers that Ember.js itself supports. However, if your app does not need to support IE anymore, you can change it to:</source>
          <target state="translated">기본 구성은 Ember.js 자체가 지원하는 광범위한 브라우저와 일치합니다. 그러나 앱이 더 이상 IE를 지원할 필요가없는 경우 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c82a49b447f0a46a1e511a5df799dfb0834560f" translate="yes" xml:space="preserve">
          <source>That file should export a function wrapped with &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper.helper()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 파일은 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper.helper()&lt;/code&gt; &lt;/a&gt; 감싸 진 함수를 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b922bfea8e08f9290c3bf2fa6bff5f3b54ebd4c" translate="yes" xml:space="preserve">
          <source>That is Ember telling you that it has created:</source>
          <target state="translated">그것은 당신이 그것을 만들었다 고 말하는 Ember입니다.</target>
        </trans-unit>
        <trans-unit id="e0de9e3a4d4633aeeb18a289a56bd4805b9cfcbf" translate="yes" xml:space="preserve">
          <source>That is why Ember CLI exposes a way of configuring what browsers your app targets. It can figure out automatically what features are supported by the browsers you are targeting, and apply the minimum set of transformations possible to your code.</source>
          <target state="translated">그렇기 때문에 Ember CLI는 앱이 대상으로하는 브라우저를 구성하는 방법을 제공합니다. 대상으로하는 브라우저에서 지원하는 기능을 자동으로 파악하고 가능한 최소한의 변환 세트를 코드에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c3ec01be68e48073d9e918cf0f3b59651463160" translate="yes" xml:space="preserve">
          <source>That makes it easy to remember how to add an action to a component. It's like passing an attribute, but you use the &lt;code&gt;action&lt;/code&gt; helper to pass a function instead.</source>
          <target state="translated">따라서 구성 요소에 동작을 추가하는 방법을 쉽게 기억할 수 있습니다. 속성을 전달하는 것과 비슷하지만 &lt;code&gt;action&lt;/code&gt; 헬퍼를 사용하여 대신 함수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="78ba75708cf1770d1ec144b19670b70c95278a4c" translate="yes" xml:space="preserve">
          <source>That said, sometimes you may want to make behavior of helpers configurable by the developers that call them from their templates. For example, let's abandon our Americentric ways and update our &lt;code&gt;format-currency&lt;/code&gt; helper to take an optional configuration for which currency symbol to display.</source>
          <target state="translated">즉, 때로는 템플릿에서 호출하는 개발자가 도우미의 동작을 구성 할 수 있도록 할 수도 있습니다. 예를 들어, Americentric 방식을 포기하고 &lt;code&gt;format-currency&lt;/code&gt; 도우미를 업데이트 하여 통화 기호를 표시 할 선택적 구성을 선택해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d7606bb113640faa278cf7a28f2eb3e24d5170f8" translate="yes" xml:space="preserve">
          <source>That state is what the &lt;code&gt;ApplicationInstance&lt;/code&gt; manages: it is responsible for creating the container that contains all application state, and disposing of it once the particular test run or FastBoot request has finished.</source>
          <target state="translated">이 상태는 &lt;code&gt;ApplicationInstance&lt;/code&gt; 가 관리하는 것입니다. 모든 응용 프로그램 상태를 포함하는 컨테이너를 만들고 특정 테스트 실행 또는 FastBoot 요청이 완료되면 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e53c9021b9ec9d905f7edbfc8bee2fd601077a71" translate="yes" xml:space="preserve">
          <source>That way the generated URL will be deterministic and that simplifies caching mechanisms in the backend.</source>
          <target state="translated">이렇게하면 생성 된 URL이 결정적이고 백엔드의 캐싱 메커니즘이 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="cca06a831613fdc449a54b01a0421b8fde878db7" translate="yes" xml:space="preserve">
          <source>The &quot;this&quot; binding for the callback</source>
          <target state="translated">콜백에 대한 &quot;this&quot;바인딩</target>
        </trans-unit>
        <trans-unit id="ccc5b4bf89b158d0eb41c14adb3ba628e5e78e8e" translate="yes" xml:space="preserve">
          <source>The 'Whoops' error will be thrown on the next turn of the event loop and you can watch for it in your console. You can also handle it using a rejection handler given to &lt;code&gt;.then&lt;/code&gt; or &lt;code&gt;.catch&lt;/code&gt; on the returned promise.</source>
          <target state="translated">다음 번 이벤트 루프에서 '후프'오류가 발생하며 콘솔에서이를 확인할 수 있습니다. 반환 된 약속의 &lt;code&gt;.then&lt;/code&gt; 또는 &lt;code&gt;.catch&lt;/code&gt; 에 제공된 거부 처리기를 사용하여 처리 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12f898edea55f5f355fe5f02c909ee411cb027ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method of your Ember application's router can be invoked to define URL mappings. When calling &lt;code&gt;map()&lt;/code&gt;, you should pass a function that will be invoked with the value &lt;code&gt;this&lt;/code&gt; set to an object which you can use to create routes.</source>
          <target state="translated">Ember 애플리케이션 라우터 의 &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 URL 매핑을 정의 할 수 있습니다. 호출 할 때 &lt;code&gt;map()&lt;/code&gt; , 당신은 값으로 호출되는 함수 통과해야 &lt;code&gt;this&lt;/code&gt; 당신이 경로를 만드는 데 사용할 수있는 객체로 설정합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
