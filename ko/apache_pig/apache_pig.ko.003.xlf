<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="82d1fe3bf7eebd5b0f18fcd555e463dcb95e98bc" translate="yes" xml:space="preserve">
          <source>Run PigUnit</source>
          <target state="translated">PigUnit 실행</target>
        </trans-unit>
        <trans-unit id="7e3c7072ad99ff57afef64b3eb6c2d2576a6cd29" translate="yes" xml:space="preserve">
          <source>Run a Pig script.</source>
          <target state="translated">Pig 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f71ace1e5b5a08bf8c2f423348e38ee58674fe25" translate="yes" xml:space="preserve">
          <source>Run the &quot;ant&quot; command from the tutorial directory. This will create the pigtutorial.tar.gz file.</source>
          <target state="translated">학습서 디렉토리에서 &quot;ant&quot;명령을 실행하십시오. pigtutorial.tar.gz 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="651aaaa7461efce30026546ee5c3b80f07a47cbe" translate="yes" xml:space="preserve">
          <source>Running Pig</source>
          <target state="translated">달리기 돼지</target>
        </trans-unit>
        <trans-unit id="73ec691cbfc0d91259e94552dcfda7e37457aea6" translate="yes" xml:space="preserve">
          <source>Running jobs on a Kerberos secured cluster</source>
          <target state="translated">Kerberos 보안 클러스터에서 작업 실행</target>
        </trans-unit>
        <trans-unit id="5216ae758a212d13b302cef1178778364c929a02" translate="yes" xml:space="preserve">
          <source>Running the Pig Scripts in Local Mode</source>
          <target state="translated">로컬 모드에서 Pig 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="8019bd48c1161a4a76cc79fc40731da99440377f" translate="yes" xml:space="preserve">
          <source>Running the Pig Scripts in Mapreduce Mode, Tez Mode or Spark Mode</source>
          <target state="translated">Mapreduce 모드, Tez 모드 또는 Spark 모드에서 Pig 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="05993e69c1712b1a21928277c8abfdc2ae39c214" translate="yes" xml:space="preserve">
          <source>SAMPLE</source>
          <target state="translated">SAMPLE</target>
        </trans-unit>
        <trans-unit id="202fac504ab5702893a768e9f140056950033d7d" translate="yes" xml:space="preserve">
          <source>SAMPLE alias size;</source>
          <target state="translated">샘플 별명 크기;</target>
        </trans-unit>
        <trans-unit id="7f265f77805f54860024c03db1c4d922768aa6dc" translate="yes" xml:space="preserve">
          <source>SHIP &amp;ndash; Keyword.</source>
          <target state="translated">선박 &amp;ndash; 키워드.</target>
        </trans-unit>
        <trans-unit id="d322cc469e85c011918d45a9e571d9b40486ee1f" translate="yes" xml:space="preserve">
          <source>SHIP('path' [, 'path' &amp;hellip;])</source>
          <target state="translated">SHIP ( '경로'[, '경로'&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="426d5f22eda911f8263247034576021bb6ad8875" translate="yes" xml:space="preserve">
          <source>SIN</source>
          <target state="translated">SIN</target>
        </trans-unit>
        <trans-unit id="4939014590070cb4aa6b7c0d56879f477a11acf4" translate="yes" xml:space="preserve">
          <source>SIN(expression)</source>
          <target state="translated">SIN(expression)</target>
        </trans-unit>
        <trans-unit id="10b524cf2ec5b43d2d9c4196276c867c052adfb1" translate="yes" xml:space="preserve">
          <source>SINH</source>
          <target state="translated">SINH</target>
        </trans-unit>
        <trans-unit id="e832dae866f83107f5cf147952c01e5c76cf4d48" translate="yes" xml:space="preserve">
          <source>SINH(expression)</source>
          <target state="translated">SINH(expression)</target>
        </trans-unit>
        <trans-unit id="88087292ed82e26f3eb824d0bffc05ccf7a30f8d" translate="yes" xml:space="preserve">
          <source>SIZE</source>
          <target state="translated">SIZE</target>
        </trans-unit>
        <trans-unit id="224ca7917218851f2e19cb690c669c2361d35d14" translate="yes" xml:space="preserve">
          <source>SIZE(expression)</source>
          <target state="translated">SIZE(expression)</target>
        </trans-unit>
        <trans-unit id="6df63cad9f75b5c64b7535d25c4ff47f6a51cc0d" translate="yes" xml:space="preserve">
          <source>SPLIT</source>
          <target state="translated">SPLIT</target>
        </trans-unit>
        <trans-unit id="10a7ef355f06e753d5db291a06420c4dc9d5a2e0" translate="yes" xml:space="preserve">
          <source>SPLIT alias INTO alias IF expression, alias IF expression [, alias IF expression &amp;hellip;] [, alias OTHERWISE];</source>
          <target state="translated">SPLIT alias INTO alias IF 표현식, alias IF 표현식 [, alias IF expression&amp;hellip;] [, alias OTHERWISE];</target>
        </trans-unit>
        <trans-unit id="7d3ef90f7bdad2ebf999d6a70b25d3a0f93a0987" translate="yes" xml:space="preserve">
          <source>SPRINTF</source>
          <target state="translated">SPRINTF</target>
        </trans-unit>
        <trans-unit id="6e19efae54188b7938aff7330ae91a2609bc6357" translate="yes" xml:space="preserve">
          <source>SPRINTF(format, [...vals])</source>
          <target state="translated">SPRINTF (형식, [... vals])</target>
        </trans-unit>
        <trans-unit id="6f3cd171d7836f21592747112410c0f0a5af46df" translate="yes" xml:space="preserve">
          <source>SPRINTF(format, arg1, arg2)</source>
          <target state="translated">SPRINTF (형식, arg1, arg2)</target>
        </trans-unit>
        <trans-unit id="eab53bbffdddccb2bf627f0887e6340bf2205493" translate="yes" xml:space="preserve">
          <source>SQRT</source>
          <target state="translated">SQRT</target>
        </trans-unit>
        <trans-unit id="1c97e577e8db73275c73a2330aeae438e9bd39d4" translate="yes" xml:space="preserve">
          <source>SQRT(expression)</source>
          <target state="translated">SQRT(expression)</target>
        </trans-unit>
        <trans-unit id="948266873e8793de3fd09264b5b7d3718152d722" translate="yes" xml:space="preserve">
          <source>STARTSWITH</source>
          <target state="translated">STARTSWITH</target>
        </trans-unit>
        <trans-unit id="0679c4c22d9bc4d2bca31c41f3ed3e7532906234" translate="yes" xml:space="preserve">
          <source>STARTSWITH(string, testAgainst)</source>
          <target state="translated">STARTSWITH (문자열, testAgainst)</target>
        </trans-unit>
        <trans-unit id="8371f7257be48c6e014fea224159af7aca0d2b88" translate="yes" xml:space="preserve">
          <source>STDERR( '/dir') or STDERR( '/dir' LIMIT n)</source>
          <target state="translated">STDERR ( '/ dir') 또는 STDERR ( '/ dir'LIMIT n)</target>
        </trans-unit>
        <trans-unit id="a022ae64c8eb7a7a35f61b709cfc684caa33ef3b" translate="yes" xml:space="preserve">
          <source>STORE</source>
          <target state="translated">STORE</target>
        </trans-unit>
        <trans-unit id="7aee0401e0aa34417245141776e1242886e013b1" translate="yes" xml:space="preserve">
          <source>STORE ... INTO ... USING</source>
          <target state="translated">저장 ... 안으로 ... 사용</target>
        </trans-unit>
        <trans-unit id="e45107ecf526d7a34cdf9b78543b9ab3f832f471" translate="yes" xml:space="preserve">
          <source>STORE Example: In this script, multi-query optimization will kick in allowing the entire script to be executed as a single job. Two outputs are produced: output1 and output2.</source>
          <target state="translated">저장 예 :이 스크립트에서 다중 쿼리 최적화는 전체 스크립트를 단일 작업으로 실행할 수 있도록합니다. 출력 1과 출력 2의 두 가지 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b87a2e11099d784d9d2b033b49f3b24894a3bfe1" translate="yes" xml:space="preserve">
          <source>STORE alias INTO 'directory' [USING function];</source>
          <target state="translated">STORE alias INTO 'directory'[사용 ​​기능];</target>
        </trans-unit>
        <trans-unit id="8b75f9eaed833ee9f304e618ddeffbecd06e685b" translate="yes" xml:space="preserve">
          <source>STREAM</source>
          <target state="translated">STREAM</target>
        </trans-unit>
        <trans-unit id="905d0a2c3b88187d109419f2afd0bf30043ac29c" translate="yes" xml:space="preserve">
          <source>STRSPLIT</source>
          <target state="translated">STRSPLIT</target>
        </trans-unit>
        <trans-unit id="42b824480d91edb5db5b3d6f1672aefa1ee2a688" translate="yes" xml:space="preserve">
          <source>STRSPLIT(string, regex, limit)</source>
          <target state="translated">STRSPLIT (문자열, 정규식, 한도)</target>
        </trans-unit>
        <trans-unit id="dcb420c797088af8e80537b9533b04c9ea834baf" translate="yes" xml:space="preserve">
          <source>STRSPLITTOBAG</source>
          <target state="translated">STRSPLITTOBAG</target>
        </trans-unit>
        <trans-unit id="4de10aefaaf83e2a2787c715b9f47859c082b50b" translate="yes" xml:space="preserve">
          <source>STRSPLITTOBAG(string, regex, limit)</source>
          <target state="translated">STRSPLITTOBAG (문자열, 정규식, 한도)</target>
        </trans-unit>
        <trans-unit id="2c721d8972a270242da1001e20ea137baece96b8" translate="yes" xml:space="preserve">
          <source>SUBSTRING</source>
          <target state="translated">SUBSTRING</target>
        </trans-unit>
        <trans-unit id="4fba3652303052336dc220cbda36622eb06c11ed" translate="yes" xml:space="preserve">
          <source>SUBSTRING(string, startIndex, stopIndex)</source>
          <target state="translated">SUBSTRING (문자열, startIndex, stopIndex)</target>
        </trans-unit>
        <trans-unit id="894b0ca72aae665c6b2e70f028bacad101c466f9" translate="yes" xml:space="preserve">
          <source>SUBTRACT</source>
          <target state="translated">SUBTRACT</target>
        </trans-unit>
        <trans-unit id="f10d69b42543aed5e2bafdbd4902e439f2e1aa28" translate="yes" xml:space="preserve">
          <source>SUBTRACT takes two bags as arguments and returns a new bag composed of the tuples of first bag are not in the second bag.</source>
          <target state="translated">SUBTRACT는 두 개의 백을 인수로 사용하여 첫 번째 백의 튜플이 두 번째 백에없는 새 백을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b20a95c5c811912bbc8c5ac7f5051d91cc4c1aa" translate="yes" xml:space="preserve">
          <source>SUBTRACT(expression, expression)</source>
          <target state="translated">SUBTRACT (표현, 표현)</target>
        </trans-unit>
        <trans-unit id="2c798885ebfbe383227dbd5c2205277f8af9d524" translate="yes" xml:space="preserve">
          <source>SUM</source>
          <target state="translated">SUM</target>
        </trans-unit>
        <trans-unit id="cee4eb7e8a48c4928bcb1fd03be9ec832e71f51e" translate="yes" xml:space="preserve">
          <source>SUM(expression)</source>
          <target state="translated">SUM(expression)</target>
        </trans-unit>
        <trans-unit id="2ea80ea6c28ace76a4d41d7ca76fdc291a793b1b" translate="yes" xml:space="preserve">
          <source>Same example as previous, but DENSE. In this case there are no gaps in ranking values.</source>
          <target state="translated">이전과 동일하지만 DENSE입니다. 이 경우 순위 값에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddf81f11bb9b310f6cd4c26f2ff11bd25220f60b" translate="yes" xml:space="preserve">
          <source>Sample Schema String - words:{(word:chararray)}, variable names inside a schema string are not used anywhere, they just make the syntax identifiable to the parser.</source>
          <target state="translated">샘플 스키마 문자열-words : {(word : chararray)}, 스키마 문자열 내부의 변수 이름은 어디에도 사용되지 않으며 구문 분석기가 구문을 식별 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="bf1d05d71f129425403f1bff44f3e1f9b92c4c31" translate="yes" xml:space="preserve">
          <source>Sample Schema String - y:{t:(word:chararray,num:long)}</source>
          <target state="translated">샘플 스키마 문자열-y : {t : (word : chararray, num : long)}</target>
        </trans-unit>
        <trans-unit id="3defea31e210f4a2999334b40982c92ad6aad70f" translate="yes" xml:space="preserve">
          <source>Sample Schema String - y:{t:(word:chararray,num:long)}, variable names inside a schema string are not used anywhere, they just make the syntax identifiable to the parser.</source>
          <target state="translated">샘플 스키마 문자열-y : {t : (word : chararray, num : long)}, 스키마 문자열 내부의 변수 이름은 어디에도 사용되지 않으며 구문 분석기가 구문을 식별 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="16c4a93542dfa1ce6ebd265a7bb35938b249e08b" translate="yes" xml:space="preserve">
          <source>Sample size, either</source>
          <target state="translated">샘플 크기</target>
        </trans-unit>
        <trans-unit id="0ca06b1d267adeb7398249bb0992d00f72144de4" translate="yes" xml:space="preserve">
          <source>Sample:</source>
          <target state="translated">Sample:</target>
        </trans-unit>
        <trans-unit id="1357102af3dcd88d515afe30428314e7304f7efc" translate="yes" xml:space="preserve">
          <source>Schema function</source>
          <target state="translated">스키마 함수</target>
        </trans-unit>
        <trans-unit id="db77ed065e4e0ae24d5474707494552cb72cf711" translate="yes" xml:space="preserve">
          <source>Schemas</source>
          <target state="translated">Schemas</target>
        </trans-unit>
        <trans-unit id="796f21935de3e6accae5ef0a2c9b6f9e808ee9d8" translate="yes" xml:space="preserve">
          <source>Schemas and Java UDFs</source>
          <target state="translated">스키마 및 Java UDF</target>
        </trans-unit>
        <trans-unit id="4d8d51f91b52825c1aa5a8b3d1a090681c3f6b0c" translate="yes" xml:space="preserve">
          <source>Schemas are defined with the &lt;a href=&quot;#load&quot;&gt;LOAD&lt;/a&gt;, &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt;, and &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt; operators using the AS clause. If you define a schema using the LOAD operator, then it is the load function that enforces the schema (see &lt;a href=&quot;#load&quot;&gt;LOAD&lt;/a&gt; and &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt; for more information).</source>
          <target state="translated">스키마는 AS 절을 사용하여 &lt;a href=&quot;#load&quot;&gt;LOAD&lt;/a&gt; , &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; 및 &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt; 연산자 로 정의됩니다 . LOAD 연산자를 사용하여 스키마를 정의하면 스키마를 강제하는로드 함수입니다 ( 자세한 정보는 &lt;a href=&quot;#load&quot;&gt;LOAD&lt;/a&gt; 및 &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="55720ed9357106916f856d1efa9ae48ac58bf31c" translate="yes" xml:space="preserve">
          <source>Schemas enable you to assign names to fields and declare types for fields. Schemas are optional but we encourage you to use them whenever possible; type declarations result in better parse-time error checking and more efficient code execution.</source>
          <target state="translated">스키마를 사용하면 필드에 이름을 지정하고 필드 유형을 선언 할 수 있습니다. 스키마는 선택 사항이지만 가능할 때마다 사용하는 것이 좋습니다. 형식 선언을 사용하면 구문 분석 시간 오류 확인 기능이 향상되고 코드 실행 효율이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="281d35eb654b2a6b3ef3d06b95bbbe7ebdbd63dd" translate="yes" xml:space="preserve">
          <source>Schemas for &lt;a href=&quot;#schema-simple&quot;&gt;simple types&lt;/a&gt; and &lt;a href=&quot;#schema-complex&quot;&gt;complex types&lt;/a&gt; can be used anywhere a schema definition is appropriate.</source>
          <target state="translated">대한 스키마 &lt;a href=&quot;#schema-simple&quot;&gt;단순 유형&lt;/a&gt; 및 &lt;a href=&quot;#schema-complex&quot;&gt;복합 유형은&lt;/a&gt; 스키마 정의가 적절 어디서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f524a3f6b0cf68d0124e8c98e06ad4df066d63" translate="yes" xml:space="preserve">
          <source>Schemas for Complex Data Types</source>
          <target state="translated">복잡한 데이터 형식에 대한 스키마</target>
        </trans-unit>
        <trans-unit id="f31208bcfa58c81613629847852c5b5ae582e595" translate="yes" xml:space="preserve">
          <source>Schemas for Multiple Types</source>
          <target state="translated">여러 유형의 스키마</target>
        </trans-unit>
        <trans-unit id="a3fd568d52854ba8942627e36d2ff6998184b009" translate="yes" xml:space="preserve">
          <source>Schemas for Simple Data Types</source>
          <target state="translated">간단한 데이터 형식에 대한 스키마</target>
        </trans-unit>
        <trans-unit id="e8fc1d110a9bd49d86be041489bbb3d0817708c9" translate="yes" xml:space="preserve">
          <source>Schemas with FOREACH</source>
          <target state="translated">FOREACH를 가진 스키마</target>
        </trans-unit>
        <trans-unit id="305e5823150902f9abbcadc5ce3ce74d3808f60f" translate="yes" xml:space="preserve">
          <source>Schemas with LOAD and STREAM</source>
          <target state="translated">LOAD 및 STREAM이있는 스키마</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="42d9f9531156cbb626c8166a64eb34909cf93f48" translate="yes" xml:space="preserve">
          <source>Scope of the parameters is global except when used with run/exec command. Caller would not see the parameters declared within the callee's scripts. See &lt;a href=&quot;#Parameter-Sub-scope-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">run / exec 명령과 함께 사용되는 경우를 제외하고 매개 변수의 범위는 전역입니다. 발신자는 수신자의 스크립트 내에 선언 된 매개 변수를 볼 수 없습니다. 자세한 내용은 &lt;a href=&quot;#Parameter-Sub-scope-example&quot;&gt;예&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0e7b2af2fae325fa163cc668721ab1cb0d743d5" translate="yes" xml:space="preserve">
          <source>Scoping with run/exec commands</source>
          <target state="translated">실행 / 실행 명령으로 범위 지정</target>
        </trans-unit>
        <trans-unit id="4c227e97f7d341e3a0998469d99e6046c49558be" translate="yes" xml:space="preserve">
          <source>ScoreGenerator</source>
          <target state="translated">ScoreGenerator</target>
        </trans-unit>
        <trans-unit id="fc35fb6940f4893cbb538c987a1140a41fcba3eb" translate="yes" xml:space="preserve">
          <source>Second Field</source>
          <target state="translated">두 번째 필드</target>
        </trans-unit>
        <trans-unit id="f294a637ad8be0a5cde94d0e51892774e0844f5b" translate="yes" xml:space="preserve">
          <source>Second, Pig returns different code upon completion for these scenarios:</source>
          <target state="translated">둘째, Pig는 다음 시나리오에서 완료시 다른 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02d5963d25492ba64d8dacb0a39d0d7951403082" translate="yes" xml:space="preserve">
          <source>Second, it allows UDFs to pass configuration information between instantiations of the UDF on the front and backends. UDFs can store information in a configuration object when they are constructed on the front end, or during other front end calls such as checkSchema. They can then read that information on the backend when exec (for EvalFunc) or getNext (for LoadFunc) is called. Note that information will not be passed between instantiations of the function on the backend. The communication channel only works from front end to back end.</source>
          <target state="translated">둘째, UDF가 프론트 엔드와 백엔드에서 UDF 인스턴스화간에 구성 정보를 전달할 수 있습니다. UDF는 프론트 엔드에서 구성되거나 checkSchema와 같은 다른 프론트 엔드 호출 중에 구성 오브젝트에 정보를 저장할 수 있습니다. 그런 다음 exec (EvalFunc) 또는 getNext (LoadFunc)가 호출 될 때 백엔드에서 해당 정보를 읽을 수 있습니다. 백엔드에서 함수의 인스턴스화간에 정보가 전달되지 않습니다. 통신 채널은 프런트 엔드에서 백 엔드로만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a5ba104e2bd46dc7f5eab438cad7a6ff9db9e226" translate="yes" xml:space="preserve">
          <source>SecondsBetween</source>
          <target state="translated">SecondsBetween</target>
        </trans-unit>
        <trans-unit id="e771628cce693ff2b4e9ce5ea451bbc371ec37fe" translate="yes" xml:space="preserve">
          <source>SecondsBetween(datetime1, datetime2)</source>
          <target state="translated">초 사이 (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="b76935f452bdf46d45453496640605cff4a9dc9e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#case-sensitivity&quot;&gt;Case Sensitivity&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#case-sensitivity&quot;&gt;대소 문자 구분&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="9d571a92befcfe78e7e7c19f3aad4e959f60c315" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#schemas&quot;&gt;Schemas&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#schemas&quot;&gt;스키마&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="675e72c9f94caa35be80b92b4855b7dd302a82f5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;basic#load&quot;&gt;LOAD&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic#load&quot;&gt;LOAD&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="a4e4132218f9c486aad985a237dda3238bdd6007" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;basic#store&quot;&gt;STORE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic#store&quot;&gt;상점&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="282a8e0e29caa09873f7234f18d77419e99f2a01" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;Parameter Substitution&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cont#Parameter-Sub&quot;&gt;매개 변수 대체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7319b0942abec957a84ee7646c16cb99cac74e53" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;cont#import-macros&quot;&gt;IMPORT (macros)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cont#import-macros&quot;&gt;IMPORT (매크로)&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="3cf293de3dccb8e18611d71d328317eafcc35003" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://avro.apache.org/docs/current/spec.html&quot;&gt; the Apache Avro Documentation&lt;/a&gt; for more details on how to specify a valid schema.</source>
          <target state="translated">참조 &lt;a href=&quot;http://avro.apache.org/docs/current/spec.html&quot;&gt;아파치 아 브로 문서&lt;/a&gt; 유효한 스키마를 지정하는 방법에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="ed56700e27751f5b613c5dc7bc2b2705f2751f3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;Bloom Filter&lt;/a&gt; for a discussion of how to select the number of bits and the number of hash functions.</source>
          <target state="translated">비트 수와 해시 함수 수를 선택하는 방법에 대한 설명은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;블룸 필터&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cd2d608a7db17f1b4e40a09c1d3992b4fdae9df" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (macros)&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (매크로)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c300929f409388b39a2ba8f402ade27dac68b4d1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;basic#bag&quot;&gt;Bag&lt;/a&gt; data type and &lt;a href=&quot;basic#type-construction&quot;&gt;Type Construction Operators&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;basic#bag&quot;&gt;백&lt;/a&gt; 데이터 유형 및 &lt;a href=&quot;basic#type-construction&quot;&gt;유형 구성 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49d2404713a2d9dcb4eb64a3c55944aa1245a391" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;basic#map&quot;&gt;Map&lt;/a&gt; data type and &lt;a href=&quot;basic#type-construction&quot;&gt;Type Construction Operators&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;basic#map&quot;&gt;지도&lt;/a&gt; 데이터 유형 및 &lt;a href=&quot;basic#type-construction&quot;&gt;유형 구성 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81c05107fe0ba3b999afcaf77b3784e62d6d0909" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;basic#tuple&quot;&gt;Tuple&lt;/a&gt; data type and &lt;a href=&quot;basic#type-construction&quot;&gt;Type Construction Operators&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;basic#tuple&quot;&gt;튜플&lt;/a&gt; 데이터 형식 및 &lt;a href=&quot;basic#type-construction&quot;&gt;형식 구성 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1945af922aee51df1d4536831ee44148cc332f8" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28bc6e00420dc39ccc234985c20889a2f5080e8b" translate="yes" xml:space="preserve">
          <source>See the examples below. If a field's data type is not specified, Pig will use bytearray to denote an unknown type. If the number of fields is not known, Pig will derive an unknown schema.</source>
          <target state="translated">아래 예를 참조하십시오. 필드의 데이터 유형을 지정하지 않으면 Pig는 바이트 배열을 사용하여 알 수없는 유형을 나타냅니다. 필드 수를 알 수 없으면 Pig는 알 수없는 스키마를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="497dea2253a9763272c1d3ca91776ece14a847f1" translate="yes" xml:space="preserve">
          <source>See:</source>
          <target state="translated">See:</target>
        </trans-unit>
        <trans-unit id="46b24143f8f15477976066d011e8c9374637295e" translate="yes" xml:space="preserve">
          <source>Selects a random sample of data based on the specified sample size.</source>
          <target state="translated">지정된 샘플 크기를 기준으로 무작위 데이터 샘플을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="265e9040bb5fd6acdafb6e314482ba345e45c24d" translate="yes" xml:space="preserve">
          <source>Selects tuples from a relation based on some condition.</source>
          <target state="translated">조건에 따라 관계에서 튜플을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f0e0d470b10492a6a6e5f946d4bb8e8f294291c2" translate="yes" xml:space="preserve">
          <source>Sends an error message when the second script is executed: &quot;ERROR 1118: Cannot cast bytes loaded from BinStorage. Please provide a custom converter.&quot;</source>
          <target state="translated">두 번째 스크립트가 실행될 때 오류 메시지를 보냅니다. &quot;오류 1118 : BinStorage에서로드 된 바이트를 캐스팅 할 수 없습니다. 사용자 정의 변환기를 제공하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="6c3d0db4106188a753a193803e62901618772e89" translate="yes" xml:space="preserve">
          <source>Sends data to an external script or program.</source>
          <target state="translated">외부 스크립트 나 프로그램으로 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6e805bfcfc4391697043ec5049e526eef7d42719" translate="yes" xml:space="preserve">
          <source>Serialization is needed to convert data from tuples to a format that can be processed by the streaming application. Deserialization is needed to convert the output from the streaming application back into tuples. PigStreaming is the default serialization/deserialization function.</source>
          <target state="translated">데이터를 튜플에서 스트리밍 응용 프로그램이 처리 할 수있는 형식으로 변환하려면 직렬화가 필요합니다. 스트리밍 응용 프로그램의 출력을 다시 튜플로 변환하려면 역 직렬화가 필요합니다. PigStreaming은 기본 직렬화 / 직렬화 기능입니다.</target>
        </trans-unit>
        <trans-unit id="069e27b49fda52d216382ba7e9ab1799f36e1713" translate="yes" xml:space="preserve">
          <source>Set &quot;pig.blacklist&quot; to a comma-delimited set of operators and commands. For eg, &lt;strong&gt;pig.blacklist=rm,kill,cross&lt;/strong&gt; would disable users from executing any of &quot;rm&quot;, &quot;kill&quot; commands and &quot;cross&quot; operator.</source>
          <target state="translated">&quot;pig.blacklist&quot;를 쉼표로 구분 된 연산자 및 명령 세트로 설정하십시오. 예를 들어 &lt;strong&gt;pig.blacklist = rm, kill, cross&lt;/strong&gt; 는 사용자가 &quot;rm&quot;, &quot;kill&quot;명령 및 &quot;cross&quot;연산자를 실행하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="dc941abb1b2c83b7f01645e8e80fa8251fb5bfa3" translate="yes" xml:space="preserve">
          <source>Set the HADOOP_CONF_DIR environment variable to the location of the cluster configuration directory:</source>
          <target state="translated">HADOOP_CONF_DIR 환경 변수를 클러스터 구성 디렉토리의 위치로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9796fe5d55d7853b9743a633850cbef58d8847fa" translate="yes" xml:space="preserve">
          <source>Set the PIG_CLASSPATH environment variable to the location of the cluster configuration directory (the directory that contains the core-site.xml, hdfs-site.xml and mapred-site.xml files):</source>
          <target state="translated">PIG_CLASSPATH 환경 변수를 클러스터 구성 디렉토리 (core-site.xml, hdfs-site.xml 및 mapred-site.xml 파일을 포함하는 디렉토리)의 위치로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9585e2a7adfd9963a4bda498493d1300bfd503f8" translate="yes" xml:space="preserve">
          <source>Set the PIG_HOME environment variable:</source>
          <target state="translated">PIG_HOME 환경 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4169c6ec662e4cc9cfec946bbf9d67b6238b3c92" translate="yes" xml:space="preserve">
          <source>Set the following properties (either via the .pigrc file or on the command line via -P file)</source>
          <target state="translated">.pigrc 파일을 통해 또는 -P 파일을 통해 명령 행에서 다음 특성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="27e7130484e79b1db6775793248b312a94df3587" translate="yes" xml:space="preserve">
          <source>Sets the number of reducers for all MapReduce jobs generated by Pig (see &lt;a href=&quot;perf#parallel&quot;&gt;Use the Parallel Features&lt;/a&gt;).</source>
          <target state="translated">Pig가 생성 한 모든 MapReduce 작업에 대한 감속기 수를 설정합니다 ( &lt;a href=&quot;perf#parallel&quot;&gt;병렬 기능 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7ff69afb7aee18b05f20de205f7f39d0a5bd5ac9" translate="yes" xml:space="preserve">
          <source>Sets the priority of a Pig job.</source>
          <target state="translated">Pig 작업의 우선 순위를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="18156d399ff60482696dfecbfd7f1a4b845611a7" translate="yes" xml:space="preserve">
          <source>Sets user-specified name for the job</source>
          <target state="translated">작업의 사용자 지정 이름을 설정합니다</target>
        </trans-unit>
        <trans-unit id="4df3275ea75a66bc7b4ca5d7660999342e32eebb" translate="yes" xml:space="preserve">
          <source>Setting up a test for this script is easy because the argument and the input data are specified by two text arrays. It is the same for the expected output of the script that will be compared to the actual result of the execution of the Pig script.</source>
          <target state="translated">인수와 입력 데이터가 두 개의 텍스트 배열로 지정되므로이 스크립트에 대한 테스트 설정이 쉽습니다. Pig 스크립트 실행의 실제 결과와 비교할 스크립트의 예상 출력과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9b8a17b60beef7e31b830caf3b4fa7a5fa8dad7a" translate="yes" xml:space="preserve">
          <source>Several new public classes make it easier for external tools such as Oozie to integrate with Pig statistics.</source>
          <target state="translated">몇 가지 새로운 공개 클래스를 통해 Oozie와 같은 외부 도구를 Pig 통계와 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d91c0e9c2e10b3624ca467a6cfec024511dd3e" translate="yes" xml:space="preserve">
          <source>Shell Commands</source>
          <target state="translated">쉘 명령</target>
        </trans-unit>
        <trans-unit id="64bfc6109ead989aad1b6f231c28d1b24bfb867f" translate="yes" xml:space="preserve">
          <source>Shell and Utility Commands</source>
          <target state="translated">쉘 및 유틸리티 명령</target>
        </trans-unit>
        <trans-unit id="1fa7a9327af596bedec1882ca6115525e63cae36" translate="yes" xml:space="preserve">
          <source>Shipping files to relative paths or absolute paths is not supported since you might not have permission to read/write/execute from arbitrary paths on the clusters.</source>
          <target state="translated">클러스터의 임의 경로에서 읽기 / 쓰기 / 실행 권한이 없을 수 있으므로 상대 경로 또는 절대 경로로 파일을 전달하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd7e2505db28c95031bbe2b0b2f000301131352f" translate="yes" xml:space="preserve">
          <source>Shipping files to relative paths or absolute paths is undefined and mostly will fail since you may not have permissions to read/write/execute from arbitraty paths on the actual clusters.</source>
          <target state="translated">상대 경로 또는 절대 경로로 파일을 전달하는 것은 정의되어 있지 않으며 실제 클러스터의 임의 경로에서 읽기 / 쓰기 / 실행 권한이 없을 수 있기 때문에 대부분 실패합니다.</target>
        </trans-unit>
        <trans-unit id="979aec4f0038fd154155b5afeb73500d058dbf14" translate="yes" xml:space="preserve">
          <source>Short lived jobs</source>
          <target state="translated">단명 한 직업</target>
        </trans-unit>
        <trans-unit id="3ff0993e31d7971a1df63e3a281487aebccdb382" translate="yes" xml:space="preserve">
          <source>Shows/Assigns values to keys used in Pig.</source>
          <target state="translated">Pig에 사용 된 키에 값을 표시 / 할당합니다.</target>
        </trans-unit>
        <trans-unit id="f477ca07697317e50fcae1ea56190c92128ba337" translate="yes" xml:space="preserve">
          <source>Sign Operators</source>
          <target state="translated">부호 연산자</target>
        </trans-unit>
        <trans-unit id="8eb96aab1a4ac68d77491628831d6eb1a629e40f" translate="yes" xml:space="preserve">
          <source>Signed 32-bit integer</source>
          <target state="translated">부호있는 32 비트 정수</target>
        </trans-unit>
        <trans-unit id="82614be0e5d3713491b1ecaa3f5ff2c9ecb53c7c" translate="yes" xml:space="preserve">
          <source>Signed 64-bit integer</source>
          <target state="translated">부호있는 64 비트 정수</target>
        </trans-unit>
        <trans-unit id="7244c8641e12a1bd6d09463d966a3fe3402eab3f" translate="yes" xml:space="preserve">
          <source>Similar to regular Pig parameter substitution, you can define parameters using -param/&amp;ndash;param_file on Pig's command line. This variable will be treated as one of the binding variables when binding the Pig Latin script. For example, you can invoke the below Python script using: pig &amp;ndash;param loadfile=student.txt script.py.</source>
          <target state="translated">일반적인 Pig 매개 변수 대체와 유사하게 Pig 명령 행에서 -param / &amp;ndash;param_file을 사용하여 매개 변수를 정의 할 수 있습니다. 이 변수는 Pig Latin 스크립트를 바인딩 할 때 바인딩 변수 중 하나로 취급됩니다. 예를 들어 pig &amp;ndash;param loadfile = student.txt script.py를 사용하여 아래 Python 스크립트를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ff1a7f75b85e6341938ab3c697c363a7090107" translate="yes" xml:space="preserve">
          <source>Similarly, Accumulator UDFs are declared using the three annotations @AccumulatorAccumulate, @AccumulatorGetValue and @AccumulatorCleanup which are to annotate methods that correspond to the methods accumulate, getValue and cleanup of a Java Accumulator UDF. Those annotations have a single parameter which is the name of the Accumulator UDF that will be available in Pig. The methods annotated with @AccumulatorAccumulate and @AccumulatorCleanup return void. The methods annotated with @AccumulatorGetValue and @AccumulatorCleanup take no parameters. The method annotated with @AccumulatorAccumulate takes a Tuple as parameter. The return schema of the Accumulator UDF is determined by the @OutputSchema or @OutputSchemaFunction annotation used on the method annotated with @AccumulatorGetValue. Note that even though a method annotated with @AccumulatorGetValue has an @OutputSchema or @OutputSchemaFunction annotation, it will not be available in Pig, only the Accumulator UDF to which it belongs will.</source>
          <target state="translated">마찬가지로 Accumulator UDF는 Java Accumulator UDF의 누적, getValue 및 정리 메소드에 해당하는 메소드에 주석을 달기위한 @AccumulatorAccumulate, @AccumulatorGetValue 및 @AccumulatorCleanup의 세 가지 어노테이션을 사용하여 선언됩니다. 이러한 주석에는 Pig에서 사용할 수있는 Accumulator UDF의 이름 인 단일 매개 변수가 있습니다. @AccumulatorAccumulate 및 @AccumulatorCleanup으로 주석이 달린 메소드는 void를 반환합니다. @AccumulatorGetValue 및 @AccumulatorCleanup으로 주석이 달린 메소드에는 매개 변수가 없습니다. @AccumulatorAccumulate로 주석이 달린 메소드는 Tuple을 매개 변수로 사용합니다. Accumulator UDF의 리턴 스키마는 @AccumulatorGetValue로 어노테이션이있는 메소드에 사용 된 @OutputSchema 또는 @OutputSchemaFunction 어노테이션에 의해 결정됩니다.@AccumulatorGetValue로 어노테이션이있는 메소드에 @OutputSchema 또는 @OutputSchemaFunction 어노테이션이 있지만 Pig에서는 사용할 수 없으며 해당 어큐뮬레이터 UDF 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcb18f4c67a1e36dac1b401bbdb3fe8f4c3e132" translate="yes" xml:space="preserve">
          <source>Simple and Complex</source>
          <target state="translated">간단하고 복잡한</target>
        </trans-unit>
        <trans-unit id="406ea3116aad1c0ccad5a9f4da3320c4da82846e" translate="yes" xml:space="preserve">
          <source>Simple data types include int, long, float, double, chararray, bytearray, boolean, datetime, biginteger and bigdecimal.</source>
          <target state="translated">간단한 데이터 유형에는 int, long, float, double, chararray, bytearray, boolean, datetime, biginteger 및 bigdecimal이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="61469ec0a270a95050856b7f3cbb7662708bd809" translate="yes" xml:space="preserve">
          <source>Simple delimited strings are simple:</source>
          <target state="translated">간단한 구분 된 문자열은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="7e6603ffb066cdd141e15b51427fbdcb71280b2d" translate="yes" xml:space="preserve">
          <source>Simple tasks like string manipulation, mathematical computations, and reorganizing data types can be easily done using Jython scripts without having to develop long and complex UDFs in Java. The overall overhead of using scripting language is much less and development cost is almost negligible. The following UDFs, developed in Jython, can be used with Pig.</source>
          <target state="translated">Java에서 길고 복잡한 UDF를 개발할 필요없이 Jython 스크립트를 사용하여 문자열 조작, 수학 계산 및 데이터 유형 재구성과 같은 간단한 작업을 쉽게 수행 할 수 있습니다. 스크립팅 언어를 사용하는 전체 오버 헤드는 훨씬 적으며 개발 비용은 거의 무시할 수 있습니다. Jython에서 개발 된 다음 UDF는 Pig와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab53c55591ebff329a2cb8fcc3c0f83e8c8dfe81" translate="yes" xml:space="preserve">
          <source>SimplePigStats</source>
          <target state="translated">SimplePigStats</target>
        </trans-unit>
        <trans-unit id="08df06308123b7b064e3fe41bae847130c0ea5d1" translate="yes" xml:space="preserve">
          <source>SimplePigStats is a new class that extends PigStats. SimplePigStats.getAllStats() will return null.</source>
          <target state="translated">SimplePigStats는 PigStats를 확장하는 새로운 클래스입니다. SimplePigStats.getAllStats ()는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="458da12bf0adfbc54b3662609c857717b983be7a" translate="yes" xml:space="preserve">
          <source>Simply annotating your UDF in this way will cause Pig to terminate the UDF's exec() method if it runs for more than 10 seconds, and return the default value of null. The duration of the timeout and the default value can be specified in the annotation, if desired:</source>
          <target state="translated">이런 식으로 UDF에 주석을 달기 만하면 Pig가 UDF의 exec () 메소드를 10 초 이상 실행하면 UDF를 종료하고 기본값 인 null을 반환합니다. 원하는 경우 시간 초과 기간과 기본값을 주석에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21f09574b9498453f96c19fcc1a76e69c4a845cd" translate="yes" xml:space="preserve">
          <source>Since Accumulator UDFs maintain state, the methods annotated with the @AccumulatorXXX annotations cannot be static. A single instance of the enclosing class will be used when invoking them, thus enabling them to access a single state.</source>
          <target state="translated">Accumulator UDF는 상태를 유지하므로 @AccumulatorXXX 주석으로 주석이 달린 메소드는 정적 일 수 없습니다. 엔 클로징 클래스의 단일 인스턴스는 호출 할 때 사용되므로 단일 상태에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44325482f469c25ef4825d4b1af4e046d10621b8" translate="yes" xml:space="preserve">
          <source>Since JavaScript functions are first class objects, you can annotate them by adding attributes. Add an outputSchema attribute to your function so that Pig can identify return types for the script UDF.</source>
          <target state="translated">JavaScript 함수는 일류 객체이므로 속성을 추가하여 주석을 달 수 있습니다. Pig가 스크립트 UDF의 리턴 유형을 식별 할 수 있도록 outputSchema 속성을 함수에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="29324cd673a73b1a630ce6365123117e4fe27064" translate="yes" xml:space="preserve">
          <source>Since null values are used to represent subtotals in cube and rollup operation, in order to differentiate the legitimate null values that already exists as dimension values, CUBE operator converts any null values in dimensions to &quot;unknown&quot; value before performing cube or rollup operation. For example, for CUBE(product,location) with a sample tuple (car,) the output will be</source>
          <target state="translated">널 (null) 값은 큐브 및 롤업 작업에서 소계를 나타내는 데 사용되므로 CUBE 연산자는 차원 값으로 이미 존재하는 합법적 인 널 값을 구별하기 위해 큐브 또는 롤업 작업을 수행하기 전에 차원의 모든 널 값을 &quot;알 수 없음&quot;값으로 변환합니다. 예를 들어, 샘플 튜플 (car)이있는 CUBE (product, location)의 경우 출력은</target>
        </trans-unit>
        <trans-unit id="8d913ecf53286924f2c34548c7c3e7f85653854d" translate="yes" xml:space="preserve">
          <source>Since the nulls from A and B won't be collected together, when the nulls are flattened we're guaranteed to have an empty bag, which will result in no output. So the null keys will be dropped. But they will not be dropped until the last possible moment.</source>
          <target state="translated">A와 B의 널 (null)은 함께 수집되지 않으므로 널 (null)이 평평 할 때 빈 백이 보장되므로 출력이 없습니다. 따라서 널 키가 삭제됩니다. 그러나 그들은 가능한 마지막 순간까지 떨어지지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f7a75938a6c8a0fa27fbc4b75a224b5184f7bef" translate="yes" xml:space="preserve">
          <source>Single-quoted string that contains the job name.</source>
          <target state="translated">작업 이름이 포함 된 작은 따옴표로 묶인 문자열.</target>
        </trans-unit>
        <trans-unit id="a9cc46c896572c6fcc6aadcc438bdae4ba27ca8a" translate="yes" xml:space="preserve">
          <source>Skewed Joins</source>
          <target state="translated">비뚤어진 조인</target>
        </trans-unit>
        <trans-unit id="3daef923736671424d6386311a7e8cf79844970f" translate="yes" xml:space="preserve">
          <source>Skewed join can be used when the underlying data is sufficiently skewed and you need a finer control over the allocation of reducers to counteract the skew. It should also be used when the data associated with a given key is too large to fit in memory.</source>
          <target state="translated">기본 데이터가 충분히 왜곡되어 있고 비뚤어 짐을 방지하기 위해 감속기 할당을보다 세밀하게 제어해야 할 때 기울이기 조인을 사용할 수 있습니다. 주어진 키와 관련된 데이터가 너무 커서 메모리에 맞지 않을 때도 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="90fa6e2857a6d13cba545e4b463cd58540c1c1ff" translate="yes" xml:space="preserve">
          <source>Skewed join does not address (balance) uneven data distribution across reducers. However, in most cases, skewed join ensures that the join will finish (however slowly) rather than fail.</source>
          <target state="translated">비뚤어진 조인은 감속기 전체의 고르지 않은 데이터 분배를 해결하지 않습니다. 그러나 대부분의 경우 비뚤어진 조인은 조인이 실패하지 않고 (느리게) 완료되도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d9b12489fca6fe554210236bed02363aec06af2" translate="yes" xml:space="preserve">
          <source>Skewed join will only work under these conditions:</source>
          <target state="translated">비뚤어진 조인은 다음 조건에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="07a8d8e7a984e73f9c17f0b8ab1b5e76edf040cd" translate="yes" xml:space="preserve">
          <source>Skewed join works with two-table inner and outer join. Currently we do not support more than two tables for skewed join. Specifying three-way (or more) joins will fail validation. For such joins, we rely on you to break them up into two-way joins.</source>
          <target state="translated">기울어 진 조인은 2 테이블 내부 및 외부 조인과 함께 작동합니다. 현재 비뚤어진 조인에 대해 둘 이상의 테이블을 지원하지 않습니다. 3 자 이상의 조인을 지정하면 유효성 검사가 실패합니다. 이러한 조인의 경우 양방향 조인으로 나누는 데 의존합니다.</target>
        </trans-unit>
        <trans-unit id="6ce060197eb8ef8db38f0494a22248715405d922" translate="yes" xml:space="preserve">
          <source>So &quot;a1&amp;gt;0&quot; and &quot;b1&amp;gt;0&quot; can be pushed up individually.</source>
          <target state="translated">따라서 &quot;a1&amp;gt; 0&quot;및 &quot;b1&amp;gt; 0&quot;을 개별적으로 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd243d320270be58ec8889e23d413a18695113a4" translate="yes" xml:space="preserve">
          <source>Solutions are to either:</source>
          <target state="translated">해결책은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="a1a5d771b27dfa13c76e37b6494105890e20267f" translate="yes" xml:space="preserve">
          <source>Some maven dependencies need classifiers in order to be able to resolve. You can specify them using a classifier key.</source>
          <target state="translated">일부 maven 의존성은 해결하기 위해 분류자가 필요합니다. 분류 자 키를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4fe47e182abdc02d1885b2a7151f6e6e9a39a2" translate="yes" xml:space="preserve">
          <source>Sometimes it is necessary to store intermediate results.</source>
          <target state="translated">때때로 중간 결과를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="1616cf9bcee0d0e199b61b66273612fb5b2d4676" translate="yes" xml:space="preserve">
          <source>Sometimes one may discover that a UDF that executes very quickly in the vast majority of cases turns out to run exceedingly slowly on occasion. This can happen, for example, if a UDF uses complex regular expressions to parse free-form strings, or if a UDF uses some external service to communicate with. As of version 0.8, Pig provides a facility for monitoring the length of time a UDF is executing for every invocation, and terminating its execution if it runs too long. This facility can be turned on using a simple Java annotation:</source>
          <target state="translated">때로는 대다수의 경우에 매우 빠르게 실행되는 UDF가 경우에 따라 매우 느리게 실행되는 것으로 나타났습니다. 예를 들어, UDF가 복잡한 정규식을 사용하여 자유 형식 문자열을 구문 분석하거나 UDF가 외부 서비스를 사용하여 통신하는 경우에 발생할 수 있습니다. 버전 0.8부터 Pig는 모든 호출에 대해 UDF가 실행되는 시간을 모니터링하고 실행 시간이 너무 길면 종료하는 기능을 제공합니다. 이 기능은 간단한 Java 주석을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7c0987dc6c2534821dc72e5b3d274ad10ca273" translate="yes" xml:space="preserve">
          <source>Sometimes you need to mock out the data in specific aliases. Using PigTest's mocking you can override an alias everywhere it is assigned. If you do not know the schema (or want to keep your test dynamic) you can use PigTest.getAliasToSchemaMap() to determine the schema. If you chose to go this route, you should cache the map for the specific script to ensure efficient execution.</source>
          <target state="translated">때로는 특정 별칭의 데이터를 모의해야합니다. PigTest의 조롱을 사용하면 할당 된 모든 곳에서 별칭을 무시할 수 있습니다. 스키마를 모르거나 테스트를 동적으로 유지하려면 PigTest.getAliasToSchemaMap ()을 사용하여 스키마를 결정할 수 있습니다. 이 경로를 선택하면 효율적인 실행을 위해 특정 스크립트에 대한 맵을 캐시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a60b9fe63e5542fa49f6be6ad8c405b1b88c3e68" translate="yes" xml:space="preserve">
          <source>Sometimes, you may want change job configuration for jobs that are converted to run in local mode (eg- change io.sort.mb for small jobs). To do so, you can use pig.local. prefix to any configuration and configuration will be set on converted jobs. For example, set pig.local.io.sort.mb 100 will change io.sort.mb value to 100 for jobs converted to run in local mode.</source>
          <target state="translated">경우에 따라 로컬 모드에서 실행되도록 변환 된 작업의 작업 구성 변경 (예 : 작은 작업의 경우 io.sort.mb 변경)이 필요할 수 있습니다. 그렇게하기 위해 pig.local을 사용할 수 있습니다. 모든 구성 및 구성의 접두사는 변환 된 작업에서 설정됩니다. 예를 들어, pig.local.io.sort.mb 100을 설정하면 로컬 모드에서 실행되도록 변환 된 작업에 대해 io.sort.mb 값을 100으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f7529f816bfb066f147924539d56e59bbe14123a" translate="yes" xml:space="preserve">
          <source>Sort in ascending order.</source>
          <target state="translated">오름차순으로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="d122cd4e0173a38ee7b810b94cac4a696f542969" translate="yes" xml:space="preserve">
          <source>Sort in descending order.</source>
          <target state="translated">내림차순으로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="2876797f006540323d01111915bfbfc0e6e5aa37" translate="yes" xml:space="preserve">
          <source>Sorts a relation based on one or more fields.</source>
          <target state="translated">하나 이상의 필드를 기준으로 관계를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="1fb24f1fe058999303c2e8bc6bfc20a77d72c1d9" translate="yes" xml:space="preserve">
          <source>Specialized Joins</source>
          <target state="translated">전문 조인</target>
        </trans-unit>
        <trans-unit id="e4959b70be9ef62d97487e4da4e6e257350f73ab" translate="yes" xml:space="preserve">
          <source>Specifically this makes sense for file-based output locations (HDFS, Local FS, S3..) to avoid Pig script from failing when multiple MR jobs write to the same location.</source>
          <target state="translated">특히 여러 MR 작업이 동일한 위치에 쓸 때 Pig 스크립트가 실패하지 않도록 파일 기반 출력 위치 (HDFS, 로컬 FS, S3 ..)에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="a063622be89b4578c812b5b40562515a204d9e95" translate="yes" xml:space="preserve">
          <source>Specify &quot;-M&quot; or &quot;-no_multiquery&quot; to revert to the old names</source>
          <target state="translated">이전 이름으로 되돌리려면 &quot;-M&quot;또는 &quot;-no_multiquery&quot;를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="909b8655688d45305a8801ad1206b9717a4d02c2" translate="yes" xml:space="preserve">
          <source>Specify a column family and a portion of column qualifier name as a prefix followed by an asterisk (i.e., user_info:address_*). This approach is used to read one or more columns from the same column family with a matching descriptor prefix. The datatype for this field will be a map of column descriptor name to field value. Note that combining this style of prefix with a long list of fully qualified column descriptor names could cause perfomance degredation on the HBase scan. This will produce a Pig map in the resultant tuple with column descriptors as keys.</source>
          <target state="translated">열 패밀리 및 열 규정 자 이름의 일부를 접 두부 뒤에 별표 (예 : user_info : address_ *)로 지정하십시오. 이 방법은 설명 열 접두사가 일치하는 동일한 열 제품군에서 하나 이상의 열을 읽는 데 사용됩니다. 이 필드의 데이터 유형은 열 설명자 이름과 필드 값의 맵입니다. 이 스타일의 접두어를 완전한 열 디스크립터 이름의 긴 목록과 결합하면 HBase 스캔에서 성능 저하가 발생할 수 있습니다. 그러면 열 설명자가 키인 결과 튜플에 Pig 맵이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1a674ed1e370998af9f8a93196bcb957528e90ab" translate="yes" xml:space="preserve">
          <source>Specify a custom scheme for the LoadFunc/Slicer</source>
          <target state="translated">LoadFunc / Slicer에 대한 사용자 정의 구성표 지정</target>
        </trans-unit>
        <trans-unit id="785d141b7ee15cc72996a9c9dd5c9c3fdc688fe1" translate="yes" xml:space="preserve">
          <source>Specify all the columns of a column family using the column family name followed by an asterisk (i.e., user_info:*). This will produce a Pig map in the resultant tuple with column descriptors as keys.</source>
          <target state="translated">열 패밀리 이름과 별표 (예 : user_info : *)를 사용하여 열 패밀리의 모든 열을 지정하십시오. 그러면 열 설명자가 키인 결과 튜플에 Pig 맵이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="19e7fee81c983a52a521b0b6c1fada54641a4ce3" translate="yes" xml:space="preserve">
          <source>Specifying Parameter Values as a Command</source>
          <target state="translated">명령으로 매개 변수 값 지정</target>
        </trans-unit>
        <trans-unit id="f942a2de329f16ff0cd85c510c2fa2175c495f59" translate="yes" xml:space="preserve">
          <source>Specifying Parameter Values as a sequence of Characters</source>
          <target state="translated">일련의 문자로 매개 변수 값 지정</target>
        </trans-unit>
        <trans-unit id="ba1f6ab5146eab70926f150fa7fe49ff8aec42f1" translate="yes" xml:space="preserve">
          <source>Specifying Parameters</source>
          <target state="translated">매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="77ff948cfc50317e72420ef9e2df3f6f4bb3b991" translate="yes" xml:space="preserve">
          <source>Specifying Parameters Using the Declare Statement</source>
          <target state="translated">선언문을 사용하여 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="55c77feb97c2f3c41f1497ee1be255bab599d160" translate="yes" xml:space="preserve">
          <source>Specifying Parameters Using the Default Statement</source>
          <target state="translated">기본 명령문을 사용하여 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="8ef07030f85f1c43b9512e2ee6bd2149ddc555dd" translate="yes" xml:space="preserve">
          <source>Specifying Parameters in the Command Line</source>
          <target state="translated">명령 행에서 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="a9b713af8fe95b463eac1a86f2928a968a63f1e0" translate="yes" xml:space="preserve">
          <source>Specifying a classifier</source>
          <target state="translated">분류기 지정</target>
        </trans-unit>
        <trans-unit id="27dc306271b79d4a3f30258e23e2e1f593b7bcf8" translate="yes" xml:space="preserve">
          <source>Specifying parameters Using a Parameter File</source>
          <target state="translated">매개 변수 파일을 사용하여 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="ef365a10a7d612393f19eabac47a941314a47f36" translate="yes" xml:space="preserve">
          <source>Split filter conditions so that we can push filter more aggressively.</source>
          <target state="translated">더 적극적으로 필터를 푸시 할 수 있도록 필터 조건을 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="14a1713136d38b4b0a8e06095cd194fd25219476" translate="yes" xml:space="preserve">
          <source>SplitFilter</source>
          <target state="translated">SplitFilter</target>
        </trans-unit>
        <trans-unit id="1fdf4e95a41b0f042d3d828cc4bebe08f3a9e508" translate="yes" xml:space="preserve">
          <source>Splits a string and outputs a bag of words.</source>
          <target state="translated">문자열을 나누고 단어 한 줄을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="517ba20e0f0761a76a63c662c7eb3d5e304f17a7" translate="yes" xml:space="preserve">
          <source>Splits a string around matches of a given regular expression and returns a databag</source>
          <target state="translated">주어진 정규 표현식과 일치하는 문자열을 분할하고 데이터 백을 반환</target>
        </trans-unit>
        <trans-unit id="14ddde9f0e886af20681104ce6860d43f146e134" translate="yes" xml:space="preserve">
          <source>Splits a string around matches of a given regular expression.</source>
          <target state="translated">주어진 정규 표현식과 일치하는 문자열을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="6ff849a4622c7c26246a7fe1eab81d40e45ac53c" translate="yes" xml:space="preserve">
          <source>Star Expressions</source>
          <target state="translated">별 표현</target>
        </trans-unit>
        <trans-unit id="9eddc7f127859925abc9ccbca75f7a746fac881a" translate="yes" xml:space="preserve">
          <source>Star expressions ( * ) can be used to represent all the fields of a tuple. It is equivalent to writing out the fields explicitly. In the following example the definition of B and C are exactly the same, and MyUDF will be invoked with exactly the same arguments in both cases.</source>
          <target state="translated">별표 (*)는 튜플의 모든 필드를 나타내는 데 사용할 수 있습니다. 필드를 명시 적으로 쓰는 것과 같습니다. 다음 예에서 B와 C의 정의는 정확히 동일하며, 두 경우 모두 MyUDF가 정확히 동일한 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="26448b7748dac2564f721715b37981faf4ddd499" translate="yes" xml:space="preserve">
          <source>Starting with Pig 0.8, some applications such as Oozie workflow invoke Pig using the PigRunner Java class rather than through the command line. For these applications, the PigRunner interface has been expanded to accommodate embedded Pig. PigRunner accepts Python and JavaScript scripts as input. These scripts can potentially contain multiple Pig pipelines; therefore, we need a way to return results for all of them.</source>
          <target state="translated">Pig 0.8부터 Oozie 워크 플로와 같은 일부 응용 프로그램은 명령 줄 대신 PigRunner Java 클래스를 사용하여 Pig를 호출합니다. 이러한 응용 프로그램을 위해 PigRunner 인터페이스가 내장 Pig를 수용하도록 확장되었습니다. PigRunner는 Python 및 JavaScript 스크립트를 입력으로 허용합니다. 이 스크립트에는 여러 개의 Pig 파이프 라인이 포함될 수 있습니다. 따라서 모든 결과를 반환 할 수있는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3d8f67a1dde3e4ce85cff18b9c55bf480ecb50b7" translate="yes" xml:space="preserve">
          <source>Store Example</source>
          <target state="translated">상점 예</target>
        </trans-unit>
        <trans-unit id="3140dab45665e366571183e7816bd9bac370c7a4" translate="yes" xml:space="preserve">
          <source>Store Examples</source>
          <target state="translated">상점 예</target>
        </trans-unit>
        <trans-unit id="7dc600c9fbbec46a886ddbd3bd69001e44aa87c8" translate="yes" xml:space="preserve">
          <source>Store Functions</source>
          <target state="translated">저장 기능</target>
        </trans-unit>
        <trans-unit id="294e32a5e338dae90a5f2a219adb865f0c6e3452" translate="yes" xml:space="preserve">
          <source>Store alias2 into the inputLocation using storeFunc, which is then used by the MapReduce/Tez job to read its data.</source>
          <target state="translated">storeFunc를 사용하여 alias2를 inputLocation에 저장 한 다음 MapReduce / Tez 작업에서 데이터를 읽는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48894cd5141429802342dfe745e3bfb46a987bed" translate="yes" xml:space="preserve">
          <source>Store statements &amp;ndash; PigStorage outputs data using field delimiters, either the tab character ('\t') or other specified character, and the line feed record delimiter ('\n').</source>
          <target state="translated">저장 문 &amp;ndash; PigStorage는 필드 구분 기호, 탭 문자 ( '\ t') 또는 기타 지정된 문자 및 줄 바꿈 레코드 구분 기호 ( '\ n')를 사용하여 데이터를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="8c92b008a892d23b68e491dbc0929bfe9c76db6c" translate="yes" xml:space="preserve">
          <source>Store vs. Dump</source>
          <target state="translated">저장 대 덤프</target>
        </trans-unit>
        <trans-unit id="be6f4ed10854b287bb1975aa58732d01d19d76ef" translate="yes" xml:space="preserve">
          <source>Storer side:</source>
          <target state="translated">저장 자 쪽 :</target>
        </trans-unit>
        <trans-unit id="3553645c3cc59fd52927162c4d2166089b8c2802" translate="yes" xml:space="preserve">
          <source>Stores data in UTF-8 format.</source>
          <target state="translated">UTF-8 형식으로 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a9c76f65b2c7842a49e10088e2aee1c7e92d9f76" translate="yes" xml:space="preserve">
          <source>Stores or saves results to the file system.</source>
          <target state="translated">결과를 파일 시스템에 저장하거나 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5058d23d7b4c6c3dae4bcb5cbf5c3fdf33f9c0ed" translate="yes" xml:space="preserve">
          <source>Storing Data</source>
          <target state="translated">데이터 저장</target>
        </trans-unit>
        <trans-unit id="240cd119731bcf16d33fe5d52676cacdf4791075" translate="yes" xml:space="preserve">
          <source>Storing Final Results</source>
          <target state="translated">최종 결과 저장</target>
        </trans-unit>
        <trans-unit id="6e2eafa0a462070c6d664b0252b8bbc184f98ce9" translate="yes" xml:space="preserve">
          <source>Storing Intermediate Results</source>
          <target state="translated">중간 결과 저장</target>
        </trans-unit>
        <trans-unit id="893ae89fc71b86c272d08a3081361a5565ef4b73" translate="yes" xml:space="preserve">
          <source>Straight brackets are also used to indicate the map data type. In this case &amp;lt;&amp;gt; is used to indicate optional items.</source>
          <target state="translated">지도 데이터 유형을 나타내는 데 직선 괄호도 사용됩니다. 이 경우 &amp;lt;&amp;gt;는 옵션 항목을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c60c48e195e494877a8fc78b257b5eb65774936" translate="yes" xml:space="preserve">
          <source>Straight brackets enclose one or more optional items.</source>
          <target state="translated">직선 괄호는 하나 이상의 옵션 품목을 묶습니다.</target>
        </trans-unit>
        <trans-unit id="dc773f482eb1b597e269c53928a0b646ef1dbf28" translate="yes" xml:space="preserve">
          <source>Streaming uses the same default format as PigStorage to serialize/deserialize the data. If you want to explicitly specify a format, you can do it as show below (see more examples in the Examples: Input/Output section).</source>
          <target state="translated">스트리밍은 PigStorage와 동일한 기본 형식을 사용하여 데이터를 직렬화 / 직렬화합니다. 형식을 명시 적으로 지정하려는 경우 아래에 표시된대로 형식을 지정할 수 있습니다 (예 : 입력 / 출력 섹션의 추가 예 참조).</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="e695515a83c1c72c5a35c86b1a0815cb037a93cb" translate="yes" xml:space="preserve">
          <source>String Functions</source>
          <target state="translated">문자열 함수</target>
        </trans-unit>
        <trans-unit id="833904db1833f9fa2b3b325ed2334e8d564257ea" translate="yes" xml:space="preserve">
          <source>String format specification</source>
          <target state="translated">문자열 형식 사양</target>
        </trans-unit>
        <trans-unit id="1836573a33f4b8e3137cc19e5ca0dc8a997a36a6" translate="yes" xml:space="preserve">
          <source>String that contains the path.</source>
          <target state="translated">경로가 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1975775022d691abc8eb765690f2be98b21b5198" translate="yes" xml:space="preserve">
          <source>String: chararray</source>
          <target state="translated">끈 : chararray</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="206cd355948fa22a5c2c55b1bf21a012d58dd77b" translate="yes" xml:space="preserve">
          <source>Submit your patch following the process described in &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;How to Contribute to Pig&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;Pig&lt;/a&gt; 에 참여 하는 방법에 설명 된 프로세스에 따라 패치를 제출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1f4de8ceff8b368a5711db5e3e83f332d8592d4" translate="yes" xml:space="preserve">
          <source>Substitute values for parameters at run time.</source>
          <target state="translated">런타임시 매개 변수의 값을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="4ca0e29a257b20cd5b6ba311ffea000470007519" translate="yes" xml:space="preserve">
          <source>SubtractDuration</source>
          <target state="translated">SubtractDuration</target>
        </trans-unit>
        <trans-unit id="30b06863d2617289310eab743eaa63606e0ceb6b" translate="yes" xml:space="preserve">
          <source>SubtractDuration(datetime, duration)</source>
          <target state="translated">빼기 지속 시간 (날짜 시간, 기간)</target>
        </trans-unit>
        <trans-unit id="e7f13007cfd26d33edd64be056de5ac9587bac2b" translate="yes" xml:space="preserve">
          <source>Support for compression is determined by the load/store function. PigStorage and TextLoader support gzip and bzip compression for both read (load) and write (store). BinStorage does not support compression.</source>
          <target state="translated">압축 지원은로드 / 저장 기능에 의해 결정됩니다. PigStorage 및 TextLoader는 읽기 (로드) 및 쓰기 (저장) 모두에 대해 gzip 및 bzip 압축을 지원합니다. BinStorage는 압축을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29cb406a36c3e9bc68cca62ff7ad766d81c73ce0" translate="yes" xml:space="preserve">
          <source>Suppose that you are saving a bag called measurements with the schema:</source>
          <target state="translated">스키마를 사용하여 측정이라는 백을 저장한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6fea954bf148fe82f27452ac23bdbf16886c26" translate="yes" xml:space="preserve">
          <source>Suppose that you were provided with a file of avro data (located in 'stuff') with the following schema:</source>
          <target state="translated">다음 스키마와 함께 avro 데이터 파일 ( 'stuff'에 위치)이 제공되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="527a8806da9240bfdedbb614619f68e3b83da0e5" translate="yes" xml:space="preserve">
          <source>Suppose we have a data file called 'mydata' and a pig script called 'myscript.pig'.</source>
          <target state="translated">'mydata'라는 데이터 파일과 'myscript.pig'라는 돼지 스크립트가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ce00729d33d2710c048a00de67eb98fcdcd7e610" translate="yes" xml:space="preserve">
          <source>Suppose we have a data file called myfile.txt. The fields are tab-delimited. The records are newline-separated.</source>
          <target state="translated">myfile.txt라는 데이터 파일이 있다고 가정하십시오. 필드는 탭으로 구분됩니다. 레코드는 줄 바꿈으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="624e7ca860d67c2a865d81d84273cafe58f5860f" translate="yes" xml:space="preserve">
          <source>Suppose we have a parameter file called 'myparams.'</source>
          <target state="translated">'myparams'라는 매개 변수 파일이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1f242317776136bed9f5bb1c625a078e9a7c5fc6" translate="yes" xml:space="preserve">
          <source>Suppose we have relation A.</source>
          <target state="translated">관계 A가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d36da6b3dd5aad7e3c388cc6f36b17faaff8cb9e" translate="yes" xml:space="preserve">
          <source>Suppose we have relation B, formed by grouping relation A (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">관계 A를 그룹화하여 구성된 관계 B가 있다고 가정하십시오 (관계 B의 필드 이름에 대한 정보는 GROUP 연산자 참조).</target>
        </trans-unit>
        <trans-unit id="bdb212e67921dc6abd44ee757871e36386ebd338" translate="yes" xml:space="preserve">
          <source>Suppose we have relations A and B.</source>
          <target state="translated">관계 A와 B가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d48ed4b77bbb0fd715c3e2905d1f38a0d9966d6" translate="yes" xml:space="preserve">
          <source>Suppose we have relations A and B. Note that relation B contains an inner bag.</source>
          <target state="translated">관계 A와 B가 있다고 가정하십시오. 관계 B에는 내부 백이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b615c1c42402575c11c994ec60da3cb4048eaa" translate="yes" xml:space="preserve">
          <source>Suppose we have two relations, A and B.</source>
          <target state="translated">A와 B의 두 가지 관계가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="22d03121adfa16440d0c044314294d8c7064c6ff" translate="yes" xml:space="preserve">
          <source>Syntax (&amp;lt;&amp;gt; demotes optional)</source>
          <target state="translated">구문 (&amp;lt;&amp;gt; 강등 옵션)</target>
        </trans-unit>
        <trans-unit id="5143478097b5ccd9c3d4682cbb300b1f5b93e63b" translate="yes" xml:space="preserve">
          <source>Syntax (&amp;lt;&amp;gt; denotes optional)</source>
          <target state="translated">구문 (&amp;lt;&amp;gt;는 선택 사항을 나타냄)</target>
        </trans-unit>
        <trans-unit id="7741a68cf3fe7b8d4a142fc0ccee28593e4fab51" translate="yes" xml:space="preserve">
          <source>Syntax: Inner bag</source>
          <target state="translated">구문 : 내부 가방</target>
        </trans-unit>
        <trans-unit id="f60bf2739731f85af00da24b650dc5ae0c4cc185" translate="yes" xml:space="preserve">
          <source>Syntax: Specifying Parameters Using Preprocessor Statements in a Pig Script</source>
          <target state="translated">구문 : Pig 스크립트에서 전 처리기 명령문을 사용하여 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="e61d642e0efaefe93c9c7b16dbfd11430b7ac83a" translate="yes" xml:space="preserve">
          <source>Syntax: Specifying Parameters Using the Pig Command Line</source>
          <target state="translated">구문 : Pig 명령 행을 사용하여 매개 변수 지정</target>
        </trans-unit>
        <trans-unit id="ed93af0f04af7cacdeebb0a43515c646521d3137" translate="yes" xml:space="preserve">
          <source>Syntax: UDF and streaming</source>
          <target state="translated">구문 : UDF 및 스트리밍</target>
        </trans-unit>
        <trans-unit id="c0bc60feab72f7555a110ea439a9e15724c15c50" translate="yes" xml:space="preserve">
          <source>TAN</source>
          <target state="translated">TAN</target>
        </trans-unit>
        <trans-unit id="748f86128cfbebaf461e1e36387107bf7f12daf3" translate="yes" xml:space="preserve">
          <source>TAN(expression)</source>
          <target state="translated">TAN(expression)</target>
        </trans-unit>
        <trans-unit id="9fa5937af21e96622b86460b51850ee0fb770ffe" translate="yes" xml:space="preserve">
          <source>TANH</source>
          <target state="translated">TANH</target>
        </trans-unit>
        <trans-unit id="ee3458a2dc11a209b21b4354fefaafbb343cc39c" translate="yes" xml:space="preserve">
          <source>TANH(expression)</source>
          <target state="translated">TANH(expression)</target>
        </trans-unit>
        <trans-unit id="b197f7d4fc520a43772cd63ee9d631265cec1a47" translate="yes" xml:space="preserve">
          <source>THROUGH</source>
          <target state="translated">THROUGH</target>
        </trans-unit>
        <trans-unit id="4090847bf88746d90088cd3733aa8a904ebf0f5a" translate="yes" xml:space="preserve">
          <source>TOBAG</source>
          <target state="translated">TOBAG</target>
        </trans-unit>
        <trans-unit id="c0e2243e4ec01cdaf4d459c8d919498b6d047e7c" translate="yes" xml:space="preserve">
          <source>TOBAG(expression [, expression ...])</source>
          <target state="translated">TOBAG (식 [, 식 ...])</target>
        </trans-unit>
        <trans-unit id="b9572adf6670d55feb22da9a57727115dcea2e7a" translate="yes" xml:space="preserve">
          <source>TOKENIZE</source>
          <target state="translated">TOKENIZE</target>
        </trans-unit>
        <trans-unit id="b09649671b16a8de7036735e8bcb219a82f434f9" translate="yes" xml:space="preserve">
          <source>TOKENIZE(expression [, 'field_delimiter'])</source>
          <target state="translated">TOKENIZE (식 [, 'field_delimiter'])</target>
        </trans-unit>
        <trans-unit id="b5727645328a06d0ad1054d2257017f7dde22f77" translate="yes" xml:space="preserve">
          <source>TOMAP</source>
          <target state="translated">TOMAP</target>
        </trans-unit>
        <trans-unit id="88a6b21bb3e785362abf9e58d46601cb0544e67a" translate="yes" xml:space="preserve">
          <source>TOMAP(key-expression, value-expression [, key-expression, value-expression ...])</source>
          <target state="translated">TOMAP (키 표현, 값 표현 [, 키 표현, 값 표현 ...])</target>
        </trans-unit>
        <trans-unit id="b48813fa0aece2d14a9215d74ebb9cba0cf6faa9" translate="yes" xml:space="preserve">
          <source>TOP</source>
          <target state="translated">TOP</target>
        </trans-unit>
        <trans-unit id="47b363b911b9ac1385b261a5239353f685f99b2d" translate="yes" xml:space="preserve">
          <source>TOP function returns a bag containing top N tuples from the input bag where N is controlled by the first parameter to the function. The tuple comparison is performed based on a single column from the tuple. The column position is determined by the second parameter to the function. The function assumes that all tuples in the bag contain an element of the same type in the compared column.</source>
          <target state="translated">TOP 함수는 입력 백에서 맨 위 N 튜플이 포함 된 백을 리턴합니다. 여기서 N은 첫 번째 매개 변수로 제어됩니다. 튜플 비교는 튜플의 단일 열을 기반으로 수행됩니다. 열 위치는 함수에 대한 두 번째 매개 변수에 의해 결정됩니다. 이 함수는 백의 모든 튜플이 비교 열에 동일한 유형의 요소를 포함한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7b01bdbcbb84f8758957c56540ff71f65a650697" translate="yes" xml:space="preserve">
          <source>TOP(topN,column,relation)</source>
          <target state="translated">TOP(topN,column,relation)</target>
        </trans-unit>
        <trans-unit id="1407ca0b487a373eb5356fcf17c25a454c95bd95" translate="yes" xml:space="preserve">
          <source>TOTUPLE</source>
          <target state="translated">TOTUPLE</target>
        </trans-unit>
        <trans-unit id="86ba006bb7375d731bca9808f59689909df47eae" translate="yes" xml:space="preserve">
          <source>TOTUPLE(expression [, expression ...])</source>
          <target state="translated">TOTUPLE (식 [, 식 ...])</target>
        </trans-unit>
        <trans-unit id="ba3e011804ea47187cb1d3de91aecb7cc6bbde51" translate="yes" xml:space="preserve">
          <source>TRIM</source>
          <target state="translated">TRIM</target>
        </trans-unit>
        <trans-unit id="7bf12aeeef5e2b4ebde7d138145474a2a6ee86d4" translate="yes" xml:space="preserve">
          <source>TRIM(expression)</source>
          <target state="translated">TRIM(expression)</target>
        </trans-unit>
        <trans-unit id="a90331315a4a5de1650f80df4f6614a9b2150c4b" translate="yes" xml:space="preserve">
          <source>Take Advantage of Join Optimizations</source>
          <target state="translated">조인 최적화 활용</target>
        </trans-unit>
        <trans-unit id="8af91a07e385522a6ac4a7f348850b9f002737ca" translate="yes" xml:space="preserve">
          <source>Take a look at the COUNT implementation to see how this is done. Note that the exec function of the Initial and Intermed classes is parameterized with Tuple and the exec of the Final class is parameterized with the real type of the function, which in the case of the COUNT is Long. Also, note that the fully-qualified name of the class needs to be returned from getInitial, getIntermed, and getFinal methods.</source>
          <target state="translated">이것이 어떻게 수행되는지 COUNT 구현을 살펴보십시오. Initial 및 Intermed 클래스의 exec 함수는 Tuple로 매개 변수화되고 Final 클래스의 exec는 함수의 실제 유형으로 매개 변수화되며 COUNT의 경우 Long입니다. 또한 클래스의 완전한 이름은 getInitial, getIntermed 및 getFinal 메소드에서 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0058a5054c034748fd438cef80ff3ecc37db7071" translate="yes" xml:space="preserve">
          <source>Takes an expression on the left and a string constant on the right.</source>
          <target state="translated">왼쪽에 표현식을, 오른쪽에 문자열 상수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="19900c1595007a6f83f1b0b60b63593c95630f27" translate="yes" xml:space="preserve">
          <source>Test the Pig installation with this simple command: $ pig -help</source>
          <target state="translated">이 간단한 명령으로 Pig 설치를 테스트하십시오 : $ pig -help</target>
        </trans-unit>
        <trans-unit id="6558c0c2060d0c07285ac6231253d437e732a169" translate="yes" xml:space="preserve">
          <source>Testing and Diagnostics</source>
          <target state="translated">테스트 및 진단</target>
        </trans-unit>
        <trans-unit id="ebf7ef1847d647a542479739bc274ed3852936d7" translate="yes" xml:space="preserve">
          <source>Tests inputs to determine if the first argument ends with the string in the second.</source>
          <target state="translated">첫 번째 인수가 두 번째의 문자열로 끝나는 지 판별하기 위해 입력을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="88d595c142e20f56244bd49b803a30fa35b8b472" translate="yes" xml:space="preserve">
          <source>Tests inputs to determine if the first argument starts with the string in the second.</source>
          <target state="translated">첫 번째 인수가 두 번째의 문자열로 시작하는지 판별하기 위해 입력을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e4ed6e2f9447686cf882d71b8fef0ccf43ee7a9b" translate="yes" xml:space="preserve">
          <source>Text mode (default): multiple output (split) will be broken out in sections.</source>
          <target state="translated">텍스트 모드 (기본값) : 다중 출력 (분할)이 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="a13fb439a54b5106300495947868b835690e4664" translate="yes" xml:space="preserve">
          <source>TextLoader</source>
          <target state="translated">TextLoader</target>
        </trans-unit>
        <trans-unit id="dfeb62fb61b8eaa8a450967f5a79683392011920" translate="yes" xml:space="preserve">
          <source>TextLoader cannot be used to store data.</source>
          <target state="translated">TextLoader를 사용하여 데이터를 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aeac9eb6699d79ec5ca3daa6f35a6babeacd036d" translate="yes" xml:space="preserve">
          <source>TextLoader works with unstructured data in UTF8 format. Each resulting tuple contains a single field with one line of input text. TextLoader also supports &lt;a href=&quot;#handling-compression&quot;&gt;compression&lt;/a&gt;.</source>
          <target state="translated">TextLoader는 UTF8 형식의 비정형 데이터와 함께 작동합니다. 각 결과 튜플에는 한 줄의 입력 텍스트가있는 단일 필드가 포함됩니다. TextLoader는 &lt;a href=&quot;#handling-compression&quot;&gt;압축&lt;/a&gt; 도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="dbd0f757393e3c94bef2e63957dd7755499d93e8" translate="yes" xml:space="preserve">
          <source>TextLoader()</source>
          <target state="translated">TextLoader()</target>
        </trans-unit>
        <trans-unit id="6dff45df4f2a3f1eeadfa1306cf5cfee0554f566" translate="yes" xml:space="preserve">
          <source>TextLoader, TOKENIZE, through, tuple</source>
          <target state="translated">TextLoader, TOKENIZE, 스루, 튜플</target>
        </trans-unit>
        <trans-unit id="cff763456bb07876f9436afc5f19bfc8ef11ac5e" translate="yes" xml:space="preserve">
          <source>Tez DAG generation</source>
          <target state="translated">Tez DAG 생성</target>
        </trans-unit>
        <trans-unit id="4da0e960da0eea4c850c298b68ef78cf1547058f" translate="yes" xml:space="preserve">
          <source>Tez local mode is not stable, we see job hang in some cases</source>
          <target state="translated">Tez 로컬 모드가 안정적이지 않습니다. 경우에 따라 작업이 중단되는 것을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a941c85bf6a01e6590890d94db31595140cbd7ee" translate="yes" xml:space="preserve">
          <source>Tez mode</source>
          <target state="translated">테즈 모드</target>
        </trans-unit>
        <trans-unit id="049646505ff861656bdf7b3305c010c604990122" translate="yes" xml:space="preserve">
          <source>Tez session/container reuse</source>
          <target state="translated">테즈 세션 / 컨테이너 재사용</target>
        </trans-unit>
        <trans-unit id="83b62ad94040c42c7d3b532e001f593dde539fca" translate="yes" xml:space="preserve">
          <source>Tez specific GUI is not available yet, there is no GUI to track task progress. However, log message is available in GUI</source>
          <target state="translated">Tez 특정 GUI를 아직 사용할 수 없으며 작업 진행 상황을 추적 할 GUI가 없습니다. 그러나 GUI에서 로그 메시지를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2e2cf1ae0c124c6c9cd7ca8f787bb95621994746" translate="yes" xml:space="preserve">
          <source>TezDAGStats</source>
          <target state="translated">TezDAGStats</target>
        </trans-unit>
        <trans-unit id="617e066201ba90c01781d07f62deb115db7e9f9a" translate="yes" xml:space="preserve">
          <source>TezPigScriptStats</source>
          <target state="translated">TezPigScriptStats</target>
        </trans-unit>
        <trans-unit id="486a7f5050ea1ce58d61f367719a86b1794a7b43" translate="yes" xml:space="preserve">
          <source>TezVertexStats</source>
          <target state="translated">TezVertexStats</target>
        </trans-unit>
        <trans-unit id="d2e8cf80fa7b59b2121ee2e1e5aedc127d29d48f" translate="yes" xml:space="preserve">
          <source>The -D and a Hadoop property in PIG_OPTS environment variable (export PIG_OPTS=&amp;ndash;Dmapreduce.task.profile=true)</source>
          <target state="translated">PIG_OPTS 환경 변수의 -D 및 Hadoop 특성 (export PIG_OPTS = &amp;ndash;Dmapreduce.task.profile = true)</target>
        </trans-unit>
        <trans-unit id="b400b31d95aa040c4718dd8c49346007d144c3c5" translate="yes" xml:space="preserve">
          <source>The -D and a Pig property in PIG_OPTS environment variable (export PIG_OPTS=-Dpig.tmpfilecompression=true)</source>
          <target state="translated">PIG_OPTS 환경 변수의 -D 및 Pig 특성 (export PIG_OPTS = -Dpig.tmpfilecompression = true)</target>
        </trans-unit>
        <trans-unit id="2c19b2629bbeef7bc2484ccf7bbe590aef562ee8" translate="yes" xml:space="preserve">
          <source>The -P command line option and a properties file (pig -P mypig.properties)</source>
          <target state="translated">-P 명령 행 옵션 및 특성 파일 (pig -P mypig.properties)</target>
        </trans-unit>
        <trans-unit id="60ebd8351727767c550a62d8280d4744851d1452" translate="yes" xml:space="preserve">
          <source>The -P command line option and a property file (pig -P property_file)</source>
          <target state="translated">-P 명령 행 옵션 및 특성 파일 (pig -P property_file)</target>
        </trans-unit>
        <trans-unit id="d9002610f3f4948747e6737853466d055a7ee88c" translate="yes" xml:space="preserve">
          <source>The -t, -optimizer_off command-line options. (e.g.: pig -optimizer_off [opt_rule | all])</source>
          <target state="translated">-t, -optimizer_off 명령 행 옵션 (예 : pig -optimizer_off [opt_rule | all])</target>
        </trans-unit>
        <trans-unit id="65bef86cbabb4f126a9e3a23bce277be6fd67f7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;basic#define&quot;&gt;DEFINE&lt;/a&gt; statement is used to bind a keyword to a Java method, as above. The first argument to the InvokeFor* constructor is the full path to the desired method. The second argument is a space-delimited ordered list of the classes of the method arguments. This can be omitted or an empty string if the method takes no arguments. Valid class names are string, long, float, double, and int. Invokers can also work with array arguments, represented in Pig as DataBags of single-tuple elements. Simply refer to string[], for example. Class names are not case sensitive.</source>
          <target state="translated">&lt;a href=&quot;basic#define&quot;&gt;DEFINE&lt;/a&gt; 문은 위와 같이, Java 메소드에 키워드를 결합하는 데 사용됩니다. InvokeFor * 생성자의 첫 번째 인수는 원하는 메소드의 전체 경로입니다. 두 번째 인수는 공백으로 구분 된 메소드 인수 클래스 목록입니다. 메소드가 인수를 취하지 않으면 생략하거나 빈 문자열을 사용할 수 있습니다. 유효한 클래스 이름은 string, long, float, double 및 int입니다. 호출자는 단일 튜플 요소의 DataBag로 Pig에 표시된 배열 인수로 작업 할 수도 있습니다. 예를 들어 string []을 참조하십시오. 클래스 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb9293574eacf0fdc9b8f1d697c51a444cb84842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cmds#set&quot;&gt;set&lt;/a&gt; command (set mapred.map.tasks.speculative.execution false)</source>
          <target state="translated">&lt;a href=&quot;cmds#set&quot;&gt;설정&lt;/a&gt; 명령 (세트 mapred.map.tasks.speculative.execution의 거짓)</target>
        </trans-unit>
        <trans-unit id="d046456583259350f6b582e38487fcaeb582c17f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cmds#set&quot;&gt;set&lt;/a&gt; command (set pig.exec.nocombiner true)</source>
          <target state="translated">&lt;a href=&quot;cmds#set&quot;&gt;설정&lt;/a&gt; 명령 (세트 pig.exec.nocombiner 참)</target>
        </trans-unit>
        <trans-unit id="dbbeca61341c85522515a65c8524b89b199c23cf" translate="yes" xml:space="preserve">
          <source>The AVG function ignores NULL values.</source>
          <target state="translated">AVG 함수는 NULL 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="eb966fc0e92ae34917d24835c203e35398b3f553" translate="yes" xml:space="preserve">
          <source>The COUNT function follows syntax semantics and ignores nulls. What this means is that a tuple in the bag will not be counted if the FIRST FIELD in this tuple is NULL. If you want to include NULL values in the count computation, use &lt;a href=&quot;#count-star&quot;&gt;COUNT_STAR&lt;/a&gt;.</source>
          <target state="translated">COUNT 함수는 구문 의미론을 따르며 널을 무시합니다. 이것이 의미하는 것은이 튜플의 첫 번째 필드가 NULL이면 백의 튜플이 계산되지 않는다는 것입니다. 카운트 계산에 NULL 값을 포함하려면 &lt;a href=&quot;#count-star&quot;&gt;COUNT_STAR를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a6749d723480cdc1e841082f3d1c8e4eea81e96" translate="yes" xml:space="preserve">
          <source>The DIFF function takes two bags as arguments and compares them. Any tuples that are in one bag but not the other are returned in a bag. If the bags match, an empty bag is returned. If the fields are not bags then they will be wrapped in tuples and returned in a bag if they do not match, or an empty bag will be returned if the two records match. The implementation assumes that both bags being passed to the DIFF function will fit entirely into memory simultaneously. If this is not the case the UDF will still function but it will be VERY slow.</source>
          <target state="translated">DIFF 함수는 두 개의 백을 인수로 사용하여 비교합니다. 한 봉지에 있지만 다른 봉지에없는 튜플은 봉지로 반환됩니다. 가방이 일치하면 빈 가방이 반환됩니다. 필드가 백이 아닌 경우 튜플로 싸서 일치하지 않으면 백으로 반환되거나 두 레코드가 일치하면 빈 백이 반환됩니다. 이 구현에서는 DIFF 기능으로 전달되는 두 백이 모두 메모리에 동시에 들어가는 것으로 가정합니다. 그렇지 않은 경우 UDF는 여전히 작동하지만 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="71f24cec49b943dc26d6dc769473e8901732541e" translate="yes" xml:space="preserve">
          <source>The FLATTEN operator looks like a UDF syntactically, but it is actually an operator that changes the structure of tuples and bags in a way that a UDF cannot. Flatten un-nests tuples, bags and maps. The idea is the same, but the operation and result is different for each type of structure.</source>
          <target state="translated">FLATTEN 연산자는 구문 상 UDF처럼 보이지만 실제로는 UDF가 할 수없는 방식으로 튜플과 백의 구조를 변경하는 연산자입니다. 중첩 해제 튜플, 가방 및 맵을 평평하게 만듭니다. 아이디어는 동일하지만 각 유형의 구조에 따라 작업 및 결과가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0a777d0b0adf1f9cb04e49362299b9faea54bf39" translate="yes" xml:space="preserve">
          <source>The FsShell command parameters.</source>
          <target state="translated">FsShell 명령 매개 변수</target>
        </trans-unit>
        <trans-unit id="f832a9199e7cfb09555a3e40827bfc1845a3f105" translate="yes" xml:space="preserve">
          <source>The FsShell command.</source>
          <target state="translated">FsShell 명령</target>
        </trans-unit>
        <trans-unit id="38c076ae081cf352565109b1ad62d02981f7f269" translate="yes" xml:space="preserve">
          <source>The GENERATE keyword must be the last statement within the nested block.</source>
          <target state="translated">GENERATE 키워드는 중첩 된 블록 내의 마지막 명령문이어야합니다.</target>
        </trans-unit>
        <trans-unit id="77fdf297232ba03a9c6d9e17ea48aa8bc17e5cad" translate="yes" xml:space="preserve">
          <source>The GROUP and JOIN operators perform similar functions. GROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples</source>
          <target state="translated">GROUP 및 JOIN 연산자는 비슷한 기능을 수행합니다. GROUP은 중첩 된 출력 튜플 세트를 작성하고 JOIN은 플랫 출력 튜플 세트를 작성합니다</target>
        </trans-unit>
        <trans-unit id="604e8ed5bd70749bd373c657de60bbb838360686" translate="yes" xml:space="preserve">
          <source>The GROUP and JOIN operators perform similar functions. GROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples.</source>
          <target state="translated">GROUP 및 JOIN 연산자는 비슷한 기능을 수행합니다. GROUP은 중첩 된 출력 튜플 세트를 작성하고 JOIN은 플랫 출력 튜플 세트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="080edaee56a666121f2b7ccc6b27cc66989610a0" translate="yes" xml:space="preserve">
          <source>The GROUP operator groups together tuples that have the same group key (key field). The key field will be a tuple if the group key has more than one field, otherwise it will be the same type as that of the group key. The result of a GROUP operation is a relation that includes one tuple per group. This tuple contains two fields:</source>
          <target state="translated">GROUP 연산자는 동일한 그룹 키 (키 필드)를 가진 튜플을 함께 그룹화합니다. 그룹 키에 둘 이상의 필드가 있으면 키 필드는 튜플이되고, 그렇지 않으면 그룹 키와 동일한 유형이됩니다. GROUP 조작의 결과는 그룹당 하나의 튜플을 포함하는 관계입니다. 이 튜플에는 두 가지 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33d788c8d037c881135c091ca215c87fac1ccbe3" translate="yes" xml:space="preserve">
          <source>The GROUP statement and its elements can appear anywhere in the projection.</source>
          <target state="translated">GROUP 문과 해당 요소는 투영의 어느 곳에 나 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ff9623c063942cf2e2ed837f553e2c3cfe9bb40" translate="yes" xml:space="preserve">
          <source>The GROUP statement can be referred to as a whole or by accessing individual fields (as in the example).</source>
          <target state="translated">GROUP 문은 전체 또는 개별 필드에 액세스하여 참조 할 수 있습니다 (예와 같이).</target>
        </trans-unit>
        <trans-unit id="86a8ca6eefce9526893fdd65465a4e554fe861fe" translate="yes" xml:space="preserve">
          <source>The GROUP/COGROUP and JOIN operators handle null values differently (see &lt;a href=&quot;#nulls_group&quot;&gt;Nulls and GROUP/COGROUP Operataors&lt;/a&gt;).</source>
          <target state="translated">GROUP / COGROUP 및 JOIN 연산자는 널값을 다르게 처리합니다 ( &lt;a href=&quot;#nulls_group&quot;&gt;Null 및 GROUP / COGROUP Operataors 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a45e846aa3a29c410de8772b93fb639541ae021a" translate="yes" xml:space="preserve">
          <source>The GROUP/COGROUP and JOIN operators handle null values differently (see &lt;a href=&quot;#nulls_join&quot;&gt;Nulls and JOIN Operator&lt;/a&gt;).</source>
          <target state="translated">GROUP / COGROUP 및 JOIN 연산자는 널값을 다르게 처리합니다 ( &lt;a href=&quot;#nulls_join&quot;&gt;Null 및 JOIN 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5066176978e8f9f2442226fe0a5c76774cb16386" translate="yes" xml:space="preserve">
          <source>The Hadoop job will automatically pickup these credentials and the job will run fine.</source>
          <target state="translated">Hadoop 작업은 이러한 자격 증명을 자동으로 선택하여 작업이 정상적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c1b7d61b297e2664c88e85a2785a218bd67ffc" translate="yes" xml:space="preserve">
          <source>The Hadoop version installed.</source>
          <target state="translated">하둡 버전이 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="f5a553a4ad98e429ce84060122967bb133f84976" translate="yes" xml:space="preserve">
          <source>The IsEmpty function checks if a bag or map is empty (has no data). The function can be used to filter data.</source>
          <target state="translated">IsEmpty 함수는 백 또는 맵이 비어 있는지 확인합니다 (데이터가 없음). 이 기능을 사용하여 데이터를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46b89778c6db78c2c2bc9da908edbc8fad4a9ad" translate="yes" xml:space="preserve">
          <source>The JOIN operator - when performing inner joins - adheres to the SQL standard and disregards (filters out) null values. (See also &lt;a href=&quot;perf#nulls&quot;&gt;Drop Nulls Before a Join&lt;/a&gt;.)</source>
          <target state="translated">내부 결합을 수행 할 때 JOIN 연산자는 SQL 표준을 준수하고 널값을 무시 (필터링)합니다. ( &lt;a href=&quot;perf#nulls&quot;&gt;조인 전에 널 삭제를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="e9adabee56f2d62bcbb8f9560ad86202eb5ecc72" translate="yes" xml:space="preserve">
          <source>The LoadFunc abstract class is the main class to extend for implementing a loader. The methods which need to be overridden are explained below:</source>
          <target state="translated">LoadFunc 추상 클래스는 로더 구현을 위해 확장 할 기본 클래스입니다. 재정의해야하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dd35498aa5e3ebf3b4207e5ceb748590f5e10fe" translate="yes" xml:space="preserve">
          <source>The MAX function ignores NULL values.</source>
          <target state="translated">MAX 함수는 NULL 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="bc835713c687bc5ec200e6fe231d58236713e3aa" translate="yes" xml:space="preserve">
          <source>The MIN function ignores NULL values.</source>
          <target state="translated">MIN 함수는 NULL 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0982a8f1698da02eb47d4e5ce444fe7040a96e98" translate="yes" xml:space="preserve">
          <source>The Pig Documentation provides the information you need to get started using Pig. If you haven't already, download Pig now: .</source>
          <target state="translated">Pig Documentation은 Pig를 시작하는 데 필요한 정보를 제공합니다. 아직하지 않은 경우 지금 Pig를 다운로드하십시오 :.</target>
        </trans-unit>
        <trans-unit id="a9d90cc4ed1398b48abff2bdfc673f0792c92929" translate="yes" xml:space="preserve">
          <source>The Pig Latin load functions (for example, PigStorage and TextLoader) produce null values wherever data is missing. For example, empty strings (chararrays) are not loaded; instead, they are replaced by nulls.</source>
          <target state="translated">Pig Latin로드 기능 (예 : PigStorage 및 TextLoader)은 데이터가없는 곳에서 null 값을 생성합니다. 예를 들어, 빈 문자열 (문자열)은로드되지 않습니다. 대신, 이들은 널로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2697bac632407905afe47cfac6a09bae0297e0" translate="yes" xml:space="preserve">
          <source>The Pig Latin statements in the Pig script (id.pig) extract all user IDs from the /etc/passwd file. First, copy the /etc/passwd file to your local working directory. Next, run the Pig script from the command line (using local or mapreduce mode). The STORE operator will write the results to a file (id.out).</source>
          <target state="translated">Pig 스크립트 (id.pig)의 Pig Latin 문은 / etc / passwd 파일에서 모든 사용자 ID를 추출합니다. 먼저 / etc / passwd 파일을 로컬 작업 디렉토리로 복사하십시오. 다음으로 명령 행에서 Pig 스크립트를 실행하십시오 (로컬 또는 mapreduce 모드 사용). STORE 연산자는 결과를 파일 (id.out)에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="95e5ebdda6f1a150cac46ad696c25c8cde9baf1b" translate="yes" xml:space="preserve">
          <source>The Pig Tuple schema will be translated to a union of a map of records with an equivalent schema and null.</source>
          <target state="translated">Pig Tuple 스키마는 동등한 스키마를 가진 레코드 맵의 통합으로 변환되며 null입니다.</target>
        </trans-unit>
        <trans-unit id="eff808ab7b67410c0db999eae54badb9ce1ac01c" translate="yes" xml:space="preserve">
          <source>The Pig Tuple schema will be translated to a union of an array of records with an equivalent schema and null.</source>
          <target state="translated">Pig Tuple 스키마는 동등한 스키마와 널 (null)을 가진 레코드 배열의 결합으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff336c0f00b5e948b58296c565feb53b6276649" translate="yes" xml:space="preserve">
          <source>The Pig Tuple schema will be translated to an union of and Avro record with an equivalent schem and null.</source>
          <target state="translated">Pig Tuple 스키마는 동등한 schem과 null을 가진 Avro 레코드의 합집합으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3bc9a2198c55c3c6c93b105d21273583910b37d" translate="yes" xml:space="preserve">
          <source>The Pig combiner is an optimizer that is invoked when the statements in your scripts are arranged in certain ways. The examples below demonstrate when the combiner is used and not used. Whenever possible, make sure the combiner is used as it frequently yields an order of magnitude improvement in performance.</source>
          <target state="translated">Pig 컴 바이 너는 스크립트의 명령문이 특정 방식으로 배열 될 때 호출되는 최적화 프로그램입니다. 아래의 예는 결합기가 사용되고 사용되지 않는 경우를 보여줍니다. 가능할 때마다 결합기가 성능을 크게 향상 시키므로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e79eee5a5f431cbccc42e8190d1a362da51a36e1" translate="yes" xml:space="preserve">
          <source>The Pig load/store API is aligned with Hadoop's InputFormat and OutputFormat classes. This enables you to create new LoadFunc and StoreFunc implementations based on existing Hadoop InputFormat and OutputFormat classes with minimal code. The complexity of reading the data and creating a record lies in the InputFormat while the complexity of writing the data lies in the OutputFormat. This enables Pig to easily read/write data in new storage formats as and when an Hadoop InputFormat and OutputFormat is available for them.</source>
          <target state="translated">Pig로드 / 스토어 API는 Hadoop의 InputFormat 및 OutputFormat 클래스와 정렬됩니다. 이를 통해 최소한의 코드로 기존 Hadoop InputFormat 및 OutputFormat 클래스를 기반으로 새 LoadFunc 및 StoreFunc 구현을 작성할 수 있습니다. 데이터 읽기 및 레코드 작성의 복잡성은 InputFormat에 있으며 데이터 작성의 복잡성은 OutputFormat에 있습니다. 이를 통해 Pig는 Hadoop InputFormat 및 OutputFormat을 사용할 수있을 때 새로운 스토리지 형식으로 데이터를 쉽게 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a66ae8f634062db273bf669b0f06ea90490c1b" translate="yes" xml:space="preserve">
          <source>The Pig properties file, pig.properties, is located in the conf directory (/pig-n.n.n/conf/pig.properties). You can specify an alternate location using the PIG_CONF_DIR environment variable.</source>
          <target state="translated">Pig 속성 파일 pig.properties는 conf 디렉토리 (/pig-nnn/conf/pig.properties)에 있습니다. PIG_CONF_DIR 환경 변수를 사용하여 대체 위치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1afbcc7d77826c574489c8e80edc9e8c70c28ed" translate="yes" xml:space="preserve">
          <source>The Pig script file, pig, is located in the bin directory (/pig-n.n.n/bin/pig). The Pig environment variables are described in the Pig script file.</source>
          <target state="translated">Pig 스크립트 파일 인 pig은 bin 디렉토리 (/ pig-nnn / bin / pig)에 있습니다. Pig 환경 변수는 Pig 스크립트 파일에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a91f81af92bf8fb4b1bff351f2858ef43c96d92" translate="yes" xml:space="preserve">
          <source>The Pig statistics are available here: &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/&quot;&gt;http://pig.apache.org/docs/r0.17.0/api/&lt;/a&gt;</source>
          <target state="translated">돼지 통계는 &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/&quot;&gt;http://pig.apache.org/docs/r0.17.0/api/에서&lt;/a&gt; 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b77a22ca928e6adfc71480dd73cb52756b6be9" translate="yes" xml:space="preserve">
          <source>The Pig tutorial shows you how to run Pig scripts using Pig's local mode, mapreduce mode, Tez mode and Spark mode (see &lt;a href=&quot;#execution-modes&quot;&gt;Execution Modes&lt;/a&gt;).</source>
          <target state="translated">Pig 학습서에서는 Pig의 로컬 모드, mapreduce 모드, Tez 모드 및 Spark 모드를 사용하여 Pig 스크립트를 실행하는 방법을 보여줍니다 ( &lt;a href=&quot;#execution-modes&quot;&gt;실행 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="af8f2eee936d8de3441160c56079694edcecd438" translate="yes" xml:space="preserve">
          <source>The Pig version used.</source>
          <target state="translated">사용 된 Pig 버전.</target>
        </trans-unit>
        <trans-unit id="689e30c87e62d7e3049b4011e88254e2c3f9fcc7" translate="yes" xml:space="preserve">
          <source>The PigProgressNotificationListener interface was modified to add script id to all its methods.</source>
          <target state="translated">PigProgressNotificationListener 인터페이스는 모든 메소드에 스크립트 ID를 추가하도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8204e72fbf4fd68e41d7f906b395272f20ab4805" translate="yes" xml:space="preserve">
          <source>The PigRunner class mimics the behavior of the Main class but gives users a statistics object back. Optionally, you can call the API with an implementation of progress listener which will be invoked by Pig runtime during the execution.</source>
          <target state="translated">PigRunner 클래스는 Main 클래스의 동작을 모방하지만 사용자에게 통계 개체를 다시 제공합니다. 선택적으로, 실행 중에 Pig 런타임에 의해 호출되는 진행 리스너 구현으로 API를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e244d1f828a15276498050c3087784b1c4bcdb5" translate="yes" xml:space="preserve">
          <source>The PigStorage loader satisfies all of these conditions.</source>
          <target state="translated">PigStorage 로더는 이러한 모든 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="94132f71fa876caf035bd2757b2805d256e703ce" translate="yes" xml:space="preserve">
          <source>The Piggy Bank functions are currently distributed in source form. Users are required to checkout the code and build the package themselves. No binary distributions or nightly builds are available at this time.</source>
          <target state="translated">Piggy Bank 기능은 현재 소스 형식으로 배포됩니다. 사용자는 코드를 체크 아웃하고 패키지를 직접 빌드해야합니다. 현재 바이너리 배포판 또는 야간 빌드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="421d7539ee5054ee2e5b54f2ed391707a61b5b48" translate="yes" xml:space="preserve">
          <source>The Query Phrase Popularity script (script1-local.pig or script1-hadoop.pig) processes a search query log file from the Excite search engine and finds search phrases that occur with particular high frequency during certain times of the day.</source>
          <target state="translated">Query Phrase Popularity 스크립트 (script1-local.pig 또는 script1-hadoop.pig)는 Excite 검색 엔진에서 검색 쿼리 로그 파일을 처리하고 하루 중 특정 시간 동안 특정 빈도로 발생하는 검색 구를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2961800eaa230bb3267b513d83f582a5dc43ba6" translate="yes" xml:space="preserve">
          <source>The Register artifact command is an extension to the above register command used to &lt;a href=&quot;#register-jar&quot;&gt;register a jar&lt;/a&gt;. In addition to registering a jar from a local system or from hdfs, you can now specify the coordinates of the artifact and pig will download the artifact (and its dependencies if needed) from the configured repository.</source>
          <target state="translated">이슈 등록 명령 &lt;a href=&quot;#register-jar&quot;&gt;은 jar&lt;/a&gt; 를 등록하는 데 사용되는 위의 register 명령의 확장 입니다. 로컬 시스템 또는 hdfs에서 jar을 등록하는 것 외에도 이제 이슈의 좌표를 지정할 수 있으며 pig는 구성된 저장소에서 이슈 (및 필요한 경우 종속성)를 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="6d667f442bc6c142746d6ec9341d630be60d782a" translate="yes" xml:space="preserve">
          <source>The SUM function ignores NULL values.</source>
          <target state="translated">SUM 함수는 NULL 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="924dafcc69136f57276485da65797aa54feb3f72" translate="yes" xml:space="preserve">
          <source>The Temporal Query Phrase Popularity script (script2-local.pig or script2-hadoop.pig) processes a search query log file from the Excite search engine and compares the occurrence of frequency of search phrases across two time periods separated by twelve hours.</source>
          <target state="translated">Temporal Query Phrase Popularity 스크립트 (script2-local.pig 또는 script2-hadoop.pig)는 Excite 검색 엔진에서 검색 로그 파일을 처리하고 12 시간으로 구분 된 두 기간 동안의 검색 구문 빈도를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="86d14d4eb112e93654bebbe7991e5b76b03a5e41" translate="yes" xml:space="preserve">
          <source>The UUID for the script. All jobs spawned by the script have the same script ID.</source>
          <target state="translated">스크립트의 UUID입니다. 스크립트에 의해 생성 된 모든 작업은 동일한 스크립트 ID를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="25546ee388382eb96ecfceba757c5afd8568f75c" translate="yes" xml:space="preserve">
          <source>The Util.addToFunctionList function is a helper function that adds an entry to the list as the first argument, with the key of the class name passed as the second argument, and the schema containing two fields of the same type as the third argument.</source>
          <target state="translated">Util.addToFunctionList 함수는 클래스 이름의 키가 두 번째 인수로 전달되고 스키마가 세 번째 인수와 동일한 유형의 두 필드를 포함하는 첫 번째 인수로 목록에 항목을 추가하는 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="dabc5ee67bc4b1ce3173212af6c3a50c86ce7754" translate="yes" xml:space="preserve">
          <source>The ability to use invokers on methods that take array arguments makes methods like those in org.apache.commons.math.stat.StatUtils available (for processing the results of grouping your datasets, for example). This is helpful, but a word of caution: the resulting UDF will not be optimized for Hadoop, and the very significant benefits one gains from implementing the Algebraic and Accumulator interfaces are lost here. Be careful if you use invokers this way.</source>
          <target state="translated">배열 인수를 취하는 메소드에서 호출자를 사용하는 기능은 org.apache.commons.math.stat.StatUtils와 같은 메소드를 사용할 수있게합니다 (예 : 데이터 세트 그룹화 결과 처리). 이는 도움이되지만주의 할 점은 결과 UDF가 하둡에 최적화되지 않으며 대수 및 누산기 인터페이스를 구현함으로써 얻을 수있는 매우 큰 이점이 여기에서 사라진다는 것입니다. 이 방법으로 호출자를 사용하는 경우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="2a7e3abe9843497a5dedf8eda37dcd0b6788d459" translate="yes" xml:space="preserve">
          <source>The accumulate function is guaranteed to be called one or more times, passing one or more tuples in a bag, to the UDF. (Note that the tuple that is passed to the accumulator has the same content as the one passed to exec &amp;ndash; all the parameters passed to the UDF &amp;ndash; one of which should be a bag.)</source>
          <target state="translated">누적 함수는 하나 이상의 튜플을 백에있는 UDF로 전달하여 한 번 이상 호출되도록 보장합니다. (어큐뮬레이터로 전달되는 튜플은 exec로 전달 된 것과 동일한 내용 (UDF에 전달 된 모든 매개 변수) 중 하나는 백이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="71dccdeab40a27593746a990530dc28ca922638a" translate="yes" xml:space="preserve">
          <source>The actual function implementation is on lines 12-13 and is self-explanatory.</source>
          <target state="translated">실제 기능 구현은 12-13 행에 있으며 설명이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7bd6d10bdf8b2406035afb74481fb6a437d04397" translate="yes" xml:space="preserve">
          <source>The alias and type are separated by a colon ( : ).</source>
          <target state="translated">별명과 유형은 콜론 (:)으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="cd7036c07499560d6ac25405d46fa3971b3e3281" translate="yes" xml:space="preserve">
          <source>The alias associated with the job.</source>
          <target state="translated">작업과 연관된 별명.</target>
        </trans-unit>
        <trans-unit id="961f45dc189ffc800e0a27c8a5b929a4a1b7119c" translate="yes" xml:space="preserve">
          <source>The alias of the first relation is always taken as the alias of the unioned relation field.</source>
          <target state="translated">첫 번째 관계의 별명은 항상 결합 된 관계 필드의 별명으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae30d592b7526b49c34aeb5f851ab71499bc827" translate="yes" xml:space="preserve">
          <source>The amount of memory allocated to bags is determined by pig.cachedbag.memusage; the default is set to 20% (0.2) of available memory. Note that this memory is shared across all large bags used by the application.</source>
          <target state="translated">백에 할당 된 메모리 양은 pig.cachedbag.memusage에 의해 결정됩니다. 기본값은 사용 가능한 메모리의 20 % (0.2)로 설정되어 있습니다. 이 메모리는 응용 프로그램에서 사용하는 모든 큰 백에서 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="daf53ddfd0a5a132e57025d580a2b518a9854adf" translate="yes" xml:space="preserve">
          <source>The base64 encoded script text.</source>
          <target state="translated">base64로 인코딩 된 스크립트 텍스트</target>
        </trans-unit>
        <trans-unit id="25befff6ca430dcc18fca52ae8c02817149dbb4c" translate="yes" xml:space="preserve">
          <source>The behavior of schemas for UNION (positional notation / data types) and UNION ONSCHEMA (named fields / data types) is the same, except where noted.</source>
          <target state="translated">UNION (위치 표기법 / 데이터 유형) 및 UNION ONSCHEMA (명명 된 필드 / 데이터 유형)에 대한 스키마의 동작은 별도의 언급이없는 한 동일합니다.</target>
        </trans-unit>
        <trans-unit id="47dc5be5f75a53ab6bff98c75097dfb12b994b41" translate="yes" xml:space="preserve">
          <source>The bincond should be enclosed in parenthesis.</source>
          <target state="translated">bincond는 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc849cf6bf30515f76e2a8b9a6f0562fc02c73ea" translate="yes" xml:space="preserve">
          <source>The builtin TOKENIZE function shows how bags and tuples are created. A function takes a text string as input and returns a bag of words from the text. (Note that currently Pig bags always contain tuples.)</source>
          <target state="translated">내장 TOKENIZE 기능은 백과 튜플을 만드는 방법을 보여줍니다. 함수는 텍스트 문자열을 입력으로 받아서 텍스트에서 한 단어의 단어를 반환합니다. (현재 돼지 가방에는 항상 튜플이 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5f620099ec7995c7fa5318b0c83455118007de11" translate="yes" xml:space="preserve">
          <source>The cast relation can be used in any place where an expression of the type would make sense, including FOREACH, FILTER, and SPLIT. Note that if an explicit cast is not used an implict cast will be inserted according to Pig rules. Also, when the schema can't be inferred bytearray is used.</source>
          <target state="translated">캐스트 관계는 FOREACH, FILTER 및 SPLIT을 포함하여 유형의 표현이 적합한 모든 위치에서 사용할 수 있습니다. 명시 적 캐스트를 사용하지 않으면 Pig 규칙에 따라 묵시적 캐스트가 삽입됩니다. 또한 스키마를 유추 할 수없는 경우 바이트 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a745e008b44cb6672d71089b4191b207599c2b96" translate="yes" xml:space="preserve">
          <source>The character being searched for, in quotes.</source>
          <target state="translated">검색중인 문자가 따옴표로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="02904bf591367c849418b0a0ff48d504fcc44a2d" translate="yes" xml:space="preserve">
          <source>The clauses (input, output, ship, cache, stderr) are described below. Note the following:</source>
          <target state="translated">절 (입력, 출력, 배송, 캐시, stderr)이 아래에 설명되어 있습니다. 다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="7b691cb7dc8838e0e723ed7f2a11a09e961065d4" translate="yes" xml:space="preserve">
          <source>The clauses can be specified in any order (for example, stderr can appear before input)</source>
          <target state="translated">절은 임의의 순서로 지정할 수 있습니다 (예 : stderr은 입력 전에 나타날 수 있음)</target>
        </trans-unit>
        <trans-unit id="5cfeea9808d6d409d79501a06d5d7fb9919e1fe1" translate="yes" xml:space="preserve">
          <source>The cleanup function is called after getValue but before the next value is processed.</source>
          <target state="translated">정리 함수는 getValue 이후에 다음 값이 처리되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a985305196616cb67f7cee136335e4fd82f83473" translate="yes" xml:space="preserve">
          <source>The combiner is also not used in the case where multiple FOREACH statements are associated with the same GROUP:</source>
          <target state="translated">또한 여러 FOREACH 문이 동일한 GROUP과 연관되어있는 경우에는 결합기가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1af751939ca8d20b053bd3e49ec9aec7637d33e9" translate="yes" xml:space="preserve">
          <source>The combiner is also used with a nested foreach as long as the only nested operation used is DISTINCT (see &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt; and &lt;a href=&quot;basic#nestedblock&quot;&gt;Example: Nested Block&lt;/a&gt;).</source>
          <target state="translated">결합기 (combiner)는 사용 된 유일한 중첩 연산이 DISTINCT 인 한 중첩 된 foreach와 함께 사용됩니다 ( &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt; 및 &lt;a href=&quot;basic#nestedblock&quot;&gt;예 : 중첩 블록 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9ff17c0b76cb161de8d789a5ccb2cb23c00c86d" translate="yes" xml:space="preserve">
          <source>The combiner is generally not used if there is any operator that comes between the GROUP and FOREACH statements in the execution plan. Even if the statements are next to each other in your script, the optimizer might rearrange them. In this example, the optimizer will push FILTER above FOREACH which will prevent the use of the combiner:</source>
          <target state="translated">실행 계획에서 GROUP 문과 FOREACH 문 사이에 오는 연산자가있는 경우 결합기는 일반적으로 사용되지 않습니다. 스크립트에서 명령문이 나란히 있어도 옵티마이 저가이를 다시 정렬 할 수 있습니다. 이 예에서 옵티마이 저는 FILTER를 FOREACH 위로 푸시하여 컴 바이 너 사용을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="0b6ecddb31ac485fcabc77393f1e1c236d41595a" translate="yes" xml:space="preserve">
          <source>The combiner is generally used in the case of non-nested foreach where all projections are either expressions on the group column or expressions on algebraic UDFs (see &lt;a href=&quot;#algebraic-interface&quot;&gt;Make Your UDFs Algebraic&lt;/a&gt;).</source>
          <target state="translated">결합기는 일반적으로 모든 투영이 그룹 열의 표현이거나 대수 UDF의 표현 인 중첩되지 않은 foreach의 경우에 사용됩니다 ( &lt;a href=&quot;#algebraic-interface&quot;&gt;UDF 대수 만들기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7050f06b64b7b7af712b170f0a4b71330723f016" translate="yes" xml:space="preserve">
          <source>The command below can be used to run the script. Note that all examples in this document run in local mode for simplicity but the examples can also run in Tez local/Mapreduce/ Tez mode. For more information on how to run Pig, please see the PigTutorial.</source>
          <target state="translated">아래 명령을 사용하여 스크립트를 실행할 수 있습니다. 이 문서의 모든 예제는 간략화를 위해 로컬 모드에서 실행되지만 예제는 Tez 로컬 / Mapreduce / Tez 모드에서 실행될 수도 있습니다. Pig를 실행하는 방법에 대한 자세한 내용은 PigTutorial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e08016e762cabc2a163b497df86ea9a44c478bb" translate="yes" xml:space="preserve">
          <source>The command line used to invoke the script.</source>
          <target state="translated">스크립트를 호출하는 데 사용되는 명령 줄입니다.</target>
        </trans-unit>
        <trans-unit id="5aeedb64e21f5bff6a83dea4c6ce4c6f802a7e27" translate="yes" xml:space="preserve">
          <source>The constituents of the tuple, where the schema definition rules for the corresponding type applies to the constituents of the tuple:</source>
          <target state="translated">해당 유형의 스키마 정의 규칙이 튜플의 구성 요소에 적용되는 튜플의 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="f2d30e73274c0623d48dfefb1f91423329763894" translate="yes" xml:space="preserve">
          <source>The constructor for the function takes string parameters. If you need to use different constructor parameters for different calls to the function you will need to create multiple defines &amp;ndash; one for each parameter set.</source>
          <target state="translated">함수의 생성자는 문자열 매개 변수를 사용합니다. 함수를 호출 할 때마다 다른 생성자 매개 변수를 사용해야하는 경우 각 매개 변수 세트마다 하나씩 여러 정의를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="76f80575e86c3d5ab7aaa3a6be00889c64f473d6" translate="yes" xml:space="preserve">
          <source>The contents of the Pig tutorial file (pigtutorial.tar.gz) are described here.</source>
          <target state="translated">Pig 튜토리얼 파일 (pigtutorial.tar.gz)의 내용이 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45e95823e60e9ef4269dfbc5e21c0025f3c3965" translate="yes" xml:space="preserve">
          <source>The currently supported options are:</source>
          <target state="translated">현재 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fed1b3fe234976d72f281be07834f9b3a2b2d552" translate="yes" xml:space="preserve">
          <source>The data passed back and forth between Pig and Groovy goes through a conversion process. The following conversions rules are applied:</source>
          <target state="translated">Pig와 Groovy간에주고받는 데이터는 변환 프로세스를 거칩니다. 다음과 같은 변환 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5674c2277cf5768b9a8e053e5890d5201a185af" translate="yes" xml:space="preserve">
          <source>The data type definitions for tuples, bags, and maps apply to constants:</source>
          <target state="translated">튜플, 백 및 맵에 대한 데이터 유형 정의는 상수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0baef58c149ad1ccf8c0b0a5e7993741c0c3d947" translate="yes" xml:space="preserve">
          <source>The data type you want to cast to, enclosed in parentheses. You can cast to any data type except bytearray (see the table above).</source>
          <target state="translated">캐스트하려는 데이터 유형은 괄호로 묶습니다. 바이트 배열을 제외한 모든 데이터 유형으로 캐스트 할 수 있습니다 (위 표 참조).</target>
        </trans-unit>
        <trans-unit id="3b55617614914b59dce83e9a7d429880bbef1e0a" translate="yes" xml:space="preserve">
          <source>The datatypes of the columns are declared with the &quot;AS&quot; clause. In this example, the row key, which is the unique airport code is assigned to the &quot;code&quot; variable while all of the other columns are placed into the map. When there is a non-empty column qualifier, the key in that map will have a colon which separates which portion of the key came from the column family and which portion came from the column qualifier. The Accumulo value is placed in the Map value.</source>
          <target state="translated">열의 데이터 유형은 &quot;AS&quot;절로 선언됩니다. 이 예에서는 고유 공항 코드 인 행 키가 &quot;code&quot;변수에 할당되고 다른 모든 열은 맵에 배치됩니다. 비어 있지 않은 열 한정자가있는 경우 해당 맵의 키에는 키의 어느 부분이 열 패밀리에서 왔는지와 어떤 부분이 열 한정자에서 왔는지 구분하는 콜론이 있습니다. Accumulo 값은 맵 값에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="95b65b61b6cc56b225c89b5027e606d0f1693ea5" translate="yes" xml:space="preserve">
          <source>The datatypes of the columns are declared with the &quot;AS&quot; clause. The first_name and last_name columns are specified as fully qualified column names with a chararray datatype. The third specification of tags:work_* requests a set of columns in the tags column family that begin with &quot;work_&quot;. There can be zero, one or more columns of that type in the HBase table. The type is specified as tags_map:map[]. This indicates that the set of column values returned will be accessed as a map, where the key is the column name and the value is the cell value of the column. The fourth column specification is also a map of column descriptors to cell values.</source>
          <target state="translated">열의 데이터 유형은 &quot;AS&quot;절로 선언됩니다. first_name 및 last_name 컬럼은 chararray 데이터 유형의 완전한 컬럼 이름으로 지정됩니다. tags : work_ *의 세 번째 사양은 &quot;work_&quot;로 시작하는 태그 열 패밀리의 열 세트를 요청합니다. HBase 테이블에 해당 유형의 열이 하나 이상있을 수 있습니다. 유형은 tags_map : map []로 지정됩니다. 이는 리턴 된 열 값 세트가 맵으로 액세스됨을 나타냅니다. 여기서 키는 열 이름이고 값은 열의 셀 값입니다. 네 번째 열 스펙은 또한 열 설명자를 셀 값에 대한 맵입니다.</target>
        </trans-unit>
        <trans-unit id="15f536d899c03fdeea22541e53ddda46ac77489e" translate="yes" xml:space="preserve">
          <source>The date time format pattern string (see &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html&quot;&gt;Java SimpleDateFormat class&lt;/a&gt;).</source>
          <target state="translated">날짜 시간 형식 패턴 문자열 ( &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html&quot;&gt;Java SimpleDateFormat 클래스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="ddf671ad0082b927df5e0be9183e343061ba927f" translate="yes" xml:space="preserve">
          <source>The datetime string in the &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601 format&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 8601 형식&lt;/a&gt; 의 날짜 / 시간 문자열 입니다 .</target>
        </trans-unit>
        <trans-unit id="a240ef33a21f178cba72ae95e764f44480d5817c" translate="yes" xml:space="preserve">
          <source>The datetime string in the user defined format.</source>
          <target state="translated">사용자 정의 형식의 날짜 시간 문자열</target>
        </trans-unit>
        <trans-unit id="a0bb48259dc736b00cd689493b41bf550b127833" translate="yes" xml:space="preserve">
          <source>The declare statement is processed prior to running the Pig script.</source>
          <target state="translated">선언문은 Pig 스크립트를 실행하기 전에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="77bbd5152137f280ee30434b3a3590c7f3066bf0" translate="yes" xml:space="preserve">
          <source>The default field delimiter is tab ('\t').</source>
          <target state="translated">기본 필드 구분 기호는 탭 ( '\ t')입니다.</target>
        </trans-unit>
        <trans-unit id="b9b8cc5ef14c0a376a676a656e63bd01b0e4c66b" translate="yes" xml:space="preserve">
          <source>The default handling of complex elements works, but probably isn't what you want.</source>
          <target state="translated">복잡한 요소의 기본 처리는 작동하지만 원하는 것은 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="f72f961e8f75f7259970edc3cf5669f6612c033e" translate="yes" xml:space="preserve">
          <source>The default reducer estimation algorithm described above can be overridden by setting the pig.exec.reducer.estimator parameter to the fully qualified class name of an implementation of &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigReducerEstimator.java&quot;&gt;org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigReducerEstimator&lt;/a&gt;(MapReduce) or &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/TezOperDependencyParallelismEstimator.java&quot;&gt;org.apache.pig.backend.hadoop.executionengine.tez.plan.optimizer.TezOperDependencyParallelismEstimator&lt;/a&gt;(Tez). The class must exist on the classpath of the process submitting the Pig job. If the pig.exec.reducer.estimator.arg parameter is set, the value will be passed to a constructor of the implementing class that takes a single String.</source>
          <target state="translated">pig.exec.reducer.estimator 매개 변수를 &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigReducerEstimator.java&quot;&gt;org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigReducerEstimator&lt;/a&gt; (MapReduce) 구현의 완전한 클래스 이름으로 설정하여 위에서 설명한 기본 감속기 추정 알고리즘을 대체 할 수 있습니다. &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/TezOperDependencyParallelismEstimator.java&quot;&gt;org.apache.pig.backend.hadoop.executionengine.tez.plan.optimizer.TezOperDependencyParallelismEstimator&lt;/a&gt; (Tez). Pig 작업을 제출하는 프로세스의 클래스 경로에 클래스가 존재해야합니다. pig.exec.reducer.estimator.arg 매개 변수가 설정되면 단일 문자열을 사용하는 구현 클래스의 생성자로 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ab98e16313b515db50be8164befc578d482fb376" translate="yes" xml:space="preserve">
          <source>The default statement is processed prior to running the Pig script.</source>
          <target state="translated">기본 스크립트는 Pig 스크립트를 실행하기 전에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="60d34c5b86043b38e82c072cc2dac898004553ae" translate="yes" xml:space="preserve">
          <source>The default string conversion is applied to each element. If the bags contents are not atoms (tuple, map, etc), this may be not be what you want. Use a nested FOREACH to format values and then compose them with BagToString as shown below</source>
          <target state="translated">기본 문자열 변환이 각 요소에 적용됩니다. 백 내용이 원자가 아닌 경우 (튜플, 맵 등), 이것이 원하는 것이 아닐 수도 있습니다. 중첩 된 FOREACH를 사용하여 값을 형식화 한 후 아래와 같이 BagToString으로 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6dc765878975c5dff8e47b9674c784df20c00c45" translate="yes" xml:space="preserve">
          <source>The designation for a bag, a set of curly brackets.</source>
          <target state="translated">가방의 명칭, 중괄호 세트.</target>
        </trans-unit>
        <trans-unit id="10c83875aebac0b1cad4803f7df5380d9c892081" translate="yes" xml:space="preserve">
          <source>The designation for a map, a set of straight brackets [ ].</source>
          <target state="translated">지도의 지정, 직선 괄호 세트 [].</target>
        </trans-unit>
        <trans-unit id="57133fc0829e5a94de7fda36b622528342a5990e" translate="yes" xml:space="preserve">
          <source>The designation for a tuple, a set of parentheses.</source>
          <target state="translated">튜플, 괄호 세트의 지정.</target>
        </trans-unit>
        <trans-unit id="190983249dd11cb759541678d2e7ea388ade3c8e" translate="yes" xml:space="preserve">
          <source>The designator for a tuple.</source>
          <target state="translated">튜플의 지정자.</target>
        </trans-unit>
        <trans-unit id="dac1bc551ab3e438ce56a900fdb637dba39438c1" translate="yes" xml:space="preserve">
          <source>The duration string in &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 format&lt;/a&gt;.</source>
          <target state="translated">의 기간 문자열 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 형식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94db26b122e7f3572e60484dc1f3fca5a2ffdc2c" translate="yes" xml:space="preserve">
          <source>The elements must comply with map type rules:</source>
          <target state="translated">요소는지도 유형 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="2cc342c44a608dfb6dbe166eddb07dfb1d377ead" translate="yes" xml:space="preserve">
          <source>The example above covers a reasonably simple case where the UDF only takes one parameter and there is a separate function for each parameter type. However, this will not always be the case. If Pig can't find an exact match it tries to do a best match. The rule for the best match is to find the most efficient function that can be used safely. This means that Pig must find the function that, for each input parameter, provides the smallest type that is equal to or greater than the input type. The type progression rules are: int&amp;gt;long&amp;gt;float&amp;gt;double.</source>
          <target state="translated">위의 예는 UDF가 하나의 매개 변수 만 취하고 각 매개 변수 유형마다 별도의 기능이있는 상당히 간단한 경우를 다룹니다. 그러나 항상 그런 것은 아닙니다. Pig가 정확히 일치하는 것을 찾지 못하면 최상의 일치를 시도합니다. 가장 일치하는 규칙은 안전하게 사용할 수있는 가장 효율적인 기능을 찾는 것입니다. 즉, Pig는 각 입력 매개 변수에 대해 입력 유형보다 크거나 같은 가장 작은 유형을 제공하는 기능을 찾아야합니다. 타입 진행 규칙은 int&amp;gt; long&amp;gt; float&amp;gt; double입니다.</target>
        </trans-unit>
        <trans-unit id="065153fc3f26ece884bef31714cf79cef650054c" translate="yes" xml:space="preserve">
          <source>The example above shows how to create an output schema for a tuple. Doing this for a bag is very similar. Let's extend the TOKENIZE function to do that.</source>
          <target state="translated">위의 예는 튜플에 대한 출력 스키마를 생성하는 방법을 보여줍니다. 가방 에이 작업을 수행하는 것은 매우 유사합니다. 이를 위해 TOKENIZE 함수를 확장 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ba68018acaa9c2801f84b1aa1846a8a4f0a644b0" translate="yes" xml:space="preserve">
          <source>The example below uses the IsEmpy builtin filter function to implement joins.</source>
          <target state="translated">아래 예제는 IsEmpy 내장 필터 기능을 사용하여 조인을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f50d60613b5474a30f518170fa17e4af90054c9b" translate="yes" xml:space="preserve">
          <source>The example included here computes the top N of the most common queries. The Pig script, top_queries.pig, is similar to the &lt;a href=&quot;start#pig-script-1&quot;&gt;Query Phrase Popularity&lt;/a&gt; in the Pig tutorial. It expects an input a file of queries and a parameter n (n is 2 in our case in order to do a top 2).</source>
          <target state="translated">여기에 포함 된 예제는 가장 일반적인 쿼리 중 상위 N 개를 계산합니다. Pig 스크립트 top_queries.pig 는 Pig 튜토리얼 의 &lt;a href=&quot;start#pig-script-1&quot;&gt;Query Phrase Popularity&lt;/a&gt; 와 유사합니다 . 쿼리 파일과 매개 변수 n (입력은 상위 2를 수행하기 위해 n은 2입니다)을 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8bee8ca2e8872dcd7536e2ad3acfa2bc2d5b661" translate="yes" xml:space="preserve">
          <source>The field can be represented by positional notation or by name (alias). For example, if f1 is the first field and type int, you can cast to type long using (long)$0 or (long)f1.</source>
          <target state="translated">필드는 위치 표기법 또는 이름 (별칭)으로 표시 할 수 있습니다. 예를 들어, f1이 첫 번째 필드이고 int 유형 인 경우 (long) $ 0 또는 (long) f1을 사용하여 long을 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650cd3adca66519216bb09c82bfde27f7f47ba47" translate="yes" xml:space="preserve">
          <source>The field whose type you want to change.</source>
          <target state="translated">유형을 변경하려는 필드입니다.</target>
        </trans-unit>
        <trans-unit id="e74613ba69c8db5a7cb490d9c2498357e3d5ec08" translate="yes" xml:space="preserve">
          <source>The fields to apply the pluck to, usually '*'</source>
          <target state="translated">뽑기를 적용 할 필드, 일반적으로 '*'</target>
        </trans-unit>
        <trans-unit id="713c9fad65bae7bcd90ee8feef4b71b35dbd17c6" translate="yes" xml:space="preserve">
          <source>The first field is named &quot;group&quot; (do not confuse this with the GROUP operator) and is the same type as the group key.</source>
          <target state="translated">첫 번째 필드의 이름은 &quot;group&quot;이며 (GROUP 연산자와 혼동하지 마십시오) 그룹 키와 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c6f0351c5528c43ab8214561494ca4b392a6104" translate="yes" xml:space="preserve">
          <source>The first foreach statement does not contain flatten.</source>
          <target state="translated">첫 번째 foreach 문에는 병합이 없습니다.</target>
        </trans-unit>
        <trans-unit id="759df96ee6c3b575061e92de5790670dc89eac6f" translate="yes" xml:space="preserve">
          <source>The first line of the script provides the location of the jar file that contains the UDF. (Note that there are no quotes around the jar file. Having quotes would result in a syntax error.) To locate the jar file, Pig first checks the classpath. If the jar file can't be found in the classpath, Pig assumes that the location is either an absolute path or a path relative to the location from which Pig was invoked. If the jar file can't be found, an error will be printed: java.io.IOException: Can't read jar file: myudfs.jar.</source>
          <target state="translated">스크립트의 첫 번째 행은 UDF를 포함하는 jar 파일의 위치를 ​​제공합니다. jar 파일 주위에 따옴표가 없습니다. 따옴표를 사용하면 구문 오류가 발생합니다. jar 파일을 찾기 위해 Pig는 먼저 클래스 경로를 확인합니다. jar 파일을 클래스 경로에서 찾을 수 없으면 Pig는 위치가 절대 경로이거나 Pig가 호출 된 위치에 상대적인 경로라고 가정합니다. jar 파일을 찾을 수 없으면 오류가 인쇄됩니다. java.io.IOException : jar 파일을 읽을 수 없습니다 : myudfs.jar.</target>
        </trans-unit>
        <trans-unit id="8dea781ad20f45fe726b12b25fc2080f619924d9" translate="yes" xml:space="preserve">
          <source>The first parameter of DEFINE statement is an alias of the function. The second parameter is the fully-qualified name of the function. After the statement, you can call the function using the alias instead of the fually-qualified name.</source>
          <target state="translated">DEFINE 문의 첫 번째 매개 변수는 함수의 별명입니다. 두 번째 매개 변수는 함수의 완전한 이름입니다. 명령문 후, fually 규정 된 이름 대신 별명을 사용하여 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f26f51c1f5369b6909c811408740a02811b09e6" translate="yes" xml:space="preserve">
          <source>The first query is clearly more efficient than the second one because it reduces the amount of data going into the join.</source>
          <target state="translated">첫 번째 쿼리는 두 번째 쿼리보다 훨씬 효율적입니다. 조인에 들어가는 데이터 양이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6731fbd6e6497448c69f865d493f8f3f85593dc0" translate="yes" xml:space="preserve">
          <source>The first step to improving performance and efficiency is measuring where the time is going. Pig provides a light-weight method for approximately measuring how much time is spent in different user-defined functions (UDFs) and Loaders. Simply set the pig.udf.profile property to true. This will cause new counters to be tracked for all Map-Reduce jobs generated by your script: approx_microsecs measures the approximate amount of time spent in a UDF, and approx_invocations measures the approximate number of times the UDF was invoked. In addition, the frequency of profiling can be configured via the pig.udf.profile.frequency (by default, every 100th invocation). Note that this may produce a large number of counters (two per UDF). Excessive amounts of counters can lead to poor JobTracker performance, so use this feature carefully, and preferably on a test cluster.</source>
          <target state="translated">성능과 효율성을 향상시키는 첫 번째 단계는 시간이 어디로 가고 있는지 측정하는 것입니다. Pig는 다양한 사용자 정의 함수 (UDF)와 로더에서 소요되는 시간을 대략적으로 측정하기위한 간단한 방법을 제공합니다. pig.udf.profile 특성을 true로 설정하십시오. 그러면 스크립트에 의해 생성 된 모든 Map-Reduce 작업에 대해 새 카운터가 추적됩니다. approx_microsecs는 UDF에 소요 된 대략적인 시간을 측정하고 approx_invocations는 UDF가 호출 된 대략적인 횟수를 측정합니다. 또한, 프로파일 링 빈도는 pig.udf.profile.frequency (기본적으로 100 번째 호출마다)를 통해 구성 할 수 있습니다. 이로 인해 많은 수의 카운터가 생성 될 수 있습니다 (UDF 당 2 개). 카운터가 너무 많으면 JobTracker 성능이 저하 될 수 있으므로이 기능을주의해서 사용하십시오.바람직하게는 테스트 클러스터에서.</target>
        </trans-unit>
        <trans-unit id="91c1a89f76e62e5d3211b77508e9e3868ad2369e" translate="yes" xml:space="preserve">
          <source>The first thing to decide is what to do with invalid data. This depends on the format of the data. If the data is of type bytearray it means that it has not yet been converted to its proper type. In this case, if the format of the data does not match the expected type, a NULL value should be returned. If, on the other hand, the input data is of another type, this means that the conversion has already happened and the data should be in the correct format. This is the case with our example and that's why it throws an error (line 15.)</source>
          <target state="translated">가장 먼저 결정해야 할 것은 유효하지 않은 데이터로 무엇을해야하는지입니다. 이것은 데이터 형식에 따라 다릅니다. 데이터가 bytearray 유형 인 경우 아직 올바른 유형으로 변환되지 않았 음을 의미합니다. 이 경우 데이터 형식이 예상 형식과 일치하지 않으면 NULL 값이 반환되어야합니다. 반면에 입력 데이터가 다른 유형 인 경우 변환이 이미 발생했으며 데이터의 형식이 올바른 것입니다. 이것은 우리의 예에서 그렇기 때문에 오류가 발생하는 이유입니다 (15 행).</target>
        </trans-unit>
        <trans-unit id="ac053b0e4dc04b11b42d3ae1d3c190632a1a460f" translate="yes" xml:space="preserve">
          <source>The following conditions apply:</source>
          <target state="translated">다음 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d15c15ac17006302ec0e81b03a5fa073b666f30" translate="yes" xml:space="preserve">
          <source>The following entries are included in job conf:</source>
          <target state="translated">다음과 같은 항목이 작업 conf에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2da0cbf40a5dd1c01ac5cfafc62c8a7864ee7605" translate="yes" xml:space="preserve">
          <source>The following example defines an Accumulator UDF named 'sumacc':</source>
          <target state="translated">다음 예제는 'sumacc'라는 누적 기 UDF를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cfc2eedb81e3bb439248b9830a86eddb7193315c" translate="yes" xml:space="preserve">
          <source>The following methods have default implementations in LoadFunc and should be overridden only if needed:</source>
          <target state="translated">다음 메소드는 LoadFunc에 기본 구현이 있으며 필요한 경우에만 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f24ad213f3825cfcad61330f10a662ff05ea4c16" translate="yes" xml:space="preserve">
          <source>The following methods have default implementations in StoreFunc and should be overridden only if necessary:</source>
          <target state="translated">다음 메소드는 StoreFunc에 기본 구현이 있으며 필요한 경우에만 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="9abc6b7254a2508658695840b2d17bfafa6bfc3d" translate="yes" xml:space="preserve">
          <source>The following parameter control the behavior of automatic parallelism in Tez (share with MapReduce):</source>
          <target state="translated">다음 매개 변수는 Tez (MapReduce와 공유)에서 자동 병렬 처리의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b4689772fb51f336f70067789e592925d2795a16" translate="yes" xml:space="preserve">
          <source>The following precedence order is supported: pig.properties &amp;lt; -D Pig property &amp;lt; -P properties file &amp;lt; set command. This means that if the same property is provided using the &amp;ndash;D command line option as well as the &amp;ndash;P command line option (properties file), the value of the property in the properties file will take precedence.</source>
          <target state="translated">다음 우선 순위 순서가 지원됩니다. pig.properties &amp;lt;-D Pig 특성 &amp;lt;-P properties file &amp;lt;set 명령. 이는 &amp;ndash;P 명령 행 옵션 (속성 파일)뿐만 아니라 &amp;ndash;D 명령 행 옵션을 사용하여 동일한 특성이 제공되는 경우 특성 파일의 특성 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="607a6cf59793512c0410e03ddecbfcf6f9c9a6ec" translate="yes" xml:space="preserve">
          <source>The following syntax is also supported, where myfuncs is the namespace created for all the functions inside test.groovy.</source>
          <target state="translated">다음 구문도 지원됩니다. 여기서 myfuncs는 test.groovy 내의 모든 함수에 대해 작성된 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="c150e917fc6d51c12d7b42a939633b2409f0aca0" translate="yes" xml:space="preserve">
          <source>The following syntax is also supported, where myfuncs is the namespace created for all the functions inside test.js.</source>
          <target state="translated">다음 구문도 지원됩니다. 여기서 myfuncs는 test.js 내의 모든 함수에 대해 작성된 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="869a8d0d0991f61ac9835e73d2e5b4ad965a5a5a" translate="yes" xml:space="preserve">
          <source>The following syntax is also supported, where myfuncs is the namespace created for all the functions inside test.py.</source>
          <target state="translated">다음 구문도 지원됩니다. 여기서 myfuncs는 test.py 내의 모든 함수에 대해 작성된 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="cf544e02879064cb91372e0a9ec0c0b988c505a0" translate="yes" xml:space="preserve">
          <source>The foreach statement should not change the position of the join keys.</source>
          <target state="translated">foreach 문은 조인 키의 위치를 ​​변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bd5a0c93012b9a47ca79fab8a12cc82dfdaba211" translate="yes" xml:space="preserve">
          <source>The foreach statements are consecutive.</source>
          <target state="translated">foreach 문은 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="ee78caae506e35bf2ba652d67ad3eb216e99c6dd" translate="yes" xml:space="preserve">
          <source>The formats for complex data types are shown here:</source>
          <target state="translated">복잡한 데이터 형식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="559e21c5974bdf82b8f7c34508098a47b64530ec" translate="yes" xml:space="preserve">
          <source>The formula, shown below, is very simple and will improve over time. The computed value takes all inputs within the script into account and applies the computed value to all the jobs within Pig script.</source>
          <target state="translated">아래에 표시된 공식은 매우 간단하며 시간이 지남에 따라 개선됩니다. 계산 된 값은 스크립트 내의 모든 입력을 고려하여 계산 된 값을 Pig 스크립트 내의 모든 작업에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="13a7115c690bc1e9bc8963b80a67d2f6fb4b0ad9" translate="yes" xml:space="preserve">
          <source>The function creates a schema with a single field (of type FieldSchema) of type tuple. The name of the field is constructed using the getSchemaName function of the EvalFunc class. The name consists of the name of the UDF function, the first parameter passed to it, and a sequence number to guarantee uniqueness. In the previous script, if you replace dump D; with describe B; , you will see the following output:</source>
          <target state="translated">이 함수는 tuple 유형의 단일 필드 (FieldSchema 유형)로 스키마를 작성합니다. 필드 이름은 EvalFunc 클래스의 getSchemaName 함수를 사용하여 구성됩니다. 이름은 UDF 함수의 이름, 전달 된 첫 번째 매개 변수 및 고유성을 보장하는 시퀀스 번호로 구성됩니다. 이전 스크립트에서 덤프 D를 교체하면; 설명 B와 함께; , 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fea045e3a67bec10cd122eba01481fe38b6dce7a" translate="yes" xml:space="preserve">
          <source>The function has a long package name that you don't want to include in a script, especially if you call the function several times in that script.</source>
          <target state="translated">함수는 스크립트에 포함하지 않으려는 긴 패키지 이름을 가지고 있습니다. 특히 해당 스크립트에서 함수를 여러 번 호출하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="00f5879eb8bda3f680cf575cd6c5e27e8d8f03d4" translate="yes" xml:space="preserve">
          <source>The function provided in this example takes an ASCII string and produces its uppercase version. If you are familiar with column transformation functions in SQL, you will recognize that UPPER fits this concept. However, as we will see later in the document, eval functions in Pig go beyond column transformation functions and include aggregate and filter functions.</source>
          <target state="translated">이 예제에서 제공되는 함수는 ASCII 문자열을 사용하여 대문자 버전을 생성합니다. SQL의 열 변환 함수에 익숙하면 UPPER가이 개념에 적합 함을 알 수 있습니다. 그러나이 문서의 뒷부분에서 볼 수 있듯이 Pig의 평가 함수는 열 변환 함수를 넘어 집계 및 필터 함수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7dc74ce0d40143a72e502fc2614d5b4772e47b21" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;a href=&quot;#PigStats-Object&quot;&gt;PigStats object&lt;/a&gt; that tells you whether the run succeeded or failed. In case of success, additional run statistics are provided.</source>
          <target state="translated">이 함수는 실행의 성공 여부를 알려주 는 &lt;a href=&quot;#PigStats-Object&quot;&gt;PigStats 객체&lt;/a&gt; 를 반환합니다 . 성공한 경우 추가 실행 통계가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0976e8646e055ac0d63efc37991610717ef92d67" translate="yes" xml:space="preserve">
          <source>The function returns a string that corresponds to the matched group in the position specified by the index. If there is no matched expression at that position, NULL is returned.</source>
          <target state="translated">이 함수는 인덱스로 지정된 위치에서 일치하는 그룹에 해당하는 문자열을 반환합니다. 해당 위치에 일치하는 표현식이 없으면 NULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c4e7bd8c40736174965e80e009871120dfdfd5a0" translate="yes" xml:space="preserve">
          <source>The function returns a tuple where each field represents a matched expression. If there is no match, an empty tuple is returned.</source>
          <target state="translated">이 함수는 각 필드가 일치하는 표현식을 나타내는 튜플을 반환합니다. 일치하는 것이 없으면 빈 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="336fed6e10abdf5a6b9c9d78f02ebfc996979ed2" translate="yes" xml:space="preserve">
          <source>The function returns tuples which are placed in a bag. Each tuple only contains one field which represents a matched expression.</source>
          <target state="translated">이 함수는 백에 배치 된 튜플을 반환합니다. 각 튜플에는 일치하는 표현식을 나타내는 하나의 필드 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9d48fce1e99479b57ea799b99ac307783856867c" translate="yes" xml:space="preserve">
          <source>The function, including the schema, looks like this:</source>
          <target state="translated">스키마를 포함한 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76c66fae137b1646b34f8efb86731b18ab7fd53b" translate="yes" xml:space="preserve">
          <source>The getValue function is called after all the tuples for a particular key have been processed to retrieve the final value.</source>
          <target state="translated">getValue 함수는 특정 키에 대한 모든 튜플이 처리되어 최종 값을 검색 한 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bb16918bd3782e6c2979a4461139cc1481db317a" translate="yes" xml:space="preserve">
          <source>The help command prints a list of Pig commands or properties.</source>
          <target state="translated">help 명령은 Pig 명령 또는 속성 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14d7b70d3a90eef7ddda698dcf9175e133af72d2" translate="yes" xml:space="preserve">
          <source>The history command shows the statements used so far.</source>
          <target state="translated">history 명령은 지금까지 사용한 명령문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="62cfc09e617a0f30c16c10e2c443df7e44481ad3" translate="yes" xml:space="preserve">
          <source>The implementation assumes that both bags being passed to the SUBTRACT function will fit &lt;strong&gt;entirely into memory&lt;/strong&gt; simultaneously, if this is not the case, SUBTRACT will still function but will be &lt;strong&gt;very&lt;/strong&gt; slow.</source>
          <target state="translated">구현에서는 SUBTRACT 함수로 전달되는 두 백이 동시에 &lt;strong&gt;메모리&lt;/strong&gt; 에 &lt;strong&gt;완전히 들어&lt;/strong&gt; 맞는 것으로 가정합니다. 그렇지 않은 경우 SUBTRACT는 여전히 작동하지만 &lt;strong&gt;매우&lt;/strong&gt; 느립니다.</target>
        </trans-unit>
        <trans-unit id="e10b4c14d17601d7364505b9b4056eda675aaaf1" translate="yes" xml:space="preserve">
          <source>The implementation of the IsEmpty function looks like this:</source>
          <target state="translated">IsEmpty 함수의 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4da4533e9fc2b07b513e832533ce0c8f3c9b9df" translate="yes" xml:space="preserve">
          <source>The implementation uses Hadoop's bloom filters (org.apache.hadoop.util.bloom.BloomFilter) internally.</source>
          <target state="translated">이 구현은 내부적으로 Hadoop의 블룸 필터 (org.apache.hadoop.util.bloom.BloomFilter)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff41b518d9aee4b935b38ee99f120f236f5d05fa" translate="yes" xml:space="preserve">
          <source>The index (type integer) of the character &lt;em&gt;following&lt;/em&gt; the last character of the substring.</source>
          <target state="translated">부분 문자열의 마지막 문자 &lt;em&gt;다음에 오는&lt;/em&gt; 문자의 색인 (정수) .</target>
        </trans-unit>
        <trans-unit id="fd02a827918ab164ac806ae6dc11fffce6395458" translate="yes" xml:space="preserve">
          <source>The index (type integer) of the first character of the substring.</source>
          <target state="translated">부분 문자열의 첫 번째 문자의 인덱스 (정수).</target>
        </trans-unit>
        <trans-unit id="c8b14fbba8cc3ff8307b9b23a023ddf4a0835196" translate="yes" xml:space="preserve">
          <source>The index from which to begin the forward search.</source>
          <target state="translated">정방향 검색을 시작할 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="9bc60800e40bd9a2de2a28ac754a79fbc655f0d6" translate="yes" xml:space="preserve">
          <source>The index of a string begins with zero (0).</source>
          <target state="translated">문자열의 인덱스는 0으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="faf37c00cba0abbef5e0507a9cad8eea454406a9" translate="yes" xml:space="preserve">
          <source>The index of the matched group to return.</source>
          <target state="translated">리턴 할 일치 그룹의 색인.</target>
        </trans-unit>
        <trans-unit id="9045157cf1b5cdc3357a87ceb92988dba01e7a2a" translate="yes" xml:space="preserve">
          <source>The input and output locations for the MapReduce/Tez program are conveyed to Pig using the STORE/LOAD clauses. Pig, however, does not pass this information (nor require that this information be passed) to the MapReduce/Tez program. If you want to pass the input and output locations to the MapReduce/Tez program you can use the params clause or you can hardcode the locations in the MapReduce/Tez program.</source>
          <target state="translated">MapReduce / Tez 프로그램의 입력 및 출력 위치는 STORE / LOAD 절을 사용하여 Pig로 전달됩니다. 그러나 Pig는이 정보를 MapReduce / Tez 프로그램에 전달하지 않습니다 (이 정보를 전달하지 않아도 됨). 입력 및 출력 위치를 MapReduce / Tez 프로그램으로 전달하려면 params 절을 사용하거나 MapReduce / Tez 프로그램에서 위치를 하드 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bac1ec5553d04d6c357b298a44c79c6f0e371b" translate="yes" xml:space="preserve">
          <source>The interface is parameterized with the return type of the function.</source>
          <target state="translated">인터페이스는 함수의 리턴 유형으로 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="aed17b13def9d813bcddca7c246ded262b2271a4" translate="yes" xml:space="preserve">
          <source>The jar file containing MapReduce or Tez program (enclosed in single quotes).</source>
          <target state="translated">MapReduce 또는 Tez 프로그램을 포함하는 jar 파일 (작은 따옴표로 묶음).</target>
        </trans-unit>
        <trans-unit id="01da2ad9f454a6441657044e8acc263b0709c11e" translate="yes" xml:space="preserve">
          <source>The job id.</source>
          <target state="translated">작업 ID</target>
        </trans-unit>
        <trans-unit id="9636a6025654d252067e83364fbd97e2f3f82253" translate="yes" xml:space="preserve">
          <source>The kill command will attempt to kill any MapReduce jobs associated with the Pig job. Under certain conditions, however, this may fail; for example, when a Pig job is killed and does not have a chance to call its shutdown procedures.</source>
          <target state="translated">kill 명령은 Pig 작업과 연관된 MapReduce 작업을 강제 종료합니다. 그러나 특정 조건에서는 실패 할 수 있습니다. 예를 들어, Pig 작업이 종료되고 종료 프로 시저를 호출 할 기회가없는 경우.</target>
        </trans-unit>
        <trans-unit id="701574eb5f219db0024ca8571a0397218095007c" translate="yes" xml:space="preserve">
          <source>The last input schema field in getArgToFuncMapping() can be marked as vararg, which enables UDF writers to create UDFs that take variable length arguments. This is done by overriding the getSchemaType() method:</source>
          <target state="translated">getArgToFuncMapping ()의 마지막 입력 스키마 필드를 vararg로 표시하여 UDF 작성자가 가변 길이 인수를 사용하는 UDF를 작성할 수 있습니다. 이는 getSchemaType () 메소드를 대체하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3663d47420f192e5ceebb95dfb3c4d547bbff4f1" translate="yes" xml:space="preserve">
          <source>The load function.</source>
          <target state="translated">로드 기능.</target>
        </trans-unit>
        <trans-unit id="e02138c2d0d6a3d2ae95bd89f2be54afbc50c2ed" translate="yes" xml:space="preserve">
          <source>The load/store UDFs control how data goes into Pig and comes out of Pig. Often, the same function handles both input and output but that does not have to be the case.</source>
          <target state="translated">로드 / 저장 UDF는 데이터가 Pig로 들어가고 Pig에서 나오는 방법을 제어합니다. 종종 동일한 함수가 입력과 출력을 모두 처리하지만 반드시 그럴 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4460cce5cd82664fa6d15d087cba949488f208a2" translate="yes" xml:space="preserve">
          <source>The loader implementation in the example is a loader for text data with line delimiter as '\n' and '\t' as default field delimiter (which can be overridden by passing a different field delimiter in the constructor) - this is similar to current PigStorage loader in Pig. The implementation uses an existing Hadoop supported Inputformat - TextInputFormat - as the underlying InputFormat.</source>
          <target state="translated">이 예제의 로더 구현은 줄 구분 기호가 '\ n'이고 '\ t'가 기본 필드 구분 기호 인 텍스트 데이터에 대한 로더입니다 (생성자에서 다른 필드 구분 기호를 전달하여 재정의 할 수 있음). 이것은 현재와 유사합니다. Pig의 PigStorage 로더. 구현시 기존 Hadoop 지원 Inputformat-TextInputFormat-을 기본 InputFormat으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56925ed7533834928ea149481f0055040f149b8a" translate="yes" xml:space="preserve">
          <source>The loader must be stateless across the invocations to the prepareToRead method. That is, the method should reset any internal states that are not affected by the RecordReader argument.</source>
          <target state="translated">loader는 prepareToRead 메소드를 호출 할 때 상태 비 저장 상태 여야합니다. 즉,이 메소드는 RecordReader 인수의 영향을받지 않는 내부 상태를 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="231c9adce0ac22ce3bbbb556f47cbf4f807cc335" translate="yes" xml:space="preserve">
          <source>The loader must implement the {CollectableLoader} interface.</source>
          <target state="translated">로더는 {CollectableLoader} 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab2d4801e679074e634a20ad878755811177fd23" translate="yes" xml:space="preserve">
          <source>The loader produces the data of the type specified by the schema. If the data does not conform to the schema, depending on the loader, either a null value or an error is generated.</source>
          <target state="translated">로더는 스키마에 의해 지정된 유형의 데이터를 생성합니다. 데이터가 스키마를 준수하지 않으면 로더에 따라 널값 또는 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e627ec71020e6d3062a0247084e63d9556b993c" translate="yes" xml:space="preserve">
          <source>The logical plan shows a pipeline of operators to be executed to build the relation. Type checking and backend-independent optimizations (such as applying filters early on) also apply.</source>
          <target state="translated">논리적 계획은 관계를 구축하기 위해 실행될 운영자의 파이프 라인을 보여줍니다. 유형 검사 및 백엔드 독립적 최적화 (예 : 필터를 조기에 적용)도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5dec0cf54adc5b4e4e1ecdeae5110b88cc9ebe5a" translate="yes" xml:space="preserve">
          <source>The main thing to know about Pig's type system is that Pig uses native Java types for almost all of its types, as shown in this table.</source>
          <target state="translated">Pig의 유형 시스템에 대해 알아야 할 주요 사항은 Pig가이 표에 표시된 것처럼 거의 모든 유형에 대해 원시 Java 유형을 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c8abbd26c8540a17be643a85d3c9eb37842d283" translate="yes" xml:space="preserve">
          <source>The main thing to notice in this example is the getArgToFuncMapping() method. This method returns a list that contains a mapping from the input schema to the class that should be used to handle it. In this example the main class handles the bytearray input and outsources the rest of the work to other classes implemented in separate files in the same package. The example of one such class is below. This class handles integer input values.</source>
          <target state="translated">이 예제에서 주목해야 할 것은 getArgToFuncMapping () 메소드입니다. 이 메소드는 입력 스키마에서이를 처리하는 데 사용해야하는 클래스로의 맵핑이 포함 된 목록을 리턴합니다. 이 예제에서 기본 클래스는 바이트 배열 입력을 처리하고 나머지 작업을 동일한 패키지의 별도 파일로 구현 된 다른 클래스로 아웃소싱합니다. 이러한 클래스 중 하나의 예는 다음과 같습니다. 이 클래스는 정수 입력 값을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1f7cf5c976cce9cdff9b97a4214e8cca1503a403" translate="yes" xml:space="preserve">
          <source>The mapreduce plan shows how the physical operators are grouped into map reduce jobs.</source>
          <target state="translated">mapreduce 계획은 실제 운영자가 맵 감소 작업으로 그룹화되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9cf8785313dd2dfb2f1863dc0c12a83fca1c7581" translate="yes" xml:space="preserve">
          <source>The mechanisms featured in the &lt;a href=&quot;cont&quot;&gt;Control Structures&lt;/a&gt; guide give you greater control over how your Pig scripts are structured and executed. The &lt;a href=&quot;cont&quot;&gt;Performance and Efficiency&lt;/a&gt; guide provides valuable examples and suggestions for optimizing your code.</source>
          <target state="translated">&lt;a href=&quot;cont&quot;&gt;제어 구조&lt;/a&gt; 안내서 에 나와있는 메커니즘을 통해 Pig 스크립트의 구성 및 실행 방식을보다 효과적으로 제어 할 수 있습니다. &lt;a href=&quot;cont&quot;&gt;성능 및 효율성&lt;/a&gt; 가이드는 코드를 최적화하기위한 귀중한 사례 및 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b98a3f8b6bae16a6fd9040763344ec9dc3fe3af" translate="yes" xml:space="preserve">
          <source>The methods which need to be overridden in StoreFunc are explained below:</source>
          <target state="translated">StoreFunc에서 재정의해야하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2d77a5344bf02f17d69188c490a2f83a3f87896" translate="yes" xml:space="preserve">
          <source>The most extensive support is provided for Java functions. You can customize all parts of the processing including data load/store, column transformation, and aggregation. Java functions are also more efficient because they are implemented in the same language as Pig and because additional interfaces are supported such as the &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt; and the &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;.</source>
          <target state="translated">Java 기능에 대한 가장 광범위한 지원이 제공됩니다. 데이터로드 / 저장, 열 변환 및 집계를 포함하여 처리의 모든 부분을 사용자 정의 할 수 있습니다. Java 함수는 Pig와 동일한 언어로 구현되고 &lt;a href=&quot;#algebraic-interface&quot;&gt;대수 인터페이스&lt;/a&gt; 및 &lt;a href=&quot;#accumulator-interface&quot;&gt;누산기 인터페이스&lt;/a&gt; 와 같은 추가 인터페이스가 지원되므로보다 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="21f0885e1ac63f788494cfe08ad79a7dbe12ab04" translate="yes" xml:space="preserve">
          <source>The name assigned to the bag.</source>
          <target state="translated">가방에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e6d858386128db250344466bb0108698396e7717" translate="yes" xml:space="preserve">
          <source>The name assigned to the field.</source>
          <target state="translated">필드에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4bd707e36a8cb2c2744d72701ae01db0ac63a0e5" translate="yes" xml:space="preserve">
          <source>The name assigned to the map.</source>
          <target state="translated">지도에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b9f4c6c3cc68dce0ae60a5d296e59531ca1f4752" translate="yes" xml:space="preserve">
          <source>The name assigned to the tuple.</source>
          <target state="translated">튜플에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="012ddfc11981fde0c795cc36b8c73a884eb0f7d6" translate="yes" xml:space="preserve">
          <source>The name for a UDF function or the name for a streaming command (the cmd_alias for the &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; operator).</source>
          <target state="translated">UDF 함수의 이름 또는 스트리밍 명령의 이름 ( &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; 연산자 의 cmd_alias ).</target>
        </trans-unit>
        <trans-unit id="97d447f9e1cb0af66da5a1e08c9a2da7c8afd0dd" translate="yes" xml:space="preserve">
          <source>The name of a Pig script.</source>
          <target state="translated">Pig 스크립트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="183b87fbae282842ba832f22562e3c3d30931936" translate="yes" xml:space="preserve">
          <source>The name of a UDF function.</source>
          <target state="translated">UDF 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d6270434e46603385f08b002b61d8368df861490" translate="yes" xml:space="preserve">
          <source>The name of a command created using the DEFINE operator (see &lt;a href=&quot;#define-udfs&quot;&gt;DEFINE (UDFs, streaming)&lt;/a&gt; for additional streaming examples).</source>
          <target state="translated">DEFINE 연산자를 사용하여 작성된 명령의 이름 ( 추가 스트리밍 예는 &lt;a href=&quot;#define-udfs&quot;&gt;DEFINE (UDF, 스트리밍)&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="319772bec3edf4c96def7646dbdab7806724ba1f" translate="yes" xml:space="preserve">
          <source>The name of a file (enclosed in single quotes) that contains one or more macro definitions; for example, 'my_macro.pig' or 'mypath/my_macro.pig'.</source>
          <target state="translated">하나 이상의 매크로 정의를 포함하는 파일 이름 (작은 따옴표로 묶음). 예를 들어, 'my_macro.pig'또는 'mypath / my_macro.pig'입니다.</target>
        </trans-unit>
        <trans-unit id="f85a508f4c0b535e784c9ea9b533053cc57b0b90" translate="yes" xml:space="preserve">
          <source>The name of a file containing one or more parameters.</source>
          <target state="translated">하나 이상의 매개 변수를 포함하는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="64fb253328ea30aa71f21d2d69f8155c967180cd" translate="yes" xml:space="preserve">
          <source>The name of a relation.</source>
          <target state="translated">관계의 이름.</target>
        </trans-unit>
        <trans-unit id="a4559ffd3d0492173c02f15700a09d85f1e6b0ef" translate="yes" xml:space="preserve">
          <source>The name of a relation. Applies to alias, left-alias and right-alias.</source>
          <target state="translated">관계의 이름. 별명, 왼쪽 별명 및 오른쪽 별명에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="91e2f17289c2d81845308cca53192bf4847b3c3f" translate="yes" xml:space="preserve">
          <source>The name of relation (outer bag).</source>
          <target state="translated">관계의 이름 (외부 가방).</target>
        </trans-unit>
        <trans-unit id="e936392f872f8d82b18ea98fca62de842d6d7b76" translate="yes" xml:space="preserve">
          <source>The name of the UDF has to be fully qualified with the package name or an error will be reported: java.io.IOException: Cannot instantiate:UPPER. Also, the function name is case sensitive (UPPER and upper are not the same). A UDF can take one or more parameters. The exact signature of the function should be clear from its documentation.</source>
          <target state="translated">UDF의 이름은 패키지 이름으로 완전한 이름이어야합니다. 그렇지 않으면 오류가보고됩니다. java.io.IOException : 인스턴스화 할 수 없음 : UPPER. 또한 함수 이름은 대소 문자를 구분합니다 (UPPER와 upper는 동일하지 않습니다). UDF는 하나 이상의 매개 변수를 취할 수 있습니다. 함수의 정확한 서명은 문서에서 명확해야합니다.</target>
        </trans-unit>
        <trans-unit id="eba48dd7591f2a8286d003142da20cdf1c4a50ad" translate="yes" xml:space="preserve">
          <source>The name of the file or directory, in single quotes.</source>
          <target state="translated">작은 따옴표로 묶은 파일 또는 디렉토리의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="780ee87cfb444408cb415e1fbcbaefd903e5d2c5" translate="yes" xml:space="preserve">
          <source>The name of the inner bag.</source>
          <target state="translated">내부 가방의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="babb8c26cfc2cc56da7515fefb7fa2b6c74b5965" translate="yes" xml:space="preserve">
          <source>The name of the join column for the corresponding relation. Applies to left-alias-column and right-alias-column.</source>
          <target state="translated">해당 관계에 대한 조인 열의 이름입니다. 왼쪽 별칭 열 및 오른쪽 별칭 열에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e68d86b7e87fce23ca58e495d3b0f6c3a2f73aa" translate="yes" xml:space="preserve">
          <source>The name of the macro. Macro names are global.</source>
          <target state="translated">매크로의 이름입니다. 매크로 이름은 전역입니다.</target>
        </trans-unit>
        <trans-unit id="8a8a70c857b76c39add9edb24cfc5c2e9c295c63" translate="yes" xml:space="preserve">
          <source>The name of the module to load. Translated directly to a Maven artifactId or an Ivy artifact.</source>
          <target state="translated">로드 할 모듈의 이름입니다. Maven artifactId 또는 Ivy artifact로 직접 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3769b527bb8624b7887fa5dc2bf5b6c49ca51e94" translate="yes" xml:space="preserve">
          <source>The name of the parameter.</source>
          <target state="translated">매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="45d8a75368562a9284d1d2552bdc24e16c3ea0eb" translate="yes" xml:space="preserve">
          <source>The name of the relation.</source>
          <target state="translated">관계의 이름.</target>
        </trans-unit>
        <trans-unit id="065bd03f45fe9c9c7bc9f2fc436b42ed7f5a74d2" translate="yes" xml:space="preserve">
          <source>The name of the storage directory, in quotes. If the directory already exists, the STORE operation will fail.</source>
          <target state="translated">스토리지 디렉토리의 이름 (따옴표) 디렉토리가 이미 존재하면 STORE 조작이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="31d2cc4ec8776d8b85faa1d8841bf653545859d0" translate="yes" xml:space="preserve">
          <source>The names (aliases) of fields f1, f2, and f3 are case sensitive.</source>
          <target state="translated">필드 f1, f2 및 f3의 이름 (별칭)은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="8f6ba8786743fef77c871b89f3e9d60636c33c4a" translate="yes" xml:space="preserve">
          <source>The names (aliases) of relations A, B, and C are case sensitive.</source>
          <target state="translated">관계 A, B 및 C의 이름 (별칭)은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="b62dd4558f9445b98ed2e8619cbd7998c4653e1d" translate="yes" xml:space="preserve">
          <source>The names (aliases) of relations and fields are case sensitive. The names of Pig Latin functions are case sensitive. The names of parameters (see &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;Parameter Substitution&lt;/a&gt;) and all other Pig Latin keywords (see &lt;a href=&quot;#reserved-keywords&quot;&gt;Reserved Keywords&lt;/a&gt;) are case insensitive.</source>
          <target state="translated">관계 및 필드의 이름 (별칭)은 대소 문자를 구분합니다. Pig Latin 함수의 이름은 대소 문자를 구분합니다. 매개 변수 이름 ( &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;매개 변수 대체&lt;/a&gt; 참조 ) 및 기타 모든 Pig Latin 키워드 ( &lt;a href=&quot;#reserved-keywords&quot;&gt;예약 된 키워드&lt;/a&gt; 참조 )는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69cd026d26050ad9abbbfc6165e6a8bc10f75dec" translate="yes" xml:space="preserve">
          <source>The names of both fields are generated by the system as shown in the example below.</source>
          <target state="translated">두 필드의 이름은 아래 예와 같이 시스템에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="edd56426f0b3177c12602a5c444a84fc8a763e47" translate="yes" xml:space="preserve">
          <source>The names of relations.</source>
          <target state="translated">관계의 이름.</target>
        </trans-unit>
        <trans-unit id="82f6a8d6100c3a9b8b4048c41cba6cbf36f8eb81" translate="yes" xml:space="preserve">
          <source>The nested block is enclosed in opening and closing brackets { &amp;hellip; }.</source>
          <target state="translated">중첩 된 블록은 열기 및 닫기 괄호 {&amp;hellip;}로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="c69b7adc2137979efdbf63e6ce32ad765537b870" translate="yes" xml:space="preserve">
          <source>The new Accumulator interface is designed to decrease memory usage by targeting such UDFs. For the functions that implement this interface, Pig guarantees that the data for the same key is passed continuously but in small increments. To work with incremental data, here is the interface a UDF needs to implement:</source>
          <target state="translated">새로운 Accumulator 인터페이스는 이러한 UDF를 대상으로하여 메모리 사용량을 줄 이도록 설계되었습니다. 이 인터페이스를 구현하는 기능의 경우, Pig는 동일한 키의 데이터가 지속적으로 조금씩 전달되도록합니다. 증분 데이터로 작업하기 위해 UDF가 구현해야하는 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fb46521864ca2f19280c544b639d6ef1c5da82a" translate="yes" xml:space="preserve">
          <source>The new Pig statistics and the existing Hadoop statistics can also be accessed via the Hadoop job history file (and job xml file).</source>
          <target state="translated">새로운 Pig 통계 및 기존 Hadoop 통계는 Hadoop 작업 히스토리 파일 (및 작업 xml 파일)을 통해 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="706e311d24cc670f2eae99bf4831c8c83e80d5fe" translate="yes" xml:space="preserve">
          <source>The new characters replacing the existing characters, in quotes.</source>
          <target state="translated">새 문자는 기존 문자를 따옴표로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="72e2d0851a12191e1b958d3e84299b4580ef9dc6" translate="yes" xml:space="preserve">
          <source>The null operators can be applied to all data types (see &lt;a href=&quot;#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;).</source>
          <target state="translated">null 연산자는 모든 데이터 유형에 적용 할 수 있습니다 ( &lt;a href=&quot;#nulls&quot;&gt;Null 및 Pig Latin&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4ec7f6f19bc55e28cecc5aad9a18978a4cd339d9" translate="yes" xml:space="preserve">
          <source>The number of bits in the bloom filter.</source>
          <target state="translated">블룸 필터의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="da970980a212402e2e674bb5800bd1347e5779a1" translate="yes" xml:space="preserve">
          <source>The number of hash functions used in constructing the bloom filter.</source>
          <target state="translated">블룸 필터 구성에 사용되는 해시 함수의 수입니다.</target>
        </trans-unit>
        <trans-unit id="abc0b8e5f5d27ca15cd541caf2ba6158e0a8742c" translate="yes" xml:space="preserve">
          <source>The number of output tuples, either:</source>
          <target state="translated">출력 튜플 수 :</target>
        </trans-unit>
        <trans-unit id="8b4e86885accc68cdd7c1510fa9fc406ef76d378" translate="yes" xml:space="preserve">
          <source>The number of reducers you need for a particular construct in Pig that forms a MapReduce boundary depends entirely on (1) your data and the number of intermediate keys you are generating in your mappers and (2) the partitioner and distribution of map (combiner) output keys. In the best cases we have seen that a reducer processing about 1 GB of data behaves efficiently.</source>
          <target state="translated">MapReduce 경계를 형성하는 Pig의 특정 구성에 필요한 감속기의 수는 전적으로 (1) 매퍼에서 생성하는 데이터와 중간 키의 수, (2) 맵의 분할기 및 분포 (조합기)에 따라 달라집니다 출력 키. 가장 좋은 경우에 우리는 약 1GB의 데이터를 처리하는 감속기가 효율적으로 작동하는 것을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="7108db73929d2365977dde07efd87f0ea730d7a5" translate="yes" xml:space="preserve">
          <source>The number of top tuples to return (type integer).</source>
          <target state="translated">리턴 할 상위 튜플 수 (유형 정수).</target>
        </trans-unit>
        <trans-unit id="cb703d756af9a301bf55499fcaf8cac09151f39b" translate="yes" xml:space="preserve">
          <source>The objective of this rule is to merge together two feach statements, if these preconditions are met:</source>
          <target state="translated">이 규칙의 목적은 이러한 전제 조건이 충족되는 경우 두 개의 Feach 문을 병합하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="05b4c38aaf0936a7fe4d79ebfc35b83eeab72794" translate="yes" xml:space="preserve">
          <source>The objective of this rule is to push the FILTER operators up the data flow graph. As a result, the number of records that flow through the pipeline is reduced.</source>
          <target state="translated">이 규칙의 목적은 FILTER 연산자를 데이터 흐름 그래프 위로 올리는 것입니다. 결과적으로 파이프 라인을 통과하는 레코드 수가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="56f451c2f1aba6d526e6c7571ba1130df0bcd84d" translate="yes" xml:space="preserve">
          <source>The objective of this rule is to push the LIMIT operator up the data flow graph (or down the tree for database folks). In addition, for top-k (ORDER BY followed by a LIMIT) the LIMIT is pushed into the ORDER BY.</source>
          <target state="translated">이 규칙의 목적은 LIMIT 연산자를 데이터 플로우 그래프 (또는 데이터베이스 사용자의 트리 아래)로 올리는 것입니다. 또한 top-k (ORDER BY 다음에 LIMIT)의 경우 LIMIT가 ORDER BY로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="f305985f78f16616993d6cee1a85f0ffe1afd0f9" translate="yes" xml:space="preserve">
          <source>The objective of this rule is to reduce the number of records that flow through the pipeline by moving FOREACH operators with a FLATTEN down the data flow graph. In the example shown below, it would be more efficient to move the foreach after the join to reduce the cost of the join operation.</source>
          <target state="translated">이 규칙의 목표는 FLEACHEN이있는 FOREACH 연산자를 데이터 플로우 그래프 아래로 이동하여 파이프 라인을 통해 흐르는 레코드 수를 줄이는 것입니다. 아래에 표시된 예에서는 조인 작업 후 비용을 줄이기 위해 조인 후 foreach를 이동하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f65b5d133c1a1fc7d56f1548fb07f80e75c3c0c1" translate="yes" xml:space="preserve">
          <source>The offset from 1970-01-01T00:00:00.000Z in terms of the number milliseconds (either positive or negative).</source>
          <target state="translated">수 밀리 초 (양수 또는 음수)로 1970-01-01T00 : 00 : 00.000Z의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="356b85d30545bb1851dcde7659d37b34f4b8a406" translate="yes" xml:space="preserve">
          <source>The optimizer selects the exact method by which a UDF is invoked based on the UDF type and the query. Note that only a single interface is used at any given time. The optimizer tries to find the most efficient way to execute the function. If a combiner is used and the function implements the Algebraic interface then this interface will be used to invoke the function. If the combiner is not invoked but the accumulator can be used and the function implements Accumulator interface then that interface is used. If neither of the conditions is satisfied then the exec function is used to invoke the UDF.</source>
          <target state="translated">옵티마이 저는 UDF 유형 및 조회를 기반으로 UDF가 호출되는 정확한 메소드를 선택합니다. 주어진 시간에 단일 인터페이스 만 사용됩니다. 옵티마이 저는 함수를 실행하는 가장 효율적인 방법을 찾으려고합니다. 결합기가 사용되고 함수가 대수 인터페이스를 구현하는 경우이 인터페이스는 함수를 호출하는 데 사용됩니다. 결합기가 호출되지 않았지만 누산기가 사용될 수 있고 함수가 누산기 인터페이스를 구현하는 경우 해당 인터페이스가 사용됩니다. 조건이 만족되지 않으면 exec 함수를 사용하여 UDF를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d0fabb46aa58ed337061f9a45f5e2934a0bc9f52" translate="yes" xml:space="preserve">
          <source>The output data files, named part-nnnnn, are written to this directory.</source>
          <target state="translated">part-nnnnn이라는 출력 데이터 파일이이 디렉토리에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="487c0a69542da5455d60a3a8174818d126d9aecd" translate="yes" xml:space="preserve">
          <source>The output may contain a few Hadoop warnings which can be ignored:</source>
          <target state="translated">출력에는 무시할 수있는 몇 개의 Hadoop 경고가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b145073766ea7c91dd42faf0345b2759cfadc21" translate="yes" xml:space="preserve">
          <source>The parameter name has the structure of a standard language identifier: it must start with a letter or underscore followed by any number of letters, digits, and underscores.</source>
          <target state="translated">매개 변수 이름은 표준 언어 식별자의 구조를 갖습니다. 문자 나 밑줄로 시작하고 그 뒤에 문자, 숫자 및 밑줄이 몇 개나 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b06a195dd985c82525e6561aad3925022a06ad68" translate="yes" xml:space="preserve">
          <source>The path to the JAR file (the full location URI is required). Do not place the name in quotes.</source>
          <target state="translated">JAR 파일의 경로입니다 (전체 위치 URI가 필요함). 이름을 따옴표로 묶지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3b8174d5a2988a2b381987b12b4d289cfe55ce82" translate="yes" xml:space="preserve">
          <source>The path to the local keytab file that must be used to authenticate with.</source>
          <target state="translated">인증에 사용해야하는 로컬 키탭 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="c6a903eb3a1dafa93335d61755bd255bac123a8c" translate="yes" xml:space="preserve">
          <source>The path to the local krb5.conf file.</source>
          <target state="translated">로컬 krb5.conf 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="11ca16fcd78582bcf2761832f1f81b0d02a5993e" translate="yes" xml:space="preserve">
          <source>The physical plan shows how the logical operators are translated to backend-specific physical operators. Some backend optimizations also apply.</source>
          <target state="translated">실제 계획은 논리 연산자가 백엔드 특정 물리 연산자로 변환되는 방법을 보여줍니다. 일부 백엔드 최적화도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="283601fac0679e25dda61f250555c986facfa16a" translate="yes" xml:space="preserve">
          <source>The pig.optimizer.rules.disabled&lt;a href=&quot;start#properties&quot;&gt;pig property&lt;/a&gt;, which accepts a comma-separated list of optimization rules to disable; the all keyword disables all non-mandatory optimizations. (e.g.: set pig.optimizer.rules.disabled 'ColumnMapKeyPrune';)</source>
          <target state="translated">pig.optimizer.rules.disabled &lt;a href=&quot;start#properties&quot;&gt;pig 속성&lt;/a&gt; 은 쉼표로 구분 된 최적화 규칙 목록을 허용하여 비활성화합니다. all 키워드는 모든 필수가 아닌 최적화를 비활성화합니다. (예 : set pig.optimizer.rules.disabled 'ColumnMapKeyPrune';)</target>
        </trans-unit>
        <trans-unit id="10af663f5be0235f063086d6104c047f478f6ce9" translate="yes" xml:space="preserve">
          <source>The pig.properties file (add the directory that contains the pig.properties file to the classpath)</source>
          <target state="translated">pig.properties 파일 (pig.properties 파일을 포함하는 디렉토리를 클래스 경로에 추가)</target>
        </trans-unit>
        <trans-unit id="3b4a1a8941bb7c4cd51bb5c55358a29452de26c1" translate="yes" xml:space="preserve">
          <source>The pig.skewedjoin.reduce.memusage Java parameter specifies the fraction of heap available for the reducer to perform the join. A low fraction forces Pig to use more reducers but increases copying cost. We have seen good performance when we set this value in the range 0.1 - 0.4. However, note that this is hardly an accurate range. Its value depends on the amount of heap available for the operation, the number of columns in the input and the skew. An appropriate value is best obtained by conducting experiments to achieve a good performance. The default value is 0.5.</source>
          <target state="translated">pig.skewedjoin.reduce.memusage Java 매개 변수는 감속기가 결합을 수행하는 데 사용할 수있는 힙 비율을 지정합니다. 낮은 비율은 Pig가 더 많은 감속기를 사용하도록하지만 복사 비용은 증가시킵니다. 이 값을 0.1-0.4 범위에서 설정할 때 좋은 성능을 보았습니다. 그러나 이것은 정확한 범위는 아닙니다. 값은 조작에 사용 가능한 힙의 양, 입력의 열 수 및 스큐에 따라 다릅니다. 적절한 성능은 실험을 수행하여 최상의 성능을 달성하는 것이 가장 좋습니다. 기본값은 0.5입니다.</target>
        </trans-unit>
        <trans-unit id="6e68e7a2a9f12c8d517b2848459d2ecba1a04bb7" translate="yes" xml:space="preserve">
          <source>The pricipal you want to login with.</source>
          <target state="translated">귀하가 로그인하고자하는 대변인.</target>
        </trans-unit>
        <trans-unit id="baf5e34ce28e0b5846e849cdb37f03536bc8bad5" translate="yes" xml:space="preserve">
          <source>The primary use case for casting relations to scalars is the ability to use the values of global aggregates in follow up computations.</source>
          <target state="translated">스칼라에 관계를 캐스트하는 주요 사용 사례는 후속 계산에서 전역 집계 값을 사용하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8238414a3c0eab4a0e5155b1a560e93ae8fc45b3" translate="yes" xml:space="preserve">
          <source>The printf-style string describing the template.</source>
          <target state="translated">템플릿을 설명하는 printf 스타일 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="011b1a58d2dcff1bf140276a174b255fdf268241" translate="yes" xml:space="preserve">
          <source>The quit command enables you to quit or exit the Pig grunt shell.</source>
          <target state="translated">quit 명령을 사용하면 Pig grunt 쉘을 종료하거나 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c660c18a4f80c9ae9c4ec8ba3f7096a29432cda" translate="yes" xml:space="preserve">
          <source>The register statement above registers the Jython functions defined in test.py in Pig&amp;rsquo;s runtime within the defined namespace (myfuncs here). They can then be referred later on in the pig script as myfuncs.helloworld(), myfuncs.complex(), and myfuncs.square(). An example usage is:</source>
          <target state="translated">위의 register 문은 Pig의 런타임에서 test.py에 정의 된 Jython 함수를 정의 된 네임 스페이스 (여기서는 myfuncs) 내에 등록합니다. 그런 다음 나중에 돼지 스크립트에서 myfuncs.helloworld (), myfuncs.complex () 및 myfuncs.square ()로 참조 할 수 있습니다. 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25cf08ac175886167b8d3569cf5c6bc0ebb1db75" translate="yes" xml:space="preserve">
          <source>The register statement above registers the Python functions defined in test.py in Pig&amp;rsquo;s runtime within the defined namespace (myfuncs here). They can then be referred later on in the pig script as myfuncs.square(), myfuncs.concat(). An example usage is:</source>
          <target state="translated">위의 register 문은 Pig의 런타임에서 test.py에 정의 된 Python 함수를 정의 된 네임 스페이스 (여기서는 myfuncs)에 등록합니다. 그런 다음 나중에 돼지 스크립트에서 myfuncs.square (), myfuncs.concat ()로 참조 할 수 있습니다. 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c2004471b2061dc2d01f0d6ea0d0fce4dc5841a" translate="yes" xml:space="preserve">
          <source>The register statement above registers the Ruby functions defined in test.rb in Pig&amp;rsquo;s runtime within the defined namespace (myfuncs in this example). They can then be referred later on in the Pig Latin script as myfuncs.square(). An example usage is:</source>
          <target state="translated">위의 register 문은 Pig의 런타임에 test.rb에 정의 된 Ruby 함수를 정의 된 네임 스페이스 (이 예에서는 myfuncs)에 등록합니다. 그런 다음 나중에 Pig Latin 스크립트에서 myfuncs.square ()로 참조 할 수 있습니다. 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1633ed8c3396afa3be96ed7626a832f4a2207d6" translate="yes" xml:space="preserve">
          <source>The register statement above registers the js functions defined in test.js in Pig&amp;rsquo;s runtime within the defined namespace (myfuncs here). They can then be referred later on in the pig script as myfuncs.helloworld(), myfuncs.complex(), and myfuncs.square(). An example usage is:</source>
          <target state="translated">위의 register 문은 Pig의 런타임에서 test.js에 정의 된 js 함수를 정의 된 네임 스페이스 (여기서는 myfuncs)에 등록합니다. 그런 다음 나중에 돼지 스크립트에서 myfuncs.helloworld (), myfuncs.complex () 및 myfuncs.square ()로 참조 할 수 있습니다. 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="451ff135bc2116280609b6465bbc198b535d8eef" translate="yes" xml:space="preserve">
          <source>The regular expression to which the string is to be matched, in quotes.</source>
          <target state="translated">문자열과 일치하는 정규식을 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="e8af2c1c8d3bd42fca7f147f1dddb3a5a6370471" translate="yes" xml:space="preserve">
          <source>The regular expression.</source>
          <target state="translated">정규식.</target>
        </trans-unit>
        <trans-unit id="331428183a66a47e3c1432c84af16c7ea16b3664" translate="yes" xml:space="preserve">
          <source>The relation (bag of tuples) containing the tuple column.</source>
          <target state="translated">튜플 열을 포함하는 관계 (튜플의 백)입니다.</target>
        </trans-unit>
        <trans-unit id="a0127c3332a42030d6ec43dd44fc032bae313e68" translate="yes" xml:space="preserve">
          <source>The repositories can be configured using an ivysettings file. Pig will search for an ivysettings.xml file in the following locations in order. PIG_CONF_DIR &amp;gt; PIG_HOME &amp;gt; Classpath</source>
          <target state="translated">리포지토리는 ivysettings 파일을 사용하여 구성 할 수 있습니다. Pig는 다음 위치에서 ivysettings.xml 파일을 순서대로 검색합니다. PIG_CONF_DIR&amp;gt; PIG_HOME&amp;gt; 클래스 경로</target>
        </trans-unit>
        <trans-unit id="b09dd5e40e2e5a7d8c080a3d1fb95e5da72f41bd" translate="yes" xml:space="preserve">
          <source>The result is a multiple of the digits-th power of ten: 0 leads to no fractional digits; a negative value zeros out correspondingly many places to the left of the decimal point.</source>
          <target state="translated">결과는 10의 자릿수 제곱의 배수입니다. 0은 소수 자릿수가 없습니다. 음수 값은 소수점 왼쪽의 해당 위치에서 제로화됩니다.</target>
        </trans-unit>
        <trans-unit id="54ca8d8f1b2f29c8f446209d26468c3312bcba5c" translate="yes" xml:space="preserve">
          <source>The result is fetched if the query contains any of the following operators: &lt;a href=&quot;basic#filter&quot;&gt;FILTER&lt;/a&gt;, &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt;, &lt;a href=&quot;basic#limit&quot;&gt;LIMIT&lt;/a&gt;, &lt;a href=&quot;basic#stream&quot;&gt;STREAM&lt;/a&gt;, &lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt;.</source>
          <target state="translated">쿼리에 &lt;a href=&quot;basic#filter&quot;&gt;FILTER&lt;/a&gt; , &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt; , &lt;a href=&quot;basic#limit&quot;&gt;LIMIT&lt;/a&gt; , &lt;a href=&quot;basic#stream&quot;&gt;STREAM&lt;/a&gt; , &lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt; 연산자가 포함되어 있으면 결과가 페치됩니다 .</target>
        </trans-unit>
        <trans-unit id="01e5b00226167fe65ddf7033fb240852843b547f" translate="yes" xml:space="preserve">
          <source>The result of a boolean expression (an expression that includes boolean and comparison operators) is always of type boolean (true or false).</source>
          <target state="translated">부울 표현식 (부울 및 비교 연산자를 포함하는 표현식)의 결과는 항상 부울 유형 (true 또는 false)입니다.</target>
        </trans-unit>
        <trans-unit id="5722085ccd637639518e03ee217a91fd84e4af18" translate="yes" xml:space="preserve">
          <source>The same goes for filters.</source>
          <target state="translated">필터도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f17165c62418c77b367f87732eb37ac03f6a2cd1" translate="yes" xml:space="preserve">
          <source>The same precedence holds: Hadoop configuration files &amp;lt; -D Hadoop property &amp;lt; -P properties_file &amp;lt; set command.</source>
          <target state="translated">동일한 우선 순위가 유지됩니다. Hadoop 구성 파일 &amp;lt;-D Hadoop 특성 &amp;lt;-P properties_file &amp;lt;set 명령.</target>
        </trans-unit>
        <trans-unit id="d2b2c84ac1f3e04cf4962592a8ac2b4dd94c0faf" translate="yes" xml:space="preserve">
          <source>The schemas for all the outputs of the when/else branches should match.</source>
          <target state="translated">when / else 분기의 모든 출력에 대한 스키마가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9d45d205208c535ceb84b3ce5bb29eef79cb9ad" translate="yes" xml:space="preserve">
          <source>The schemas for the two conditional outputs of the bincond should match.</source>
          <target state="translated">bincond의 두 조건부 출력에 대한 스키마가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="41ffac1718e02da30a8bceeaead35c3273ade54e" translate="yes" xml:space="preserve">
          <source>The scope is the same as for %declare.</source>
          <target state="translated">범위는 % declare와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5ceb518670e56068b175505490af0a7e0031b240" translate="yes" xml:space="preserve">
          <source>The scope of a parameter value defined using declare is all the lines following the declare statement until the next declare statement that defines the same parameter is encountered. When used with run/exec command, see &lt;a href=&quot;#Parameter-Sub-scope&quot;&gt;Scope section&lt;/a&gt;.</source>
          <target state="translated">선언을 사용하여 정의 된 매개 변수 값의 범위는 동일한 매개 변수를 정의하는 다음 선언문이 나타날 때까지 선언문 다음의 모든 행입니다. run / exec 명령과 함께 사용하는 경우 &lt;a href=&quot;#Parameter-Sub-scope&quot;&gt;범위 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="059752d06990886c7884a7d52516a62299d4d610" translate="yes" xml:space="preserve">
          <source>The script above uses the COUNT function to count the number of students with the same name. There are a couple of things to note about this script. First, even though we are using a function, there is no register command. Second, the function is not qualified with the package name. The reason for both is that COUNT is a builtin function meaning that it comes with the Pig distribution. These are the only two differences between builtins and UDFs. Builtins are discussed in more detail later in this document.</source>
          <target state="translated">위 스크립트는 COUNT 함수를 사용하여 같은 이름을 가진 학생 수를 계산합니다. 이 스크립트에 대해 몇 가지주의 할 사항이 있습니다. 첫째, 함수를 사용하더라도 레지스터 명령은 없습니다. 둘째, 기능이 패키지 이름으로 규정되지 않았습니다. 두 가지 이유는 COUNT가 Pig 분포와 함께 제공되는 내장 함수이기 때문입니다. 이것들은 내장과 UDF의 유일한 차이점입니다. 내장은이 문서의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8e80c5d9d4cae566763291cf3d90c2f15d6a38f5" translate="yes" xml:space="preserve">
          <source>The script file should not contain an ILLUSTRATE statement.</source>
          <target state="translated">스크립트 파일에는 ILLUSTRATE 문이 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2d6013d04f198373320dd50bfffe627091dde8c9" translate="yes" xml:space="preserve">
          <source>The script is shown here:</source>
          <target state="translated">스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2781db889017a16d0e383ee218c1f6eff3ec9c5e" translate="yes" xml:space="preserve">
          <source>The script keyword followed by the name of a Pig script (for example, myscript.pig).</source>
          <target state="translated">script 키워드 뒤에 Pig 스크립트의 이름이옵니다 (예 : myscript.pig).</target>
        </trans-unit>
        <trans-unit id="130675046873ebebab537d635ab40b859f063559" translate="yes" xml:space="preserve">
          <source>The second field takes the name of the original relation and is type bag.</source>
          <target state="translated">두 번째 필드는 원래 관계의 이름을 사용하며 유형 백입니다.</target>
        </trans-unit>
        <trans-unit id="1f50acdf075167571d30e473c4e2b92c7608ec1b" translate="yes" xml:space="preserve">
          <source>The second foreach is not nested.</source>
          <target state="translated">두 번째 foreach는 중첩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d3e6d64fa91d78bb52e277db499089142b2cdae" translate="yes" xml:space="preserve">
          <source>The second parameter to the FieldSchema constructor is the schema representing this field, which in this case is a tuple with two fields. The third parameter represents the type of the schema, which in this case is a TUPLE. All supported schema types are defined in the org.apache.pig.data.DataType class.</source>
          <target state="translated">FieldSchema 생성자의 두 번째 매개 변수는이 필드를 나타내는 스키마이며이 경우 두 개의 필드가있는 튜플입니다. 세 번째 매개 변수는 스키마의 유형을 나타내며이 경우에는 TUPLE입니다. 지원되는 모든 스키마 유형은 org.apache.pig.data.DataType 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f3b28aaf785cd2f874107138c8e3a62c8df6ba" translate="yes" xml:space="preserve">
          <source>The second query will run more efficiently than the first. In some of our queries with see 2x speedup.</source>
          <target state="translated">두 번째 쿼리는 첫 번째 쿼리보다 효율적으로 실행됩니다. 우리의 쿼리 중 일부는 2 배 속도 향상을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6dd948fdfd81a246638bf69bf435c05cd97d95a" translate="yes" xml:space="preserve">
          <source>The sh shell command parameters.</source>
          <target state="translated">sh 쉘 명령 매개 변수.</target>
        </trans-unit>
        <trans-unit id="8d49398f1135e673ec9bc1e425c0bcee81f37f0a" translate="yes" xml:space="preserve">
          <source>The sh shell command.</source>
          <target state="translated">sh 쉘 명령.</target>
        </trans-unit>
        <trans-unit id="f8f358e03aac13768206f376d8d72b583a123c56" translate="yes" xml:space="preserve">
          <source>The ship option works with binaries, jars, and small datasets. However, loading larger datasets at run time for every execution can severely impact performance. Instead, use the cache option to access large files already moved to and available on the compute nodes. Only files, not directories, can be specified with the cache option.</source>
          <target state="translated">배송 옵션은 이진, 항아리 및 작은 데이터 세트와 함께 작동합니다. 그러나 모든 실행에 대해 런타임시 더 큰 데이터 세트를로드하면 성능에 심각한 영향을 줄 수 있습니다. 대신 캐시 옵션을 사용하여 이미 컴퓨팅 노드로 이동하여 사용 가능한 대용량 파일에 액세스하십시오. 캐시 옵션을 사용하여 디렉토리가 아닌 파일 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fda777a2fc8cef4d9220bd15f8b457907b94648c" translate="yes" xml:space="preserve">
          <source>The singleton UDFContext class provides two features to UDF writers. First, on the backend, it allows UDFs to get access to the JobConf object, by calling getJobConf. This is only available on the backend (at run time) as the JobConf has not yet been constructed on the front end (during planning time).</source>
          <target state="translated">싱글 톤 UDFContext 클래스는 UDF 작성자에게 두 가지 기능을 제공합니다. 먼저 백엔드에서 getJobConf를 호출하여 UDF가 JobConf 오브젝트에 액세스 할 수 있도록합니다. JobConf가 아직 프런트 엔드에 구성되지 않았기 때문에 (계획 시간 동안) 백엔드 (런타임)에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f43c7da689ff64afe4dc14ad71718a05ba9f1ca" translate="yes" xml:space="preserve">
          <source>The skewed table must be specified as the left table. Pig samples on that table and determines the number of reducers per key.</source>
          <target state="translated">기울어 진 테이블은 왼쪽 테이블로 지정해야합니다. 해당 테이블의 돼지 샘플은 키당 감속기 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4bde4d695abc2c3fbbbcea23706dc6b0d5ef8d6e" translate="yes" xml:space="preserve">
          <source>The source string.</source>
          <target state="translated">소스 문자열</target>
        </trans-unit>
        <trans-unit id="b95e5e8a969eeb9529114ba9f69865d64df2a48f" translate="yes" xml:space="preserve">
          <source>The stats classes are in the package: org.apache.pig.tools.pigstats</source>
          <target state="translated">통계 클래스는 org.apache.pig.tools.pigstats 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7206d48f452aa8613b0b605ed88327ad2bb6c903" translate="yes" xml:space="preserve">
          <source>The store function.</source>
          <target state="translated">저장 기능.</target>
        </trans-unit>
        <trans-unit id="fd7d7d00ae9f23e53773d2d5167a3fc900cc9e11" translate="yes" xml:space="preserve">
          <source>The storer implementation in the example is a storer for text data with line delimiter as '\n' and '\t' as default field delimiter (which can be overridden by passing a different field delimiter in the constructor) - this is similar to current PigStorage storer in Pig. The implementation uses an existing Hadoop supported OutputFormat - TextOutputFormat as the underlying OutputFormat.</source>
          <target state="translated">이 예제에서 저장 기 구현은 줄 구분 기호가 '\ n'이고 '\ t'가 기본 필드 구분 기호 인 텍스트 데이터에 대한 저장 기입니다 (생성자에서 다른 필드 구분 기호를 전달하여 재정의 할 수 있음). 이것은 현재와 유사합니다. Pig의 PigStorage 저장 기. 구현시 기존 Hadoop 지원 OutputFormat-TextOutputFormat을 기본 OutputFormat으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85232a9dc2fcf4a31571496a73c1a1c93847bf50" translate="yes" xml:space="preserve">
          <source>The streaming command specification is complex.</source>
          <target state="translated">스트리밍 명령 사양은 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="ccabf717837dd5fd44695714149e2a15ae894de7" translate="yes" xml:space="preserve">
          <source>The streaming command specification requires additional parameters (input, output, and so on).</source>
          <target state="translated">스트리밍 명령 사양에는 추가 매개 변수 (입력, 출력 등)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d335987f50bf472901aa62950d47e8ce7c5afcb6" translate="yes" xml:space="preserve">
          <source>The string from which a substring will be extracted.</source>
          <target state="translated">부분 문자열을 추출 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3bce118c685b997b754432e2412ae478d9cd4d2e" translate="yes" xml:space="preserve">
          <source>The string in which to perform the match.</source>
          <target state="translated">일치를 수행 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="90a1be68b234e57dee51c32392a3734e6dce6c0a" translate="yes" xml:space="preserve">
          <source>The string index begins with zero (0).</source>
          <target state="translated">문자열 인덱스는 0으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d6b3c2c21b5884da55600ee5d72c709d27d952ab" translate="yes" xml:space="preserve">
          <source>The string to be searched.</source>
          <target state="translated">검색 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c3c01408b5ed1ffbbfa8208ebb24a0544f27354b" translate="yes" xml:space="preserve">
          <source>The string to be split.</source>
          <target state="translated">분할 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="79494882838acc90e24bfdaaad91d7d26cf4f78d" translate="yes" xml:space="preserve">
          <source>The string to be tested.</source>
          <target state="translated">테스트 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d8272016e54fb8d91b008aa4537485103c6d9ab8" translate="yes" xml:space="preserve">
          <source>The string to be updated.</source>
          <target state="translated">업데이트 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c811ebd5347bf454e2716fc7c012c1e41ee34acb" translate="yes" xml:space="preserve">
          <source>The string to compare against.</source>
          <target state="translated">비교할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b752c06ad611be911021125898339d5b4eb3317c" translate="yes" xml:space="preserve">
          <source>The string to test against.</source>
          <target state="translated">테스트 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4965ecb445de4bac45534c38feeddbb2dfacc9b7" translate="yes" xml:space="preserve">
          <source>The test can be executed by JUnit (or any other Java testing framework). It requires:</source>
          <target state="translated">테스트는 JUnit (또는 다른 Java 테스트 프레임 워크)에 의해 실행될 수 있습니다. 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="3834a324e873e08fccff8ea1771db14f58c47110" translate="yes" xml:space="preserve">
          <source>The test takes about 25s to run and should pass. In case of error (for example change the parameter n to n=3), the diff of output is displayed:</source>
          <target state="translated">테스트는 약 25 초가 걸리며 통과해야합니다. 오류가 발생한 경우 (예 : 매개 변수 n을 n = 3으로 변경) 출력 차이가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c2d6555f3518dfc80aa9241e126ba33762ac89f" translate="yes" xml:space="preserve">
          <source>The timezone string. Either the UTC offset and the location based format can be used as a parameter, while internally the timezone will be converted to the UTC offset format.</source>
          <target state="translated">시간대 문자열. 내부적으로 시간대는 UTC 오프셋 형식으로 변환되는 반면 UTC 오프셋 및 위치 기반 형식을 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772bc8b49dd9ea7ba0724a3364b023e9f4b2e850" translate="yes" xml:space="preserve">
          <source>The tuple column whose values are being compared, note 0 denotes the first column.</source>
          <target state="translated">값이 비교되는 튜플 열, 참고 0은 첫 번째 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="77f85e479d13c7b0ef3e133efbad70698485c5df" translate="yes" xml:space="preserve">
          <source>The type applies to the map value only; the map key is always type chararray (see &lt;a href=&quot;#map&quot;&gt;Map&lt;/a&gt;).</source>
          <target state="translated">유형은지도 값에만 적용됩니다. 맵 키는 항상 chararray 유형입니다 ( &lt;a href=&quot;#map&quot;&gt;Map&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5b3e92215e18b1a34e6ebe2f99b60fcd7c000dc0" translate="yes" xml:space="preserve">
          <source>The type of hash function to use. Valid values for the hash functions are 'jenkins' and 'murmur'.</source>
          <target state="translated">사용할 해시 함수의 유형입니다. 해시 함수의 유효한 값은 'jenkins'및 'murmur'입니다.</target>
        </trans-unit>
        <trans-unit id="fb454f5342d9e8ab86798ffe3cff0e3e987762a4" translate="yes" xml:space="preserve">
          <source>The user defined functions (UDFs) are described here.</source>
          <target state="translated">사용자 정의 함수 (UDF)가 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9084fafb1d7e7e4df11b26b1e3e2df7b19f5831f" translate="yes" xml:space="preserve">
          <source>The value of a parameter, in either form, can be expressed in terms of other parameters as long as the values of the dependent parameters are already defined.</source>
          <target state="translated">종속 매개 변수의 값이 이미 정의되어있는 한 매개 변수의 값은 다른 형식으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5cee8d2a1cb5997905efecbf3b6fc2c76ae6a3" translate="yes" xml:space="preserve">
          <source>The value of the parameter.</source>
          <target state="translated">매개 변수의 값입니다.</target>
        </trans-unit>
        <trans-unit id="4b76e9e1a3ad779427ec1f83a0f93c82fc48d7d0" translate="yes" xml:space="preserve">
          <source>The values for inputLocation and outputLocation can be passed in the params.</source>
          <target state="translated">inputLocation 및 outputLocation의 값은 매개 변수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b9b15e0e709aa5650a19134621fda61dc41706d" translate="yes" xml:space="preserve">
          <source>The values to place in the template. There must be a tuple element for each formatting placeholder, and it must have the correct type: int or long for integer formats such as %d; float or double for decimal formats such as %f; and long for date/time formats such as %t.</source>
          <target state="translated">템플릿에 배치 할 값입니다. 각 서식 자리 표시 자에 대한 튜플 요소가 있어야하며 올바른 형식이어야합니다. 정수 형식 (예 : % d)의 경우 int 또는 long; % f와 같은 10 진수 형식의 경우 float 또는 double; % t와 같은 날짜 / 시간 형식이 길다.</target>
        </trans-unit>
        <trans-unit id="513c7352a571555a771fc399e6eaef48dc542933" translate="yes" xml:space="preserve">
          <source>The version of the module to use. You can specify a specific version or use &quot;+&quot; or &quot;*&quot; to use the latest version.</source>
          <target state="translated">사용할 모듈의 버전입니다. 특정 버전을 지정하거나 &quot;+&quot;또는 &quot;*&quot;를 사용하여 최신 버전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb321c09c54d4e7ce11a129b37ede53bba073bb0" translate="yes" xml:space="preserve">
          <source>There are a few key differences between Avro and Pig data, and in some cases it helps to understand the differences between the Avro and Pig data models. Before writing Pig data to Avro (or creating Avro files to use in Pig), keep in mind that there might not be an equivalent Avro Schema for every Pig Schema (and vice versa):</source>
          <target state="translated">Avro와 Pig 데이터에는 몇 가지 주요 차이점이 있으며 경우에 따라 Avro와 Pig 데이터 모델의 차이점을 이해하는 데 도움이됩니다. Pig 데이터를 Avro에 쓰거나 Pig에서 사용할 Avro 파일을 작성하기 전에 모든 Pig Schema에 대해 동등한 Avro Schema가 없을 수도 있습니다 (또는 그 반대).</target>
        </trans-unit>
        <trans-unit id="eac6cbecedb3940a2c71148579a9c606c3e7922b" translate="yes" xml:space="preserve">
          <source>There are multiple &lt;a href=&quot;start#properties&quot;&gt;pig properties&lt;/a&gt; than can be configured to construct a more efficient bloom filter. See &lt;a href=&quot;http://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;Bloom Filter&lt;/a&gt; for a discussion of how to select the number of bits and the number of hash functions. Easier option would be to search for &quot;bloom filter calculator&quot; in a search engine and use one of the online bloom filter calculators available to arrive at the desired values.</source>
          <target state="translated">보다 효율적인 블룸 필터를 구성하기 위해 구성 할 수있는 것보다 여러 개의 &lt;a href=&quot;start#properties&quot;&gt;돼지 속성&lt;/a&gt; 이 있습니다. 비트 수와 해시 함수 수를 선택하는 방법에 대한 설명은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;블룸 필터&lt;/a&gt; 를 참조하십시오 . 더 쉬운 옵션은 검색 엔진에서 &quot;블룸 필터 계산기&quot;를 검색하고 원하는 값에 도달 할 수있는 온라인 블룸 필터 계산기 중 하나를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0de62bd66342ea87d294198fcd0a506c6a58d819" translate="yes" xml:space="preserve">
          <source>There are no hard limits on the size except that parameters need to fit into memory.</source>
          <target state="translated">매개 변수가 메모리에 맞아야한다는 점을 제외하고는 크기에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="be60a4905c7bc8f3bfc3fddcc6ef74e4cfc2a7e4" translate="yes" xml:space="preserve">
          <source>There are several things to note here:</source>
          <target state="translated">여기에 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b781f8f14adcc0729099bfdd98fe9fc2f0ab22" translate="yes" xml:space="preserve">
          <source>There are several types of errors that can occur in a UDF:</source>
          <target state="translated">UDF에서 발생할 수있는 몇 가지 유형의 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bfcf2c7aa5439639baf64c2d3732f7fcf02d796" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of project-to-end form of project-range (eg &quot;x .. &quot;) when the input schema is unknown (null):</source>
          <target state="translated">입력 스키마를 알 수없는 경우 프로젝트 대 엔드 형식의 프로젝트 범위 (예 : &quot;x ..&quot;)를 사용하는 경우 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="674bc57fb94d0b4feb7c767e1bd1a0db00864ac3" translate="yes" xml:space="preserve">
          <source>There are some restrictions on use of the star expression when the input schema is unknown (null):</source>
          <target state="translated">입력 스키마를 알 수없는 경우 스타 표현식 사용에 대한 몇 가지 제한 사항이 있습니다 (널).</target>
        </trans-unit>
        <trans-unit id="516e4a192c832a5e069a69b6a0f6410fd54d1b1e" translate="yes" xml:space="preserve">
          <source>There are two properties you can use to control what users are able to do</source>
          <target state="translated">사용자가 수행 할 수있는 작업을 제어하는 ​​데 사용할 수있는 두 가지 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8beef24619557965aea11f4f08b08755e7d31e12" translate="yes" xml:space="preserve">
          <source>There are two ways to call a Java UDF using a short name. One way is specifying the package to an import list via Java property, and the other is defining an alias of the UDF by DEFINE statement.</source>
          <target state="translated">짧은 이름을 사용하여 Java UDF를 호출하는 방법에는 두 가지가 있습니다. 한 가지 방법은 Java 특성을 통해 패키지를 가져 오기 목록으로 지정하는 것이고 다른 하나는 DEFINE 문으로 UDF의 별명을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8288f86d0172c243c83f20c424182e582d22744" translate="yes" xml:space="preserve">
          <source>There is a class of problems that involve iterating over a data pipeline an indeterminate number of times until a certain value is reached. Examples arise in machine learning, graph traversal, and a host of numerical analysis problems which involve finding interpolations, extrapolations or regressions. The Python example below shows one way to achieve convergence using Pig scripts.</source>
          <target state="translated">특정 값에 도달 할 때까지 데이터 파이프 라인을 불확실한 횟수만큼 반복하는 문제가 있습니다. 기계 학습, 그래프 탐색 및 보간, 외삽 또는 회귀 찾기와 관련된 수많은 수치 분석 문제에서 예가 발생합니다. 아래의 Python 예제는 Pig 스크립트를 사용하여 수렴을 달성하는 한 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dbbddba77e6e851baa2d11045a802f3fa24e2a67" translate="yes" xml:space="preserve">
          <source>There is a problem with this sequence of events. The first script does not define data types and, as the result, the data is stored as a bytearray and a bag with a tuple that contains two bytearrays. The second script attempts to cast the bytearray to double; however, since the data originated from a different loader, it has no way to know the format of the bytearray or how to cast it to a different type. To solve this problem, Pig:</source>
          <target state="translated">이 이벤트 순서에 문제가 있습니다. 첫 번째 스크립트는 데이터 유형을 정의하지 않으므로 결과적으로 데이터는 바이트 배열과 두 바이트 배열을 포함하는 튜플이 포함 된 백으로 저장됩니다. 두 번째 스크립트는 바이트 배열을 두 배로 캐스트하려고 시도합니다. 그러나 데이터가 다른 로더에서 시작되었으므로 바이트 배열의 형식이나 다른 유형으로 캐스트하는 방법을 알 수있는 방법이 없습니다. 이 문제를 해결하려면 Pig :</target>
        </trans-unit>
        <trans-unit id="d8e13c62fde46cf2a9fe8cbb7fee216944eef102" translate="yes" xml:space="preserve">
          <source>There is a shortcut form to reference the relation on the previous line of a pig script or grunt session:</source>
          <target state="translated">pig 스크립트 또는 grunt 세션의 이전 행에 대한 관계를 참조하는 바로 가기 양식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01a9e505e0558df9c3513bbf34870aae20f7a17d" translate="yes" xml:space="preserve">
          <source>There is no native constant type for datetime field. You can use a ToDate udf with chararray constant as argument to generate a datetime value.</source>
          <target state="translated">날짜 시간 필드에는 기본 상수 유형이 없습니다. chararray 상수와 함께 ToDate udf를 인수로 사용하여 날짜 시간 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0f1edf0555f299e9f443e1f75b6083aa3ea694" translate="yes" xml:space="preserve">
          <source>There is no need for v, y, or z to participate in this query. And there is no need to carry both t and x past the join, just one will suffice. Changing the query above to the query below will greatly reduce the amount of data being carried through the map and reduce phases by pig.</source>
          <target state="translated">v, y 또는 z가이 쿼리에 참여할 필요는 없습니다. 그리고 조인 이후에 t와 x를 모두 가지고 다닐 필요가 없으며, 하나만으로 충분합니다. 위 쿼리를 아래 쿼리로 변경하면 맵을 통해 전달되는 데이터의 양이 크게 줄어들고 돼지의 단계가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="460321f1dc97f83c63fbb6c64a0c02ba1855cda3" translate="yes" xml:space="preserve">
          <source>There may be filter statements and foreach statements between the sorted data source and the join statement. The foreach statement should meet the following conditions:</source>
          <target state="translated">정렬 된 데이터 소스와 조인 문 사이에 필터 문과 foreach 문이있을 수 있습니다. foreach 문은 다음 조건을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="1002f57a94b85806f73e99a692173997c56fed8f" translate="yes" xml:space="preserve">
          <source>There might be cases in which you want different processing on separate parts of the same data stream.</source>
          <target state="translated">동일한 데이터 스트림의 별도 부분에서 다른 처리를 원하는 경우가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c24b03229fc8163a67a2f5117198c1e0225c8d" translate="yes" xml:space="preserve">
          <source>There should be no transformation on the join keys which will change the sort order.</source>
          <target state="translated">정렬 순서를 변경하는 결합 키에는 변환이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a63696b2357bb7a7e8f39a6864c7993a038c153e" translate="yes" xml:space="preserve">
          <source>There should not be any conflicts between blacklist and whitelist. Make sure to have them entirely distinct or Pig will complain.</source>
          <target state="translated">블랙리스트와 화이트리스트 사이에 충돌이 없어야합니다. 그것들을 완전히 구별하도록하십시오. 그렇지 않으면 Pig가 불평 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="19826f68f6e81f1db8178f5699df6333592a036f" translate="yes" xml:space="preserve">
          <source>These Pig Latin statements extract all user IDs from the /etc/passwd file. First, copy the /etc/passwd file to your local working directory. Next, invoke the Grunt shell by typing the &quot;pig&quot; command (in local or hadoop mode). Then, enter the Pig Latin statements interactively at the grunt prompt (be sure to include the semicolon after each statement). The DUMP operator will display the results to your terminal screen.</source>
          <target state="translated">이 Pig Latin 문은 / etc / passwd 파일에서 모든 사용자 ID를 추출합니다. 먼저 / etc / passwd 파일을 로컬 작업 디렉토리로 복사하십시오. 그런 다음 &quot;pig&quot;명령 (로컬 또는 hadoop 모드)을 입력하여 Grunt 쉘을 호출하십시오. 그런 다음 grunt 프롬프트에서 Pig Latin 문장을 대화식으로 입력하십시오 (각 문장 뒤에 세미콜론을 포함하십시오). DUMP 연산자는 결과를 터미널 화면에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ac007cad6c15552fcf81058ce52b9a8842d44561" translate="yes" xml:space="preserve">
          <source>These expanded paths will be passed to any LoadFunc or Slicer implementation. In some cases this can cause problems, especially when a LoadFunc/Slicer is not used to read from a dfs file or path (for example, loading from an SQL database).</source>
          <target state="translated">이러한 확장 경로는 모든 LoadFunc 또는 슬라이서 구현으로 전달됩니다. 경우에 따라 특히 LoadFunc / Slicer를 사용하여 dfs 파일 또는 경로를 읽지 않는 경우 (예 : SQL 데이터베이스에서로드) 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72cfab5c5854663d406fc7496819be232d8786a6" translate="yes" xml:space="preserve">
          <source>These functions ignore nulls.</source>
          <target state="translated">이 함수는 널을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ddfa7835ca1cb71d0d11dcff612e9006dc6bfb35" translate="yes" xml:space="preserve">
          <source>These operators can be used anywhere where the expression of the corresponding type is acceptable including FOREACH GENERATE, FILTER, etc.</source>
          <target state="translated">이 연산자는 FOREACH GENERATE, FILTER 등 해당 유형의 표현이 허용되는 모든 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b2a9c18837c2d8ab4abee11878cc319ac89bab" translate="yes" xml:space="preserve">
          <source>These operators handle nulls differently (see examples below).</source>
          <target state="translated">이 연산자는 널을 다르게 처리합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="a85d8647a986fc0f59cb426cbc7bb9f92689bb9f" translate="yes" xml:space="preserve">
          <source>Third Field</source>
          <target state="translated">세 번째 필드</target>
        </trans-unit>
        <trans-unit id="9c7d62346f2319178633ea7d4ed601b5c7a820fe" translate="yes" xml:space="preserve">
          <source>This Pig script registers the JavaScript UDF (udf.js).</source>
          <target state="translated">이 Pig 스크립트는 JavaScript UDF (udf.js)를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="a313579338b74c859f105862a805842367386887" translate="yes" xml:space="preserve">
          <source>This can be also written as follows:</source>
          <target state="translated">다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="59ed6bf9208c8a2ea90bad01a60c3f7f0702776e" translate="yes" xml:space="preserve">
          <source>This command can be used or can replace the &lt;a href=&quot;#register-jar&quot;&gt;register jar&lt;/a&gt; command wherever used including macros.</source>
          <target state="translated">이 명령은 매크로를 포함하여 사용되는 모든 위치 에서 &lt;a href=&quot;#register-jar&quot;&gt;register jar&lt;/a&gt; 명령을 사용하거나 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="260bd0797c97f005c3b4402a51af73a973b4640f" translate="yes" xml:space="preserve">
          <source>This does not work</source>
          <target state="translated">이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="538c5928d784e0a5b058d6d3b9c01a67abd9667f" translate="yes" xml:space="preserve">
          <source>This error means that you are missing some jars in your test environment.</source>
          <target state="translated">이 오류는 테스트 환경에서 일부 항아리가 누락되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3802ce84285fab37d43fa6684377ad7a9ce15c4b" translate="yes" xml:space="preserve">
          <source>This example combines JavaScript and Pig. This &quot;combined&quot; script can only be embedded in JavaScript.</source>
          <target state="translated">이 예제는 JavaScript와 Pig를 결합합니다. 이 &quot;결합 된&quot;스크립트는 JavaScript에만 내장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3976f8046ac3b58b967b2c3a5c3c72396fa9ddf" translate="yes" xml:space="preserve">
          <source>This example combines Jython and Pig. This &quot;combined&quot; script can only be embedded in Jython.</source>
          <target state="translated">이 예는 Jython과 Pig를 결합합니다. 이 &quot;결합 된&quot;스크립트는 Jython에만 임베드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b52e0c71f5e13727af65ef80119ca48fdab6686" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to run the wordcount MapReduce progam from Pig. Note that the files specified as input and output locations in the NATIVE statement will NOT be deleted by Pig automatically. You will need to delete them manually.</source>
          <target state="translated">이 예는 Pig에서 단어 수 MapReduce 프로그램을 실행하는 방법을 보여줍니다. NATIVE 문의 입력 및 출력 위치로 지정된 파일은 Pig에 의해 자동으로 삭제되지 않습니다. 수동으로 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="888346446e3a20db9c5e6aab6231887658f21ea3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use ILLUSTRATE with a Pig script. Note that the script itself should not contain an ILLUSTRATE statement.</source>
          <target state="translated">이 예제는 ILLUSTRATE를 Pig 스크립트와 함께 사용하는 방법을 보여줍니다. 스크립트 자체에는 ILLUSTRATE 문이 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e4497be6a53c9df6664d45a2b111ebe698b8d323" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use ILLUSTRATE with a relation. Note that the LOAD statement must include a schema (the AS clause).</source>
          <target state="translated">이 예는 ILLUSTRATE를 관계와 함께 사용하는 방법을 보여줍니다. LOAD 문은 스키마 (AS 절)를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1005546d01bd834b777e9ab2778a0852b61d3ca" translate="yes" xml:space="preserve">
          <source>This example demonstrates the importance of knowing parameter types before using them in a macro script. Notice that when pass parameter $outfile to my_macro1 inside my_macro2, it must be quoted.</source>
          <target state="translated">이 예제는 매크로 스크립트에서 사용하기 전에 매개 변수 유형을 알아야하는 중요성을 보여줍니다. 매개 변수 $ outfile을 my_macro2 내의 my_macro1에 전달할 때 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="10b2870143b83ed391d0fc3ace6e90a3e3d7f085" translate="yes" xml:space="preserve">
          <source>This example shows a CROSS and FOREACH nested to the second level.</source>
          <target state="translated">이 예는 두 번째 레벨에 중첩 된 CROSS 및 FOREACH를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c49c92d37c2f29eaf0ad0b95df19ebb22c5be40" translate="yes" xml:space="preserve">
          <source>This example shows a bloom right outer join.</source>
          <target state="translated">이 예는 블룸 오른쪽 외부 조인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18a81269070a5528e1fff23b561cb478d0408593" translate="yes" xml:space="preserve">
          <source>This example shows a full outer join.</source>
          <target state="translated">이 예는 전체 외부 조인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fa9e4027701802cfe336e26f0a8b92610e176139" translate="yes" xml:space="preserve">
          <source>This example shows a left outer join.</source>
          <target state="translated">이 예는 왼쪽 외부 조인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="658eeaff281ddbd7bb47adcdcd2f2b6b35dbe40a" translate="yes" xml:space="preserve">
          <source>This example shows a replicated left outer join.</source>
          <target state="translated">이 예는 복제 된 왼쪽 외부 조인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="39dfc2be3be51260ee476cfc0684d95bc1253b56" translate="yes" xml:space="preserve">
          <source>This example shows a skewed full outer join.</source>
          <target state="translated">이 예에서는 비뚤어진 완전 외부 조인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc1ffe4439550b2d27d73b45185c4730789d3e0d" translate="yes" xml:space="preserve">
          <source>This example shows how to group using multiple keys.</source>
          <target state="translated">이 예는 여러 키를 사용하여 그룹화하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="72ee6b075af839ac1732c92b3c2a333b71e21d45" translate="yes" xml:space="preserve">
          <source>This example shows how to run Pig in local and mapreduce mode using the pig command.</source>
          <target state="translated">이 예는 pig 명령을 사용하여 로컬 및 mapreduce 모드에서 Pig를 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ce083c5d10cbf0bfe5f6e7cc6406d606d4a90328" translate="yes" xml:space="preserve">
          <source>This example shows how to specify a glob pattern using either a relative path or an absolute path.</source>
          <target state="translated">이 예제는 상대 경로 또는 절대 경로를 사용하여 glob 패턴을 지정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="baa47553ae12d8776d5de06976c0b3569645bad5" translate="yes" xml:space="preserve">
          <source>This example shows how to view the schema of a nested relation using the :: operator.</source>
          <target state="translated">이 예는 :: 연산자를 사용하여 중첩 관계의 스키마를 보는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="730327f56fb55813fed2e98e07d6a3b8fdd10f23" translate="yes" xml:space="preserve">
          <source>This example shows the implementation of the ABS function that returns the absolute value of a numeric value passed to it as input.</source>
          <target state="translated">이 예는 입력으로 전달 된 숫자 값의 절대 값을 리턴하는 ABS 함수의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="319f2a25daa320e0961eb340b9806891a3591375" translate="yes" xml:space="preserve">
          <source>This example shows the use of ONSCHEMA.</source>
          <target state="translated">이 예는 ONSCHEMA의 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="acb80be30ad7db6281675210538ff77dad65fdf2" translate="yes" xml:space="preserve">
          <source>This example shows the use of a typed maps.</source>
          <target state="translated">이 예는 유형이 지정된 맵의 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8693ae7d4043ac727c40fbb5fa888b53274887f1" translate="yes" xml:space="preserve">
          <source>This example shows you how to pass an entire Pig script to the compile call.</source>
          <target state="translated">이 예제는 전체 Pig 스크립트를 컴파일 호출에 전달하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c50d73cb03c1c5664dd59c4c92e40c27091ab85" translate="yes" xml:space="preserve">
          <source>This example will return the string '192.168.1.5'.</source>
          <target state="translated">이 예는 문자열 '192.168.1.5'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef3f926d0ce166a7ad01eb245c0a51226e8109d6" translate="yes" xml:space="preserve">
          <source>This example will return the tuple (192.168.1.5,8020).</source>
          <target state="translated">이 예제는 튜플 (192.168.1.5,8020)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd03875e84b84baa62ad2a2b2d698fb32b355d94" translate="yes" xml:space="preserve">
          <source>This feature CANNOT be used with skewed joins.</source>
          <target state="translated">이 기능은 기울어 진 조인과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1d35fe5c9a7f86fa2330441d0adfcddfaaecbe3" translate="yes" xml:space="preserve">
          <source>This feature works with &lt;a href=&quot;func#pigstorage&quot;&gt;PigStorage&lt;/a&gt;. However, if you are using a custom loader, please note the following:</source>
          <target state="translated">이 기능은 &lt;a href=&quot;func#pigstorage&quot;&gt;PigStorage&lt;/a&gt; 와 함께 작동합니다 . 그러나 사용자 정의 로더를 사용하는 경우 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="906bbd36022f4d7920709d6176eb958529e54fa7" translate="yes" xml:space="preserve">
          <source>This function counts all values, including nulls.</source>
          <target state="translated">이 함수는 null을 포함한 모든 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5b4c5ea193297509d6a5a9cb69cc5941d87d52d3" translate="yes" xml:space="preserve">
          <source>This is a shortcut to the complete syntax:</source>
          <target state="translated">이것은 완전한 구문에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="ab7ef7365e2f041374247cfef2ac8c82acfa0dd1" translate="yes" xml:space="preserve">
          <source>This is an admin feature providing ability to blacklist or/and whitelist certain commands and operations. Pig exposes a few of these that could be not very safe in a multitenant environment. For example, &quot;sh&quot; invokes shell commands, &quot;set&quot; allows users to change non-final configs. While these are tremendously useful in general, having an ability to disable would make Pig a safer platform. The goal is to allow administrators to be able to have more control over user scripts. Default behaviour would still be the same - no filters applied on commands and operators.</source>
          <target state="translated">특정 명령 및 작업을 블랙리스트에 추가하거나 화이트리스트에 추가하는 기능을 제공하는 관리자 기능입니다. Pig는 다중 테넌트 환경에서 안전하지 않을 수있는 몇 가지를 노출합니다. 예를 들어 &quot;sh&quot;는 쉘 명령을 호출하고 &quot;set&quot;은 사용자가 비 최종 구성을 변경할 수 있도록합니다. 이것들은 일반적으로 매우 유용하지만 비활성화 할 수있는 기능이 있으면 Pig를보다 안전한 플랫폼으로 만들 수 있습니다. 목표는 관리자가 사용자 스크립트를보다 효과적으로 제어 할 수 있도록하는 것입니다. 기본 동작은 여전히 ​​동일합니다. 명령과 연산자에는 필터가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="514f852f5366f297288f9e6b05a038aa3a960a26" translate="yes" xml:space="preserve">
          <source>This is an even safer approach to disallowing functionality in Pig. Using this you will be able to disable all commands and operators that are not a part of the whitelist. For eg, &lt;strong&gt;pig.whitelist=load,filter,store&lt;/strong&gt; will disallow every command and operator other than &quot;load&quot;, &quot;filter&quot; and &quot;store&quot;.</source>
          <target state="translated">이것은 Pig의 기능을 허용하지 않는보다 안전한 방법입니다. 이를 사용하면 화이트리스트에 포함되지 않은 모든 명령과 연산자를 비활성화 할 수 있습니다. 예를 들어 &lt;strong&gt;pig.whitelist = load, filter, store&lt;/strong&gt; 는 &quot;load&quot;, &quot;filter&quot;및 &quot;store&quot;이외의 모든 명령과 연산자를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7205cfdde4023cd8d9795307ffd15d0ec2c23aed" translate="yes" xml:space="preserve">
          <source>This is because Pig is only aware of two columns in B while line 4 is requesting the third column of the tuple. (Column indexing in Pig starts with 0.)</source>
          <target state="translated">이는 4 행이 튜플의 세 번째 열을 요청하는 동안 Pig는 B의 두 열만 인식하기 때문입니다. Pig의 열 인덱싱은 0으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a0c357a57b309ff954d333f6e3ad917197342a54" translate="yes" xml:space="preserve">
          <source>This is example will return the bag {(=04 ),(=06 ),(=96 )}.</source>
          <target state="translated">다음은 백 {(= 04), (= 06), (= 96)}을 반환하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="796fa865eefc9ecd0c2f0fccebf95ea661069fd3" translate="yes" xml:space="preserve">
          <source>This is how the flag is used:</source>
          <target state="translated">이것은 플래그가 사용되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="33de11fee0d8840517d81296017a80f41853014c" translate="yes" xml:space="preserve">
          <source>This is only applicable for Tez execution mode and will not work with Mapreduce mode. Specifying PARALLEL will introduce an extra reduce step that will slightly degrade performance. The primary purpose in this case is to control the number of output files.</source>
          <target state="translated">이것은 Tez 실행 모드에만 적용되며 Mapreduce 모드에서는 작동하지 않습니다. PARALLEL을 지정하면 성능을 약간 저하시키는 추가 축소 단계가 도입됩니다. 이 경우의 주요 목적은 출력 파일 수를 제어하는 ​​것입니다.</target>
        </trans-unit>
        <trans-unit id="061014a0f3cc07b3c0d886486cb6142ea75884af" translate="yes" xml:space="preserve">
          <source>This join</source>
          <target state="translated">이 조인</target>
        </trans-unit>
        <trans-unit id="2bbb912a3293fff276b066a38f42a09b8f362d8c" translate="yes" xml:space="preserve">
          <source>This problem is partially addressed by Algebraic UDFs that use the combiner and can deal with data being passed to them incrementally during different processing phases (map, combiner, and reduce). However, there are a number of UDFs that are not Algebraic, don't use the combiner, but still don&amp;rsquo;t need to be given all data at once.</source>
          <target state="translated">이 문제는 결합기를 사용하고 다른 처리 단계 (맵, 결합기 및 축소) 동안 점진적으로 전달되는 데이터를 처리 할 수있는 대수 UDF에 의해 부분적으로 해결됩니다. 그러나 대수적이지 않은 많은 UDF가 있으며 결합기를 사용하지 않지만 한 번에 모든 데이터를 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="df1adc644b18340a64b60315b290d758963f4d7a" translate="yes" xml:space="preserve">
          <source>This rule evaluates constant expression.</source>
          <target state="translated">이 규칙은 상수 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6da41bb1fa7e804d3438beb60370849eff3fad33" translate="yes" xml:space="preserve">
          <source>This script will result in the following error cause by line 4 ( C = foreach B generate $2;).</source>
          <target state="translated">이 스크립트는 라인 4에 의해 다음과 같은 오류 원인이됩니다 (C = foreach B generate $ 2;).</target>
        </trans-unit>
        <trans-unit id="7bbd4884728bea5cef051fc2b3932c9460cfad22" translate="yes" xml:space="preserve">
          <source>This will contain &quot;&amp;amp;&quot; separated key-value pairs to help us exclude all or specific dependencies etc.</source>
          <target state="translated">여기에는 &quot;&amp;amp;&quot;로 구분 된 키-값 쌍이 포함되어 모든 또는 특정 종속성 등을 제외하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1458dfe63303a12ab8e9dcbe389526ca2f043c" translate="yes" xml:space="preserve">
          <source>This works</source>
          <target state="translated">이 작동합니다</target>
        </trans-unit>
        <trans-unit id="e0eb56e9afe4b168200b033fac1914c7129b6bca" translate="yes" xml:space="preserve">
          <source>Timing your UDFs</source>
          <target state="translated">UDF 타이밍</target>
        </trans-unit>
        <trans-unit id="1e892b44ccefbb592a1c872a10cd38cd84935b63" translate="yes" xml:space="preserve">
          <source>To annotate a Jython script so that Pig can identify return types, use Jython decorators to define output schema for the script UDF.</source>
          <target state="translated">Pig가 리턴 유형을 식별 할 수 있도록 Jython 스크립트에 주석을 달려면 Jython 데코레이터를 사용하여 스크립트 UDF에 대한 출력 스키마를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="18a61cfa9edaeefcac42ff00d8237e64dfb45b0c" translate="yes" xml:space="preserve">
          <source>To annotate a Python script so that Pig can identify return types, use Python decorators to define output schema for the script UDF.</source>
          <target state="translated">Pig가 리턴 유형을 식별 할 수 있도록 Python 스크립트에 주석을 달려면 Python 데코레이터를 사용하여 스크립트 UDF에 대한 출력 스키마를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="cdd8ac02519fd5831ae513aaba0a3574f672454a" translate="yes" xml:space="preserve">
          <source>To auto-ship, the file in question should be present in the PATH. So if the file is in the current working directory then the current working directory should be in the PATH.</source>
          <target state="translated">자동 배송하려면 문제의 파일이 PATH에 있어야합니다. 따라서 파일이 현재 작업 디렉토리에 있으면 현재 작업 디렉토리가 PATH에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="81305295aacf9029d33d0baf17112f5285972e7f" translate="yes" xml:space="preserve">
          <source>To build a jar file that contains all available UDFs, follow these steps:</source>
          <target state="translated">사용 가능한 모든 UDF를 포함하는 jar 파일을 빌드하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="91339103078c4a7afb42d49b2b952e667ca738c9" translate="yes" xml:space="preserve">
          <source>To build pig, do the following:</source>
          <target state="translated">돼지를 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7e3aedc7b1a661fcdc5fde0e874b88efebfb546a" translate="yes" xml:space="preserve">
          <source>To compile PigUnit run the command shown below from the Pig trunk. The compile will create the pigunit.jar file.</source>
          <target state="translated">PigUnit을 컴파일하려면 Pig 트렁크에서 아래 표시된 명령을 실행하십시오. 컴파일하면 pigunit.jar 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e150a15c6d11b0dcef03ddca28e99d8f7d47ca31" translate="yes" xml:space="preserve">
          <source>To compress your output with AvroStorage, you need to use the correct Avro properties for compression. For example, to enable compression using deflate level 5, you would specify</source>
          <target state="translated">AvroStorage로 출력을 압축하려면 압축에 올바른 Avro 속성을 사용해야합니다. 예를 들어 수축 수준 5를 사용하여 압축을 활성화하려면 다음을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f15515dea3591b489b0bcc2b46a8a7f0d0532a70" translate="yes" xml:space="preserve">
          <source>To contribute a Java function that you have written, do the following:</source>
          <target state="translated">작성한 Java 함수를 제공하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="921946df03149f506ea5498353d080428e33bc9b" translate="yes" xml:space="preserve">
          <source>To do this and to preserve backward compatibility PigStats and related objects were expanded as shown below:</source>
          <target state="translated">이를 수행하고 이전 버전과의 호환성을 유지하기 위해 PigStats 및 관련 개체가 아래와 같이 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="55dbe6817d3ea7004ed5c5ddec9604ec8249b2e3" translate="yes" xml:space="preserve">
          <source>To download an Artifact (and its dependencies), you need to specify the artifact's group, module and version following the syntax shown below. This command will download the Jar specified and all its dependencies and load it into the classpath.</source>
          <target state="translated">아티팩트 (및 해당 종속성)를 다운로드하려면 아래 표시된 구문에 따라 아티팩트의 그룹, 모듈 및 버전을 지정해야합니다. 이 명령은 지정된 Jar 및 모든 종속 항목을 다운로드하여 클래스 경로에로드합니다.</target>
        </trans-unit>
        <trans-unit id="79e784a57c7bd2c468c72e552ff656951d02f41f" translate="yes" xml:space="preserve">
          <source>To enable control flow, you can embed Pig Latin statements and Pig commands in the Java programming language.</source>
          <target state="translated">제어 흐름을 가능하게하기 위해 Java 프로그래밍 언어에 Pig Latin 문 및 Pig 명령을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c9258ec8b24360f792ca85fd09d9e9c927c512" translate="yes" xml:space="preserve">
          <source>To enable control flow, you can embed Pig Latin statements and Pig commands in the Python, JavaScript and Groovy scripting languages using a JDBC-like compile, bind, run model. For Python, make sure the Jython jar is included in your class path. For JavaScript, make sure the Rhino jar is included in your classpath. For Groovy, make sure the groovy-all jar is included in your classpath.</source>
          <target state="translated">제어 흐름을 가능하게하기 위해 JDBC 유사 컴파일, 바인드, 실행 모델을 사용하여 Python, JavaScript 및 Groovy 스크립팅 언어에 Pig Latin 문 및 Pig 명령을 임베드 할 수 있습니다. Python의 경우 Jython jar이 클래스 경로에 포함되어 있는지 확인하십시오. JavaScript의 경우 Rhino jar이 클래스 경로에 포함되어 있는지 확인하십시오. Groovy의 경우, groovy-all jar이 클래스 경로에 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d26b8a55a94549b80d9f32b7bd70ad12ac7fdef" translate="yes" xml:space="preserve">
          <source>To enforce strict checking of output location, set &lt;strong&gt;pig.location.check.strict=true&lt;/strong&gt;. See also &lt;a href=&quot;start#properties&quot;&gt;Pig Properties&lt;/a&gt; on how to set this property.</source>
          <target state="translated">출력 위치를 엄격하게 검사하려면 &lt;strong&gt;pig.location.check.strict = true를&lt;/strong&gt; 설정 &lt;strong&gt;하십시오&lt;/strong&gt; . 이 속성을 설정하는 방법 은 &lt;a href=&quot;start#properties&quot;&gt;돼지 속성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86991e36aeff417575e5fae6bc7ae1d446afa668" translate="yes" xml:space="preserve">
          <source>To extract unique values from a column in a relation you can use DISTINCT or GROUP BY/GENERATE. DISTINCT is the preferred method; it is faster and more efficient.</source>
          <target state="translated">관계의 열에서 고유 한 값을 추출하려면 DISTINCT 또는 GROUP BY / GENERATE를 사용할 수 있습니다. DISTINCT가 선호되는 방법입니다. 더 빠르고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="642a6f7d57620b60b6903ac65c1a9b07f533aa7c" translate="yes" xml:space="preserve">
          <source>To get a Pig distribution, do the following:</source>
          <target state="translated">Pig 배포판을 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="411f3ae65d0d498258b8573f358f8b36d78c2bb8" translate="yes" xml:space="preserve">
          <source>To get started, do the following preliminary tasks:</source>
          <target state="translated">시작하려면 다음 예비 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9349e6bf32a613954b19c5f571a7e98572dfd385" translate="yes" xml:space="preserve">
          <source>To improve performance, hash-based aggregation will aggregate records in the map task before sending them to the combiner. This optimization reduces the serializing/deserializing costs of the combiner by sending it fewer records.</source>
          <target state="translated">성능을 향상시키기 위해 해시 기반 집계는 맵 태스크에서 레코드를 결합기로 보내기 전에 레코드를 집계합니다. 이 최적화는 더 적은 수의 레코드를 전송함으로써 결합기의 직렬화 / 직렬화 비용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7a1f9adbf8ecd4e2df50b79287eb0aaad9f3cd54" translate="yes" xml:space="preserve">
          <source>To make the script work (to ensure that the right execution order is enforced) add the exec statement. The exec statement will trigger the execution of the statements that produce the out1 file.</source>
          <target state="translated">올바른 실행 순서가 적용되도록 스크립트를 작동 시키려면 exec 문을 추가하십시오. exec 문은 out1 파일을 생성하는 명령문의 실행을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="9b4d98e5abbe336bfa67a9380a579fbae9901eb9" translate="yes" xml:space="preserve">
          <source>To make the script work, add the exec statement.</source>
          <target state="translated">스크립트가 작동하게하려면 exec 문을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0de297a0f31c230e8375af7e15a9c492363699ea" translate="yes" xml:space="preserve">
          <source>To make use of import scripts, do the following:</source>
          <target state="translated">가져 오기 스크립트를 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dc05fe88ec44d02f2f5f09cedcdd39b9eb9b6924" translate="yes" xml:space="preserve">
          <source>To obtain javadoc description of the functions run ant javadoc from directory trunk/contrib/piggybank/java. The documentation is generate in directory trunk/contrib/piggybank/java/build/javadoc.</source>
          <target state="translated">함수의 javadoc 설명을 얻으려면 디렉토리 trunk / contrib / piggybank / java에서 ant javadoc을 실행하십시오. 문서는 디렉토리 trunk / contrib / piggybank / java / build / javadoc에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9783d167d9550656647063bf349a225f19ac1e9a" translate="yes" xml:space="preserve">
          <source>To perform self joins in Pig load the same data multiple times, under different aliases, to avoid naming conflicts.</source>
          <target state="translated">Pig에서 자체 결합을 수행하려면 이름 충돌을 피하기 위해 다른 별명으로 동일한 데이터를 여러 번로드하십시오.</target>
        </trans-unit>
        <trans-unit id="215ab1bba88e64a146f2de31b51671a6364678eb" translate="yes" xml:space="preserve">
          <source>To register a listener, set the pig.notification.listener parameter to the fully qualified class name of an implementation of &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/tools/pigstats/PigProgressNotificationListener.java&quot;&gt;org.apache.pig.tools.pigstats.PigProgressNotificationListener&lt;/a&gt;. The class must exist on the classpath of the process submitting the Pig job. If the pig.notification.listener.arg parameter is set, the value will be passed to a constructor of the implementing class that takes a single String.</source>
          <target state="translated">리스너를 등록하려면 pig.notification.listener 매개 변수를 &lt;a href=&quot;http://svn.apache.org/repos/asf/pig/trunk/src/org/apache/pig/tools/pigstats/PigProgressNotificationListener.java&quot;&gt;org.apache.pig.tools.pigstats.PigProgressNotificationListener&lt;/a&gt; 구현의 완전한 클래스 이름으로 설정하십시오 . Pig 작업을 제출하는 프로세스의 클래스 경로에 클래스가 존재해야합니다. pig.notification.listener.arg 매개 변수가 설정되면 단일 문자열을 사용하는 구현 클래스의 생성자로 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="879a7d854add9af139f4d414c98b838762d77893" translate="yes" xml:space="preserve">
          <source>To run Pig in tez mode, simply add &quot;-x tez&quot; in pig command line. Alternatively, you can add &quot;exectype=tez&quot; to conf/pig.properties to change the default exec type to Tez. Java system property &quot;-Dexectype=tez&quot; is also good to trigger the Tez mode.</source>
          <target state="translated">tez 모드에서 Pig를 실행하려면 간단히 pig 명령 행에 &quot;-x tez&quot;를 추가하십시오. 또는 &quot;exectype = tez&quot;를 conf / pig.properties에 추가하여 기본 실행 유형을 Tez로 변경할 수 있습니다. Java 시스템 특성 &quot;-Dexectype = tez&quot;도 Tez 모드를 트리거하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c3ebe4f496379cae549f69b9c922d65a68b08117" translate="yes" xml:space="preserve">
          <source>To run script &quot;myscript.pig&quot; without the optimization, execute Pig as follows:</source>
          <target state="translated">최적화없이 &quot;myscript.pig&quot;스크립트를 실행하려면 다음과 같이 Pig를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c871b6b2b96ef0f81307fec7e5bf05f6bebfe270" translate="yes" xml:space="preserve">
          <source>To run the Pig scripts in local mode, do the following:</source>
          <target state="translated">로컬 모드에서 Pig 스크립트를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3084ac58a1518b99727338bc0305d729ff577faf" translate="yes" xml:space="preserve">
          <source>To run the Pig scripts in mapreduce mode, do the following:</source>
          <target state="translated">mapreduce 모드에서 Pig 스크립트를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="81f90430422855d53750bcb0f628401421b91f31" translate="yes" xml:space="preserve">
          <source>To specify Hadoop properties you can use the same mechanisms:</source>
          <target state="translated">하둡 속성을 지정하려면 동일한 메커니즘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41aa42790f55dd42419657bac227fe9734d57014" translate="yes" xml:space="preserve">
          <source>To specify Pig properties use one of these mechanisms:</source>
          <target state="translated">Pig 속성을 지정하려면 다음 메커니즘 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="49ea1e14a8e9eb08a89175b2b720fabc0acab605" translate="yes" xml:space="preserve">
          <source>To specify a long constant, l or L must be appended to the number (for example, 12345678L). If the l or L is not specified, but the number is too large to fit into an int, the problem will be detected at parse time and the processing is terminated.</source>
          <target state="translated">긴 상수를 지정하려면 숫자에 l 또는 L을 추가해야합니다 (예 : 12345678L). l 또는 L이 지정되지 않았지만 숫자가 너무 커서 int에 맞지 않으면 구문 분석시 문제점이 감지되고 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7349c3a3bcd72f5ad883a8868bd7f1666aa46a" translate="yes" xml:space="preserve">
          <source>To store information, the UDF calls getUDFProperties. This returns a Properties object which the UDF can record the information in or read the information from. To avoid name space conflicts UDFs are required to provide a signature when obtaining a Properties object. This can be done in two ways. The UDF can provide its Class object (via this.getClass()). In this case, every instantiation of the UDF will be given the same Properties object. The UDF can also provide its Class plus an array of Strings. The UDF can pass its constructor arguments, or some other identifying strings. This allows each instantiation of the UDF to have a different properties object thus avoiding name space collisions between instantiations of the UDF.</source>
          <target state="translated">정보를 저장하기 위해 UDF는 getUDFProperties를 호출합니다. 이것은 UDF가 정보를 기록하거나 정보를 읽을 수있는 Properties 오브젝트를 리턴합니다. 네임 스페이스 충돌을 피하려면 UDF는 특성 오브젝트를 확보 할 때 서명을 제공해야합니다. 이것은 두 가지 방법으로 수행 할 수 있습니다. UDF는 클래스 객체를 제공 할 수 있습니다 (this.getClass ()를 통해). 이 경우 UDF의 모든 인스턴스화에는 동일한 Properties 오브젝트가 제공됩니다. UDF는 클래스와 문자열 배열도 제공 할 수 있습니다. UDF는 생성자 인수 또는 다른 식별 문자열을 전달할 수 있습니다. 이것은 UDF의 각 인스턴스화가 다른 특성 오브젝트를 가질 수있게하여 UDF의 인스턴스화 사이의 이름 공간 충돌을 피합니다.</target>
        </trans-unit>
        <trans-unit id="83bdb394ac68528a25357d7ba31b761ec369542f" translate="yes" xml:space="preserve">
          <source>To store this bag into a file called &quot;measurements&quot;, you can use a statement like:</source>
          <target state="translated">이 백을 &quot;measurements&quot;라는 파일에 저장하려면 다음과 같은 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b5039c6bd83c0a4b510a98fafc60885ba6e4d7" translate="yes" xml:space="preserve">
          <source>To take advantage of this optimization, make sure that the table with the largest number of tuples per key is the last table in your query. In some of our tests we saw 10x performance improvement as the result of this optimization.</source>
          <target state="translated">이 최적화를 활용하려면 키당 튜플 수가 가장 많은 테이블이 쿼리의 마지막 테이블인지 확인하십시오. 일부 테스트에서이 최적화의 결과로 성능이 10 배 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="80e0ecbc5f050adc3253bb72224503d49d530580" translate="yes" xml:space="preserve">
          <source>To use a function, you need to determine which package it belongs to. The top level packages correspond to the function type and currently are:</source>
          <target state="translated">함수를 사용하려면 해당 패키지가 속한 패키지를 결정해야합니다. 최상위 패키지는 기능 유형에 해당하며 현재 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="999b06561a4a460b63c02ed03a6684480783a12e" translate="yes" xml:space="preserve">
          <source>To use the Hadoop Partitioner add PARTITION BY clause to the appropriate operator:</source>
          <target state="translated">Hadoop Partitioner를 사용하려면 PARTITION BY 절을 적절한 연산자에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b464621182ad0acea5ad12e5955b293bb31e4a" translate="yes" xml:space="preserve">
          <source>To work with bzip compressed files, the input/output files need to have a .bz or .bz2 extension. Because the compression is block-oriented, bzipped files can be split across multiple maps.</source>
          <target state="translated">bzip 압축 파일로 작업하려면 입력 / 출력 파일의 확장자가 .bz 또는 .bz2 여야합니다. 압축은 블록 중심이므로 bzipped 파일은 여러 맵으로 분할 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="353a93f063fb93797ecc62c1678f7b4ef9140314" translate="yes" xml:space="preserve">
          <source>To work with gzip compressed files, input/output files need to have a .gz extension. Gzipped files cannot be split across multiple maps; this means that the number of maps created is equal to the number of part files in the input location.</source>
          <target state="translated">gzip 압축 파일을 사용하려면 입력 / 출력 파일의 확장자가 .gz 여야합니다. 압축 된 파일은 여러 맵으로 분할 할 수 없습니다. 이는 작성된 맵 수가 입력 위치에있는 부품 파일 수와 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f8ef015ffaff8e9f423a3a273a67d25d3d671b65" translate="yes" xml:space="preserve">
          <source>ToDate</source>
          <target state="translated">ToDate</target>
        </trans-unit>
        <trans-unit id="4cd1078f9b06216bb97d35ca5a9d9f53c1e4f1e4" translate="yes" xml:space="preserve">
          <source>ToDate(iosstring)</source>
          <target state="translated">ToDate(iosstring)</target>
        </trans-unit>
        <trans-unit id="514316b5754ec3292cd4173be3953dff90fdc7e2" translate="yes" xml:space="preserve">
          <source>ToDate(milliseconds)</source>
          <target state="translated">ToDate(milliseconds)</target>
        </trans-unit>
        <trans-unit id="6c3a5e725bdda245f1573fa44cd9bfed255b4d89" translate="yes" xml:space="preserve">
          <source>ToDate(userstring, format)</source>
          <target state="translated">ToDate (사용자 문자열, 형식)</target>
        </trans-unit>
        <trans-unit id="a1e696c45a34c7151c0729ae0b95de675f0f1977" translate="yes" xml:space="preserve">
          <source>ToDate(userstring, format, timezone)</source>
          <target state="translated">ToDate (사용자 문자열, 형식, 시간대)</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="cec337942193c9cec73135f8a7bb32b588607d66" translate="yes" xml:space="preserve">
          <source>ToMilliSeconds</source>
          <target state="translated">ToMilliSeconds</target>
        </trans-unit>
        <trans-unit id="795476c8e9ac2cd01ed1afe01d7e4f6c8d5bd39f" translate="yes" xml:space="preserve">
          <source>ToMilliSeconds(CurrentTime())</source>
          <target state="translated">ToMilliSeconds(CurrentTime())</target>
        </trans-unit>
        <trans-unit id="601a9bae94d57671c879ff892a2131690d5e208e" translate="yes" xml:space="preserve">
          <source>ToMilliSeconds(datetime)</source>
          <target state="translated">ToMilliSeconds(datetime)</target>
        </trans-unit>
        <trans-unit id="1dbc7385badbfda548fb27e2160a33cf32c0f545" translate="yes" xml:space="preserve">
          <source>ToString</source>
          <target state="translated">ToString</target>
        </trans-unit>
        <trans-unit id="f2a84f91b419c8c37d012170cb7d148e9f02e11c" translate="yes" xml:space="preserve">
          <source>ToString converts the DateTime object to the ISO or the customized string.</source>
          <target state="translated">ToString은 DateTime 개체를 ISO 또는 사용자 지정 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3bc9083ee22f29b0c7008ff73b6bfea841928174" translate="yes" xml:space="preserve">
          <source>ToString(CurrentTime(), 'yyyy-MM-dd HH:mm:ss Z')</source>
          <target state="translated">ToString (CurrentTime (), 'yyyy-MM-dd HH : mm : ss Z')</target>
        </trans-unit>
        <trans-unit id="cdef788bed7580bb80d82108517ff98135ba24ae" translate="yes" xml:space="preserve">
          <source>ToString(datetime [, format string])</source>
          <target state="translated">ToString (날짜 시간 [, 형식 문자열])</target>
        </trans-unit>
        <trans-unit id="a681ef9374ca3da5554c7c0483b87df6931f59d0" translate="yes" xml:space="preserve">
          <source>ToUnixTime</source>
          <target state="translated">ToUnixTime</target>
        </trans-unit>
        <trans-unit id="01cf064f8cedbba6a8076153858220f95b8ee1f1" translate="yes" xml:space="preserve">
          <source>ToUnixTime(datetime)</source>
          <target state="translated">ToUnixTime(datetime)</target>
        </trans-unit>
        <trans-unit id="186d477aa80f2ae0c3fdeeff469eead3b085e4e2" translate="yes" xml:space="preserve">
          <source>Top results:</source>
          <target state="translated">최고 결과 :</target>
        </trans-unit>
        <trans-unit id="ed1c409e8b0b54be4ce0b3a2e02dd7ab71a8e3e6" translate="yes" xml:space="preserve">
          <source>Transitive helps specifying if you need the dependencies along with the registering jar. By setting transitive to false in the querystring we can tell pig to register only the artifact without its dependencies. This will download only the artifact specified and will not download the dependencies of the jar. The default value of transitive is true.</source>
          <target state="translated">전이는 등록 항아리와 함께 종속성이 필요한지 지정하는 데 도움이됩니다. querystring에서 transitive를 false로 설정하면 종속물없이 이슈 만 등록하도록 pig에 지시 할 수 있습니다. 지정된 아티팩트 만 다운로드하고 jar의 종속성을 다운로드하지 않습니다. 전이의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="77aa03832a1146b22f4c70f02a63ceaf05ab8040" translate="yes" xml:space="preserve">
          <source>Translated Avro Type</source>
          <target state="translated">번역 된 Avro 유형</target>
        </trans-unit>
        <trans-unit id="cc1eed170430e9e13b295e12d2f19abffefd2bb8" translate="yes" xml:space="preserve">
          <source>Translated Pig Type</source>
          <target state="translated">번역 된 돼지 유형</target>
        </trans-unit>
        <trans-unit id="36d7fab83303db7097b3062f17ec492bf7d05e2d" translate="yes" xml:space="preserve">
          <source>Trevni is a column-oriented storage format that is part of the Apache Avro project. Trevni is closely related to Avro.</source>
          <target state="translated">Trevni는 Apache Avro 프로젝트의 일부인 열 지향 스토리지 형식입니다. Trevni는 Avro와 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa1f00686a8b51b3da0e4fe3313fb2460cd075b" translate="yes" xml:space="preserve">
          <source>TrevniStorage</source>
          <target state="translated">TrevniStorage</target>
        </trans-unit>
        <trans-unit id="7079c63ef4dba92d65af4a88d31f2d8803345f92" translate="yes" xml:space="preserve">
          <source>TrevniStorage(['schema|record name'], ['options'])</source>
          <target state="translated">TrevniStorage ([ '스키마 | 레코드 이름'], [ '옵션'])</target>
        </trans-unit>
        <trans-unit id="ae7c25d974b03822cbdab495aebca1237aa4757a" translate="yes" xml:space="preserve">
          <source>Troubleshooting Tips</source>
          <target state="translated">문제 해결 팁</target>
        </trans-unit>
        <trans-unit id="39132781fcfd91c588af3fea5203f5d6cc22627a" translate="yes" xml:space="preserve">
          <source>Tuning options</source>
          <target state="translated">튜닝 옵션</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="bbf61cf6fd3254a549619060026f62d4160c2f6c" translate="yes" xml:space="preserve">
          <source>Tuple Expressions</source>
          <target state="translated">튜플 표현식</target>
        </trans-unit>
        <trans-unit id="cc59b18243a22e1ab382f1fbf59caef1165bf7e9" translate="yes" xml:space="preserve">
          <source>Tuple Schemas</source>
          <target state="translated">튜플 스키마</target>
        </trans-unit>
        <trans-unit id="fc1502ea166bcc0b352d501990f70c772dd7fdd8" translate="yes" xml:space="preserve">
          <source>Tuple and DataBag are different in that they are not concrete classes but rather interfaces. This enables users to extend Pig with their own versions of tuples and bags. As a result, UDFs cannot directly instantiate bags or tuples; they need to go through factory classes: TupleFactory and BagFactory.</source>
          <target state="translated">Tuple과 DataBag는 구체적인 클래스가 아니라 인터페이스라는 점에서 다릅니다. 이를 통해 사용자는 자체 버전의 튜플 및 백으로 Pig를 확장 할 수 있습니다. 결과적으로 UDF는 백이나 튜플을 직접 인스턴스화 할 수 없습니다. TupleFactory와 BagFactory라는 팩토리 클래스를 거쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="7957226cdc446a295266efbd03bd6e77243960a8" translate="yes" xml:space="preserve">
          <source>Tuple dereferencing can be done by name (tuple.field_name) or position (mytuple.$0). If a set of fields are dereferenced (tuple.(name1, name2) or tuple.($0, $1)), the expression represents a tuple composed of the specified fields. Note that if the dot operator is applied to a bytearray, the bytearray will be assumed to be a tuple.</source>
          <target state="translated">튜플 역 참조는 이름 (tuple.field_name) 또는 위치 (mytuple. $ 0)로 수행 할 수 있습니다. 필드 세트가 역 참조 (tuple. (name1, name2) 또는 tuple. ($ 0, $ 1)) 인 경우 표현식은 지정된 필드로 구성된 튜플을 나타냅니다. 도트 연산자가 바이트 배열에 적용되면 바이트 배열은 튜플로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0017f514449ecc779f4e278e71f102c749127099" translate="yes" xml:space="preserve">
          <source>Tuple expressions form subexpressions into tuples. The tuple expression has the form (expression [, expression &amp;hellip;]), where expression is a general expression. The simplest tuple expression is the star expression, which represents all fields.</source>
          <target state="translated">튜플 표현식은 하위 표현식을 튜플로 형성합니다. 튜플 표현식의 형식은 (expression [, expression ...])이며 여기서 expression은 일반 표현식입니다. 가장 간단한 튜플 식은 모든 필드를 나타내는 별 식입니다.</target>
        </trans-unit>
        <trans-unit id="519bcfdf20c09e0d8dde8480e9fe4df23b951b84" translate="yes" xml:space="preserve">
          <source>Tuple, Bag, Map Functions</source>
          <target state="translated">튜플, 백, 맵 함수</target>
        </trans-unit>
        <trans-unit id="19dabf0c122323ac6f5bd3c9aae10eaec25619bc" translate="yes" xml:space="preserve">
          <source>Tuple: groovy.lang.Tuple</source>
          <target state="translated">튜플 : groovy.lang.Tuple</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="7455bf0b5358c0f2196900a11da25f6b4b71852a" translate="yes" xml:space="preserve">
          <source>Turning it On or Off</source>
          <target state="translated">켜거나 끄기</target>
        </trans-unit>
        <trans-unit id="b0ab0e6b8ba4ecd3d3a80948e9d7598dcffc690a" translate="yes" xml:space="preserve">
          <source>Turns debug-level logging on or off.</source>
          <target state="translated">디버그 레벨 로깅을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="03062718226e2d976892e74dfca4da21d07fd85a" translate="yes" xml:space="preserve">
          <source>TutorialUtil</source>
          <target state="translated">TutorialUtil</target>
        </trans-unit>
        <trans-unit id="660ad1a7ec1147bfb1740d6783f1ae02a608e6e5" translate="yes" xml:space="preserve">
          <source>Two items, one required:</source>
          <target state="translated">두 항목, 하나 필요 :</target>
        </trans-unit>
        <trans-unit id="a0a40cbc27f1b82964cce85380a30f4fcd1061ed" translate="yes" xml:space="preserve">
          <source>Two run scenarios are optimized, as explained below: explicit and implicit splits, and storing intermediate results.</source>
          <target state="translated">아래 설명 된대로 명시 적 및 암시 적 분할과 중간 결과 저장이라는 두 가지 실행 시나리오가 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd5c7330fc58d0eea691b4374f311f9cfaa2f81" translate="yes" xml:space="preserve">
          <source>Type Construction Operators</source>
          <target state="translated">유형 건설 연산자</target>
        </trans-unit>
        <trans-unit id="476929e368140c8ba063ef3731334ffa7387b9f4" translate="yes" xml:space="preserve">
          <source>Type Conversions</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="61c938e021ec6cef2d79522eb7086e13402194d0" translate="yes" xml:space="preserve">
          <source>Type information must be provided for the join key in the schema.</source>
          <target state="translated">스키마에서 조인 키에 대한 유형 정보를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="62ba8b16937b3dae732a006e6c6fb12bbeb031d7" translate="yes" xml:space="preserve">
          <source>Type information must be provided in the schema for all the loaders.</source>
          <target state="translated">모든 로더에 대한 스키마에 유형 정보가 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c59dcb8be096edaa5b4a0a597de8dc64ef373896" translate="yes" xml:space="preserve">
          <source>Typecasting from bytearrays</source>
          <target state="translated">바이트 배열에서 타입 캐스팅</target>
        </trans-unit>
        <trans-unit id="d814d53e4fac60a9801d59cea66d08ad4d314e44" translate="yes" xml:space="preserve">
          <source>Types Table</source>
          <target state="translated">유형 테이블</target>
        </trans-unit>
        <trans-unit id="a619c85c0f0d33211baeb69f6b912f4a77f1387f" translate="yes" xml:space="preserve">
          <source>Types Table: addition (+) and subtraction (-) operators</source>
          <target state="translated">유형 테이블 : 더하기 (+) 및 빼기 (-) 연산자</target>
        </trans-unit>
        <trans-unit id="3e26b87c56002f7501e02aaf16cedc945a10ae28" translate="yes" xml:space="preserve">
          <source>Types Table: equal (==) operator</source>
          <target state="translated">유형 테이블 : 같음 (==) 연산자</target>
        </trans-unit>
        <trans-unit id="8de3e2b78f2a870d52c20e5c828765e43d577bc1" translate="yes" xml:space="preserve">
          <source>Types Table: matches operator</source>
          <target state="translated">유형 테이블 : 연산자 일치</target>
        </trans-unit>
        <trans-unit id="d9882f1e8518edce58a9e892840f1d76d8337fa0" translate="yes" xml:space="preserve">
          <source>Types Table: modulo (%) operator</source>
          <target state="translated">유형 테이블 : 모듈로 (%) 연산자</target>
        </trans-unit>
        <trans-unit id="cd813bdd3f49f1cd19fabbd7db29870eb7d4f3ec" translate="yes" xml:space="preserve">
          <source>Types Table: multiplication (*) and division (/) operators</source>
          <target state="translated">유형 테이블 : 곱셈 (*) 및 나누기 (/) 연산자</target>
        </trans-unit>
        <trans-unit id="2c925a0a99c4d6a5c04dcfa50f5d5ad64b284d6d" translate="yes" xml:space="preserve">
          <source>Types Table: negative ( - ) operator</source>
          <target state="translated">유형 테이블 : 음수 (-) 연산자</target>
        </trans-unit>
        <trans-unit id="671dd0889370802a2fcc04bebf75c3920e9cff17" translate="yes" xml:space="preserve">
          <source>Types Table: not equal (!=) operator</source>
          <target state="translated">유형 테이블 : 같지 않음 (! =) 연산자</target>
        </trans-unit>
        <trans-unit id="0af001a1eab973daf42a82dc9eecc57948bbde05" translate="yes" xml:space="preserve">
          <source>Types Tables</source>
          <target state="translated">유형 테이블</target>
        </trans-unit>
        <trans-unit id="9711f1a83ed065b27c81af08a634fd48bcc6b207" translate="yes" xml:space="preserve">
          <source>UCFIRST</source>
          <target state="translated">UCFIRST</target>
        </trans-unit>
        <trans-unit id="d748b23c290d890ff211057326a56ef935ae9aba" translate="yes" xml:space="preserve">
          <source>UCFIRST(expression)</source>
          <target state="translated">UCFIRST(expression)</target>
        </trans-unit>
        <trans-unit id="87f73bd7b8182fa086c1862162eaa8f054d3f5fe" translate="yes" xml:space="preserve">
          <source>UDF Interfaces</source>
          <target state="translated">UDF 인터페이스</target>
        </trans-unit>
        <trans-unit id="fd65861ed31abb9c20fc0999ad6dd8bb0cabbbc0" translate="yes" xml:space="preserve">
          <source>UDF Statements</source>
          <target state="translated">UDF 문</target>
        </trans-unit>
        <trans-unit id="a405c0e041790fe13c13a1707d136259249594ea" translate="yes" xml:space="preserve">
          <source>UDF jars Not Found</source>
          <target state="translated">UDF 항아리를 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="0ccdd116c8e408da7d36d004362ebde7866a80fd" translate="yes" xml:space="preserve">
          <source>UDF writers are encouraged to provide type-specific versions of a function if this can result in better performance. On the other hand, we don't want the users of the functions to worry about different functions - the right thing should just happen. Pig allows for this via a function table mechanism as shown in the next example.</source>
          <target state="translated">UDF 작성자는 성능이 향상 될 수있는 경우 유형별 기능 버전을 제공하도록 권장됩니다. 반면에, 우리는 함수의 사용자가 다른 함수에 대해 걱정하는 것을 원하지 않습니다. 올바른 일이 일어나야합니다. Pig는 다음 예제와 같이 함수 테이블 메커니즘을 통해이를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15c001243ba36104a71961da7ee4c9ba8bfd2796" translate="yes" xml:space="preserve">
          <source>UDFs also have to adhere to the previous condition and should not transform the JOIN keys in a way that would change the sort order.</source>
          <target state="translated">UDF는 또한 이전 조건을 준수해야하며 정렬 순서를 변경하는 방식으로 JOIN 키를 변환하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="82035e44f44fb2ec36c6242949f2b1821450c071" translate="yes" xml:space="preserve">
          <source>UDFs and Pig scripts are generally stored in separate files. For testing purposes you can combine the code in a single file - a &quot;combined&quot; script. Note, however, if you then decide to embed this &quot;combined&quot; script in a host language, the language of the UDF and the host language must match.</source>
          <target state="translated">UDF 및 Pig 스크립트는 일반적으로 별도의 파일에 저장됩니다. 테스트 목적으로 코드를 단일 파일 ( &quot;결합 된&quot;스크립트)로 결합 할 수 있습니다. 그러나이 &quot;결합 된&quot;스크립트를 호스트 언어로 임베드하기로 결정한 경우 UDF 언어와 호스트 언어가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9534a9b692fc876a0670a9b2a3384ba8ca3dbc3e" translate="yes" xml:space="preserve">
          <source>UDFs and Pig scripts are generally stored in separate files. For testing purposes you can combine the code in a single file - a &quot;combined&quot; script. Note, however, if you then decide to embed this &quot;combined&quot; script in a host language, the language of the UDF must match the host language.</source>
          <target state="translated">UDF 및 Pig 스크립트는 일반적으로 별도의 파일에 저장됩니다. 테스트 목적으로 코드를 단일 파일 ( &quot;결합 된&quot;스크립트)로 결합 할 수 있습니다. 그러나이 &quot;결합 된&quot;스크립트를 호스트 언어로 임베드하기로 결정한 경우 UDF 언어는 호스트 언어와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="1dacd1c3580a87251613889fab79308e30a33108" translate="yes" xml:space="preserve">
          <source>UPPER</source>
          <target state="translated">UPPER</target>
        </trans-unit>
        <trans-unit id="b2e36d032b7f0f24b9d7ec3c414e41ed6ad4fd7b" translate="yes" xml:space="preserve">
          <source>UPPER(expression)</source>
          <target state="translated">UPPER(expression)</target>
        </trans-unit>
        <trans-unit id="7ad1e7b093e2665ff1bdef8789dda91b1e51fde7" translate="yes" xml:space="preserve">
          <source>UPPERCASE</source>
          <target state="translated">UPPERCASE</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="1162ed51ba49e5a917ac13789ff2df1516b06323" translate="yes" xml:space="preserve">
          <source>USING &amp;ndash; Keyword.</source>
          <target state="translated">사용 &amp;ndash; 키워드.</target>
        </trans-unit>
        <trans-unit id="e4a7f04091ac9d1629b1c844c7b226c7b1cdaa50" translate="yes" xml:space="preserve">
          <source>Un-nests the elements of a bag into a tuple.</source>
          <target state="translated">가방의 요소를 튜플에 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8793c58a5003adf979cd34caf39c37da75f17049" translate="yes" xml:space="preserve">
          <source>Union columns of compatible type will produce an &quot;escalate&quot; type. The priority is:</source>
          <target state="translated">호환 가능한 유형의 통합 열은 &quot;확장&quot;유형을 생성합니다. 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b27c466048bbd7e41432f8c9a4dd54773c629248" translate="yes" xml:space="preserve">
          <source>Union columns with incompatible types results in a failure. (See &lt;a href=&quot;#types-table-add&quot;&gt;Types Table for addition and subtraction&lt;/a&gt; for incompatible types.)</source>
          <target state="translated">유형이 호환되지 않는 통합 열은 실패합니다. 호환되지 않는 유형의 &lt;a href=&quot;#types-table-add&quot;&gt;덧셈과 뺄셈&lt;/a&gt; 은 유형 표를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0150d8270b2e716da72db4f2f16c7f2e8c76be02" translate="yes" xml:space="preserve">
          <source>Union of different inner types results in an empty complex type:</source>
          <target state="translated">다른 내부 유형의 연합으로 인해 빈 복합 유형이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f675297cba1cfdc80b369f7b3b5852a01945a27" translate="yes" xml:space="preserve">
          <source>Union on relations with two different sizes result in a null schema (union only):</source>
          <target state="translated">서로 다른 두 가지 크기의 관계에 대한 결합으로 인해 널 스키마가 발생합니다 (유니언 만 해당).</target>
        </trans-unit>
        <trans-unit id="b27f5a5ac819d7119a32c3d6a86268ca111fa0ce" translate="yes" xml:space="preserve">
          <source>UniqueID</source>
          <target state="translated">UniqueID</target>
        </trans-unit>
        <trans-unit id="f82ab1808abfcc69ba887a3bb42824c40345f4f9" translate="yes" xml:space="preserve">
          <source>UniqueID generates a unique id for each records. The id takes form &quot;taskindex-sequence&quot;</source>
          <target state="translated">UniqueID는 각 레코드에 대해 고유 한 ID를 생성합니다. ID는 &quot;taskindex-sequence&quot;형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="05785067e3cd6d24a4f4e69eb164542e358289a4" translate="yes" xml:space="preserve">
          <source>Unix and Windows users need the following:</source>
          <target state="translated">Unix 및 Windows 사용자는 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b1795a345347d7c9e76c19cbf0c4c7d1eac6b2b4" translate="yes" xml:space="preserve">
          <source>Unlike user defined functions (UDFs), which only allow quoted strings as its parameters, Pig macros support four types of parameters:</source>
          <target state="translated">인용 된 문자열 만 매개 변수로 허용하는 사용자 정의 함수 (UDF)와 달리 Pig 매크로는 다음 네 가지 유형의 매개 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3b16f4d28cc67bd7b4c3927f65c1dbdd2da66f0d" translate="yes" xml:space="preserve">
          <source>Unordered data &amp;ndash; No guarantee for the order in which the data is delivered to the streaming application.</source>
          <target state="translated">정렬되지 않은 데이터 &amp;ndash; 데이터가 스트리밍 응용 프로그램으로 전달되는 순서를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e546a98953dafdf55dbecc42cfd53a5c3d6a01" translate="yes" xml:space="preserve">
          <source>Unpack the downloaded Pig distribution, and then note the following:</source>
          <target state="translated">다운로드 한 Pig 배포를 풀고 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="7d0a6f565be606dc6ebbf471651cfebe617dd6a1" translate="yes" xml:space="preserve">
          <source>Unzip the pigtutorial.tar.gz file.</source>
          <target state="translated">pigtutorial.tar.gz 파일을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="31fdeb34a4f4bc8a7b882018ab434e09d2defd44" translate="yes" xml:space="preserve">
          <source>Usage Examples</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="d6d15e732a3c518018896f6f2664aa858a6874c5" translate="yes" xml:space="preserve">
          <source>Use &quot;-help properties&quot; to get a list of properties.</source>
          <target state="translated">&quot;-help properties&quot;를 사용하여 속성 목록을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="862ee49c84a0d145c0373343d5f752649d549039" translate="yes" xml:space="preserve">
          <source>Use &quot;-help&quot; to get a list of commands.</source>
          <target state="translated">&quot;-help&quot;를 사용하여 명령 목록을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="c2f2f926d2d8047036be447bd6b0389c04aff014" translate="yes" xml:space="preserve">
          <source>Use DEFINE to specify a UDF function when:</source>
          <target state="translated">다음과 같은 경우 DEFINE을 사용하여 UDF 기능을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fe02e4a2ee56fef507832f7da1f6dce0384e7619" translate="yes" xml:space="preserve">
          <source>Use DEFINE to specify a streaming command when:</source>
          <target state="translated">다음과 같은 경우 DEFINE을 사용하여 스트리밍 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="cfab99e0bcbf874f56503facab7e04b1e7f3689f" translate="yes" xml:space="preserve">
          <source>Use JsonLoader to load JSON data.</source>
          <target state="translated">JsonLoader를 사용하여 JSON 데이터를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="01b0272d9c404cc660102354506d36c2b9e3ba01" translate="yes" xml:space="preserve">
          <source>Use JsonStorage to store JSON data.</source>
          <target state="translated">JsonStorage를 사용하여 JSON 데이터를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="f2c6b833cbe82666d85534512c0d00ac437ce227" translate="yes" xml:space="preserve">
          <source>Use Optimization</source>
          <target state="translated">최적화 사용</target>
        </trans-unit>
        <trans-unit id="f3efcc91bf459e27078d2235ad41669264073d9a" translate="yes" xml:space="preserve">
          <source>Use Pig scripts to place Pig Latin statements and Pig commands in a single file. While not required, it is good practice to identify the file using the *.pig extension.</source>
          <target state="translated">Pig 스크립트를 사용하여 Pig Latin 문 및 Pig 명령을 단일 파일에 배치하십시오. 필수는 아니지만 * .pig 확장자를 사용하여 파일을 식별하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f1b5134b8be317ff7cd5444d83e2318a4ae47993" translate="yes" xml:space="preserve">
          <source>Use Pig's Administration features &lt;a href=&quot;admin&quot;&gt;Administration&lt;/a&gt; which provides properties that could be set to be used by all your users.</source>
          <target state="translated">모든 사용자가 사용할 수있는 속성을 제공하는 Pig의 관리 기능 &lt;a href=&quot;admin&quot;&gt;관리&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6f250441e1d9e56c21dbb3177f4b1d01e5bfb0" translate="yes" xml:space="preserve">
          <source>Use Types</source>
          <target state="translated">사용 유형</target>
        </trans-unit>
        <trans-unit id="ebb19892e84a86bc3b6b810dd455ff9fb7adc54f" translate="yes" xml:space="preserve">
          <source>Use an explicit empty string to just smush everything together</source>
          <target state="translated">명시 적으로 빈 문자열을 사용하여 모든 것을 하나로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="db9eec7278f69eef011d6f87842f13482560306a" translate="yes" xml:space="preserve">
          <source>Use assert to ensure a condition is true on your data. Processing fails if any of the records voilate the condition.</source>
          <target state="translated">assert를 사용하여 데이터에 조건이 맞는지 확인하십시오. 레코드가 조건을 위반하면 처리가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cc278f0a075bb6b341b3e3e78563e318c8b3241e" translate="yes" xml:space="preserve">
          <source>Use expressions only (relational operators are not allowed).</source>
          <target state="translated">표현식 만 사용하십시오 (관계 연산자는 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="c465e6ac2330bb67aa8195176ac3a21c62bbc05d" translate="yes" xml:space="preserve">
          <source>Use getCacheFiles or getShipFiles to return a list of HDFS files or local files that need to be shipped to distributed cache. Inside exec method, you can assume that these files already exist in distributed cache. For example:</source>
          <target state="translated">getCacheFiles 또는 getShipFiles를 사용하여 분산 캐시로 전달해야하는 HDFS 파일 또는 로컬 파일 목록을 리턴하십시오. exec 메소드에서 이러한 파일이 분산 캐시에 이미 있다고 가정 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2574e083a6b8fc27b8cca13781df343ee19495c2" translate="yes" xml:space="preserve">
          <source>Use schemas to assign types to fields. If you don't assign types, fields default to type bytearray and implicit conversions are applied to the data depending on the context in which that data is used. For example, in relation B, f1 is converted to integer because 5 is integer. In relation C, f1 and f2 are converted to double because we don't know the type of either f1 or f2.</source>
          <target state="translated">스키마를 사용하여 필드에 유형을 지정하십시오. 유형을 지정하지 않으면 필드는 기본적으로 유형 바이트 배열로 지정되며 암시 적 변환은 해당 데이터가 사용되는 컨텍스트에 따라 데이터에 적용됩니다. 예를 들어, 관계 B에서 5는 정수이므로 f1은 정수로 변환됩니다. 관계 C에서 f1과 f2의 유형을 모르기 때문에 f1과 f2는 double로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5b9740fc68f6a1aebc14d17259abfceeb413bb58" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;collected&amp;rsquo; clause with the GROUP operation (works with one relation only).</source>
          <target state="translated">GROUP 연산과 함께 'collected'절을 사용하십시오 (한 관계에서만 작동).</target>
        </trans-unit>
        <trans-unit id="fb1d0bf24e1d1bf7496cb4cecb1dd7afe1965e33" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;merge&amp;rsquo; clause with the COGROUP operation (works with two or more relations only).</source>
          <target state="translated">COGROUP 조작과 함께 'merge'절을 사용하십시오 (두 개 이상의 관계에서만 작동).</target>
        </trans-unit>
        <trans-unit id="12dc263422d03206fa5f7c1b3bbcabd66e7a95ed" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;basic#filter&quot;&gt;FILTER&lt;/a&gt; operator to work with tuples or rows of data. Use the &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt; operator to work with columns of data.</source>
          <target state="translated">&lt;a href=&quot;basic#filter&quot;&gt;FILTER&lt;/a&gt; 연산자를 사용하여 튜플 또는 데이터 행에 대해 작업 하십시오 . &lt;a href=&quot;basic#foreach&quot;&gt;FOREACH&lt;/a&gt; 연산자를 사용하여 데이터 열에 대해 작업 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a76e57fe36119dc09b2acfe417cf604d832f7ff" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator to group data in a single relation. Use the &lt;a href=&quot;basic#cogroup&quot;&gt;COGROUP&lt;/a&gt;, &lt;a href=&quot;basic#join-inner&quot;&gt;inner JOIN&lt;/a&gt;, and &lt;a href=&quot;basic#join-outer&quot;&gt;outer JOIN&lt;/a&gt; operators to group or join data in two or more relations.</source>
          <target state="translated">&lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; 연산자를 사용하여 단일 관계로 데이터를 그룹화 하십시오 . 사용 &lt;a href=&quot;basic#cogroup&quot;&gt;COGROUP을&lt;/a&gt; , &lt;a href=&quot;basic#join-inner&quot;&gt;내부 조인&lt;/a&gt; 과 &lt;a href=&quot;basic#join-outer&quot;&gt;외부는 가입&lt;/a&gt; 두 개 이상의 관계에서 데이터를 그룹에 운영자 또는 가입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eccf060ba887374ab51446b58c8d76bb0255295" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;basic#load&quot;&gt;LOAD&lt;/a&gt; operator and the &lt;a href=&quot;udf#load-store-functions&quot;&gt;load/store functions&lt;/a&gt; to read data into Pig (PigStorage is the default load function).</source>
          <target state="translated">사용 &lt;a href=&quot;basic#load&quot;&gt;LOAD의&lt;/a&gt; 운영자 및 &lt;a href=&quot;udf#load-store-functions&quot;&gt;로드 / 저장 기능&lt;/a&gt; (PigStorage 기본 부하의 함수이다) 돼지에 데이터를 읽고.</target>
        </trans-unit>
        <trans-unit id="7cd8bac801951d44aab13b5b837806b189ec8dfc" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;basic#store&quot;&gt;STORE&lt;/a&gt; operator and the &lt;a href=&quot;udf#load-store-functions&quot;&gt;load/store functions&lt;/a&gt; to write results to the file system (PigStorage is the default store function).</source>
          <target state="translated">&lt;a href=&quot;basic#store&quot;&gt;STORE&lt;/a&gt; 연산자 및 &lt;a href=&quot;udf#load-store-functions&quot;&gt;로드 / 저장 기능&lt;/a&gt; 을 사용하여 결과를 파일 시스템에 씁니다 (PigStorage가 기본 저장 기능 임).</target>
        </trans-unit>
        <trans-unit id="d6ded132dc4a94bc5f98674878f2e704b1996455" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt; operator to merge the contents of two or more relations. Use the &lt;a href=&quot;basic#split&quot;&gt;SPLIT&lt;/a&gt; operator to partition the contents of a relation into multiple relations.</source>
          <target state="translated">&lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt; 연산자를 사용하여 둘 이상의 관계 내용을 병합하십시오. &lt;a href=&quot;basic#split&quot;&gt;SPLIT&lt;/a&gt; 연산자를 사용하여 관계의 내용을 여러 관계로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="8af9146f23aeaf92b8b84bc799406065ca4bb8eb" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;cmds#set&quot;&gt;set default parallel&lt;/a&gt; command to set the number of reducers at the script level.</source>
          <target state="translated">사용 &lt;a href=&quot;cmds#set&quot;&gt;설정 기본 병렬&lt;/a&gt; 스크립트 수준에서 감속기의 수를 설정하는 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f80e649666d59a2f150113eedd1ffa285eda7846" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; operator to review the schema of a relation.</source>
          <target state="translated">&lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; 연산자를 사용하여 관계의 스키마를 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="f96b1715cc9fc2feecd0ae5beb59d880f152dce2" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; operator to display results to your terminal screen.</source>
          <target state="translated">&lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; 연산자를 사용하여 결과를 터미널 화면에 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="5ff4648da890ac309bdfa39d06c9b854887fdb46" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; operator to view the logical, physical, or map reduce execution plans to compute a relation.</source>
          <target state="translated">&lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; 연산자를 사용하여 논리, 물리적 또는 맵 감소 실행 계획을보고 관계를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="dde401bd87ee0386ce7cd09ebed710923a7156e9" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;test#illustrate&quot;&gt;ILLUSTRATE&lt;/a&gt; operator to view the step-by-step execution of a series of statements.</source>
          <target state="translated">&lt;a href=&quot;test#illustrate&quot;&gt;ILLUSTRATE&lt;/a&gt; 연산자를 사용하여 일련의 명령문의 단계별 실행을보십시오.</target>
        </trans-unit>
        <trans-unit id="2a89eeacf194450ef5031d0bb4f654b947a7ab3d" translate="yes" xml:space="preserve">
          <source>Use the ABS function to return the absolute value of an expression. If the result is not negative (x &amp;ge; 0), the result is returned. If the result is negative (x &amp;lt; 0), the negation of the result is returned.</source>
          <target state="translated">ABS 함수를 사용하여 표현식의 절대 값을 리턴하십시오. 결과가 음수가 아닌 경우 (x &amp;ge; 0) 결과가 반환됩니다. 결과가 음수이면 (x &amp;lt;0) 결과의 부정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa46d1d7b46094cdad4bcf2af225b26622e379b" translate="yes" xml:space="preserve">
          <source>Use the ACOS function to return the arc cosine of an expression.</source>
          <target state="translated">ACOS 함수를 사용하여 식의 아크 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="802da801d45039a5e4f36bf324d03dac4ec393ce" translate="yes" xml:space="preserve">
          <source>Use the ASIN function to return the arc sine of an expression.</source>
          <target state="translated">식의 아크 사인을 반환하려면 ASIN 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0057601cc8a42573bdee322fca678587d47d9068" translate="yes" xml:space="preserve">
          <source>Use the ATAN function to return the arc tangent of an expression.</source>
          <target state="translated">ATAN 함수를 사용하여 식의 아크 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dacab64d9056657a3e32ac19594f60b2c8f3975a" translate="yes" xml:space="preserve">
          <source>Use the AVG function to compute the average of the numeric values in a single-column bag. AVG requires a preceding GROUP ALL statement for global averages and a GROUP BY statement for group averages.</source>
          <target state="translated">단일 열 백에서 숫자 값의 평균을 계산하려면 AVG 함수를 사용하십시오. AVG에는 전역 평균에 대한 GROUP ALL 문과 그룹 평균에 대한 GROUP BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0124105a35341e5c7516fba4c3ba73b8b696ef54" translate="yes" xml:space="preserve">
          <source>Use the Accumulator Interface</source>
          <target state="translated">누산기 인터페이스 사용</target>
        </trans-unit>
        <trans-unit id="7bd9e1cbf411e515be0d9feb8c764cea7149d31a" translate="yes" xml:space="preserve">
          <source>Use the AddDuration function to created a new datetime object by add some duration to a given datetime object.</source>
          <target state="translated">AddDuration 함수를 사용하여 지정된 datetime 객체에 기간을 추가하여 새로운 datetime 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f68c3c5a579538a2ec1aeabf579c3fa0c1d156b4" translate="yes" xml:space="preserve">
          <source>Use the CBRT function to return the cube root of an expression.</source>
          <target state="translated">CBRT 함수를 사용하여 표현식의 큐브 루트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="debab9e2b2a3866571c4b014b09915324010801c" translate="yes" xml:space="preserve">
          <source>Use the CEIL function to return the value of an expression rounded up to the nearest integer. This function never decreases the result value.</source>
          <target state="translated">CEIL 함수를 사용하여 가장 가까운 정수로 반올림 된 표현식 값을 리턴하십시오. 이 기능은 결과 값을 절대로 낮추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d89e9ab188ffbd8a37c0981d55508e060d60e30" translate="yes" xml:space="preserve">
          <source>Use the CONCAT function to concatenate two or more expressions. The result values of the expressions must have identical types.</source>
          <target state="translated">CONCAT 함수를 사용하여 둘 이상의 표현식을 연결하십시오. 표현식의 결과 값은 동일한 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="f3f49c628a522b6fa820e1e5d841c7202e2b5702" translate="yes" xml:space="preserve">
          <source>Use the COS function to return the trigonometric cosine of an expression.</source>
          <target state="translated">COS 함수를 사용하여 표현식의 삼각 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="90a9c5d28a40e7c005a54b8dca492314ed075302" translate="yes" xml:space="preserve">
          <source>Use the COSH function to return the hyperbolic cosine of an expression.</source>
          <target state="translated">COSH 함수를 사용하여 표현식의 쌍곡 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20bda36834df86d70856d1d448afa25f23e2837f" translate="yes" xml:space="preserve">
          <source>Use the COUNT function to compute the number of elements in a bag. COUNT requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</source>
          <target state="translated">백에서 요소 수를 계산하려면 COUNT 함수를 사용하십시오. COUNT에는 전체 개수에 대한 GROUP ALL 문과 그룹 개수에 대한 GROUP BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ec576a08a88f0ef1fd6150eaf11dba7dbb562681" translate="yes" xml:space="preserve">
          <source>Use the COUNT function to get the count (occurrences) of each n-gram.</source>
          <target state="translated">COUNT 함수를 사용하여 각 n-gram의 개수 (발생)를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="759bd7ea29bd32eda9ea90b94b6fc43216a2526f" translate="yes" xml:space="preserve">
          <source>Use the COUNT_STAR function to compute the number of elements in a bag. COUNT_STAR requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</source>
          <target state="translated">백의 요소 수를 계산하려면 COUNT_STAR 함수를 사용하십시오. COUNT_STAR에는 전체 개수에 대한 선행 GROUP ALL 문과 그룹 개수에 대한 GROUP BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dfd0b822ac02da9d60c48afe5e3acc0fdeb84147" translate="yes" xml:space="preserve">
          <source>Use the CROSS operator to compute the cross product (Cartesian product) of two or more relations.</source>
          <target state="translated">CROSS 연산자를 사용하여 둘 이상의 관계에 대한 교차 곱 (카테 시안 곱)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="eb761d801b1b65f211d63bff779c2d1eea0e9301" translate="yes" xml:space="preserve">
          <source>Use the CurrentTime function to generate a datetime object of current timestamp with millisecond accuracy.</source>
          <target state="translated">CurrentTime 함수를 사용하여 밀리 초 정확도로 현재 시간 소인의 날짜 시간 오브젝트를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5c10f5643f850923852542c9aa4f05e87337669d" translate="yes" xml:space="preserve">
          <source>Use the DEFINE statement to assign a name (alias) to a UDF function or to a streaming command.</source>
          <target state="translated">DEFINE 문을 사용하여 이름 (별칭)을 UDF 함수 또는 스트리밍 명령에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c2ab4626b646615f22818ab2ccc4383f5e95ee62" translate="yes" xml:space="preserve">
          <source>Use the DESCRIBE operator to view the schema of a relation. You can view outer relations as well as relations defined in a nested FOREACH statement.</source>
          <target state="translated">DESCRIBE 연산자를 사용하여 관계의 스키마를보십시오. 중첩 된 FOREACH 문에 정의 된 관계뿐만 아니라 외부 관계도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a56313d3a01556381ffe66a66b6bd530dd1172e" translate="yes" xml:space="preserve">
          <source>Use the DISTINCT operator to get the unique n-grams for all records.</source>
          <target state="translated">DISTINCT 연산자를 사용하여 모든 레코드에 대해 고유 한 n- 그램을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1dbcbfe7f356316b06cd9f78a97c57956878ffe3" translate="yes" xml:space="preserve">
          <source>Use the DISTINCT operator to remove duplicate tuples in a relation. DISTINCT does not preserve the original order of the contents (to eliminate duplicates, Pig must first sort the data). You cannot use DISTINCT on a subset of fields; to do this, use FOREACH and a nested block to first select the fields and then apply DISTINCT (see &lt;a href=&quot;#nestedblock&quot;&gt;Example: Nested Block&lt;/a&gt;).</source>
          <target state="translated">DISTINCT 연산자를 사용하여 관계에서 중복 튜플을 제거하십시오. DISTINCT는 내용의 원래 순서를 유지하지 않습니다 (중복을 제거하려면 Pig가 먼저 데이터를 정렬해야 함). 필드 하위 집합에 DISTINCT를 사용할 수 없습니다. 이렇게하려면 FOREACH 및 중첩 블록을 사용하여 먼저 필드를 선택한 다음 DISTINCT를 적용하십시오 ( &lt;a href=&quot;#nestedblock&quot;&gt;예 : 중첩 블록&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f1f2467da0d046f581982a3fb8a8d0e7787622d" translate="yes" xml:space="preserve">
          <source>Use the DUMP operator to run (execute) Pig Latin statements and display the results to your screen. DUMP is meant for interactive mode; statements are executed immediately and the results are not saved (persisted). You can use DUMP as a debugging device to make sure that the results you are expecting are actually generated.</source>
          <target state="translated">DUMP 연산자를 사용하여 Pig Latin 문을 실행 (실행)하고 결과를 화면에 표시하십시오. DUMP는 대화식 모드를위한 것입니다. 명령문이 즉시 실행되고 결과가 저장되지 않습니다 (지속됨). DUMP를 디버깅 장치로 사용하여 예상 한 결과가 실제로 생성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de32b1559e72f8714cfed72c3af7fc850cec4f9c" translate="yes" xml:space="preserve">
          <source>Use the DaysBetween function to get the number of days between the two given datetime objects.</source>
          <target state="translated">DaysBetween 함수를 사용하여 주어진 두 datetime 객체 사이의 일 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="557c298cc2106bed92560a71cf2ab40b5e6e2777" translate="yes" xml:space="preserve">
          <source>Use the ENDSWITH function to determine if the first argument ends with the string in the second.</source>
          <target state="translated">ENDSWITH 함수를 사용하여 첫 번째 인수가 두 번째의 문자열로 끝나는 지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="19bc09747735b5c98ae62245f644a4c23028933c" translate="yes" xml:space="preserve">
          <source>Use the EXP function to return the value of Euler's number e raised to the power of x (where x is the result value of the expression).</source>
          <target state="translated">EXP 함수를 사용하여 오일러 수 e의 값을 x의 거듭 제곱으로 반환합니다 (여기서 x는 표현식의 결과 값임).</target>
        </trans-unit>
        <trans-unit id="f23b63feb711ff444b3bfa757cd332d82b15b103" translate="yes" xml:space="preserve">
          <source>Use the EXPLAIN operator to review the logical, physical, and map reduce execution plans that are used to compute the specified relationship.</source>
          <target state="translated">EXPLAIN 연산자를 사용하여 지정된 관계를 계산하는 데 사용되는 논리적, 물리적 및 맵 감소 실행 계획을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="9443053b7239c6e7d99bcbfe6818ed994c79622a" translate="yes" xml:space="preserve">
          <source>Use the EqualsIgnoreCase function to determine if two string are equal ignoring case.</source>
          <target state="translated">EqualsIgnoreCase 함수를 사용하여 두 문자열이 대소 문자를 무시하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0c929b9d142b8682935b18070fa8f0610463afa6" translate="yes" xml:space="preserve">
          <source>Use the FILTER operator to remove all records with a score less than or equal to 2.0.</source>
          <target state="translated">FILTER 연산자를 사용하여 점수가 2.0 이하인 모든 레코드를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac2c9c00ee396d23e2853c086e1944a73db5129" translate="yes" xml:space="preserve">
          <source>Use the FILTER operator to work with tuples or rows of data (if you want to work with columns of data, use the FOREACH...GENERATE operation).</source>
          <target state="translated">FILTER 연산자를 사용하여 튜플 또는 데이터 행에 대해 작업하십시오 (데이터 열에 대해 작업하려면 FOREACH ... GENERATE 조작을 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="54ede846f82c9d209140093db98b437e37abb7b1" translate="yes" xml:space="preserve">
          <source>Use the FILTERoperator to get the n-grams for hour &amp;lsquo;00&amp;rsquo;</source>
          <target state="translated">FILTERoperator를 사용하여 시간 '00'에 대한 n- 그램을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="65306ed843eea3ccfb595b26897f9964e32e0156" translate="yes" xml:space="preserve">
          <source>Use the FLOOR function to return the value of an expression rounded down to the nearest integer. This function never increases the result value.</source>
          <target state="translated">FLOOR 함수를 사용하여 가장 가까운 정수로 내림 된 표현식의 값을 리턴하십시오. 이 기능은 결과 값을 증가시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faab68cdbc4f9887b00acd3224c7c76b772d60c4" translate="yes" xml:space="preserve">
          <source>Use the FOREACH&amp;hellip;GENERATE operation to work with columns of data (if you want to work with tuples or rows of data, use the FILTER operation).</source>
          <target state="translated">FOREACH&amp;hellip; GENERATE 연산을 사용하여 데이터 열에 대해 작업하십시오 (튜플 또는 데이터 행에 대해 작업하려면 FILTER 연산을 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="46cb2c9ea3dd4a6c8ec20a55fe6d64a9c5035898" translate="yes" xml:space="preserve">
          <source>Use the FOREACH-GENERATE operator to assign names to the fields.</source>
          <target state="translated">FOREACH-GENERATE 연산자를 사용하여 필드에 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="184ae53a65d5eb6c8ad9aac3fecc78f6579afd68" translate="yes" xml:space="preserve">
          <source>Use the FOREACH-GENERATE operator to record their frequency.</source>
          <target state="translated">FOREACH-GENERATE 연산자를 사용하여 빈도를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="8a42bab2fcd499a8f7b0166e063347cc97284f36" translate="yes" xml:space="preserve">
          <source>Use the GROUP operator to group records by n-gram and hour.</source>
          <target state="translated">GROUP 연산자를 사용하여 n-gram 및 hour로 레코드를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed260dfef88fdb59b2c5b3e560487169a8189ed" translate="yes" xml:space="preserve">
          <source>Use the GROUP operator to group records by n-gram only. Each group now corresponds to a distinct n-gram and has the count for each hour.</source>
          <target state="translated">GROUP 연산자를 사용하여 n-gram만으로 레코드를 그룹화하십시오. 각 그룹은 이제 별개의 n- 그램에 해당하며 각 시간의 수를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="92e0669e5304945b47fe98b3f0538f9d7862719b" translate="yes" xml:space="preserve">
          <source>Use the GROUP operator to group the records by n-gram and hour.</source>
          <target state="translated">GROUP 연산자를 사용하여 n-gram 및 시간별로 레코드를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="0de136f1fbe2c4545a5f3bb36098a021ecd2473a" translate="yes" xml:space="preserve">
          <source>Use the GetDay function to extract the day of a month from the given datetime object.</source>
          <target state="translated">GetDay 함수를 사용하여 주어진 datetime 객체에서 한 달의 날짜를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="83926f4085f034596e1c24147ddf195ef03749db" translate="yes" xml:space="preserve">
          <source>Use the GetHour function to extract the hour of a day from the given datetime object.</source>
          <target state="translated">GetHour 함수를 사용하여 주어진 datetime 객체에서 하루 중 시간을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="35d18a4755f8f53d3011f380a2798f6765dc5ba2" translate="yes" xml:space="preserve">
          <source>Use the GetMilliSecond function to extract the millsecond of a second from the given datetime object.</source>
          <target state="translated">GetMilliSecond 함수를 사용하여 지정된 datetime 객체에서 밀리 초를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="6bac2eaa33e2781cd1742154bfa99b7348a119f2" translate="yes" xml:space="preserve">
          <source>Use the GetMinute function to extract the minute of a hour from the given datetime object.</source>
          <target state="translated">GetMinute 함수를 사용하여 주어진 날짜 / 시간 객체에서 시간을 분 단위로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9318d217cfdbd263e674c43069f1a63dc5e976e2" translate="yes" xml:space="preserve">
          <source>Use the GetMonth function to extract the month of a year from the given datetime object.</source>
          <target state="translated">GetMonth 함수를 사용하여 주어진 datetime 객체에서 한 달의 월을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b0a51ead63f3c7c34970253fa3e06e9464c92fdc" translate="yes" xml:space="preserve">
          <source>Use the GetSecond function to extract the second of a minute from the given datetime object.</source>
          <target state="translated">GetSecond 함수를 사용하여 주어진 날짜 / 시간 객체에서 분을 초 단위로 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="bf7d9a7b1bd9bb0119d92ed1e43e2990b1d174a6" translate="yes" xml:space="preserve">
          <source>Use the GetWeek function to extract the week of a week year from the given datetime object. Note that week year may be different from year.</source>
          <target state="translated">GetWeek 함수를 사용하여 주어진 datetime 객체에서 요일을 추출합니다. 주년은 연도와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1e995b49ee66c8467216af9151e10ddaf8a7af" translate="yes" xml:space="preserve">
          <source>Use the GetWeekYear function to extract the week year from the given datetime object. Note that week year may be different from year.</source>
          <target state="translated">GetWeekYear 함수를 사용하여 주어진 날짜 / 시간 객체에서 주 연도를 추출합니다. 주년은 연도와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f950e4dce9d35c8cc58cfc5adf69b2bfb044b36" translate="yes" xml:space="preserve">
          <source>Use the GetYear function to extract the year from the given datetime object.</source>
          <target state="translated">GetYear 함수를 사용하여 주어진 datetime 객체에서 연도를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c97ebd4690e8d5480cb91511e05d3804b673ff17" translate="yes" xml:space="preserve">
          <source>Use the HoursBetween function to get the number of hours between the two given datetime objects.</source>
          <target state="translated">주어진 두 datetime 객체 사이의 시간 수를 얻으려면 HoursBetween 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4f561e1892da617f8069dcd745b6291b616eb829" translate="yes" xml:space="preserve">
          <source>Use the ILLUSTRATE operator to review how data is transformed through a sequence of Pig Latin statements. ILLUSTRATE allows you to test your programs on small datasets and get faster turnaround times.</source>
          <target state="translated">ILLUSTRATE 연산자를 사용하여 일련의 Pig Latin 문을 통해 데이터가 변환되는 방식을 검토하십시오. ILLUSTRATE를 사용하면 작은 데이터 세트에서 프로그램을 테스트하고 처리 시간을 단축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1459941dd5f8b06aaef5841bb17da989a4c4f4c5" translate="yes" xml:space="preserve">
          <source>Use the IMPORT command to import a macro defined in a separate file into your Pig script.</source>
          <target state="translated">IMPORT 명령을 사용하여 별도의 파일에 정의 된 매크로를 Pig 스크립트로 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="d206bd4f838941c8782a371299d2150aee2a2d05" translate="yes" xml:space="preserve">
          <source>Use the INDEXOF function to determine the index of the first occurrence of a character in a string. The forward search for the character begins at the designated start index.</source>
          <target state="translated">INDEXOF 함수를 사용하여 문자열에서 문자가 처음 나타나는 색인을 판별하십시오. 문자에 대한 정방향 검색은 지정된 시작 색인에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1797afc2770711e49b2a2b964fa9c366fe96f0f7" translate="yes" xml:space="preserve">
          <source>Use the JOIN operator to get the n-grams that appear in both hours.</source>
          <target state="translated">JOIN 연산자를 사용하여 두 시간에 모두 나타나는 n- 그램을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="302b859692ad189460e99ba74fecf7d6ab97bc66" translate="yes" xml:space="preserve">
          <source>Use the JOIN operator to perform an inner, equijoin join of two or more relations based on common field values. Inner joins ignore null keys, so it makes sense to filter them out before the join.</source>
          <target state="translated">JOIN 연산자를 사용하여 공통 필드 값을 기반으로 둘 이상의 관계를 내부적으로 결합합니다. 내부 조인은 null 키를 무시하므로 조인 전에 필터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb49a17adf66b2d1c47c3d183760de4aea2bf215" translate="yes" xml:space="preserve">
          <source>Use the JOIN operator with the corresponding keywords to perform left, right, or full outer joins. The keyword OUTER is optional for outer joins; the keywords LEFT, RIGHT and FULL will imply left outer, right outer and full outer joins respectively when OUTER is omitted. The Pig Latin syntax closely adheres to the SQL standard.</source>
          <target state="translated">왼쪽, 오른쪽 또는 전체 외부 조인을 수행하려면 JOIN 연산자를 해당 키워드와 함께 사용하십시오. OUTER 키워드는 외부 조인의 경우 선택 사항입니다. LEFT, RIGHT 및 FULL 키워드는 OUTER을 생략 할 때 각각 왼쪽 외부, 오른쪽 외부 및 전체 외부 조인을 의미합니다. Pig Latin 구문은 SQL 표준을 엄격하게 준수합니다.</target>
        </trans-unit>
        <trans-unit id="83d260b0da624d6a7fe93451c288da6aef6ee8a1" translate="yes" xml:space="preserve">
          <source>Use the Java &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html&quot;&gt;format&lt;/a&gt; for regular expressions.</source>
          <target state="translated">정규식에 Java &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html&quot;&gt;형식&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="80352c5726cb2b3f645603077d2f38d848e5937f" translate="yes" xml:space="preserve">
          <source>Use the LAST_INDEX_OF function to determine the index of the last occurrence of a character in a string. The backward search for the character begins at the end of the string.</source>
          <target state="translated">LAST_INDEX_OF 함수를 사용하여 문자열에서 문자의 마지막 항목 색인을 판별하십시오. 문자의 역방향 검색은 문자열의 끝에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c8e0db585ff200dde0edc7992c89a35c4419527c" translate="yes" xml:space="preserve">
          <source>Use the LCFIRST function to convert only the first character in a string to lower case.</source>
          <target state="translated">LCFIRST 함수를 사용하여 문자열의 첫 번째 문자 만 소문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="4ecdfd959de3b3322dcd4f72557e4c30196274f1" translate="yes" xml:space="preserve">
          <source>Use the LIMIT Operator</source>
          <target state="translated">LIMIT 연산자 사용</target>
        </trans-unit>
        <trans-unit id="3bd8537eee059ee1eabdd42324d98d1e117f8f9b" translate="yes" xml:space="preserve">
          <source>Use the LIMIT operator to limit the number of output tuples.</source>
          <target state="translated">출력 튜플의 수를 제한하려면 LIMIT 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f501ad951b935c2cafdb719a5eb074f42a36c1e5" translate="yes" xml:space="preserve">
          <source>Use the LOAD operator to load data from the file system.</source>
          <target state="translated">LOAD 연산자를 사용하여 파일 시스템에서 데이터를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="ac61c06d4afc73a3ce4c7c0571eeb65eb2caa1d8" translate="yes" xml:space="preserve">
          <source>Use the LOG function to return the natural logarithm (base e) of an expression.</source>
          <target state="translated">LOG 함수를 사용하여 표현식의 자연 로그 (base e)를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="535081b54c39807aa4675597d64bba1972ce2448" translate="yes" xml:space="preserve">
          <source>Use the LOG10 function to return the base 10 logarithm of an expression.</source>
          <target state="translated">LOG10 함수를 사용하여 표현식의 밑이 10 인 로그를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="66c560b4e79db4f39723be0812d9edfbfe43dabe" translate="yes" xml:space="preserve">
          <source>Use the LOWER function to convert all characters in a string to lower case.</source>
          <target state="translated">문자열의 모든 문자를 소문자로 변환하려면 LOWER 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b3ed72493ec88acbd5062677c294933f9ddd46e" translate="yes" xml:space="preserve">
          <source>Use the LTRIM function to remove leading white space from a string.</source>
          <target state="translated">문자열에서 선행 공백을 제거하려면 LTRIM 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f0f02557b7fc60dd667837a76860e45f693d297" translate="yes" xml:space="preserve">
          <source>Use the MAX function to compute the maximum of the numeric values or chararrays in a single-column bag.</source>
          <target state="translated">MAX 함수를 사용하여 단일 열 백에서 숫자 값 또는 chararray의 최대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="a5d5917dbc877c3bbee9517f72bea06be5ce345e" translate="yes" xml:space="preserve">
          <source>Use the MIN function to compute the minimum of a set of numeric values or chararrays in a single-column bag.</source>
          <target state="translated">MIN 함수를 사용하여 단일 열 백에서 숫자 값 또는 chararray의 최소값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="623335a6b1a7ffc0303255f2f970267b42d44d77" translate="yes" xml:space="preserve">
          <source>Use the MilliSecondsBetween function to get the number of millseconds between the two given datetime objects.</source>
          <target state="translated">MilliSecondsBetween 함수를 사용하여 지정된 두 datetime 객체 사이의 밀리 초 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5155523d54e0c419a535870dd49368e36805c23b" translate="yes" xml:space="preserve">
          <source>Use the MinutsBetween function to get the number of minutes between the two given datetime objects.</source>
          <target state="translated">주어진 두 datetime 객체 사이의 시간 (분)을 얻으려면 MinutsBetween 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="830c6a39acef6e31b0e07116311b8bfabcd03b24" translate="yes" xml:space="preserve">
          <source>Use the MonthsBetween function to get the number of months between the two given datetime objects.</source>
          <target state="translated">MonthsBetween 함수를 사용하여 주어진 두 datetime 객체 사이의 월 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5f32491c0d73a544f809fac7457c1aabf1c40254" translate="yes" xml:space="preserve">
          <source>Use the NATIVE operator to run native MapReduce/Tez jobs from inside a Pig script.</source>
          <target state="translated">NATIVE 연산자를 사용하여 Pig 스크립트 내부에서 기본 MapReduce / Tez 작업을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3c034465bee6f4f64ace81a965821e383e718672" translate="yes" xml:space="preserve">
          <source>Use the ONSCHEMA clause to base the union on named fields (rather than positional notation). All inputs to the union must have a non-unknown (non-null) &lt;a href=&quot;#schemas&quot;&gt;schema&lt;/a&gt;.</source>
          <target state="translated">ONSCHEMA 절을 사용하여 위치 표기법이 아닌 명명 된 필드를 통합하십시오. 공용체에 대한 모든 입력에는 알 수없는 (널이 아닌) &lt;a href=&quot;#schemas&quot;&gt;스키마가 있어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7393eb31bd773f6c7add0cf2ab085f79ef585775" translate="yes" xml:space="preserve">
          <source>Use the ORDER operator to sort the remaining records by hour and score.</source>
          <target state="translated">ORDER 연산자를 사용하여 시간 및 점수별로 나머지 레코드를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="0d88d8da46059eb91f0029355abbb59930384b30" translate="yes" xml:space="preserve">
          <source>Use the Parallel Features</source>
          <target state="translated">병렬 기능 사용</target>
        </trans-unit>
        <trans-unit id="3ddee517942e6dec64afe646b3081400943b18a0" translate="yes" xml:space="preserve">
          <source>Use the PigStorage function to load the excite log file (excite.log or excite-small.log) into the &amp;ldquo;raw&amp;rdquo; bag as an array of records with the fields &lt;strong&gt;user&lt;/strong&gt;, &lt;strong&gt;time&lt;/strong&gt;, and &lt;strong&gt;query&lt;/strong&gt;.</source>
          <target state="translated">PigStorage 함수를 사용하여 excite 로그 파일 (excite.log 또는 excite-small.log)을 &lt;strong&gt;user&lt;/strong&gt; , &lt;strong&gt;time&lt;/strong&gt; 및 &lt;strong&gt;query&lt;/strong&gt; 필드가있는 레코드 배열로&amp;ldquo;raw&amp;rdquo;백에로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af20307c98d0568b40b04b0550a63747a36b3bf" translate="yes" xml:space="preserve">
          <source>Use the PigStorage function to store the results. The output file contains a list of n-grams with the following fields: &lt;strong&gt;hour&lt;/strong&gt;, &lt;strong&gt;ngram&lt;/strong&gt;, &lt;strong&gt;score&lt;/strong&gt;, &lt;strong&gt;count&lt;/strong&gt;, &lt;strong&gt;mean&lt;/strong&gt;.</source>
          <target state="translated">PigStorage 기능을 사용하여 결과를 저장하십시오. 출력 파일에는 &lt;strong&gt;hour&lt;/strong&gt; , &lt;strong&gt;ngram&lt;/strong&gt; , &lt;strong&gt;score&lt;/strong&gt; , &lt;strong&gt;count&lt;/strong&gt; , &lt;strong&gt;mean&lt;/strong&gt; 필드가있는 n-gram 목록이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="82be6a56df6c26632254966ee15ed09ea66c4ae2" translate="yes" xml:space="preserve">
          <source>Use the PigStorage function to store the results. The output file contains a list of n-grams with the following fields: &lt;strong&gt;ngram&lt;/strong&gt;, &lt;strong&gt;count00&lt;/strong&gt;, &lt;strong&gt;count12&lt;/strong&gt;.</source>
          <target state="translated">PigStorage 기능을 사용하여 결과를 저장하십시오. 출력 파일에는 &lt;strong&gt;ngram&lt;/strong&gt; , &lt;strong&gt;count00&lt;/strong&gt; , &lt;strong&gt;count12&lt;/strong&gt; 필드가있는 n-gram 목록이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d25e481adff9500c1275465097b2e69ab7c6fa03" translate="yes" xml:space="preserve">
          <source>Use the RANDOM function to return a pseudo random number (type double) greater than or equal to 0.0 and less than 1.0.</source>
          <target state="translated">RANDOM 함수를 사용하여 0.0 이상 1.0 미만의 의사 난수 (유형 double)를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a5408e665d53c9316cb9c44dd72bb697b04a56cb" translate="yes" xml:space="preserve">
          <source>Use the REGEX_EXTRACT function to perform regular expression matching and to extract the matched group defined by the index parameter (where the index is a 1-based parameter.) The function uses Java regular expression form.</source>
          <target state="translated">REGEX_EXTRACT 함수를 사용하여 정규식 일치를 수행하고 색인 매개 변수로 정의 된 일치 그룹을 추출하십시오 (여기서 색인은 1 기반 매개 변수입니다).이 함수는 Java 정규식 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b3b278f12059c0d3fa81592b7a2fde9f00e5987d" translate="yes" xml:space="preserve">
          <source>Use the REGEX_EXTRACT_ALL function to perform regular expression matching and to extract all matched groups. The function uses Java regular expression form.</source>
          <target state="translated">정규식 일치를 수행하고 일치하는 모든 그룹을 추출하려면 REGEX_EXTRACT_ALL 함수를 사용하십시오. 이 함수는 Java 정규식 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d57358927dbbda13d8508e70fe72a0e68ce05cf3" translate="yes" xml:space="preserve">
          <source>Use the REGEX_SEARCH function to perform regular expression matching and to find all matched characters in a string.</source>
          <target state="translated">REGEX_SEARCH 함수를 사용하여 정규식 일치를 수행하고 문자열에서 일치하는 모든 문자를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a658c93bcf452bc0e4feb82bdfba60621ef07f46" translate="yes" xml:space="preserve">
          <source>Use the REGISTER statement inside a Pig script to specify a JAR file or a Python/JavaScript module. Pig supports JAR files and modules stored in local file systems as well as remote, distributed file systems such as HDFS and Amazon S3 (see &lt;a href=&quot;start#pig-scripts&quot;&gt;Pig Scripts&lt;/a&gt;).</source>
          <target state="translated">Pig 스크립트 내에서 REGISTER 문을 사용하여 JAR 파일 또는 Python / JavaScript 모듈을 지정하십시오. Pig는 HDFS 및 Amazon S3와 같은 원격 분산 파일 시스템뿐만 아니라 로컬 파일 시스템에 저장된 JAR 파일 및 모듈을 지원합니다 ( &lt;a href=&quot;start#pig-scripts&quot;&gt;Pig Scripts&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c4a51be200f5fd482269515aa2e29a5b0f6f1510" translate="yes" xml:space="preserve">
          <source>Use the REPLACE function to replace existing characters in a string with new characters.</source>
          <target state="translated">문자열의 기존 문자를 새 문자로 바꾸려면 REPLACE 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc48ffc14d62ec16e495843ee5989dd30282d71a" translate="yes" xml:space="preserve">
          <source>Use the ROUND function to return the value of an expression rounded to a fixed number of digits. Given a float, its result is a float; given a double its result is a double.</source>
          <target state="translated">ROUND 함수를 사용하여 고정 자릿수로 반올림 된 표현식 값을 리턴하십시오. float가 주어지면 결과는 float입니다. 배가 주어지면 결과는 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="0236e546070748ffd8749a6ac081ec305a70b081" translate="yes" xml:space="preserve">
          <source>Use the ROUND function to return the value of an expression rounded to an integer (if the result type is float) or rounded to a long (if the result type is double).</source>
          <target state="translated">ROUND 함수를 사용하여 정수로 반올림 된 (결과 유형이 float 인 경우) 표현식을 리턴하거나 long으로 반올림 한 (결과 유형이 double 인 경우) 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="41f43774c41a79c3ae3a810502dfbedb1d36b0c5" translate="yes" xml:space="preserve">
          <source>Use the RTRIM function to remove trailing white space from a string.</source>
          <target state="translated">문자열에서 후행 공백을 제거하려면 RTRIM 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9739479f66bcc0c917b3a826a56a8f176b38347" translate="yes" xml:space="preserve">
          <source>Use the SAMPLE operator to select a random data sample with the stated sample size. SAMPLE is a probabalistic operator; there is no guarantee that the exact same number of tuples will be returned for a particular sample size each time the operator is used.</source>
          <target state="translated">SAMPLE 연산자를 사용하여 명시된 샘플 크기의 랜덤 데이터 샘플을 선택하십시오. 샘플은 확률 론적 연산자입니다. 연산자를 사용할 때마다 특정 샘플 크기에 대해 정확히 동일한 수의 튜플이 반환된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="90fcb81084654270ce6e4f330c417f75c3844932" translate="yes" xml:space="preserve">
          <source>Use the SIN function to return the sine of an expession.</source>
          <target state="translated">SIN 함수를 사용하여 expinesion의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="708292a2a3db2bf8428c67cd61707a2a7d4f9ba7" translate="yes" xml:space="preserve">
          <source>Use the SINH function to return the hyperbolic sine of an expression.</source>
          <target state="translated">SINH 함수를 사용하여 표현식의 쌍곡 사인을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="65193d14f889d061c14a5ad69c44e7bcb8ee6f98" translate="yes" xml:space="preserve">
          <source>Use the SIZE function to compute the number of elements based on the data type (see the Types Tables below). SIZE includes NULL values in the size computation. SIZE is not algebraic.</source>
          <target state="translated">SIZE 함수를 사용하여 데이터 유형을 기준으로 요소 수를 계산하십시오 (아래 유형 테이블 참조). SIZE는 크기 계산에 NULL 값을 포함합니다. SIZE는 대수적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c29550cbd9f80e06474859c32a6d272ba9c7fadc" translate="yes" xml:space="preserve">
          <source>Use the SPLIT operator to partition the contents of a relation into two or more relations based on some expression. Depending on the conditions stated in the expression:</source>
          <target state="translated">SPLIT 연산자를 사용하여 일부 표현을 기반으로 관계의 컨텐츠를 둘 이상의 관계로 분할하십시오. 표현식에 명시된 조건에 따라 :</target>
        </trans-unit>
        <trans-unit id="0a9bf4a798312c0f33430951825cbae3e2e810fe" translate="yes" xml:space="preserve">
          <source>Use the SPRINTF function to format a string according to a template. For example, SPRINTF(&quot;part-%05d&quot;, 69) will return 'part-00069'.</source>
          <target state="translated">SPRINTF 함수를 사용하여 템플리트에 따라 문자열을 형식화하십시오. 예를 들어 SPRINTF ( &quot;part- % 05d&quot;, 69)는 'part-00069'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a201bdce8987f885b881fb65bae49e1a5533a1c2" translate="yes" xml:space="preserve">
          <source>Use the SQRT function to return the positive square root of an expression.</source>
          <target state="translated">SQRT 함수를 사용하여 표현식의 양의 제곱근을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="65911d1ba3cd89d69685a525152d6bf810acb7ef" translate="yes" xml:space="preserve">
          <source>Use the STARTSWITH function to determine if the first argument starts with the string in the second.</source>
          <target state="translated">첫 번째 인수가 두 번째의 문자열로 시작하는지 여부를 판별하려면 STARTSWITH 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c8eeaa73d0fa3a81579f8c676c353003475e944" translate="yes" xml:space="preserve">
          <source>Use the STORE operator to run (execute) Pig Latin statements and save (persist) results to the file system. Use STORE for production scripts and batch mode processing.</source>
          <target state="translated">STORE 연산자를 사용하여 Pig Latin 문을 실행 (실행)하고 결과를 파일 시스템에 저장 (지속)하십시오. 프로덕션 스크립트 및 배치 모드 처리에는 STORE를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a49ff7c80a5641b8ba4b415b3d0063c281bbdd9e" translate="yes" xml:space="preserve">
          <source>Use the STREAM operator to send data through an external script or program. Multiple stream operators can appear in the same Pig script. The stream operators can be adjacent to each other or have other operations in between.</source>
          <target state="translated">STREAM 연산자를 사용하여 외부 스크립트 또는 프로그램을 통해 데이터를 보냅니다. 여러 스트림 연산자가 동일한 Pig 스크립트에 나타날 수 있습니다. 스트림 오퍼레이터는 서로 인접 할 수 있거나 그 사이에 다른 오퍼레이션을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="9f0655fa3cbe21b79b49769d14135ae69cf70d78" translate="yes" xml:space="preserve">
          <source>Use the STRSPLIT function to split a string around matches of a given regular expression.</source>
          <target state="translated">STRSPLIT 함수를 사용하여 주어진 정규식과 일치하는 문자열을 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="63ab17a4fbde75b2d518f023f9fcd33c3bf0b1bf" translate="yes" xml:space="preserve">
          <source>Use the STRSPLITTOBAG function to split a string around matches of a given regular expression.</source>
          <target state="translated">STRSPLITTOBAG 함수를 사용하여 주어진 정규 표현식과 일치하는 문자열을 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="0d072ef4b2668c687c70b83cadafa8fd4ba19afb" translate="yes" xml:space="preserve">
          <source>Use the SUBSTRING function to return a substring from a given string.</source>
          <target state="translated">주어진 문자열에서 서브 스트링을 리턴하려면 SUBSTRING 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24776d02f93aba768f2f338688289ae810ca571e" translate="yes" xml:space="preserve">
          <source>Use the SUM function to compute the sum of a set of numeric values in a single-column bag.</source>
          <target state="translated">SUM 함수를 사용하여 단일 열 백에서 숫자 값 세트의 합계를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="e7206fffbe74dc458fe941ec01495481ea5b2da4" translate="yes" xml:space="preserve">
          <source>Use the SecondsBetween function to get the number of seconds between the two given datetime objects.</source>
          <target state="translated">SecondsBetween 함수를 사용하여 주어진 두 datetime 객체 사이의 시간 (초)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="80646d35773dbe009c16b73d1e6e52c739ca0408" translate="yes" xml:space="preserve">
          <source>Use the TAN function to return the trignometric tangent of an angle.</source>
          <target state="translated">TAN 함수를 사용하여 각도의 삼각 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c8d951ff2b8bd2acaa20f4e9c5b6122db0db46c" translate="yes" xml:space="preserve">
          <source>Use the TANH function to return the hyperbolic tangent of an expression.</source>
          <target state="translated">TANH 함수를 사용하여 표현식의 쌍곡 탄젠트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="304c0a00a74217a57d476a25fe3341e952b83332" translate="yes" xml:space="preserve">
          <source>Use the TOBAG function to convert one or more expressions to individual tuples which are then placed in a bag.</source>
          <target state="translated">TOBAG 함수를 사용하여 하나 이상의 표현식을 개별 튜플로 변환 한 다음 백에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="1da6cfc996c6bc5bef32988003de274875cc990e" translate="yes" xml:space="preserve">
          <source>Use the TOKENIZE function to split a string of words (all words in a single tuple) into a bag of words (each word in a single tuple).</source>
          <target state="translated">TOKENIZE 함수를 사용하여 단어 문자열 (단일 튜플의 모든 단어)을 단어 백 (단일 튜플의 각 단어)으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="3be37d992ac640da984d7ba498b6146629c7204c" translate="yes" xml:space="preserve">
          <source>Use the TOMAP function to convert pairs of expressions into a map. Note the following:</source>
          <target state="translated">TOMAP 함수를 사용하여 표현식 쌍을 맵으로 변환하십시오. 다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="6513b87b5ca2f56f0099d61fee166c0f4558f373" translate="yes" xml:space="preserve">
          <source>Use the TOTUPLE function to convert one or more expressions to a tuple.</source>
          <target state="translated">TOTUPLE 함수를 사용하여 하나 이상의 표현식을 튜플로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="e932be64c0e6f3d2ba1f7b6efad144b1634d9307" translate="yes" xml:space="preserve">
          <source>Use the TRIM function to remove leading and trailing white space from a string.</source>
          <target state="translated">문자열에서 선행 및 후행 공백을 제거하려면 TRIM 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfd672f78eec70de668c30e0c34ff54cc690bf83" translate="yes" xml:space="preserve">
          <source>Use the ToDate function to generate a DateTime object. Note that if the timezone is not specified with the ISO datetime string or by the timezone parameter, the default timezone will be used.</source>
          <target state="translated">ToDate 함수를 사용하여 DateTime 개체를 생성하십시오. 시간대를 ISO 날짜 / 시간 문자열 또는 시간대 매개 변수로 지정하지 않으면 기본 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb10cb4b7d7bed0e81b8795512fbe54433dae6fe" translate="yes" xml:space="preserve">
          <source>Use the ToMilliSeconds function to convert the DateTime to the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT.</source>
          <target state="translated">ToMilliSeconds 함수를 사용하여 DateTime을 1970 년 1 월 1 일 00 : 00 : 00.000 GMT 이후에 경과 한 밀리 초 수로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="071df6aeb965329c23ec7dabe2a9046f5938c017" translate="yes" xml:space="preserve">
          <source>Use the ToString function to convert the DateTime to the customized string.</source>
          <target state="translated">ToString 함수를 사용하여 DateTime을 사용자 정의 된 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="f955adceae61726b0d3e2dd5c05265472e91afb0" translate="yes" xml:space="preserve">
          <source>Use the ToUnixTime function to convert the DateTime to Unix Time.</source>
          <target state="translated">ToUnixTime 함수를 사용하여 DateTime을 Unix Time으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="d8f5de5308fd689b97bf6840e7e111c9fdbf60d6" translate="yes" xml:space="preserve">
          <source>Use the UCFIRST function to convert only the first character in a string to upper case.</source>
          <target state="translated">UCFIRST 함수를 사용하여 문자열의 첫 번째 문자 만 대문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="11cea17ef9143e712b0b04b012284faad34bcb2d" translate="yes" xml:space="preserve">
          <source>Use the UNION operator to merge the contents of two or more relations. The UNION operator:</source>
          <target state="translated">UNION 연산자를 사용하여 둘 이상의 관계 내용을 병합하십시오. UNION 연산자 :</target>
        </trans-unit>
        <trans-unit id="ab8011b832b949a6583a25ef28940f0c6ef7de1a" translate="yes" xml:space="preserve">
          <source>Use the UPPER function to convert all characters in a string to upper case.</source>
          <target state="translated">문자열의 모든 문자를 대문자로 변환하려면 UPPER 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7846464e760287ba79e1e27f35345ba83ba91666" translate="yes" xml:space="preserve">
          <source>Use the WeeksBetween function to get the number of weeks between the two given datetime objects.</source>
          <target state="translated">WeeksBetween 함수를 사용하여 주어진 두 datetime 객체 사이의 주 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="097848582e845415ce6846bd059a6c1797ded859" translate="yes" xml:space="preserve">
          <source>Use the YearsBetween function to get the number of years between the two given datetime objects.</source>
          <target state="translated">YearsBetween 함수를 사용하여 주어진 두 datetime 객체 사이의 년 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f9475728f19d8cefef723aa11b42adab8bf648eb" translate="yes" xml:space="preserve">
          <source>Use the comparison operators with numeric and string data.</source>
          <target state="translated">숫자 및 문자열 데이터와 함께 비교 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e53acee31e7c222201bc3d64b5bee49232aba2b1" translate="yes" xml:space="preserve">
          <source>Use the dereference operators to reference and work with fields that are complex data types.</source>
          <target state="translated">역 참조 연산자를 사용하여 복잡한 데이터 유형 인 필드를 참조하고 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="266c9585fc32e9825a1a06df15d20cc2e1138a86" translate="yes" xml:space="preserve">
          <source>Use the exec command to run a Pig script with no interaction between the script and the Grunt shell (batch mode). Aliases defined in the script are not available to the shell; however, the files produced as the output of the script and stored on the system are visible after the script is run. Aliases defined via the shell are not available to the script.</source>
          <target state="translated">exec 명령을 사용하여 스크립트와 Grunt 쉘 (배치 모드)간에 상호 작용없이 Pig 스크립트를 실행하십시오. 스크립트에 정의 된 별명은 쉘에서 사용할 수 없습니다. 그러나 스크립트의 출력으로 생성되어 시스템에 저장된 파일은 스크립트가 실행 된 후에 볼 수 있습니다. 셸을 통해 정의 된 별칭은 스크립트에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17611d3cc0ac7df1fac0ab6ff0e609bb7751afb3" translate="yes" xml:space="preserve">
          <source>Use the fs command to invoke any FsShell command from within a Pig script or Grunt shell. The fs command greatly extends the set of supported file system commands and the capabilities supported for existing commands such as ls that will now support globing. For a complete list of FsShell commands, see &lt;a href=&quot;http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/FileSystemShell.html&quot;&gt;File System Shell Guide&lt;/a&gt;</source>
          <target state="translated">fs 명령을 사용하여 Pig 스크립트 또는 Grunt 쉘 내에서 FsShell 명령을 호출하십시오. fs 명령은 지원되는 파일 시스템 명령 세트와 현재 globing을 지원하는 ls와 같은 기존 명령에 지원되는 기능을 크게 확장합니다. FsShell 명령의 전체 목록은 &lt;a href=&quot;http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/FileSystemShell.html&quot;&gt;파일 시스템 셸 안내서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="883068650ea53383b6397bccd91e0ee06d67ccef" translate="yes" xml:space="preserve">
          <source>Use the kill command to kill a Pig job based on the job id.</source>
          <target state="translated">kill 명령을 사용하여 작업 ID를 기반으로 Pig 작업을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="89087664ab5268c74efacbb49fd681b30ae1b92c" translate="yes" xml:space="preserve">
          <source>Use the run command to run a Pig script that can interact with the Grunt shell (interactive mode). The script has access to aliases defined externally via the Grunt shell. The Grunt shell has access to aliases defined within the script. All commands from the script are visible in the command history.</source>
          <target state="translated">run 명령을 사용하여 Grunt 쉘과 상호 작용할 수있는 Pig 스크립트를 실행하십시오 (대화식 모드). 스크립트는 Grunt 쉘을 통해 외부 적으로 정의 된 별칭에 액세스 할 수 있습니다. Grunt 쉘은 스크립트 내에 정의 된 별명에 액세스 할 수 있습니다. 스크립트의 모든 명령은 명령 기록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57c70e890fa202d895c702c744805ac7e18a66ab" translate="yes" xml:space="preserve">
          <source>Use the schemas for complex data types to name fields that are complex data types.</source>
          <target state="translated">복합 데이터 유형에 대한 스키마를 사용하여 복합 데이터 유형 인 필드의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3596ab849649c75e0db536e4f5dbd1df100033ea" translate="yes" xml:space="preserve">
          <source>Use the set command to assign values to keys, as shown in the table. All keys and their corresponding values (for Pig and Hadoop) are case sensitive. If set command is used without key/value pair argument, Pig prints all the configurations and system properties.</source>
          <target state="translated">표에 표시된대로 set 명령을 사용하여 키에 값을 지정하십시오. 모든 키와 해당 값 (Pig 및 Hadoop의 경우)은 대소 문자를 구분합니다. 키 / 값 쌍 인수없이 set 명령을 사용하면 Pig는 모든 구성 및 시스템 속성을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="51112be35e104dcdd59a837f1e84139ab997bf57" translate="yes" xml:space="preserve">
          <source>Use the sh command to invoke any sh shell command from within a Pig script or Grunt shell.</source>
          <target state="translated">sh 스크립트를 사용하여 Pig 스크립트 또는 Grunt 쉘에서 sh 쉘 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="14457c4c69aef46f39498d171bd46e8380864d21" translate="yes" xml:space="preserve">
          <source>Use the ship option to send streaming binary and supporting files, if any, from the client node to the compute nodes. Pig does not automatically ship dependencies; it is your responsibility to explicitly specify all the dependencies and to make sure that the software the processing relies on (for instance, perl or python) is installed on the cluster. Supporting files are shipped to the task's current working directory and only relative paths should be specified. Any pre-installed binaries should be specified in the PATH.</source>
          <target state="translated">ship 옵션을 사용하여 클라이언트 노드에서 계산 노드로 스트리밍 바이너리 및 지원 파일을 보냅니다 (있는 경우). Pig는 자동으로 의존성을 제공하지 않습니다. 모든 종속성을 명시 적으로 지정하고 처리에 의존하는 소프트웨어 (예 : perl 또는 python)가 클러스터에 설치되어 있는지 확인해야합니다. 지원 파일은 작업의 현재 작업 디렉토리로 배송되며 상대 경로 만 지정해야합니다. 사전 설치된 바이너리는 PATH에 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d169e37bd22471d157ca32819d53fce7d2262e2" translate="yes" xml:space="preserve">
          <source>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs.</source>
          <target state="translated">이 기능을 사용하여 Hadoop Partitioner를 지정하십시오. 파티 셔 너는 중간 맵 출력의 키 파티셔닝을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="50b82fa888fe15f9a575f926adb6e91b2cb96ed7" translate="yes" xml:space="preserve">
          <source>Use to construct a bag from the specified elements. Equivalent to &lt;a href=&quot;func#tobag&quot;&gt;TOBAG&lt;/a&gt;.</source>
          <target state="translated">지정된 요소로 백을 구성하는 데 사용합니다. &lt;a href=&quot;func#tobag&quot;&gt;TOBAG&lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e6776a7cddf3c6c8ce81c948e4ed472a8ea5c910" translate="yes" xml:space="preserve">
          <source>Use to construct a map from the specified elements. Equivalent to &lt;a href=&quot;func#tomap&quot;&gt;TOMAP&lt;/a&gt;.</source>
          <target state="translated">지정된 요소에서 맵을 구성하는 데 사용합니다. &lt;a href=&quot;func#tomap&quot;&gt;TOMAP과&lt;/a&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1c9a68ef0db145ee99b4f1f93d4d821807917fa1" translate="yes" xml:space="preserve">
          <source>Use to construct a tuple from the specified elements. Equivalent to &lt;a href=&quot;func#totuple&quot;&gt;TOTUPLE&lt;/a&gt;.</source>
          <target state="translated">지정된 요소에서 튜플을 구성하는 데 사용합니다. &lt;a href=&quot;func#totuple&quot;&gt;TOTUPLE과&lt;/a&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c4a7b08eca343792bafd62d175553b1acb74108d" translate="yes" xml:space="preserve">
          <source>Use to describe one parameter in terms of other parameters.</source>
          <target state="translated">하나의 매개 변수를 다른 매개 변수와 관련하여 설명하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="054700577b1adde15ae6af6c183daa418fa5d2fc" translate="yes" xml:space="preserve">
          <source>Use to perform bloom joins (see &lt;a href=&quot;perf#bloom-joins&quot;&gt;Bloom Joins&lt;/a&gt;).</source>
          <target state="translated">블룸 조인을 수행하는 데 사용합니다 ( &lt;a href=&quot;perf#bloom-joins&quot;&gt;Bloo Joins&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ec73dc5b185f02e859dcb300ac65e920f164bc26" translate="yes" xml:space="preserve">
          <source>Use to perform merge joins (see &lt;a href=&quot;perf#merge-joins&quot;&gt;Merge Joins&lt;/a&gt;).</source>
          <target state="translated">병합 조인을 수행하는 데 사용합니다 ( &lt;a href=&quot;perf#merge-joins&quot;&gt;병합 조인&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="aca60fd29b72d85fecd4997e65372680f9c29708" translate="yes" xml:space="preserve">
          <source>Use to perform merge-sparse joins (see &lt;a href=&quot;perf#merge-sparse-joins&quot;&gt;Merge-Sparse Joins&lt;/a&gt;).</source>
          <target state="translated">병합 스파 스 조인을 수행하는 데 사용합니다 ( &lt;a href=&quot;perf#merge-sparse-joins&quot;&gt;병합 스파 스 조인&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24a65fde3d2dc10e2da00a40168270895e9e19fb" translate="yes" xml:space="preserve">
          <source>Use to perform replicated joins (see &lt;a href=&quot;perf#replicated-joins&quot;&gt;Replicated Joins&lt;/a&gt;).</source>
          <target state="translated">조인 복제 수행 할 때 사용합니다 ( &lt;a href=&quot;perf#replicated-joins&quot;&gt;복제 조인&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8080a68fbb5ebc1dd0f49b70336e8717443f8a65" translate="yes" xml:space="preserve">
          <source>Use to perform skewed joins (see &lt;a href=&quot;perf#skewed-joins&quot;&gt;Skewed Joins&lt;/a&gt;).</source>
          <target state="translated">비뚤어진 조인을 수행하는 데 사용합니다 ( &lt;a href=&quot;perf#skewed-joins&quot;&gt;비뚤어진 조인&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f35ec6115649d74b7077624aad25e84bac12a831" translate="yes" xml:space="preserve">
          <source>Use to provide a default value for a parameter. The default value has the lowest priority and is used if a parameter value has not been defined by other means.</source>
          <target state="translated">매개 변수의 기본값을 제공하는 데 사용하십시오. 기본값은 우선 순위가 가장 낮으며 다른 방법으로 매개 변수 값을 정의하지 않은 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1790de2b41a458532a3bfc51bb2577c511dc49d7" translate="yes" xml:space="preserve">
          <source>Use to specify a Pig script.</source>
          <target state="translated">Pig 스크립트를 지정하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0bd9c275babcafde13aa4d41504fb57db3acdad" translate="yes" xml:space="preserve">
          <source>Use to specify the output path (directory).</source>
          <target state="translated">출력 경로 (디렉토리)를 지정하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01dcddcaaf8fcd20531c1d549573527b2b24cf35" translate="yes" xml:space="preserve">
          <source>User Defined Functions</source>
          <target state="translated">사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="4a09c226980077cfbba09a0bda433b983a4354d6" translate="yes" xml:space="preserve">
          <source>User Jar Cache</source>
          <target state="translated">사용자 Jar 캐시</target>
        </trans-unit>
        <trans-unit id="b9200c88a8c20e226619e712cebbbbeba74a1f51" translate="yes" xml:space="preserve">
          <source>User defined functions (UDFs) and Java classes</source>
          <target state="translated">사용자 정의 함수 (UDF) 및 Java 클래스</target>
        </trans-unit>
        <trans-unit id="7578b2baf1e4ea64626cb635936774382ac6f08e" translate="yes" xml:space="preserve">
          <source>User jar cache feature is fail safe. If jars cannot be copied to jar cache due to any permission/configuration problems, pig will default old behavior.</source>
          <target state="translated">사용자 jar 캐시 기능은 안전합니다. 권한 / 구성 문제로 인해 jar을 jar 캐시에 복사 할 수없는 경우 pig는 기본적으로 이전 동작을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b7afb11f30d73cb54b50e41ac31e0d584b853f60" translate="yes" xml:space="preserve">
          <source>Users should not make assumptions about how many times a function is instantiated; instead, they should make their code resilient to multiple instantiations. For instance, they could check if the files exist before creating them.</source>
          <target state="translated">사용자는 함수가 몇 번이나 인스턴스화되는지에 대해 가정해서는 안됩니다. 대신 코드를 여러 인스턴스화에 탄력적으로 만들어야합니다. 예를 들어, 파일을 작성하기 전에 파일이 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f3f86167af8db7ceff97a67e84fb2a00e4c2e2" translate="yes" xml:space="preserve">
          <source>Uses the FILTER operators to get the n-grams for hour &amp;lsquo;12&amp;rsquo;</source>
          <target state="translated">FILTER 연산자를 사용하여 시간 '12'에 대한 n- 그램을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d94acd482ed230b1a53c28d24a6d8dc7ebb577bc" translate="yes" xml:space="preserve">
          <source>Using Counters</source>
          <target state="translated">카운터 사용</target>
        </trans-unit>
        <trans-unit id="a20b74697154b21d3d87d2422451ab345dbbcae4" translate="yes" xml:space="preserve">
          <source>Using Distributed Cache</source>
          <target state="translated">분산 캐시 사용</target>
        </trans-unit>
        <trans-unit id="5741c47ff13bc47910e48beda1c4f33066ae4a1f" translate="yes" xml:space="preserve">
          <source>Using Short Names</source>
          <target state="translated">짧은 이름 사용</target>
        </trans-unit>
        <trans-unit id="cf5a203d6668baa769e4f6a7a704e701389228a0" translate="yes" xml:space="preserve">
          <source>Using the ktutil tool you can create a keytab using roughly these commands:</source>
          <target state="translated">ktutil 도구를 사용하면 대략 다음 명령을 사용하여 키탭을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d316dca6cf3592c6cbd20cbab4e4ce3ea72feb0" translate="yes" xml:space="preserve">
          <source>Usually this is &quot;/etc/krb5.conf&quot;</source>
          <target state="translated">일반적으로 이것은 &quot;/etc/krb5.conf&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="608848a46bf1f5285ddefa5c5b4724766b2bd95e" translate="yes" xml:space="preserve">
          <source>Usually this would look like this &quot;/home/niels/.krb/niels.keytab&quot;</source>
          <target state="translated">일반적으로 이것은 &quot;/home/niels/.krb/niels.keytab&quot;과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cbe6d00371735c3b1edaadf2c958f4f42d93de9" translate="yes" xml:space="preserve">
          <source>Usually this would look like this &quot;niels@EXAMPLE.NL&quot;</source>
          <target state="translated">일반적으로 이것은 &quot;niels@EXAMPLE.NL&quot;과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6fd03544a88b02dc6fe79195d933af3e6d2f746" translate="yes" xml:space="preserve">
          <source>Utility Commands</source>
          <target state="translated">유틸리티 명령</target>
        </trans-unit>
        <trans-unit id="cef4b01ce25c791a64fb96f6f87aeac13ce12c15" translate="yes" xml:space="preserve">
          <source>Valid identifiers:</source>
          <target state="translated">유효한 식별자 :</target>
        </trans-unit>
        <trans-unit id="4268234b5c0897c659be054bc2deea7c123c97a7" translate="yes" xml:space="preserve">
          <source>Valid values for avro.output.codec include deflate, snappy, and null.</source>
          <target state="translated">avro.output.codec에 유효한 값은 deflate, snappy 및 null입니다.</target>
        </trans-unit>
        <trans-unit id="070e4522d3f6f78a61dd2859752e94eda11dd394" translate="yes" xml:space="preserve">
          <source>Validate the pig.jar by running a unit test: ant test</source>
          <target state="translated">단위 테스트를 실행하여 pig.jar의 유효성을 검증하십시오. ant test</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="631941f9f4eddabf18f399cff245808f583a1b40" translate="yes" xml:space="preserve">
          <source>Value for key (see table). Case sensitive.</source>
          <target state="translated">키 값 (표 참조). 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="1f5d782847120d179d26f2729c1a2bd48adc215d" translate="yes" xml:space="preserve">
          <source>Values are rounded towards positive infinity: round(x) = floor(x + 0.5).</source>
          <target state="translated">값은 양의 무한대로 반올림됩니다 : round (x) = floor (x + 0.5).</target>
        </trans-unit>
        <trans-unit id="429604a563635aeffa7770e32919bb9df44db51b" translate="yes" xml:space="preserve">
          <source>Variable names inside a schema string are used for type conversion between Pig and JavaScript. Tuples are converted to Objects using the names and vice versa</source>
          <target state="translated">스키마 문자열 내부의 변수 이름은 Pig와 JavaScript 간의 유형 변환에 사용됩니다. 튜플은 이름을 사용하여 객체로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d89198e3d12d880e8748d35818cd2e61d68ee143" translate="yes" xml:space="preserve">
          <source>Variable-length arguments:</source>
          <target state="translated">가변 길이 인수 :</target>
        </trans-unit>
        <trans-unit id="6d135ef17bd7b1034a813d4712d4955387194440" translate="yes" xml:space="preserve">
          <source>We can only prune a2 from the loader. However, a0 is never used after &quot;ORDER BY&quot;. So we can drop a0 right after &quot;ORDER BY&quot; statement.</source>
          <target state="translated">로더에서 a2 만 제거 할 수 있습니다. 그러나 &quot;ORDER BY&quot;뒤에는 a0이 사용되지 않습니다. 따라서 &quot;ORDER BY&quot;문 바로 다음에 a0을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f42029fedad6c5c651c806be8c803096500d779a" translate="yes" xml:space="preserve">
          <source>We have already seen that the simplest way to run a script is to call runSingle without any parameters. Additionally, a Java Properties object or a file containing a list of properties can be passed to this call. The properties are passed to Pig and a treated as any other properties passed from command line.</source>
          <target state="translated">스크립트를 실행하는 가장 간단한 방법은 매개 변수없이 runSingle을 호출하는 것입니다. 또한 Java 등록 정보 객체 또는 등록 정보 목록이 포함 된 파일을이 호출로 전달할 수 있습니다. 특성은 Pig로 전달되고 명령 행에서 전달 된 다른 특성으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f1ca2bed7dff3d7360a2cadec34602d55f7d2c69" translate="yes" xml:space="preserve">
          <source>We have seen several examples of users doing something like this:</source>
          <target state="translated">다음과 같은 사용자의 몇 가지 예를 보았습니다.</target>
        </trans-unit>
        <trans-unit id="5ef13d7a1963b8a48755c5c581467f5953d70919" translate="yes" xml:space="preserve">
          <source>WeeksBetween</source>
          <target state="translated">WeeksBetween</target>
        </trans-unit>
        <trans-unit id="e28aa92210bc58f6a1eb15087ac7bd3cb5097f49" translate="yes" xml:space="preserve">
          <source>WeeksBetween(datetime1, datetime2)</source>
          <target state="translated">주간 (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="5477d3b7df1a27352529050e7df20fbe937d3fde" translate="yes" xml:space="preserve">
          <source>When &quot;columns&quot; is not provided or is a blank String, it is treated equivalently to &quot;*&quot;. This is to say that when a column specification string is not provided, for reads, all columns in the given Accumulo row will be placed into a single Map (with the Map keys being colon delimited to preserve the column family/qualifier from Accumulo). For writes, the Map keys will be placed into the column family and the column qualifier will be empty.</source>
          <target state="translated">&quot;열&quot;이 제공되지 않거나 공백 문자열 인 경우 &quot;*&quot;와 동일하게 처리됩니다. 즉, 열 지정 문자열이 제공되지 않으면 읽기에 대해 지정된 Accumulo 행의 모든 ​​열이 단일 맵에 배치됩니다 (맵 키가 콜론으로 구분되어 Accumulo의 열 계열 / 자격자를 유지함). 쓰기의 경우 맵 키가 열 패밀리에 배치되고 열 한정자가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d597d1e270fce83a697cdc533a9fcd73494cf434" translate="yes" xml:space="preserve">
          <source>When DAG progress, Pig adjust the parallelism of vertexes with the best knowledge available at that moment (Pig grace paralellism)</source>
          <target state="translated">DAG가 진행될 때 Pig는 해당 시점에 가능한 최고의 지식으로 정점의 평행도를 조정합니다 (Pig grace paralellism)</target>
        </trans-unit>
        <trans-unit id="5ac77ecf8dca12f201d6bf64fe8b3618dbb5fc0a" translate="yes" xml:space="preserve">
          <source>When implementing more advanced types of EvalFuncs, the simpler implementations can be automatically provided by Pig. Thus if your UDF implements &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic&lt;/a&gt; then you will get the Accumulator interface and basic the basic EvalFunc exec method for free. Similarly, if your UDF implements &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt; you will get the basic EvalFunc exec method for free. You will not get the Algebraic implemenation. Note that these free implementations are based on simulation, which might not be the most efficient. If you wish to ensure the efficiency of your Accumulator of EvalFunc exec method, you may still implement them yourself and your implementations will be used.</source>
          <target state="translated">고급 유형의 EvalFunc를 구현할 때 Pig에서 더 간단한 구현을 자동으로 제공 할 수 있습니다. 따라서 UDF가 &lt;a href=&quot;#algebraic-interface&quot;&gt;대수&lt;/a&gt; 를 구현 하면 Accumulator 인터페이스와 기본 EvalFunc exec 메소드가 무료로 제공됩니다. 마찬가지로 UDF가 &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt; 를 구현 하면 기본 EvalFunc exec 메소드를 무료로 얻을 수 있습니다. 대수 구현을 얻지 못할 것입니다. 이러한 무료 구현은 시뮬레이션을 기반으로하므로 가장 효율적이지 않을 수 있습니다. Accuulator of EvalFunc exec 메소드의 효율성을 보장하려면 여전히 직접 구현할 수 있으며 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56a72cf2e7877a912482bdd99a515ef260962151" translate="yes" xml:space="preserve">
          <source>When invoking Pig Scripts that use AccumuloStorage, it's important to ensure that Pig has the Accumulo jars on its classpath. This is easily achieved using the ACCUMULO_HOME environment variable.</source>
          <target state="translated">AccumuloStorage를 사용하는 Pig 스크립트를 호출 할 때 Pig가 클래스 경로에 Accumulo jar을 가지고 있는지 확인하는 것이 중요합니다. 이것은 ACCUMULO_HOME 환경 변수를 사용하여 쉽게 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3faeeed982526ba3388b8a4d6c576c060ce128" translate="yes" xml:space="preserve">
          <source>When mode has the value 4 (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_UP&quot;&gt;RoundingMode.HALF_UP&lt;/a&gt;), the result is rounded towards the nearest neighbor, and ties are &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero&quot;&gt;rounded away from zero&lt;/a&gt;. This mode matches the behavior of most SQL systems.</source>
          <target state="translated">mode의 값이 4 ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_UP&quot;&gt;RoundingMode.HALF_UP&lt;/a&gt; ) 인 경우 결과는 가장 가까운 이웃으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero&quot;&gt;반올림&lt;/a&gt; 되고 타이는 0에서 반올림됩니다 . 이 모드는 대부분의 SQL 시스템의 동작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5a50ddd96cd3117b3d5235af7be8a9d03a15b781" translate="yes" xml:space="preserve">
          <source>When mode is omitted or has the value 6 (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt;), the result is rounded towards the nearest neighbor, and ties are &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;rounded to the nearest even digit&lt;/a&gt;. This mode minimizes cumulative error and tends to preserve the average of a set of values.</source>
          <target state="translated">mode가 생략되거나 값이 6 ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; ) 인 경우 결과는 가장 가까운 이웃으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;반올림&lt;/a&gt; 되고 관계는 가장 가까운 짝수 로 반올림됩니다 . 이 모드는 누적 오류를 최소화하고 값 집합의 평균을 유지하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc8855d1a784843c2742d01b7e78f1898036e06f" translate="yes" xml:space="preserve">
          <source>When no decorator is specified, Pig assumes the output datatype as bytearray and converts the output generated by script function to bytearray. This is consistent with Pig's behavior in case of Java UDFs.</source>
          <target state="translated">데코레이터를 지정하지 않으면 Pig는 출력 데이터 유형을 바이트 배열로 가정하고 스크립트 함수에 의해 생성 된 출력을 바이트 배열로 변환합니다. 이것은 Java UDF의 경우 Pig의 동작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="67744018a95ce06f5e06c3d2e743c7029feb1d1b" translate="yes" xml:space="preserve">
          <source>When running short jobs all you need to do is ensure that the user has been logged in into Kerberos via the normal kinit method.</source>
          <target state="translated">짧은 작업을 실행할 때는 사용자가 일반적인 kinit 메소드를 통해 Kerberos에 로그인했는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="047ae105067bcb549c4d8a6d4189c038d3169f27" translate="yes" xml:space="preserve">
          <source>When specifying no field to sort on, the RANK operator simply prepends a sequential value to each tuple.</source>
          <target state="translated">정렬 할 필드를 지정하지 않으면 RANK 연산자는 각 튜플에 순차 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="db7c02cdeb5aa8e585312154c165562896641b73" translate="yes" xml:space="preserve">
          <source>When storing a bag of tuples with AvroStorage, if you do not want to specify the full schema, you may specify the avro record name instead. (AvroStorage will determine that the argument isn't a valid schema definition and use it as a variable name instead.)</source>
          <target state="translated">AvroStorage로 튜플 백을 저장할 때 전체 스키마를 지정하지 않으려면 avro 레코드 이름을 대신 지정할 수 있습니다. (AvroStorage는 인수가 유효한 스키마 정의가 아니라고 판단하여 변수 이름으로 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="4252bcb442e2ece936503733e258204739a13df3" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; operator is used to execute Pig Latin statements, Pig can take the advantage to minimize latency by directly reading data from HDFS rather than launching MapReduce jobs.</source>
          <target state="translated">때 &lt;a href=&quot;test#dump&quot;&gt;덤프&lt;/a&gt; 운전자는 돼지 라틴어 문을 실행하는 데 사용됩니다, 돼지는 직접 HDFS 데이터를 읽기보다는 맵리 듀스 작업을 실행하여 대기 시간을 최소화하기 위해 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2373171fd41393791531861c60bbf2afb742f60" translate="yes" xml:space="preserve">
          <source>When the Combiner is Not Used</source>
          <target state="translated">컴 바이 너를 사용하지 않을 때</target>
        </trans-unit>
        <trans-unit id="9f21b634f1410ca3967733771204d8617de9c912" translate="yes" xml:space="preserve">
          <source>When the Combiner is Used</source>
          <target state="translated">결합기를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="e21d8eca76a680cd0cc2b21cc02359543d4ee186" translate="yes" xml:space="preserve">
          <source>When the type of the column is specified as a map in the &quot;AS&quot; clause, the map keys are the column descriptor names and the data type is chararray. The datatype of the columns values can be declared explicitly as shown in the examples below:</source>
          <target state="translated">&quot;AS&quot;절에서 열 유형이 맵으로 지정된 경우 맵 키는 열 디스크립터 이름이고 데이터 유형은 chararray입니다. 열 값의 데이터 유형은 아래 예와 같이 명시 적으로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e2947a03f0c7ab90bda87a1fa43ee183478db9" translate="yes" xml:space="preserve">
          <source>When there are additional projections in the expression, a cross product will happen similar to bags. For example, if we apply the expression GENERATE $0, FLATTEN($1) to the input tuple (a, m[k1#1, k2#2, k3#3]), we will see (a,k1,1), (a,k2,2) and (a,k3,3) as the result.</source>
          <target state="translated">표현에 추가 투영이있을 경우 백과 유사한 교차 곱이 발생합니다. 예를 들어 GENERATE $ 0, FLATTEN ($ 1) 표현식을 입력 튜플 (a, m [k1 # 1, k2 # 2, k3 # 3])에 적용하면 (a, k1,1), ( 결과적으로 a, k2,2) 및 (a, k3,3).</target>
        </trans-unit>
        <trans-unit id="8c391ebe8e21fb7e7fb86fe5ee0f1f508d24bed9" translate="yes" xml:space="preserve">
          <source>When two bytearrays are used in arithmetic expressions or a bytearray expression is used with built in aggregate functions (such as SUM) they are implicitly cast to double. If the underlying data is really int or long, you&amp;rsquo;ll get better performance by declaring the type or explicitly casting the data.</source>
          <target state="translated">두 개의 바이트 배열이 산술 표현식에 사용되거나 바이트 배열 표현식이 내장 함수 (예 : SUM)와 함께 사용되는 경우 암시 적으로 두 배로 캐스트됩니다. 기본 데이터가 실제로 int이거나 길면 유형을 선언하거나 명시 적으로 데이터를 캐스팅하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af191b7a0fec74b55feccfc99c41d372c5daa2f8" translate="yes" xml:space="preserve">
          <source>When used with a cmd_alias, a stream statement could look like this, where mycmd is the defined alias.</source>
          <target state="translated">cmd_alias와 함께 사용하면 스트림 명령문은 다음과 같습니다. 여기서 mycmd는 정의 된 별명입니다.</target>
        </trans-unit>
        <trans-unit id="8fbf83d05e6f7c1b31a490161cd3390d05a1db87" translate="yes" xml:space="preserve">
          <source>When used with a command, a stream statement could look like this:</source>
          <target state="translated">명령과 함께 사용하면 스트림 명령문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6ed721807105ce7255af0e9c5898fccbd17e610" translate="yes" xml:space="preserve">
          <source>When using PigUnit in mapreduce mode, be sure to include the $HADOOP_CONF_DIR of the cluster in your CLASSPATH.</source>
          <target state="translated">mapreduce 모드에서 PigUnit을 사용하는 경우 CLASSPATH에 클러스터의 $ HADOOP_CONF_DIR을 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="a6e69c3d6a1342bd92a800a4ba135b65013b9e43" translate="yes" xml:space="preserve">
          <source>When using the GROUP (COGROUP) operator with multiple relations, records with a null group key from different relations are considered different and are grouped separately. In the example below note that there are two tuples in the output corresponding to the null group key: one that contains tuples from relation A (but not relation B) and one that contains tuples from relation B (but not relation A).</source>
          <target state="translated">여러 관계가있는 GROUP (COGROUP) 연산자를 사용하는 경우 다른 관계의 널 그룹 키가있는 레코드는 다른 것으로 간주되며 별도로 그룹화됩니다. 아래 예제에서 널 그룹 키에 해당하는 출력에는 두 개의 튜플이 있습니다. 하나는 관계 A의 튜플을 포함하지만 (관계 B는 아님) 하나는 관계 B의 튜플을 포함합니다 (관계 A는 아님).</target>
        </trans-unit>
        <trans-unit id="cb59744ca37f334780c7cde8268e12a5e7ae3d31" translate="yes" xml:space="preserve">
          <source>When using the GROUP operator with a single relation, records with a null group key are grouped together.</source>
          <target state="translated">단일 관계로 GROUP 연산자를 사용하는 경우 널 그룹 키가있는 레코드가 함께 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="94ef2ebb83e97591d4d3973d95f282d730009ea2" translate="yes" xml:space="preserve">
          <source>When you JOIN/COGROUP/CROSS multiple relations, if any relation has an unknown schema (or no defined schema, also referred to as a null schema), the schema for the resulting relation is null.</source>
          <target state="translated">여러 관계에 참여 / 결합 할 때 관계에 알 수없는 스키마가 있거나 정의 된 스키마가없는 경우 (또는 널 스키마라고도 함) 결과 관계의 스키마는 널입니다.</target>
        </trans-unit>
        <trans-unit id="f79acf3ea663e5f8ea7ebeb5313df16304b005c1" translate="yes" xml:space="preserve">
          <source>Where possible, Pig performs implicit casts. In this example $0 is cast to int (regardless of underlying data) and $1 is cast to double.</source>
          <target state="translated">가능한 경우, Pig는 암시 적 캐스트를 수행합니다. 이 예에서 $ 0은 기본 데이터에 관계없이 int로 캐스트되고 $ 1은 두 배로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="bac531b3a0ebf83fcbadf0beb9ec60ce69809488" translate="yes" xml:space="preserve">
          <source>Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization.</source>
          <target state="translated">모듈이 어느 모듈 그룹에서 왔는가. Maven groupId 또는 Ivy Organization으로 직접 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d4b9be4fd7a9f12091dd655c34b0008f97acb4b2" translate="yes" xml:space="preserve">
          <source>While registering an artifact if you wish to exclude some dependencies you can specify them using the exclude key. Suppose you want to use a specific version of a dependent jar which doesn't match the version of the jar when automatically fetched, then you could exclude such dependencies by specifying a comma separated list of dependencies and register the dependent jar separately.</source>
          <target state="translated">일부 종속성을 제외하려는 경우 이슈를 등록하는 동안 제외 키를 사용하여 이슈를 지정할 수 있습니다. 자동 페치시 jar 버전과 일치하지 않는 특정 버전의 종속 jar을 사용하려는 경우 쉼표로 구분 된 종속성 목록을 지정하여 해당 종속성을 제외하고 종속 jar을 별도로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef6951086b871c6202677cb736322928babf20c" translate="yes" xml:space="preserve">
          <source>While the example above is easier to read, you might want to consider combining the two foreach statements to improve your query performance:</source>
          <target state="translated">위의 예제는 읽기가 쉽지만 쿼리 성능을 향상시키기 위해 두 개의 foreach 문을 결합하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="56822d3ba59b98a2eda2ccf3d3052b14da36311d" translate="yes" xml:space="preserve">
          <source>Whitelisting</source>
          <target state="translated">Whitelisting</target>
        </trans-unit>
        <trans-unit id="093a93d105fb7b5416837ee24d87c45b6e3175a9" translate="yes" xml:space="preserve">
          <source>Will be ignored, though by convention it should be &quot;fixed&quot; or &quot;fixedsize&quot;</source>
          <target state="translated">관례 적으로 &quot;고정&quot;또는 &quot;고정 크기&quot;여야하지만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc57a23ecbe8505471947377faab44f137f26d6" translate="yes" xml:space="preserve">
          <source>Will generate a logical_plan[.txt|.dot], physical_plan[.text|.dot], exec_plan[.text|.dot] file in the specified path.</source>
          <target state="translated">지정된 경로에 logical_plan [.txt | .dot], physical_plan [.text | .dot], exec_plan [.text | .dot] 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a1a145ea57751d65571e45985c1a82849cddd92" translate="yes" xml:space="preserve">
          <source>With FOREACH operators, the schema following the AS keyword must be enclosed in parentheses when the FLATTEN operator is used. Otherwise, the schema should not be enclosed in parentheses.</source>
          <target state="translated">FOREACH 연산자를 사용하면 FLATTEN 연산자를 사용할 때 AS 키워드 뒤의 스키마를 괄호로 묶어야합니다. 그렇지 않으면 스키마를 괄호로 묶지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6505ffc697fdc8748970d9039bfe3920ade0c91f" translate="yes" xml:space="preserve">
          <source>With JavaScript, the control flow MUST be defined in the main function. Otherwise the script will result in an error.</source>
          <target state="translated">JavaScript를 사용하면 제어 흐름을 주 함수에서 정의해야합니다. 그렇지 않으면 스크립트에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7458f08dbc4de7dde4ba6a5f161033760791b6dd" translate="yes" xml:space="preserve">
          <source>With Jython you MUST use the if __name__ == '__main__':  construct to separate UDFs and control flow. Otherwise the script will result in an error.</source>
          <target state="translated">자이 썬에서는 반드시 if __name__ == '__main__': 구문을 사용하여 UDF와 제어 흐름을 분리해야합니다. 그렇지 않으면 스크립트에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53b9a15afc97dfce6efac41c9bfb4e2cd59c3e75" translate="yes" xml:space="preserve">
          <source>With LOAD and STREAM operators, the schema following the AS keyword must be enclosed in parentheses.</source>
          <target state="translated">LOAD 및 STREAM 연산자를 사용하면 AS 키워드 다음의 스키마는 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="350c647e532731bdf32a4a96132a1c8798af58f6" translate="yes" xml:space="preserve">
          <source>With default statement, as part of a Pig script.</source>
          <target state="translated">Pig 스크립트의 일부로 기본 명령문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd1fdcef52bb8b4757d26e7002ca15a81a6a88b" translate="yes" xml:space="preserve">
          <source>With gzip we saw a better compression (96-99%) but at a cost of 4% slowdown. Thus, we don't recommend using gzip.</source>
          <target state="translated">gzip을 사용하면 압축률이 향상되었지만 (96-99 %) 4 %의 속도 저하가 발생했습니다. 따라서 gzip을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="da52cd7c6787cbfb5fe96b14fbd87f19bdb2c5fc" translate="yes" xml:space="preserve">
          <source>With multi-query exection, you want to use &lt;a href=&quot;basic#store&quot;&gt;STORE&lt;/a&gt; to save (persist) your results. You do not want to use &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; as it will disable multi-query execution and is likely to slow down execution. (If you have included DUMP statements in your scripts for debugging purposes, you should remove them.)</source>
          <target state="translated">다중 쿼리 실행에서는 &lt;a href=&quot;basic#store&quot;&gt;STORE&lt;/a&gt; 를 사용 하여 결과를 저장 (지속) 하려고 합니다. &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; 를 사용하지 않으려면 다중 쿼리 실행이 비활성화되고 실행 속도가 느려질 수 있습니다. (디버깅 목적으로 스크립트에 DUMP 문을 포함한 경우 제거해야합니다.)</target>
        </trans-unit>
        <trans-unit id="304efc3fdd6915af3ace7e5b5fd8ad75ba910377" translate="yes" xml:space="preserve">
          <source>With multi-query execution Pig processes an entire script or a batch of statements at once.</source>
          <target state="translated">다중 쿼리 실행을 통해 Pig는 전체 스크립트 또는 일괄 처리 문을 한 번에 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e4a9b17bee16c54f445587e05146e4a19d51cc7c" translate="yes" xml:space="preserve">
          <source>With multi-query execution Pig processes an entire script or a batch of statements at once. By default Pig tries to run all the jobs that result from that, regardless of whether some jobs fail during execution. To check which jobs have succeeded or failed use one of these options.</source>
          <target state="translated">다중 쿼리 실행을 통해 Pig는 전체 스크립트 또는 일괄 처리 문을 한 번에 처리합니다. 기본적으로 Pig는 실행 중 일부 작업이 실패하는지 여부에 관계없이 해당 작업에서 발생하는 모든 작업을 실행하려고합니다. 성공 또는 실패한 작업을 확인하려면 다음 옵션 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae512fe82091d69dc3fd94007b5adc45f36366a" translate="yes" xml:space="preserve">
          <source>With the declare statement, as part of Pig script.</source>
          <target state="translated">Pig 스크립트의 일부로 선언문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6858d9255cf418f91dc92f069c20c76cb8141d26" translate="yes" xml:space="preserve">
          <source>With the exec command, store statements will not trigger execution; rather, the entire script is parsed before execution starts. Unlike the run command, exec does not change the command history or remembers the handles used inside the script. Exec without any parameters can be used in scripts to force execution up to the point in the script where the exec occurs.</source>
          <target state="translated">exec 명령을 사용하면 store 문은 실행을 트리거하지 않습니다. 오히려 실행이 시작되기 전에 전체 스크립트가 구문 분석됩니다. 실행 명령과 달리 exec는 명령 기록을 변경하지 않거나 스크립트 내에서 사용 된 핸들을 기억합니다. 스크립트에서 매개 변수없이 Exec을 사용하여 exec가 발생하는 스크립트의 지점까지 강제로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d43f158ead25fc9a8b797da71f7fe0a909b06f" translate="yes" xml:space="preserve">
          <source>With the introduction of nulls, join and cogroup semantics were altered to work with nulls. The semantic for cogrouping with nulls is that nulls from a given input are grouped together, but nulls across inputs are not grouped together. This preserves the semantics of grouping (nulls are collected together from a single input to be passed to aggregate functions like COUNT) and the semantics of join (nulls are not joined across inputs). Since flattening an empty bag results in an empty row (and no output), in a standard join the rows with a null key will always be dropped.</source>
          <target state="translated">널 (null)이 도입됨에 따라 조인 및 공동 그룹 의미가 널과 작동하도록 변경되었습니다. 널과의 공동 그룹화의 의미는 주어진 입력의 널이 함께 그룹화되지만 입력의 널은 함께 그룹화되지 않는다는 것입니다. 이렇게하면 그룹화의 의미가 유지됩니다 (null은 단일 입력에서 함께 수집되어 COUNT와 같은 집계 함수로 전달됨) 및 결합의 의미 (null은 입력에서 결합되지 않습니다)를 유지합니다. 빈 백을 병합하면 빈 행이 생성되고 출력이 없으므로 표준 조인에서는 null 키가있는 행이 항상 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e672825b485bb57eea0622c11d927961b9147305" translate="yes" xml:space="preserve">
          <source>With the run command, every store triggers execution. The statements from the script are put into the command history and all the aliases defined in the script can be referenced in subsequent statements after the run command has completed. Issuing a run command on the grunt command line has basically the same effect as typing the statements manually.</source>
          <target state="translated">run 명령을 사용하면 모든 상점이 실행을 트리거합니다. 스크립트의 명령문은 명령 히스토리에 저장되며 스크립트에 정의 된 모든 별명은 실행 명령이 완료된 후 후속 명령문에서 참조 될 수 있습니다. grunt 명령 행에서 실행 명령을 실행하면 기본적으로 명령문을 수동으로 입력하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7829ae01aea0fe575577fca772b874f93430503f" translate="yes" xml:space="preserve">
          <source>Working with Data</source>
          <target state="translated">데이터 작업</target>
        </trans-unit>
        <trans-unit id="b067c0c8dfd104c67aaac0896a0b7b6cd77a6216" translate="yes" xml:space="preserve">
          <source>Works with integral numbers (int, long).</source>
          <target state="translated">정수 (int, long)와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6ce62000fd007a48329db4ce77e89846d8c0c36c" translate="yes" xml:space="preserve">
          <source>Writing Groovy UDFs</source>
          <target state="translated">Groovy UDF 작성</target>
        </trans-unit>
        <trans-unit id="d04acff52433373f40b1c744807ad76243c0d65e" translate="yes" xml:space="preserve">
          <source>Writing Java UDFs</source>
          <target state="translated">Java UDF 작성</target>
        </trans-unit>
        <trans-unit id="025fbb184c96f2d9186be9dc4cf7e1bd28ae5226" translate="yes" xml:space="preserve">
          <source>Writing JavaScript UDFs</source>
          <target state="translated">JavaScript UDF 작성</target>
        </trans-unit>
        <trans-unit id="822847a0e557559123f0a6756c8691a85c75c216" translate="yes" xml:space="preserve">
          <source>Writing Jython UDFs</source>
          <target state="translated">자이 썬 UDF 작성</target>
        </trans-unit>
        <trans-unit id="7c65e4157abf8d885a7d183b5ff38ef4236aef0d" translate="yes" xml:space="preserve">
          <source>Writing Python UDFs</source>
          <target state="translated">파이썬 UDF 작성</target>
        </trans-unit>
        <trans-unit id="1794f4d979fd4da5d8b316153152eccf75479b68" translate="yes" xml:space="preserve">
          <source>Writing Ruby UDFs</source>
          <target state="translated">루비 UDF 작성</target>
        </trans-unit>
        <trans-unit id="5634f4eeecfa605acfad7e1f3fe66af01e0ee24e" translate="yes" xml:space="preserve">
          <source>Writing a Ruby UDF</source>
          <target state="translated">루비 UDF 작성</target>
        </trans-unit>
        <trans-unit id="731bf6cf3d4ad718e2e995ce8a19175d7b1bcfd0" translate="yes" xml:space="preserve">
          <source>Xml mode: outputs a xml which represent the plan (only logical plan is shown currently).</source>
          <target state="translated">Xml 모드 : 계획을 나타내는 xml을 출력합니다 (논리 계획 만 현재 표시됨).</target>
        </trans-unit>
        <trans-unit id="71872f5817758dd99a85c5be26e02589360670fc" translate="yes" xml:space="preserve">
          <source>YearsBetween</source>
          <target state="translated">YearsBetween</target>
        </trans-unit>
        <trans-unit id="771a0b459893ba24610475ee4656f8a8af41dc8b" translate="yes" xml:space="preserve">
          <source>YearsBetween(datetime1, datetime2)</source>
          <target state="translated">YearsBetween (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="795fdf6acb2b4c54fa143dec62ec30fb9c96c7f6" translate="yes" xml:space="preserve">
          <source>You an assign an alias to another alias. The new alias can be used in the place of the original alias to refer the original relation.</source>
          <target state="translated">다른 별명에 별명을 지정합니다. 원래 별명 대신 새 별명을 사용하여 원래 관계를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50fe41d37ee050565928429f0cecc1a80e847709" translate="yes" xml:space="preserve">
          <source>You can COGROUP up to but no more than 127 relations at a time.</source>
          <target state="translated">한 번에 최대 127 개의 관계를 COGROUP 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a34efde7b20ae076c4ffe00e799f7f6b0eac614f" translate="yes" xml:space="preserve">
          <source>You can also name a pipeline stored in the script:</source>
          <target state="translated">스크립트에 저장된 파이프 라인의 이름을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d5652726a0804f6f249dcbfb9965a5867de967" translate="yes" xml:space="preserve">
          <source>You can also perform projections within the nested block.</source>
          <target state="translated">중첩 된 블록 내에서 투영을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b71e24261c08dd76cb17c8c49f57f9b9b977dd7" translate="yes" xml:space="preserve">
          <source>You can also write Algebraic and Accumulator UDFs using Groovy. Both types of UDFs are declared using annotations, a single Groovy file can therefore enclose several Algebraic/Accumulator UDFs, all mixed with regular UDFs.</source>
          <target state="translated">Groovy를 사용하여 대수 및 누산기 UDF를 작성할 수도 있습니다. 두 유형의 UDF는 주석을 사용하여 선언되므로 단일 Groovy 파일은 여러 개의 대수 / 축적 기 UDF를 모두 포함 할 수 있으며 모두 정규 UDF와 혼합됩니다.</target>
        </trans-unit>
        <trans-unit id="71693c358b175870893b33f67a8b36faf99724b7" translate="yes" xml:space="preserve">
          <source>You can also write Algebraic and Accumulator UDFs using Ruby. You need to extend your class from AlgebraicPigUdf and AccumulatorPigUdf respectively. For an Algebraic UDF, define initial, intermed, and final methods in the class. For an Accumulator UDF, define exec and get methods in the class. Below are example for each type of UDF:</source>
          <target state="translated">Ruby를 사용하여 대수 및 누산기 UDF를 작성할 수도 있습니다. AlgebraicPigUdf 및 AccumulatorPigUdf에서 각각 클래스를 확장해야합니다. 대수 UDF의 경우 클래스에서 초기, 연동 및 최종 메소드를 정의하십시오. Accumulator UDF의 경우 exec를 정의하고 클래스에서 메소드를 가져 오십시오. 다음은 각 유형의 UDF에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="074eb4092b3df33964b45cd789655c92ddcf0d35" translate="yes" xml:space="preserve">
          <source>You can check if the combiner is used for your query by running &lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; on the FOREACH alias as shown above. You should see the combine section in the MapReduce part of the plan:</source>
          <target state="translated">위와 같이 FOREACH 별명 에서 &lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; 을 실행하여 결합기가 쿼리에 사용되는지 확인할 수 있습니다 . 계획의 MapReduce 부분에 결합 섹션이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="69e09b184c5724e3e2cbf99c321076d742b4b9cc" translate="yes" xml:space="preserve">
          <source>You can choose not to define a schema; in this case, the field is un-named and the field type defaults to bytearray.</source>
          <target state="translated">스키마를 정의하지 않도록 선택할 수 있습니다. 이 경우 필드의 이름이 지정되지 않고 필드 유형의 기본값은 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ab1ab840aa494cde3d3cf29c3ad3e8cbefef881c" translate="yes" xml:space="preserve">
          <source>You can define a schema that includes both the field name and field type.</source>
          <target state="translated">필드 이름과 필드 유형을 모두 포함하는 스키마를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1aaf17fe7247d2f0056b51d4a671cd01f1469c2" translate="yes" xml:space="preserve">
          <source>You can define a schema that includes the field name only; in this case, the field type defaults to bytearray.</source>
          <target state="translated">필드 이름 만 포함하는 스키마를 정의 할 수 있습니다. 이 경우 필드 유형의 기본값은 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3320eb9158b2a3d726767c1e6fbbc38842907cd8" translate="yes" xml:space="preserve">
          <source>You can define an alias for a function using &lt;a href=&quot;basic#define-udfs&quot;&gt;DEFINE statement&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;basic#define-udfs&quot;&gt;DEFINE 문을&lt;/a&gt; 사용하여 함수의 별명을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7dda8c6f68b98382ce4c28793f84be13fc99869" translate="yes" xml:space="preserve">
          <source>You can define schemas for data that includes multiple types.</source>
          <target state="translated">여러 유형을 포함하는 데이터에 대한 스키마를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab6717423ad02eb13bb0321d770ef0f19fc0417" translate="yes" xml:space="preserve">
          <source>You can import Jython modules in your Jython script. Pig resolves Jython dependencies recursively, which means Pig will automatically ship all dependent Jython modules to the backend. Jython modules should be found in the jython search path: JYTHON_HOME, JYTHONPATH, or current directory.</source>
          <target state="translated">Jython 스크립트에서 Jython 모듈을 가져올 수 있습니다. Pig는 Jython 종속성을 재귀 적으로 해결합니다. 즉, Pig는 모든 종속 Jython 모듈을 백엔드에 자동으로 제공합니다. Jython 모듈은 jython 검색 경로 (JYTHON_HOME, JYTHONPATH 또는 현재 디렉토리)에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e9c132d2cc6b1e3ca4c235a90ba406069a7afcca" translate="yes" xml:space="preserve">
          <source>You can include comments in Pig scripts:</source>
          <target state="translated">Pig 스크립트에 주석을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf75fc924807d61425bb3df1c432339ee18fef5" translate="yes" xml:space="preserve">
          <source>You can register JavaScript as shown here. This example uses org.apache.pig.scripting.js.JsScriptEngine to interpret JavaScript. You can develop and use custom script engines to support multiple programming languages and ways to interpret them. Currently, Pig identifies js as a keyword and ships the required scriptengine (Rhino) to interpret it.</source>
          <target state="translated">여기에 표시된대로 JavaScript를 등록 할 수 있습니다. 이 예는 org.apache.pig.scripting.js.JsScriptEngine을 사용하여 JavaScript를 해석합니다. 사용자 정의 스크립트 엔진을 개발하고 사용하여 여러 프로그래밍 언어 및이를 해석하는 방법을 지원할 수 있습니다. 현재 Pig는 js를 키워드로 식별하고이를 해석하는 데 필요한 스크립트 엔진 (Rhino)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b6f292d4e8075527bb1829618c55c2a2364c609" translate="yes" xml:space="preserve">
          <source>You can register a Groovy script as shown here. This example uses org.apache.pig.scripting.groovy.GroovyScriptEngine to interpret the Groovy script. You can develop and use custom script engines to support multiple programming languages and ways to interpret them. Currently, Pig identifies groovy as a keyword and ships the required scriptengine (groovy-all) to interpret it.</source>
          <target state="translated">여기에 표시된대로 Groovy 스크립트를 등록 할 수 있습니다. 이 예에서는 org.apache.pig.scripting.groovy.GroovyScriptEngine을 사용하여 Groovy 스크립트를 해석합니다. 사용자 정의 스크립트 엔진을 개발하고 사용하여 여러 프로그래밍 언어 및이를 해석하는 방법을 지원할 수 있습니다. 현재 Pig는 groovy를 키워드로 식별하고이를 해석하는 데 필요한 스크립트 엔진 (groovy-all)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f2ddefdaba687e18128012a1784a08302e99bae9" translate="yes" xml:space="preserve">
          <source>You can register a Jython script as shown here. This example uses org.apache.pig.scripting.jython.JythonScriptEngine to interpret the Jython script. You can develop and use custom script engines to support multiple programming languages and ways to interpret them. Currently, Pig identifies jython as a keyword and ships the required scriptengine (jython) to interpret it.</source>
          <target state="translated">여기에 표시된대로 Jython 스크립트를 등록 할 수 있습니다. 이 예는 org.apache.pig.scripting.jython.JythonScriptEngine을 사용하여 Jython 스크립트를 해석합니다. 사용자 정의 스크립트 엔진을 개발하고 사용하여 여러 프로그래밍 언어 및이를 해석하는 방법을 지원할 수 있습니다. 현재 Pig는 jython을 키워드로 식별하고이를 해석하는 데 필요한 스크립트 엔진 (jython)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b611b8c510797ee2b099befc2e735a73e5cdaed7" translate="yes" xml:space="preserve">
          <source>You can register a Python script as shown here.</source>
          <target state="translated">여기에 표시된대로 Python 스크립트를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9998370b627d1970597f83291286cdf24555332" translate="yes" xml:space="preserve">
          <source>You can register a Ruby UDF as shown here.</source>
          <target state="translated">여기에 표시된대로 Ruby UDF를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36d35eba5826b86f61136e4a065d210be616d0b" translate="yes" xml:space="preserve">
          <source>You can register additional files (to use with your Pig script) via PIG_OPTS environment variable using the -Dpig.additional.jars.uris option. For more information see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;.</source>
          <target state="translated">-Dpig.additional.jars.uris 옵션을 사용하여 PIG_OPTS 환경 변수를 통해 추가 파일 (Pig 스크립트와 함께 사용)을 등록 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="499dd7e6bddff79f8cc3f3a10a340ef5a203a31c" translate="yes" xml:space="preserve">
          <source>You can run Pig (execute Pig Latin statements and Pig commands) using various modes.</source>
          <target state="translated">다양한 모드를 사용하여 Pig (Pcute Latin Latin 문 및 Pig 명령 실행)를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a7736df215eaa09ba703ff1ea765ab1aebd0b2" translate="yes" xml:space="preserve">
          <source>You can run Pig in batch mode using &lt;a href=&quot;#pig-scripts&quot;&gt;Pig scripts&lt;/a&gt; and the &quot;pig&quot; command (in local or hadoop mode).</source>
          <target state="translated">&lt;a href=&quot;#pig-scripts&quot;&gt;Pig 스크립트&lt;/a&gt; 와 &quot;pig&quot;명령 (로컬 또는 hadoop 모드)을 사용하여 배치 모드에서 Pig를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31d5472f3ff35ff9d36296bf3eb455215193891f" translate="yes" xml:space="preserve">
          <source>You can run Pig in either mode using the &quot;pig&quot; command (the bin/pig Perl script) or the &quot;java&quot; command (java -cp pig.jar ...).</source>
          <target state="translated">&quot;pig&quot;명령 (bin / pig Perl 스크립트) 또는 &quot;java&quot;명령 (java -cp pig.jar ...)을 사용하여 어느 모드에서든 Pig를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2409b0c521b4f5d35a7061c4edd5e1636d898e" translate="yes" xml:space="preserve">
          <source>You can run Pig in interactive mode using the Grunt shell. Invoke the Grunt shell using the &quot;pig&quot; command (as shown below) and then enter your Pig Latin statements and Pig commands interactively at the command line.</source>
          <target state="translated">Grunt 쉘을 사용하여 대화식 모드에서 Pig를 실행할 수 있습니다. &quot;pig&quot;명령 (아래 그림 참조)을 사용하여 Grunt 쉘을 호출 한 다음 명령 행에서 Pig Latin 문 및 Pig 명령을 대화식으로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="281b903f35c69224dbc1528d7b80ada4d2e8fef1" translate="yes" xml:space="preserve">
          <source>You can run Pig scripts from the command line and from the Grunt shell (see the &lt;a href=&quot;cmds#run&quot;&gt;run&lt;/a&gt; and &lt;a href=&quot;cmds#exec&quot;&gt;exec&lt;/a&gt; commands).</source>
          <target state="translated">명령 행 및 Grunt 쉘에서 Pig 스크립트를 실행할 수 있습니다 ( &lt;a href=&quot;cmds#run&quot;&gt;run&lt;/a&gt; 및 &lt;a href=&quot;cmds#exec&quot;&gt;exec&lt;/a&gt; 명령 참조).</target>
        </trans-unit>
        <trans-unit id="4aeee6507ad6d45378fea7dbfe53e8ef75b476b6" translate="yes" xml:space="preserve">
          <source>You can run PigUnit using Pig's local mode or mapreduce mode.</source>
          <target state="translated">Pig의 로컬 모드 또는 mapreduce 모드를 사용하여 PigUnit을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760ce39fbe88e9419851cf4439a339e047517889" translate="yes" xml:space="preserve">
          <source>You can set the number of reduce tasks for the MapReduce jobs generated by Pig using two parallel features. (The parallel features only affect the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block.)</source>
          <target state="translated">두 개의 병렬 기능을 사용하여 Pig가 생성 한 MapReduce 작업에 대한 축소 작업 수를 설정할 수 있습니다. 병렬 기능은 축소 작업 수에만 영향을줍니다. 맵 병렬 처리는 입력 파일에 의해 결정되며 각 HDFS 블록 당 하나의 맵이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c3b13bb770247193591c37dff9a1b6c38362d44e" translate="yes" xml:space="preserve">
          <source>You can set the value for these properties:</source>
          <target state="translated">다음 특성의 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317cbf4fb377ec7f133ea81c4961bbff8e5ef56a" translate="yes" xml:space="preserve">
          <source>You can set the values for these properties in order to configure the behavior:</source>
          <target state="translated">동작을 구성하기 위해 이러한 특성의 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b654d72bdd3101af2208366d00cecca01c2ffc" translate="yes" xml:space="preserve">
          <source>You can set the values for these properties in order to configure the jar cache:</source>
          <target state="translated">jar 캐시를 구성하기 위해 이러한 특성의 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7db82bc36bf06512e17a451f6983f98cd93b20" translate="yes" xml:space="preserve">
          <source>You can set the values for these properties:</source>
          <target state="translated">다음 특성에 대한 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cca3d9f54086be4dffec1ffe6fb5371b13ffde4" translate="yes" xml:space="preserve">
          <source>You can specify any MapReduce/Tez jar file that can be run through the hadoop jar native.jar params command.</source>
          <target state="translated">hadoop jar native.jar params 명령을 통해 실행할 수있는 MapReduce / Tez jar 파일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="002ea90fdb516ef9dd2e3f32c2ec8f58b3f6251b" translate="yes" xml:space="preserve">
          <source>You can specify other characters as field delimiters; however, be sure to encase the characters in single quotes.</source>
          <target state="translated">다른 문자를 필드 구분자로 지정할 수 있습니다. 그러나 문자를 작은 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc9b56e473915692486860a854b0f3f2d76b49f2" translate="yes" xml:space="preserve">
          <source>You can specify parameter names and parameter values as follows:</source>
          <target state="translated">다음과 같이 매개 변수 이름 및 매개 변수 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db03646222eaa9a8f6c7b726f81b517a76e9b40" translate="yes" xml:space="preserve">
          <source>You can supply multiple locations as well:</source>
          <target state="translated">여러 위치를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9fdcc7852fa7eefbe87062ae320f04e71f078f2" translate="yes" xml:space="preserve">
          <source>You can think of a tuple as a row with one or more fields, where each field can be any data type and any field may or may not have data. If a field has no data, then the following happens:</source>
          <target state="translated">튜플은 하나 이상의 필드가있는 행으로 생각할 수 있습니다. 각 필드는 모든 데이터 유형이 될 수 있고 모든 필드에는 데이터가 있거나 없을 수 있습니다. 필드에 데이터가 없으면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d032b8c00194674992f98358704e2ac2177bf6e5" translate="yes" xml:space="preserve">
          <source>You can use Hadoop globing to specify files at the file system or directory levels (see Hadoop &lt;a href=&quot;http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)&quot;&gt;globStatus&lt;/a&gt; for details on globing syntax).</source>
          <target state="translated">Hadoop globing을 사용하여 파일 시스템 또는 디렉토리 레벨에서 파일을 지정할 수 있습니다 ( globing 구문에 대한 자세한 내용 은 Hadoop &lt;a href=&quot;http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)&quot;&gt;globStatus&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="13089db7bf21f2e8fb1f47a7f96ffe65139d5770" translate="yes" xml:space="preserve">
          <source>You can use a built in function (see &lt;a href=&quot;func#load-store-functions&quot;&gt;Load/Store Functions&lt;/a&gt;). PigStorage is the default load function and does not need to be specified (simply omit the USING clause).</source>
          <target state="translated">내장 함수를 사용할 수 있습니다 ( &lt;a href=&quot;func#load-store-functions&quot;&gt;로드 / 저장 함수&lt;/a&gt; 참조 ). PigStorage는 기본로드 기능이므로 지정할 필요가 없습니다 (USING 절은 생략 함).</target>
        </trans-unit>
        <trans-unit id="be7cf74700256475333e04fbe9fa6581d21c804a" translate="yes" xml:space="preserve">
          <source>You can use a built in function (see the &lt;a href=&quot;func#load-store-functions&quot;&gt;Load/Store Functions&lt;/a&gt;). PigStorage is the default store function and does not need to be specified (simply omit the USING clause).</source>
          <target state="translated">내장 함수를 사용할 수 있습니다 ( &lt;a href=&quot;func#load-store-functions&quot;&gt;로드 / 저장 함수 참조&lt;/a&gt; ). PigStorage는 기본 저장 기능이므로 지정할 필요가 없습니다 (USING 절을 생략 함).</target>
        </trans-unit>
        <trans-unit id="06c947167ffe28fd0acb552326acf6e7aa7be6ba" translate="yes" xml:space="preserve">
          <source>You can write your own load function if your data is in a format that cannot be processed by the built in functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="translated">데이터가 내장 함수로 처리 할 수없는 형식 인 경우 고유 한로드 함수를 작성할 수 있습니다 ( &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0582cfc4a6e5a372e7116951977cc10523ac1f60" translate="yes" xml:space="preserve">
          <source>You can write your own store function if your data is in a format that cannot be processed by the built in functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="translated">데이터가 내장 함수로 처리 할 수없는 형식 인 경우 고유 한 상점 함수를 작성할 수 있습니다 ( &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d7fc379c7a5f2d89ea658f7d1908e990b68d2556" translate="yes" xml:space="preserve">
          <source>You have two ways to define the return schema, both use annotations:</source>
          <target state="translated">리턴 스키마를 정의하는 두 가지 방법이 있으며 둘 다 주석을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2541770519f0974da941a9aec11ee0715b66b20c" translate="yes" xml:space="preserve">
          <source>You have two ways to define the return schema:</source>
          <target state="translated">리턴 스키마를 정의하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c67edb3cc8c1bdcf182e85b95c730e00f94446a" translate="yes" xml:space="preserve">
          <source>You invoke Pig in the host scripting language through an embedded &lt;a href=&quot;#pig-object&quot;&gt;Pig object&lt;/a&gt;.</source>
          <target state="translated">내장 된 &lt;a href=&quot;#pig-object&quot;&gt;Pig 개체를&lt;/a&gt; 통해 호스트 스크립팅 언어로 Pig를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="76ce75c22ac1b1e47de3acdb4a4e48556a9ad73c" translate="yes" xml:space="preserve">
          <source>You must extend PigUdf and define your Ruby UDFs in the class.</source>
          <target state="translated">PigUdf를 확장하고 클래스에서 Ruby UDF를 정의해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
