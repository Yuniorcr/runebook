<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="ab5146bc0337c0c4ec162adcbc0f516bf45e19f0" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;</source>
          <target state="translated">사용법은 &lt;a href=&quot;#partitionby&quot;&gt;예 : PARTITION BY를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f9184fa3102a195538324a094c9f3e87e8512af" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;.</source>
          <target state="translated">사용법은 &lt;a href=&quot;#partitionby&quot;&gt;예 : PARTITION BY를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0950ec5daec19b5369e8db389d77d478ef703948" translate="yes" xml:space="preserve">
          <source>For use with functions.</source>
          <target state="translated">기능과 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2e73207156965726452940b3f15d34faa203e678" translate="yes" xml:space="preserve">
          <source>For use with streaming.</source>
          <target state="translated">스트리밍과 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e710be2705e01b5fdc5bc69b770043ff7d7443e6" translate="yes" xml:space="preserve">
          <source>Force parallel &quot;1&quot; for &quot;group all&quot; statement. That's because even if we set parallel to N, only 1 reducer will be used in this case and all other reducer produce empty result.</source>
          <target state="translated">&quot;모두 그룹화&quot;명령문에 대해 병렬 &quot;1&quot;을 강제하십시오. 우리가 N에 평행하게 설정하더라도이 경우에는 하나의 감속기가 사용되며 다른 모든 감속기는 빈 결과를 생성하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c4f05734f466b587d8c8a1997c40b3f98c2fd069" translate="yes" xml:space="preserve">
          <source>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java docs&lt;/a&gt;)</source>
          <target state="translated">% f로 부동 소수점 / 더블 형식, % x로 16 진 정수 형식 지정 (외에 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java 문서&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="65b19c46035a1e459a4e6bb765528e1af24e48c0" translate="yes" xml:space="preserve">
          <source>Format strings with %s, integers with %d. Types are converted for you where reasonable (here, int -&amp;gt; string).</source>
          <target state="translated">문자열을 % s로, 정수를 % d로 포맷하십시오. 적절한 경우 유형이 변환됩니다 (여기서 int-&amp;gt; 문자열).</target>
        </trans-unit>
        <trans-unit id="f0c02fc6d4fa96dcda39151919580b8f3027d3c2" translate="yes" xml:space="preserve">
          <source>Formats a set of values according to a printf-style template, using the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;native Java Formatter&lt;/a&gt; library.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;기본 Java Formatter&lt;/a&gt; 라이브러리를 사용하여 printf 스타일 템플리트에 따라 값 세트를 형식화 합니다.</target>
        </trans-unit>
        <trans-unit id="37a95ef7b2da5e9dfb0b25b33a9688c6a79aa3a1" translate="yes" xml:space="preserve">
          <source>Fragment replicate join is a special type of join that works well if one or more relations are small enough to fit into main memory. In such cases, Pig can perform a very efficient join because all of the hadoop work is done on the map side. In this type of join the large relation is followed by one or more small relations. The small relations must be small enough to fit into main memory; if they don't, the process fails and an error is generated.</source>
          <target state="translated">프래그먼트 복제 조인은 하나 이상의 관계가 주 메모리에 적합 할 정도로 작을 경우 잘 작동하는 특수한 조인 유형입니다. 이러한 경우, 모든 hadoop 작업이 맵 측에서 수행되기 때문에 Pig는 매우 효율적인 조인을 수행 할 수 있습니다. 이 유형의 조인에서 큰 관계 다음에는 하나 이상의 작은 관계가옵니다. 작은 관계는 주 메모리에 맞도록 충분히 작아야합니다. 그렇지 않으면 프로세스가 실패하고 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d2029d8a7b6c3c5acd074ab389e6e84bd20928" translate="yes" xml:space="preserve">
          <source>Fragment replicate joins are experimental; we don't have a strong sense of how small the small relation must be to fit into memory. In our tests with a simple query that involves just a JOIN, a relation of up to 100 M can be used if the process overall gets 1 GB of memory. Please share your observations and experience with us.</source>
          <target state="translated">단편 복제 조인은 실험적입니다. 작은 관계가 메모리에 얼마나 작아야하는지에 대한 강한 감각이 없습니다. JOIN 만 포함하는 간단한 쿼리를 사용한 테스트에서 프로세스 전체가 1GB의 메모리를 가져 오는 경우 최대 100M의 관계를 사용할 수 있습니다. 당신의 관찰과 경험을 우리와 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="f3b8fd3a28a763d9eab819f563e9a8f0681fa259" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idlocal.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">현재 작업 디렉토리에서 프로그램을 컴파일하십시오. idlocal.class는 현재 작업 디렉토리에 기록됩니다. 프로그램을 실행할 때 클래스 경로에 &quot;.&quot;를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="68b6e84a59d14c66e17c94d2084cee2765bf4216" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idmapreduce.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">현재 작업 디렉토리에서 프로그램을 컴파일하십시오. idmapreduce.class는 현재 작업 디렉토리에 기록됩니다. 프로그램을 실행할 때 클래스 경로에&amp;ldquo;.&amp;rdquo;를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="8d3c6572188487e7d0f0bf43f11a330f71f5a985" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the idout directory on your Hadoop system.</source>
          <target state="translated">현재 작업 디렉토리에서 프로그램을 실행하십시오. 결과를 보려면 Hadoop 시스템에서 idout 디렉토리를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3ae11fbd09e929b80dba1b8d2891594f82f70b9d" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the output file, id.out.</source>
          <target state="translated">현재 작업 디렉토리에서 프로그램을 실행하십시오. 결과를 보려면 출력 파일 id.out을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a7a933fc62edcf10d9c4963f8596c7a787656527" translate="yes" xml:space="preserve">
          <source>Full outer join is not supported for bloom joins.</source>
          <target state="translated">블룸 조인에는 전체 외부 조인이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f3f294cdfe303f5625a901ee7d581a06175c157" translate="yes" xml:space="preserve">
          <source>Full outer join.</source>
          <target state="translated">완전 외부 조인.</target>
        </trans-unit>
        <trans-unit id="bd51a32f96535333dd4e1a84807c6dd179d912eb" translate="yes" xml:space="preserve">
          <source>Function Instantiation</source>
          <target state="translated">함수 인스턴스화</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">함수 오버로딩</target>
        </trans-unit>
        <trans-unit id="41a40e8fa627c3e0562970952ab6b5e561ad1d21" translate="yes" xml:space="preserve">
          <source>Function names PigStorage and COUNT are case sensitive.</source>
          <target state="translated">함수 이름 PigStorage 및 COUNT는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="8a60d2c69bf2f39201997d6084ec499f9e7d4ad3" translate="yes" xml:space="preserve">
          <source>Functions can be a part of almost every operator in Pig. The &lt;a href=&quot;func&quot;&gt;Built In Functions&lt;/a&gt; guide describes Pig's built in functions. The &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt; manual shows you how to how to write your own functions and how to access/contribute functions using the Piggy Bank repository.</source>
          <target state="translated">함수는 Pig에서 거의 모든 연산자의 일부가 될 수 있습니다. &lt;a href=&quot;func&quot;&gt;내장에서 함수&lt;/a&gt; 가이드는 돼지의 내장 기능에 대해 설명합니다. &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; 그 방법 액세스 자신의 함수를 작성하는 방법에 대한 방법과 수동 쇼 / 돼지 은행 저장소를 사용하여 기능을 기여하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="69c25d3382693097f4ee01b8b77967c5ef7e79d1" translate="yes" xml:space="preserve">
          <source>Future Enhancements</source>
          <target state="translated">향후 개선 사항</target>
        </trans-unit>
        <trans-unit id="c47a6ad23578fb44a406e049fe66c07a90f32a42" translate="yes" xml:space="preserve">
          <source>GENERATE expression [AS schema] [expression [AS schema]&amp;hellip;.]</source>
          <target state="translated">GENERATE 식 [AS 스키마] [식 [AS 스키마]&amp;hellip;.]</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="013e1ba0cbe0583ac34e8b6e095d4f74e6839fce" translate="yes" xml:space="preserve">
          <source>General Expressions</source>
          <target state="translated">일반 표현</target>
        </trans-unit>
        <trans-unit id="ba7ce2025ad3e9884daf361153c61aba79035239" translate="yes" xml:space="preserve">
          <source>General expressions can be made up of UDFs and almost any operator. Since Pig does not consider boolean a base type, the result of a general expression cannot be a boolean. Field expressions are the simpliest general expressions.</source>
          <target state="translated">일반 표현식은 UDF와 거의 모든 연산자로 구성 될 수 있습니다. Pig는 기본 유형을 부울로 간주하지 않으므로 일반 표현식의 결과는 부울이 될 수 없습니다. 필드 표현식은 가장 간단한 일반 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="05659366d857f4eb5690afb9bdc9b7cff8960f88" translate="yes" xml:space="preserve">
          <source>Generates data transformations based on columns of data.</source>
          <target state="translated">데이터 열을 기반으로 데이터 변환을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5d31621c5fbd4db9066caabd502e7f486ee3e5b1" translate="yes" xml:space="preserve">
          <source>GetDay</source>
          <target state="translated">GetDay</target>
        </trans-unit>
        <trans-unit id="a2818cfc533e59e26a20d03c8af18c62d9b9c5cb" translate="yes" xml:space="preserve">
          <source>GetDay(datetime)</source>
          <target state="translated">GetDay(datetime)</target>
        </trans-unit>
        <trans-unit id="3b156f58cad62688611629fcdf71abc53cfef5f1" translate="yes" xml:space="preserve">
          <source>GetHour</source>
          <target state="translated">GetHour</target>
        </trans-unit>
        <trans-unit id="7f19466d1ae92343794e23e8bd7e86f438306630" translate="yes" xml:space="preserve">
          <source>GetHour(datetime)</source>
          <target state="translated">GetHour(datetime)</target>
        </trans-unit>
        <trans-unit id="58893931dfea4b07fda21ca1e5395092265e2c3a" translate="yes" xml:space="preserve">
          <source>GetMilliSecond</source>
          <target state="translated">GetMilliSecond</target>
        </trans-unit>
        <trans-unit id="afef00aa595fe91edb36d72cf45140620b780d38" translate="yes" xml:space="preserve">
          <source>GetMilliSecond(datetime)</source>
          <target state="translated">GetMilliSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="fbac074c454a28eb5bc3652325337229670aceab" translate="yes" xml:space="preserve">
          <source>GetMinute</source>
          <target state="translated">GetMinute</target>
        </trans-unit>
        <trans-unit id="6ddb6810694ebf38157652de08ac6474351f11dd" translate="yes" xml:space="preserve">
          <source>GetMinute(datetime)</source>
          <target state="translated">GetMinute(datetime)</target>
        </trans-unit>
        <trans-unit id="9a9c8d02c50cc38f21c8d41bc770a3c35f506480" translate="yes" xml:space="preserve">
          <source>GetMonth</source>
          <target state="translated">GetMonth</target>
        </trans-unit>
        <trans-unit id="f2fff6f22018398e947df0b8d628bc57c850fec7" translate="yes" xml:space="preserve">
          <source>GetMonth(datetime)</source>
          <target state="translated">GetMonth(datetime)</target>
        </trans-unit>
        <trans-unit id="ff6d2cdc9cd0bca91c09f0335184b3630e5b2deb" translate="yes" xml:space="preserve">
          <source>GetSecond</source>
          <target state="translated">GetSecond</target>
        </trans-unit>
        <trans-unit id="45f99eb79a9b7a9ba3bd539dcbbaf4f8c0817e77" translate="yes" xml:space="preserve">
          <source>GetSecond(datetime)</source>
          <target state="translated">GetSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="dbe83da717d9b3ecc4a104bf9633dbb6f97546bc" translate="yes" xml:space="preserve">
          <source>GetWeek</source>
          <target state="translated">GetWeek</target>
        </trans-unit>
        <trans-unit id="b1f08071cdcc6fbf37da9c2cb680ecaa83720d89" translate="yes" xml:space="preserve">
          <source>GetWeek(datetime)</source>
          <target state="translated">GetWeek(datetime)</target>
        </trans-unit>
        <trans-unit id="535b65cc823f05d8dee165e5013a86a55c020e85" translate="yes" xml:space="preserve">
          <source>GetWeekYear</source>
          <target state="translated">GetWeekYear</target>
        </trans-unit>
        <trans-unit id="05f2caa2e1cdd71879407becb731af0dcee8c734" translate="yes" xml:space="preserve">
          <source>GetWeekYear(datetime)</source>
          <target state="translated">GetWeekYear(datetime)</target>
        </trans-unit>
        <trans-unit id="834cef9635aab01a61de7d362e8845f769065b31" translate="yes" xml:space="preserve">
          <source>GetYear</source>
          <target state="translated">GetYear</target>
        </trans-unit>
        <trans-unit id="fb7ba0f88bff662f921c57e03488fa999f79c2f9" translate="yes" xml:space="preserve">
          <source>GetYear(datetime)</source>
          <target state="translated">GetYear(datetime)</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="4682593736b76df959401b0677e46c3da95e5f88" translate="yes" xml:space="preserve">
          <source>Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and 4 is the index of E (the character &lt;em&gt;following&lt;/em&gt; the last character of the substring).</source>
          <target state="translated">값이 ABCDEF 인 alpha라는 필드가 주어지면 서브 스트링 BCD를 리턴하려면 다음 명령문을 사용하십시오. SUBSTRING (alpha, 1,4). 1은 B의 색인 (하위 문자열의 첫 문자)이고 4는 E의 색인 ( 하위 문자열의 마지막 문자 &lt;em&gt;다음&lt;/em&gt; 문자)입니다.</target>
        </trans-unit>
        <trans-unit id="2904ccdb85701307c7a4cf0211c6c673432f8e03" translate="yes" xml:space="preserve">
          <source>Given relation A above, the three fields are separated out in this table.</source>
          <target state="translated">위의 관계 A가 주어지면이 표에서 세 개의 필드가 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="5a460e02a6c7ad51f55a1454d1e43a85fd04b53c" translate="yes" xml:space="preserve">
          <source>Given this {$1, $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">이 {$ 1, $ 2}이 (가) 주어지면 Pig는이 {($ 1), ($ 2)}을 (를) 두 개의 튜플이있는 백을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="819d769c6789870f4f6ec3bd99567803b29a16b7" translate="yes" xml:space="preserve">
          <source>Given this {($1), $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">이 {($ 1), $ 2} Pig는이 {($ 1), ($ 2)}을 (를) 두 개의 튜플이있는 백으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7b8a3b30656b5b8d1c274bf06cf27e2edc4a7002" translate="yes" xml:space="preserve">
          <source>Given this {($1, $2)} Pig creates this {($1, $2)} a bag with a single tuple</source>
          <target state="translated">이 {($ 1, $ 2)} 돼지가이 {($ 1, $ 2)}을 (를) 단일 튜플이있는 백을 만듭니다</target>
        </trans-unit>
        <trans-unit id="c18327c070894ced2aa384e5bac6ad7ebbd23172" translate="yes" xml:space="preserve">
          <source>Groovy to Pig</source>
          <target state="translated">그루비에서 돼지까지</target>
        </trans-unit>
        <trans-unit id="671afc89df0401f9442ee7ad8b3683045e599c39" translate="yes" xml:space="preserve">
          <source>Group/Organization and Version are optional fields. In such cases you can leave them blank.</source>
          <target state="translated">그룹 / 조직 및 버전은 선택적 필드입니다. 이러한 경우 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="748922032ec9b2f255ede26d965bccd104ad8a43" translate="yes" xml:space="preserve">
          <source>GroupByConstParallelSetter</source>
          <target state="translated">GroupByConstParallelSetter</target>
        </trans-unit>
        <trans-unit id="6ac2bc105d01b75f0cb6647c28ad7b1ded321074" translate="yes" xml:space="preserve">
          <source>Grouped and ordered data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</source>
          <target state="translated">그룹화 및 정렬 된 데이터 &amp;ndash; 동일한 그룹화 키에 대한 데이터는 스트리밍 애플리케이션에 연속적으로 제공됩니다. 또한 그룹 내의 데이터는 제공된 보조 키로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb388e32ba9398b3d8e495be2290836a832d3ca" translate="yes" xml:space="preserve">
          <source>Grouped data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</source>
          <target state="translated">그룹화 된 데이터 &amp;ndash; 동일한 그룹화 된 키에 대한 데이터가 스트리밍 애플리케이션에 연속적으로 제공되도록 보장</target>
        </trans-unit>
        <trans-unit id="20439eb031c2c2b9f6f2b1f7678cd259da8c350d" translate="yes" xml:space="preserve">
          <source>Groups the data in one or more relations.</source>
          <target state="translated">하나 이상의 관계로 데이터를 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="f5b29066a94b56a4df47b36a243e361e26fd8c0a" translate="yes" xml:space="preserve">
          <source>HBaseStorage</source>
          <target state="translated">HBaseStorage</target>
        </trans-unit>
        <trans-unit id="bc02175406f48d300473a8fc281831d54e6647b9" translate="yes" xml:space="preserve">
          <source>HBaseStorage stores and loads data from HBase. The function takes two arguments. The first argument is a space seperated list of columns. The second optional argument is a space seperated list of options. Column syntax and available options are listed above. Note that HBaseStorage always disable split combination.</source>
          <target state="translated">HBaseStorage는 HBase에서 데이터를 저장하고로드합니다. 이 함수는 두 가지 인수를 취합니다. 첫 번째 인수는 공백으로 구분 된 열 목록입니다. 두 번째 선택적 인수는 공백으로 구분 된 옵션 목록입니다. 열 구문과 사용 가능한 옵션이 위에 나열되어 있습니다. HBaseStorage는 항상 분할 조합을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="42e829762cee04a70bc5305f66fd119de2d0708d" translate="yes" xml:space="preserve">
          <source>HBaseStorage('columns', ['options'])</source>
          <target state="translated">HBaseStorage ( '열', [ '옵션'])</target>
        </trans-unit>
        <trans-unit id="a681ca832e37b54f22d309ff4273f4866e57dab0" translate="yes" xml:space="preserve">
          <source>Hadoop configuration files (include pig-cluster-hadoop-site.xml)</source>
          <target state="translated">하둡 구성 파일 (pig-cluster-hadoop-site.xml 포함)</target>
        </trans-unit>
        <trans-unit id="020d890f6143875ea62437b4701c7f2b8c694a7e" translate="yes" xml:space="preserve">
          <source>Hadoop counters are easily accessible within EvalFunc by using PigStatusReporter object. Here is one example:</source>
          <target state="translated">Hadoop 카운터는 PigStatusReporter 객체를 사용하여 EvalFunc 내에서 쉽게 액세스 할 수 있습니다. 다음은 하나의 예입니다.</target>
        </trans-unit>
        <trans-unit id="efd0ea6d637892905e05f7688a0e68aa55230d64" translate="yes" xml:space="preserve">
          <source>Hadoop properties are not interpreted by Pig but are passed directly to Hadoop. Any Hadoop property can be passed this way.</source>
          <target state="translated">하둡 속성은 Pig에서 해석하지 않지만 하둡으로 직접 전달됩니다. 모든 하둡 속성은이 방법으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c073bed947ef004c13b391708120392ca11dadb" translate="yes" xml:space="preserve">
          <source>Handling Compression</source>
          <target state="translated">압축 처리</target>
        </trans-unit>
        <trans-unit id="4f90cbd026c5d20793d9146514d003112f491dc9" translate="yes" xml:space="preserve">
          <source>Handling null values in dimensions</source>
          <target state="translated">차원의 널값 처리</target>
        </trans-unit>
        <trans-unit id="456113f4880e946d95b861c54ca030a6ccd9d9bc" translate="yes" xml:space="preserve">
          <source>Has no effect.</source>
          <target state="translated">효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae32223dae550e038f070d4468e48d2258fd9abe" translate="yes" xml:space="preserve">
          <source>Hash-based Aggregation in Map Task</source>
          <target state="translated">맵 태스크의 해시 기반 집계</target>
        </trans-unit>
        <trans-unit id="41e875e1fcc46eff88f8e5016b5fc7b546a006fe" translate="yes" xml:space="preserve">
          <source>Hash-based aggregation has been shown to improve the speed of group-by operations by up to 50%. However, since this is a very new feature, it is currently turned OFF by default. To turn it ON, set the property pig.exec.mapPartAgg to true.</source>
          <target state="translated">해시 기반 집계는 그룹 별 작업 속도를 최대 50 % 향상시키는 것으로 나타났습니다. 그러나 이것은 매우 새로운 기능이므로 현재 기본적으로 꺼져 있습니다. 켜려면 속성 pig.exec.mapPartAgg를 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2640b5898454356e628151c15672d38e055e19" translate="yes" xml:space="preserve">
          <source>Having a deterministic schema is very powerful; however, sometimes it comes at the cost of performance. Consider the following example:</source>
          <target state="translated">결정 론적 스키마를 갖는 것은 매우 강력합니다. 그러나 때때로 성능 비용이 발생합니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bfef818e148e3b8356ff2f774f2b9ee7df4e0e3b" translate="yes" xml:space="preserve">
          <source>Here D will be splitted into:</source>
          <target state="translated">여기서 D는 다음과 같이 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="5b126cd838c032776e841c16e4e7635096eb5aff" translate="yes" xml:space="preserve">
          <source>Here Python UDFs means C Python UDFs. It uses python command line to run the Python UDFs. It is different than Jython, which relies on Jython library. Instead, it streams the data in and out of the python process. The implementation mechanism is completely different than Jython.</source>
          <target state="translated">여기서 Python UDF는 C Python UDF를 의미합니다. Python 명령 행을 사용하여 Python UDF를 실행합니다. 자이 썬 라이브러리에 의존하는 자이 썬과는 다르다. 대신, 파이썬 프로세스 안팎으로 데이터를 스트리밍합니다. 구현 메커니즘은 Jython과 완전히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5f2c08c455258fee101fb67d0b42f00bc1baf24c" translate="yes" xml:space="preserve">
          <source>Here are two complete Ruby UDF samples.</source>
          <target state="translated">다음은 두 가지 완전한 Ruby UDF 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="b8dcfe1b81cf245877e8f5d58903219442973ef1" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Avro values to Pig:</source>
          <target state="translated">AvroStorage가 Avro 값을 Pig로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e9d5893cd22a1028524ead1e3803b984d8322c6" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Pig values to Avro:</source>
          <target state="translated">AvroStorage가 Pig 값을 Avro로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d29548e0cb2915ac50ffc61f38a48d8d0a1e70d9" translate="yes" xml:space="preserve">
          <source>Here is the code for SimpleCustomPartitioner:</source>
          <target state="translated">SimpleCustomPartitioner의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d42a9f211cf946a11b895acfcf50eecca384660" translate="yes" xml:space="preserve">
          <source>Here us a code snippet of the integer version of the MAX function that implements the interface:</source>
          <target state="translated">다음은 인터페이스를 구현하는 MAX 함수의 정수 버전에 대한 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="69363bb44856067aa39c56a08488523df0c874c7" translate="yes" xml:space="preserve">
          <source>Here's the way to think about this in the Hadoop world. The exec function of the Initial class is invoked once for each input tuple by the map process and produces partial results. The exec function of the Intermed class is invoked once by each combiner invocation (which can happen zero or more times) and also produces partial results. The exec function of the Final class is invoked once by the reducer and produces the final result.</source>
          <target state="translated">하둡 세계에서 이에 대해 생각하는 방법은 다음과 같습니다. Initial 클래스의 exec 함수는 맵 프로세스에 의해 각 입력 튜플마다 한 번씩 호출되며 부분 결과를 생성합니다. Intermed 클래스의 exec 함수는 각 결합기 호출 (0 회 이상 발생할 수 있음)에 의해 한 번 호출되며 부분 결과도 생성합니다. Final 클래스의 exec 함수는 리듀서에 의해 한 번 호출되어 최종 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="729230c39ce6b3b3af88b635a6fffcb4e16631bf" translate="yes" xml:space="preserve">
          <source>Here's what the multi-query execution does to increase the performance:</source>
          <target state="translated">다중 쿼리 실행이 성능을 향상시키기 위해 수행하는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d08b502754ac5a29f00b79cc168f4200278b24f3" translate="yes" xml:space="preserve">
          <source>Here, we read the file 'flights.txt' out of HDFS and store the results into the relation A. We extract a unique ID for the flight, its source and destination and the tail number from the given file. When STORE'ing back into Accumulo, we specify the column specifications (in this case, just a column family). It is also important to note that four elements are provided as columns because the first element in the Tuple is used as the row in Accumulo.</source>
          <target state="translated">여기서는 HDFS에서 'flights.txt'파일을 읽고 결과를 관계 A에 저장합니다. 제공된 파일에서 항공편의 고유 ID, 출발지 및 목적지 및 꼬리 번호를 추출합니다. STORE가 다시 Accumulo로 돌아올 때, 우리는 열 사양을 지정합니다 (이 경우에는 열 패밀리). Tuple의 첫 번째 요소가 Accumulo의 행으로 사용되므로 4 개의 요소가 열로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88f4ff51e4104da0415333a640e6fd975154c6c2" translate="yes" xml:space="preserve">
          <source>Hive UDF</source>
          <target state="translated">하이브 UDF</target>
        </trans-unit>
        <trans-unit id="f9ce0b773269b974a71ef6d3a6fce10ebf9a16ec" translate="yes" xml:space="preserve">
          <source>Hive UDF name. This can be a fully qualified class name of the Hive UDF/UDTF/UDAF class, or a registered short name in Hive FunctionRegistry (most Hive builtin UDF does that)</source>
          <target state="translated">하이브 UDF 이름. Hive UDF / UDTF / UDAF 클래스의 정규화 된 클래스 이름이거나 Hive FunctionRegistry에 등록 된 짧은 이름 일 수 있습니다 (대부분의 Hive 내장 UDF는이를 수행함)</target>
        </trans-unit>
        <trans-unit id="c5b9d1b74a891758ac6053ce9ef2656a452abb0a" translate="yes" xml:space="preserve">
          <source>HiveUDAF</source>
          <target state="translated">HiveUDAF</target>
        </trans-unit>
        <trans-unit id="a7bf7f603ccf4f8e5fd4d24a6b4801fd41785386" translate="yes" xml:space="preserve">
          <source>HiveUDAF with constant parameter</source>
          <target state="translated">상수 매개 변수가있는 HiveUDAF</target>
        </trans-unit>
        <trans-unit id="6be8ec051a4a129cb854a01427a634a2d62c1beb" translate="yes" xml:space="preserve">
          <source>HiveUDF</source>
          <target state="translated">HiveUDF</target>
        </trans-unit>
        <trans-unit id="1f5b904784c7a83976cd781e900ba741b08bcc25" translate="yes" xml:space="preserve">
          <source>HiveUDF(name[, constant parameters])</source>
          <target state="translated">HiveUDF (이름 [, 상수 매개 변수])</target>
        </trans-unit>
        <trans-unit id="57b25bdd42a8bfd89cde5d17150a800bbdd82d46" translate="yes" xml:space="preserve">
          <source>HiveUDF, HiveUDAF, HiveUDTF share the same syntax.</source>
          <target state="translated">HiveUDF, HiveUDAF, HiveUDTF는 동일한 구문을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="b176b48a267bfe0c13f39e147ccb976626dc67ed" translate="yes" xml:space="preserve">
          <source>HiveUDTF</source>
          <target state="translated">HiveUDTF</target>
        </trans-unit>
        <trans-unit id="0c649e2ec017b5914ee8ac547ddec61818f46581" translate="yes" xml:space="preserve">
          <source>Horizontal ellipsis points indicate that you can repeat a portion of the code.</source>
          <target state="translated">가로 줄임표는 코드의 일부를 반복 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3c07a08d24fc29656223d7ad5fe33d21d2ff9db" translate="yes" xml:space="preserve">
          <source>HoursBetween</source>
          <target state="translated">HoursBetween</target>
        </trans-unit>
        <trans-unit id="d85ad836458e49eb6188932c56b1a9f36287859a" translate="yes" xml:space="preserve">
          <source>HoursBetween(datetime1, datetime2)</source>
          <target state="translated">시간 사이 (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="100cb0b9b76cf128bd36c57de623e9519f3f1a9c" translate="yes" xml:space="preserve">
          <source>How it Works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="5a512c42842d315c68d30298afe72953eec16d9c" translate="yes" xml:space="preserve">
          <source>How to Use a Simple Eval Function</source>
          <target state="translated">간단한 평가 함수를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="859136ad08aa1c154af53341ef9e723eb18c7e39" translate="yes" xml:space="preserve">
          <source>How to Write a Simple Eval Function</source>
          <target state="translated">간단한 평가 함수를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="d404f08d8481d9ea8efead4d447a2938101dcb8f" translate="yes" xml:space="preserve">
          <source>How to enable Tez</source>
          <target state="translated">Tez를 활성화하는 방법</target>
        </trans-unit>
        <trans-unit id="9a04bea978466940a152fd73b98e9fbace4a67cf" translate="yes" xml:space="preserve">
          <source>However, if you further process relation X (Y = FILTER X BY $0 &amp;gt; 1;) there is no guarantee that the data will be processed in the order you originally specified (descending).</source>
          <target state="translated">그러나 관계 X를 추가로 처리하면 (Y = FILTER X BY $ 0&amp;gt; 1;) 데이터가 원래 지정한 순서 (내림차순)로 처리된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="74d77878ac50a503b2a5ae4d6f5d12f747eb630d" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE</source>
          <target state="translated">ILLUSTRATE</target>
        </trans-unit>
        <trans-unit id="4cf3dfa0284dcad8ef3078afd5ea4e09752b0fad" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE is based on an example generator (see &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;Generating Example Data for Dataflow Programs&lt;/a&gt;). The algorithm works by retrieving a small sample of the input data and then propagating this data through the pipeline. However, some operators, such as JOIN and FILTER, can eliminate tuples from the data - and this could result in no data following through the pipeline. To address this issue, the algorithm will automatically generate example data, in near real-time. Thus, you might see data propagating through the pipeline that was not found in the original input data, but this data changes nothing and ensures that you will be able to examine the semantics of your Pig Latin statements.</source>
          <target state="translated">ILLUSTRATE는 예제 생성기를 기반으로합니다 ( &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;데이터 흐름 프로그램의 예제 데이터 생성&lt;/a&gt; 참조 ). 이 알고리즘은 입력 데이터의 작은 샘플을 검색 한 다음 파이프 라인을 통해이 데이터를 전파함으로써 작동합니다. 그러나 JOIN 및 FILTER와 같은 일부 연산자는 데이터에서 튜플을 제거 할 수 있으므로 파이프 라인을 통해 데이터를 추적 할 수 없습니다. 이 문제를 해결하기 위해 알고리즘은 거의 실시간으로 예제 데이터를 자동으로 생성합니다. 따라서 원래 입력 데이터에서 찾을 수없는 파이프 라인을 통해 데이터가 전파되는 것을 볼 수 있지만이 데이터는 아무 것도 변경하지 않으며 Pig Latin 문의 의미를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eac28999aea33c81cb98bea80ea6fcce043fe8e" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE {alias | -script scriptfile};</source>
          <target state="translated">삽화 {별칭 | -script scriptfile};</target>
        </trans-unit>
        <trans-unit id="b034fe864d511351df0ee4a7cfd55942cb62d4ba" translate="yes" xml:space="preserve">
          <source>IMPORT</source>
          <target state="translated">IMPORT</target>
        </trans-unit>
        <trans-unit id="89fff016f6b8ebc8add59a5f8f96f47f4a92e5df" translate="yes" xml:space="preserve">
          <source>IMPORT 'file-with-macro';</source>
          <target state="translated">가져 오기 '파일과 함께'매크로;</target>
        </trans-unit>
        <trans-unit id="1167b0e824163ea9e215a382f87b8f12fbf29970" translate="yes" xml:space="preserve">
          <source>IMPORT (macros)</source>
          <target state="translated">수입 (매크로)</target>
        </trans-unit>
        <trans-unit id="5badbc082509a68348d1b2de0b506786bd7658d9" translate="yes" xml:space="preserve">
          <source>IMPORT adds the macro definitions to the Pig Latin namespace; these macros can then be invoked as if they were defined in the same file.</source>
          <target state="translated">IMPORT는 매크로 정의를 Pig Latin 네임 스페이스에 추가합니다. 이러한 매크로는 마치 동일한 파일에 정의 된 것처럼 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="059d298a40b3fec4385406229f5af45d61612a3d" translate="yes" xml:space="preserve">
          <source>IN (expression)</source>
          <target state="translated">IN (표현)</target>
        </trans-unit>
        <trans-unit id="c55aaf120352287dba10abc369c393e2d067b025" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to help reduce the need for multiple OR conditions.</source>
          <target state="translated">IN 연산자를 사용하면 표현식이 값 목록의 값과 일치하는지 쉽게 테스트 할 수 있습니다. 여러 OR 조건의 필요성을 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d85ce819eaff4a81308dc90de69623bf9480d8a" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to reduce the need for multiple OR conditions.</source>
          <target state="translated">IN 연산자를 사용하면 표현식이 값 목록의 값과 일치하는지 쉽게 테스트 할 수 있습니다. 여러 OR 조건의 필요성을 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f22e0a8543ace135a5f509674fc4700b89a5896" translate="yes" xml:space="preserve">
          <source>IN operator is equivalent to nested OR operators.</source>
          <target state="translated">IN 연산자는 중첩 OR 연산자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d219b4dc13cdee432eb9cf599decd114b681ee36" translate="yes" xml:space="preserve">
          <source>INDEXOF</source>
          <target state="translated">INDEXOF</target>
        </trans-unit>
        <trans-unit id="2c95e05e2e3fc975e680d037087c38ecaa793399" translate="yes" xml:space="preserve">
          <source>INDEXOF(string, 'character', startIndex)</source>
          <target state="translated">INDEXOF (문자열, '문자', startIndex)</target>
        </trans-unit>
        <trans-unit id="091cedb09a5345c158de5c9b9ce5201d93e5d038" translate="yes" xml:space="preserve">
          <source>INPUT &amp;ndash; Keyword.</source>
          <target state="translated">입력 &amp;ndash; 키워드.</target>
        </trans-unit>
        <trans-unit id="e2e6f67f49f77e6f17a5a4a70377d85084890b16" translate="yes" xml:space="preserve">
          <source>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] &amp;hellip;] )</source>
          <target state="translated">INPUT ({stdin | 'path'} [사용 시리얼 라이저] [, {stdin | 'path'} [사용 시리얼 라이저] ...]</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="0fe012d40367d7664e9b3bf78c05516e6b49cdfd" translate="yes" xml:space="preserve">
          <source>Identifiers include the names of relations (aliases), fields, variables, and so on. In Pig, identifiers start with a letter and can be followed by any number of letters, digits, or underscores.</source>
          <target state="translated">식별자에는 관계 이름 (별칭), 필드, 변수 등이 포함됩니다. Pig에서 식별자는 문자로 시작하며 그 뒤에 여러 문자, 숫자 또는 밑줄이 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33cf76ea88eecf41631c2c6696ed2f52f782942a" translate="yes" xml:space="preserve">
          <source>If A is a relation (outer bag), a FOREACH statement could look like this.</source>
          <target state="translated">A가 관계 (외부 백) 인 경우 FOREACH 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afe0e53cb4d9d90b6ba1aca74a93d2f8445ecde1" translate="yes" xml:space="preserve">
          <source>If A is an inner bag, a FOREACH statement could look like this.</source>
          <target state="translated">A가 내부 백인 경우 FOREACH 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c63da8e13e1306df1c5329f267b1cf013f00c39" translate="yes" xml:space="preserve">
          <source>If CUBE and ROLLUP operations are used together, the output groups will be the cross product of all groups generated by cube and rollup operation. If there are m dimensions in cube operations and n dimensions in rollup operation then overall number of combinations will be (2^m) * (n+1).</source>
          <target state="translated">CUBE 및 ROLLUP 작업을 함께 사용하면 출력 그룹은 큐브 및 롤업 작업으로 생성 된 모든 그룹의 교차 곱이됩니다. 큐브 작업에 m 차원이 있고 롤업 작업에 n 차원이있는 경우 전체 조합 수는 (2 ^ m) * (n + 1)입니다.</target>
        </trans-unit>
        <trans-unit id="53995723b5b706a6616e5f264aad6a4b93b46fe0" translate="yes" xml:space="preserve">
          <source>If MyUDF is algebraic, the query will use combiner and run much faster. You can run explain command on your query to make sure that combiner is used.</source>
          <target state="translated">MyUDF가 대수적이면 쿼리는 결합기를 사용하고 훨씬 빠르게 실행됩니다. 쿼리에서 Explain 명령을 실행하여 결합기가 사용되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc88faf080a72258643a84cf95f10e149e13ae3" translate="yes" xml:space="preserve">
          <source>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the &lt;a href=&quot;#types-table-add&quot;&gt;Types Table for addition and subtraction&lt;/a&gt;).</source>
          <target state="translated">Pig가 암시 적 캐스트를 통해 호환되지 않는 유형을 해결할 수 없으면 오류가 발생합니다. 예를 들어, chararray 및 float을 추가 할 수 없습니다 ( &lt;a href=&quot;#types-table-add&quot;&gt;더하기 및 빼기 유형 테이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e01f1d7383a02a96bedbc379dd0c0288bc379a73" translate="yes" xml:space="preserve">
          <source>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on).</source>
          <target state="translated">Pig가 절대 경로를 자동 전달해야한다고 결정하면 파일을 필요한 위치 (권한 부족 등)로 전달할 수있는 방법이 없기 때문에 전혀 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e62658035d80920f5b1abb78f7987725661dad47" translate="yes" xml:space="preserve">
          <source>If Pig is unable to process the expression, Pig returns an exception.</source>
          <target state="translated">Pig가 표현식을 처리 할 수 ​​없으면 Pig는 예외를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3816a983fff2acee696300df0a392ba6e758130e" translate="yes" xml:space="preserve">
          <source>If a UDF returns a tuple or a bag and schema information is not provided, Pig assumes that the tuple contains a single field of type bytearray. If this is not the case, then not specifying the schema can cause failures. We look at this next.</source>
          <target state="translated">UDF가 튜플 또는 백을 리턴하고 스키마 정보가 제공되지 않으면 Pig는 튜플에 bytearray 유형의 단일 필드가 있다고 가정합니다. 그렇지 않은 경우 스키마를 지정하지 않으면 오류가 발생할 수 있습니다. 우리는 이것을 다음에 봅니다.</target>
        </trans-unit>
        <trans-unit id="486e4f66991631e2d049a07741fd4d7ef1bfe823" translate="yes" xml:space="preserve">
          <source>If a custom loader using a text-based InputFormat or a file-based InputFormat would like to read files in all subdirectories under a given input directory recursively, then it should use the PigTextInputFormat and PigFileInputFormat classes provided in org.apache.pig.backend.hadoop.executionengine.mapReduceLayer. The Pig InputFormat classes work around a current limitation in the Hadoop TextInputFormat and FileInputFormat classes which only read one level down from the provided input directory. For example, if the input in the load statement is 'dir1' and there are subdirs 'dir2' and 'dir2/dir3' beneath dir1, the Hadoop TextInputFormat and FileInputFormat classes read the files under 'dir1' only. Using PigTextInputFormat or PigFileInputFormat (or by extending them), the files in all the directories can be read.</source>
          <target state="translated">텍스트 기반 InputFormat 또는 파일 기반 InputFormat을 사용하는 사용자 정의 로더가 지정된 입력 디렉토리 아래의 모든 서브 디렉토리에서 파일을 재귀 적으로 읽으려면 org.apache.pig.backend에 제공된 PigTextInputFormat 및 PigFileInputFormat 클래스를 사용해야합니다. hadoop.executionengine.mapReduceLayer. Pig InputFormat 클래스는 제공된 입력 디렉토리에서 한 수준 아래로만 읽는 Hadoop TextInputFormat 및 FileInputFormat 클래스의 현재 제한 사항을 해결합니다. 예를 들어, load 문의 입력이 'dir1'이고 dir1 아래에 'dir2'및 'dir2 / dir3'하위 디렉토리가있는 경우 Hadoop TextInputFormat 및 FileInputFormat 클래스는 'dir1'아래의 파일 만 읽습니다. PigTextInputFormat 또는 PigFileInputFormat을 사용하거나 확장하여 모든 디렉토리의 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4794078ab3e12dc82064bb4f0a80d07b3c59c8f" translate="yes" xml:space="preserve">
          <source>If a function is algebraic but can be used in a FOREACH statement with accumulator functions, it needs to implement the Accumulator interface in addition to the Algebraic interface.</source>
          <target state="translated">함수가 대수적이지만 어큐뮬레이터 함수가있는 FOREACH 문에서 사용될 수있는 경우, 대수 인터페이스 외에 Accumulator 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccda3daa249c8bc65b4370e66326a311939c526e" translate="yes" xml:space="preserve">
          <source>If a loader implements IndexableLoadFunc, or implements OrderedLoadFunc and CollectableLoadFunc, its input splits won't be subject to possible combinations.</source>
          <target state="translated">로더가 IndexableLoadFunc를 구현하거나 OrderedLoadFunc 및 CollectableLoadFunc를 구현하는 경우 입력 분할에 가능한 조합이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d22536397a6526bff16d2b44ae5ad32b2dad3166" translate="yes" xml:space="preserve">
          <source>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</source>
          <target state="translated">스키마가로드 문의 일부로 정의 된 경우로드 함수는 스키마 시행을 시도합니다. 데이터가 스키마를 준수하지 않으면 로더는 널값 또는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d20b21a086aff45ff998ceac8189b33486fbc4c6" translate="yes" xml:space="preserve">
          <source>If a script has dependencies on the execution order outside of what Pig knows about, execution may fail.</source>
          <target state="translated">스크립트가 Pig가 알고있는 것 이외의 실행 순서에 의존하는 경우 실행이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c60b8394e3c8ca844c4dd6c95b31ff82395596c7" translate="yes" xml:space="preserve">
          <source>If a script with a alias is specified, it will output the plan for the given alias.</source>
          <target state="translated">별명이있는 스크립트가 지정되면 지정된 별명에 대한 계획이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c929a573b654a6447af3bebd28ecf3072a0bfa7e" translate="yes" xml:space="preserve">
          <source>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce).</source>
          <target state="translated">별칭이없는 스크립트가 지정되면 전체 실행 그래프 (논리적, 물리적 또는 맵 축소)가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="7b66f4af28f8442dd36e47f974b35d46ae1ab601" translate="yes" xml:space="preserve">
          <source>If a type is declared then ALL values in the map must be of this type.</source>
          <target state="translated">유형이 선언되면 맵의 모든 값은이 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9165157e4c228dc6b25213c7bef47de768cebba" translate="yes" xml:space="preserve">
          <source>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</source>
          <target state="translated">명시 적 캐스트가 지원되지 않으면 오류가 발생합니다. 예를 들어, chararray를 int로 캐스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c8c61b8e893dc2134f7b454bd561bcf24bcadc6" translate="yes" xml:space="preserve">
          <source>If any subexpression is null, the resulting expression is null.</source>
          <target state="translated">하위 표현식이 널이면 결과 표현식은 널입니다.</target>
        </trans-unit>
        <trans-unit id="bb9518c418a6a42b64160ff3fdffbdf9e983c161" translate="yes" xml:space="preserve">
          <source>If arguments are not bags, an IOException is thrown.</source>
          <target state="translated">인수가 백이 아닌 경우 IOException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="67c0548636f03fb391aff763f50ae24a819f4ca2" translate="yes" xml:space="preserve">
          <source>If desired, custom logic can also be implemented for error handling by creating a subclass of MonitoredUDFExecutor.ErrorCallback, and overriding its handleError and/or handleTimeout methods. Both of those methods are static, and are passed in the instance of the EvalFunc that produced an exception, as well as an exception, so you may use any state you have in the UDF to process the errors as desired. The default behavior is to increment Hadoop counters every time an error is encountered. Once you have an implementation of the ErrorCallback that performs your custom logic, you can provide it in the annotation:</source>
          <target state="translated">원하는 경우 MonitoredUDFExecutor.ErrorCallback의 서브 클래스를 작성하고 handleError 및 / 또는 handleTimeout 메소드를 대체하여 오류 처리를 위해 사용자 정의 로직을 구현할 수도 있습니다. 이 두 메소드는 정적이며 예외뿐만 아니라 예외를 생성 한 EvalFunc 인스턴스에 전달되므로 UDF에있는 모든 상태를 사용하여 원하는대로 오류를 처리 할 수 ​​있습니다. 기본 동작은 오류가 발생할 때마다 Hadoop 카운터를 증가시키는 것입니다. 사용자 정의 로직을 수행하는 ErrorCallback을 구현 한 후에는 주석에이를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9eef31189a46ca896e1a11d04cfdc69be907574" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the result is null.</source>
          <target state="translated">하위 표현식 중 하나가 널이면 결과는 널입니다.</target>
        </trans-unit>
        <trans-unit id="fbb8787a10e9277578f3bacf3c583933a72af49a" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the resulting expression is null.</source>
          <target state="translated">하위 표현식 중 하나가 널인 경우 결과 표현식은 널입니다.</target>
        </trans-unit>
        <trans-unit id="df9492dcb135b34471ac4c01597f6c3e6e9d0c72" translate="yes" xml:space="preserve">
          <source>If either the string being matched against or the string defining the match is null, the result is null.</source>
          <target state="translated">일치하는 문자열 또는 일치를 정의하는 문자열이 null 인 경우 결과는 null입니다.</target>
        </trans-unit>
        <trans-unit id="7c7b8337ae5bc3235aee39b3bf00c4a3b18c0f1e" translate="yes" xml:space="preserve">
          <source>If field_delimiter is null or not passed, the following will be used as delimiters: space [ ], double quote [ &quot; ], coma [ , ] parenthesis [ () ], star [ * ].</source>
          <target state="translated">field_delimiter가 널이거나 전달되지 않으면 공백 [], 큰 따옴표 [ &quot;], 쉼표 [,] 괄호 [()], 별 [*] 등의 구분 기호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d38b38abb97f4eb1e0dcf9186921de58382f8118" translate="yes" xml:space="preserve">
          <source>If invoking Pig in Java, there is change in PigStats and PigProgressNotificationListener if using PigRunner.run(), check &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Statistics&lt;/a&gt; and &lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Notification Listener&lt;/a&gt;</source>
          <target state="translated">Java에서 Pig를 호출하는 경우 PigRunner.run ()을 사용하는 경우 PigStats 및 PigProgressNotificationListener에 변경 사항이 있습니다. &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig 통계&lt;/a&gt; 및 &lt;a href=&quot;test#ppnl&quot;&gt;Pig 진행 알림 리스너를 확인하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94ca295cf76f515a0109ec429d1f4a34670cbbe4" translate="yes" xml:space="preserve">
          <source>If load statement specify a schema, Pig will convert the complex type according to schema. If conversion fails, the affected item will be null (see &lt;a href=&quot;basic#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;).</source>
          <target state="translated">load 문이 스키마를 지정하면 Pig는 스키마에 따라 복합 유형을 변환합니다. 변환에 실패하면 영향을받는 항목은 null입니다 ( &lt;a href=&quot;basic#nulls&quot;&gt;Null 및 Pig Latin&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f3c3c0240ae80e56e35fc2fe724ffaf7f5b93b5" translate="yes" xml:space="preserve">
          <source>If neither &quot;set default parallel&quot; nor the PARALLEL clause are used, Pig sets the number of reducers using a heuristic based on the size of the input data. You can set the values for these properties:</source>
          <target state="translated">&quot;set default parallel&quot;또는 PARALLEL 절을 사용하지 않으면 Pig는 입력 데이터의 크기에 따라 휴리스틱을 사용하여 감속기 수를 설정합니다. 다음 특성에 대한 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1dbfad22027ead0b9c53033155be2cdf92f70af" translate="yes" xml:space="preserve">
          <source>If no script is given:</source>
          <target state="translated">스크립트가 제공되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="3c30b8a15458b41c3c14a039867b1afab3f19551" translate="yes" xml:space="preserve">
          <source>If null, bag arguments are replaced by empty bags.</source>
          <target state="translated">널인 경우 백 인수는 빈 백으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="1f86825c5ae24539f35706c23d25d87bce6d588c" translate="yes" xml:space="preserve">
          <source>If one is running Pig in Tez mode (or both Tez/MapReduce mode), should pass PigTezProgressNotificationListener which extends PigProgressNotificationListener to PigRunner.run() to make sure to get notification in both Tez mode or MapReduce mode.</source>
          <target state="translated">Tez 모드 (또는 Tez / MapReduce 모드)에서 Pig를 실행중인 경우 PigProgressNotificationListener를 PigRunner.run ()으로 확장하는 PigTezProgressNotificationListener를 전달하여 Tez 모드 또는 MapReduce 모드 모두에서 알림을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="a520e683b22094fd77e688c9dcd1fed6eddf94bb" translate="yes" xml:space="preserve">
          <source>If one of the data sets is small enough to fit into memory, a Replicated Join is very likely to provide better performance.</source>
          <target state="translated">데이터 세트 중 하나가 메모리에 들어갈만큼 작 으면 복제 된 조인이 더 나은 성능을 제공 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="207190487fec91fe50bf8a8e561b556722ac4451" translate="yes" xml:space="preserve">
          <source>If only one argument is given, the field is delimited with underscore characters</source>
          <target state="translated">하나의 인수 만 제공하면 필드는 밑줄 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="979bda1c695b72deb2de992c0dbc8fd750122f17" translate="yes" xml:space="preserve">
          <source>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</source>
          <target state="translated">Pig 명령 행 또는 매개 변수 파일에 매개 변수가 지정된 경우, 스크립트는 명령 행 또는 매개 변수 파일에 포함 된 각 para_name에 대해 $ param_name을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3bd4de29e52beea43d5160ea3b5d527766906ff" translate="yes" xml:space="preserve">
          <source>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</source>
          <target state="translated">전 처리기 명령문을 사용하여 매개 변수를 지정하면 스크립트에 % declare 또는 % default가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="52ce5e98f919ecf8fe4edf9131ddd0faddc8d6f2" translate="yes" xml:space="preserve">
          <source>If sort is provided by the loader, rather than an explicit Order operation, the right-side loader must implement either the {OrderedLoadFunc} interface or {IndexableLoadFunc} interface.</source>
          <target state="translated">명시 적 Order 조작이 아닌 로더가 정렬을 제공하는 경우 오른쪽 로더는 {OrderedLoadFunc} 인터페이스 또는 {IndexableLoadFunc} 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="aee0b5384005bdfb9e581a456be8ae8427f85fcd" translate="yes" xml:space="preserve">
          <source>If tagPath or tagFile option is specified, PigStorage will add a pseudo-column INPUT_FILE_PATH or INPUT_FILE_NAME respectively to the beginning of the record. As the name suggests, it is the input file path/name containing this particular record. Please note tagsource is deprecated.</source>
          <target state="translated">tagPath 또는 tagFile 옵션이 지정되면 PigStorage는 의사 열 INPUT_FILE_PATH 또는 INPUT_FILE_NAME을 레코드의 시작 부분에 각각 추가합니다. 이름에서 알 수 있듯이이 특정 레코드를 포함하는 입력 파일 경로 / 이름입니다. tagsource는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d16362f5232337bd67ea5e2e860c60236bd2764" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used, enclose the schema in parentheses.</source>
          <target state="translated">는 IF &lt;a href=&quot;#flatten&quot;&gt;평평의&lt;/a&gt; 연산자를 사용하는 괄호에있는 스키마를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="0caf7a1673c2590cb133f449af480656dad1cb8b" translate="yes" xml:space="preserve">
          <source>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</source>
          <target state="translated">FLATTEN 연산자를 사용하지 않는 경우 스키마를 괄호로 묶지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8742c01ca7dfdb8c7b97679f58a80857cfe6e74b" translate="yes" xml:space="preserve">
          <source>If the STORE and LOAD both had exact matching file paths, Pig will recognize the implicit dependency and launch two different mapreduce jobs/Tez DAGs with the second job depending on the output of the first one. exec is not required to be specified in that case.</source>
          <target state="translated">STORE와 LOAD가 모두 정확히 일치하는 파일 경로를 가진 경우, Pig는 내재 된 종속성을 인식하고 첫 번째 작업의 출력에 따라 두 번째 작업으로 두 개의 다른 mapreduce 작업 / Tez DAG를 시작합니다. 이 경우 exec를 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce8a9990603bf3420d85f373d9702d4a3cac5619" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default load function PigStorage is used.</source>
          <target state="translated">USING 절이 생략되면 기본로드 함수 PigStorage가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="caf383bc86d8a53d213a4ff08b295b5cdb463fbc" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default store function PigStorage is used.</source>
          <target state="translated">USING 절이 생략되면 기본 저장 함수 PigStorage가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ade11ca523a11122e604fa8fcd322615b76561d" translate="yes" xml:space="preserve">
          <source>If the build is successful, you should see the pig.jar file created in that directory.</source>
          <target state="translated">빌드가 성공하면 해당 디렉토리에 pig.jar 파일이 작성되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e73841d4f5c17efd8924856bacadb48c1718106" translate="yes" xml:space="preserve">
          <source>If the de-referenced tuple or map is null, returns null.</source>
          <target state="translated">역 참조 된 튜플 또는 맵이 null 인 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="136bbc1ae8c1804896ccba758e270481404a38b7" translate="yes" xml:space="preserve">
          <source>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</source>
          <target state="translated">스트리밍 명령의 첫 번째 단어가 perl 또는 python 인 경우 Pig는 이진수가 대시로 시작하지 않는 첫 번째 인용되지 않은 문자열이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2edbaa925c2b4bb7fab3191de0feae3407e8c8ae" translate="yes" xml:space="preserve">
          <source>If the group-by keys used for grouping don't result in a sufficient reduction in the number of records, the performance might be worse with this feature turned ON. To prevent this from happening, the feature turns itself off if the reduction in records sent to combiner is not more than a configurable threshold. This threshold can be set using the property pig.exec.mapPartAgg.minReduction. It is set to a default value of 10, which means that the number of records that get sent to the combiner should be reduced by a factor of 10 or more.</source>
          <target state="translated">그룹화에 사용 된 그룹 별 키로 인해 레코드 수가 충분히 줄어들지 않으면이 기능을 켜면 성능이 저하 될 수 있습니다. 이를 방지하기 위해 결합기로 전송되는 레코드 감소가 구성 가능한 임계 값을 초과하지 않으면 기능이 자동으로 꺼집니다. 이 임계 값은 pig.exec.mapPartAgg.minReduction 속성을 사용하여 설정할 수 있습니다. 기본값 10으로 설정됩니다. 즉, 결합기로 전송되는 레코드 수는 10 배 이상 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f0a0dbd61aa62c74fcf75355267ae83889868c65" translate="yes" xml:space="preserve">
          <source>If the input relation has a schema, you can refer to columns by alias rather than by column position. You can also combine aliases and column positions in an expression; for example, &quot;col1 .. $5&quot; is valid.</source>
          <target state="translated">입력 관계에 스키마가있는 경우 열 위치가 아닌 별명으로 열을 참조 할 수 있습니다. 표현식에서 별칭과 열 위치를 결합 할 수도 있습니다. 예를 들어 &quot;col1 .. $ 5&quot;가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1aceb56e8670ae04161c5161bd71a70daf79faf0" translate="yes" xml:space="preserve">
          <source>If the macro has no return alias, then void must be specified.</source>
          <target state="translated">매크로에 리턴 별명이 없으면 void를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab05a18b7e2fd87f280e1388a3db09480d98d569" translate="yes" xml:space="preserve">
          <source>If the noschema option is NOT specified, and a schema is found, it gets loaded when loading data.</source>
          <target state="translated">noschema 옵션이 지정되지 않고 스키마가 발견되면 데이터를로드 할 때로드됩니다.</target>
        </trans-unit>
        <trans-unit id="cc815978d8fbacfa3f024e4ccf2f529fd09fcb51" translate="yes" xml:space="preserve">
          <source>If the parameters of the EvalFunc are all constants, Pig could evaluate the result at compile time. The benefit of evaluating at compile time is performance optimization, and enable certain other optimizations at front end (such as partition pruning, which only allow constant not UDF in filter condition). By default, compile time evaluation is disabled in EvalFunc to prevent potential side effect. To enable it, override allowCompileTimeCalculation. For example:</source>
          <target state="translated">EvalFunc의 매개 변수가 모두 상수이면 Pig는 컴파일 타임에 결과를 평가할 수 있습니다. 컴파일시 평가의 이점은 성능 최적화이며 프런트 엔드에서 특정 다른 최적화 (예 : 필터 조건에서 UDF가 아닌 상수 만 허용하는 파티션 정리)를 가능하게합니다. 잠재적 부작용을 방지하기 위해 EvalFunc에서 기본적으로 컴파일 시간 평가는 비활성화되어 있습니다. 활성화하려면 allowCompileTimeCalculation을 재정의하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37792a4c1c43f548d87fd2c3c9b325971248e022" translate="yes" xml:space="preserve">
          <source>If the query is rewritten to</source>
          <target state="translated">쿼리를 다시 쓴 경우</target>
        </trans-unit>
        <trans-unit id="884e911c9fc042d4017b9c9111d9b8041a7952e3" translate="yes" xml:space="preserve">
          <source>If the result value is not a number (NaN), Pig returns null.</source>
          <target state="translated">결과 값이 숫자 (NaN)가 아니면 Pig는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c1585043821cee828c177bd1dee01acb15c382d" translate="yes" xml:space="preserve">
          <source>If the result value is null or empty, Pig returns null.</source>
          <target state="translated">결과 값이 null이거나 비어 있으면 Pig는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="832a57705057f4442db3191d05182bfe04aabc3e" translate="yes" xml:space="preserve">
          <source>If the schema is null, Pig treats all fields as bytearray (in the backend, Pig will determine the real type for the fields dynamically)</source>
          <target state="translated">스키마가 null이면 Pig는 모든 필드를 바이트 배열로 취급합니다 (백엔드에서 Pig는 필드의 실제 유형을 동적으로 결정합니다)</target>
        </trans-unit>
        <trans-unit id="b0b624c38d08281a478732651dc5b82106034b90" translate="yes" xml:space="preserve">
          <source>If the schema of a relation can&amp;rsquo;t be inferred, Pig will just use the runtime data as is and propagate it through the pipeline.</source>
          <target state="translated">관계의 스키마를 유추 할 수없는 경우 Pig는 런타임 데이터를 그대로 사용하여 파이프 라인을 통해 전파합니다.</target>
        </trans-unit>
        <trans-unit id="0e6717986491eb0953097c78d9d3c2a67abe2393" translate="yes" xml:space="preserve">
          <source>If the schema option is NOT specified, a schema will not be written when storing data.</source>
          <target state="translated">스키마 옵션을 지정하지 않으면 데이터를 저장할 때 스키마가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff2b36c03367bc79f4d31985e06636e1530acb9a" translate="yes" xml:space="preserve">
          <source>If the schema option is specified, a hidden &quot;.pig_schema&quot; file is created in the output directory when storing data. It is used by PigStorage (with or without -schema) during loading to determine the field names and types of the data without the need for a user to explicitly provide the schema in an as clause, unless noschema is specified. No attempt to merge conflicting schemas is made during loading. The first schema encountered during a file system scan is used.</source>
          <target state="translated">스키마 옵션을 지정하면 데이터를 저장할 때 숨겨진 &quot;.pig_schema&quot;파일이 출력 디렉토리에 작성됩니다. noschema가 지정되지 않은 경우 사용자가 as 절에서 스키마를 명시 적으로 제공 할 필요없이 PigStorage (로드 또는 스키마없이)를 사용하여 데이터의 필드 이름 및 유형을 판별합니다. 로드하는 동안 충돌하는 스키마를 병합하지 않습니다. 파일 시스템 스캔 중에 발생한 첫 번째 스키마가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eda78a9c0114a6e6fb5cb21af8108768e29477da" translate="yes" xml:space="preserve">
          <source>If the script doesn't re-load A' for the processing of A the steps above A' will be duplicated. This is a special case of Example 2 above, so the same steps are recommended. With multi-query execution, the script will process A and dump A' as a side-effect.</source>
          <target state="translated">스크립트가 A 처리를 위해 A '를 다시로드하지 않으면 A'위의 단계가 복제됩니다. 이것은 위의 예 2의 특별한 경우이므로 동일한 단계가 권장됩니다. 다중 쿼리 실행을 통해 스크립트는 A를 처리하고 A '를 부작용으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="56ff9b9e7d57fa5c8fe5a67569d32c6b3312a279" translate="yes" xml:space="preserve">
          <source>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</source>
          <target state="translated">배송 및 캐시 옵션을 지정하지 않으면 Pig는 다음과 같은 방법으로 바이너리를 자동 배송하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6540b7615ec5950ced044baf9a5fecbbb70e65b7" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, all tuples in the relation are returned.</source>
          <target state="translated">지정된 출력 튜플 수가 관계의 튜플 수와 같거나 초과하면 관계의 모든 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="661dd3451b1f1f8a9425df1c0a8c2855275567c4" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is less than the number of tuples in the relation, then n tuples are returned. There is no guarantee which n tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</source>
          <target state="translated">지정된 출력 튜플 수가 관계의 튜플 수보다 작 으면 n 튜플이 반환됩니다. n 개의 튜플이 반환 될 것이라는 보장은 없으며 반환 된 튜플은 한 실행에서 다음 실행으로 변경 될 수 있습니다. ORDER 연산자와 LIMIT를 사용하여 특정 튜플 세트를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018691f5562232d00cbae123ff01bedb87fa8b15" translate="yes" xml:space="preserve">
          <source>If the tested object is null, returns null.</source>
          <target state="translated">테스트 된 객체가 null이면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e1b93c2a09e03a21f0905f246868a8fad2e9176" translate="yes" xml:space="preserve">
          <source>If the tested object is null, the SIZE function returns null.</source>
          <target state="translated">테스트 된 객체가 null이면 SIZE 함수는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52452dd37cfe0e014d1a5eeb279eb873c8dd2f17" translate="yes" xml:space="preserve">
          <source>If the tested value is not null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">테스트 된 값이 널이 아닌 경우 true를 리턴합니다. 그렇지 않으면 false를 리턴합니다 ( &lt;a href=&quot;#null_operators&quot;&gt;Null 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="05bcf78db415053b73d510bab61b81cfa58b8490" translate="yes" xml:space="preserve">
          <source>If the tested value is null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">테스트 된 값이 null이면 true를 반환합니다. 그렇지 않으면 false를 리턴합니다 ( &lt;a href=&quot;#null_operators&quot;&gt;Null 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="45e72887e023eb789c7ad2ce2f5d3f8a9395e06f" translate="yes" xml:space="preserve">
          <source>If the the underlying data is sufficiently skewed, bloom join might not help. Skewed join can be considered for those cases.</source>
          <target state="translated">기본 데이터가 충분히 왜곡되면 블룸 조인이 도움이되지 않을 수 있습니다. 이러한 경우에 치우친 조인을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a278eee26bc0d40cd14c07492b34d0e32ef8c022" translate="yes" xml:space="preserve">
          <source>If the type is omitted, the field defaults to type bytearray.</source>
          <target state="translated">유형이 생략되면 필드의 기본값은 bytearray입니다.</target>
        </trans-unit>
        <trans-unit id="df75bf757439ba68f277b7d366c1fe4887dcb0d3" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied for the length of the result tuple.</source>
          <target state="translated">값이 음수이면 결과 튜플의 길이에 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36672551acc7fb0ca7d3aa692155b038a5a092b7" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied to the size of the result bag.</source>
          <target state="translated">값이 음수이면 결과 백의 크기에 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="989efda04814537696830f9d12387663f1d8fe4d" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum length of the result tuple. The last element of the result tuple will contain all input after the last match.</source>
          <target state="translated">값이 양수이면 패턴 (정규 표현식의 컴파일 된 표현)이 최대 한계 1 회 적용되므로 인수 값은 결과 튜플의 최대 길이를 의미합니다. 결과 튜플의 마지막 요소에는 마지막 일치 이후의 모든 입력이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d264e7216fcd7fd94f7b27901536988583458c" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum size of the result bag. The last tuple of the result bag will contain all input after the last match.</source>
          <target state="translated">값이 양수이면 패턴 (정규 표현식의 컴파일 된 표현)이 최대 한계 1 회 적용되므로 인수 값은 결과 백의 최대 크기를 의미합니다. 결과 백의 마지막 튜플에는 마지막 일치 후의 모든 입력이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="03070291f5db09d8b1e48844535ce39e98bd447f" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied for the length of the result tuple too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">값이 0이면 결과 튜플의 길이에도 제한이 적용되지 않으며 후행 빈 문자열 (있는 경우)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7e89973f6facf127728c69232069efe9c532fbb6" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied to the size of the result bag too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">값이 0이면 결과 백의 크기에도 제한이 적용되지 않으며 후행 빈 문자열 (있는 경우)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6231df4fcddcd0669f4101ebd7715a2f671b8fe9" translate="yes" xml:space="preserve">
          <source>If there is a filter statement right after OrcStorage, Pig will push the filter condition to the loader. OrcStorage will prune file/stripe/row group which does not satisfy the condition entirely. For the file/stripe/row group contains data that satisfies the filter condition, OrcStorage will load the file/stripe/row group and Pig will evaluate the filter condition again to remove additional data which does not satisfy the filter condition.</source>
          <target state="translated">OrcStorage 바로 다음에 필터 명령문이 있으면 Pig는 필터 조건을 로더로 푸시합니다. OrcStorage는 조건을 완전히 만족시키지 않는 파일 / 스트라이프 / 행 그룹을 제거합니다. 파일 / 스트라이프 / 행 그룹에 필터 조건을 만족하는 데이터가 포함 된 경우 OrcStorage는 파일 / 스트라이프 / 행 그룹을로드하고 Pig는 필터 조건을 다시 평가하여 필터 조건을 만족하지 않는 추가 데이터를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="59ca04d3d9150ea272608b03ae0156c687fc7b38" translate="yes" xml:space="preserve">
          <source>If types are not specified in the load statement, Pig assumes the type of =double= for numeric computations. A lot of the time, your data would be much smaller, maybe, integer or long. Specifying the real type will help with speed of arithmetic computation. It has an additional advantage of early error detection.</source>
          <target state="translated">load 문에 유형을 지정하지 않으면 Pig는 숫자 계산에 = double = 유형을 가정합니다. 대부분의 경우 데이터는 훨씬 작거나 정수 또는 길어질 수 있습니다. 실제 유형을 지정하면 산술 계산 속도에 도움이됩니다. 조기 오류 감지의 추가 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="24fb50f409eb821f7919123b47b4f273f7700fc1" translate="yes" xml:space="preserve">
          <source>If user specify neither &quot;parallel&quot; or &quot;default_parallel&quot;, Pig will use automatic parallelism. In MapReduce, Pig submit one MapReduce job a time and before submiting a job, Pig has chance to automatically set reduce parallelism based on the size of input file. On the contrary, Tez submit a DAG as a unit and automatic parallelism is managed in three parts</source>
          <target state="translated">사용자가 &quot;병렬&quot;또는 &quot;default_parallel&quot;을 지정하지 않으면 Pig는 자동 병렬 처리를 사용합니다. MapReduce에서 Pig는 한 번에 하나의 MapReduce 작업을 제출하고 작업을 제출하기 전에 입력 파일의 크기에 따라 병렬 처리 감소를 자동으로 설정할 수 있습니다. 반대로 Tez는 DAG를 단위로 제출하고 자동 병렬 처리는 세 부분으로 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="b4dc665c403c330f35903b458f6fe6096a2ced59" translate="yes" xml:space="preserve">
          <source>If you FLATTEN a bag with empty inner schema, the schema for the resulting relation is null.</source>
          <target state="translated">내부 스키마가 비어있는 백을 FLATTEN하면 결과 관계에 대한 스키마가 널입니다.</target>
        </trans-unit>
        <trans-unit id="a9dad6c87764738da3cfc061e6f727d2a6799327" translate="yes" xml:space="preserve">
          <source>If you UNION two relations with incompatible schema, the schema for resulting relation is null.</source>
          <target state="translated">호환되지 않는 스키마로 두 관계를 UNION하면 결과 관계에 대한 스키마가 널입니다.</target>
        </trans-unit>
        <trans-unit id="56e8101602c2d9c75a14cf49e518adb7c0ea62ba" translate="yes" xml:space="preserve">
          <source>If you are just a user of UDFs, this is most of what you need to know about UDFs to use them in your code.</source>
          <target state="translated">UDF 사용자 인 경우 코드에서 UDF를 사용하려면 UDF에 대해 알아야 할 대부분의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="7c772834e2a9aed00764a6e96ad1c9163813c083" translate="yes" xml:space="preserve">
          <source>If you are using Spark, you will also need to specify SPARK_HOME and specify SPARK_JAR which is the hdfs location where you uploaded $SPARK_HOME/lib/spark-assembly*.jar:</source>
          <target state="translated">Spark를 사용하는 경우 SPARK_HOME을 지정하고 $ SPARK_HOME / lib / spark-assembly * .jar을 업로드 한 hdfs 위치 인 SPARK_JAR도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cb81c239c67bf888e13b2d22dde63010dbe3dfb" translate="yes" xml:space="preserve">
          <source>If you are using Tez, you will also need to put Tez configuration directory (the directory that contains the tez-site.xml):</source>
          <target state="translated">Tez를 사용하는 경우 Tez 구성 디렉토리 (tez-site.xml을 포함하는 디렉토리)도 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="f86801fd7dc0106a735a5ab7b2fbc69bbc1e2ca3" translate="yes" xml:space="preserve">
          <source>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</source>
          <target state="translated">필드에 이름을 지정하면 이름을 사용하거나 위치 표기법으로 해당 필드를 참조 할 수 있습니다. 필드에 이름을 지정하지 않으면 (필드의 이름이 지정되지 않은) 위치 표기법을 사용하여 필드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2068efddb33c739f6e1e4118009324d44d4dc5" translate="yes" xml:space="preserve">
          <source>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</source>
          <target state="translated">필드에 유형을 지정하면 캐스트 연산자를 사용하여 유형을 변경할 수 있습니다. 필드에 유형을 지정하지 않으면 필드의 기본값은 바이트 배열입니다. 캐스트 연산자를 사용하여 기본 유형을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93009caea4faeed63c7a3f49e29e15e2d31dcaf9" translate="yes" xml:space="preserve">
          <source>If you do &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; on B, you will see a single column of type double. This is because Pig makes the safest choice and uses the largest numeric type when the schema is not know. In practice, the input data could contain integer values; however, Pig will cast the data to double and make sure that a double result is returned.</source>
          <target state="translated">B에서 &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; 를 수행 하면 double 유형의 단일 열이 표시됩니다. 이는 스키마를 모르면 Pig가 가장 안전한 선택을하고 가장 큰 숫자 유형을 사용하기 때문입니다. 실제로, 입력 데이터는 정수 값을 포함 할 수 있습니다. 그러나 Pig는 데이터를 두 배로 캐스팅하고 두 배의 결과가 반환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c200fd2558a69c650aaf5de63cfc921f16db98be" translate="yes" xml:space="preserve">
          <source>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</source>
          <target state="translated">주어진 스트리밍 명령에 대해 DEFINE을 제공하지 않으면 자동 배송 기능이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d732bcc63d3993a0471861bd1df7f8145f5af3" translate="yes" xml:space="preserve">
          <source>If you have more questions, you can ask on the &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists&lt;/a&gt;.</source>
          <target state="translated">더 궁금한 점이 있으면 &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists (돼지 메일 링리스트)&lt;/a&gt; 에 문의하십시오 .</target>
        </trans-unit>
        <trans-unit id="76dbbb85aae7650b87268f029aecb7ef5ea47ad5" translate="yes" xml:space="preserve">
          <source>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</source>
          <target state="translated">대체 형식이 필요한 경우 다음 인터페이스를 구현하여 사용자 정의 직렬 변환기 / 직렬 변환기를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ab330aaf103a3416195109dc88d65171a3113af" translate="yes" xml:space="preserve">
          <source>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same data.</source>
          <target state="translated">관계 A를 주문하여 관계 X (X = ORDER A BY * DESC;)를 생성하는 경우 관계 A와 X는 여전히 동일한 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4e50578ad11c2c7c9f284f3844fbe57c5a3d59d7" translate="yes" xml:space="preserve">
          <source>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</source>
          <target state="translated">스크립트가 사용하지 않는 스크립트에 매개 변수를 전달하면이 매개 변수는 자동으로 무시됩니다. 스크립트에 매개 변수가 있고 값을 제공하거나 대체하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1369a59a2bb2e259294a035010e7c4da3f78013e" translate="yes" xml:space="preserve">
          <source>If you retrieve relation X (DUMP X;) the data is guaranteed to be in the order you specified (descending).</source>
          <target state="translated">관계 X (DUMP X;)를 검색하면 지정된 순서 (내림차순)로 데이터가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="07b727742d1a4fca1de7143e1c07d0e86425235b" translate="yes" xml:space="preserve">
          <source>If you specify a directory name, all the files in the directory are loaded.</source>
          <target state="translated">디렉토리 이름을 지정하면 디렉토리의 모든 파일이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="2b27e9a3e53e3fef81b3d326d2e23e78ab25c9ea" translate="yes" xml:space="preserve">
          <source>If you use a local cluster, you need to set the required environment variables before starting it:</source>
          <target state="translated">로컬 클러스터를 사용하는 경우 시작하기 전에 필요한 환경 변수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6a85122c8dd900955aa81ccb9781c63a8e5c20c" translate="yes" xml:space="preserve">
          <source>If you use concatenated bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</source>
          <target state="translated">Pig 작업에 연결된 bzip 파일을 사용하면 오류가 표시되지 않지만 결과는 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec27bed12f5b3966ebd9a9d8528ad6a6ed6a7aba" translate="yes" xml:space="preserve">
          <source>If your Pig script generates a sequence of MapReduce jobs, you can compress the output of the intermediate jobs using LZO compression. (Use the &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt; operator to determine if your script produces multiple MapReduce Jobs.)</source>
          <target state="translated">Pig 스크립트가 일련의 MapReduce 작업을 생성하는 경우 LZO 압축을 사용하여 중간 작업의 출력을 압축 할 수 있습니다. 스크립트가 여러 MapReduce 작업을 생성하는지 여부를 판별 하려면 &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1239ee562b13227e2353dd2b5d0642351c9fb666" translate="yes" xml:space="preserve">
          <source>If your UDF can't be made Algebraic but is able to deal with getting input in chunks rather than all at once, consider implementing the Accumulator interface to reduce the amount of memory used by your script. If your function &lt;em&gt;is&lt;/em&gt; Algebraic and can be used on conjunction with Accumulator functions, you will need to implement the Accumulator interface as well as the Algebraic interface. For more information, see &lt;a href=&quot;udf#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;.</source>
          <target state="translated">UDF를 대수로 만들 수는 없지만 한 번에 청크 대신 입력을 처리 할 수있는 경우, Accumulator 인터페이스를 구현하여 스크립트에서 사용하는 메모리 양을 줄이십시오. 함수 &lt;em&gt;가&lt;/em&gt; 대수이고 Accumulator 기능과 함께 사용할 수있는 경우, Accumulator 인터페이스와 Algebraic 인터페이스를 구현해야합니다. 자세한 내용은 &lt;a href=&quot;udf#accumulator-interface&quot;&gt;누산기 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="349f0b1b2f441677a38531ccee38d0d7d15aa938" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, the &amp;lsquo;merge&amp;rsquo; clause to perform an optimized version of COGROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">데이터 및 로더가 이러한 조건을 만족하는 경우 최적화 된 버전의 COGROUP을 수행하기위한 '병합'절; 작업은 맵 측에서 실행되며 감소 단계 실행을 피합니다.</target>
        </trans-unit>
        <trans-unit id="f86b761e8e078b0506cc07cd02d05eb34d02e1a7" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, use the &amp;lsquo;collected&amp;rsquo; clause to perform an optimized version of GROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">데이터 및 로더가 이러한 조건을 만족하는 경우 'collected'절을 사용하여 최적화 된 버전의 GROUP을 수행하십시오. 작업은 맵 측에서 실행되며 감소 단계 실행을 피합니다.</target>
        </trans-unit>
        <trans-unit id="feef6e3b59816e49d675edf99fac1a33a1fb5a57" translate="yes" xml:space="preserve">
          <source>If your loader implementation makes use of the PigSplit object passed through the prepareToRead method, then you may need to rebuild the loader since the definition of PigSplit has been modified.</source>
          <target state="translated">로더 구현에서 prepareToRead 메소드를 통해 전달 된 PigSplit 오브젝트를 사용하는 경우 PigSplit 정의가 수정되었으므로 로더를 다시 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="dee1bf176cbe01fd0441b1a12c13b06adb1b7153" translate="yes" xml:space="preserve">
          <source>Implement UDF by Simulation</source>
          <target state="translated">시뮬레이션으로 UDF 구현</target>
        </trans-unit>
        <trans-unit id="5827f6f79b07ec443d93d8058ad81cc9d4d2ac27" translate="yes" xml:space="preserve">
          <source>Implicit Dependencies</source>
          <target state="translated">암시 적 종속성</target>
        </trans-unit>
        <trans-unit id="4c4d1de553948a314adeca034d84e23cd3b9ae4a" translate="yes" xml:space="preserve">
          <source>Import Lists</source>
          <target state="translated">가져 오기 목록</target>
        </trans-unit>
        <trans-unit id="1e56c1186fa7d5c3374f67d59101df99e56c90cb" translate="yes" xml:space="preserve">
          <source>Import macros defined in a separate file.</source>
          <target state="translated">별도의 파일에 정의 된 매크로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="translated">모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="398119218cf11b626396e7917ac6cf24641f838c" translate="yes" xml:space="preserve">
          <source>Improvements and other components based on PigUnit that could be built later.</source>
          <target state="translated">나중에 빌드 할 수있는 PigUnit 기반의 개선 및 기타 구성 요소.</target>
        </trans-unit>
        <trans-unit id="ab855867b4034f4bb99051d1f3ccaf64cefc7280" translate="yes" xml:space="preserve">
          <source>In Pig Latin,</source>
          <target state="translated">돼지 라틴어에서는</target>
        </trans-unit>
        <trans-unit id="7b89c2531e0f47016cb2eac1f0115cc5c90e90d9" translate="yes" xml:space="preserve">
          <source>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</source>
          <target state="translated">Pig Latin에서 표현식은 FILTER, FOREACH, GROUP 및 SPLIT 연산자 및 평가 함수와 함께 사용되는 언어 구성입니다.</target>
        </trans-unit>
        <trans-unit id="047330b0ff963c6df380d337f23e804c0fa8f828" translate="yes" xml:space="preserve">
          <source>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation.</source>
          <target state="translated">Pig Latin에서는 널의 SQL 정의를 알 수 없거나 존재하지 않는 것으로 널이 구현됩니다. 널은 데이터에서 자연적으로 발생하거나 조작의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b472a5cb1d2bb6677c5894a233ab880022ee5b" translate="yes" xml:space="preserve">
          <source>In Pig, problems with memory usage can occur when data, which results from a group or cogroup operation, needs to be placed in a bag and passed in its entirety to a UDF.</source>
          <target state="translated">Pig에서는 그룹 또는 공동 그룹 작업의 결과로 생성 된 데이터를 백에 넣고 UDF로 전달해야 할 때 메모리 사용 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ac446bcfdd607749e9908e882446119d984b45" translate="yes" xml:space="preserve">
          <source>In Pig, relations are unordered (see &lt;a href=&quot;#relations&quot;&gt;Relations, Bags, Tuples, Fields&lt;/a&gt;):</source>
          <target state="translated">Pig에서는 관계가 정렬되지 않습니다 ( &lt;a href=&quot;#relations&quot;&gt;관계, 가방, 튜플, 필드 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="77395bf675c2c5145ba7cb6ba484de1ce1ad1445" translate="yes" xml:space="preserve">
          <source>In Tez, jvm could reuse for other tasks. It is important to cleanup static variable to make sure there is no side effect. Here is one example:</source>
          <target state="translated">Tez에서 jvm은 다른 작업에 재사용 할 수 있습니다. 정적 변수를 정리하여 부작용이 없는지 확인하는 것이 중요합니다. 다음은 하나의 예입니다.</target>
        </trans-unit>
        <trans-unit id="7dd89a54572b05053fd654da00615655e3c8186b" translate="yes" xml:space="preserve">
          <source>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</source>
          <target state="translated">load 문에서 로더는 튜플에 null을 주입합니다. 널로 대체되는 실제 값은 로더마다 다릅니다. 예를 들어 PigStorage는 빈 필드를 null로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="9ab73a609fcb251095ae635071ba701b69b3b5ae" translate="yes" xml:space="preserve">
          <source>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</source>
          <target state="translated">로드가 아닌 명령문에서 요청 된 필드가 튜플에서 누락되면 Pig는 null을 주입합니다.</target>
        </trans-unit>
        <trans-unit id="761d64cc264226017ae6e486dbdb548f042b4ea4" translate="yes" xml:space="preserve">
          <source>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</source>
          <target state="translated">위치뿐만 아니라 데이터 그룹화 및 순서는 데이터 자체에 의해 결정될 수 있습니다. 그러나 데이터의 구조를 이용하려면 데이터의 속성을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="4e5448a648336936524e336b0e640a723e9a9434" translate="yes" xml:space="preserve">
          <source>In addition to providing Pig script via a string, you can store it in a file and pass the file to the compile call:</source>
          <target state="translated">문자열을 통해 Pig 스크립트를 제공하는 것 외에도 파일에 저장하고 컴파일 호출에 파일을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea3be12b2777f643d5e98b83b6f48b651f89c54" translate="yes" xml:space="preserve">
          <source>In cases where the schema is stored as part of the StoreFunc like PigStorage, JsonStorage, AvroStorage or OrcStorage, users generally have to use an extra FOREACH before STORE to rename the field names and remove the disambiguate operator from the names. To automatically remove the disambiguate operator from the schema for the STORE operation, the pig.store.schema.disambiguate Pig property can be set to &quot;false&quot;. It is the responsibility of the user to make sure that there is no conflict in the field names when using this setting.</source>
          <target state="translated">스키마가 PigStorage, JsonStorage, AvroStorage 또는 OrcStorage와 같이 StoreFunc의 일부로 저장되는 경우 사용자는 일반적으로 STORE 전에 추가 FOREACH를 사용하여 필드 이름의 이름을 바꾸고 명확하지 않은 연산자를 이름에서 제거해야합니다. STORE 조작의 스키마에서 명확성 연산자를 자동으로 제거하기 위해 pig.store.schema.disambiguate Pig 특성을 &quot;false&quot;로 설정할 수 있습니다. 이 설정을 사용할 때 필드 이름에 충돌이 없는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="cb09a5599dba9a08193e6ba5ca41cf184a2941b2" translate="yes" xml:space="preserve">
          <source>In general, lowercase type indicates elements that you supply.</source>
          <target state="translated">일반적으로 소문자 유형은 제공하는 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="667bae580123f622168d5ecaf410d9ca73353cd3" translate="yes" xml:space="preserve">
          <source>In general, uppercase type indicates elements the system supplies.</source>
          <target state="translated">일반적으로 대문자 유형은 시스템이 제공하는 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43385afe9d70e705c298432cd61a48b9ebab8e78" translate="yes" xml:space="preserve">
          <source>In its basic form, compile just takes a Pig Latin fragment that defines the pipeline as described in the previous section. Additionally, the pipeline can be given a name. This name is only used when the embedded script is invoked via the PigRunner Java API (as discussed later in this document).</source>
          <target state="translated">기본 형식에서 컴파일은 이전 섹션에서 설명한대로 파이프 라인을 정의하는 Pig Latin 조각 만 가져옵니다. 또한 파이프 라인에 이름을 지정할 수 있습니다. 이 이름은 PigRunner Java API를 통해 내장 된 스크립트를 호출 할 때만 사용됩니다 (이 문서의 뒷부분에서 설명).</target>
        </trans-unit>
        <trans-unit id="c386aecc87f49116be4bbc8980ea9301e6beef05" translate="yes" xml:space="preserve">
          <source>In its simplest form, bind takes no parameters. In this case, an implicit bind is performed; Pig internally constructs a map of parameters from the local variables specified by the user in the script.</source>
          <target state="translated">가장 간단한 형태의 bind는 매개 변수를 사용하지 않습니다. 이 경우 내재 된 바인드가 수행됩니다. Pig는 내부적으로 스크립트에서 사용자가 지정한 로컬 변수에서 매개 변수 맵을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a6ce11ff76294b5348b9aa96365ef9638cb0d1b7" translate="yes" xml:space="preserve">
          <source>In many cases, AvroStorage will automatically translate your data correctly and you will not need to provide any more information to AvroStorage. But sometimes, it may be convenient to manually provide a schema to AvroStorge. See the example selection below for examples on manually specifying a schema with AvroStorage.</source>
          <target state="translated">대부분의 경우 AvroStorage는 데이터를 자동으로 올바르게 변환하므로 AvroStorage에 더 이상 정보를 제공 할 필요가 없습니다. 그러나 때때로 AvroStorge에 스키마를 수동으로 제공하는 것이 편리 할 수 ​​있습니다. AvroStorage를 사용하여 스키마를 수동으로 지정하는 예는 아래 예 선택을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d274aa391941e3db3eaf1d92d4ca5b2b777dcc2" translate="yes" xml:space="preserve">
          <source>In map-reduce mode, the following script will load from &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/data1&quot; and store into &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/tmp/out1&quot;.</source>
          <target state="translated">맵 축소 모드에서 다음 스크립트는 &quot;hdfs : // &amp;lt;host&amp;gt; : &amp;lt;port&amp;gt; / data1&quot;에서로드되어 &quot;hdfs : // &amp;lt;host&amp;gt; : &amp;lt;port&amp;gt; / tmp / out1&quot;에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fbac605553184ef19261778bcb7ec6f398ca51e3" translate="yes" xml:space="preserve">
          <source>In order to avoid replicated joins on large relations, we fail if size of relation(s) to be replicated (in bytes) is greater than pig.join.replicated.max.bytes (default = 1GB).</source>
          <target state="translated">큰 관계에서 복제 된 조인을 피하기 위해 복제 할 관계의 크기 (바이트)가 pig.join.replicated.max.bytes (기본값 = 1GB)보다 크면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f6df614c8a5e9de3ecdeefdab6a02557f17f3174" translate="yes" xml:space="preserve">
          <source>In parameter file, as part of a command line.</source>
          <target state="translated">명령 행의 일부로 매개 변수 파일에서.</target>
        </trans-unit>
        <trans-unit id="a83607c547c007f3cf1a9c56712a1e100cdccaa1" translate="yes" xml:space="preserve">
          <source>In prior Pig releases, Example 1 will dump A' to disk and then start jobs for B' and C'. Example 2 will execute all the dependencies of B' and store it and then execute all the dependencies of C' and store it. Both are equivalent, but the performance will be different.</source>
          <target state="translated">이전 Pig 릴리스에서 예 1은 A '를 디스크에 덤프 한 다음 B'및 C '에 대한 작업을 시작합니다. 예제 2는 B '의 모든 종속성을 실행하고 저장 한 다음 C'의 모든 종속성을 실행하고 저장합니다. 둘 다 동일하지만 성능이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3dd2199bc012d7207d555ef9e715d44419202375" translate="yes" xml:space="preserve">
          <source>In some cases it might be desirable to fail the entire script upon detecting the first failed job. This can be achieved with the &quot;-F&quot; or &quot;-stop_on_failure&quot; command line flag. If used, Pig will stop execution when the first failed job is detected and discontinue further processing. This also means that file commands that come after a failed store in the script will not be executed (this can be used to create &quot;done&quot; files).</source>
          <target state="translated">경우에 따라 첫 번째 실패한 작업을 감지하면 전체 스크립트를 실패하는 것이 바람직 할 수 있습니다. 이것은 &quot;-F&quot;또는 &quot;-stop_on_failure&quot;명령 행 플래그를 사용하여 수행 할 수 있습니다. 사용하면 Pig는 첫 번째 실패한 작업이 감지 될 때 실행을 중지하고 추가 처리를 중단합니다. 또한 스크립트에서 실패한 저장소 다음에 오는 파일 명령은 실행되지 않습니다 ( &quot;완료&quot;파일을 만드는 데 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a902912f349147fbbe0eb2d57a40fcb3a4e6de06" translate="yes" xml:space="preserve">
          <source>In the FOREACH statement, the field in relation B is referred to by positional notation ($0).</source>
          <target state="translated">FOREACH 문에서 관계 B의 필드는 위치 표기법 ($ 0)으로 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="0534091b29b78ead8b83df710a7671a6499bd98e" translate="yes" xml:space="preserve">
          <source>In the SQL case, the SQLLoader function is invoked with 'sql://mytable'.</source>
          <target state="translated">SQL의 경우 SQLLoader 함수는 'sql : // mytable'로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7013811a67a11af4ac23552269ed48873de74a1b" translate="yes" xml:space="preserve">
          <source>In the above example, a variety of expressions can be applied to algebraic functions including:</source>
          <target state="translated">위의 예에서 다음을 포함한 대수 함수에 다양한 표현을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="translated">위의 예에서 :</target>
        </trans-unit>
        <trans-unit id="789a8aaef2965b6eb70d651d97130eed1c314f0f" translate="yes" xml:space="preserve">
          <source>In the case of inner join and right outer join, the right most relation is used for building the bloom filter and the users are expected to specify the smaller dataset as the right most relation. But in the case of left outer join, the left most relation is used for building the bloom filter and is expected to be the smaller dataset. This is because all records of the outer relation should be in the result and no records can be filtered. If the left relation turns out to be the bigger dataset, it would not be as efficient to build the bloom filter on the bigger dataset. But it might still perform better than a regular join if it is able to filter lot of records from the right relation.</source>
          <target state="translated">내부 조인과 오른쪽 외부 조인의 경우 가장 오른쪽 관계가 블룸 필터를 만드는 데 사용되며 사용자는 가장 작은 관계를 가장 오른쪽 관계로 지정해야합니다. 그러나 왼쪽 외부 조인의 경우 가장 왼쪽 관계는 블룸 필터를 만드는 데 사용되며 더 작은 데이터 집합이 될 것으로 예상됩니다. 외부 관계의 모든 레코드가 결과에 있어야하고 레코드를 필터링 할 수 없기 때문입니다. 왼쪽 관계가 더 큰 데이터 세트로 판명되면 더 큰 데이터 세트에 블룸 필터를 작성하는 것이 비효율적입니다. 그러나 올바른 관계에서 많은 레코드를 필터링 할 수있는 경우 일반 조인보다 여전히 성능이 우수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="366cfaa9f77dcf4de6672d5c4eeb8495d9aab995" translate="yes" xml:space="preserve">
          <source>In the example above relation A is loaded from HDFS and stored in HBase. Note that the schema of relation A is a tuple of size 3, but only two column descriptor names are passed to the HBaseStorage constructor. This is because the first entry in the tuple is used as the HBase rowKey.</source>
          <target state="translated">위의 예에서 관계 A는 HDFS에서로드되어 HBase에 저장됩니다. 관계 A의 스키마는 크기가 3 인 튜플이지만 HBaseStorage 생성자에는 두 개의 열 설명자 이름 만 전달됩니다. 튜플의 첫 번째 항목이 HBase rowKey로 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8768ae4a7963f867789d54883f792a4b049338c3" translate="yes" xml:space="preserve">
          <source>In the example below, note the following:</source>
          <target state="translated">아래 예에서 다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="810f4025eba8164da7f5c931db880c74c3f881c2" translate="yes" xml:space="preserve">
          <source>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</source>
          <target state="translated">스크립트에서 매개 변수 이름은 백 슬래시 문자 (\)로 이스케이프 할 수 있으며이 경우 대체가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="823a66cbb60bb79080f0a8b1ea0d329c7d74614e" translate="yes" xml:space="preserve">
          <source>In these examples a directory is created, a file is copied, a file is listed.</source>
          <target state="translated">이 예제에서는 디렉토리가 작성되고 파일이 복사되며 파일이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb53acc5fc864b189dffd5763e2ccfc43d29a03" translate="yes" xml:space="preserve">
          <source>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</source>
          <target state="translated">이 예에서 A는 튜플의 관계 또는 백입니다. 이 가방을 외부 가방으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b8d5695ad31a39e71eead60f9a78e531f16388" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used to load multiple locations.</source>
          <target state="translated">이 예에서 BinStorage는 여러 위치를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4dad7abc1d7506c6a665f7d105adc4e5904a6a" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used with the LOAD and STORE functions.</source>
          <target state="translated">이 예에서 BinStorage는 LOAD 및 STORE 기능과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a58d2ef04a5cda433ef29f50daa6af7e7faab9f" translate="yes" xml:space="preserve">
          <source>In this example COUNT_STAR is used to count the tuples in a bag.</source>
          <target state="translated">이 예에서 COUNT_STAR는 가방에서 튜플을 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff7470c5528ca285c04a3c3ac0c8d55936316c0" translate="yes" xml:space="preserve">
          <source>In this example DIFF compares the tuples in two bags.</source>
          <target state="translated">이 예에서 DIFF는 두 백의 튜플을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="59300d5fb1b29001840b069de1bdcfdde402ef36" translate="yes" xml:space="preserve">
          <source>In this example FOREACH is nested to the second level.</source>
          <target state="translated">이 예에서 FOREACH는 두 번째 수준으로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="c1481519e4226587e1177016b76ec2132f08cef8" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used to store a relation into HBase.</source>
          <target state="translated">이 예에서 HBaseStorage는 관계를 HBase에 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab84b86ed1cd0f81d89240b20eeb6f47b9930a87" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used with the LOAD function with an explicit schema.</source>
          <target state="translated">이 예에서 HBaseStorage는 명시 적 스키마와 함께 LOAD 함수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="435c4dd4d77b5e857be6bf8ad142ee3d71a0e7a5" translate="yes" xml:space="preserve">
          <source>In this example PARALLEL is used with the GROUP operator.</source>
          <target state="translated">이 예에서 PARALLEL은 GROUP 연산자와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40cb6c5ae4d9ef5896bcd6d4b036252b875f816a" translate="yes" xml:space="preserve">
          <source>In this example Pig will validate, but not execute, the LOAD and FOREACH statements.</source>
          <target state="translated">이 예제에서 Pig는 LOAD 및 FOREACH 문의 유효성을 검사하지만 실행하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="de61ae61ea6032b2e228021c21932ce307a7c989" translate="yes" xml:space="preserve">
          <source>In this example PigDump is used with the STORE function.</source>
          <target state="translated">이 예에서 PigDump는 STORE 기능과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46d2148592ebc16cb761333836a92127b54281f5" translate="yes" xml:space="preserve">
          <source>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</source>
          <target state="translated">이 예에서 PigStorage는 input.txt에 탭으로 구분 된 필드와 줄 바꾸기로 구분 된 레코드가 포함될 것으로 예상합니다. 진술은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6470b4bdc80ce6ec14c6b369cff173d8a96a70af" translate="yes" xml:space="preserve">
          <source>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE statement specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</source>
          <target state="translated">이 예에서 PigStorage는 X의 내용을 별표 (*)로 구분 된 필드가있는 파일에 저장합니다. STORE 문은 파일이 output이라는 디렉토리에 있고 파일의 이름이 part-nnnnn (예 : part-00000)임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3545f3dfb4a61c191d5ce7c17db12055dbea1552" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</source>
          <target state="translated">이 예에서 PigStreaming은 기본 직렬화 / 직렬화 기능입니다. 관계 A의 튜플은 스크립트로 전달되는 탭으로 구분 된 줄로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="53acd63180313d053382b996221400c3670c3ad0" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</source>
          <target state="translated">이 예에서는 PigStreaming이 직렬화 / 직렬화 해제 함수로 사용되지만 쉼표가 구분 기호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="505900e4da0fa482992eb1a2f88bcc0e5d38a43b" translate="yes" xml:space="preserve">
          <source>In this example REGISTER states that the JavaScript module, myfunc.js, is located in the /src directory.</source>
          <target state="translated">이 예에서 REGISTER는 JavaScript 모듈 myfunc.js가 / src 디렉토리에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50cb9301684455fe267eae841880105c8315f523" translate="yes" xml:space="preserve">
          <source>In this example TextLoader is used with the LOAD function.</source>
          <target state="translated">이 예제에서 TextLoader는 LOAD 함수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c5e9d3dd6f9a44bb764a99545f07562b251abc9" translate="yes" xml:space="preserve">
          <source>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</source>
          <target state="translated">이 예에서 X는 관계 또는 튜플 백입니다. X의 튜플에는 두 개의 필드가 있습니다. 첫 번째 필드는 int 유형입니다. 두 번째 필드는 가방 유형입니다. 이 가방을 내부 가방으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf5f5dc213edcf0c2a75a62d467adfd719f4117" translate="yes" xml:space="preserve">
          <source>In this example a CROSS is performed within the nested block.</source>
          <target state="translated">이 예에서 CROSS는 중첩 블록 내에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9d96da638dd744c8666b0a4d7441d6698bbcae66" translate="yes" xml:space="preserve">
          <source>In this example a JAR file stored in HDFS and a local JAR file are registered.</source>
          <target state="translated">이 예에서는 HDFS에 저장된 JAR 파일과 로컬 JAR 파일이 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="c853730b16a0a6d3de6a48047bf1fd0903963d8c" translate="yes" xml:space="preserve">
          <source>In this example a and null are projected.</source>
          <target state="translated">이 예에서는 a와 null이 투영됩니다.</target>
        </trans-unit>
        <trans-unit id="252278b82d54611f8604f3c1c4920b5131753f06" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type bag.</source>
          <target state="translated">이 예제에서는 바이트 배열 (A의 fld)이 유형 bag으로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="52be4343435f44112a5462538218eec269b8c99a" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type map.</source>
          <target state="translated">이 예에서는 바이트 배열 (관계형의 fld)이 유형 맵으로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="adc6b1c539b7f3b4f765bf66f1bbf223243eec17" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type tuple.</source>
          <target state="translated">이 예제에서는 바이트 배열 (관계형의 fld)이 튜플 형식으로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="b780edd4e748b15aca64e2b122fa86c500341bd8" translate="yes" xml:space="preserve">
          <source>In this example a command is defined for use with the &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; operator.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; 연산자 와 함께 사용하도록 명령이 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a42086ec48674799538294ab226a5ef8414b48d8" translate="yes" xml:space="preserve">
          <source>In this example a dump is performed after each statement.</source>
          <target state="translated">이 예에서 덤프는 각 명령문 다음에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="28b34e252e518f10cb207856de095b2d0a0edae9" translate="yes" xml:space="preserve">
          <source>In this example a field delimiter is specified.</source>
          <target state="translated">이 예에서는 필드 구분자가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="231dd12f30cc168f8fe434f1dc9d10741002943a" translate="yes" xml:space="preserve">
          <source>In this example a function is defined for use with the FOREACH &amp;hellip;GENERATE operator.</source>
          <target state="translated">이 예제에서 함수는 FOREACH&amp;hellip; GENERATE 연산자와 함께 사용하도록 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="902f7920721a3a412c9e07306586280fa07bbed2" translate="yes" xml:space="preserve">
          <source>In this example a macro (group_with_parallel) refers to another macro (foreach_count).</source>
          <target state="translated">이 예에서 매크로 (group_with_parallel)는 다른 매크로 (foreach_count)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c526f01c29f290403e51e19b0ba26f8e808e9d41" translate="yes" xml:space="preserve">
          <source>In this example a multi-field tuple is used. For the FILTER statement, Pig performs an implicit cast. For the FOREACH statement, an explicit cast is used.</source>
          <target state="translated">이 예에서는 다중 필드 튜플이 사용됩니다. FILTER 문의 경우, Pig는 내재 된 캐스트를 수행합니다. FOREACH 문에는 명시 적 캐스트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f34e9ccd45ed5247a9948b597bda137a57066df6" translate="yes" xml:space="preserve">
          <source>In this example a name collision will occur. Here letter B is used as alias name and as name in user-defined schema. Pig will throw an exception when name collision is detected.</source>
          <target state="translated">이 예에서는 이름 충돌이 발생합니다. 여기서 문자 B는 별명 및 사용자 정의 스키마의 이름으로 사용됩니다. 이름 충돌이 감지되면 Pig에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe539b60b5336a69ebbb6e4634bb45d1f0a5d224" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified as part of the STREAM statement.</source>
          <target state="translated">이 예에서 스키마는 STREAM 문의 일부로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="06061e753d06a1e6057c5ffcb4a812aa78fbf9d1" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</source>
          <target state="translated">이 예에서는 AS 절을 사용하여 스키마를 지정합니다. 모든 데이터가 스키마를 준수하면 Pig는 할당 된 유형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="34acf70f365e4b31c6e0e3cccb93c0182b8a1c41" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema.</source>
          <target state="translated">이 예에서는 AS 키워드를 사용하여 스키마를 지정합니다. 두 개의 LOAD 문은 동일합니다. DESCRIBE 및 ILLUSTRATE 연산자를 사용하여 스키마를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc43776c73d7d053427079800e34a406b2a45d68" translate="yes" xml:space="preserve">
          <source>In this example additional JAR files are registered via PIG_OPTS environment variable.</source>
          <target state="translated">이 예제에서 추가 JAR 파일은 PIG_OPTS 환경 변수를 통해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="16dcc4a12858c636c8fa146c2aad2b889eb7fae9" translate="yes" xml:space="preserve">
          <source>In this example all duplicate tuples are removed.</source>
          <target state="translated">이 예에서는 모든 중복 튜플이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b618f5f0bcbb7b8e5bdafd32f7a9e4baece8803f" translate="yes" xml:space="preserve">
          <source>In this example all students with an SSN but no name are located.</source>
          <target state="translated">이 예에서 SSN은 있지만 이름이없는 모든 학생이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79068ccaa260466fc6f972d14a88f57c0fcfb5d3" translate="yes" xml:space="preserve">
          <source>In this example all the MapReduce jobs that get launched use 20 reducers.</source>
          <target state="translated">이 예에서 시작된 모든 MapReduce 작업은 20 개의 감속기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b770e6fe233709b0a9582cf8bb7b9270df9258d2" translate="yes" xml:space="preserve">
          <source>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</source>
          <target state="translated">이 예에서는 요청 된 열 ($ 3)이 선언 된 스키마 외부에 있기 때문에 오류가 발생합니다 (위치 표기법은 $ 0으로 시작). 명령문이 실행되기 전에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="019c413fae337da8ece686fc5d54f62505ef2c7a" translate="yes" xml:space="preserve">
          <source>In this example an int is cast to type chararray (see relation X).</source>
          <target state="translated">이 예제에서 int는 chararray 유형으로 캐스트됩니다 (관계 X 참조).</target>
        </trans-unit>
        <trans-unit id="93db6358d966d0c7d514bd2decd538210cc879e4" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be cast to int, a implicitly, and null explicitly.</source>
          <target state="translated">이 예제에서 a와 null은 모두 int, 암시 적으로, 명시 적으로 null로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="f959bad76d0bbfd8004a39fa235bd4ca5f054f65" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be implicitly cast to double.</source>
          <target state="translated">이 예제에서 a와 null은 암시 적으로 double로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="e27f98b53bc5588e16ad4f1af469c5dfda881206" translate="yes" xml:space="preserve">
          <source>In this example cache is used to specify a file located on the cluster compute nodes.</source>
          <target state="translated">이 예에서 캐시는 클러스터 계산 노드에있는 파일을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0dfa087e0c75a861542022b8ebc000c17d370200" translate="yes" xml:space="preserve">
          <source>In this example data is loaded with a schema.</source>
          <target state="translated">이 예제에서 데이터는 스키마와 함께로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d52a2a475a46079874a2842b0e1af3a3ae07325b" translate="yes" xml:space="preserve">
          <source>In this example data is loaded without a schema; it assumes there is a .pig_schema (produced by JsonStorage) in the input directory.</source>
          <target state="translated">이 예제에서 데이터는 스키마없이로드됩니다. 입력 디렉토리에 .pig_schema (JsonStorage에서 생성)가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="98510e7774ca7a3b39f659179e898062288bbc9c" translate="yes" xml:space="preserve">
          <source>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</source>
          <target state="translated">이 예에서 데이터는 PigStorage와 별표 문자 (*)를 필드 구분 기호로 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="993517c57ee376d2b7b84473441b0326f8a923af" translate="yes" xml:space="preserve">
          <source>In this example default_parallel is set in the Pig script; all MapReduce jobs that get launched will use 20 reducers.</source>
          <target state="translated">이 예제에서 default_parallel은 Pig 스크립트에서 설정됩니다. 시작되는 모든 MapReduce 작업은 20 개의 감속기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="004f088c97324626f2f5dd9f710d01d17559c6aa" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to look up the value of key 'open'.</source>
          <target state="translated">이 예에서 역 참조는 키 'open'의 값을 조회하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b80a144f43f789acea82e8c85d4bcbd2d95337f" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</source>
          <target state="translated">이 예에서 역 참조는 튜플 (그룹)에서 필드 (f1)와 백 (a)에서 필드 (f1)를 투영하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="212fc5892a721a0060e45e75350a1fbdbf50b4be" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to retrieve two fields from tuple f2.</source>
          <target state="translated">이 예제에서 역 참조는 튜플 f2에서 두 필드를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="904d63269308c6655e00fc821dff1fc33db0eed0" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</source>
          <target state="translated">이 예에서 비 참조는 백 (a)에 각 튜플의 첫 번째 필드 (f1)를 투영하기 위해 관계 X와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd906ea6b105d25e2f0d5b0003b730ae52af1ed4" translate="yes" xml:space="preserve">
          <source>In this example field &quot;gpa&quot; will default to bytearray because no type is declared.</source>
          <target state="translated">이 예제에서 &quot;gpa&quot;필드는 유형이 선언되지 않았기 때문에 기본적으로 bytearray입니다.</target>
        </trans-unit>
        <trans-unit id="71b7c69ad52a06b1bcb69143364d7c4a4045b02f" translate="yes" xml:space="preserve">
          <source>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</source>
          <target state="translated">이 예제에서 입력 관계의 필드 중 하나가 튜플, 백 또는 맵인 경우, 지연 연산자를 사용하여 해당 필드에 대한 투영을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="381c3ad80f6a75a1d6369b158db1f23e56c0c1a2" translate="yes" xml:space="preserve">
          <source>In this example key value pairs are set at the command line.</source>
          <target state="translated">이 예제에서 키 값 쌍은 명령 행에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="036d7f9ad9b7cc7d5a796a8fa59f8957b424182b" translate="yes" xml:space="preserve">
          <source>In this example multiple key value pairs are set in the Pig script. These key value pairs are put in job-conf by Pig (making the pairs available to Pig and Hadoop). This is a script-wide setting; if a key value is defined multiple times in the script the last value will take effect and will be set for all jobs generated by the script.</source>
          <target state="translated">이 예에서는 Pig 스크립트에서 여러 키 값 쌍이 설정되어 있습니다. 이 주요 값 쌍은 Pig에 의해 job-conf에 저장됩니다 (Pag 및 Hadoop에서 쌍을 사용 가능하게 함). 이것은 스크립트 전체 설정입니다. 스크립트에서 키 값이 여러 번 정의 된 경우 마지막 값이 적용되며 스크립트에서 생성 된 모든 작업에 대해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5f41fb70f423cb0dbfced17b805614a0b220128e" translate="yes" xml:space="preserve">
          <source>In this example multiple nested columns are retained.</source>
          <target state="translated">이 예에서는 여러 개의 중첩 된 열이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5857ac7ca8abbc90407cf41477661d258b1c55" translate="yes" xml:space="preserve">
          <source>In this example multiple parameters are specified.</source>
          <target state="translated">이 예에서는 여러 매개 변수가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="74314f14b6f4d8ce3ccc71bc58e4f39e20febcce" translate="yes" xml:space="preserve">
          <source>In this example my_macro (defined above) is expanded. Because alias B is not visible from the outside it is renamed macro_my_macro_B_0.</source>
          <target state="translated">이 예에서는 my_macro (위에 정의 됨)가 확장되었습니다. 별명 B는 외부에서 볼 수 없으므로 macro_my_macro_B_0으로 이름이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef086a29e25d0a628246ae86a8dfd0251c73a5a" translate="yes" xml:space="preserve">
          <source>In this example no parameters are passed to the macro.</source>
          <target state="translated">이 예제에서는 매개 변수가 매크로로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c2b33f77cda03a397ae83edefe497af878760f6" translate="yes" xml:space="preserve">
          <source>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</source>
          <target state="translated">이 예에서는 스키마가 지정되지 않았습니다. 모든 필드는 기본적으로 bytearray 또는 long을 입력합니다 (데이터 유형 참조).</target>
        </trans-unit>
        <trans-unit id="60048a1c8591e593e65c99554a20d95fc58747db" translate="yes" xml:space="preserve">
          <source>In this example nulls are injected if fields do not have data.</source>
          <target state="translated">이 예에서 필드에 데이터가 없으면 널이 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c2d3f0591222c2c9f03e628a85df359bc7b283" translate="yes" xml:space="preserve">
          <source>In this example of an outer join, if the join key is missing from a table it is replaced by null.</source>
          <target state="translated">외부 조인의이 예에서, 조인 키가 테이블에서 누락 된 경우 널로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0107821bc8812479bdbf1f64b26078690d140226" translate="yes" xml:space="preserve">
          <source>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</source>
          <target state="translated">이 예제에서 출력은 3 개의 튜플로 제한됩니다. 세 개의 튜플이 출력 될 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6926a0c31dcd9e33a949b13c70271304c004ba03" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the exec command.</source>
          <target state="translated">이 예제에서 매개 변수 대체는 exec 명령과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8418fd14b7d1e17833903e6a625c75e3ce956813" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the run command.</source>
          <target state="translated">이 예제에서 매개 변수 대체는 run 명령과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="829f361647b770f5f6f543d85b2622ed7c6cd584" translate="yes" xml:space="preserve">
          <source>In this example parameters are passed and returned.</source>
          <target state="translated">이 예제에서 매개 변수가 전달되고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f8309b5f7726c99d87799e05a93319a66d843c5f" translate="yes" xml:space="preserve">
          <source>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</source>
          <target state="translated">이 예에서 관계 A는 세 번째 필드 f3을 기준으로 내림차순으로 정렬됩니다. 3으로 끝나는 3 개의 튜플의 순서는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7a76748d23607d469a11fdd632d38e8948725ce" translate="yes" xml:space="preserve">
          <source>In this example relation A is split into three relations, X, Y, and Z.</source>
          <target state="translated">이 예에서 관계 A는 X, Y 및 Z의 세 가지 관계로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="ea5ae7eac546e34a2d13c3fafaa1736e62a4a6ac" translate="yes" xml:space="preserve">
          <source>In this example relation X will contain 1% of the data in relation A.</source>
          <target state="translated">이 예에서 관계 X는 관계 A에있는 데이터의 1 %를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e048f00ed84c4268f680319e8d3e4543df48f677" translate="yes" xml:space="preserve">
          <source>In this example relations A and B are joined by their first fields.</source>
          <target state="translated">이 예에서 관계 A와 B는 첫 번째 필드로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbb00b56354e90b99f0d0abee287efa949183ef" translate="yes" xml:space="preserve">
          <source>In this example ship is used to send the script to the cluster compute nodes.</source>
          <target state="translated">이 예제에서 ship은 스크립트를 클러스터 계산 노드로 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb32f8e1cb739afed30691ec54c7d7d010de23a0" translate="yes" xml:space="preserve">
          <source>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</source>
          <target state="translated">이 예제에서 특수 문자 (이 경우 mydata)를 사용하지 않는 단일 단어 값은 따옴표로 묶을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb06a1600d91e4a228d8c694d3f8cc460e0f109e" translate="yes" xml:space="preserve">
          <source>In this example the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used to eliminate nesting.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; 연산자를 사용하여 중첩을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="00106135a67fa0fb49d05b22a6af49367f72d99b" translate="yes" xml:space="preserve">
          <source>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</source>
          <target state="translated">이 예에서 EXPLAIN 연산자는 세 가지 계획을 모두 생성합니다. (이 예에서는 출력의 일부만 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="e7c916eb550f56bcc8d23590cbf1cf0c80f42104" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes FLATTEN and a schema for simple data types.</source>
          <target state="translated">이 예에서 FOREACH 문에는 FLATTEN 및 단순 데이터 유형에 대한 스키마가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="417fccbcd046561d8ffe25457defbd55e880d1fe" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schema for simple expression.</source>
          <target state="translated">이 예에서 FOREACH 문은 단순 표현식에 대한 스키마를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e7d9bf5151735fb7eac9687d81ce6fb8ed553219" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schemas for multiple fields.</source>
          <target state="translated">이 예에서 FOREACH 문은 여러 필드에 대한 스키마를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="24842feb372ec793af9f761b6b82120ae0b6939d" translate="yes" xml:space="preserve">
          <source>In this example the LOAD statement includes a schema definition for simple data types.</source>
          <target state="translated">이 예에서 LOAD 문에는 단순 데이터 유형에 대한 스키마 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1685e1972a2735b748823663c7d18cc3169868" translate="yes" xml:space="preserve">
          <source>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</source>
          <target state="translated">이 예에서 ORDER 연산자는 튜플을 주문하는 데 사용되고 LIMIT 연산자는 처음 세 튜플을 출력하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d46d714daa065ac64bf616b27d931b45616989ad" translate="yes" xml:space="preserve">
          <source>In this example the asterisk (*) is used to project all fields from relation A to relation X. Relation A and X are identical.</source>
          <target state="translated">이 예에서 별표 (*)는 관계 A에서 관계 X까지 모든 필드를 투영하는 데 사용됩니다. 관계 A와 X는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f747b7eff53d66ec54b4dcd3a59958f8f656a8bc" translate="yes" xml:space="preserve">
          <source>In this example the average GPA for each student is computed (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">이 예에서는 각 학생의 평균 GPA가 계산됩니다 ( 관계 B의 필드 이름에 대한 정보 는 &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; 연산자 참조 ).</target>
        </trans-unit>
        <trans-unit id="ce3f8dbd72e1ca5670215036e9a44f0b071ca7c3" translate="yes" xml:space="preserve">
          <source>In this example the bincond operator is used with fields f2 and B. The condition is &quot;f2 equals 1&quot;; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</source>
          <target state="translated">이 예제에서 bincond 연산자는 필드 f2 및 B와 함께 사용됩니다. 조건은 &quot;f2 equals 1&quot;입니다. 조건이 true이면 1을 리턴하십시오. 조건이 거짓이면 B의 튜플 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6aaa13edf7e147edb799d5432c00b145a2899bd3" translate="yes" xml:space="preserve">
          <source>In this example the built in function SUM() is used to sum a set of numbers in a bag.</source>
          <target state="translated">이 예에서는 내장 함수 SUM ()을 사용하여 백의 숫자 세트를 합산합니다.</target>
        </trans-unit>
        <trans-unit id="f0ad9fb42b25648f0ae623cc3fafcfffe7daac86" translate="yes" xml:space="preserve">
          <source>In this example the case operator is used with field f2. The expression is &quot;f2 % 2&quot;; if the expression is equal to 0, return 'even'; if the expression is equal to 1, return 'odd'.</source>
          <target state="translated">이 예제에서 케이스 연산자는 필드 f2와 함께 사용됩니다. 표현은 &quot;f2 % 2&quot;이고; 식이 0이면 'even'을 반환합니다. 식이 1이면 'odd'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="092f4e5a8bef8cb9851796d251a7997b165bdd80" translate="yes" xml:space="preserve">
          <source>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped.</source>
          <target state="translated">이 예에서 문자 (이 경우 Joe의 URL)는 작은 따옴표 나 큰 따옴표로 묶을 수 있으며 문자 시퀀스 내의 따옴표를 이스케이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede799c3bc9b3029dc9c8360cd04456907800fde" translate="yes" xml:space="preserve">
          <source>In this example the clear command clean up Pig grunt shell.</source>
          <target state="translated">이 예에서 clear 명령은 Pig grunt shell을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="25d6ee41375a393d7a680688e835a625f56d5bef" translate="yes" xml:space="preserve">
          <source>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</source>
          <target state="translated">이 예에서 명령은 백 틱으로 묶여 있습니다. 먼저, 선언문이 발견되면 매개 변수 mycmd 및 date가 대체됩니다. 그런 다음 결과 명령이 실행되고로드 명령문이 실행되기 전에 해당 stdout이 경로에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b89b66c6c88049c686630255f175fff0f626bdcf" translate="yes" xml:space="preserve">
          <source>In this example the command is executed and its stdout is used as the parameter value.</source>
          <target state="translated">이 예제에서 명령이 실행되고 해당 stdout이 매개 변수 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce0f2c976b3fe8e4f40f38c3029dab1eb1cec85" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</source>
          <target state="translated">이 예에서 조건은 첫 번째 필드가 8과 같거나 필드 f2와 f3의 합이 첫 번째 필드보다 크지 않으면 튜플 관계 X를 포함한다는 조건입니다.</target>
        </trans-unit>
        <trans-unit id="26b224c7415697f3852d73862430dd9075adbd5f" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</source>
          <target state="translated">이 예에서 조건은 세 번째 필드가 3이면 튜플을 관계 X와 함께 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d1025ef014af40aa64437028c4999384b00c45c4" translate="yes" xml:space="preserve">
          <source>In this example the cross product of relation A and B is computed.</source>
          <target state="translated">이 예에서 관계 A와 B의 교차 곱이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="acbe209f9e9a1e61b98b326bbd67ec1907b268ea" translate="yes" xml:space="preserve">
          <source>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</source>
          <target state="translated">이 예제에서 데이터 파일은 튜플을 포함합니다. 복잡한 데이터 유형 (이 경우 튜플)에 대한 스키마가 데이터를로드하는 데 사용됩니다. 그런 다음 역 참조 연산자 (t1.t1a 및 t2. $ 0의 점)를 사용하여 튜플의 필드에 액세스합니다. 필드에 이름을 지정할 때 여전히 위치 표기법을 사용하여 이러한 필드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4e82302c1dcf3cf245b321e2f2024b324f3f18" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped and ordered.</source>
          <target state="translated">이 예에서 데이터는 그룹화되고 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="d6c450e1b8e75a80b634b42feb0e20c5b019d350" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped.</source>
          <target state="translated">이 예에서는 데이터가 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="cb28ee9adf8539445368e3a7354c61897a47de43" translate="yes" xml:space="preserve">
          <source>In this example the data is unordered.</source>
          <target state="translated">이 예에서는 데이터가 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6603ac59abe4e83a9f3630ed1514e5ee65f95568" translate="yes" xml:space="preserve">
          <source>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray.</source>
          <target state="translated">이 예에서 기본로드 함수 인 PigStorage는 myfile.txt에서 데이터를로드하여 관계 A를 형성합니다. 두 개의 LOAD 문은 동일합니다. 스키마가 지정되지 않았기 때문에 필드 이름이 지정되지 않고 모든 필드는 기본적으로 bytearray 유형입니다.</target>
        </trans-unit>
        <trans-unit id="eb0d387430982dda1c08cffe6bc594f972418231" translate="yes" xml:space="preserve">
          <source>In this example the history command shows all the statements with line numbers and without them.</source>
          <target state="translated">이 예에서 history 명령은 줄 번호가 있거나없는 모든 명령문을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="476af286c3ec71967ab312182ce2b62adf926b94" translate="yes" xml:space="preserve">
          <source>In this example the job with id job_0001 is killed.</source>
          <target state="translated">이 예에서는 id가 job_0001 인 작업이 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b029e1c370efb6daa4ba5eb4f901c821a93416f8" translate="yes" xml:space="preserve">
          <source>In this example the limit is expressed as a scalar.</source>
          <target state="translated">이 예에서 한계는 스칼라로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e34eec81ca9c49c22acf02db69215d8d4e34e78" translate="yes" xml:space="preserve">
          <source>In this example the ls command is invoked.</source>
          <target state="translated">이 예에서 ls 명령이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="76f374ece7dcad13158f830af8da60b38d97b189" translate="yes" xml:space="preserve">
          <source>In this example the macro does not have a return alias; thus, void must be specified.</source>
          <target state="translated">이 예에서 매크로에는 반환 별칭이 없습니다. 따라서 void를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd64ffc9b96611ae3793e3e5ba859e7d36b80811" translate="yes" xml:space="preserve">
          <source>In this example the macro is named my_macro. Note that only aliases A and C are visible from the outside; alias B is not visible from the outside.</source>
          <target state="translated">이 예제에서 매크로 이름은 my_macro입니다. 별명 A와 C 만 외부에서 볼 수 있습니다. 별칭 B는 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6404afa0a6b34470610936e43c5cf53ae1ed10be" translate="yes" xml:space="preserve">
          <source>In this example the map includes two key value pairs.</source>
          <target state="translated">이 예에서 맵에는 두 개의 키 값 쌍이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1711a19cfa3302a682910d13c83d53af9d0f1b78" translate="yes" xml:space="preserve">
          <source>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">이 예에서는 모든 학생의 최대 GPA가 각 학생에 대해 계산됩니다 (관계 B의 필드 이름에 대한 정보는 GROUP 연산자 참조).</target>
        </trans-unit>
        <trans-unit id="9d880bfbdf389fd36ac97f66b734bd7cf322568a" translate="yes" xml:space="preserve">
          <source>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">이 예에서 모든 학생에 대한 최소 GPA는 각 학생마다 계산됩니다 (관계 B의 필드 이름에 대한 정보는 GROUP 연산자 참조).</target>
        </trans-unit>
        <trans-unit id="6f6938263aa57a2bb9d2caa685487136b07bb471" translate="yes" xml:space="preserve">
          <source>In this example the modulo operator is used with fields f1 and f2.</source>
          <target state="translated">이 예제에서 모듈로 연산자는 필드 f1 및 f2와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9587d64b9e55a467c8f05370b86a5919538e4e78" translate="yes" xml:space="preserve">
          <source>In this example the number of characters in the first field is computed.</source>
          <target state="translated">이 예에서는 첫 번째 필드의 문자 수가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1b286a09468d93c61174ef82f5d5ce20e0200311" translate="yes" xml:space="preserve">
          <source>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">이 예에서는 애완 동물의 수가 계산됩니다. B의 필드 이름에 대한 정보는 GROUP 연산자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1317fabb77110a5157dbf3c1989811a052d00d38" translate="yes" xml:space="preserve">
          <source>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</source>
          <target state="translated">이 예에서 매개 변수 (DATE) 및 값 ( '20090101')은 기본 명령문을 사용하여 Pig 스크립트에 지정됩니다. 다른 곳에 DATE 값을 지정하지 않으면 기본값 20090101이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e98bd8685b77fd467a6fbb1af6b37b502f7b21e" translate="yes" xml:space="preserve">
          <source>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</source>
          <target state="translated">이 예제에서 매개 변수 (data) 및 매개 변수 값 (mydata)은 명령 행에 지정됩니다. 명령 행 (data)의 매개 변수 이름과 스크립트 ($ data)의 매개 변수 이름이 일치하지 않으면 스크립트가 실행되지 않습니다. 매개 변수 값 (mydata)을 찾을 수 없으면 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed4d9d9c3e64f1c8ed8531ebff8cca25da2370b" translate="yes" xml:space="preserve">
          <source>In this example the parameters and values are passed to the script using the parameter file.</source>
          <target state="translated">이 예제에서 매개 변수 및 값은 매개 변수 파일을 사용하여 스크립트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b2909b057f9a09ca537aaf439edc1877ad06cf" translate="yes" xml:space="preserve">
          <source>In this example the percentage of clicks belonging to a particular user are computed. For the FOREACH statement, an explicit cast is used. If the SUM is not given a name, a position can be used as well (userid, clicks/(double)C.$0).</source>
          <target state="translated">이 예에서는 특정 사용자에 속하는 클릭의 비율이 계산됩니다. FOREACH 문에는 명시 적 캐스트가 사용됩니다. SUM에 이름이 없으면 위치도 사용할 수 있습니다 (사용자 ID, 클릭 / (더블) C. $ 0).</target>
        </trans-unit>
        <trans-unit id="d4aff9a2fd5846372e7438a9400d514b26787e3a" translate="yes" xml:space="preserve">
          <source>In this example the quit command exits the Pig grunt shall.</source>
          <target state="translated">이 예에서 quit 명령은 Pig grunt를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2d4709cf6d5853667a759dfa1d106eed84020b7e" translate="yes" xml:space="preserve">
          <source>In this example the same data is loaded twice using aliases A and B.</source>
          <target state="translated">이 예에서는 별칭 A와 B를 사용하여 동일한 데이터가 두 번로드됩니다.</target>
        </trans-unit>
        <trans-unit id="fc5789de4d75cad94be41c5facecc34fe4971feb" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a bag. The two load statements are equivalent.</source>
          <target state="translated">이 예에서 스키마는 백을 정의합니다. 두로드 문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8755ba412043fe803f3282f9a04a78a7dee177a3" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a tuple, bag, and map.</source>
          <target state="translated">이 예에서 스키마는 튜플, 백 및 맵을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7cd7118a92ca87fa2d331c8470cf4842dff265de" translate="yes" xml:space="preserve">
          <source>In this example the schema defines an untyped map (the map values default to bytearray). The load statements are equivalent.</source>
          <target state="translated">이 예제에서 스키마는 유형이 지정되지 않은 맵을 정의합니다 (맵 값은 기본적으로 bytearray입니다). 로드 문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5cd0cb1fc97ce5841696cd76163b3e5eb768aca1" translate="yes" xml:space="preserve">
          <source>In this example the schema defines multiple types.</source>
          <target state="translated">이 예에서 스키마는 여러 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="82f2e4223d2166be4de020826791e51ada52b60a" translate="yes" xml:space="preserve">
          <source>In this example the schema defines one tuple. The load statements are equivalent.</source>
          <target state="translated">이 예에서 스키마는 하나의 튜플을 정의합니다. 로드 문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bf67db086de69e41eae0849cf525acbd64482062" translate="yes" xml:space="preserve">
          <source>In this example the schema defines two tuples.</source>
          <target state="translated">이 예에서 스키마는 두 개의 튜플을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="374e1d1c9089f64e9a3f6e17445b7108876892bc" translate="yes" xml:space="preserve">
          <source>In this example the script interacts with the results of commands issued via the Grunt shell.</source>
          <target state="translated">이 예제에서 스크립트는 Grunt 쉘을 통해 실행 된 명령 결과와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="99317ecfb2f2d2f8e22397ef775944c5ef25b329" translate="yes" xml:space="preserve">
          <source>In this example the script is displayed and run.</source>
          <target state="translated">이 예에서는 스크립트가 표시되고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2e598eccd5a601dd744d347f16c97195afdc76a1" translate="yes" xml:space="preserve">
          <source>In this example the streaming stderr is stored in the _logs/&amp;lt;dir&amp;gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</source>
          <target state="translated">이 예제에서 스트리밍 stderr은 작업 출력 디렉토리의 _logs / &amp;lt;dir&amp;gt; 디렉토리에 저장됩니다. 작업에 연관된 스트리밍 응용 프로그램이 여러 개있을 수 있으므로 충돌을 피하기 위해 다른 디렉토리 이름을 사용해야합니다. Pig는 스트리밍 작업 당 최대 100 개의 작업을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="12004346bfe8b9058047ed1fff89d8df9e7971b7" translate="yes" xml:space="preserve">
          <source>In this example the strings in each row are split.</source>
          <target state="translated">이 예에서는 각 행의 문자열이 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca70fcce90aa1c6cf4766d1a9176002ded5188b" translate="yes" xml:space="preserve">
          <source>In this example the top 10 occurrences are returned.</source>
          <target state="translated">이 예에서는 상위 10 개의 발생이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="021afd1412e5a5955bb3fb59bfd3c0a85c063129" translate="yes" xml:space="preserve">
          <source>In this example the tuple contains three fields.</source>
          <target state="translated">이 예제에서 튜플에는 세 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f597683856676d8bafb6405513e3ebe7baf66915" translate="yes" xml:space="preserve">
          <source>In this example the tuples are grouped using an expression, f2*f3.</source>
          <target state="translated">이 예제에서 튜플은 f2 * f3 표현식을 사용하여 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="5e310234a9bc1536d78449f454a40dbd0fea419f" translate="yes" xml:space="preserve">
          <source>In this example the tuples in the bag are counted (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">이 예제에서 백의 튜플이 계산됩니다 ( 관계 B의 필드 이름에 대한 정보 는 &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; 연산자 참조 ).</target>
        </trans-unit>
        <trans-unit id="c431411d674fcbd3d4993f3b148f0ab1fd9627c8" translate="yes" xml:space="preserve">
          <source>In this example the union of relation A and B is computed.</source>
          <target state="translated">이 예에서는 관계 A와 B의 합집합이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9b64e41ad4836645b8177be3ac9c0030fd0d8b" translate="yes" xml:space="preserve">
          <source>In this example tuples are co-grouped using field &amp;ldquo;owner&amp;rdquo; from relation A and field &amp;ldquo;friend2&amp;rdquo; from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has three fields, &quot;group&quot;, &quot;A&quot; and &quot;B&quot; (see the GROUP operator for information about the field names).</source>
          <target state="translated">이 예에서 튜플은 관계 A의 &quot;owner&quot;필드와 관계 B의 &quot;friend2&quot;필드를 키 필드로 사용하여 공동 그룹화됩니다. DESCRIBE 연산자는 &quot;group&quot;, &quot;A&quot;및 &quot;B&quot;라는 세 개의 필드가있는 관계 X에 대한 스키마를 표시합니다 (필드 이름에 대한 정보는 GROUP 연산자 참조).</target>
        </trans-unit>
        <trans-unit id="dde4ecc1f27426000ba5fe853e50128821f2f398" translate="yes" xml:space="preserve">
          <source>In this example two fields from relation A are projected to form relation X.</source>
          <target state="translated">이 예에서는 관계 A의 두 필드가 관계 X를 형성하도록 투영됩니다.</target>
        </trans-unit>
        <trans-unit id="bc47fb195353fb6458455bd7a9f15093c04fb95c" translate="yes" xml:space="preserve">
          <source>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</source>
          <target state="translated">이 예에서는 관계 A의 두 필드가 합쳐져 ​​관계 X를 형성합니다. 스키마는 투영 된 필드에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="374e1a3a44b5c072bbee353fcde0ae6d5ba08c31" translate="yes" xml:space="preserve">
          <source>In this example user defined serialization/deserialization functions are used with the script.</source>
          <target state="translated">이 예제에서는 사용자 정의 직렬화 / 직렬화 기능이 스크립트와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1a5311dceb63c974e9b2cfc727be221f3bb244" translate="yes" xml:space="preserve">
          <source>In this example we filter out ID 4 and 6.</source>
          <target state="translated">이 예에서는 ID 4와 6을 걸러냅니다.</target>
        </trans-unit>
        <trans-unit id="12cea5022f6e359ede64a2f3cade86cdf43e9f89" translate="yes" xml:space="preserve">
          <source>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE. Also, note the use of projection (PA = FA.outlink;) to retrieve a field. DISTINCT can be applied to a subset of fields (as opposed to a relation) only within a nested block.</source>
          <target state="translated">이 예에서는 중첩 블록에서 허용되는 두 가지 작업 인 FILTER 및 DISTINCT를 수행합니다. 중첩 된 블록의 마지막 명령문은 GENERATE 여야합니다. 또한 프로젝션 (PA = FA.outlink;)을 사용하여 필드를 검색하십시오. DISTINCT는 중첩 된 블록 내에서만 필드의 하위 집합 (관계가 아닌)에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa386fd96cd26dfb68e71c6977b54eb2ca55f776" translate="yes" xml:space="preserve">
          <source>In this example, Pig will validate and then execute the LOAD, FOREACH, and DUMP statements.</source>
          <target state="translated">이 예에서 Pig는 LOAD, FOREACH 및 DUMP 문을 유효성 검증 한 후 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d4558a0e1b18bdd5eee2ed93dafa87c2da9e505c" translate="yes" xml:space="preserve">
          <source>In this example, PigStorage loads data with complex data type, a bag of map and double.</source>
          <target state="translated">이 예에서 PigStorage는 복잡한 데이터 유형, 맵 백 및 이중으로 데이터를로드합니다.</target>
        </trans-unit>
        <trans-unit id="b9f6baa8723253b0ff5da6f6200823682a8e7924" translate="yes" xml:space="preserve">
          <source>In this example, SUBTRACT creates a new bag composed of B1 elements that are not in B2.</source>
          <target state="translated">이 예에서 SUBTRACT는 B2에없는 B1 요소로 구성된 새 백을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="628bdb7c844633083f052de93a85c78a122db14c" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with one field is converted to a tuple.</source>
          <target state="translated">이 예에서, 하나의 필드를 가진 튜플을 포함하는 백은 튜플로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="31ad0d826c111e02076048c8e848b2bc5512a7f5" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with two fields is converted to a tuple.</source>
          <target state="translated">이 예에서 두 개의 필드가있는 튜플이 포함 된 백은 튜플로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba1ab45b8d5e801bda851513ebce706791389a2" translate="yes" xml:space="preserve">
          <source>In this example, a scalar expression is used (it will sample approximately 1000 records from the input).</source>
          <target state="translated">이 예에서는 스칼라식이 사용됩니다 (입력에서 약 1000 개의 레코드를 샘플링합니다).</target>
        </trans-unit>
        <trans-unit id="0c050f08cf94a0faf1569c2cd017c23c7029793b" translate="yes" xml:space="preserve">
          <source>In this example, because a path is not given, Pig will use the import path specified in pig.import.search.path.</source>
          <target state="translated">이 예에서는 경로가 제공되지 않기 때문에 Pig는 pig.import.search.path에 지정된 가져 오기 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8d18d2738156bb9536be2726da1b0055af29572" translate="yes" xml:space="preserve">
          <source>In this example, fields f1 and f3 are converted to tuples that are then placed in a bag.</source>
          <target state="translated">이 예제에서 필드 f1 및 f3은 튜플로 변환 된 다음 백에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8b5550925189ae7bf57a03a71682900e5449f00f" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, an underscore string literal, f2 and f3 are concatenated.</source>
          <target state="translated">이 예에서는 밑줄 문자열 리터럴 인 필드 f1, f2 및 f3이 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab2c3d36b021dc631caeb2e9d192769dc62ae3c" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, f2 and f3 are converted to a tuple.</source>
          <target state="translated">이 예에서, 필드 f1, f2 및 f3은 튜플로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7924a4aff410ec62e1625fb749420c25e9e40967" translate="yes" xml:space="preserve">
          <source>In this example, parameters passed to run/exec command or declared within the called scripts are not visible to the caller.</source>
          <target state="translated">이 예에서 run / exec 명령으로 전달되거나 호출 된 스크립트 내에 선언 된 매개 변수는 호출자에게 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bb04af80246e86e73ab32302c82691b112dec27" translate="yes" xml:space="preserve">
          <source>In this example, student names (type chararray) and student GPAs (type float) are used to create three maps.</source>
          <target state="translated">이 예에서는 학생 이름 (유형 chararray)과 학생 GPA (유형 float)를 사용하여 세 개의 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e7bb96091fb633aa0dd9a62cf0641bf708fbda94" translate="yes" xml:space="preserve">
          <source>In this example, the CONCAT function is used to format the data before it is stored.</source>
          <target state="translated">이 예에서 CONCAT 함수는 데이터를 저장하기 전에 데이터를 형식화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="067351e08e674c5bf43312d16f3cfc906bf4efea" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator does not change the order of the relation and simply prepends to each tuple a sequential value.</source>
          <target state="translated">이 예에서 RANK 연산자는 관계 순서를 변경하지 않고 단순히 각 튜플에 순차적 인 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f697de11b6e8be82a227e004decddf6bf4447be5" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator works with f1 and f2 fields, and each one with different sorting order. RANK sorts the relation on these fields and prepends the rank value to each tuple. Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">이 예에서 RANK 연산자는 f1 및 f2 필드 및 각각 다른 정렬 순서로 작업합니다. RANK는 이러한 필드의 관계를 정렬하고 순위 값을 각 튜플 앞에 추가합니다. 그렇지 않으면 RANK 연산자는 각 필드 (또는 필드 세트)를 사용하여 관계를 정렬합니다. 튜플의 순위는 1에 다른 순위 값의 수를 더한 값입니다. 둘 이상의 튜플이 정렬 필드 값에 연결되면 동일한 순위를받습니다.</target>
        </trans-unit>
        <trans-unit id="1f3b4221a79d008988b7876075995e6b8d7835e6" translate="yes" xml:space="preserve">
          <source>In this example, the SPLIT and FILTER statements are essentially equivalent. However, because SPLIT is implemented as &quot;split the data stream and then apply filters&quot; the SPLIT statement is more expensive than the FILTER statement because Pig needs to filter and store two data streams.</source>
          <target state="translated">이 예에서 SPLIT 및 FILTER 문은 본질적으로 동일합니다. 그러나 SPLIT는 &quot;데이터 스트림 분할 후 필터 적용&quot;으로 구현되므로 Pig는 두 개의 데이터 스트림을 필터링하고 저장해야하므로 SPLIT 문은 FILTER 문보다 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="14d08384e4aaff3f8be0a78561d22848f60f1375" translate="yes" xml:space="preserve">
          <source>In this example, the function gets one parameter of type float and another of type double. The best fit will be the function that takes two double values. Pig makes this choice on the user's behalf by inserting implicit casts for the parameters. Running the script above is equivalent to running the script below:</source>
          <target state="translated">이 예제에서 함수는 float 유형의 매개 변수 하나와 double 유형의 매개 변수 하나를 가져옵니다. 가장 적합한 것은 두 개의 이중 값을 취하는 함수입니다. Pig는 매개 변수에 대한 내재 된 캐스트를 삽입하여 사용자 대신이 선택을합니다. 위의 스크립트를 실행하는 것은 아래의 스크립트를 실행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="881155eba58f9e850386857207058c2bcc0dde01" translate="yes" xml:space="preserve">
          <source>In this example, the negation operator is applied to the &quot;x&quot; values.</source>
          <target state="translated">이 예에서 부정 연산자는 &quot;x&quot;값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed1b3ee3654de3cdf2209317bbe036a32a65e1c9" translate="yes" xml:space="preserve">
          <source>In this example, to disambiguate y, use A::y or B::y. In cases where there is no ambiguity, such as z, the :: is not necessary but is still supported.</source>
          <target state="translated">이 예에서 y를 명확하게하려면 A :: y 또는 B :: y를 사용하십시오. z와 같이 모호성이없는 경우 ::는 필요하지 않지만 여전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0224a2baaf9cd9707e2e7cf53337aeaeaf373da6" translate="yes" xml:space="preserve">
          <source>In this example, values that are not null are obtained.</source>
          <target state="translated">이 예에서는 null이 아닌 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6e4679058adb8da48ed2faf2b2035bd49505dbe0" translate="yes" xml:space="preserve">
          <source>In this example, we pass (null, &quot;names.txt&quot;) to the construct of UDF in_file, meaning the first parameter is regular, the second parameter is a constant. names.txt can be double quoted (unlike other Pig syntax), or quoted in \'. Note we need to pass 'names.txt' again in line 3. This looks stupid but we need to do this to fill the semantic gap between Pig and Hive. We need to pass the constant in the data pipeline in line 3, which is similar Pig UDF. Initialization code in Hive UDF takes ObjectInspector, which capture the data type and whether or not the parameter is a constant. However, initialization code in Pig takes schema, which only capture the former. We need to use additional mechanism (construct parameter) to convey the later.</source>
          <target state="translated">이 예에서, (null, &quot;names.txt&quot;)를 UDF in_file의 구조에 전달합니다. 즉, 첫 번째 매개 변수는 규칙적이고 두 번째 매개 변수는 상수입니다. names.txt는 다른 Pig 구문과 달리 큰 따옴표로 묶거나 \ '로 따옴표로 묶을 수 있습니다. 3 번 줄에서 'names.txt'를 다시 전달해야합니다. 어리석은 것처럼 보이지만 Pig와 Hive 사이의 시맨틱 갭을 채우기 위해이 작업을 수행해야합니다. 우리는 라인 3의 데이터 파이프 라인에서 상수를 전달해야합니다. 이는 돼지 UDF와 유사합니다. Hive UDF의 초기화 코드는 ObjectInspector를 사용하여 데이터 유형과 매개 변수가 상수인지 여부를 캡처합니다. 그러나 Pig의 초기화 코드는 스키마 만 사용하며 이전 코드 만 캡처합니다. 나중에 전달하려면 추가 메커니즘 (구문 매개 변수)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c2dcd3fec58a0ebe5b61ce427c75e4270cee26f" translate="yes" xml:space="preserve">
          <source>In this example, we're passing a BigInteger and using NOT operator, thereby negating the passed list of fields in the IN clause</source>
          <target state="translated">이 예에서는 BigInteger를 전달하고 NOT 연산자를 사용하여 IN 절에서 전달 된 필드 목록을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8ac1c53434de8d305b7f189975c25cebec6a49b" translate="yes" xml:space="preserve">
          <source>In this script, MYUDF might try to read from out1, a file that A was just stored into. However, Pig does not know that MYUDF depends on the out1 file and might submit the jobs producing the out2 and out1 files at the same time.</source>
          <target state="translated">이 스크립트에서 MYUDF는 A가 방금 저장된 파일 인 out1에서 읽으려고 시도 할 수 있습니다. 그러나 Pig는 MYUDF가 out1 파일에 의존하고 out2 및 out1 파일을 생성하는 작업을 동시에 제출할 수 있음을 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="eaeebfe1f5eff1ee401092bdf4bfaa13b02e1352" translate="yes" xml:space="preserve">
          <source>In this script, the STORE/LOAD operators have different file paths; however, the LOAD operator depends on the STORE operator.</source>
          <target state="translated">이 스크립트에서 STORE / LOAD 연산자는 다른 파일 경로를 갖습니다. 그러나 LOAD 연산자는 STORE 연산자에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="388a7f3ab68e1015ed7e6c293c2ff263c2a3d0ea" translate="yes" xml:space="preserve">
          <source>Increase the parallelism of a job by specifying the number of reduce tasks, n.</source>
          <target state="translated">축소 작업 수를 지정하여 작업의 병렬 처리를 증가시킵니다. n.</target>
        </trans-unit>
        <trans-unit id="e9a90a62d3ab8cd810db61a4caae391f73d2d675" translate="yes" xml:space="preserve">
          <source>Inner merge join (between two tables) will only work under these conditions:</source>
          <target state="translated">내부 병합 조인 (두 테이블 간)은 다음 조건에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="03a548863c266dc43de099b2b4dcd58730363f30" translate="yes" xml:space="preserve">
          <source>InputStats</source>
          <target state="translated">InputStats</target>
        </trans-unit>
        <trans-unit id="a881c6dfaceae2347739afd1176127808734fa29" translate="yes" xml:space="preserve">
          <source>Inside your script, you can define parameters and then pass parameters from command line to your script. There are two ways to pass parameters to your script:</source>
          <target state="translated">스크립트 내에서 매개 변수를 정의한 후 명령 행에서 스크립트로 매개 변수를 전달할 수 있습니다. 스크립트에 매개 변수를 전달하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38ec86271222cf540ae29ce6fdce3cf0bb0bdae" translate="yes" xml:space="preserve">
          <source>Instead of figuring out the dependencies manually, downloading them and registering each jar using the above &lt;a href=&quot;#register-jar&quot;&gt;register command&lt;/a&gt;, you can specify the artifact's coordinates and expect pig to automatically fetch the required dependencies, download and register them.</source>
          <target state="translated">종속성을 수동으로 파악하고 다운로드하고 위의 &lt;a href=&quot;#register-jar&quot;&gt;register 명령을&lt;/a&gt; 사용하여 각 jar을 등록하는 대신 아티팩트의 좌표를 지정하고 pig이 필요한 종속성을 자동으로 가져 와서 다운로드하여 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e225003256a2a1b59e6d92b0617521bd13c8e2" translate="yes" xml:space="preserve">
          <source>Instead use ToString to format the date/time portions and SPRINTF to layout the results.</source>
          <target state="translated">대신 ToString을 사용하여 날짜 / 시간 부분을 형식화하고 SPRINTF를 사용하여 결과를 레이아웃하십시오.</target>
        </trans-unit>
        <trans-unit id="4cf0450c6e840f4cdcb5c3195b6b05d10c9d0ad9" translate="yes" xml:space="preserve">
          <source>Instead, assemble it in pieces. In step 2, we sort on one field but process another; it remains in the sorted order.</source>
          <target state="translated">대신 조각으로 조립하십시오. 2 단계에서는 한 필드를 기준으로 정렬하지만 다른 필드를 처리합니다. 정렬 된 순서대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="94dc8e4a59fafe99eded0ffa98b6e8ea00efeca7" translate="yes" xml:space="preserve">
          <source>Interaction</source>
          <target state="translated">Interaction</target>
        </trans-unit>
        <trans-unit id="af3758608388b05871589b2b19e12008ace4a0d4" translate="yes" xml:space="preserve">
          <source>Interactive Mode</source>
          <target state="translated">대화식 모드</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="048850efc4e3902868045111cefcac3a0e527ce7" translate="yes" xml:space="preserve">
          <source>Invalid identifiers:</source>
          <target state="translated">잘못된 식별자 :</target>
        </trans-unit>
        <trans-unit id="888bb77151bd6eaba885bae449bb376eb7118989" translate="yes" xml:space="preserve">
          <source>Invocation Basics</source>
          <target state="translated">호출 기초</target>
        </trans-unit>
        <trans-unit id="b747cea14bf58e7def2e01119aae868ffb489ab7" translate="yes" xml:space="preserve">
          <source>Invocation Details</source>
          <target state="translated">호출 세부 사항</target>
        </trans-unit>
        <trans-unit id="cb31f6339e723fd50bd0157d6fe131b36204092b" translate="yes" xml:space="preserve">
          <source>Invokes any FsShell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">Pig 스크립트 또는 Grunt 쉘 내에서 FsShell 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="387341bd057cbb29666274908fe3359e6d22dd4f" translate="yes" xml:space="preserve">
          <source>Invokes any sh shell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">Pig 스크립트 또는 Grunt 쉘에서 sh 쉘 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="363a45b6f463769784d3f21486a12e29d0abf261" translate="yes" xml:space="preserve">
          <source>IsEmpty(expression)</source>
          <target state="translated">IsEmpty(expression)</target>
        </trans-unit>
        <trans-unit id="88de2259b3b3f72d4d9041583c92b54b45aa01e0" translate="yes" xml:space="preserve">
          <source>It is possible to enable a Hadoop job to request new tickets when they expire by creating a keytab file and make it part of the job that is running in the cluster. This will extend the maximum job duration beyond the maximum renew time of the kerberos tickets.</source>
          <target state="translated">키탭 파일을 작성하여 클러스터에서 실행중인 작업의 일부로 만들어 Hadoop 작업이 만료 될 때 새 티켓을 요청할 수 있습니다. 이는 kerberos 티켓의 최대 갱신 시간을 초과하여 최대 작업 기간을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="33cd6ef902f5caf739b2a2823cacab7fda072487" translate="yes" xml:space="preserve">
          <source>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</source>
          <target state="translated">클러스터 작업의 현재 작업 디렉토리에서 실행할 파일 만 제공하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d9433ba5a82fa587313360ad26116c0000526441" translate="yes" xml:space="preserve">
          <source>It is simple to fetch all columns from Airport codes that fall between Boston and San Francisco that can be viewed with 'auth1' and/or 'auth2' Accumulo authorizations.</source>
          <target state="translated">보스턴과 샌프란시스코 사이에있는 공항 코드에서 'auth1'및 ​​/ 또는 'auth2'Accumulo 인증으로 볼 수있는 모든 열을 가져 오는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="eb8f70933c32c8862ef0e315b9d3b91803410867" translate="yes" xml:space="preserve">
          <source>It is very important for performance to make sure that aggregate functions that are algebraic are implemented as such. Let's look at the implementation of the COUNT function to see what this means. (Error handling and some other code is omitted to save space. The full code can be accessed &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt; here&lt;/a&gt;.)</source>
          <target state="translated">대수적인 집계 함수가 그대로 구현되도록하려면 성능이 매우 중요합니다. 이것이 무엇을 의미하는지 COUNT 함수의 구현을 살펴 보자. 공간을 절약하기 위해 오류 처리 및 기타 코드가 생략되었습니다. 전체 코드는 &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt;여기에서&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27ef4d2a6cf1d08c5ea52e79fbc6638e458ce3ab" translate="yes" xml:space="preserve">
          <source>It's OK to supply too many, though</source>
          <target state="translated">너무 많이 공급해도 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="720a64aa2e384f654ad24f02483f843d4fa544c7" translate="yes" xml:space="preserve">
          <source>JOIN (inner)</source>
          <target state="translated">가입 (내부)</target>
        </trans-unit>
        <trans-unit id="10dbe28c733242b09a204b8afa7bda322c04edfb" translate="yes" xml:space="preserve">
          <source>JOIN (outer)</source>
          <target state="translated">가입 (외부)</target>
        </trans-unit>
        <trans-unit id="7d1cb24c2595ad4575c4ec6e01cbd73136b6732a" translate="yes" xml:space="preserve">
          <source>Jars required for user defined functions (UDFs) are copied to distributed cache by pig to make them available on task nodes. To put these jars on distributed cache, pig clients copy these jars to HDFS under a temporary location. For scheduled jobs, these jars do not change frequently. Also, creating a lot of small jar files on HDFS is not HDFS friendly. To avoid copying these small jar files to HDFS again and again, pig allows users to configure a user level jar cache (readable only to the user for security reasons). If pig.user.cache.enabled flag is set to true, UDF jars are copied to jar cache location (configurable) under a directory named with the hash (SHA) of the jar. Hash of the jar is used to identify the existence of the jar in subsequent uses of the jar by the user. If a jar with same hash and filename is found in the cache, it is used avoiding copy of the jar to hdfs.</source>
          <target state="translated">사용자 정의 함수 (UDF)에 필요한 jar은 작업 노드에서 사용할 수 있도록 pig에 의해 분산 캐시에 복사됩니다. 이러한 jar을 분산 캐시에두기 위해 pig 클라이언트는 이러한 jar을 임시 위치의 HDFS에 복사합니다. 예약 된 작업의 경우 이러한 항아리는 자주 변경되지 않습니다. 또한 HDFS에서 많은 작은 jar 파일을 만드는 것은 HDFS에 적합하지 않습니다. 이러한 작은 jar 파일을 HDFS에 반복해서 복사하는 것을 피하기 위해 pig에서는 사용자 수준의 jar 캐시를 구성 할 수 있습니다 (보안상의 이유로 사용자 만 읽을 수 있음). pig.user.cache.enabled 플래그가 true로 설정되면 UDF jar은 jar의 해시 (SHA)로 이름이 지정된 디렉토리에서 jar 캐시 위치 (구성 가능)로 복사됩니다. 항아리의 해시는 사용자가 항아리를 계속 사용할 때 항아리의 존재를 식별하는 데 사용됩니다. 캐시에 동일한 해시 및 파일 이름을 가진 jar이 있으면jar를 hdfs에 복사하지 않고 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95430344cb2583fdd1f91fe40b6a426c6cdb7d10" translate="yes" xml:space="preserve">
          <source>Java API</source>
          <target state="translated">자바 API</target>
        </trans-unit>
        <trans-unit id="220874040658928dfd28599011834e1d343f6a06" translate="yes" xml:space="preserve">
          <source>Java BigDecimal</source>
          <target state="translated">자바 BigDecimal</target>
        </trans-unit>
        <trans-unit id="08f070a244c3d5ae1d6e726845ba3cf27ed3a4ee" translate="yes" xml:space="preserve">
          <source>Java BigInteger</source>
          <target state="translated">자바 BigInteger</target>
        </trans-unit>
        <trans-unit id="8c689b2df07d5ac7a956c5d5f96beb6beed619e6" translate="yes" xml:space="preserve">
          <source>Java Class</source>
          <target state="translated">자바 클래스</target>
        </trans-unit>
        <trans-unit id="ecdb578d70bdad641779bb3cf2409b8a930d4cc0" translate="yes" xml:space="preserve">
          <source>Java Objects</source>
          <target state="translated">자바 객체</target>
        </trans-unit>
        <trans-unit id="4e2d7efd6e5d57f9e2fd04c772bf368801395eaf" translate="yes" xml:space="preserve">
          <source>Java Test</source>
          <target state="translated">자바 테스트</target>
        </trans-unit>
        <trans-unit id="c016599191077ac21a20ca4a9937da89712a611b" translate="yes" xml:space="preserve">
          <source>Java UDFs can be invoked multiple ways. The simplest UDF can just extend EvalFunc, which requires only the exec function to be implemented (see &lt;a href=&quot;#eval-functions-write&quot;&gt; How to Write a Simple Eval Function&lt;/a&gt;). Every eval UDF must implement this. Additionally, if a function is algebraic, it can implement Algebraic interface to significantly improve query performance in the cases when combiner can be used (see &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;). Finally, a function that can process tuples in an incremental fashion can also implement the Accumulator interface to improve query memory consumption (see &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;).</source>
          <target state="translated">Java UDF는 여러 가지 방법으로 호출 할 수 있습니다. 가장 간단한 UDF는 EvalFunc를 확장 할 수 있으며 exec 함수 만 구현하면됩니다 ( &lt;a href=&quot;#eval-functions-write&quot;&gt;간단한 평가 함수 작성 방법&lt;/a&gt; 참조 ). 모든 eval UDF는 이것을 구현해야합니다. 또한 함수가 대수 인 경우 결합기를 사용할 수있는 경우 쿼리 성능을 크게 향상시키기 위해 대수 인터페이스를 구현할 수 있습니다 ( &lt;a href=&quot;#algebraic-interface&quot;&gt;대수 인터페이스&lt;/a&gt; 참조 ). 마지막으로 튜플을 증분 방식으로 처리 할 수있는 기능은 쿼리 메모리 소비를 향상시키기 위해 Accumulator 인터페이스를 구현할 수도 있습니다 ( &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator 인터페이스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d5889044826a763834c9c012a37f5c86407ecc85" translate="yes" xml:space="preserve">
          <source>Job XML</source>
          <target state="translated">직업 XML</target>
        </trans-unit>
        <trans-unit id="6cc61673b0dee9980ed3e68bb162982c295dc41b" translate="yes" xml:space="preserve">
          <source>JobStats</source>
          <target state="translated">JobStats</target>
        </trans-unit>
        <trans-unit id="5753a498f025464d72e088a9d5d6e872592d5f91" translate="yes" xml:space="preserve">
          <source>John</source>
          <target state="translated">John</target>
        </trans-unit>
        <trans-unit id="13b0d0b8d9cc13668684c1e4def8925fe90d5929" translate="yes" xml:space="preserve">
          <source>JsonLoader( ['schema'] )</source>
          <target state="translated">JsonLoader ([ '스키마'])</target>
        </trans-unit>
        <trans-unit id="8ecc1bbc9be4c62ea582a64bff9ee07d59799f5d" translate="yes" xml:space="preserve">
          <source>JsonLoader, JsonStorage</source>
          <target state="translated">JsonLoader, JsonStorage</target>
        </trans-unit>
        <trans-unit id="606d2a58b14210dd67ff5015b481adddb0d11fcd" translate="yes" xml:space="preserve">
          <source>JsonStorage( )</source>
          <target state="translated">JsonStorage ()</target>
        </trans-unit>
        <trans-unit id="4f52e476a57f572278206a16e11c4378156dad2a" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt;, Java UDF has a getLoadCaster() method that returns &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; to convert byte arrays to specific types. A UDf implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported. Default implementation returns null and Pig will determine if all parameters passed to the UDF have identical loadcaster and use it when true.</source>
          <target state="translated">&lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt; 과 마찬가지로 Java UDF에는 바이트 배열을 특정 유형으로 변환하기 위해 &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; 를 리턴하는 getLoadCaster () 메소드가 있습니다. UDf 구현은 DataByteArray 필드에서 다른 유형으로의 캐스트 (내재적 또는 명시 적)가 지원되어야하는 경우이를 구현해야합니다. 기본 구현은 null을 반환하고 Pig는 UDF에 전달 된 모든 매개 변수가 동일한로드 캐스터를 가지고 있는지 확인하고 true 일 때이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b07a29909bdb4a7c9a4c7d68a06e09221fc27e7c" translate="yes" xml:space="preserve">
          <source>Just like MapReduce, if user specify &quot;parallel&quot; in their Pig statement, or user define default_parallel in Tez mode, Pig will honor it (the only exception is if user specify a parallel which is apparently too low, Pig will override it)</source>
          <target state="translated">MapReduce와 마찬가지로 사용자가 Pig 문에 &quot;parallel&quot;을 지정하거나 사용자가 Tez 모드에서 default_parallel을 정의하면 Pig가이를 존중합니다 (사용자가 너무 낮은 병렬을 지정하면 Pig가이를 대체 함)</target>
        </trans-unit>
        <trans-unit id="362ce6c69aec6aa228025cdea51fbad41241c2ee" translate="yes" xml:space="preserve">
          <source>Kerberos is a authentication system that uses tickets with a limited validity time.</source>
          <target state="translated">Kerberos는 유효 시간이 제한된 티켓을 사용하는 인증 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="134d1eb6aa3d758c6d2a1058ae3736bf8dd9041a" translate="yes" xml:space="preserve">
          <source>Key (see table). Case sensitive.</source>
          <target state="translated">키 (표 참조). 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6cca404086c0c970a335a2fb82ffafe8356b46e5" translate="yes" xml:space="preserve">
          <source>Key value pairs are separated by the pound sign #.</source>
          <target state="translated">키 값 쌍은 파운드 기호 #으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="8098eb09dd0aab077b1f27f175c7ab7b69b5f496" translate="yes" xml:space="preserve">
          <source>Key values within a relation must be unique.</source>
          <target state="translated">관계 내의 키 값은 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="20f56842c9025d12cf677dcfcfc8d42101d62d87" translate="yes" xml:space="preserve">
          <source>Keyword.</source>
          <target state="translated">Keyword.</target>
        </trans-unit>
        <trans-unit id="59a29873cf3f108383cd6005d3b1061f15d203a8" translate="yes" xml:space="preserve">
          <source>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</source>
          <target state="translated">예어. 모든 튜플을 단일 그룹으로 이동하려면 ALL을 사용하십시오. 예를 들어, 전체 관계에서 집계를 수행 할 때.</target>
        </trans-unit>
        <trans-unit id="a7c4c244651ed2eef71562ff0f3f4ddcc23cb537" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to group the relation by field, tuple or expression.</source>
          <target state="translated">예어. 필드, 튜플 또는 표현식별로 관계를 그룹화하려면이 절을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="319289cdafee96fb1df0ad9cc8cefb1bd579fb6b" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to name the store function.</source>
          <target state="translated">예어. 저장 함수의 이름을 지정하려면이 절을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="67bd5860f834413aaa7d43179cf49527a0e0a2a6" translate="yes" xml:space="preserve">
          <source>Keywords LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, and DUMP are case insensitive. They can also be written as load, using, as, group, by, etc.</source>
          <target state="translated">키워드 LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE 및 DUMP는 대소 문자를 구분하지 않습니다. 또한로드, 사용, 그룹, 기준 등으로 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0edfbf0b2bd967f0c42ea28a41230fdd455d94f6" translate="yes" xml:space="preserve">
          <source>Kills a job.</source>
          <target state="translated">직업을 죽인다.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="081687e57ce32b0d5310545712b5004fdc61e427" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF</source>
          <target state="translated">LAST_INDEX_OF</target>
        </trans-unit>
        <trans-unit id="df47fe57bbca631a9709a10608e1b138590b99bd" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF(string, 'character')</source>
          <target state="translated">LAST_INDEX_OF (문자열, '문자')</target>
        </trans-unit>
        <trans-unit id="52e4213745bcac792482d968e621c5b7a8d439c9" translate="yes" xml:space="preserve">
          <source>LCFIRST</source>
          <target state="translated">LCFIRST</target>
        </trans-unit>
        <trans-unit id="97e019a4f6ed7512191b214c6cc6b45d3f156619" translate="yes" xml:space="preserve">
          <source>LCFIRST(expression)</source>
          <target state="translated">LCFIRST(expression)</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="4774d9fc38721cde600e4accf82d0e696ef36f65" translate="yes" xml:space="preserve">
          <source>LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//&lt;strong&gt;part &lt;/strong&gt;'</source>
          <target state="translated">LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00// &lt;strong&gt;부품&lt;/strong&gt; '</target>
        </trans-unit>
        <trans-unit id="9a4fc268593a3d77b3f981e8ec7b7ac700de71ad" translate="yes" xml:space="preserve">
          <source>LOAD 'data' [USING function] [AS schema];</source>
          <target state="translated">'데이터'로드 [사용 기능] [AS 스키마];</target>
        </trans-unit>
        <trans-unit id="285ba2da17d87dd834eefed1cada61171d7d941f" translate="yes" xml:space="preserve">
          <source>LOAD ... USING ... AS</source>
          <target state="translated">LOAD ... USING ... AS</target>
        </trans-unit>
        <trans-unit id="6a8f5f55cccc7758440851683be6f04c67cd6f96" translate="yes" xml:space="preserve">
          <source>LOAD, AS - Pig keywords</source>
          <target state="translated">LOAD, AS-돼지 키워드</target>
        </trans-unit>
        <trans-unit id="94b16081400651bfe270528a0e3ee7024a5f9ca3" translate="yes" xml:space="preserve">
          <source>LOG</source>
          <target state="translated">LOG</target>
        </trans-unit>
        <trans-unit id="fd8045b04b52cf7e9e6124cd894331256d12dd1a" translate="yes" xml:space="preserve">
          <source>LOG(expression)</source>
          <target state="translated">LOG(expression)</target>
        </trans-unit>
        <trans-unit id="bc31df31706dbabb2fd79fd247573138a9a82419" translate="yes" xml:space="preserve">
          <source>LOG10</source>
          <target state="translated">LOG10</target>
        </trans-unit>
        <trans-unit id="bf7398056782a2eb6fd651f94e9a8d6d8204c678" translate="yes" xml:space="preserve">
          <source>LOG10(expression)</source>
          <target state="translated">LOG10(expression)</target>
        </trans-unit>
        <trans-unit id="e2b5c793d8e006e471a5275e68adfb98fe059dc4" translate="yes" xml:space="preserve">
          <source>LOWER</source>
          <target state="translated">LOWER</target>
        </trans-unit>
        <trans-unit id="92aead129812450be477e67e7eb989a4e9f71ce9" translate="yes" xml:space="preserve">
          <source>LOWER(expression)</source>
          <target state="translated">LOWER(expression)</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="27e73e8192dd9ba4f47ae3488ff498e67ffd4019" translate="yes" xml:space="preserve">
          <source>LTRIM(expression)</source>
          <target state="translated">LTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="fc5aafa84439164f5915b1b47617fd862bbd82b2" translate="yes" xml:space="preserve">
          <source>Left outer join.</source>
          <target state="translated">왼쪽 외부 조인.</target>
        </trans-unit>
        <trans-unit id="13b628b4ab8b2509575a1cd6f8cb5fda2b247abd" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement the {CollectableLoader} interface as well as {OrderedLoadFunc} interface.</source>
          <target state="translated">가장 왼쪽 로더는 {CollectableLoader} 인터페이스와 {OrderedLoadFunc} 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="73cd7b56ef42ec03731837023a47cd87b79de49f" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement {CollectableLoader} interface as well as {OrderedLoadFunc}.</source>
          <target state="translated">가장 왼쪽의 로더는 {CollectableLoader} 인터페이스와 {OrderedLoadFunc}를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca2f7f65c0903edf089f4879169677e242e0ac7f" translate="yes" xml:space="preserve">
          <source>Let's assume that we have UDF Swap that, given a tuple with two fields, swaps their order. Let's assume that the UDF does not specify a schema and look at the scripts below:</source>
          <target state="translated">두 개의 필드가있는 튜플이 주어지면 순서를 바꾸는 UDF 스왑이 있다고 가정 해 봅시다. UDF가 스키마를 지정하지 않고 아래 스크립트를 보자고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="32d45a02984af444cda547a94ac518a5c5a58bc4" translate="yes" xml:space="preserve">
          <source>Let's now look at the implementation of the UPPER UDF.</source>
          <target state="translated">이제 UPPER UDF의 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fe6299c19bf8df974b9bebf8fccacccb0c36ebbe" translate="yes" xml:space="preserve">
          <source>Let's now see how this function can be used in a Pig script:</source>
          <target state="translated">이제 Pig 스크립트에서이 함수를 어떻게 사용할 수 있는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="ea4e0d6736c7d827cc4e7a66876464026006c55b" translate="yes" xml:space="preserve">
          <source>Let's revisit the UPPER function from our first example. As it is written now, it would only work if the data passed to it is of type chararray. To make it work with data whose type is not explicitly set, a function table with a single entry needs to be added:</source>
          <target state="translated">첫 번째 예에서 UPPER 함수를 다시 살펴 보겠습니다. 지금 작성되었으므로 전달 된 데이터가 chararray 유형 인 경우에만 작동합니다. 유형이 명시 적으로 설정되지 않은 데이터를 사용하려면 단일 항목이있는 함수 테이블을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="475a9652b88fed65852bd4b23c1359282ee6e175" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache Software License version 2.0.</source>
          <target state="translated">Apache Software License 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ae3881b2b0fb732bb6de9dde72017285f72800a" translate="yes" xml:space="preserve">
          <source>Like any other expression, null constants can be implicitly or explicitly cast.</source>
          <target state="translated">다른 표현식과 마찬가지로 null 상수는 암시 적으로 또는 명시 적으로 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="854814e315400972c4441dad1114f75bef4e9cc4" translate="yes" xml:space="preserve">
          <source>Likewise, TrevniStorage is very closely related to AvroStorage, and shares the same options as AvroStorage. See &lt;a href=&quot;#AvroStorage&quot;&gt;AvroStorage&lt;/a&gt; for a detailed description of the arguments for TrevniStorage.</source>
          <target state="translated">마찬가지로 TrevniStorage는 AvroStorage와 밀접한 관련이 있으며 AvroStorage와 동일한 옵션을 공유합니다. &lt;a href=&quot;#AvroStorage&quot;&gt;TrevniStorage&lt;/a&gt; 의 인수에 대한 자세한 설명은 AvroStorage 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b87f80550d82a9e0365779f8be23adc0ee585a43" translate="yes" xml:space="preserve">
          <source>LimitOptimizer</source>
          <target state="translated">LimitOptimizer</target>
        </trans-unit>
        <trans-unit id="6195b6b19ca290cb1f0c777b8f337e23861be917" translate="yes" xml:space="preserve">
          <source>Limited support is provided for Jython, Python, JavaScript, Ruby and Groovy functions. These functions are new, still evolving, additions to the system. Currently only the basic interface is supported; load/store functions are not supported. Furthermore, JavaScript, Ruby and Groovy are provided as experimental features because they did not go through the same amount of testing as Java or Jython. At runtime note that Pig will automatically detect the usage of a scripting UDF in the Pig script and will automatically ship the corresponding scripting jar, either Jython, Rhino, JRuby or Groovy-all, to the backend. Python does not require any runtime engine since it invoke python command line and stream data in and out of it.</source>
          <target state="translated">Jython, Python, JavaScript, Ruby 및 Groovy 함수에 대한 지원이 제한되어 있습니다. 이 기능들은 시스템에 새로 추가 된 새로운 기능입니다. 현재 기본 인터페이스 만 지원됩니다. 로드 / 저장 기능은 지원되지 않습니다. 또한 JavaScript, Ruby 및 Groovy는 Java 또는 Jython과 같은 양의 테스트를 거치지 않았으므로 실험 기능으로 제공됩니다. 런타임에 Pig는 Pig 스크립트에서 스크립팅 UDF의 사용을 자동으로 감지하고 해당 스크립팅 jar (Jython, Rhino, JRuby 또는 Groovy-all)을 백엔드에 자동으로 제공합니다. 파이썬은 python 명령 행을 호출하고 데이터를 스트림 아웃하기 때문에 런타임 엔진이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7515906f2285af7d60e86a7d43455b7a249592bf" translate="yes" xml:space="preserve">
          <source>Limits the number of output tuples.</source>
          <target state="translated">출력 튜플의 수를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="956e1330b61723ff186fcbcfd265adba91e6af54" translate="yes" xml:space="preserve">
          <source>Line 1 indicates that the function is part of the myudfs package. The UDF class extends the EvalFunc class which is the base class for all eval functions. It is parameterized with the return type of the UDF which is a Java String in this case. We will look into the EvalFunc class in more detail later, but for now all we need to do is to implement the exec function. This function is invoked on every input tuple. The input into the function is a tuple with input parameters in the order they are passed to the function in the Pig script. In our example, it will contain a single string field corresponding to the student name.</source>
          <target state="translated">1 행은 함수가 myudfs 패키지의 일부임을 나타냅니다. UDF 클래스는 모든 평가 함수의 기본 클래스 인 EvalFunc 클래스를 확장합니다. 이 경우 Java 문자열 인 UDF의 리턴 유형으로 매개 변수화됩니다. 우리는 나중에 EvalFunc 클래스를 더 자세히 살펴볼 것이지만 지금은 exec 함수를 구현하기 만하면됩니다. 이 함수는 모든 입력 튜플에서 호출됩니다. 함수로의 입력은 Pig 스크립트에서 함수로 전달되는 순서대로 입력 매개 변수가있는 튜플입니다. 이 예에서는 학생 이름에 해당하는 단일 문자열 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5caa6119e5a5784410641134836063fbda7a2642" translate="yes" xml:space="preserve">
          <source>List Pig properties.</source>
          <target state="translated">돼지 속성을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="f021aa6572ced84b6338a8aa2d7c6ec393f0e8e9" translate="yes" xml:space="preserve">
          <source>Load Example</source>
          <target state="translated">로드 예</target>
        </trans-unit>
        <trans-unit id="1c6f5e374c495440813dfb8c43762f92a485801a" translate="yes" xml:space="preserve">
          <source>Load Examples</source>
          <target state="translated">하중 예</target>
        </trans-unit>
        <trans-unit id="153ed64057be54f8d2533568f5517a405ba5a31f" translate="yes" xml:space="preserve">
          <source>Load Functions</source>
          <target state="translated">로드 기능</target>
        </trans-unit>
        <trans-unit id="c84877c34cdbb71bdceab39a857b49dc7dd074db" translate="yes" xml:space="preserve">
          <source>Load or store JSON data.</source>
          <target state="translated">JSON 데이터를로드하거나 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b8a5a6a4984d874b5d5fc5f56453ae2255a611d3" translate="yes" xml:space="preserve">
          <source>Load statements &amp;ndash; PigStorage expects data to be formatted using field delimiters, either the tab character ('\t') or other specified character.</source>
          <target state="translated">로드 문 &amp;ndash; PigStorage는 데이터를 탭 문자 ( '\ t') 또는 기타 지정된 문자와 같은 필드 구분 기호를 사용하여 포맷해야합니다.</target>
        </trans-unit>
        <trans-unit id="8394a86595651bd6aa48839d4b9509225529fe8b" translate="yes" xml:space="preserve">
          <source>Load/Store Functions</source>
          <target state="translated">로드 / 저장 기능</target>
        </trans-unit>
        <trans-unit id="1ff3612ad5b787d3be631d6699ef0010173126d2" translate="yes" xml:space="preserve">
          <source>Load/store functions determine how data goes into Pig and comes out of Pig. Pig provides a set of built-in load/store functions, described in the sections below. You can also write your own load/store functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="translated">로드 / 저장 기능은 데이터가 돼지에 들어가고 돼지에서 나오는 방법을 결정합니다. Pig는 아래 섹션에서 설명하는 내장 된로드 / 저장 기능 세트를 제공합니다. 자체로드 / 스토어 함수를 작성할 수도 있습니다 ( &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c431ce3cc6de545c006a5dc4f55812d9901c37ac" translate="yes" xml:space="preserve">
          <source>Loader side:</source>
          <target state="translated">로더 측 :</target>
        </trans-unit>
        <trans-unit id="292c202d7f33de20bb18cb9b0cd78363326e07b9" translate="yes" xml:space="preserve">
          <source>Loader will be instructed to loader the partition with dt=='201310' and state=='CA'</source>
          <target state="translated">로더는 dt == '201310'및 state == 'CA'인 파티션을 로더하도록 지시받습니다.</target>
        </trans-unit>
        <trans-unit id="1bbec1f2925e33de29cc103440eaad38ddc86d8c" translate="yes" xml:space="preserve">
          <source>Loading Data</source>
          <target state="translated">데이터 로딩</target>
        </trans-unit>
        <trans-unit id="c2683406031d7a18de1fd67e1e11494ce9bebe57" translate="yes" xml:space="preserve">
          <source>Loads and stores data as structured text files.</source>
          <target state="translated">데이터를 구조화 된 텍스트 파일로로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="c5ab9df0752359ce2a9010c5aca5c7b13218b8ac" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Avro files.</source>
          <target state="translated">Avro 파일에서 데이터를로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="fd223bb0ff10c21f09b831e58eea8a6f58904d01" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Trevni files.</source>
          <target state="translated">Trevni 파일에서 데이터를로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="80db5f3f39fbbc84dd2b14e51899dff294e39ece" translate="yes" xml:space="preserve">
          <source>Loads and stores data from an HBase table.</source>
          <target state="translated">HBase 테이블에서 데이터를로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d72f04a406a7e49e13a302e150306baf032923ec" translate="yes" xml:space="preserve">
          <source>Loads and stores data in machine-readable format.</source>
          <target state="translated">기계가 읽을 수있는 형식으로 데이터를로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7c132ef27274638f19bb72b1001c8a9395135f95" translate="yes" xml:space="preserve">
          <source>Loads data from the file system.</source>
          <target state="translated">파일 시스템에서 데이터를로드합니다.</target>
        </trans-unit>
        <trans-unit id="eea9cefa9b896289e9167b60ed8b404fccfd5b53" translate="yes" xml:space="preserve">
          <source>Loads from or stores data to Orc file.</source>
          <target state="translated">오크 파일에서 데이터를로드하거나 저장합니다.</target>
        </trans-unit>
        <trans-unit id="18e8e0842b1999e676731438c4dea4a56f79cd4c" translate="yes" xml:space="preserve">
          <source>Loads or stores data from an Accumulo table. The first element in a Tuple is equivalent to the &quot;row&quot; from the Accumulo Key, while the columns in that row are can be grouped in various static or wildcarded ways. Basic wildcarding functionality exists to group various columns families/qualifiers into a Map for LOADs, or serialize a Map into some group of column families or qualifiers on STOREs.</source>
          <target state="translated">Accumulo 테이블에서 데이터를로드하거나 저장합니다. Tuple의 첫 번째 요소는 Accumulo Key의 &quot;행&quot;과 동일하지만 해당 행의 열은 다양한 정적 또는 와일드 카드 방식으로 그룹화 할 수 있습니다. 기본 와일드 카드 기능은 다양한 컬럼 계열 / 자격자를 LOAD for Map으로 그룹화하거나 맵을 STORE의 일부 컬럼 계열 또는 규정 자 그룹으로 직렬화하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="740ccec530db15440e48181713136ee050ab7097" translate="yes" xml:space="preserve">
          <source>Loads unstructured data in UTF-8 format.</source>
          <target state="translated">비정형 데이터를 UTF-8 형식으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="b3b24cc821e27fff117200af94d65c12872874b1" translate="yes" xml:space="preserve">
          <source>Local Mode</source>
          <target state="translated">로컬 모드</target>
        </trans-unit>
        <trans-unit id="ea7076530ceab2e77fb3cb520efd850a7ddef48b" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (local mode)</source>
          <target state="translated">로그 파일, Excite 검색 엔진 (로컬 모드)</target>
        </trans-unit>
        <trans-unit id="863629ee92f0cce989f168afc709eb06192b10b7" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (mapreduce)</source>
          <target state="translated">로그 파일, Excite 검색 엔진 (mapreduce)</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="0178a9a96c884d695567e06fe46d3aa4cbf9b156" translate="yes" xml:space="preserve">
          <source>Long lived jobs</source>
          <target state="translated">오래 살았던 직업</target>
        </trans-unit>
        <trans-unit id="c95e7e6f6a263bc67561c7fc8ceb0607d15d1cba" translate="yes" xml:space="preserve">
          <source>Long: long</source>
          <target state="translated">긴 : 긴</target>
        </trans-unit>
        <trans-unit id="3316c8ddabfaccc1e70bfecfd5b7747a06043e4b" translate="yes" xml:space="preserve">
          <source>Longs</source>
          <target state="translated">Longs</target>
        </trans-unit>
        <trans-unit id="7b186e235f284107df6b4dbe6060d2b6a5d9f1e5" translate="yes" xml:space="preserve">
          <source>MAX</source>
          <target state="translated">MAX</target>
        </trans-unit>
        <trans-unit id="3ada24ec29991deafbe9dbcbe2155e2e6ee05875" translate="yes" xml:space="preserve">
          <source>MAX(expression)</source>
          <target state="translated">MAX(expression)</target>
        </trans-unit>
        <trans-unit id="04e66352aa8f9c4c5f26b71bf380973ada994760" translate="yes" xml:space="preserve">
          <source>MIN</source>
          <target state="translated">MIN</target>
        </trans-unit>
        <trans-unit id="9f16fb3a367f47ced429f9a96ee8af3d40dcccdd" translate="yes" xml:space="preserve">
          <source>MIN(expression)</source>
          <target state="translated">MIN(expression)</target>
        </trans-unit>
        <trans-unit id="4a83930aeba65503717c88ca93580a0d643e3c2d" translate="yes" xml:space="preserve">
          <source>Macro expansion is not a complete replacement for function calls. Recursive expansions are not supported.</source>
          <target state="translated">매크로 확장은 함수 호출을 완전히 대체하지 않습니다. 재귀 확장은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90103d0b5c28db7922249a3fa2ea7bfff2ba0064" translate="yes" xml:space="preserve">
          <source>Macro names are global and all macros share the same name space. While the file can contain more than one macro definition, having two macros with the same name in your execution context will result in an error.</source>
          <target state="translated">매크로 이름은 전역 적이며 모든 매크로는 동일한 네임 스페이스를 공유합니다. 파일에 둘 이상의 매크로 정의가 포함될 수 있지만 실행 컨텍스트에 동일한 이름을 가진 두 개의 매크로가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a950d781ec76e0d5d8f9a49df1d80136a24daf6d" translate="yes" xml:space="preserve">
          <source>Macros are NOT alllowed inside a nested block.</source>
          <target state="translated">중첩 된 블록 안에 매크로가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0fe92ab842bd9468af7fe40e3c0e996ece09d87" translate="yes" xml:space="preserve">
          <source>Macros are not allowed inside a &lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; nested block.</source>
          <target state="translated">&lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; 중첩 블록 내에서는 매크로를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ec793f1eac030adf34d2e41a8195b5aa6af3faa2" translate="yes" xml:space="preserve">
          <source>Macros can only contain Pig Latin statements; Grunt shell commands are not supported. REGISTER statements and parameter definitions with %default or %declare are both valid however. Your macro file also IMPORT other macro files, so long as these imports are not recursive.</source>
          <target state="translated">매크로는 Pig Latin 문장 만 포함 할 수 있습니다. 그런트 쉘 명령은 지원되지 않습니다. 그러나 % default 또는 % declare를 사용하는 REGISTER 문 및 매개 변수 정의는 모두 유효합니다. 가져 오기가 재귀 적이 지 않은 한 매크로 파일은 다른 매크로 파일도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8f5d729039ce92b99bf31323c027bd3e1999e4d3" translate="yes" xml:space="preserve">
          <source>Macros cannot contain &lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt shell commands&lt;/a&gt;.</source>
          <target state="translated">매크로는 &lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt 쉘 명령을&lt;/a&gt; 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4798c01e02a87a25ab288415fe8315792ab65a" translate="yes" xml:space="preserve">
          <source>Macros cannot include a user-defined schema that has a name collision with an alias in the macro.</source>
          <target state="translated">매크로는 매크로의 별칭과 이름 충돌이있는 사용자 정의 스키마를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b90c9bc525fef91c7051e223d84db955ed26d8b6" translate="yes" xml:space="preserve">
          <source>Make Your UDFs Algebraic</source>
          <target state="translated">UDF를 대수적으로 만들기</target>
        </trans-unit>
        <trans-unit id="0c76e7b16941afa21f1bc061662c5afc67e30d7d" translate="yes" xml:space="preserve">
          <source>Make sure that for each function, you add a corresponding test class in the test part of the tree.</source>
          <target state="translated">각 함수마다 트리의 테스트 부분에 해당 테스트 클래스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="89075a765b1a0bbdfb1037d1e343f2d19beb8ffd" translate="yes" xml:space="preserve">
          <source>Make sure that your code follows Pig coding conventions described in &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;How to Contribute to Pig&lt;/a&gt;.</source>
          <target state="translated">코드 &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;가 Pig에 기여하는 방법에&lt;/a&gt; 설명 된 Pig 코딩 규칙을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="1453bf305e9c5ecb3fb272c5a0f810f865052a67" translate="yes" xml:space="preserve">
          <source>Make sure that your function is well documented and uses the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; style of documentation.</source>
          <target state="translated">함수가 잘 문서화되고 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; 스타일의 문서를 사용하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="02bf56b1b68374b208d34a48eae88f93b5114cb8" translate="yes" xml:space="preserve">
          <source>Make sure the JAVA_HOME environment variable is set the root of your Java installation.</source>
          <target state="translated">JAVA_HOME 환경 변수가 Java 설치의 루트로 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f0a14e7b46d7b053eeee4d905350e82494b9e784" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes bin/pig (this enables you to run the tutorials using the &quot;pig&quot; command).</source>
          <target state="translated">PATH에 bin / pig가 포함되어 있는지 확인하십시오 ( &quot;pig&quot;명령을 사용하여 학습서를 실행할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="8f2f922bc9ecd3f2a3cdc0e7b3ae6ed62fb20721" translate="yes" xml:space="preserve">
          <source>Makes the split non-blocking and allows processing to continue. This helps reduce the amount of data that has to be stored right at the split.</source>
          <target state="translated">분할을 차단하지 않고 처리를 계속할 수 있습니다. 이는 분할시 바로 저장해야하는 데이터의 양을 줄이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="209567b32f8fea5e9ef198fb3941b8730fad033c" translate="yes" xml:space="preserve">
          <source>Many PigUnit examples are available in the &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit tests&lt;/a&gt;.</source>
          <target state="translated">많은 PigUnit 예제가 &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit 테스트&lt;/a&gt; 에서 사용 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="dae74f13b986a147221f41b0053b991ea203fea3" translate="yes" xml:space="preserve">
          <source>Map Schemas</source>
          <target state="translated">맵 스키마</target>
        </trans-unit>
        <trans-unit id="8af46e94e502b7aa7a2f1aa05b12cb0c07e01870" translate="yes" xml:space="preserve">
          <source>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</source>
          <target state="translated">맵 역 참조는 키 (field_name # key 또는 $ 0 # key)로 수행해야합니다. 파운드 연산자가 바이트 배열에 적용되면 바이트 배열은 맵으로 간주됩니다. 키가 존재하지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="172c8b9363030fc7be69a2798cd806007e34c86e" translate="yes" xml:space="preserve">
          <source>Map&amp;lt;Object, Object&amp;gt;</source>
          <target state="translated">지도 &amp;lt;개체, 개체&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5a376ab0b0389e27d40fa426227bc396c3d2e452" translate="yes" xml:space="preserve">
          <source>Map: java.util.Map</source>
          <target state="translated">지도 : java.util.Map</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="1a50f5954df4dfe8722ed6d174a9520e089c8ce6" translate="yes" xml:space="preserve">
          <source>Maps are enclosed in straight brackets [ ].</source>
          <target state="translated">지도는 대괄호 []로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="1756bec08ab2e5a4f6f3ea1577c5665ca0e8a418" translate="yes" xml:space="preserve">
          <source>Math Functions</source>
          <target state="translated">수학 함수</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="ffc4d0fd84372762976635002c427e810e8329a6" translate="yes" xml:space="preserve">
          <source>Merge Joins</source>
          <target state="translated">조인 병합</target>
        </trans-unit>
        <trans-unit id="627dc8ff0cef660b000fb836bad32ded77d9db38" translate="yes" xml:space="preserve">
          <source>Merge filter conditions after PushUpFilter rule to decrease the number of filter statements.</source>
          <target state="translated">PushUpFilter 규칙 후 필터 조건을 병합하여 필터 문의 수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="51c7b431837f24885f18db611764cb39830ff71e" translate="yes" xml:space="preserve">
          <source>Merge-Sparse Joins</source>
          <target state="translated">병합 스파 스 조인</target>
        </trans-unit>
        <trans-unit id="8fea2fed8c16c2288bb31ada275a77e267a6ab5c" translate="yes" xml:space="preserve">
          <source>Merge-Sparse join is a specialization of merge join. Merge-sparse join is intended for use when one of the tables is very sparse, meaning you expect only a small number of records to be matched during the join. In tests this join performed well for cases where less than 1% of the data was matched in the join.</source>
          <target state="translated">병합-스파 스 조인은 병합 조인을 전문으로합니다. 병합 스파 스 조인은 테이블 중 하나가 매우 희박 할 때 사용하기위한 것으로, 조인 중에 적은 수의 레코드 만 일치 할 것으로 예상됩니다. 테스트에서이 결합은 데이터의 1 % 미만이 결합에서 일치하는 경우에 잘 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4bdcc67e1fd583bc328f53c3b10ec1e75cec47e" translate="yes" xml:space="preserve">
          <source>Merge-sparse join only works for inner joins and is not currently implemented for outer joins.</source>
          <target state="translated">병합 스파 스 조인은 내부 조인에만 작동하며 현재 외부 조인에는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8fae7f7316c44f46454df38407830d960deca78" translate="yes" xml:space="preserve">
          <source>MergeFilter</source>
          <target state="translated">MergeFilter</target>
        </trans-unit>
        <trans-unit id="23a02331f579c7154e40a84a1946289d36647520" translate="yes" xml:space="preserve">
          <source>MergeForEach</source>
          <target state="translated">MergeForEach</target>
        </trans-unit>
        <trans-unit id="6b121c3e89581e5ceab18466104db8aab4915066" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween</source>
          <target state="translated">MilliSecondsBetween</target>
        </trans-unit>
        <trans-unit id="e71ec4d9c2fb04eac5ce8aa7ddfc94b4e537dc73" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween(datetime1, datetime2)</source>
          <target state="translated">MilliSecondsBetween (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="6295a9ae493dccb2f773f064edfa765b839ab428" translate="yes" xml:space="preserve">
          <source>MiniCluster generates one in build/classes.</source>
          <target state="translated">MiniCluster는 빌드 / 클래스에서 하나를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13b68c92e094101ca904236df27e6d286dfc4604" translate="yes" xml:space="preserve">
          <source>MinutesBetween</source>
          <target state="translated">MinutesBetween</target>
        </trans-unit>
        <trans-unit id="121265c9da1c27a9e91b296b9a032f9dc043e2cf" translate="yes" xml:space="preserve">
          <source>MinutesBetween(datetime1, datetime2)</source>
          <target state="translated">분 사이 (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="5af6b4c2a5b65cc8ab62dc972a6b79fd159c1004" translate="yes" xml:space="preserve">
          <source>MissingFormatArgumentException: Format specifier '%-8s'</source>
          <target state="translated">MissingFormatArgumentException : 형식 지정자 '% -8s'</target>
        </trans-unit>
        <trans-unit id="99a3402325144d291bec7ddf15b2b92ddc5bc907" translate="yes" xml:space="preserve">
          <source>Mocking</source>
          <target state="translated">Mocking</target>
        </trans-unit>
        <trans-unit id="98c1556eb14f903ff0cc6da7fce11300097e4f71" translate="yes" xml:space="preserve">
          <source>Monitoring Long-Running UDFs</source>
          <target state="translated">장기 실행 UDF 모니터링</target>
        </trans-unit>
        <trans-unit id="f4e4587a8e5bc89978b95fd14712b5c637d334c7" translate="yes" xml:space="preserve">
          <source>MonthsBetween</source>
          <target state="translated">MonthsBetween</target>
        </trans-unit>
        <trans-unit id="c2497de4c3a7f46f52e471bf016580c8b05abe79" translate="yes" xml:space="preserve">
          <source>MonthsBetween(datetime1, datetime2)</source>
          <target state="translated">MonthsBetween (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="5d01423227f4b2cd4ded59e2cdbfb0057686b879" translate="yes" xml:space="preserve">
          <source>Most Orc data type has one to one mapping to Pig data type. Several exceptions are:</source>
          <target state="translated">대부분의 Orc 데이터 형식에는 Pig 데이터 형식에 대한 일대일 매핑이 있습니다. 몇 가지 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdfa5243b3d54966023e586cfec06cfd9d7a42dd" translate="yes" xml:space="preserve">
          <source>Most existing Pig scripts will produce the same result with or without the multi-query execution. There are cases though where this is not true. Path names and schemes are discussed here.</source>
          <target state="translated">대부분의 기존 Pig 스크립트는 다중 쿼리 실행 유무에 관계없이 동일한 결과를 생성합니다. 이것이 사실이 아닌 경우가 있습니다. 경로 이름과 구성표가 여기에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b10b3ed627fb4772162ce992b3ea0544246f7c8b" translate="yes" xml:space="preserve">
          <source>Most of the time, single-tuple processing within a UDF is very short and does not require a UDF to heartbeat. The same is true for aggregate functions that operate on large bags because bag iteration code takes care of it. However, if you have a function that performs a complex computation that can take an order of minutes to execute, you should add a progress indicator to your code. This is very easy to accomplish. The EvalFunc class provides a progress function that you need to call in your exec method.</source>
          <target state="translated">대부분의 경우 UDF 내 단일 튜플 처리는 매우 짧으며 UDF가 하트 비트 일 필요는 없습니다. 백 반복 코드가이를 처리하므로 대형 백에서 작동하는 집계 함수의 경우에도 마찬가지입니다. 그러나 복잡한 계산을 수행하는 데 몇 분이 걸리는 함수가 있으면 코드에 진행률 표시기를 추가해야합니다. 이것은 달성하기가 매우 쉽습니다. EvalFunc 클래스는 exec 메소드에서 호출해야하는 progress 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e6ca4666a38ad0441b66ffd38051824a3e1f9b9e" translate="yes" xml:space="preserve">
          <source>Most times, it is not necessary, nor desired for performance reasons, to fetch all columns.</source>
          <target state="translated">대부분의 경우 모든 컬럼을 페치 할 필요가 없으며 성능상의 이유로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12fdb217bf25b1d89a39ced7476e27e33bf049f6" translate="yes" xml:space="preserve">
          <source>Move to the Pig tutorial directory (.../pig-0.17.0/tutorial).</source>
          <target state="translated">Pig 튜토리얼 디렉토리 (... / pig-0.17.0 / tutorial)로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="31c02a320c089f6597a14f81e99bbbb176a8d14f" translate="yes" xml:space="preserve">
          <source>Move to the pigtmp directory.</source>
          <target state="translated">pigtmp 디렉토리로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6ac8dd3fbae422b42dfb2b029fcf9ffa579e90ba" translate="yes" xml:space="preserve">
          <source>Multi-Query Execution</source>
          <target state="translated">다중 쿼리 실행</target>
        </trans-unit>
        <trans-unit id="01b85aabcb3b39447e1aab1a2ca45fed5b213163" translate="yes" xml:space="preserve">
          <source>Multi-query execution introduces some changes:</source>
          <target state="translated">다중 쿼리 실행에는 몇 가지 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0c81ed15124e2c9f58dac0249e297166b9f212" translate="yes" xml:space="preserve">
          <source>Multi-query execution is turned on by default. To turn it off and revert to Pig's &quot;execute-on-dump/store&quot; behavior, use the &quot;-M&quot; or &quot;-no_multiquery&quot; options.</source>
          <target state="translated">다중 쿼리 실행은 기본적으로 켜져 있습니다. 이 기능을 끄고 Pig의 &quot;덤프에 덤프 실행 / 저장&quot;동작으로 되돌리려면 &quot;-M&quot;또는 &quot;-no_multiquery&quot;옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="df511d0b9ccb7e1d2a7d7c5c3de6213920d670e9" translate="yes" xml:space="preserve">
          <source>Multiple fields are enclosed in parentheses and separated by commas.</source>
          <target state="translated">여러 필드는 괄호로 묶고 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="49c92016401e9e368896026aade96455b23a26cb" translate="yes" xml:space="preserve">
          <source>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</source>
          <target state="translated">여러 파일을 지정할 수 있습니다. 파일에 동일한 매개 변수가 여러 번 존재하면 마지막 값이 사용되며 경고가 생성됩니다. 여러 파일에 매개 변수가 있으면 마지막 파일의 값이 사용되며 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="78de899b1c722999a754115b391c3f6d8afcc630" translate="yes" xml:space="preserve">
          <source>Multiple items:</source>
          <target state="translated">여러 항목 :</target>
        </trans-unit>
        <trans-unit id="4fd56e73c50d1cf9df45651cb8969f782fc4bd9d" translate="yes" xml:space="preserve">
          <source>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</source>
          <target state="translated">여러 매개 변수를 지정할 수 있습니다. 동일한 매개 변수가 여러 번 지정된 경우 마지막 값이 사용되며 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a7224113267e40a9f1083035389fd70d294aaf25" translate="yes" xml:space="preserve">
          <source>Multiple register commands can be used in the same script. If the same fully-qualified function is present in multiple jars, the first occurrence will be used consistently with Java semantics.</source>
          <target state="translated">동일한 스크립트에서 여러 레지스터 명령을 사용할 수 있습니다. 동일한 jar 함수가 여러 jar에 있으면 첫 번째 발생이 Java 의미와 일관되게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e91b337a11e8be469e11fd079a265758b7d0f67" translate="yes" xml:space="preserve">
          <source>Must be chararray data type. Must be a unique value.</source>
          <target state="translated">chararray 데이터 형식이어야합니다. 고유 한 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="dbda54bf8f5b0c2cab6b61e46d69af778895241e" translate="yes" xml:space="preserve">
          <source>NATIVE</source>
          <target state="translated">NATIVE</target>
        </trans-unit>
        <trans-unit id="8e7f35442a0cbdf6e52522bf252417e0672f3cf5" translate="yes" xml:space="preserve">
          <source>NGramGenerator</source>
          <target state="translated">NGramGenerator</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="434fe5f55d2da77a8c38d9d086d184382c0431af" translate="yes" xml:space="preserve">
          <source>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword (see &lt;a href=&quot;#identifiers&quot;&gt;Identifiers&lt;/a&gt; for valid name examples).</source>
          <target state="translated">스키마를 사용하여 (또는 GROUP 연산자 및 일부 기능의 경우 시스템에서) 이름을 지정합니다. Pig 키워드가 아닌 모든 이름을 사용할 수 있습니다 ( 유효한 이름 예제는 &lt;a href=&quot;#identifiers&quot;&gt;식별자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a1cd1435493b07624397f0caecc9c127f1237605" translate="yes" xml:space="preserve">
          <source>Nested FOREACH...GENERATE block used with a inner bag. Use this syntax:</source>
          <target state="translated">내부 백과 함께 사용되는 중첩 FOREACH ... GENERATE 블록. 이 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="856b986d3b3538c9f63c14a8bfa923da457a6cbf" translate="yes" xml:space="preserve">
          <source>No gap in the ranking values.</source>
          <target state="translated">순위 값에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8afea8785f2d471644a7e2ce83ccf7eaafc476b5" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the LOAD and COGROUP statements.</source>
          <target state="translated">LOAD와 COGROUP 문 사이에 다른 조작을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cacbef0c08a2a634815e58b66c00fed7c2c41d6" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the load and join statements.</source>
          <target state="translated">load 문과 join 문 사이에 다른 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37c34486a47e980837dfed80ad60c633165578bc" translate="yes" xml:space="preserve">
          <source>No terms.</source>
          <target state="translated">조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f05f854bcf667613eb1bcf644bf89bea7c04c22" translate="yes" xml:space="preserve">
          <source>Non-empty bag: {code}{(tuple1),(tuple2),(tuple3)}{code}</source>
          <target state="translated">비어 있지 않은 백 : {code} {(tuple1), (tuple2), (tuple3)} {code}</target>
        </trans-unit>
        <trans-unit id="a9028fbba3faab3bb8d6374d3d3b12e55ec4d07e" translate="yes" xml:space="preserve">
          <source>Non-empty map: [key1#value1,key2#value2]</source>
          <target state="translated">비어 있지 않은 맵 : [key1 # value1, key2 # value2]</target>
        </trans-unit>
        <trans-unit id="454c82816301c007849136a6a6afd39e636c7a7d" translate="yes" xml:space="preserve">
          <source>Non-empty tuple: (item1,item2,item3)</source>
          <target state="translated">비어 있지 않은 튜플 : (item1, item2, item3)</target>
        </trans-unit>
        <trans-unit id="8bb35935b1c067f8f5b9269c75f07f122dc91e0b" translate="yes" xml:space="preserve">
          <source>NonURLDetector</source>
          <target state="translated">NonURLDetector</target>
        </trans-unit>
        <trans-unit id="f3a561a666d179ca85f5eca5281a4cc29dc561d4" translate="yes" xml:space="preserve">
          <source>Not applicable.</source>
          <target state="translated">적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3097e34dbf20e18d2f69780a551e61726fd84f2e" translate="yes" xml:space="preserve">
          <source>Not only inside outputSchema at compile time, input schema is also accessible in exec at runtime. For example:</source>
          <target state="translated">컴파일시 outputSchema 내부뿐만 아니라 런타임에 exec에서도 입력 스키마에 액세스 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fe6878280c596a2dd5322865b0537fe6209c86bf" translate="yes" xml:space="preserve">
          <source>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &amp;lt;= i &amp;lt; s A[i] == B[i])</source>
          <target state="translated">참고 1 : 부울 (튜플 A는 크기가 s이고 모두 0 &amp;lt;= i &amp;lt;s A [i] == B [i] 인 경우 튜플 B와 같습니다)</target>
        </trans-unit>
        <trans-unit id="e7ce1a756a8dac8acf02cf7ce21512a25d378b81" translate="yes" xml:space="preserve">
          <source>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 == k2 and v1 == v2)</source>
          <target state="translated">참고 2 : 부울 (A와 B의 항목 수가 동일한 경우 맵 A는 맵 B와 동일하며 값이 v1 인 A의 모든 키 k1에 대해 값이 v2 인 B의 키 k2가 있습니다. k1 == k2 및 v1 == v2)</target>
        </trans-unit>
        <trans-unit id="7b6c6d89bc2c99329a0bff371ae22ebd24929b95" translate="yes" xml:space="preserve">
          <source>Note that a DUMP or STORE statement is required to generate output.</source>
          <target state="translated">출력을 생성하려면 DUMP 또는 STORE 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7830de9d278f278b280af353b2b1e821813572b3" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Java UDF may be embedded in Python, JavaScript, Groovy, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">호스트 언어와 UDF 언어 (내장 Pig의 일부로 포함)는 완전히 직교합니다. 예를 들어 Java UDF를 등록하는 Pig Latin 문은 Python, JavaScript, Groovy 또는 Java에 임베드 될 수 있습니다. 여기에 언어가 일치합니다 (참조해야한다 -이 규칙의 예외는 &quot;결합&quot;스크립트입니다 &lt;a href=&quot;udf#jython-advanced&quot;&gt;파이썬에 대한 고급 주제&lt;/a&gt; , &lt;a href=&quot;udf#js-advanced&quot;&gt;자바 스크립트에 대한 고급 주제&lt;/a&gt; 와 &lt;a href=&quot;udf#groovy-advanced&quot;&gt;그루비를위한 고급 항목&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ced2283529be7070b1816e7bc88ea7c4ff8a20e9" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Python UDF may be embedded in Python, JavaScript, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">호스트 언어와 UDF 언어 (내장 Pig의 일부로 포함)는 완전히 직교합니다. 예를 들어 Python UDF를 등록하는 Pig Latin 문은 Python, JavaScript 또는 Java에 임베드 될 수 있습니다. 여기에 언어가 일치합니다 (참조해야한다 -이 규칙의 예외는 &quot;결합&quot;스크립트입니다 &lt;a href=&quot;udf#jython-advanced&quot;&gt;파이썬에 대한 고급 주제&lt;/a&gt; , &lt;a href=&quot;udf#js-advanced&quot;&gt;자바 스크립트에 대한 고급 주제&lt;/a&gt; 와 &lt;a href=&quot;udf#groovy-advanced&quot;&gt;그루비를위한 고급 항목&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a92b6e8e114c8750692dc7d3c9a3cb2162bb5174" translate="yes" xml:space="preserve">
          <source>Note that only real programs can be run form the sh command. Commands such as cd are not programs but part of the shell environment and as such cannot be executed unless the user invokes the shell explicitly, like &quot;bash cd&quot;.</source>
          <target state="translated">실제 프로그램 만 sh 명령으로 실행할 수 있습니다. cd와 같은 명령은 프로그램이 아니라 셸 환경의 일부이므로 &quot;bash cd&quot;와 같이 사용자가 셸을 명시 적으로 호출하지 않으면 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3b397cb98d2ff8d3aff186a2a49ff9b5ce0dce4" translate="yes" xml:space="preserve">
          <source>Note that production scripts SHOULD NOT use DUMP as it will disable multi-query optimizations and is likely to slow down execution (see &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;).</source>
          <target state="translated">프로덕션 스크립트는 다중 쿼리 최적화를 비활성화하고 실행 속도가 느려질 수 있으므로 DUMP를 사용하지 않아야합니다 ( &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="220abe9e473e98cfec1e0a00df725cde1dc89b0a" translate="yes" xml:space="preserve">
          <source>Note that regardless of whether or not you store the schema, you always need to specify the correct delimiter to read your data. If you store using delimiter &quot;#&quot; and then load using the default delimiter, your data will not be parsed correctly.</source>
          <target state="translated">스키마를 저장하는지 여부에 관계없이 데이터를 읽으려면 항상 올바른 구분 기호를 지정해야합니다. 구분 기호 &quot;#&quot;을 사용하여 저장 한 다음 기본 구분 기호를 사용하여로드하면 데이터가 올바르게 구문 분석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd60f49eedb0eb2995d8bffd71cf6b05d7d5ba0e" translate="yes" xml:space="preserve">
          <source>Note that the REPLACE function is internally implemented using &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt; java.string.replaceAll(String regex, String replacement)&lt;/a&gt; where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt; special characters&lt;/a&gt; such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\[').</source>
          <target state="translated">REPLACE 함수는 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt;java.string.replaceAll (String regex, String replacement)을&lt;/a&gt; 사용하여 내부적으로 구현됩니다. 여기서 'regExp'및 'newChar'는 각각 첫 번째 및 두 번째 인수로 전달됩니다. 문자열 리터럴에서 '['와 같은 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt;특수 문자&lt;/a&gt; 를 바꾸려면 이중 백 슬래시 (예 : '\\ [')를 접두어로 붙여서 'regExp'에서 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e09f5334aab86da1b1a89569910200108793437" translate="yes" xml:space="preserve">
          <source>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable.</source>
          <target state="translated">ship 옵션에는 두 가지 구성 요소가 있습니다. ship () 절에 제공된 소스 스펙은 기계의보기입니다. 명령 스펙은 실제 클러스터의보기입니다. 제공된 파일은 실행 된 작업의 현재 작업 디렉토리에서 사용 가능하고 현재 작업 디렉토리도 PATH 환경 변수에 있다는 것이 보증됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1565e4014885607dad5c0c2988001edad8fcbf" translate="yes" xml:space="preserve">
          <source>Note that there is no concept of delimit in JsonLoader or JsonStorage. The data is encoded in standard JSON format. JsonLoader optionally takes a schema as the construct argument.</source>
          <target state="translated">JsonLoader 또는 JsonStorage에는 구분 개념이 없습니다. 데이터는 표준 JSON 형식으로 인코딩됩니다. JsonLoader는 선택적으로 스키마를 구성 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f363dfb66c51fc8e96f3f1500d605d9e9288e8c2" translate="yes" xml:space="preserve">
          <source>Note that type is NOT part of parameter definition. It is your responsibility to document the types of the parameters in a macro.</source>
          <target state="translated">유형은 매개 변수 정의의 일부가 아닙니다. 매크로에 매개 변수 유형을 문서화하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="2d208e362ac7a9c4e5eb23ba8f74811e2d7eaa7a" translate="yes" xml:space="preserve">
          <source>Note that, even if filtering is omitted, the same results will be produced because the foreach results is a cross product and cross products get rid of empty bags. However, doing up-front filtering is more efficient since it reduces the input of the cross product.</source>
          <target state="translated">필터링이 생략 되더라도 foreach 결과는 교차 곱이고 교차 곱은 빈 백을 제거하므로 동일한 결과가 생성됩니다. 그러나 선행 필터링을 수행하면 교차 제품의 입력이 줄어들 기 때문에보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1ed3db195fd189a63eb841d3fbd72406806084cd" translate="yes" xml:space="preserve">
          <source>Note the following about bags:</source>
          <target state="translated">가방에 대해 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="d3b92c42da2b629b81e09e80527a3382ab34212d" translate="yes" xml:space="preserve">
          <source>Note the following about the GROUP/COGROUP and JOIN operators:</source>
          <target state="translated">GROUP / COGROUP 및 JOIN 연산자에 대해 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="cc2f3dea19169906a9c3f9ebf1959122ab5b196c" translate="yes" xml:space="preserve">
          <source>Note the following general observations about data types:</source>
          <target state="translated">데이터 유형에 대한 다음과 같은 일반적인 관찰 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="69a5304de52ed596021b9b04debf06f38d8482d3" translate="yes" xml:space="preserve">
          <source>Note the following restrictions:</source>
          <target state="translated">다음 제한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="473512170f0fb2c20a02c7d3b244817ba7bd30ab" translate="yes" xml:space="preserve">
          <source>Note the second column, &amp;lsquo;cube&amp;rsquo; field which is a bag of all tuples that belong to &amp;lsquo;group&amp;rsquo;. Also note that the measure attribute &amp;lsquo;sales&amp;rsquo; along with other unused dimensions in load statement are pushed down so that it can be referenced later while computing aggregates on the measure, like in this case SUM(cube.sales).</source>
          <target state="translated">두 번째 열인 'cube'필드는 'group'에 속하는 모든 튜플의 백입니다. 또한 load 문에서 측정되지 않은 다른 차원과 함께 측정 값 속성 'sales'가 푸시 다운되므로 측정 값에서 집계를 계산하는 동안 나중에 참조 할 수 있습니다 (이 경우 SUM (cube.sales)).</target>
        </trans-unit>
        <trans-unit id="2e3c6dd868a0b7f3f2667d05913760948c880115" translate="yes" xml:space="preserve">
          <source>Note, the legacy property pig.additional.jars which use colon as separator is still supported. But we recommend to use pig.additional.jars.uris since colon is also used in URL scheme, and thus we cannot use full scheme in the list. We will deprecate pig.additional.jar in future releases.</source>
          <target state="translated">콜론을 분리 자로 사용하는 레거시 특성 pig.additional.jars는 계속 지원됩니다. 그러나 URL 체계에도 콜론이 사용되므로 pig.additional.jars.uris를 사용하는 것이 좋습니다. 따라서 전체 체계를 목록에서 사용할 수는 없습니다. 향후 릴리스에서는 pig.additional.jar을 더 이상 사용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="965007b15476572db9ef0dd93fbea3f0a4093cfd" translate="yes" xml:space="preserve">
          <source>Note: A few Hive 0.14 UDF contains bug which affects Pig and are fixed in Hive 1.0. Here is a list: compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</source>
          <target state="translated">참고 : 일부 Hive 0.14 UDF에는 Pig에 영향을주는 버그가 포함되어 있으며 Hive 1.0에서 수정되었습니다. 다음은리스트입니다 : compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</target>
        </trans-unit>
        <trans-unit id="1dc746cfe7d74da28d435069888547345cd0e6c0" translate="yes" xml:space="preserve">
          <source>Note: FOREACH statements can be nested to two levels only. FOREACH statements that are nested to three or more levels will result in a grammar error.</source>
          <target state="translated">참고 : FOREACH 문은 두 레벨로만 중첩 될 수 있습니다. 세 개 이상의 레벨로 중첩 된 FOREACH 문은 문법 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="80e6a55bf31a90c13baf56b918aa0883b6a73cca" translate="yes" xml:space="preserve">
          <source>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</source>
          <target state="translated">참고 : 성능상의 이유로 로더는 데이터를 지정된 형식으로 즉시 변환하지 않을 수 있습니다. 그러나 지정된 유형을 가정하여 데이터를 계속 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3e4fdc51f94140b39d0bd6e49fb88dc740fa81" translate="yes" xml:space="preserve">
          <source>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED bz/bz2 FILES generated in this manner:</source>
          <target state="translated">참고 : PigStorage 및 TextLoader는 압축 된 파일이 다음과 같은 방식으로 생성 된 bz / bz2 파일이 아닌 한 압축 파일을 올바르게 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c0518f86c35b79620a3094a43a0ad3c6c991d598" translate="yes" xml:space="preserve">
          <source>Note: The GROUP and COGROUP operators are identical. Both operators work with one or more relations. For readability GROUP is used in statements involving one relation and COGROUP is used in statements involving two or more relations. You can COGROUP up to but no more than 127 relations at a time.</source>
          <target state="translated">참고 : GROUP 및 COGROUP 연산자는 동일합니다. 두 연산자는 하나 이상의 관계로 작업합니다. 가독성을 위해 GROUP은 하나의 관계와 관련된 명령문에 사용되고 COGROUP은 두 개 이상의 관계와 관련된 명령문에 사용됩니다. 한 번에 최대 127 개의 관계를 COGROUP 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd595d75ed7d8086119b3f8ba5b4bdfe66882d8" translate="yes" xml:space="preserve">
          <source>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</source>
          <target state="translated">참고 : LIMIT 연산자를 사용하면 Pig는 관계에서 모든 튜플을 처리하지 않아도됩니다. 대부분의 경우 LIMIT를 사용하는 쿼리는 LIMIT를 사용하지 않는 동일한 쿼리보다 효율적으로 실행됩니다. 가능하면 항상 제한을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2b9a0acdfe2379b3842f287d992bccd78205e712" translate="yes" xml:space="preserve">
          <source>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</source>
          <target state="translated">참고 : 표현식은 상수 또는 스칼라로 구성 될 수 있습니다. 입력 관계의 열을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0f3237ae0f4fc4380931b678193ed2fc302b2e4" translate="yes" xml:space="preserve">
          <source>Note: To debug scripts during development, you can use &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; to check intermediate results.</source>
          <target state="translated">참고 : 개발 중 스크립트를 디버그하기 위해 &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; 를 사용 하여 중간 결과를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b80c89e4cc5f492c5be085c22ab1f50cca4f91fc" translate="yes" xml:space="preserve">
          <source>Note: Using a scalar instead of a constant in LIMIT automatically disables most optimizations (only push-before-foreach is performed).</source>
          <target state="translated">참고 : LIMIT에서 상수 대신 스칼라를 사용하면 대부분의 최적화가 자동으로 비활성화됩니다 (for-forefore foreach 만 수행됨).</target>
        </trans-unit>
        <trans-unit id="ee0e474fc81852f36c5fdc6b3952b10b45bbe057" translate="yes" xml:space="preserve">
          <source>Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.</source>
          <target state="translated">참고 : COUNT와 함께 튜플 지정자 (*)를 사용할 수 없습니다. 즉, COUNT (*)가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="109a6c5afefe5d900d28ab42046f4fa5d0b0d109" translate="yes" xml:space="preserve">
          <source>Note: exec, run, and explain also support parameter substitution.</source>
          <target state="translated">참고 : exec, run 및 Explain은 매개 변수 대체도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c256885553501e3fcd67fb31c3651f0b8df34e96" translate="yes" xml:space="preserve">
          <source>Now that we have the function implemented, it needs to be compiled and included in a jar. You will need to build pig.jar to compile your UDF. You can use the following set of commands to checkout the code from SVN repository and create pig.jar:</source>
          <target state="translated">이제 함수를 구현 했으므로 컴파일하여 jar에 포함시켜야합니다. UDF를 컴파일하려면 pig.jar을 빌드해야합니다. 다음 명령 세트를 사용하여 SVN 저장소에서 코드를 체크 아웃하고 pig.jar을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb88ad100d7880e07c6d760abded0864a9d02ad0" translate="yes" xml:space="preserve">
          <source>Now the following script will ran:</source>
          <target state="translated">이제 다음 스크립트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2d994aef96688f7037755c22498e05bc932790" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A by the first field to form relation X.</source>
          <target state="translated">이제 관계 A를 첫 번째 필드로 그룹화하여 관계 X를 형성한다고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="80712e1ab7247b5e2bf95f9c76ec0fce22fb65e3" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A on field &quot;age&quot; for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named &quot;group&quot; and is type int, the same as field &quot;age&quot; in relation A. The second field is name &quot;A&quot; after relation A and is type bag.</source>
          <target state="translated">이제 양식 B의 필드 &quot;연령&quot;에 관계 A를 그룹화한다고 가정하십시오. DESCRIBE 및 ILLUSTRATE 연산자를 사용하여 관계 B의 구조를 검사 할 수 있습니다. 관계 B에는 두 개의 필드가 있습니다. 첫 번째 필드는 &quot;group&quot;으로 이름 지정되며 관계 A의 &quot;age&quot;필드와 동일한 int 유형입니다. 두 번째 필드는 관계 A 뒤에 &quot;A&quot;라는 이름이 있으며 bag 유형입니다.</target>
        </trans-unit>
        <trans-unit id="217dc9412f1631b0d14b11b385eb5f1c8fece4f7" translate="yes" xml:space="preserve">
          <source>Now, you can assert that a0 column in your data is &amp;gt;0, fail if otherwise</source>
          <target state="translated">이제 데이터의 a0 열이&amp;gt; 0이라고 주장 할 수 있습니다. 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b5fa110064ef2aba05aa7955d4237db465bf6269" translate="yes" xml:space="preserve">
          <source>Null Operators</source>
          <target state="translated">널 연산자</target>
        </trans-unit>
        <trans-unit id="d723cf2b44d40a1ac71aeacb0490bce050f06594" translate="yes" xml:space="preserve">
          <source>Null operator:</source>
          <target state="translated">널 연산자 :</target>
        </trans-unit>
        <trans-unit id="9a0b4f0bceedd8bee0e9f98e565c8e1a7a905e08" translate="yes" xml:space="preserve">
          <source>Nulls and Constants</source>
          <target state="translated">널과 상수</target>
        </trans-unit>
        <trans-unit id="f8e886cfbe6cffa98e03a6ad89d5caf8d8cf99de" translate="yes" xml:space="preserve">
          <source>Nulls and GROUP/COGROUP Operators</source>
          <target state="translated">널 및 GROUP / COGROUP 연산자</target>
        </trans-unit>
        <trans-unit id="9d0af334fae1ee9bc62facfa1200db1ece9b07c4" translate="yes" xml:space="preserve">
          <source>Nulls and JOIN Operator</source>
          <target state="translated">널과 조인 연산자</target>
        </trans-unit>
        <trans-unit id="0b3c1a0927de16437ff4e83643fa705f3fbadba3" translate="yes" xml:space="preserve">
          <source>Nulls and Load Functions</source>
          <target state="translated">널과로드 함수</target>
        </trans-unit>
        <trans-unit id="d3eb7d232fed3cb6080570b64943cc8ecee344e0" translate="yes" xml:space="preserve">
          <source>Nulls and Pig Latin</source>
          <target state="translated">널과 돼지 라틴어</target>
        </trans-unit>
        <trans-unit id="6da7a1f37680b518d10a94f89d73ceb2846a7f55" translate="yes" xml:space="preserve">
          <source>Nulls are considered smaller than evertyhing. If data contains null keys, they should occur before anything else.</source>
          <target state="translated">널은 영원보다 작은 것으로 간주됩니다. 데이터에 널 키가 포함 된 경우 다른 키보다 먼저 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="e071444e347313a47d45e426ba220f983bb2317e" translate="yes" xml:space="preserve">
          <source>Nulls can be used as constant expressions in place of expressions of any type.</source>
          <target state="translated">널은 모든 유형의 표현식 대신 상수 표현식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1208e9e89c0a8cbfe9919e6706a3a570ae6c30f8" translate="yes" xml:space="preserve">
          <source>Nulls, Operators, and Functions</source>
          <target state="translated">널, 연산자 및 함수</target>
        </trans-unit>
        <trans-unit id="67b2f87c7a2f07028b46ec3058b64c67312a49b0" translate="yes" xml:space="preserve">
          <source>Numerics take a prefix modifier: , for locale-specific thousands-delimiting, 0 for zero-padding; + to always show a plus sign for positive numbers; space  to allow a space preceding positive numbers; ( to indicate negative numbers with parentheses (accountant-style).</source>
          <target state="translated">숫자는 접두사 수정자를 사용합니다. 로케일 별 천 단위 구분의 경우 0, 패딩 0의 경우; +는 항상 양수에 더하기 부호를 표시합니다. 양수 앞에 공백을 허용하는 공백; (괄호 (회계사 스타일)로 음수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e98bff99da15229b9b6d25ba78b508e05e344875" translate="yes" xml:space="preserve">
          <source>ONSCHEMA</source>
          <target state="translated">ONSCHEMA</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="7b09d896b967e0241fb1f8e717db211b19ad86b0" translate="yes" xml:space="preserve">
          <source>OTHERWISE</source>
          <target state="translated">OTHERWISE</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="91ecfe414d0fb8ea8961b0c7b022ed8849f2e096" translate="yes" xml:space="preserve">
          <source>OUTPUT &amp;ndash; Keyword.</source>
          <target state="translated">출력 &amp;ndash; 키워드.</target>
        </trans-unit>
        <trans-unit id="5e8b6c4fabb5fcd98502309908c5ae2f7f3b3d89" translate="yes" xml:space="preserve">
          <source>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] &amp;hellip;] )</source>
          <target state="translated">OUTPUT ({stdout | stderr | 'path'} [디시리얼라이저 사용] [, {stdout | stderr | 'path'} [디시리얼라이저 사용]&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="436316c809cb5512af5763e373c28a63cb305e4d" translate="yes" xml:space="preserve">
          <source>Object[]: Tuple</source>
          <target state="translated">객체 [] : 튜플</target>
        </trans-unit>
        <trans-unit id="a921503fb0dae8fda28f9d3615aba523991068c2" translate="yes" xml:space="preserve">
          <source>Occasionally, users use BinStorage to store their own data. However, because BinStorage is a proprietary binary format, the original data is never in BinStorage - it is always a derivation of some other data.</source>
          <target state="translated">때때로 사용자는 BinStorage를 사용하여 자신의 데이터를 저장합니다. 그러나 BinStorage는 독점적 인 이진 형식이므로 원본 데이터는 절대 BinStorage에 있지 않으며 항상 다른 데이터의 파생입니다.</target>
        </trans-unit>
        <trans-unit id="0bc92801b465b9bb97e55a1a664340f960368994" translate="yes" xml:space="preserve">
          <source>Often user data is stored such that both inputs are already sorted on the join key. In this case, it is possible to join the data in the map phase of a MapReduce job. This provides a significant performance improvement compared to passing all of the data through unneeded sort and shuffle phases.</source>
          <target state="translated">종종 두 입력이 모두 조인 키에서 정렬되도록 사용자 데이터가 저장됩니다. 이 경우, MapReduce 작업의 맵 단계에서 데이터를 결합 할 수 있습니다. 따라서 불필요한 모든 정렬 및 셔플 단계를 통해 모든 데이터를 전달하는 것과 비교하여 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f378e4a14200e531d64d8be58a4840b795824261" translate="yes" xml:space="preserve">
          <source>Often you are not interested in the entire output but rather a sample or top results. In such cases, using LIMIT can yield a much better performance as we push the limit as high as possible to minimize the amount of data travelling through the pipeline.</source>
          <target state="translated">종종 전체 출력에 관심이 없지만 샘플 또는 상위 결과에 관심이 있습니다. 이러한 경우 LIMIT를 사용하면 파이프 라인을 통해 이동하는 데이터의 양을 최소화하기 위해 한계를 가능한 한 높게 설정하면 성능이 훨씬 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf71a41255fb73b5c3854a80e8b93532dd87b916" translate="yes" xml:space="preserve">
          <source>Often you may need to use a simple function that is already provided by standard Java libraries, but for which a &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDF) has not been written. Dynamic invokers allow you to refer to Java functions without having to wrap them in custom UDFs, at the cost of doing some Java reflection on every function call.</source>
          <target state="translated">표준 Java 라이브러리에서 이미 제공했지만 &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; (UDF)가 작성되지 않은 간단한 함수를 사용해야 할 수도 있습니다 . 동적 호출자를 사용하면 모든 함수 호출에서 Java 리플렉션을 수행하는 대신 사용자 정의 UDF로 랩핑하지 않고도 Java 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0734e56926091020e2bafbec598196d6c34bd12" translate="yes" xml:space="preserve">
          <source>Omit line numbers in the list.</source>
          <target state="translated">목록에서 줄 번호를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="5922013b0865acdbeeb785909913820c1e623db4" translate="yes" xml:space="preserve">
          <source>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</source>
          <target state="translated">UTF-8 시스템에서는 'abc'와 같은 인쇄 가능한 ASCII 문자로 구성된 문자열 상수를 지정할 수 있습니다. '\ t'와 같은 제어 문자를 지정할 수 있습니다. '\ u'로 시작하여 유니 코드로 문자를 지정할 수 있습니다. 예를 들어, '\ u0001'은 16 진수로 Ctrl-A를 나타냅니다 (Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 참조&lt;/a&gt; ). 이론적으로, 비 UTF-8 시스템에서 비 UTF-8 상수를 지정할 수 있어야하지만 테스트되지 않은 것으로 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccca353eb6301c93d9f86e365716c6debf47b6c" translate="yes" xml:space="preserve">
          <source>On the non-trivial queries (one ran longer than a couple of minutes) we saw significant improvements both in terms of query latency and space usage. For some queries we saw up to 96% disk saving and up to 4x query speed up. Of course, the performance characteristics are very much query and data dependent and testing needs to be done to determine gains. We did not see any slowdown in the tests we peformed which means that you are at least saving on space while using compression.</source>
          <target state="translated">사소하지 않은 쿼리 (2 분 이상 실행 된 쿼리)에서 쿼리 대기 시간과 공간 사용량 측면에서 크게 개선되었습니다. 일부 쿼리의 경우 최대 96 %의 디스크 절약 및 최대 4 배의 쿼리 속도가 나타났습니다. 물론 성능 특성은 쿼리에 매우 의존적이며 데이터에 따라 달라지며 이득을 결정하기 위해 테스트를 수행해야합니다. 우리가 수행 한 테스트에서 속도가 느려지지 않았으므로 압축을 사용하는 동안 최소한 공간을 절약하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c24fbf5c7d7120112ceec12106504825249996b" translate="yes" xml:space="preserve">
          <source>One case where pushing filters up might not be a good idea is if the cost of applying filter is very high and only a small amount of data is filtered out.</source>
          <target state="translated">필터를 올리는 것이 좋지 않은 경우는 필터 적용 비용이 매우 높고 소량의 데이터 만 필터링되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c2cbc2e2cd29c7b36db51b7156f79f696494a899" translate="yes" xml:space="preserve">
          <source>One downside of MapReduce is the startup cost for a job is very high. That hurts the performance especially for small job. Tez alleviate the problem by using session and container reuse, so it is not necessary to start an application master for every job, and start a JVM for every task. By default, session/container reuse is on and we usually shall not turn it off. JVM reuse might cause some side effect if static variable is used since static variable might live across different jobs. So if static variable is used in EvalFunc/LoadFunc/StoreFunc, be sure to implement a cleanup function and register with &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;.</source>
          <target state="translated">MapReduce의 한 가지 단점은 작업 시작 비용이 매우 높다는 것입니다. 특히 소규모 작업의 경우 성능이 저하됩니다. Tez는 세션 및 컨테이너 재사용을 사용하여 문제점을 완화하므로 모든 작업에 대해 애플리케이션 마스터를 시작하고 모든 태스크에 대해 JVM을 시작할 필요는 없습니다. 기본적으로 세션 / 컨테이너 재사용은 켜져 있으며 일반적으로 끄지 않아야합니다. 정적 변수가 다른 작업간에 존재할 수 있으므로 정적 변수를 사용하는 경우 JVM 재사용으로 인해 부작용이 발생할 수 있습니다. 따라서 EvalFunc / LoadFunc / StoreFunc에서 정적 변수를 사용하는 경우 정리 함수를 구현하고 &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager에&lt;/a&gt; 등록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="01399f316fca8487fd4f55faaee3ac7bb6836292" translate="yes" xml:space="preserve">
          <source>One more note about schemas and UDFs. Users have requested the ability to examine the input schema of the data before processing the data via a UDF. For example, they would like to know how to convert an input tuple to a map such that the keys in the map are the names of the input columns. Currently there is no way to do this. This is a feature we would like to support in the future.</source>
          <target state="translated">스키마 및 UDF에 대한 추가 참고 사항 사용자는 UDF를 통해 데이터를 처리하기 전에 데이터의 입력 스키마를 검사하는 기능을 요청했습니다. 예를 들어, 맵의 키가 입력 열의 이름이되도록 입력 튜플을 맵으로 변환하는 방법을 알고 싶습니다. 현재는이를 수행 할 방법이 없습니다. 향후 지원하고자하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="86b1a003236c7726fc8c1ef65c53f5899623c990" translate="yes" xml:space="preserve">
          <source>One or more Pig Latin statements, enclosed in curly brackets.</source>
          <target state="translated">중괄호로 묶인 하나 이상의 Pig Latin 문.</target>
        </trans-unit>
        <trans-unit id="cb292bd04b825808a658558eceff1f99e3746de2" translate="yes" xml:space="preserve">
          <source>One problem that users run into is when they make assumption about how many times a constructor for their UDF is called. For instance, they might be creating side files in the store function and doing it in the constructor seems like a good idea. The problem with this approach is that in most cases Pig instantiates functions on the client side to, for instance, examine the schema of the data.</source>
          <target state="translated">사용자가 겪는 한 가지 문제점은 UDF 생성자가 몇 번 호출되는지 가정 할 때입니다. 예를 들어, 상점 기능에서 부가 파일을 작성하고 생성자에서 작성하는 것이 좋은 생각 인 것 같습니다. 이 방법의 문제점은 대부분의 경우 Pig가 클라이언트 측에서 함수를 인스턴스화하여 예를 들어 데이터의 스키마를 검사한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="768e440f42a11fcbfa95a4b6852f49f12632d6f7" translate="yes" xml:space="preserve">
          <source>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</source>
          <target state="translated">ship 옵션을 사용하여 디렉토리가 아닌 파일 만 지정할 수 있습니다. 이 제한을 해결하는 한 가지 방법은 모든 종속성을 계산 노드에 필요한 구조를 정확하게 반영하는 tar 파일로 tar 한 다음 실행 전에 종속성을 untar하는 스크립트 래퍼를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f500bcae0ac1d9a7f69a316f1483fc4cc7418c1" translate="yes" xml:space="preserve">
          <source>Only left outer join is supported for replicated joins.</source>
          <target state="translated">복제 된 조인에는 왼쪽 외부 조인 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="98c134b4570970f85b7a28cd1d729744bbdd592f" translate="yes" xml:space="preserve">
          <source>Only methods annotated with either @OutputSchema or @OutputSchemaFunction will be exposed to Pig as UDFs. In the example above, squareSchema will not be available in Pig as a UDF.</source>
          <target state="translated">@OutputSchema 또는 @OutputSchemaFunction으로 주석이 달린 메소드 만 Pig에 UDF로 노출됩니다. 위의 예에서 squareSchema는 Pig에서 UDF로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7404c733035e01f2951203e52a17f2d7b25c3f70" translate="yes" xml:space="preserve">
          <source>Only primitives can be used for numbers; no capital-letter numeric classes can be used as arguments. Depending on the return type, a specific kind of invoker must be used: InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, or InvokeForFloat.</source>
          <target state="translated">숫자에는 프리미티브 만 사용할 수 있습니다. 대문자로 된 숫자 클래스는 인수로 사용할 수 없습니다. 반환 유형에 따라 InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble 또는 InvokeForFloat와 같은 특정 종류의 호출자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c500f72032e0fffa7307e38303bd6bd22f060e21" translate="yes" xml:space="preserve">
          <source>Operations That Produce Nulls</source>
          <target state="translated">널을 생성하는 연산</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="6c7f4f579b94c45bf7d1ec93c8760a07327897b1" translate="yes" xml:space="preserve">
          <source>Optimization Rules</source>
          <target state="translated">최적화 규칙</target>
        </trans-unit>
        <trans-unit id="04659a29a038f8b6f95d9df28a89681d94dc2803" translate="yes" xml:space="preserve">
          <source>Optimization can also be achieved using fragment replicate joins, skewed joins, and merge joins. For more information see &lt;a href=&quot;perf#specialized-joins&quot;&gt;Specialized Joins&lt;/a&gt;.</source>
          <target state="translated">조각 복제 조인, 기울어 진 조인 및 병합 조인을 사용하여 최적화를 수행 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;perf#specialized-joins&quot;&gt;특수 조인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f92b41bb13aa91ef73f2405bc184ea22fe7ab53" translate="yes" xml:space="preserve">
          <source>Optimization for regular joins ensures that the last table in the join is not brought into memory but streamed through instead. Optimization reduces the amount of memory used which means you can avoid spilling the data and also should be able to scale your query to larger data volumes.</source>
          <target state="translated">일반 조인을 최적화하면 조인의 마지막 테이블이 메모리로 가져 오지 않고 대신 스트리밍됩니다. 최적화는 사용되는 메모리 양을 줄이므로 데이터 유출을 피할 수 있으며 쿼리를 더 큰 데이터 볼륨으로 확장 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8766608ab14ae4c0ace8e4aee51b7a378f862b8" translate="yes" xml:space="preserve">
          <source>Optional items:</source>
          <target state="translated">선택 품목 :</target>
        </trans-unit>
        <trans-unit id="9efc8753c1e4995cd0d1185902d8c3c9200a5b32" translate="yes" xml:space="preserve">
          <source>Optional keyword. Designates a default relation.</source>
          <target state="translated">선택적 키워드. 기본 관계를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f9d88b237b4a78d338edf7da6c0b3e11382d6f4d" translate="yes" xml:space="preserve">
          <source>Optional tuple representing constant parameters of a Hive UDF/UDTF/UDAF. If Hive UDF requires a constant parameter, there is no other way Pig can pass that information to Hive, since Pig schema does not carry the information whether a parameter is constant or not. Null item in the tuple means this field is not a constant. Non-null item represents a constant field. Data type for the item is determined by Pig contant parser.</source>
          <target state="translated">Hive UDF / UDTF / UDAF의 상수 매개 변수를 나타내는 선택적 튜플. Hive UDF에 상수 매개 변수가 필요한 경우 Pig 스키마는 매개 변수가 상수인지 여부에 관계없이 정보를 전달하지 않기 때문에 Pig가 해당 정보를 Hive에 전달할 수있는 다른 방법이 없습니다. 튜플의 Null 항목은이 필드가 상수가 아님을 의미합니다. 널이 아닌 항목은 상수 필드를 나타냅니다. 항목의 데이터 유형은 Pig contant 파서에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="371b0ae2ff2ab087176f32bee166d4da2913bff3" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark local mode:</source>
          <target state="translated">또는 Spark 로컬 모드를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="095b0c2883ec0b939fed65357c1b04420e296e0a" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark:</source>
          <target state="translated">또는 Spark를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="907c1518b24f449be57666853914f303931b978f" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez local mode:</source>
          <target state="translated">또는 Tez 로컬 모드를 사용중인 경우 :</target>
        </trans-unit>
        <trans-unit id="5a4c4c74b3f7d241b86e5336001adb11c6de88bf" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez:</source>
          <target state="translated">또는 Tez를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="4c9450cd3b04d1fd47af444a11a91bb90f9a49d5" translate="yes" xml:space="preserve">
          <source>Orc BYTE/BINARY all map to Pig bytearray</source>
          <target state="translated">오크 바이트 / 바이너리 모두 돼지 바이트 어레이에 매핑</target>
        </trans-unit>
        <trans-unit id="b510b6858c4b9765788f82d0e9c521f50419cd2f" translate="yes" xml:space="preserve">
          <source>Orc DECIMAL maps to Pig bigdecimal</source>
          <target state="translated">오크 DECIMAL은 돼지 bigdecimal에 매핑</target>
        </trans-unit>
        <trans-unit id="9961f1b05ddf0fc66a4ab6a46c676c806aebb176" translate="yes" xml:space="preserve">
          <source>Orc STRING/CHAR/VARCHAR all map to Pig varchar</source>
          <target state="translated">오크 STRING / CHAR / VARCHAR 모든 돼지 varchar에 매핑</target>
        </trans-unit>
        <trans-unit id="6d27972086aacd281681114b9c28fd369d9c4b9f" translate="yes" xml:space="preserve">
          <source>Orc TIMESTAMP/DATE all maps to Pig datetime</source>
          <target state="translated">오크 TIMESTAMP / DATE 모든 돼지 날짜 / 시간 맵</target>
        </trans-unit>
        <trans-unit id="a1591da02510a2712f04308058e399add5eca1dd" translate="yes" xml:space="preserve">
          <source>OrcStorage</source>
          <target state="translated">OrcStorage</target>
        </trans-unit>
        <trans-unit id="4c9f23c645f12bfa00bd50f98ef015ca573fdaf2" translate="yes" xml:space="preserve">
          <source>OrcStorage as a LoadFunc.</source>
          <target state="translated">LoadFunc로서의 OrcStorage.</target>
        </trans-unit>
        <trans-unit id="3eb7b9cec1cdd27213bef34fc6170acf9fdd4faa" translate="yes" xml:space="preserve">
          <source>OrcStorage as a StoreFunc.</source>
          <target state="translated">StoreFunc로서의 OrcStorage.</target>
        </trans-unit>
        <trans-unit id="469606f67e8335e115993b24e3f6965fc1459c33" translate="yes" xml:space="preserve">
          <source>OrcStorage predicate pushdown currently support all primitive data types but none of the complex data types. For example, map condition cannot push into OrcStorage:</source>
          <target state="translated">OrcStorage 술어 푸시 다운은 현재 모든 기본 데이터 유형을 지원하지만 복잡한 데이터 유형은 지원하지 않습니다. 예를 들어 맵 조건은 OrcStorage로 푸시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bfcf8f6cfd1ff12ec733abbdfb29a53dcdc9dcc" translate="yes" xml:space="preserve">
          <source>OrcStorage(['options'])</source>
          <target state="translated">OrcStorage(['options'])</target>
        </trans-unit>
        <trans-unit id="d0fe29562a7c21056884a2c410f56a9812b54c99" translate="yes" xml:space="preserve">
          <source>Original Avro Types</source>
          <target state="translated">오리지널 아브로 타입</target>
        </trans-unit>
        <trans-unit id="882617723625c587393c99fb5f6b0d0cf3ad5a0e" translate="yes" xml:space="preserve">
          <source>Original Pig Type</source>
          <target state="translated">오리지널 피그 타입</target>
        </trans-unit>
        <trans-unit id="be0be73dfa142afb06644b4bd429b15778e4bac4" translate="yes" xml:space="preserve">
          <source>Other Modes</source>
          <target state="translated">다른 모드</target>
        </trans-unit>
        <trans-unit id="ebe6018e98731e126f80812a6b4853d5ee2275d6" translate="yes" xml:space="preserve">
          <source>Other properties</source>
          <target state="translated">다른 속성</target>
        </trans-unit>
        <trans-unit id="701a7e9210bdedb5978458dbeba9fb2d822971a2" translate="yes" xml:space="preserve">
          <source>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from /bin, /usr/bin, /usr/local/bin. Pig will determine this by scanning the path if an absolute path is provided or by executing which. The paths can be made configurable using the &lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt; option (you can use multiple set commands to specify more than one path to skip).</source>
          <target state="translated">그렇지 않으면 Pig는 / bin, / usr / bin, / usr / local / bin에서 오는 것이 아니라면 명령 줄에서 첫 번째 문자열을 전달하려고 시도합니다. Pig는 절대 경로가 제공되면 경로를 스캔하거나 어느 경로를 실행하여이를 결정합니다. &lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt; 옵션을 사용하여 경로를 구성 할 수 있습니다 (여러 set 명령을 사용하여 건너 뛸 둘 이상의 경로를 지정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a338e1e79d114a1522d9eb5979c8db612a93073a" translate="yes" xml:space="preserve">
          <source>Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">그렇지 않으면 RANK 연산자는 각 필드 (또는 필드 세트)를 사용하여 관계를 정렬합니다. 튜플의 순위는 1에 다른 순위 값의 수를 더한 값입니다. 둘 이상의 튜플이 정렬 필드 값에 연결되면 동일한 순위를받습니다.</target>
        </trans-unit>
        <trans-unit id="5cd2e1cb8ff03e85d7add8f6016467a3f5e57d79" translate="yes" xml:space="preserve">
          <source>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</source>
          <target state="translated">외부 조인은 양방향 조인에만 적용됩니다. 다 방향 외부 결합을 수행하려면 다중 양방향 외부 결합 명령문을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="600054c2fe7432d844752d909a7af30d0a800923" translate="yes" xml:space="preserve">
          <source>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</source>
          <target state="translated">외부 조인은 null을 생성해야하는 관계 (일치하지 않는 키의 경우)에 스키마가있는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c746f245398c7408bb6df1ccfc1430c711902402" translate="yes" xml:space="preserve">
          <source>Outer merge join (between two tables) and inner merge join (between three or more tables) will only work under these conditions:</source>
          <target state="translated">외부 병합 조인 (두 테이블 간) 및 내부 병합 조인 (3 개 이상의 테이블 간)은 다음 조건에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0d2a263550d66b9f4e2dd5cc2ce0bd6b5aa3b982" translate="yes" xml:space="preserve">
          <source>Output location strict check</source>
          <target state="translated">출력 위치 엄격한 점검</target>
        </trans-unit>
        <trans-unit id="c5729f9b287de5b3dfc0238cb6432a164885bc6a" translate="yes" xml:space="preserve">
          <source>Output schema</source>
          <target state="translated">출력 스키마</target>
        </trans-unit>
        <trans-unit id="f1657b858c692a8810b394c9fbe10ef1f3ebefa9" translate="yes" xml:space="preserve">
          <source>OutputStats</source>
          <target state="translated">OutputStats</target>
        </trans-unit>
        <trans-unit id="efbc45e086170113898fb269e6cf4a872cd68ed5" translate="yes" xml:space="preserve">
          <source>Overall you would create a file that looks like this (assume we call it niels.kerberos.properties):</source>
          <target state="translated">전반적으로 다음과 같은 파일을 작성합니다 (이를 niels.kerberos.properties라고 가정).</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="96ce24f1a92e6b30382bcf71beddd1d02bbf7658" translate="yes" xml:space="preserve">
          <source>PARALLEL n</source>
          <target state="translated">평행 한 n</target>
        </trans-unit>
        <trans-unit id="b00fec6efa227099463e118d74a38da9dc9e323c" translate="yes" xml:space="preserve">
          <source>PARTITION BY partitioner</source>
          <target state="translated">파티 셔 너별 파티션</target>
        </trans-unit>
        <trans-unit id="2b338af39aea20defe562c404d22d384da1fb4d9" translate="yes" xml:space="preserve">
          <source>Parallel Execution</source>
          <target state="translated">병렬 실행</target>
        </trans-unit>
        <trans-unit id="58171bd8fa88aa62d26baf06d454a174292bf115" translate="yes" xml:space="preserve">
          <source>Parallel joins are vulnerable to the presence of skew in the underlying data. If the underlying data is sufficiently skewed, load imbalances will swamp any of the parallelism gains. In order to counteract this problem, skewed join computes a histogram of the key space and uses this data to allocate reducers for a given key. Skewed join does not place a restriction on the size of the input keys. It accomplishes this by splitting the left input on the join predicate and streaming the right input. The left input is sampled to create the histogram.</source>
          <target state="translated">병렬 조인은 기본 데이터의 기울어 짐에 취약합니다. 기본 데이터가 충분히 왜곡되면로드 불균형으로 인해 병렬 처리 게인이 좁아집니다. 이 문제를 해결하기 위해 기울어 진 조인은 키 공간의 히스토그램을 계산하고이 데이터를 사용하여 지정된 키에 대한 감속기를 할당합니다. 비뚤어진 조인은 입력 키의 크기를 제한하지 않습니다. 결합 술어에서 왼쪽 입력을 분할하고 오른쪽 입력을 스트리밍하여이를 수행합니다. 왼쪽 입력은 히스토그램을 만들기 위해 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="3375c065590ef4a44f56b15335a0387a3cccbc5a" translate="yes" xml:space="preserve">
          <source>Parameter Substitution</source>
          <target state="translated">매개 변수 대체</target>
        </trans-unit>
        <trans-unit id="7790c9a165b0c914283a93f7037cf0b0cc4cb830" translate="yes" xml:space="preserve">
          <source>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed.</source>
          <target state="translated">매개 변수 파일은 명령 행에 지정된 순서대로 스캔됩니다. 각 파일 내에서 매개 변수는 나열된 순서대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="70117576ffa2ad03e5513ff9b3fbd512b8641d45" translate="yes" xml:space="preserve">
          <source>Parameter names are case insensitive.</source>
          <target state="translated">매개 변수 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6466211ad9aa97ba4dc313d987046ab6af23120" translate="yes" xml:space="preserve">
          <source>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods.</source>
          <target state="translated">매개 변수 대체를 사용하면 매개 변수가 포함 된 Pig 스크립트를 작성하고 런타임에 이러한 매개 변수의 값을 제공 할 수 있습니다. 예를 들어, 현재 날짜의 데이터를 사용하여 매일 실행해야하는 작업이 있다고 가정하십시오. 날짜에 대한 매개 변수를 포함하는 Pig 스크립트를 작성할 수 있습니다. 그런 다음이 스크립트를 실행할 때 지원되는 방법 중 하나를 사용하여 날짜 매개 변수의 값을 지정하거나 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f69e14d703d0fb6cfc378c0a831efb4f72f66bf1" translate="yes" xml:space="preserve">
          <source>Parameter substitution may be used inside of macros. When there are conflicts between names of parameters defined at the top level and names of arguments or return values for a given macro, then ones inside the macro are used. See &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (macros)&lt;/a&gt;.</source>
          <target state="translated">매크로 내에서 매개 변수 대체를 사용할 수 있습니다. 최상위 레벨에 정의 된 매개 변수 이름과 주어진 매크로에 대한 인수 이름 또는 리턴 값 사이에 충돌이있는 경우 매크로 내부의 이름이 사용됩니다. &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (매크로)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c256c12a753b5b6bd6decc3861da77cc5d8f2234" translate="yes" xml:space="preserve">
          <source>Parameters Supported in the Query String</source>
          <target state="translated">쿼리 문자열에서 지원되는 매개 변수</target>
        </trans-unit>
        <trans-unit id="769003fbcc6fc353a4044c923e34ca968752f228" translate="yes" xml:space="preserve">
          <source>Parameters are processed as follows:</source>
          <target state="translated">매개 변수는 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0074ddadeda7d41356f958931e0fcd57e8b79c9b" translate="yes" xml:space="preserve">
          <source>Parameters defined in parameter files specified by -param_file</source>
          <target state="translated">-param_file로 지정된 매개 변수 파일에 정의 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="70543f43b0b77a80afe0d18b065682a97d7fcc6d" translate="yes" xml:space="preserve">
          <source>Parameters defined in the command line using -param</source>
          <target state="translated">-param을 사용하여 명령 행에 정의 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="e7a454f5498afc7a5bd9a3b2032372bdf7551245" translate="yes" xml:space="preserve">
          <source>Parameters defined using the declare statement</source>
          <target state="translated">선언문을 사용하여 정의 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="7030e575509b3a9849a213f50450f6c3ea2b9a16" translate="yes" xml:space="preserve">
          <source>Parameters defined using the default statement</source>
          <target state="translated">기본 명령문을 사용하여 정의 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="ef98d6e375037bebdef260ca6d55bd8ab3dd0e64" translate="yes" xml:space="preserve">
          <source>Parentheses are also used to indicate the tuple data type.</source>
          <target state="translated">괄호는 튜플 데이터 형식을 나타내는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc4e9e14a7a05acd86ecf4b274ad71ee33e5bcd" translate="yes" xml:space="preserve">
          <source>Parentheses enclose one or more items.</source>
          <target state="translated">괄호는 하나 이상의 항목을 묶습니다.</target>
        </trans-unit>
        <trans-unit id="9277a0569e80e9b319b019aefc95b0225b6e8571" translate="yes" xml:space="preserve">
          <source>PartitionFilterOptimizer</source>
          <target state="translated">PartitionFilterOptimizer</target>
        </trans-unit>
        <trans-unit id="97a0e02c60f7bd5b056aeeb4d721b45b24381261" translate="yes" xml:space="preserve">
          <source>Partitions a relation into two or more relations.</source>
          <target state="translated">관계를 둘 이상의 관계로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="5fffb570a05163ec7d3a9ee94c710223f45deb55" translate="yes" xml:space="preserve">
          <source>Passing Configurations to UDFs</source>
          <target state="translated">UDF로 구성 전달</target>
        </trans-unit>
        <trans-unit id="900e8b0d2c1088af54281fa7b734ee24070da72e" translate="yes" xml:space="preserve">
          <source>Passing Parameters to a Script</source>
          <target state="translated">스크립트에 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="30e96c64e3d87a1b3ae0dcab374223bf047c1fd7" translate="yes" xml:space="preserve">
          <source>Passing a Pig Script</source>
          <target state="translated">돼지 스크립트 전달</target>
        </trans-unit>
        <trans-unit id="bc0b27a7477f8ed02a5b4c719673367cbbf610fe" translate="yes" xml:space="preserve">
          <source>Perform a bloom join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations. Bloom filter is built from join keys of the right most relation which is small and the filter is applied on the big and medium relations. None of the relations are required to fit into main memory.</source>
          <target state="translated">USING 절로 블룸 조인을 수행하십시오 ( &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (내부)&lt;/a&gt; 및 &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (외부) 참조&lt;/a&gt; ). 이 예에서 큰 관계는 두 개의 작은 관계로 연결됩니다. 큰 관계가 먼저 이어지고 더 작은 관계가옵니다. 블룸 필터는 가장 작은 관계의 조인 키로 구성되며 필터는 대 / 중 관계에 적용됩니다. 메인 메모리에 맞는 관계는 없습니다.</target>
        </trans-unit>
        <trans-unit id="67969b99648d91d1035f722084db31dddca473ad" translate="yes" xml:space="preserve">
          <source>Perform a merge join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">USING 절로 병합 결합을 수행하십시오 ( &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (내부)&lt;/a&gt; 및 &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (외부) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd5572ed8b373fc67c4f3724a55aa798b14ca3c3" translate="yes" xml:space="preserve">
          <source>Perform a merge-sparse join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt;).</source>
          <target state="translated">USING 절로 병합 스파 스 조인을 수행하십시오 ( &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (내부)&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="402e4b589f5a0d62e1e68cc5769ea6fe810721f3" translate="yes" xml:space="preserve">
          <source>Perform a replicated join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations; and, all small relations together must fit into main memory, otherwise an error is generated.</source>
          <target state="translated">USING 절로 복제 된 결합을 수행하십시오 ( &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (내부)&lt;/a&gt; 및 &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (외부) 참조&lt;/a&gt; ). 이 예에서 큰 관계는 두 개의 작은 관계로 연결됩니다. 큰 관계가 먼저 이어지고 더 작은 관계가 나옵니다. 그리고 모든 작은 관계는 기본 메모리에 맞아야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f464de18fcec5cc28885815dcee4e7667a7ec7e" translate="yes" xml:space="preserve">
          <source>Perform a skewed join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">USING 절로 비뚤어진 조인을 수행하십시오 ( &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (내부)&lt;/a&gt; 및 &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (외부) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3130994b43da1d8950109e1c6564a8348e9d6104" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
          <target state="translated">성능 고려 사항</target>
        </trans-unit>
        <trans-unit id="f24e3938bb4e4cb45e3fceea03006c92f75688c9" translate="yes" xml:space="preserve">
          <source>Performance Enhancers</source>
          <target state="translated">성능 향상제</target>
        </trans-unit>
        <trans-unit id="25a6857524ecb9afe00595831a6eabce0d0dfafa" translate="yes" xml:space="preserve">
          <source>Performance and Efficiency</source>
          <target state="translated">성능 및 효율성</target>
        </trans-unit>
        <trans-unit id="8f76637cf34db3a94cdd1b0e2b9af4d58294a730" translate="yes" xml:space="preserve">
          <source>Performs an inner join of two or more relations based on common field values.</source>
          <target state="translated">공통 필드 값을 기반으로 둘 이상의 관계의 내부 결합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1e1e34d4c871c8f4da9be20b9f4469a363f98b73" translate="yes" xml:space="preserve">
          <source>Performs an outer join of two relations based on common field values.</source>
          <target state="translated">공통 필드 값을 기반으로 두 관계의 외부 조인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cad8be75b29842759141027890e92f4432bb017a" translate="yes" xml:space="preserve">
          <source>Performs cube/rollup operations.</source>
          <target state="translated">큐브 / 롤업 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d24cf8c587230b4ed2537a805a07c9584dcfb6ca" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts all matched groups.</source>
          <target state="translated">정규식 일치를 수행하고 일치하는 모든 그룹을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9018076e46e8c3ab55cf8633b09942355fa4aec9" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts the matched group defined by an index parameter.</source>
          <target state="translated">정규식 일치를 수행하고 색인 매개 변수로 정의 된 일치 그룹을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ebeb13a8133f2d73bb66dcd9301c11a7ab8ac32f" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and searches all matched characters in a string.</source>
          <target state="translated">정규식 일치를 수행하고 문자열에서 일치하는 모든 문자를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="28e7ba6ea4395e9894a796bb57462b156a7c5827" translate="yes" xml:space="preserve">
          <source>Pig JAR file</source>
          <target state="translated">돼지 JAR 파일</target>
        </trans-unit>
        <trans-unit id="92283693de8e1c937c436504772afa7e54d4d779" translate="yes" xml:space="preserve">
          <source>Pig Latin Basics</source>
          <target state="translated">돼지 라틴 기본</target>
        </trans-unit>
        <trans-unit id="278a8301cb0641c9a4edbfd68852047e3b82ffe2" translate="yes" xml:space="preserve">
          <source>Pig Latin Statements</source>
          <target state="translated">돼지 라틴어 진술</target>
        </trans-unit>
        <trans-unit id="abe1ac30b366cc27ad64f6b2a535541e0d5bd848" translate="yes" xml:space="preserve">
          <source>Pig Latin operators and functions interact with nulls as shown in this table.</source>
          <target state="translated">Pig Latin 연산자 및 함수는이 표에 표시된대로 널과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="3c6a60413a273559ed0f210ce1379e5ecd049483" translate="yes" xml:space="preserve">
          <source>Pig Latin provides operators that can help you debug your Pig Latin statements:</source>
          <target state="translated">Pig Latin은 Pig Latin 문을 디버깅하는 데 도움이되는 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f38d85519e485d8e2d061fcc97d35bf4ac9736e0" translate="yes" xml:space="preserve">
          <source>Pig Latin statement:</source>
          <target state="translated">돼지 라틴어 성명서 :</target>
        </trans-unit>
        <trans-unit id="aafb100d0f8b7f3882c6325c161b1a4b645fc993" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are generally organized as follows:</source>
          <target state="translated">돼지 라틴어 문장은 일반적으로 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dfefbefcd550d25bef5229b93a8fd8ba2bde0953" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are the basic constructs you use to process data using Pig. A Pig Latin statement is an operator that takes a &lt;a href=&quot;basic#relations&quot;&gt;relation&lt;/a&gt; as input and produces another relation as output. (This definition applies to all Pig Latin operators except LOAD and STORE which read data from and write data to the file system.) Pig Latin statements may include &lt;a href=&quot;basic#expressions&quot;&gt;expressions&lt;/a&gt; and &lt;a href=&quot;basic#schemas&quot;&gt;schemas&lt;/a&gt;. Pig Latin statements can span multiple lines and must end with a semi-colon ( ; ). By default, Pig Latin statements are processed using &lt;a href=&quot;perf#multi-query-execution&quot;&gt;multi-query execution&lt;/a&gt;.</source>
          <target state="translated">Pig Latin 문은 Pig를 사용하여 데이터를 처리하는 데 사용하는 기본 구성입니다. Pig Latin 문은 &lt;a href=&quot;basic#relations&quot;&gt;관계&lt;/a&gt; 를 입력으로 사용하고 다른 관계를 출력으로 생성 하는 연산자입니다 . (이 정의는 파일 시스템에서 데이터를 읽고 파일 시스템에 데이터를 쓰는 LOAD 및 STORE를 제외한 모든 Pig Latin 연산자에 적용됩니다.) Pig Latin 문은 &lt;a href=&quot;basic#expressions&quot;&gt;표현식&lt;/a&gt; 및 &lt;a href=&quot;basic#schemas&quot;&gt;스키마를&lt;/a&gt; 포함 할 수 있습니다 . Pig Latin 문은 여러 줄에 걸쳐있을 수 있으며 세미콜론 (;)으로 끝나야합니다. 기본적으로 Pig Latin 문은 &lt;a href=&quot;perf#multi-query-execution&quot;&gt;다중 쿼리 실행을&lt;/a&gt; 사용하여 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d6b1b831ea171957ed0e1ca09e2fcb0f0cc8198" translate="yes" xml:space="preserve">
          <source>Pig Latin supports casts as shown in this table.</source>
          <target state="translated">Pig Latin은이 표에 표시된대로 캐스트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d272d6e8e9fd410fba40f8d7f45eb3ef23d66fd5" translate="yes" xml:space="preserve">
          <source>Pig Latin supports the definition, expansion, and import of macros.</source>
          <target state="translated">Pig Latin은 매크로의 정의, 확장 및 가져 오기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a52974cdd3ea4e71d39c1a5b454a4491f41f2366" translate="yes" xml:space="preserve">
          <source>Pig Latin syntax statement:</source>
          <target state="translated">돼지 라틴어 구문 설명 :</target>
        </trans-unit>
        <trans-unit id="a6de2cdfe9e769e638ae13f67688e2ebf50c4116" translate="yes" xml:space="preserve">
          <source>Pig Macros</source>
          <target state="translated">돼지 매크로</target>
        </trans-unit>
        <trans-unit id="4a2ca1d4b92ee91ccc81dde3263e5535ea441ba7" translate="yes" xml:space="preserve">
          <source>Pig Object</source>
          <target state="translated">돼지 개체</target>
        </trans-unit>
        <trans-unit id="9fd1a1cb2d567f7a5ff0480ca9134d87032c5949" translate="yes" xml:space="preserve">
          <source>Pig Progress Notification Listener</source>
          <target state="translated">돼지 진행 알림 리스너</target>
        </trans-unit>
        <trans-unit id="99c542779d91327bc9bd3447f9526c2088c67b88" translate="yes" xml:space="preserve">
          <source>Pig Properties</source>
          <target state="translated">돼지 속성</target>
        </trans-unit>
        <trans-unit id="734f02bedf731c9ba833109c0b94942fe59227b8" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (local mode)</source>
          <target state="translated">Pig Script 1, 쿼리 구문 인기도 (로컬 모드)</target>
        </trans-unit>
        <trans-unit id="0e141603768346ca22cbf8799fa641ebc9a2665a" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">Pig Script 1, 쿼리 구문 인기 (mapreduce 모드)</target>
        </trans-unit>
        <trans-unit id="2da304232e645beee888e58d6826aa40479df310" translate="yes" xml:space="preserve">
          <source>Pig Script 1: Query Phrase Popularity</source>
          <target state="translated">돼지 스크립트 1 : 쿼리 구문 인기도</target>
        </trans-unit>
        <trans-unit id="f9be711a0ed7d8a9d09e991f0c431dfed287b99e" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (local mode)</source>
          <target state="translated">Pig Script 2, 임시 쿼리 구문 인기도 (로컬 모드)</target>
        </trans-unit>
        <trans-unit id="f2397170eecb6952fd14aafebda31090031e9196" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">Pig Script 2, 임시 쿼리 구문 인기도 (mapreduce 모드)</target>
        </trans-unit>
        <trans-unit id="96a4246b4d848f77f5340b34b8f5f9356de36427" translate="yes" xml:space="preserve">
          <source>Pig Script 2: Temporal Query Phrase Popularity</source>
          <target state="translated">돼지 스크립트 2 : 임시 쿼리 구문 인기도</target>
        </trans-unit>
        <trans-unit id="d650e124b03231e4f6e63a60633af92981457281" translate="yes" xml:space="preserve">
          <source>Pig Scripts</source>
          <target state="translated">돼지 스크립트</target>
        </trans-unit>
        <trans-unit id="3711a90b3c1fa50c85635bc7e599451f34dc20e0" translate="yes" xml:space="preserve">
          <source>Pig Scripts and MapReduce Job IDs (MapReduce mode only)</source>
          <target state="translated">Pig 스크립트 및 MapReduce 작업 ID (MapReduce 모드 만 해당)</target>
        </trans-unit>
        <trans-unit id="43590fd010743d8912e0f24af54d70fb5088bcc6" translate="yes" xml:space="preserve">
          <source>Pig Setup</source>
          <target state="translated">돼지 설치</target>
        </trans-unit>
        <trans-unit id="ad6533e178840e687da8395d7e65379f0284aea8" translate="yes" xml:space="preserve">
          <source>Pig Statistics</source>
          <target state="translated">돼지 통계</target>
        </trans-unit>
        <trans-unit id="e124c110e55a5e3fc700ba74964a062c34387574" translate="yes" xml:space="preserve">
          <source>Pig Statistics is a framework for collecting and storing script-level statistics for Pig Latin. Characteristics of Pig Latin scripts and the resulting MapReduce jobs are collected while the script is executed. These statistics are then available for Pig users and tools using Pig (such as Oozie) to retrieve after the job is done.</source>
          <target state="translated">Pig Statistics는 Pig Latin에 대한 스크립트 수준 통계를 수집하고 저장하기위한 프레임 워크입니다. Pig Latin 스크립트의 특성 및 결과 MapReduce 작업은 스크립트가 실행되는 동안 수집됩니다. 그런 다음이 통계는 Pig 사용자 및 Pig (예 : Oozie)를 사용하는 도구가 작업 완료 후 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="612dd975aa5ad31fc345b7a3ddd612ad0616e4ab" translate="yes" xml:space="preserve">
          <source>Pig Tutorial</source>
          <target state="translated">돼지 튜토리얼</target>
        </trans-unit>
        <trans-unit id="4757ba63e67d355d84729fef8914757bf15f22dd" translate="yes" xml:space="preserve">
          <source>Pig Tutorial Files</source>
          <target state="translated">돼지 튜토리얼 파일</target>
        </trans-unit>
        <trans-unit id="f4e3c20276b1374c79d691d19de05b31570ed547" translate="yes" xml:space="preserve">
          <source>Pig Type</source>
          <target state="translated">돼지 형</target>
        </trans-unit>
        <trans-unit id="47775b7064fc01c255082ec71e837ab11cb3bfdc" translate="yes" xml:space="preserve">
          <source>Pig Types and Native Java Types</source>
          <target state="translated">돼지 유형 및 기본 Java 유형</target>
        </trans-unit>
        <trans-unit id="763ba17130114f0d728d2c9da6a94cee2662e38e" translate="yes" xml:space="preserve">
          <source>Pig allocates a fix amount of memory to store bags and spills to disk as soon as the memory limit is reached. This is very similar to how Hadoop decides when to spill data accumulated by the combiner.</source>
          <target state="translated">Pig는 메모리 한계에 도달하자마자 백을 저장하기 위해 고 정량의 메모리를 할당하고 디스크에 유출합니다. 이는 Hadoop이 결합기에 의해 누적 된 데이터를 유출 할시기를 결정하는 방식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="11d7036422db3b031d72375b00787ef03de9aa59" translate="yes" xml:space="preserve">
          <source>Pig allows you to cast the elements of a single-tuple relation into a scalar value. The tuple can be a single-field or multi-field tulple. If the relation contains more than one tuple, however, a runtime error is generated: &quot;Scalar has more than one row in the output&quot;.</source>
          <target state="translated">Pig를 사용하면 단일 튜플 관계의 요소를 스칼라 값으로 캐스트 할 수 있습니다. 튜플은 단일 필드 또는 다중 필드 튜플 일 수 있습니다. 그러나 관계에 둘 이상의 튜플이 포함되어 있으면 런타임 오류가 생성됩니다. &quot;스칼라에 출력에 둘 이상의 행이 있습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="e6f9793557df721a51315601bec2173f9083f743" translate="yes" xml:space="preserve">
          <source>Pig allows you to transform data in many ways. As a starting point, become familiar with these operators:</source>
          <target state="translated">Pig를 사용하면 여러 가지 방법으로 데이터를 변환 할 수 있습니다. 시작점으로 다음 연산자에 익숙해 지십시오.</target>
        </trans-unit>
        <trans-unit id="73604424b7f623aa52673331d4844b85c87dfa4e" translate="yes" xml:space="preserve">
          <source>Pig also provides support for Piggy Bank, a repository for JAVA UDFs. Through Piggy Bank you can access Java UDFs written by other users and contribute Java UDFs that you have written.</source>
          <target state="translated">Pig는 또한 JAVA UDF 저장소 인 Piggy Bank를 지원합니다. Piggy Bank를 통해 다른 사용자가 작성한 Java UDF에 액세스하고 작성한 Java UDF를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2ee3d36a3dc27b7f962519361eb68284ec849ad" translate="yes" xml:space="preserve">
          <source>Pig bigdecimal/biginteger all map to Orc DECIMAL</source>
          <target state="translated">돼지 bigdecimal / biginteger 모든지도에 오크 DECIMAL</target>
        </trans-unit>
        <trans-unit id="5a000788cb7b838a8a19059f606035a562b8829b" translate="yes" xml:space="preserve">
          <source>Pig bytearray maps to Orc BINARY</source>
          <target state="translated">Pig bytearray가 Orc BINARY에 매핑</target>
        </trans-unit>
        <trans-unit id="da371b573e3bcb43e639b2160b5c518b0b7700f1" translate="yes" xml:space="preserve">
          <source>Pig chararray maps to Orc STRING</source>
          <target state="translated">돼지 캐릭터가 오크 STRING에 매핑</target>
        </trans-unit>
        <trans-unit id="7d31dc542bef65e4c473198b27d60992d79d21e7" translate="yes" xml:space="preserve">
          <source>Pig comes with a set of built in functions (the eval, load/store, math, string, bag and tuple functions). Two main properties differentiate built in functions from &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDFs). First, built in functions don't need to be registered because Pig knows where they are. Second, built in functions don't need to be qualified when they are used because Pig knows where to find them.</source>
          <target state="translated">Pig는 내장 함수 세트 (eval, load / store, math, string, bag 및 tuple 함수)와 함께 제공됩니다. 두 가지 주요 속성은 내장 함수를 &lt;a href=&quot;udf&quot;&gt;사용자 정의 함수&lt;/a&gt; (UDF)와 구분합니다. 첫째, 내장 함수는 Pig가 어디에 있는지 알고 있기 때문에 등록 할 필요가 없습니다. 둘째, 내장 함수는 Pig가 그 위치를 알고 있기 때문에 사용될 때 자격을 갖추지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="ec76128e5910a6c0dc476b3ee3f3c86bf0e02469" translate="yes" xml:space="preserve">
          <source>Pig currently drops all STORE and DUMP commands. You can tell PigUnit to keep the commands and execute the script:</source>
          <target state="translated">Pig는 현재 모든 STORE 및 DUMP 명령을 삭제합니다. PigUnit에 명령을 유지하고 스크립트를 실행하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad1529318465104bd4cda2ad68472350964be44" translate="yes" xml:space="preserve">
          <source>Pig currently supports ordering on fields with simple types or by tuple designator (*). You cannot order on fields with complex types or by expressions.</source>
          <target state="translated">Pig는 현재 단순 유형 또는 튜플 지정자 (*)를 사용하여 필드에서 주문을 지원합니다. 복잡한 유형 또는 표현식으로 필드를 주문할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9f5530e025cc570af7472498b65ad3cdc347893" translate="yes" xml:space="preserve">
          <source>Pig datetime maps to Orc TIMESTAMP</source>
          <target state="translated">돼지 날짜 시간이 오크 TIMESTAMP에 매핑</target>
        </trans-unit>
        <trans-unit id="b06635ad448da689ef56ed31a6a822d359c09cd2" translate="yes" xml:space="preserve">
          <source>Pig does not (yet) determine when a field is no longer needed and drop the field from the row. For example, say you have a query like:</source>
          <target state="translated">Pig는 필드가 더 이상 필요하지 않은 시점을 아직 결정하지 않고 행에서 필드를 삭제합니다. 예를 들어 다음과 같은 쿼리가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9e85a8b2e0c0dd60b8ab7196e655a11595d0e5" translate="yes" xml:space="preserve">
          <source>Pig does not provide a loader that supports outer merge joins. You will need to build your own loader to take advantage of this feature.</source>
          <target state="translated">Pig는 외부 병합 조인을 지원하는 로더를 제공하지 않습니다. 이 기능을 이용하려면 고유 한 로더를 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="78bf7455f2e9a63798376b4de79dec1915e2cc29" translate="yes" xml:space="preserve">
          <source>Pig function names are case sensitive and UPPER CASE.</source>
          <target state="translated">돼지 기능 이름은 대소 문자를 구분하며 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="3497b8a9c4307da9ad98ce7b329893e102bfadf9" translate="yes" xml:space="preserve">
          <source>Pig has implemented a merge join algorithm, or sort-merge join. It works on pre-sorted data, and does not sort data for you. See Conditions, below, for restrictions that apply when using this join algorithm. Pig implements the merge join algorithm by selecting the left input of the join to be the input file for the map phase, and the right input of the join to be the side file. It then samples records from the right input to build an index that contains, for each sampled record, the key(s) the filename and the offset into the file the record begins at. This sampling is done in the first MapReduce job. A second MapReduce job is then initiated, with the left input as its input. Each map uses the index to seek to the appropriate record in the right input and begin doing the join.</source>
          <target state="translated">Pig는 병합 결합 알고리즘 또는 정렬 병합 결합을 구현했습니다. 미리 정렬 된 데이터에서 작동하며 데이터를 정렬하지 않습니다. 이 결합 알고리즘을 사용할 때 적용되는 제한 사항은 아래 조건을 참조하십시오. Pig는 조인의 왼쪽 입력을 맵 단계의 입력 파일로, 조인의 오른쪽 입력을 사이드 파일로 선택하여 병합 조인 알고리즘을 구현합니다. 그런 다음 올바른 입력에서 레코드를 샘플링하여 각 샘플링 된 레코드에 대해 파일 이름과 키가 레코드가 시작되는 파일에 대한 오프셋을 포함하는 색인을 작성합니다. 이 샘플링은 첫 번째 MapReduce 작업에서 수행됩니다. 그런 다음 왼쪽 입력을 입력으로 사용하여 두 번째 MapReduce 작업이 시작됩니다. 각 맵은 색인을 사용하여 올바른 입력에서 적절한 레코드를 찾고 결합을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8c465a5a14c5bf2028d4313b2065c52ed6b1f407" translate="yes" xml:space="preserve">
          <source>Pig has six execution modes or exectypes:</source>
          <target state="translated">Pig에는 6 가지 실행 모드 또는 exectype이 있습니다.</target>
        </trans-unit>
        <trans-unit id="abe1a7ac5158db2e5d49b5c0bf1750141f4b1162" translate="yes" xml:space="preserve">
          <source>Pig invokes all types of Hive UDF, including UDF, GenericUDF, UDAF, GenericUDAF and GenericUDTF. Depending on the Hive UDF you want to use, you need to declare it in Pig with HiveUDF(handles UDF and GenericUDF), HiveUDAF(handles UDAF and GenericUDAF), HiveUDTF(handles GenericUDTF).</source>
          <target state="translated">Pig는 UDF, GenericUDF, UDAF, GenericUDAF 및 GenericUDTF를 포함한 모든 유형의 Hive UDF를 호출합니다. 사용하려는 Hive UDF에 따라 HiveUDF (핸들 UDF 및 GenericUDF), HiveUDAF (핸들 UDAF 및 GenericUDAF), HiveUDTF (GenericUDTF 처리)를 사용하여 Pig로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab624fcbf738a4b8acd080c76087b67d14708f02" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</source>
          <target state="translated">Pig는 Java API 사양에 명시된 것과 다르게 결과를 처리 할 수 ​​있습니다. 입력 매개 변수 중 하나가 널이거나 충분하지 않은 수의 매개 변수가 제공되면 NULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5a922bbffcd1b5032fad1768816830c613580833" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification:</source>
          <target state="translated">Pig는 Java API 사양에 명시된 것과 다르게 결과를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9471d85941c65173fff582e14b71cf4f967ea913" translate="yes" xml:space="preserve">
          <source>Pig provides constant representations for all data types except bytearrays.</source>
          <target state="translated">Pig는 바이트 배열을 제외한 모든 데이터 유형에 대해 일정한 표현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="87c574c013f523193858b45a84f91642023a8f10" translate="yes" xml:space="preserve">
          <source>Pig provides extensive support for user defined functions (UDFs) as a way to specify custom processing. Pig UDFs can currently be implemented in six languages: Java, Jython, Python, JavaScript, Ruby and Groovy.</source>
          <target state="translated">Pig는 사용자 정의 처리를 지정하는 방법으로 사용자 정의 함수 (UDF)를 광범위하게 지원합니다. Pig UDF는 현재 Java, Jython, Python, JavaScript, Ruby 및 Groovy의 6 개 언어로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceda33dea4ba3f881c49648249091f447f7a880a" translate="yes" xml:space="preserve">
          <source>Pig provides shortcuts for the frequently used debugging operators (DUMP, DESCRIBE, EXPLAIN, ILLUSTRATE). These shortcuts can be used in Grunt shell or within pig scripts. Following are the shortcuts supported by pig</source>
          <target state="translated">Pig는 자주 사용하는 디버깅 연산자 (DUMP, DESCRIBE, EXPLAIN, ILLUSTRATE)에 대한 바로 가기를 제공합니다. 이 단축키는 Grunt 쉘 또는 돼지 스크립트에서 사용할 수 있습니다. 다음은 돼지가 지원하는 지름길입니다</target>
        </trans-unit>
        <trans-unit id="8e8994ca2f5728663eb94fb005036ffcd6396df7" translate="yes" xml:space="preserve">
          <source>Pig provides the ability to register a listener to receive event notifications during the execution of a script. Events include MapReduce plan creation, script launch, script progress, script completion, job submit, job start, job completion and job failure.</source>
          <target state="translated">Pig는 스크립트 실행 중에 이벤트 알림을 수신하도록 리스너를 등록하는 기능을 제공합니다. 이벤트에는 MapReduce 계획 작성, 스크립트 실행, 스크립트 진행, 스크립트 완료, 작업 제출, 작업 시작, 작업 완료 및 작업 실패가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6596e8905b3938c3700ea230f899c89f11a17f" translate="yes" xml:space="preserve">
          <source>Pig reserved keywords are listed here.</source>
          <target state="translated">돼지 예약 키워드가 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="8ee530c88eb069019e89fb162c7af7e0491d6334" translate="yes" xml:space="preserve">
          <source>Pig scripts allow you to pass values to parameters using &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;parameter substitution&lt;/a&gt;.</source>
          <target state="translated">Pig 스크립트를 사용하면 &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;매개 변수 대체를&lt;/a&gt; 사용하여 값을 매개 변수에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7af5953cb1970013fe65b12593533955cde08d36" translate="yes" xml:space="preserve">
          <source>Pig scripts could contain multiple STORE statements. There are cases when one would like to avoid writing to the same output location. Pig provides admins/script writers with a property to check if multiple STORE statements make an attempt to write to the same output directory. And fail fast letting the user know of the same.</source>
          <target state="translated">Pig 스크립트에는 여러 STORE 문이 포함될 수 있습니다. 동일한 출력 위치에 쓰지 않으려는 경우가 있습니다. Pig는 관리자 / 스크립트 작성자에게 여러 STORE 문이 동일한 출력 디렉토리에 쓰려고하는지 확인하는 속성을 제공합니다. 그리고 사용자에게 똑같이 알리는 데 실패하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f54e08d6f27a21247ba6b73114b665162748d1" translate="yes" xml:space="preserve">
          <source>Pig stores the intermediate data generated between MapReduce jobs in a temporary location on HDFS. This location must already exist on HDFS prior to use. This location can be configured using the pig.temp.dir property. The property's default value is &quot;/tmp&quot; which is the same as the hardcoded location in Pig 0.7.0 and earlier versions.</source>
          <target state="translated">Pig는 MapReduce 작업간에 생성 된 중간 데이터를 HDFS의 임시 위치에 저장합니다. 이 위치는 사용하기 전에 HDFS에 이미 존재해야합니다. pig.temp.dir 속성을 사용하여이 위치를 구성 할 수 있습니다. 속성의 기본값은 &quot;/ tmp&quot;이며 Pig 0.7.0 및 이전 버전의 하드 코드 된 위치와 같습니다.</target>
        </trans-unit>
        <trans-unit id="714c7646d7666c8d22f8f121acb63f13797f2c2b" translate="yes" xml:space="preserve">
          <source>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</source>
          <target state="translated">돼지 문자열 함수에는 첫 번째 추가 매개 변수가 있습니다. 모든 작업이 적용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d463cd387da41f017a06eeec2ec8c8e1a5cb86d2" translate="yes" xml:space="preserve">
          <source>Pig supports a number of Java properties that you can use to customize Pig behavior. You can retrieve a list of the properties using the &lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt; command. All of these properties are optional; none are required.</source>
          <target state="translated">Pig는 Pig 동작을 사용자 정의하는 데 사용할 수있는 많은 Java 특성을 지원합니다. &lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt; 명령을 사용하여 등록 정보 목록을 검색 할 수 있습니다 . 이러한 모든 속성은 선택 사항입니다. 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baff641180058647b74777d2576baee8385ad92c" translate="yes" xml:space="preserve">
          <source>Pig supports running scripts (and Jar files) that are stored in HDFS, Amazon S3, and other distributed file systems. The script's full location URI is required (see &lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt; for information about Jar files). For example, to run a Pig script on HDFS, do the following:</source>
          <target state="translated">Pig는 HDFS, Amazon S3 및 기타 분산 파일 시스템에 저장된 스크립트 (및 Jar 파일) 실행을 지원합니다. 스크립트의 전체 위치 URI가 필요합니다 ( JAR 파일에 대한 정보는 &lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt; 참조 ). 예를 들어 HDFS에서 Pig 스크립트를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="93b8509eca6765e62d9376104cd05a29add5f154" translate="yes" xml:space="preserve">
          <source>Pig supports various &lt;a href=&quot;perf#optimization-rules&quot;&gt;optimization rules&lt;/a&gt; which are turned on by default. Become familiar with these rules.</source>
          <target state="translated">Pig는 기본적으로 켜져있는 다양한 &lt;a href=&quot;perf#optimization-rules&quot;&gt;최적화 규칙&lt;/a&gt; 을 지원합니다 . 이 규칙에 익숙해 지십시오.</target>
        </trans-unit>
        <trans-unit id="7db2788da4d3cb08c1ef2ff25689ec2ee8056211" translate="yes" xml:space="preserve">
          <source>Pig supports various optimization rules, all of which are enabled by default. To disable all or specific optimizations, use one or more of the following methods. Note some optimization rules are mandatory and cannot be disabled.</source>
          <target state="translated">Pig는 다양한 최적화 규칙을 지원하며이 규칙은 모두 기본적으로 사용됩니다. 모든 최적화 또는 특정 최적화를 비활성화하려면 다음 방법 중 하나 이상을 사용하십시오. 일부 최적화 규칙은 필수이며 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dec5b4fd96103af2122e2313ddd5abca5934ce71" translate="yes" xml:space="preserve">
          <source>Pig to Groovy</source>
          <target state="translated">그루비에 돼지</target>
        </trans-unit>
        <trans-unit id="ffd9764afd639133c7dcafbb3bfb8b5a0f6b5c57" translate="yes" xml:space="preserve">
          <source>Pig uses BinStorage to load and store the temporary data that is generated between multiple MapReduce jobs.</source>
          <target state="translated">Pig는 BinStorage를 사용하여 여러 MapReduce 작업간에 생성 된 임시 데이터를로드하고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e6f964ef2f2e1463a5575b90549505104722c310" translate="yes" xml:space="preserve">
          <source>Pig uses type information for validation and performance. It is important for UDFs to participate in type propagation. Our UDFs generally make no effort to communicate their output schema to Pig. This is because Pig can usually figure out this information by using Java's &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt; Reflection&lt;/a&gt;. If your UDF returns a scalar or a map, no work is required. However, if your UDF returns a tuple or a bag (of tuples), it needs to help Pig figure out the structure of the tuple.</source>
          <target state="translated">Pig는 유효성 검사 및 성능을 위해 유형 정보를 사용합니다. UDF가 유형 전파에 참여하는 것이 중요합니다. 우리의 UDF는 일반적으로 그들의 출력 스키마를 Pig에게 전달하려고 노력하지 않습니다. Pig는 일반적으로 Java의 &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt;Reflection&lt;/a&gt; 을 사용하여이 정보를 알아낼 수 있기 때문 입니다. UDF가 스칼라 또는 맵을 리턴하면 작업이 필요하지 않습니다. 그러나 UDF가 튜플 또는 백 (튜플)을 반환하면 Pig가 튜플의 구조를 파악하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b6c4f473278cb2c4d79b79244d369de45127e72f" translate="yes" xml:space="preserve">
          <source>Pig will look for the #!/usr/bin/python line in the script.</source>
          <target state="translated">Pig는 스크립트에서 #! / usr / bin / python 줄을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e77ea84c3c6071688fbeecc5c58ee3a6a8b11e23" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.groovy extension in the script.</source>
          <target state="translated">Pig는 스크립트에서 * .groovy 확장자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0364a2ce40f5c70f5452cfa0554c3480442e1323" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.js extension in the script.</source>
          <target state="translated">Pig는 스크립트에서 * .js 확장자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="91634384ed9e6b31da4cf199ee9633830ca9b602" translate="yes" xml:space="preserve">
          <source>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &amp;lt;file&amp;gt;' command).</source>
          <target state="translated">Pig는 다음 시스템 디렉토리에서 파일을 자동 전달하지 않습니다 ( 'which &amp;lt;file&amp;gt;'명령을 실행하여 결정됨).</target>
        </trans-unit>
        <trans-unit id="25b2234668fa28c694ddf8954f0db6fd297cd55d" translate="yes" xml:space="preserve">
          <source>PigDump</source>
          <target state="translated">PigDump</target>
        </trans-unit>
        <trans-unit id="cd0f4a6c71f7d548ed016babe0f1794757d97253" translate="yes" xml:space="preserve">
          <source>PigDump stores data as tuples in human-readable UTF-8 format.</source>
          <target state="translated">PigDump는 데이터를 사람이 읽을 수있는 UTF-8 형식으로 튜플로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="076d83430955260169fb65f99eac100421155024" translate="yes" xml:space="preserve">
          <source>PigDump()</source>
          <target state="translated">PigDump()</target>
        </trans-unit>
        <trans-unit id="7e5a4069b9fdb2979478c1ee4fdbc3e2c6ad6bac" translate="yes" xml:space="preserve">
          <source>PigProgressNotificationListener Object</source>
          <target state="translated">PigProgressNotificationListener 객체</target>
        </trans-unit>
        <trans-unit id="3b203b52f09d0ae21512293305adfa539797f50a" translate="yes" xml:space="preserve">
          <source>PigRunner API</source>
          <target state="translated">PigRunner API</target>
        </trans-unit>
        <trans-unit id="c591d5d2fae917bd8241460a851795d39ef7fd4d" translate="yes" xml:space="preserve">
          <source>PigServer Interface</source>
          <target state="translated">PigServer 인터페이스</target>
        </trans-unit>
        <trans-unit id="2f322dd1e3ab68730e8f4ea4e48514c5d2b0e8fe" translate="yes" xml:space="preserve">
          <source>PigStats</source>
          <target state="translated">PigStats</target>
        </trans-unit>
        <trans-unit id="09ef3422b57b20584bb4bd1065c0d793e6c60aa6" translate="yes" xml:space="preserve">
          <source>PigStats Object</source>
          <target state="translated">PigStats 객체</target>
        </trans-unit>
        <trans-unit id="8c9ea42da56c5bce11828868d9a6b3bd2007fda6" translate="yes" xml:space="preserve">
          <source>PigStats is now an abstract class. (PigStats as it was before has become SimplePigStats.)</source>
          <target state="translated">PigStats는 이제 추상 클래스입니다. (PigStats는 예전처럼 SimplePigStats가되었습니다.)</target>
        </trans-unit>
        <trans-unit id="25cdca4514b647129134787cd149f41de99035d4" translate="yes" xml:space="preserve">
          <source>PigStorage</source>
          <target state="translated">PigStorage</target>
        </trans-unit>
        <trans-unit id="189d56b69a7325ea9365151a6fd186619f7dba18" translate="yes" xml:space="preserve">
          <source>PigStorage is the default function used by Pig to load/store the data. PigStorage supports structured text files (in human-readable UTF-8 format) in compressed or uncompressed form (see &lt;a href=&quot;#handling-compression&quot;&gt;Handling Compression&lt;/a&gt;). All Pig &lt;a href=&quot;basic#data-types&quot;&gt;data types&lt;/a&gt; (both simple and complex) can be read/written using this function. The input data to the load can be a file, a directory or a glob.</source>
          <target state="translated">PigStorage는 Pig에서 데이터를로드 / 저장하기 위해 사용하는 기본 기능입니다. PigStorage는 압축 또는 비 압축 형태로 구조화 된 텍스트 파일 (사람이 읽을 수있는 UTF-8 형식)을 지원합니다 (압축 &lt;a href=&quot;#handling-compression&quot;&gt;처리&lt;/a&gt; 참조 ). 이 기능을 사용하여 모든 Pig &lt;a href=&quot;basic#data-types&quot;&gt;데이터 유형&lt;/a&gt; (간단하고 복잡한)을 읽고 쓸 수 있습니다. 로드에 대한 입력 데이터는 파일, 디렉토리 또는 glob 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2e71c500f2a58ecf6be6205a6d15e6c21c547c" translate="yes" xml:space="preserve">
          <source>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</source>
          <target state="translated">PigStorage는 LOAD 연산자의 기본로드 기능입니다. 이 예제에서 is not null 연산자는 null 값으로 이름을 필터링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="851b7752cd0d7ce793cb4e4ca346b699d8bf7ba9" translate="yes" xml:space="preserve">
          <source>PigStorage( [field_delimiter] , ['options'] )</source>
          <target state="translated">PigStorage ([field_delimiter], [ '옵션'])</target>
        </trans-unit>
        <trans-unit id="0d3b09a00028b253cd0f1f6c7b23a76114298a8a" translate="yes" xml:space="preserve">
          <source>PigUnit</source>
          <target state="translated">PigUnit</target>
        </trans-unit>
        <trans-unit id="dbc328ccebde1c387467a71ae41410ef063708a6" translate="yes" xml:space="preserve">
          <source>PigUnit Example</source>
          <target state="translated">PigUnit 예</target>
        </trans-unit>
        <trans-unit id="e58deab3203c61b8478e84f609cbbfd6830c6870" translate="yes" xml:space="preserve">
          <source>PigUnit also runs in Pig's mapreduce/tez/tez_local mode. Mapreduce/Tez mode requires you to use a Hadoop cluster and HDFS installation. It is enabled when the Java system property pigunit.exectype is set to specific values (mr/tez/tez_local): e.g. -Dpigunit.exectype=mr or System.getProperties().setProperty(&quot;pigunit.exectype&quot;, &quot;mr&quot;), which means PigUnit will run in mr mode. The cluster you select to run mr/tez test must be specified in the CLASSPATH (similar to the HADOOP_CONF_DIR variable).</source>
          <target state="translated">PigUnit은 Pig의 mapreduce / tez / tez_local 모드에서도 실행됩니다. Mapreduce / Tez 모드에서는 Hadoop 클러스터 및 HDFS 설치를 사용해야합니다. Java 시스템 특성 pigunit.exectype이 특정 값 (mr / tez / tez_local)으로 설정되면 사용 가능합니다. 예 : -Dpigunit.exectype = mr 또는 System.getProperties (). setProperty ( &quot;pigunit.exectype&quot;, &quot;mr&quot;) 이는 PigUnit이 mr 모드에서 실행됨을 의미합니다. mr / tez 테스트를 실행하도록 선택한 클러스터는 CLASSPATH (HADOOP_CONF_DIR 변수와 유사)에 지정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5efb4aafd77f51485d9e22a5331f73c21b84e2d1" translate="yes" xml:space="preserve">
          <source>PigUnit is a simple xUnit framework that enables you to easily test your Pig scripts. With PigUnit you can perform unit testing, regression testing, and rapid prototyping. No cluster set up is required if you run Pig in local mode.</source>
          <target state="translated">PigUnit은 간단한 xUnit 프레임 워크로 Pig 스크립트를 쉽게 테스트 할 수 있습니다. PigUnit을 사용하면 단위 테스트, 회귀 테스트 및 빠른 프로토 타이핑을 수행 할 수 있습니다. 로컬 모드에서 Pig를 실행하는 경우 클러스터 설정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e825c7a9656dd5933b89b6587e34170d6f8b825d" translate="yes" xml:space="preserve">
          <source>PigUnit runs in Pig's local mode by default. Local mode is fast and enables you to use your local file system as the HDFS cluster. Local mode does not require a real cluster but a new local one is created each time.</source>
          <target state="translated">PigUnit은 기본적으로 Pig의 로컬 모드에서 실행됩니다. 로컬 모드는 빠르며 로컬 파일 시스템을 HDFS 클러스터로 사용할 수 있습니다. 로컬 모드에는 실제 클러스터가 필요하지 않지만 매번 새 로컬 클러스터가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="51485a7e9c11278ddb30a38747984651921c7357" translate="yes" xml:space="preserve">
          <source>Piggy Bank</source>
          <target state="translated">돼지 저금통</target>
        </trans-unit>
        <trans-unit id="94706352a7655c2f04cd6d5b3c48f2991946cce6" translate="yes" xml:space="preserve">
          <source>Piggy Bank is a place for Pig users to share the Java UDFs they have written for use with Pig. The functions are contributed &quot;as-is.&quot; If you find a bug in a function, take the time to fix it and contribute the fix to Piggy Bank. If you don't find the UDF you need, take the time to write and contribute the function to Piggy Bank.</source>
          <target state="translated">Piggy Bank는 Pig 사용자가 Pig와 함께 사용하기 위해 작성한 Java UDF를 공유 할 수있는 장소입니다. 기능은 &quot;있는 그대로&quot;제공됩니다. 함수에서 버그를 발견하면 시간을내어 수정하고 Piggy Bank에 수정 사항을 제공하십시오. 필요한 UDF를 찾지 못하면 시간을내어 Piggy Bank에 기능을 작성하고 기고하십시오.</target>
        </trans-unit>
        <trans-unit id="548bf24c348f6ecb39a696616e88c2bdb8fc7c48" translate="yes" xml:space="preserve">
          <source>Piggybank now contains a load function called org.apache.pig.piggybank.storage.IndexedStorage that is a derivation of PigStorage and implements IndexedLoadFunc. This is the only loader included in the standard Pig distribution that can be used for merge-sparse join.</source>
          <target state="translated">Piggybank는 이제 PigStorage의 파생이며 IndexedLoadFunc를 구현하는 org.apache.pig.piggybank.storage.IndexedStorage라는로드 함수를 포함합니다. 이는 표준 Pig 배포에 포함 된 유일한 로더로 병합-스파 스 조인에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e46ef91cf972b79cfeb37c8c0b0f1a663a2b3c" translate="yes" xml:space="preserve">
          <source>Place your java code in the directory that makes sense for your function. The directory structure currently has two levels: (1) function type, as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;, and (2) function subtype, for some of the types (like math or string for eval functions). If you think your function requires a new subtype, feel free to add one.</source>
          <target state="translated">함수에 적합한 디렉토리에 Java 코드를 배치하십시오. 디렉토리 구조는 현재 (1) 함수 &lt;a href=&quot;#piggbank-access&quot;&gt;액세스에&lt;/a&gt; 설명 된 함수 유형 및 (2) 일부 유형 (예 : eval 함수의 경우 수학 또는 문자열)의 함수 하위 유형의 두 가지 레벨 이 있습니다. 함수에 새로운 하위 유형이 필요하다고 생각되면 자유롭게 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="45b51fb4489a0001750d8a0d80a1eabd943fd26b" translate="yes" xml:space="preserve">
          <source>Please note that all parameters must be resolved during bind. Having unbound parameters while running your script is an error. Also note that even if your script is fully defined during compile, bind without parameters still must be called.</source>
          <target state="translated">바인드하는 동안 모든 매개 변수를 해결해야합니다. 스크립트를 실행하는 동안 바인딩되지 않은 매개 변수를 갖는 것은 오류입니다. 또한 컴파일 중에 스크립트가 완전히 정의 된 경우에도 매개 변수없이 바인드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a06967c386bbcf581bbbff0858c5a65621763d0" translate="yes" xml:space="preserve">
          <source>Please note that the script above can be made more efficient by performing filtering before the GROUP statement:</source>
          <target state="translated">GROUP 문 전에 필터링을 수행하면 위 스크립트를보다 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1fc2184a267b82bd60f72a9ca2cc38f005be8b" translate="yes" xml:space="preserve">
          <source>Please note the following:</source>
          <target state="translated">다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="1e0f495264f489ed260b938fbaf923286b89db5c" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;the Joda-Time doc&lt;/a&gt; for available timezone IDs.</source>
          <target state="translated">사용 가능한 시간대 ID &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;는 Joda-Time 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3414cc34b87b848682458107bbe3817781eebf0" translate="yes" xml:space="preserve">
          <source>PluckTuple</source>
          <target state="translated">PluckTuple</target>
        </trans-unit>
        <trans-unit id="5d6a4911520319a2d3e4452f20e0a79aefaaa5b1" translate="yes" xml:space="preserve">
          <source>Point $HADOOPDIR to the directory that contains the hadoop-site.xml file. Example:</source>
          <target state="translated">$ HADOOPDIR을 hadoop-site.xml 파일이 들어있는 디렉토리를 가리 킵니다. 예:</target>
        </trans-unit>
        <trans-unit id="dbec33ded970d7645cff3e7a90ffcb1db17bf2b3" translate="yes" xml:space="preserve">
          <source>Positional notation (generated by system)</source>
          <target state="translated">위치 표기법 (시스템에서 생성)</target>
        </trans-unit>
        <trans-unit id="7a1a9c9263f88ba37537ce91842a5071d4c86b03" translate="yes" xml:space="preserve">
          <source>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2.</source>
          <target state="translated">위치 표기법은 시스템에 의해 생성됩니다. 위치 표기법은 달러 기호 ($)로 표시되며 0으로 시작합니다. 예를 들어 $ 0, $ 1, $ 2입니다.</target>
        </trans-unit>
        <trans-unit id="470b7c6b31d52098c05a7c0eb3537e05b562b162" translate="yes" xml:space="preserve">
          <source>Possible name (assigned by you using a schema)</source>
          <target state="translated">가능한 이름 (스키마를 사용하여 할당 함)</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="c62fe3da66de5300e411627aa04bcf8aba54c94e" translate="yes" xml:space="preserve">
          <source>Precedence for parameters is as follows, from highest to lowest:</source>
          <target state="translated">매개 변수의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa06e8fd282659ac6d432bb0788f9503111f1ec3" translate="yes" xml:space="preserve">
          <source>Predicate pushdown</source>
          <target state="translated">술어 푸시 다운</target>
        </trans-unit>
        <trans-unit id="67219f57bcad6686b5aafd1fa4c0f49cde92f4ad" translate="yes" xml:space="preserve">
          <source>PredicatePushdownOptimizer</source>
          <target state="translated">PredicatePushdownOptimizer</target>
        </trans-unit>
        <trans-unit id="8adf8f822b81878db822737e2402a291fabdb7a0" translate="yes" xml:space="preserve">
          <source>Prefer DISTINCT over GROUP BY/GENERATE</source>
          <target state="translated">GROUP BY / GENERATE보다 DISTINCT 선호</target>
        </trans-unit>
        <trans-unit id="71ee3d895930077b420791fb640e0fcf277eb35a" translate="yes" xml:space="preserve">
          <source>Preprocessor statement included in a Pig script.</source>
          <target state="translated">전 처리기 명령문은 Pig 스크립트에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7683a0a1b3a8c7fba74716254c107f2f5e90e3" translate="yes" xml:space="preserve">
          <source>Prerequisite: Tez requires the tez tarball to be available in hdfs while running a job on the cluster and a tez-site.xml with tez.lib.uris setting pointing to that hdfs location in classpath. Copy the tez tarball to hdfs and add the tez conf directory($TEZ_HOME/conf) containing tez-site.xml to environmental variable &quot;PIG_CLASSPATH&quot; if pig on tez fails with &quot;tez.lib.uris is not defined&quot;. This is required by the Apache Pig distribution.</source>
          <target state="translated">전제 조건 : Tez는 클러스터에서 작업을 실행하는 동안 tez tarball을 hdfs에서 사용 가능하고 tez.site.xml이 클래스 경로에서 해당 hdfs 위치를 가리키는 tez-site.xml을 필요로합니다. tez tarball을 hdfs에 복사하고 tez-site.xml을 포함하는 tez conf 디렉토리 ($ TEZ_HOME / conf)를 환경 변수 &quot;PIG_CLASSPATH&quot;에 &quot;tez.lib.uris is not defined&quot;로 tez의 돼지가 실패하면 추가하십시오. 이것은 Apache Pig 배포판에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="68c4f7f4e32d071edfecdccbc2955d1848fe5d3f" translate="yes" xml:space="preserve">
          <source>Previous Relation Shortcut</source>
          <target state="translated">이전 관계 바로 가기</target>
        </trans-unit>
        <trans-unit id="91668392239b2ed6e082ab66f5115752a3228d5d" translate="yes" xml:space="preserve">
          <source>Prints a list of Pig commands or properties.</source>
          <target state="translated">Pig 명령 또는 속성 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64172510397f433c399b5d42e0b1269626b1a958" translate="yes" xml:space="preserve">
          <source>Processing Order and Precedence</source>
          <target state="translated">처리 순서 및 우선 순위</target>
        </trans-unit>
        <trans-unit id="985f018300a3bcf017393d943a21bd0b142ab797" translate="yes" xml:space="preserve">
          <source>Processing input (either user input or intermediate input) from multiple small files can be inefficient because a separate map has to be created for each file. Pig can now combined small files so that they are processed as a single map.</source>
          <target state="translated">여러 개의 작은 파일에서 입력 (사용자 입력 또는 중간 입력)을 처리하는 것은 각 파일마다 별도의 맵을 작성해야하므로 비효율적 일 수 있습니다. Pig는 이제 작은 파일을 결합하여 단일 맵으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="068b6f370b0ca1593f3b3fbac750583d9d7d8efa" translate="yes" xml:space="preserve">
          <source>Processing small mapreduce jobs on hadoop cluster could be slow as it has overhead of job startup and job scheduling. For jobs with small input data, pig can convert them to run them as in-process mapreduce with hadoop's local mode. If pig.auto.local.enabled flag is set to true, pig will convert mapreduce jobs with input data less than pig.auto.local.input.maxbytes (100MB by default) to run in local mode, provided the number of reducers required by the job are less than or equal to 1. Note, jobs converted to run in local mode load and store data from HDFS, so any job in the pig workflow(dag) could be converted to run in local mode without affecting its downstream jobs.</source>
          <target state="translated">hadoop 클러스터에서 작은 mapreduce 작업을 처리하면 작업 시작 및 작업 스케줄링의 오버 헤드가 있으므로 느려질 수 있습니다. 입력 데이터가 작은 작업의 경우, pig는 hadoop의 로컬 모드를 사용하여 프로세스 내 mapreduce로 실행하도록 변환 할 수 있습니다. pig.auto.local.enabled 플래그가 true로 설정된 경우, pig는 필요한 감속기 수가있는 경우 pig.auto.local.input.maxbytes (기본적으로 100MB) 미만의 입력 데이터를 가진 mapreduce 작업을 로컬 모드로 실행하도록 변환합니다. 로컬 모드에서 실행되도록 변환 된 작업은 HDFS에서 데이터를 저장하고 저장하므로 돼지 워크 플로 (dag)의 모든 작업은 다운 스트림 작업에 영향을주지 않고 로컬 모드에서 실행되도록 변환 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="1d28a282560bb759052a3e6e6fcd13088d888408" translate="yes" xml:space="preserve">
          <source>Project Early and Often</source>
          <target state="translated">초기 및 종종 프로젝트</target>
        </trans-unit>
        <trans-unit id="9155c425ec77a3089191509a98c385937bbb07a9" translate="yes" xml:space="preserve">
          <source>Project-Range Expressions</source>
          <target state="translated">프로젝트 범위 표현</target>
        </trans-unit>
        <trans-unit id="549f47352730051b89a49356a5aa47d12e349987" translate="yes" xml:space="preserve">
          <source>Project-range ( .. ) expressions can be used to project a range of columns from input. For example:</source>
          <target state="translated">프로젝트 범위 (..) 표현식을 사용하여 입력에서 열 범위를 투사 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="badce2f5aad822deab06383975c71e3c2b6f9be2" translate="yes" xml:space="preserve">
          <source>Project-range can be used in all cases where the &lt;a href=&quot;#sexp&quot;&gt;star expression&lt;/a&gt; ( * ) is allowed.</source>
          <target state="translated">&lt;a href=&quot;#sexp&quot;&gt;별표&lt;/a&gt; (*)가 허용되는 모든 경우에 프로젝트 범위를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c69909c9dc93448f96162044d8b25b4d837f86e" translate="yes" xml:space="preserve">
          <source>Project-range can be used in the following statements: &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt;, &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt;, &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt;, &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt;, and &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; (also when ORDER BY is used within a nested FOREACH block).</source>
          <target state="translated">프로젝트 범위는 &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt; , &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt; , &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt; , &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt; 및 &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; 문에서 사용할 수 있습니다 (ORDER BY가 중첩 FOREACH 블록 내에서 사용되는 경우).</target>
        </trans-unit>
        <trans-unit id="fa33f39f5421ef81d13a830fb4443370104ee3c9" translate="yes" xml:space="preserve">
          <source>Projections (dimensions) of the relation. Supports field, star and project-range expressions.</source>
          <target state="translated">관계의 투영 (치수). 필드, 별표 및 프로젝트 범위 표현식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ec840bd9176cde5b4141fc791989284f3e9ed0c" translate="yes" xml:space="preserve">
          <source>Prune the loader to only load necessary columns. The performance gain is more significant if the corresponding loader support column pruning and only load necessary columns (See LoadPushDown.pushProjection). Otherwise, ColumnMapKeyPrune will insert a ForEach statement right after loader.</source>
          <target state="translated">로더를 정리하여 필요한 열만로드하십시오. 해당 로더가 열 제거를 지원하고 필요한 열만로드하는 경우 성능 향상이 더 중요합니다 (LoadPushDown.pushProjection 참조). 그렇지 않으면 ColumnMapKeyPrune은 로더 바로 다음에 ForEach 문을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="c46a0e7afbefa23c27c29686d94920c8b40fe658" translate="yes" xml:space="preserve">
          <source>Prune unused column as soon as possible. In addition to prune the loader in ColumnMapKeyPrune, we can prune a column as soon as it is not used in the rest of the script</source>
          <target state="translated">사용하지 않는 열은 가능한 빨리 정리하십시오. ColumnMapKeyPrune에서 로더를 제거하는 것 외에도 나머지 스크립트에서 사용되지 않는 즉시 열을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7931337f31f75950cb4c2cdebc73bd2f84097cc" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader.</source>
          <target state="translated">필터 조건을 로더로 밉니다.</target>
        </trans-unit>
        <trans-unit id="fc4197eb949bc0da0a0aeedd23a8819a37dc696c" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader. Different than PartitionFilterOptimizer, the filter condition will be evaluated in Pig. In other words, the filter condition pushed to the loader is a hint. Loader might still load records which does not satisfy filter condition.</source>
          <target state="translated">필터 조건을 로더로 밉니다. PartitionFilterOptimizer와 달리 필터 조건은 Pig에서 평가됩니다. 다시 말해, 로더에 푸시 된 필터 조건은 힌트입니다. 로더는 여전히 필터 조건을 만족하지 않는 레코드를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6019407474c8f4cd672f2782447a068a3eff87a" translate="yes" xml:space="preserve">
          <source>PushDownForEachFlatten</source>
          <target state="translated">PushDownForEachFlatten</target>
        </trans-unit>
        <trans-unit id="00d23fd27f64adf999e795e338babf1919b5159b" translate="yes" xml:space="preserve">
          <source>PushUpFilter</source>
          <target state="translated">PushUpFilter</target>
        </trans-unit>
        <trans-unit id="9e91ff7fcaea97ed1e629c1ea1dd3a3be1f9a961" translate="yes" xml:space="preserve">
          <source>Queries that can take advantage of the combiner generally ran much faster (sometimes several times faster) than the versions that don't. The latest code significantly improves combiner usage; however, you need to make sure you do your part. If you have a UDF that works on grouped data and is, by nature, algebraic (meaning their computation can be decomposed into multiple steps) make sure you implement it as such. For details on how to write algebraic UDFs, see &lt;a href=&quot;udf#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;.</source>
          <target state="translated">결합기를 활용할 수있는 쿼리는 일반적으로 그렇지 않은 버전보다 훨씬 빠릅니다 (때로는 몇 배 더 빠름). 최신 코드는 결합기 사용을 크게 향상시킵니다. 그러나 자신의 역할을 수행해야합니다. 그룹화 된 데이터에서 작동하는 UDF가 있고 본질적으로 대수적 (계산이 여러 단계로 분해 될 수 있음) 인 경우이를 그대로 구현해야합니다. 대수 UDF 작성 방법에 대한 자세한 내용은 &lt;a href=&quot;udf#algebraic-interface&quot;&gt;대수 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7189bc7a153aae22c9ad9fbdd927084b0fc40f73" translate="yes" xml:space="preserve">
          <source>Quits from the Pig grunt shell.</source>
          <target state="translated">Pig grunt shell에서 종료합니다.</target>
        </trans-unit>
        <trans-unit id="620db5d9320e96ee12d500dbe6be7488db8de087" translate="yes" xml:space="preserve">
          <source>RANDOM</source>
          <target state="translated">RANDOM</target>
        </trans-unit>
        <trans-unit id="9e3bfd1f2a524ee518de592cf7435459586a3d76" translate="yes" xml:space="preserve">
          <source>RANDOM( )</source>
          <target state="translated">RANDOM ()</target>
        </trans-unit>
        <trans-unit id="9cc2229409ebf7a451b2509c23892c92fff169d6" translate="yes" xml:space="preserve">
          <source>RANK</source>
          <target state="translated">RANK</target>
        </trans-unit>
        <trans-unit id="94e87841c18078a6be5f0c47297fcf1078db118b" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT</source>
          <target state="translated">REGEX_EXTRACT</target>
        </trans-unit>
        <trans-unit id="25060cd6008a61bda5883baa15d7cfb4500fcb19" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT (string, regex, index)</source>
          <target state="translated">REGEX_EXTRACT (문자열, 정규식, 색인)</target>
        </trans-unit>
        <trans-unit id="0921fe22357a6d6189cafbbaccb9446992f7c4b5" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL</source>
          <target state="translated">REGEX_EXTRACT_ALL</target>
        </trans-unit>
        <trans-unit id="0b2e921ca3a52345dca73d874d8ecb7ca4ad0cc1" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL (string, regex)</source>
          <target state="translated">REGEX_EXTRACT_ALL (문자열, 정규식)</target>
        </trans-unit>
        <trans-unit id="7aa14173b8000e15aca4adfdc3b1a5e0d8c44ef0" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH</source>
          <target state="translated">REGEX_SEARCH</target>
        </trans-unit>
        <trans-unit id="4c56880804c60faefafcbee89177e1727de2dff4" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH(string, 'regExp');</source>
          <target state="translated">REGEX_SEARCH (문자열, 'regExp');</target>
        </trans-unit>
        <trans-unit id="018678424b56c2120abb69e981ef3eec820e05dd" translate="yes" xml:space="preserve">
          <source>REGISTER (a jar/script)</source>
          <target state="translated">등록 (병 / 스크립트)</target>
        </trans-unit>
        <trans-unit id="c28d820c6f95eb8bc2a1c939755c4308dae8a884" translate="yes" xml:space="preserve">
          <source>REGISTER (an artifact)</source>
          <target state="translated">등록 (아티팩트)</target>
        </trans-unit>
        <trans-unit id="c2f18c3d25c024de2d314688e5568c2e2b885ce4" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://group:module:version?querystring</source>
          <target state="translated">등록 ivy : // group : module : version? querystring</target>
        </trans-unit>
        <trans-unit id="3213ec58664edb7df53533dc66ffd9af231fd2cb" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?classifier=value</source>
          <target state="translated">등록 ivy : // org : module : version? classifier = value</target>
        </trans-unit>
        <trans-unit id="298b74bfc4131cf922f0663bebad6b611ebc696d" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?exclude=org:mod,org:mod,...</source>
          <target state="translated">등록 ivy : // org : module : version? exclude = org : mod, org : mod, ...</target>
        </trans-unit>
        <trans-unit id="f9f07df8a78db31fca096c05b31f0bcd7a3a50f7" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?transitive=false</source>
          <target state="translated">등록 ivy : // org : module : version? transitive = false</target>
        </trans-unit>
        <trans-unit id="523fb225d3a2759dc8655903d1bc6a8288ada1ba" translate="yes" xml:space="preserve">
          <source>REGISTER path;</source>
          <target state="translated">등록 경로;</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="e04cf56acc0c4981837a53b7ff1256bf0c0ff4fe" translate="yes" xml:space="preserve">
          <source>REPLACE(string, 'regExp', 'newChar');</source>
          <target state="translated">REPLACE (문자열, 'regExp', 'newChar');</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="7f78099ba5db4acf80827e5f3d1a83db2ae525ec" translate="yes" xml:space="preserve">
          <source>ROLLUP</source>
          <target state="translated">ROLLUP</target>
        </trans-unit>
        <trans-unit id="8580cec9b53e98ece67f310e025d4a349121f88a" translate="yes" xml:space="preserve">
          <source>ROUND</source>
          <target state="translated">ROUND</target>
        </trans-unit>
        <trans-unit id="cacfa70692e87c3321966a012a48ba58ce3bb591" translate="yes" xml:space="preserve">
          <source>ROUND(expression)</source>
          <target state="translated">ROUND(expression)</target>
        </trans-unit>
        <trans-unit id="c4c0b1ef3217efe1d9bf9b7d827e6ad059b864bd" translate="yes" xml:space="preserve">
          <source>ROUND(x)</source>
          <target state="translated">ROUND(x)</target>
        </trans-unit>
        <trans-unit id="0715c249cd668d5284678dca026287c3e463851a" translate="yes" xml:space="preserve">
          <source>ROUND_TO</source>
          <target state="translated">ROUND_TO</target>
        </trans-unit>
        <trans-unit id="9e50ef723b8064863d96f779d169424a37563aa0" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits [, mode])</source>
          <target state="translated">ROUND_TO (val, 숫자 [, 모드])</target>
        </trans-unit>
        <trans-unit id="8552829751a281e6ba49d05c41a939ede5eaafcb" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits)</source>
          <target state="translated">ROUND_TO (val, 자리)</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="d0176c9b5630a9edca1e76d654fc1c435437c454" translate="yes" xml:space="preserve">
          <source>RTRIM(expression)</source>
          <target state="translated">RTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="2a967919b023bdd7576620af97326ae9c9f3491d" translate="yes" xml:space="preserve">
          <source>Record Deliminters &amp;ndash; For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</source>
          <target state="translated">레코드 구분 기호 &amp;ndash;로드 설명의 경우 Pig는 줄 바꿈 ( '\ n'), 캐리지 리턴 ( '\ r'또는 CTRL-M) 및 결합 된 CR + LF ( '\ r \ n') 문자를 레코드 구분 기호로 해석합니다 ( 이 문자를 필드 구분 기호로 사용하십시오). 상점 명령문의 경우 Pig는 줄 바꿈 ( '\ n') 문자를 레코드 구분 기호로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ef6b7434b39836c7b5476b127140cb9fc733f047" translate="yes" xml:space="preserve">
          <source>Reduce Your Operator Pipeline</source>
          <target state="translated">운영자 파이프 라인 감소</target>
        </trans-unit>
        <trans-unit id="a5b5c7ea81e2d801d5ee70f53f3a6c23d9a8c4e6" translate="yes" xml:space="preserve">
          <source>Reducer Estimation</source>
          <target state="translated">감속기 추정</target>
        </trans-unit>
        <trans-unit id="62beeb3ebea5d1b6fbcca509b70d060344fdd22b" translate="yes" xml:space="preserve">
          <source>Refer to args positionally and as many times as you like using %(pos)$.... Use %&amp;lt;... to refer to the previously-specified arg.</source>
          <target state="translated">% (pos) $ ...를 사용하여 원하는 횟수만큼 위치를 지정합니다. 이전에 지정한 인수를 참조하려면 % &amp;lt;...를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4737d8da85fe53493025312e1f0d18e0867c487c" translate="yes" xml:space="preserve">
          <source>Referencing Fields</source>
          <target state="translated">참조 필드</target>
        </trans-unit>
        <trans-unit id="4cae9bdf3920da7757a8c85f6b54d8738dd7967d" translate="yes" xml:space="preserve">
          <source>Referencing Fields that are Complex Data Types</source>
          <target state="translated">복잡한 데이터 유형 인 필드 참조</target>
        </trans-unit>
        <trans-unit id="d23bb24e2f8bcaae71a9d10cc001c98353b1b509" translate="yes" xml:space="preserve">
          <source>Referencing Relations</source>
          <target state="translated">관계 참조</target>
        </trans-unit>
        <trans-unit id="dc42ec7da7d0e19f1a5ed6e62ea29d2d256d89ad" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the included UDFs can be called in the script.</source>
          <target state="translated">포함 된 UDF를 스크립트에서 호출 할 수 있도록 학습서 JAR 파일을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="6692a10545ad9ae35c076d55ecf3df797aeb3ad4" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the user defined functions (UDFs) can be called in the script.</source>
          <target state="translated">스크립트에서 사용자 정의 함수 (UDF)를 호출 할 수 있도록 학습서 JAR 파일을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="26c92f3731d6fecfb43c28c225f8c2bc30998abb" translate="yes" xml:space="preserve">
          <source>Registering an Artifact and all its dependencies.</source>
          <target state="translated">아티팩트 및 모든 종속 항목 등록</target>
        </trans-unit>
        <trans-unit id="dc29b2e11b3b43cda736fcba0bb6760a606e849e" translate="yes" xml:space="preserve">
          <source>Registering an artifact by excluding specific dependencies.</source>
          <target state="translated">특정 종속성을 제외하여 아티팩트 등록</target>
        </trans-unit>
        <trans-unit id="5f4ed5bdc8024ad52459ee1a00ab28199dd38f89" translate="yes" xml:space="preserve">
          <source>Registering an artifact without a group or organization. Just skip them.</source>
          <target state="translated">그룹이나 조직없이 이슈를 등록합니다. 그냥 건너 뛰세요.</target>
        </trans-unit>
        <trans-unit id="3d4a9d6f350eea88c38c96fd0c95e87ab7bbad29" translate="yes" xml:space="preserve">
          <source>Registering an artifact without getting its dependencies.</source>
          <target state="translated">종속성을 얻지 않고 이슈를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="da1d3a98f791337ad0a4ec68eae079eb6ef95ae7" translate="yes" xml:space="preserve">
          <source>Registering the UDF</source>
          <target state="translated">UDF 등록</target>
        </trans-unit>
        <trans-unit id="8a29de9c3832ce4b8e6b18747e5a829713fca18d" translate="yes" xml:space="preserve">
          <source>Registering the latest artifact.</source>
          <target state="translated">최신 아티팩트 등록</target>
        </trans-unit>
        <trans-unit id="dd54c0c65bf4584f34e8a3942380ffcf0970fe76" translate="yes" xml:space="preserve">
          <source>Registers a JAR file so that the UDFs in the file can be used.</source>
          <target state="translated">파일의 UDF를 사용할 수 있도록 JAR 파일을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="428be11df215f5cd15290e03edfab6e2024b704f" translate="yes" xml:space="preserve">
          <source>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</source>
          <target state="translated">관계 X는 다음과 같습니다. 각 고유 키 필드에 대해 튜플이 생성됩니다. 튜플에는 키 필드와 두 개의 백이 포함됩니다. 첫 번째 백은 일치하는 키 필드와 첫 번째 관계의 튜플입니다. 두 번째 백은 일치하는 키 필드와 두 번째 관계의 튜플입니다. 키 필드와 일치하는 튜플이 없으면 백이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">관계 연산자</target>
        </trans-unit>
        <trans-unit id="ac6eb526c4d3427712a60a1a682dfb9f6e58dad9" translate="yes" xml:space="preserve">
          <source>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</source>
          <target state="translated">관계는 이름 (또는 별명)으로 나타납니다. 이름은 Pig Latin 문의 일부로 지정됩니다. 이 예에서 관계의 이름 (별칭)은 A입니다.</target>
        </trans-unit>
        <trans-unit id="657fe9adf3cabd570b43f36ea037911276330628" translate="yes" xml:space="preserve">
          <source>Relations, Bags, Tuples, Fields</source>
          <target state="translated">관계, 가방, 튜플, 필드</target>
        </trans-unit>
        <trans-unit id="47f90b570611ed6b62f0263d679682900ef503e8" translate="yes" xml:space="preserve">
          <source>Remove the boiler plate code appearing when there is more than one test methods.</source>
          <target state="translated">하나 이상의 테스트 방법이있을 때 나타나는 보일러 플레이트 코드를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f90556d367ec2b7b89d6cb1145ec2ab9a7d43795" translate="yes" xml:space="preserve">
          <source>Removes duplicate tuples in a relation.</source>
          <target state="translated">관계에서 중복 튜플을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d5aed14a2d8cc1e13aa0226552743bc08f973991" translate="yes" xml:space="preserve">
          <source>Removes the record if the query field is empty or a URL.</source>
          <target state="translated">쿼리 필드가 비어 있거나 URL 인 경우 레코드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="01b967cc6fcf66fa1a327d6e23a3adcc183a7585" translate="yes" xml:space="preserve">
          <source>Replaces existing characters in a string with new characters.</source>
          <target state="translated">문자열의 기존 문자를 새 문자로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7c9f7314d870cf506926a81a725609a309180df7" translate="yes" xml:space="preserve">
          <source>Replicated Joins</source>
          <target state="translated">복제 된 조인</target>
        </trans-unit>
        <trans-unit id="8e2d170ab822648a868ed17db41712a1e458ed56" translate="yes" xml:space="preserve">
          <source>Reporting Progress</source>
          <target state="translated">진행 상황보고</target>
        </trans-unit>
        <trans-unit id="c3ab25ae5e2cc5df52b11a23cfbf50e86331bacb" translate="yes" xml:space="preserve">
          <source>Required keyword.</source>
          <target state="translated">필수 키워드.</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="4fef845de7495dcd1565cda432d4b9908db6c9c9" translate="yes" xml:space="preserve">
          <source>Reserved Keywords</source>
          <target state="translated">예약 키워드</target>
        </trans-unit>
        <trans-unit id="d486788d225653651eb6a74aed6bf2b553d1d42b" translate="yes" xml:space="preserve">
          <source>Return Types and Schemas</source>
          <target state="translated">반환 타입과 스키마</target>
        </trans-unit>
        <trans-unit id="5d4dbb16b26776ff0a9681435fb191cc339ea164" translate="yes" xml:space="preserve">
          <source>Return code 0: All jobs succeeded</source>
          <target state="translated">리턴 코드 0 : 모든 작업 성공</target>
        </trans-unit>
        <trans-unit id="dcf12244c4ffa52bf59195a2ed18fd4736d7b67b" translate="yes" xml:space="preserve">
          <source>Return code 1: &lt;em&gt;Used for retrievable errors&lt;/em&gt;</source>
          <target state="translated">리턴 코드 1 : &lt;em&gt;검색 가능한 오류에 사용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0358e44b177069a82ad64649295be297b6b49ac" translate="yes" xml:space="preserve">
          <source>Return code 2: All jobs have failed</source>
          <target state="translated">리턴 코드 2 : 모든 작업이 실패했습니다</target>
        </trans-unit>
        <trans-unit id="1491195b66e37f39862ac3347539de9fd938e5ac" translate="yes" xml:space="preserve">
          <source>Return code 3: Some jobs have failed</source>
          <target state="translated">리턴 코드 3 : 일부 작업이 실패했습니다</target>
        </trans-unit>
        <trans-unit id="419dc24bbf3839e94617bca8e82b80dcf575f429" translate="yes" xml:space="preserve">
          <source>Returns Euler's number e raised to the power of x.</source>
          <target state="translated">오일러의 수 e를 x의 거듭 제곱으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="513587fb94f9ca8a02c2130dbf24ce9970499d45" translate="yes" xml:space="preserve">
          <source>Returns a DateTime object according to parameters.</source>
          <target state="translated">매개 변수에 따라 DateTime 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36cf64f64f1683a1f6fd71ff4731efb70faacd64" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with leading and trailing white space removed.</source>
          <target state="translated">선행 및 후행 공백이 제거 된 문자열의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="881fb398d9c55cad7a537386644c3c3154142c43" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only leading white space removed.</source>
          <target state="translated">선행 공백 만 제거 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7af3ae3ff3f406d011103cff7ba952d404e72e2" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only trailing white space removed.</source>
          <target state="translated">후행 공백 만 제거 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2fc98512d189e4d3f3c0cca8ae024088810e4bc5" translate="yes" xml:space="preserve">
          <source>Returns a pseudo random number.</source>
          <target state="translated">의사 난수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08d59bcf7e4da2d316cce1fe0f800acd9ca0e768" translate="yes" xml:space="preserve">
          <source>Returns a string converted to upper case.</source>
          <target state="translated">대문자로 변환 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60bd6525d26a868296aef9ef39229cb4f21b553b" translate="yes" xml:space="preserve">
          <source>Returns a string with the first character converted to upper case.</source>
          <target state="translated">첫 문자를 대문자로 변환 한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a6ceee3abe688e26f32d11ad4e8bfa6056694d1" translate="yes" xml:space="preserve">
          <source>Returns a string, an int, a long, a double, or a float</source>
          <target state="translated">문자열, int, long, double 또는 float를 반환합니다</target>
        </trans-unit>
        <trans-unit id="149929531961b59343eac086b94315964280e9c6" translate="yes" xml:space="preserve">
          <source>Returns a substring from a given string.</source>
          <target state="translated">주어진 문자열에서 부분 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f650c7101aebe01253479ec3832aa36457dd38e0" translate="yes" xml:space="preserve">
          <source>Returns a unique id string for each record in the alias.</source>
          <target state="translated">별명에있는 각 레코드의 고유 ID 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1d2e7b7f3392f0d0a7f4edac2ffbf6e49ec75c21" translate="yes" xml:space="preserve">
          <source>Returns each tuple with the rank within a relation.</source>
          <target state="translated">관계 내에서 순위가있는 각 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5de4cf3d0ef61696c28177da2c48a786b952ce4f" translate="yes" xml:space="preserve">
          <source>Returns from user defined functions (UDFs)</source>
          <target state="translated">사용자 정의 함수 (UDF)에서 반환</target>
        </trans-unit>
        <trans-unit id="22f2b5afc5bcb54987844be722ae41dd06fae1e6" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) if any single argument is null.</source>
          <target state="translated">단일 인수가 널이면 널 (오류 또는 경고 없음)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a9d33c367a852dbfb596f52d5473ef9e15fc1757" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) with a null format string.</source>
          <target state="translated">널 형식 문자열과 함께 널 (오류 또는 경고 없음)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="69abd17980fc8fc326fac6f58dfef8a3d54c981e" translate="yes" xml:space="preserve">
          <source>Returns the DateTime object of the current time.</source>
          <target state="translated">현재 시간의 DateTime 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37ef5243e85c9e64bfe6667ede2cdc7c7805da8c" translate="yes" xml:space="preserve">
          <source>Returns the Unix Time as long for a DateTime object. UnixTime is the number of seconds elapsed since January 1, 1970, 00:00:00.000 GMT.</source>
          <target state="translated">DateTime 객체의 Unix 시간을 반환합니다. UnixTime은 1970 년 1 월 1 일 00 : 00 : 00.000 GMT 이후 경과 된 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="e2205e5e3349d473a1aa00a87ddbbfaf4cef2bfb" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of an expression.</source>
          <target state="translated">식의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85b804678f1cf453ee531619aad616e9ee0444a6" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of an expression.</source>
          <target state="translated">표현식의 아크 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e39a89b4ea91acef8e89dd0bab73bd8c9003ffe3" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of an expression.</source>
          <target state="translated">식의 아크 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed3aecce972de660c52bf3943dca60cdc02e893a" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of an expression.</source>
          <target state="translated">식의 아크 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11d674b8dd60cc025724efb8108982d963bec977" translate="yes" xml:space="preserve">
          <source>Returns the base 10 logarithm of an expression.</source>
          <target state="translated">식의 밑이 10 인 로그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6204881bdacb24f052b8f2ce9e963bcd536065ea" translate="yes" xml:space="preserve">
          <source>Returns the cube root of an expression.</source>
          <target state="translated">식의 세제곱근을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b91499640701da81cac5582f0880c4af26e4863c" translate="yes" xml:space="preserve">
          <source>Returns the day of a month from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 월의 일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="046718c428dc7dd4d4c49d04ec41ba4ec46e1f95" translate="yes" xml:space="preserve">
          <source>Returns the hour of a day from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 하루 중 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9e27533f3b351679e918b0146c940f249292548" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic cosine of an expression.</source>
          <target state="translated">표현식의 쌍곡 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41ba86c915c553776146f87efe83c29cb5788f94" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic sine of an expression.</source>
          <target state="translated">표현식의 쌍곡 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29c1b5b8c50562788b9f9d48e7847459fbd66840" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic tangent of an expression.</source>
          <target state="translated">표현식의 쌍곡 탄젠트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4ba0b6ea8572bf47f2c36352a0d682f2633e3113" translate="yes" xml:space="preserve">
          <source>Returns the index of the first occurrence of a character in a string, searching forward from a start index.</source>
          <target state="translated">시작 색인에서 앞으로 검색하여 문자열에서 문자의 첫 항목 색인을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b507a1b60d4ec92ab20324dabd54b2a53b040481" translate="yes" xml:space="preserve">
          <source>Returns the index of the last occurrence of a character in a string, searching backward from the end of the string.</source>
          <target state="translated">문자열 끝에서 뒤로 검색하여 문자열에서 마지막으로 나타나는 문자의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1cb694fbca257bfbfaa8a2e38404b491899885aa" translate="yes" xml:space="preserve">
          <source>Returns the millisecond of a second from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 밀리 초를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38e5458a5bbfe1c1e08c75b6ab2b15f6d398a004" translate="yes" xml:space="preserve">
          <source>Returns the minute of a hour from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 1 분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b592cc480e5ac16c4831e12d57d73c66abb6b01" translate="yes" xml:space="preserve">
          <source>Returns the month of a year from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 한 달을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48a6c81ffdf6d2cf4cf5ac04a474905115f8080f" translate="yes" xml:space="preserve">
          <source>Returns the natural logarithm (base e) of an expression.</source>
          <target state="translated">식의 자연 로그 (기본 e)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12c23b2ca17df96650ee9ee563cc87b5e17096da" translate="yes" xml:space="preserve">
          <source>Returns the number of days between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e807d5135f00cb9c11e91294361fc38911f84ce8" translate="yes" xml:space="preserve">
          <source>Returns the number of hours between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 시간 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29fdd2cb901cf9d6cedf200b96a4083351a2cbef" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 밀리 초 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="454ce2c667f43fe5c79bf50c7bd8507796c70a8a" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds elapsed since January 1, 1970, 00:00:00.000 GMT for a DateTime object.</source>
          <target state="translated">DateTime 객체에 대해 1970 년 1 월 1 일 00 : 00 : 00.000 GMT 이후 경과 된 밀리 초 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="121e43fe18bf40c290d3191cfc7659d7eb7c5f0a" translate="yes" xml:space="preserve">
          <source>Returns the number of minutes between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 시간 (분)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f78df41df2f2e976bbae604765220c5169483d0" translate="yes" xml:space="preserve">
          <source>Returns the number of months between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 개월 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fd3b014ec0a7ff566e268eee49fccc5fe1a7e48" translate="yes" xml:space="preserve">
          <source>Returns the number of seconds between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 시간 (초)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb227e6e9a62373e0c416d76c20a65d7d2dfeb0a" translate="yes" xml:space="preserve">
          <source>Returns the number of weeks between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 주 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="223d8b607ac03fc9f2f03460164780e62eb5f639" translate="yes" xml:space="preserve">
          <source>Returns the number of years between two DateTime objects.</source>
          <target state="translated">두 DateTime 객체 사이의 연도 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52badd610226f06179fe93b678ec80a1a5fd11d0" translate="yes" xml:space="preserve">
          <source>Returns the positive square root of an expression.</source>
          <target state="translated">식의 양의 제곱근을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8616431c76cac4a8057fb11c41e0a7fb048ca004" translate="yes" xml:space="preserve">
          <source>Returns the remainder of a divided by b (a%b).</source>
          <target state="translated">나머지를 b로 나눈 값을 반환합니다 (a % b).</target>
        </trans-unit>
        <trans-unit id="9f34c6241173dbb432200f51aab86ac7ba22ce94" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object minus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="translated">DateTime 객체에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration 객체를&lt;/a&gt; 뺀 결과를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6e5f4ea42054712389ba9d161a9241dc2d2bed6b" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object plus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="translated">DateTime 객체와 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration 객체&lt;/a&gt; 의 결과를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a14b74942cf37d4ce87b5279887777ffece87cb2" translate="yes" xml:space="preserve">
          <source>Returns the schema of a relation.</source>
          <target state="translated">관계의 스키마를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7604d46e673c7c005c76a6bb8363f23077180df5" translate="yes" xml:space="preserve">
          <source>Returns the second of a minute from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 1 분을 초 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9900dd72cfc78443973c5927397ba417d993936" translate="yes" xml:space="preserve">
          <source>Returns the sine of an expression.</source>
          <target state="translated">식의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afb424818b35ef253e9f9b4a24ce670200b714b6" translate="yes" xml:space="preserve">
          <source>Returns the top-n tuples from a bag of tuples.</source>
          <target state="translated">튜플 백에서 상위 n 개의 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="429dc3c96810cd8514fb775c6cad21f062815f57" translate="yes" xml:space="preserve">
          <source>Returns the trignometric tangent of an angle.</source>
          <target state="translated">각도의 삼각 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="439e6280c2aec77be8bdbea9ad7666662569a20a" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric cosine of an expression.</source>
          <target state="translated">식의 삼각 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba4f750d033224c623421cf67f35d53975b95e79" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded down to the nearest integer.</source>
          <target state="translated">가장 가까운 정수로 내림 된 표현식의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3231b2172ae518d230e21f3d1aaf0c9d68054c6c" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to a fixed number of decimal digits.</source>
          <target state="translated">고정 소수점 이하 자릿수로 반올림 된 표현식의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="732dc5476d1cc4d243ec593b786a34517d6cbbaa" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to an integer.</source>
          <target state="translated">정수로 반올림 된 표현식의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c7f0f91270d33bf1639a9d2e64d27739473916df" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded up to the nearest integer.</source>
          <target state="translated">가장 가까운 정수로 반올림 된 표현식의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0214274502e7a06d319f46f09e8cd90ba878642c" translate="yes" xml:space="preserve">
          <source>Returns the week of a week year from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 요일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06c0ada39ef7630382e9d8499fc52074d7bb307d" translate="yes" xml:space="preserve">
          <source>Returns the week year from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 요일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6e941db4f0d8d0912857032d9ad159b271b32cc" translate="yes" xml:space="preserve">
          <source>Returns the year from a DateTime object.</source>
          <target state="translated">DateTime 객체에서 연도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5764aae9ab18ee498e93f36852feed2c93bdc9fc" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-hadoop-results or script2-hadoop-results HDFS directory:</source>
          <target state="translated">script1-hadoop-results 또는 script2-hadoop-results HDFS 디렉토리에있는 결과 파일을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="87c76b6e92d7e26b17fa88c6d0f6bf26b951de10" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-local-results.txt directory.</source>
          <target state="translated">script1-local-results.txt 디렉토리에있는 결과 파일을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="012599a8c6f241f3c89808b0514daa3a79a4c971" translate="yes" xml:space="preserve">
          <source>Right outer join.</source>
          <target state="translated">오른쪽 외부 조인.</target>
        </trans-unit>
        <trans-unit id="7469e8632182ae0e8d493ab42d0b639213cfaf09" translate="yes" xml:space="preserve">
          <source>Rollup operation</source>
          <target state="translated">롤업 작업</target>
        </trans-unit>
        <trans-unit id="18b5daa46c0d001f3238ed5f9ad432b325e08c58" translate="yes" xml:space="preserve">
          <source>Rollup operations computes multiple levels of aggregates based on hierarchical ordering of specified group by dimensions. Rollup is useful when there is hierarchical ordering on the dimensions. The number of group by combinations generated by rollup for n dimensions will be n+1.</source>
          <target state="translated">롤업 작업은 차원별로 지정된 그룹의 계층 적 순서에 따라 여러 수준의 집계를 계산합니다. 롤업은 차원에 계층 적 순서가있을 때 유용합니다. n 차원에 대한 롤업으로 생성 된 조합 별 그룹 수는 n + 1입니다.</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
