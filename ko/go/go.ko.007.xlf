<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="9d2d10677b59853b34c04edbc18da2141f6ef823" translate="yes" xml:space="preserve">
          <source>ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.</source>
          <target state="translated">ParseCertificates는 지정된 ASN.1 DER 데이터에서 하나 이상의 인증서를 구문 분석합니다. 인증서는 중간 패딩없이 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fa30c63d37bc2001c3a764872c0890c61f8acf6" translate="yes" xml:space="preserve">
          <source>ParseDERCRL parses a DER encoded CRL from the given bytes.</source>
          <target state="translated">ParseDERCRL은 지정된 바이트에서 DER로 인코딩 된 CRL을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f3ec2edc0774eff41258539b91058f5d4cf9cd35" translate="yes" xml:space="preserve">
          <source>ParseDate parses an RFC 5322 date string.</source>
          <target state="translated">ParseDate는 RFC 5322 날짜 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="758fe9e9cbf2d56e3666f652d8acda7c98141564" translate="yes" xml:space="preserve">
          <source>ParseDir calls ParseFile for all files with names ending in &quot;.go&quot; in the directory specified by path and returns a map of package name -&amp;gt; package AST with all the packages found.</source>
          <target state="translated">ParseDir는 path로 지정된 디렉토리에서 이름이 &quot;.go&quot;로 끝나는 모든 파일에 대해 ParseFile을 호출하고 모든 패키지가있는 패키지 이름-&amp;gt; 패키지 AST의 맵을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="047621ddb91e82c184423e2a73f8e0cee328837e" translate="yes" xml:space="preserve">
          <source>ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.</source>
          <target state="translated">ParseDirent는 buf의 최대 디렉토리 항목을 구문 분석하여 이름에 이름을 추가합니다. buf에서 소비 한 바이트 수, 이름에 추가 된 항목 수 및 새 이름 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba15ad44a0d5b5aa5c04df3157000d88065b3088" translate="yes" xml:space="preserve">
          <source>ParseDuration</source>
          <target state="translated">ParseDuration</target>
        </trans-unit>
        <trans-unit id="0ccdc47cbfb062465c3ce4028258bbb8cace970b" translate="yes" xml:space="preserve">
          <source>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as &quot;300ms&quot;, &quot;-1.5h&quot; or &quot;2h45m&quot;. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.</source>
          <target state="translated">ParseDuration은 기간 문자열을 구문 분석합니다. 기간 문자열은 부호있는 10 진수 시퀀스이며, 각각 선택적 분수 및 &quot;300ms&quot;, &quot;-1.5h&quot;또는 &quot;2h45m&quot;과 같은 단위 접미사를 갖습니다. 유효한 시간 단위는 &quot;ns&quot;, &quot;us&quot;(또는 &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6665378bb888147fd38985161b70b786f3c21803" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC public key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey는 SEC 1, ASN.1 DER 형식의 EC 공개 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="892fbba930b3566d06f9df2030763cda6ce95827" translate="yes" xml:space="preserve">
          <source>ParseError describes a problem parsing a time string.</source>
          <target state="translated">ParseError는 시간 문자열을 구문 분석하는 중 문제점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9a582c1b02184d48074757655b946996d9f55882" translate="yes" xml:space="preserve">
          <source>ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.</source>
          <target state="translated">ParseExpr은 표현식 x의 AST를 얻는 편리한 함수입니다. AST에 기록 된 위치 정보는 정의되어 있지 않습니다. 오류 메시지에 사용 된 파일 이름은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4fb56e49503c8edcde61d5f7c76a772eeec3484c" translate="yes" xml:space="preserve">
          <source>ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.</source>
          <target state="translated">ParseExprFrom은 표현식을 구문 분석하기위한 편리한 함수입니다. 인수는 ParseFile과 동일한 의미를 갖지만 소스는 유효한 Go (유형 또는 값) 표현식이어야합니다. 특히, fset은 nil이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="1451f0a6821c5b4b2901efe0f3d53819e7c6a483" translate="yes" xml:space="preserve">
          <source>ParseFile</source>
          <target state="translated">ParseFile</target>
        </trans-unit>
        <trans-unit id="8e9f94dbd4c4295f5a413cdec1747ee6881cd1da" translate="yes" xml:space="preserve">
          <source>ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.</source>
          <target state="translated">ParseFile은 단일 Go 소스 파일의 소스 코드를 구문 분석하고 해당 ast.File 노드를 리턴합니다. 소스 코드는 소스 파일의 파일 이름 또는 src 매개 변수를 통해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af492bad6c90c31471d746324ef2632bf8eb772d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles는 새 템플리트를 작성하고 이름 지정된 파일에서 템플리트 정의를 구문 분석합니다. 반환 된 템플릿 이름은 첫 번째 파일의 (기본) 이름과 (구문 분석 된) 내용을 갖습니다. 파일이 하나 이상 있어야합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 * Template이 nil입니다.</target>
        </trans-unit>
        <trans-unit id="8327ff213ed2179b27e0e16f606053c1fb04d28d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles는 새 템플리트를 작성하고 이름 지정된 파일에서 템플리트 정의를 구문 분석합니다. 반환 된 템플릿 이름은 기본 이름과 첫 번째 파일의 구문 분석 된 내용을 갖습니다. 파일이 하나 이상 있어야합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 * Template이 nil입니다.</target>
        </trans-unit>
        <trans-unit id="ce6f3fc6adf60ff33bcdf40a608ef536cc90aa22" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.</source>
          <target state="translated">ParseFiles는 명명 된 파일을 구문 분석하고 결과 템플릿을 t와 연결합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 템플리트는 nil입니다. 그렇지 않으면 t입니다. 파일이 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="79c733c837a6ce524269772c4ef5bf48fb11ea5a" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.</source>
          <target state="translated">ParseFiles는 명명 된 파일을 구문 분석하고 결과 템플릿을 t와 연결합니다. 오류가 발생하면 구문 분석이 중지되고 리턴 된 템플리트는 nil입니다. 그렇지 않으면 t입니다. 파일이 하나 이상 있어야합니다. ParseFiles로 작성된 템플리트는 인수 파일의 기본 이름으로 이름이 지정되므로 t는 일반적으로 파일의 (기본) 이름 중 하나의 이름을 가져야합니다. 그렇지 않으면 ParseFiles를 호출하기 전에 t의 내용에 따라 t.Execute가 실패 할 수 있습니다. 이 경우 t.ExecuteTemplate을 사용하여 유효한 템플릿을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="91b51eccc60ebf92659e48c7256549a53f281cf8" translate="yes" xml:space="preserve">
          <source>ParseFiles returns an error if t or any associated template has already been executed.</source>
          <target state="translated">t 또는 관련 템플릿이 이미 실행 된 경우 ParseFiles는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b854a59dfcaea7000b265f3f7af7b0441340249" translate="yes" xml:space="preserve">
          <source>ParseFloat</source>
          <target state="translated">ParseFloat</target>
        </trans-unit>
        <trans-unit id="a968f6b35cbd445c2c3e17a676a673ab0f036e6d" translate="yes" xml:space="preserve">
          <source>ParseFloat accepts decimal and hexadecimal floating-point number syntax. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</source>
          <target state="translated">ParseFloat는 10 진수 및 16 진수 부동 소수점 숫자 구문을 허용합니다. s의 형식이 올 바르고 유효한 부동 소수점 수에 가까운 경우 ParseFloat는 IEEE754 바이어스되지 않은 반올림을 사용하여 반올림 된 가장 가까운 부동 소수점 수를 반환합니다. 16 진 부동 소수점 값을 구문 분석하면 16 진 표현에 가수에 맞는 것보다 많은 비트가있는 경우에만 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="af48529cc69b2749ba1cfbd0072a925bc4216cca" translate="yes" xml:space="preserve">
          <source>ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.</source>
          <target state="translated">ParseFloat는 bitSize에 의해 지정된 정밀도 (float32의 경우 32, float64의 경우 64)로 문자열 s를 부동 소수점 숫자로 변환합니다. bitSize = 32 인 경우 결과에는 여전히 float64 유형이 있지만 값을 변경하지 않고 float32로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f279e3e47cdc9cf9d872e61192822459d62d17" translate="yes" xml:space="preserve">
          <source>ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.</source>
          <target state="translated">ParseFloat는 f가 주어진 정밀도 및 반올림 모드로 설정된 f.Parse (s, base)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd5ce5b41aa64ac617d720e123321224a7f4d140" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, &quot;+Inf&quot;, and &quot;-Inf&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat는 문자열 &quot;NaN&quot;, &quot;+ Inf&quot;및 &quot;-Inf&quot;를 각각의 특수 부동 소수점 값으로 인식합니다. 일치하는 경우 대소 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7da060a59d225b78f860ce3acdb64ab957496796" translate="yes" xml:space="preserve">
          <source>ParseForm populates r.Form and r.PostForm.</source>
          <target state="translated">ParseForm은 r.Form 및 r.PostForm을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="07f8973752a66d43b70ef7fb0a84b494aed23663" translate="yes" xml:space="preserve">
          <source>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob은 새 템플리트를 작성하고 패턴으로 식별 된 파일에서 템플리트 정의를 구문 분석합니다. 파일은 filepath.Match의 의미에 따라 일치하며 패턴은 하나 이상의 파일과 일치해야합니다. 반환 된 템플릿은 패턴과 일치하는 첫 번째 파일의 (기본) 이름과 (구문 분석 된) 내용을 갖습니다. ParseGlob은 패턴과 일치하는 파일 목록으로 ParseFiles를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0041d2aedbde4c39f613a021a871fa8b33bebd33" translate="yes" xml:space="preserve">
          <source>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob은 패턴으로 식별 된 파일에서 템플리트 정의를 구문 분석하고 결과 템플리트를 t와 연관시킵니다. 파일은 filepath.Match의 의미에 따라 일치하며 패턴은 하나 이상의 파일과 일치해야합니다. ParseGlob은 패턴과 일치하는 파일 목록으로 t.ParseFiles를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57508561e68db8f352026127277c4527c06f1494" translate="yes" xml:space="preserve">
          <source>ParseGlob returns an error if t or any associated template has already been executed.</source>
          <target state="translated">t 또는 관련 템플릿이 이미 실행 된 경우 ParseGlob은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c95736c9372d59f539bafb6f91f3448c1e25ac0" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses a HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion은 HTTP 버전 문자열을 구문 분석합니다. &quot;HTTP / 1.0&quot;은 (1, 0, true)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6238bd01ff6944e78dfd936bd2b841304ebe18fe" translate="yes" xml:space="preserve">
          <source>ParseIP</source>
          <target state="translated">ParseIP</target>
        </trans-unit>
        <trans-unit id="e5c3f7806dc6261b34a424f0eac37be19bc2181d" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (&quot;192.0.2.1&quot;) or IPv6 (&quot;2001:db8::68&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP는 s를 IP 주소로 구문 분석하여 결과를 반환합니다. 문자열은 점으로 구분 된 10 진수 ( &quot;192.0.2.1&quot;) 또는 IPv6 ( &quot;2001 : db8 :: 68&quot;) 형식 일 수 있습니다. s가 유효한 IP 주소의 텍스트 표현이 아닌 경우 ParseIP는 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c329eecfda46c75a2f5a9732976e5ca2eab67b96" translate="yes" xml:space="preserve">
          <source>ParseInLocation</source>
          <target state="translated">ParseInLocation</target>
        </trans-unit>
        <trans-unit id="b946980b6995c0bdde650965df500396097ee47e" translate="yes" xml:space="preserve">
          <source>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.</source>
          <target state="translated">ParseInLocation은 구문 분석과 비슷하지만 두 가지 중요한 차이점이 있습니다. 첫째, 시간대 정보가없는 경우 Parse는 시간을 UTC로 해석합니다. ParseInLocation은 주어진 위치에서 시간을 해석합니다. 둘째, 구역 오프셋이나 약어가 주어지면 Parse는 지역 위치와 일치 시키려고 시도합니다. ParseInLocation은 주어진 위치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd43b39f1cc6436ed26bf5ddd12e6461d48a315e" translate="yes" xml:space="preserve">
          <source>ParseInt</source>
          <target state="translated">ParseInt</target>
        </trans-unit>
        <trans-unit id="da8e97b7f44fd2f5e3e7756990fdef1ef6036785" translate="yes" xml:space="preserve">
          <source>ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</source>
          <target state="translated">ParseInt는 주어진 기본 (0, 2 ~ 36) 및 비트 크기 (0 ~ 64)의 문자열 s를 해석하고 해당 값 i를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da7fc45328cc9114fb2744e73272d12d929fea5f" translate="yes" xml:space="preserve">
          <source>ParseList parses the given string as a list of comma-separated addresses of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">ParseList는 주어진 문자열을 &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot;또는 &quot;foo@example.com&quot;형식의 쉼표로 구분 된 주소 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="721a0c1b5d6d1ee41cb2e1ce2ccd8399686328dd" translate="yes" xml:space="preserve">
          <source>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:</source>
          <target state="translated">ParseMAC는 다음 형식 중 하나를 사용하여 IEEE 802 MAC-48, EUI-48, EUI-64 또는 20 옥텟 IP over InfiniBand 링크 계층 주소로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="76d8884907e134cde6d1ae2f450cf0d83b8102aa" translate="yes" xml:space="preserve">
          <source>ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.</source>
          <target state="translated">ParseMediaType은 RFC 1521에 따라 미디어 유형 값과 선택적 매개 변수를 구문 분석합니다. 미디어 유형은 Content-Type 및 Content-Disposition 헤더 (RFC 2183)의 값입니다. 성공하면 ParseMediaType은 소문자로 변환되고 공백과 0이 아닌 맵으로 트리밍 된 미디어 유형을 반환합니다. 선택적 매개 변수를 구문 분석하는 동안 오류가 발생하면 미디어 유형이 오류 ErrInvalidMediaParameter와 함께 반환됩니다. 반환 된 맵 params는 대소 문자를 유지하면서 소문자 속성에서 속성 값으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8befc3cebb8742e6d50cfeac64769f0a3fff7a" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm calls ParseForm automatically. ParseForm is idempotent.</source>
          <target state="translated">ParseMultipartForm은 ParseForm을 자동으로 호출합니다. ParseForm은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="4205ffb0814fbcba9218830e9ad58589fcb016f6" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.</source>
          <target state="translated">ParseMultipartForm은 요청 본문을 multipart / form-data로 구문 분석합니다. 전체 요청 본문이 구문 분석되고 파일 부분의 최대 maxMemory 바이트가 메모리에 저장되고 나머지는 디스크에 임시 파일로 저장됩니다. 필요한 경우 ParseMultipartForm은 ParseForm을 호출합니다. ParseMultipartForm을 한 번 호출 한 후에는 후속 호출이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eecdedc3b85cbbe7f7cb2f75d45c36832c9b2317" translate="yes" xml:space="preserve">
          <source>ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.</source>
          <target state="translated">ParseNetlinkMessage는 b를 넷 링크 메시지의 배열로 구문 분석하고 NetlinkMessage 구조를 포함하는 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2f0d8e60be2a0b26156f23d2b913830f42953f1b" translate="yes" xml:space="preserve">
          <source>ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.</source>
          <target state="translated">ParseNetlinkRouteAttr은 m의 페이로드를 netlink 라우트 속성의 배열로 구문 분석하고 NetlinkRouteAttr 구조를 포함하는 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ca8ea4136f1532755b07a48dc5268d78ecf1507c" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey는 PKCS # 1, ASN.1 DER 형식의 RSA 개인 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="37bf10698677a842cf4d973614d5f0307c9b4ece" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey는 PKCS # 1, ASN.1 DER 형식의 RSA 공개 키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="585855469081df34619bcab57c0395b99ac9b879" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS#8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey는 암호화되지 않은 개인 키를 PKCS # 8, ASN.1 DER 형식으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="53e14792de36ed6cd3349fb2645358e6cd29fbb8" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey</source>
          <target state="translated">ParsePKIXPublicKey</target>
        </trans-unit>
        <trans-unit id="6a4599b4f783a30e67850f302db74a263e5ed679" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form.</source>
          <target state="translated">ParsePKIXPublicKey는 공개 키를 PKIX, ASN.1 DER 형식으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9e247d1a303dadeb36ebb627b0c5ca3e52bc27fd" translate="yes" xml:space="preserve">
          <source>ParseQuery</source>
          <target state="translated">ParseQuery</target>
        </trans-unit>
        <trans-unit id="7c00812498355c3d782c270a326950a437297e57" translate="yes" xml:space="preserve">
          <source>ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.</source>
          <target state="translated">ParseQuery는 URL 인코딩 된 쿼리 문자열을 구문 분석하고 각 키에 지정된 값을 나열하는 맵을 반환합니다. ParseQuery는 항상 발견 된 모든 유효한 쿼리 매개 변수가 포함 된 비-닐 맵을 반환합니다. err은 발생한 첫 번째 디코딩 오류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3d5fafc8859915dea1eca90debdb2203d7081d9e" translate="yes" xml:space="preserve">
          <source>ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)</source>
          <target state="translated">ParseRequestURI는 rawurl을 URL 구조로 구문 분석합니다. rawurl이 HTTP 요청에서 수신되었다고 가정하므로 rawurl은 절대 URI 또는 ​​절대 경로로만 해석됩니다. rawurl 문자열은 #fragment 접미사가없는 것으로 가정합니다. (웹 브라우저는 URL을 웹 서버로 보내기 전에 #fragment를 제거합니다.)</target>
        </trans-unit>
        <trans-unit id="303cbaa0aec4b7b4cb545ea3bdd253a60da46165" translate="yes" xml:space="preserve">
          <source>ParseSocketControlMessage parses b as an array of socket control messages.</source>
          <target state="translated">ParseSocketControlMessage는 b를 소켓 제어 메시지의 배열로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="68f8375ee4255e9bdd0c3030df2260150e5493b0" translate="yes" xml:space="preserve">
          <source>ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.</source>
          <target state="translated">ParseTime은 HTTP / 1.1에서 허용하는 세 가지 형식 (TimeFormat, time.RFC850 및 time.ANSIC) 각각을 시도하여 시간 헤더 (예 : Date : 헤더)를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d09c9d04f1ff3f62cff402b66559957826b67ae1" translate="yes" xml:space="preserve">
          <source>ParseUint</source>
          <target state="translated">ParseUint</target>
        </trans-unit>
        <trans-unit id="7c5c32fd6cd92c39f679dc5ed50b80a4f8a1e92b" translate="yes" xml:space="preserve">
          <source>ParseUint is like ParseInt but for unsigned numbers.</source>
          <target state="translated">ParseUint는 ParseInt와 비슷하지만 부호없는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5bf4d74ce6c1b340caf3e896ab5b84ef49cf1719" translate="yes" xml:space="preserve">
          <source>ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.</source>
          <target state="translated">ParseUnixCredentials는 Ucred 구조의 자격 증명이 포함 된 소켓 제어 메시지를 디코딩합니다. 이러한 메시지를 받으려면 소켓에서 SO_PASSCRED 옵션을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2cd01c6af8de29d78551fd8726d012bba380c6c" translate="yes" xml:space="preserve">
          <source>ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.</source>
          <target state="translated">ParseUnixRights는 다른 프로세스에서 열린 파일 디스크립터의 정수 배열을 포함하는 소켓 제어 메시지를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="32ac0722953b3173953c3c4db2a050c68e2bace4" translate="yes" xml:space="preserve">
          <source>Parsed reports whether f.Parse has been called.</source>
          <target state="translated">구문 분석은 f.Parse가 호출되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="3448f815420bc7428adf585d197c1f125467f90e" translate="yes" xml:space="preserve">
          <source>Parsed reports whether the command-line flags have been parsed.</source>
          <target state="translated">구문 분석은 명령 행 플래그가 구문 분석되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="dc2eb8678f8e8ede0972857e44c6282f328cc1fa" translate="yes" xml:space="preserve">
          <source>Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</source>
          <target state="translated">skip = 0을 전달하면 rpc.NewClient에서 Add를 호출 할 때 스택 추적이 시작됩니다. skip = 1을 전달하면 mypkg.Run 내에서 NewClient를 호출 할 때 스택 추적이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bc137142636c80e92c407f2aa46fcdf54313c790" translate="yes" xml:space="preserve">
          <source>Password returns the password in case it is set, and whether it is set.</source>
          <target state="translated">비밀번호는 설정 한 경우와 설정 여부에 따라 비밀번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c6302867f847fe663bbe8d220f8e92a48796687" translate="yes" xml:space="preserve">
          <source>Path returns the package path.</source>
          <target state="translated">경로는 패키지 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0506b7bdb505a3150b81c4c616dee83d176fcfa" translate="yes" xml:space="preserve">
          <source>PathError records an error and the operation and file path that caused it.</source>
          <target state="translated">PathError는 오류와 그 원인이 된 작업 및 파일 경로를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e7599081a40b17f0e8c56bbb5dfa806da5a30888" translate="yes" xml:space="preserve">
          <source>PathEscape escapes the string so it can be safely placed inside a URL path segment, replacing special characters (including /) with %XX sequences as needed.</source>
          <target state="translated">PathEscape는 문자열을 이스케이프하여 URL 경로 세그먼트 내에 안전하게 배치하여 필요에 따라 특수 문자 (/ 포함)를 % XX 시퀀스로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5c3a77b47b5350edac8b6dbc79888f216cc42e3c" translate="yes" xml:space="preserve">
          <source>PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">PathUnescape는 PathEscape의 역변환을 수행하여 &quot;% AB&quot;형식의 각 3 바이트 인코딩 된 하위 문자열을 16 진 디코딩 된 바이트 0xAB로 변환합니다. % 뒤에 두 개의 16 진수가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40463bc26e83c862cf3b0e60286130df1ab877d6" translate="yes" xml:space="preserve">
          <source>PathUnescape is identical to QueryUnescape except that it does not unescape '+' to ' ' (space).</source>
          <target state="translated">PathUnescape는 '+'를 ''(공백)로 이스케이프 처리하지 않는다는 점을 제외하고 QueryUnescape와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cda78fe9f7d0595a1e181ce1981b7483036ab29c" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="translated">패턴은 선택적으로 호스트 이름으로 시작하여 해당 호스트의 URL로만 일치를 제한 할 수 있습니다. 호스트 별 패턴은 일반 패턴보다 우선하므로 처리기는 &quot; &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt; 요청을 인계하지 않고&quot;/ codesearch &quot;및&quot;codesearch.google.com/ &quot;두 패턴을 등록 할 수 있습니다 . &quot;.</target>
        </trans-unit>
        <trans-unit id="c47c55adf239beb3a291abbb9f63d307ef60c16f" translate="yes" xml:space="preserve">
          <source>Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;, or rooted subtrees, like &quot;/images/&quot; (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both &quot;/images/&quot; and &quot;/images/thumbnails/&quot;, the latter handler will be called for paths beginning &quot;/images/thumbnails/&quot; and the former will receive requests for any other paths in the &quot;/images/&quot; subtree.</source>
          <target state="translated">패턴 이름은 &quot;/favicon.ico&quot;와 같은 고정 된 루트 경로 또는 &quot;/ images /&quot;와 같은 루트 하위 트리 (후행 슬래시 참고)입니다. &quot;/ images /&quot;및 &quot;/ images / thumbnails /&quot;에 등록 된 핸들러가 있으면 &quot;/ images / thumbnails /&quot;및 이전의 경로에 대해 후자의 핸들러가 호출되도록 더 긴 패턴이 더 짧은 패턴보다 우선합니다. &quot;/ images /&quot;하위 트리의 다른 경로에 대한 요청을받습니다.</target>
        </trans-unit>
        <trans-unit id="f28eb62c201920349ad82fd89183cea2a77fc0ce" translate="yes" xml:space="preserve">
          <source>Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.</source>
          <target state="translated">Peek는 스캐너를 진행하지 않고 소스에서 다음 유니 코드 문자를 반환합니다. 스캐너 위치가 소스의 마지막 문자 인 경우 EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2959c1935503c7a46c0b1958e9d8a81763a0ed6a" translate="yes" xml:space="preserve">
          <source>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.</source>
          <target state="translated">Peek는 리더를 진행시키지 않고 다음 n 바이트를 반환합니다. 바이트는 다음 읽기 호출에서 유효하지 않습니다. Peek가 n 바이트 미만을 반환하면 읽기가 짧은 이유를 설명하는 오류도 반환합니다. n이 b의 버퍼 크기보다 큰 경우 오류는 ErrBufferFull입니다.</target>
        </trans-unit>
        <trans-unit id="eb621fcca2c83af4eb20df9787fc904ec33fe0d9" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been received on the connection.</source>
          <target state="translated">보류 중은 연결에서 수신 한 응답하지 않은 요청 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c6855a32465d5bf0f448eaa4af31e378ea6b4379" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been sent on the connection.</source>
          <target state="translated">보류 중은 연결에서 전송 된 응답하지 않은 요청 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7ceccb01b416098f13eef5c65da35dd4ef29c59" translate="yes" xml:space="preserve">
          <source>Perl character classes (all ASCII-only):</source>
          <target state="translated">펄 문자 클래스 (모든 ASCII 전용) :</target>
        </trans-unit>
        <trans-unit id="327a2b8cad2b9a6ef158a641755a49d69b9cc93f" translate="yes" xml:space="preserve">
          <source>Perm</source>
          <target state="translated">Perm</target>
        </trans-unit>
        <trans-unit id="b4cbc1d379695fc60a43435dd6614970bc7cf1c8" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m.</source>
          <target state="translated">Perm은 Unix 권한 비트를 m 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ed0eddcb867d78e7678ca142786b03c98fcc1cf" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.</source>
          <target state="translated">Perm은 기본 소스에서 정수 [0, n)의 의사 난수 순열을 n int 슬라이스로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62a4f6eab662c10e8c22fcd7a13a5adce4b9aeef" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).</source>
          <target state="translated">Perm은 정수 [0, n)의 의사 난수 순열을 n 개의 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2eb6560251a01ddeba6819d546ca94bf5106de3c" translate="yes" xml:space="preserve">
          <source>Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].</source>
          <target state="translated">Phase는 x의 위상 (인수라고도 함)을 반환합니다. 반환 된 값은 [-Pi, Pi] 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62187a44c4849f243c0d01a0cd965d235c59c18" translate="yes" xml:space="preserve">
          <source>Pid returns the process id of the exited process.</source>
          <target state="translated">Pid는 종료 된 프로세스의 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aaf942e54daedd7cb953cee036ee4e01d73e3a05" translate="yes" xml:space="preserve">
          <source>Ping verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">Ping은 데이터베이스에 대한 연결이 아직 활성 상태인지 확인하고 필요한 경우 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1616a118fdcaf54f337c10d117d16aaa99fd0b14" translate="yes" xml:space="preserve">
          <source>PingContext verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">PingContext는 데이터베이스에 대한 연결이 아직 활성 상태인지 확인하고 필요한 경우 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8c943ad1575fde013a5e267aa7a5a04d105d169b" translate="yes" xml:space="preserve">
          <source>PingContext verifies the connection to the database is still alive.</source>
          <target state="translated">PingContext는 데이터베이스와의 연결이 여전히 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7a788a1af96c8d9977c69732be97c930615c2f24" translate="yes" xml:space="preserve">
          <source>Pinger is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Pinger는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="e40f59609b56b44e5054b6b92f52ff52a16d5fa3" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.</source>
          <target state="translated">파이프는 동기식 인 메모리 파이프를 만듭니다. io.Reader가 필요한 코드와 io.Writer가 필요한 코드를 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da50f6a47a89e9218a08186e61e447aeaa977683" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.</source>
          <target state="translated">파이프는 동기식 메모리 내 전이중 네트워크 연결을 생성합니다. 양쪽 끝은 Conn 인터페이스를 구현합니다. 한쪽 끝의 읽기는 다른 쪽의 쓰기와 일치하며 두 쪽 사이에 데이터를 직접 복사합니다. 내부 버퍼링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a31ea2b0e32b3e571d1bceba86196d7bad1fcb8" translate="yes" xml:space="preserve">
          <source>Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.</source>
          <target state="translated">파이프는 연결된 파일 쌍을 반환합니다. r에서 w에 쓴 바이트를 읽습니다. 파일과 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20f3a37d20161b0046bc712fcc1c973a57a664dc" translate="yes" xml:space="preserve">
          <source>PipeNode holds a pipeline with optional declaration</source>
          <target state="translated">PipeNode는 선택적 선언이있는 파이프 라인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f28715a2c22fba2d801918b67be067614e3917c8" translate="yes" xml:space="preserve">
          <source>Pipeline, to manage pipelined requests and responses in a client.</source>
          <target state="translated">파이프 라인 : 클라이언트에서 파이프 라인 요청 및 응답을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="06fc1a48588c809599455a2829c6d8c93dab2807" translate="yes" xml:space="preserve">
          <source>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).</source>
          <target state="translated">PixOffset은 (x, y)의 픽셀에 해당하는 Pix의 첫 번째 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf14eb94c114379d054dbd030d4c5c1a50c1bc82" translate="yes" xml:space="preserve">
          <source>Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.</source>
          <target state="translated">Pkg는 객체가 속한 패키지를 반환합니다. 유니버스 범위의 레이블 및 개체에는 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b25672d57f482ab04e1df337de0aebb92458d0d" translate="yes" xml:space="preserve">
          <source>PlainAuth</source>
          <target state="translated">PlainAuth</target>
        </trans-unit>
        <trans-unit id="0e0cce6c4e84e3f28344ac03eb2bbf3c7be04c28" translate="yes" xml:space="preserve">
          <source>PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.</source>
          <target state="translated">PlainAuth는 RFC 4616에 정의 된대로 PLAIN 인증 메커니즘을 구현하는 인증을 반환합니다. 반환 된 인증은 지정된 사용자 이름과 비밀번호를 사용하여 호스트하고 ID로 작동하도록 인증합니다. 일반적으로 아이디는 사용자 이름 역할을하는 빈 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="32488aca0b25b337080ddc28faef0ad97faab0e7" translate="yes" xml:space="preserve">
          <source>PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.</source>
          <target state="translated">연결이 TLS를 사용 중이거나 로컬 호스트에 연결된 경우 PlainAuth는 자격 증명을 보냅니다. 그렇지 않으면 자격 증명을 보내지 않고 오류와 함께 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b8996c869faa8282ed1dc0af722f7f384a441369" translate="yes" xml:space="preserve">
          <source>Plan 9</source>
          <target state="translated">계획 9</target>
        </trans-unit>
        <trans-unit id="fcc50dd97b375efa9e5795002087751fd071d726" translate="yes" xml:space="preserve">
          <source>Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4&amp;times;4&amp;times;4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.</source>
          <target state="translated">Plan9는 24 비트 RGB 공간을 4x4x4 세분으로 분할하고 각 서브 큐브에 4 개의 음영을 갖는 256 색 팔레트입니다. WebSafe와 비교하여 아이디어는 색상 큐브를 더 적은 수의 셀로 나누어 색상 해상도를 줄이고 여분의 공간을 사용하여 강도 해상도를 높이는 것입니다. 그 결과 16 개의 회색 음영 (각각 4 개의 샘플이있는 4 개의 회색 서브 큐브), 각 1 차 및 2 차 색상의 13 개의 음영 (4 개의 샘플 + 검정이있는 3 개의 서브 큐브) 및 나머지 색상 큐브를 덮는 합리적인 색상 선택이 가능합니다. 연속 톤을 더 잘 표현할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8a06b24fa70984798bf322daaec557c2b6f1b4" translate="yes" xml:space="preserve">
          <source>Playable Examples must be in a package whose name ends in &quot;_test&quot;. An Example is &quot;playable&quot; (the Play field is non-nil) in either of these circumstances:</source>
          <target state="translated">재생 가능한 예제는 이름이 &quot;_test&quot;로 끝나는 패키지에 있어야합니다. 다음 상황 중 하나에 대한 예는 &quot;재생 가능&quot;(재생 필드는 0이 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="2c6beabd4a6c27d664359314bb0b7be1a4bee461" translate="yes" xml:space="preserve">
          <source>Plugin is a loaded Go plugin.</source>
          <target state="translated">플러그인은로드 된 Go 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="79d975c909286257ed2dc841463cf2221331b8a7" translate="yes" xml:space="preserve">
          <source>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:</source>
          <target state="translated">포인터는 임의의 유형에 대한 포인터를 나타냅니다. 다른 유형에는 사용할 수없는 포인터 유형에 사용할 수있는 네 가지 특수 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c031e92d2b285f06539e450cbc88db48ddddac" translate="yes" xml:space="preserve">
          <source>Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</source>
          <target state="translated">포인터는 v의 값을 uintptr로 반환합니다. unsafe.Pointer 대신 uintptr을 반환하므로 reflect를 사용하는 코드는 unsafe.Pointers를 명시 적으로 가져 오지 않으면 unsafe.Pointer를 얻을 수 없습니다. v의 종류가 Chan, Func, Map, Ptr, Slice 또는 UnsafePointer가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="baef0ef34fa58ab846963eb42f08d22cc0916958" translate="yes" xml:space="preserve">
          <source>Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.</source>
          <target state="translated">따라서 포인터는 프로그램이 형식 시스템을 무시하고 임의의 메모리를 읽고 쓸 수 있도록합니다. 매우주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c228a838e9e7815109b6016259a9375cc32a3ee5" translate="yes" xml:space="preserve">
          <source>Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.</source>
          <target state="translated">Go의 == 연산자를 사용하여 포인터 값이 같거나 값이 매우 같으면 포인터 값이 매우 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab46185459d2a7d78c59879c795ee53dd26dd358" translate="yes" xml:space="preserve">
          <source>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</source>
          <target state="translated">포인터 값은 지정된 값으로 인코딩됩니다. nil 포인터는 null JSON 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cde07b059e3c084c9da753efae9fdd148fa375" translate="yes" xml:space="preserve">
          <source>Pointer:</source>
          <target state="translated">Pointer:</target>
        </trans-unit>
        <trans-unit id="b64fba6378c386a82e71d5a623e279c432da4e08" translate="yes" xml:space="preserve">
          <source>Polar</source>
          <target state="translated">Polar</target>
        </trans-unit>
        <trans-unit id="a5fb429c2bb667a352c2046e02293fc421f8310b" translate="yes" xml:space="preserve">
          <source>Polar returns the absolute value r and phase &amp;theta; of x, such that x = r * e**&amp;theta;i. The phase is in the range [-Pi, Pi].</source>
          <target state="translated">극좌표는 x = r * e ** &amp;theta;i가되도록 절대 값 r과 x의 위상 &amp;theta;를 반환합니다. 위상은 [-Pi, Pi] 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6bda38a58104dfd742e2b251475f4fc7ad35e0" translate="yes" xml:space="preserve">
          <source>Polynomials are represented in LSB-first form also known as reversed representation.</source>
          <target state="translated">다항식은 역 표현으로도 알려진 LSB- 첫 번째 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="62976d6c6dce665baf19823706626b87a619028b" translate="yes" xml:space="preserve">
          <source>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</source>
          <target state="translated">풀의 목적은 나중에 재사용하기 위해 할당되었지만 사용하지 않는 항목을 캐시하여 가비지 수집기의 압력을 완화하는 것입니다. 즉, 효율적이고 스레드로부터 안전한 목록을 쉽게 작성할 수 있습니다. 그러나 모든 무료 목록에 적합하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a894961424546348d9d455a430167c6470d0b453" translate="yes" xml:space="preserve">
          <source>Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).</source>
          <target state="translated">팝은 힙에서 최소 요소 (적어짐에 따라)를 제거하고 반환합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다. 팝은 제거 (h, 0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c331ce3bd04c4d21d66fc2ae1a5de46dd73eec8" translate="yes" xml:space="preserve">
          <source>Port returns the port part of u.Host, without the leading colon.</source>
          <target state="translated">포트는 선행 콜론없이 u.Host의 포트 부분을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="42cb37e41618d46d1d0e8d0bf5e059552b858cb3" translate="yes" xml:space="preserve">
          <source>Portable analogs of some common system call errors.</source>
          <target state="translated">일반적인 시스템 호출 오류의 휴대용 아날로그.</target>
        </trans-unit>
        <trans-unit id="97e4fd0d08cb7c58f4698b53bcfb9441c857ebec" translate="yes" xml:space="preserve">
          <source>Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.</source>
          <target state="translated">Pos 및 End는 스코프의 소스 ​​코드 범위 [pos, end)를 설명합니다. 형식 확인 AST에 전체 위치 정보가있는 경우에만 결과가 유효합니다. 유니버스 및 패키지 범위에 대해서는 범위가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c60ba97a8cb410a549bfe181eeaa63408b55cba" translate="yes" xml:space="preserve">
          <source>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).</source>
          <target state="translated">Pos는 객체 이름 선언의 소스 위치를 계산합니다. 계산할 수없는 경우 결과가 유효하지 않을 수 있습니다 (obj.Decl이 nil이거나 올바르지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="a0ec3702b899c2917ee8242be4cbe0bff05b9658" translate="yes" xml:space="preserve">
          <source>Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.</source>
          <target state="translated">Pos는 파일 세트 내에서 소스 위치의 컴팩트 인코딩입니다. 보다 편리하지만 훨씬 더 큰 표현을 위해 위치로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9fa7b2eba24dae9008da03956b9fa4fe5bac8a" translate="yes" xml:space="preserve">
          <source>Pos represents a byte position in the original input text from which this template was parsed.</source>
          <target state="translated">Pos는이 템플리트가 구문 분석 된 원래 입력 텍스트의 바이트 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="edf92f1280756c43fc75532da3d73537cdede740" translate="yes" xml:space="preserve">
          <source>Pos returns the Pos value for the given file offset; the offset must be &amp;lt;= f.Size(). f.Pos(f.Offset(p)) == p.</source>
          <target state="translated">Pos는 주어진 파일 오프셋에 대한 Pos 값을 반환합니다. 오프셋은 &amp;lt;= f.Size () 여야합니다. f. 위치 (f. 오프셋 (p)) == p.</target>
        </trans-unit>
        <trans-unit id="5ff010dde5f69bdb9f99370ef921975c8f9209ff" translate="yes" xml:space="preserve">
          <source>Pos returns the declaration position of the object's identifier.</source>
          <target state="translated">Pos는 객체 식별자의 선언 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd367287d957f8b0726b9d88a222f0d52b30fd66" translate="yes" xml:space="preserve">
          <source>Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.</source>
          <target state="translated">Pos는 다음 또는 스캔에 대한 마지막 호출에서 리턴 된 문자 또는 토큰 바로 다음에 문자의 위치를 ​​리턴합니다. 가장 최근에 스캔 한 토큰의 시작 위치에 스캐너 위치 필드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e31be0876f71b9f08f689f98e0ab92c2ffe225b9" translate="yes" xml:space="preserve">
          <source>Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &amp;lt; q is true if the file implied by p was added to the respective file set before the file implied by q.</source>
          <target state="translated">Pos 값은 일반적인 비교 연산자와 직접 비교할 수 있습니다. 두 Pos 값 p와 q가 동일한 파일에 있으면 p와 q를 비교하는 것은 각 소스 파일 오프셋을 비교하는 것과 같습니다. p와 q가 서로 다른 파일에있는 경우, p가 암시하는 파일이 q가 암시하는 파일 전에 각 파일 세트에 추가 된 경우 p &amp;lt;q는 true입니다.</target>
        </trans-unit>
        <trans-unit id="5fc2fa994bbd914263ceb34efcf25eb956fe5e38" translate="yes" xml:space="preserve">
          <source>Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</source>
          <target state="translated">위치는 파일 세트의 위치 p를 위치 값으로 변환합니다. s.Position (p) 호출은 s.PositionFor (p, true) 호출과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b93209a85028bf6019382a8729f55ac8145e29b1" translate="yes" xml:space="preserve">
          <source>Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &amp;gt; 0.</source>
          <target state="translated">위치는 파일, 행 및 열 위치를 포함한 임의의 소스 위치를 나타냅니다. 행 번호가 0보다 크면 위치가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d1086db7e34e995911902270435427be7e528699" translate="yes" xml:space="preserve">
          <source>Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</source>
          <target state="translated">위치는 주어진 파일 위치 p에 대한 위치 값을 반환합니다. f.Position (p) 호출은 f.PositionFor (p, true) 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bee67f02828c19ef6ab2c5867d78daacd16a5b6" translate="yes" xml:space="preserve">
          <source>PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.</source>
          <target state="translated">PositionFor는 파일 세트의 Pos p를 위치 값으로 변환합니다. 조정이 설정되면 위치 변경 // 줄 설명;을 통해 위치를 조정할 수 있습니다. 그렇지 않으면 해당 주석은 무시됩니다. p는 s 또는 NoPos의 Pos 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d4ffd5f491d5a7cdece709329d95542f519d748" translate="yes" xml:space="preserve">
          <source>PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.</source>
          <target state="translated">PositionFor는 주어진 파일 위치 p에 대한 위치 값을 반환합니다. 조정이 설정되면 위치 변경 // 줄 설명;을 통해 위치를 조정할 수 있습니다. 그렇지 않으면 해당 주석은 무시됩니다. p는 f 또는 NoPos의 Pos 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac52c588d2d22788d46da883fda78a4165f3071" translate="yes" xml:space="preserve">
          <source>Possible values for the EncryptPEMBlock encryption algorithm.</source>
          <target state="translated">EncryptPEMBlock 암호화 알고리즘에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e039b08aed18ef386a63d77f040148c0406ea827" translate="yes" xml:space="preserve">
          <source>Post is a wrapper around DefaultClient.Post.</source>
          <target state="translated">Post는 DefaultClient.Post 주위의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="4ccc94f360bffe8b14b21c70371bc08f8fc85aba" translate="yes" xml:space="preserve">
          <source>Post issues a POST to the specified URL.</source>
          <target state="translated">Post는 지정된 URL에 POST를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="cf67d20c1f3d564f229d45c7bbe51d8dd1d5c4f9" translate="yes" xml:space="preserve">
          <source>PostForm is a wrapper around DefaultClient.PostForm.</source>
          <target state="translated">PostForm은 DefaultClient.PostForm을 감싸는 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="44be7db278a3bb23e34b6df9cf0308f04a22ef65" translate="yes" xml:space="preserve">
          <source>PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.</source>
          <target state="translated">PostForm은 데이터의 키와 값을 요청 본문으로 URL 인코딩하여 지정된 URL에 POST를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="be4e82ca926447e7fa579fe9a0de6822470bae52" translate="yes" xml:space="preserve">
          <source>PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.</source>
          <target state="translated">PostFormValue는 POST, PATCH 또는 PUT 요청 본문의 명명 된 구성 요소에 대한 첫 번째 값을 반환합니다. URL 쿼리 매개 변수는 무시됩니다. PostFormValue는 필요한 경우 ParseMultipartForm 및 ParseForm을 호출하고 이러한 함수에서 반환 된 오류를 무시합니다. 키가 없으면 PostFormValue는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be28cb761efe315e0e552f0578874dbad93fb2dd" translate="yes" xml:space="preserve">
          <source>Pow</source>
          <target state="translated">Pow</target>
        </trans-unit>
        <trans-unit id="f475da806450b4216a6a39ef8f751e26584a0aa3" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y.</source>
          <target state="translated">Pow는 y의 기본 x 지수 인 x ** y를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d31ee5908c32da0243ccfa92f5fe1c7b3e3aeaf" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:</source>
          <target state="translated">Pow는 y의 기본 x 지수 인 x ** y를 반환합니다. math.Pow와의 일반화 된 호환성 :</target>
        </trans-unit>
        <trans-unit id="f348c46b140ea99d08517640a0cfa8eff3f40986" translate="yes" xml:space="preserve">
          <source>Pow10</source>
          <target state="translated">Pow10</target>
        </trans-unit>
        <trans-unit id="aee903bac5380775ed6f4d539640fd38f8839815" translate="yes" xml:space="preserve">
          <source>Pow10 returns 10**n, the base-10 exponential of n.</source>
          <target state="translated">Pow10은 기본 10 지수 n의 10 ** n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5411be6b25a0cd127e0815f04ee1c12c71a3cf9d" translate="yes" xml:space="preserve">
          <source>Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">Prec는 x의 가수 정밀도를 비트 단위로 반환합니다. | x |의 경우 결과는 0 일 수 있습니다. == 0 및 | x | == Inf.</target>
        </trans-unit>
        <trans-unit id="012c1f9cb43bafa38c87d810c24d42b2a0e95129" translate="yes" xml:space="preserve">
          <source>Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.</source>
          <target state="translated">우선 순위는 2 진 연산자 op의 연산자 우선 순위를 리턴합니다. op가 이항 연산자가 아닌 경우 결과는 LowestPrecedence입니다.</target>
        </trans-unit>
        <trans-unit id="06b7f0534bb083dff059cb7b1d374b3c3f1e0a29" translate="yes" xml:space="preserve">
          <source>Precompute performs some calculations that speed up private key operations in the future.</source>
          <target state="translated">사전 계산은 향후 개인 키 작업 속도를 높이는 일부 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="34240aca8e0c8b909225cdb2f4dfdd60a5391649" translate="yes" xml:space="preserve">
          <source>Precondition: the Uses and Defs maps are populated.</source>
          <target state="translated">전제 조건 : Uses 및 Defs 맵이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7070c5f6250bbd470fe7f73bafbee45d2955ddb3" translate="yes" xml:space="preserve">
          <source>Predefined global functions are named as follows.</source>
          <target state="translated">미리 정의 된 전역 함수의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e21e54618fe5bb45663e64ef56fb6717d24f3e6f" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</source>
          <target state="translated">사전 정의 된 레이아웃 ANSIC, UnixDate, RFC3339 및 기타는 표준 시간 및 참조 시간의 편리한 표현을 설명합니다. 참조 시간의 형식과 정의에 대한 자세한 내용은 ANSIC 설명서 및이 패키지에서 정의한 기타 상수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19d40016f56bfc80ec50dda03a3f66d54afe65d3" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">사전 정의 된 레이아웃 ANSIC, UnixDate, RFC3339 및 기타는 표준 시간 및 참조 시간의 편리한 표현을 설명합니다. 참조 시간의 형식과 정의에 대한 자세한 내용은 ANSIC 설명서 및이 패키지에서 정의한 기타 상수를 참조하십시오. 또한 Time.Format의 실행 예제는 레이아웃 문자열의 작동을 자세하게 보여 주며 좋은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="019d3598b39c078722d988d313bff8da4d9cf574" translate="yes" xml:space="preserve">
          <source>Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to:</source>
          <target state="translated">토큰 인식을 제어하기위한 사전 정의 된 모드 비트. 예를 들어, 식별자, 정수만 인식하고 주석을 건너 뛰도록 검사기를 구성하려면 검사기 모드 필드를 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0eea29821ab0f93a1960c9475350fbefcdab3d2f" translate="yes" xml:space="preserve">
          <source>Predefined polynomials.</source>
          <target state="translated">미리 정의 된 다항식.</target>
        </trans-unit>
        <trans-unit id="0d4a9c1b8dc6a14ced81402c9c52d4cba69192f5" translate="yes" xml:space="preserve">
          <source>Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.</source>
          <target state="translated">접두사는 정규 표현식과 일치하는 모든 문자로 시작해야하는 리터럴 문자열을 리턴합니다. 접두사가 전체 일치 인 경우 완료입니다.</target>
        </trans-unit>
        <trans-unit id="07aedbb616a135989fac4d8d72b5c4a5c5d60c82" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the logger.</source>
          <target state="translated">접두사는 로거의 출력 접 두부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d115a4bd5d23f67905e010343d63485a225c3e87" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the standard logger.</source>
          <target state="translated">접두사는 표준 로거의 출력 접 두부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a0ad1efe973aa121d35889249f93a7d412bb0f0" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">준비는 이후 쿼리 또는 실행을 위해 준비된 문을 만듭니다. 리턴 된 명령문에서 여러 쿼리 또는 실행이 동시에 실행될 수 있습니다. 명령문이 더 이상 필요하지 않으면 호출자는 명령문의 Close 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2f69751c5da712872417f2a510b17bd5264a134" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for use within a transaction.</source>
          <target state="translated">준비는 트랜잭션 내에서 사용할 준비된 명령문을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="19c3c9a0f98a28102c0e736d9c3bf4d64087898f" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">PrepareContext는 이후 쿼리 또는 실행을 위해 준비된 명령문을 작성합니다. 리턴 된 명령문에서 여러 쿼리 또는 실행이 동시에 실행될 수 있습니다. 명령문이 더 이상 필요하지 않으면 호출자는 명령문의 Close 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6597b9664b9651bf9f54fe07c6db1a86396a5f0" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for use within a transaction.</source>
          <target state="translated">PrepareContext는 트랜잭션 내에서 사용할 준비된 명령문을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="152856201f7dfb04864788231e3dca46c0bc77c0" translate="yes" xml:space="preserve">
          <source>Prev returns the previous list element or nil.</source>
          <target state="translated">이전은 이전 목록 요소 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4d145ba4ec6ded69ec8461fe1ea7b2b7ec58ca2" translate="yes" xml:space="preserve">
          <source>Prev returns the previous ring element. r must not be empty.</source>
          <target state="translated">이전은 이전 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88971ab7b2fead8d5aa7c50c15f575453db641e4" translate="yes" xml:space="preserve">
          <source>Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &amp;lt; 2.</source>
          <target state="translated">소수는 주어진 크기의 숫자 p를 반환하므로 p는 확률이 높은 소수입니다. 프라임은 rand.Read 또는 비트 &amp;lt;2 인 경우 반환 된 오류에 대해 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="f10e9ffa0b7bfc2f4378fe30b103cef0c696cbab" translate="yes" xml:space="preserve">
          <source>Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">인쇄는 표준 로거로 인쇄하기 위해 출력을 호출합니다. 인수는 fmt.Print 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="da7a32afaab2e92c2ad95514fe5016080d044d92" translate="yes" xml:space="preserve">
          <source>Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">인쇄 호출 l. 로거로 인쇄하기위한 출력. 인수는 fmt.Print 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0199bdcf8fc8fa33bd7d6ab92875f9706a01bd" translate="yes" xml:space="preserve">
          <source>Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자의 기본 형식을 사용하여 형식을 인쇄하고 표준 출력에 씁니다. 문자열이 아닌 경우 피연산자 사이에 공백이 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d837aa33f1404ff26202e67efb03427b1d31566" translate="yes" xml:space="preserve">
          <source>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).</source>
          <target state="translated">인쇄는 nil 필드를 건너 뛰고 x를 표준 출력으로 인쇄합니다. 인쇄 (fset, x)는 Fprint (os.Stdout, fset, x, NotNilFilter)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fff8914dcd8a6ac6b5cf34d89aeea00386da1b24" translate="yes" xml:space="preserve">
          <source>Print, Println, and Printf lay out their arguments differently. In this example we can compare their behaviors. Println always adds blanks between the items it prints, while Print adds blanks only between non-string arguments and Printf does exactly what it is told. Sprint, Sprintln, Sprintf, Fprint, Fprintln, and Fprintf behave the same as their corresponding Print, Println, and Printf functions shown here.</source>
          <target state="translated">Print, Println 및 Printf는 서로 다른 주장을 제시합니다. 이 예에서는 동작을 비교할 수 있습니다. Println은 항상 인쇄하는 항목 사이에 공백을 추가하는 반면 Print는 문자열이 아닌 인수 사이에만 공백을 추가하고 Printf는 정확히 알려줍니다. Sprint, Sprintln, Sprintf, Fprint, Fprintln 및 Fprintf는 여기에 표시된 해당 Print, Println 및 Printf 기능과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="809bcd004fc9b80aebb7cc5d33f0d171da74d5a1" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form</source>
          <target state="translated">PrintDefaults는 달리 정의되지 않은 경우 정의 된 모든 명령 줄 플래그의 기본 설정을 보여주는 사용 메시지를 표준 오류로 인쇄합니다. 정수 값 플래그 x의 경우 기본 출력 형식은</target>
        </trans-unit>
        <trans-unit id="66f194d8340d19b81ae4cbbaf04b180769f0bc50" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.</source>
          <target state="translated">PrintDefaults는 달리 구성하지 않는 한 세트에 정의 된 모든 명령 행 플래그의 기본값을 표준 오류로 인쇄합니다. 자세한 내용은 전역 함수 PrintDefaults 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0413304ebeab6806f19cc2877f7f0a8ff6c54cbc" translate="yes" xml:space="preserve">
          <source>PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.</source>
          <target state="translated">PrintError는 err 매개 변수가 ErrorList 인 경우 오류 목록을 한 줄에 하나씩 w에 인쇄하는 유틸리티 함수입니다. 그렇지 않으면 오류 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ebb2a34b39577c89ac6bbac4cad20176461fcd0b" translate="yes" xml:space="preserve">
          <source>PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.</source>
          <target state="translated">PrintRanges는 Go에 따라 인쇄 가능한 문자 세트를 정의합니다. ASCII 공간 U + 0020은 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e979fdd38cfa18a2850ab6725519f82f13a4893f" translate="yes" xml:space="preserve">
          <source>PrintStack prints to standard error the stack trace returned by runtime.Stack.</source>
          <target state="translated">PrintStack은 runtime.Stack에 의해 리턴 된 스택 추적을 표준 오류로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="d092eac8d8c7315f01318a4675b38dcda90f6b2f" translate="yes" xml:space="preserve">
          <source>Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf는 출력을 호출하여 표준 로거로 인쇄합니다. 인수는 fmt.Printf 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d34579b37294eb8c93cd5f76572f924816678d0e" translate="yes" xml:space="preserve">
          <source>Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf는 l.Output을 호출하여 로거에 인쇄합니다. 인수는 fmt.Printf 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e063c30289e6b7981e882f4697ef852c1f482795" translate="yes" xml:space="preserve">
          <source>Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">형식 지정자에 따라 형식을 인쇄하고 표준 출력에 씁니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28fa9c40e9ffd74bb5b4f094116329456de9f692" translate="yes" xml:space="preserve">
          <source>PrintfLine writes the formatted output followed by \r\n.</source>
          <target state="translated">PrintfLine은 형식화 된 출력 뒤에 \ r \ n을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f16eadab2a72ff13044cc806dbcf2c117b32244f" translate="yes" xml:space="preserve">
          <source>Printing</source>
          <target state="translated">Printing</target>
        </trans-unit>
        <trans-unit id="9be957a1debff697aafdc7801a3e8785262f0c15" translate="yes" xml:space="preserve">
          <source>Println</source>
          <target state="translated">Println</target>
        </trans-unit>
        <trans-unit id="29f11f56c6deffe1a15f67edc9a4aa4f5e39f28b" translate="yes" xml:space="preserve">
          <source>Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println은 출력을 호출하여 표준 로거로 인쇄합니다. 인수는 fmt.Println의 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cddfe7aeafd7792bfbbf9d5f8715705f967fa901" translate="yes" xml:space="preserve">
          <source>Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println은 l.Output을 호출하여 로거에 인쇄합니다. 인수는 fmt.Println의 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="811e4464a94616bb8d26e71f2e575488ec162b1d" translate="yes" xml:space="preserve">
          <source>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자에 대한 기본 형식을 사용하여 Println 형식을 지정하고 표준 출력에 씁니다. 피연산자 사이에 공백이 항상 추가되고 개행이 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca8881cd0811d2e92d6c86ae2702d8e81b20152f" translate="yes" xml:space="preserve">
          <source>PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.</source>
          <target state="translated">PrivateKey는 Ed25519 개인 키의 유형입니다. crypto.Signer를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0a4394946d56678a7614480ff518a3bad620dfd6" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a DSA private key.</source>
          <target state="translated">PrivateKey는 DSA 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5828291a45f65d96ddf669061359c25c2c15c6d0" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a private key using an unspecified algorithm.</source>
          <target state="translated">PrivateKey는 지정되지 않은 알고리즘을 사용하는 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a98b6c2702640d21b9c48b8d270c3e30325339a" translate="yes" xml:space="preserve">
          <source>PrivateKey represents an ECDSA private key.</source>
          <target state="translated">PrivateKey는 ECDSA 개인 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d801231cb01d152413f0eb3fd1b96b8b8b32f86" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.</source>
          <target state="translated">아마도 Prime은 2⁶⁴ 미만의 입력에 대해 100 % 정확합니다. 오류 확률에 대한 자세한 내용은 Menezes 등, Applied Cryptography Handbook, 1997, 145-149 및 FIPS 186-4 부록 F를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="442fffca41b5ff8be9e7d3c5a0d5bb3bcdd79c79" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.</source>
          <target state="translated">아마도 Prime은 공격자가 시험을 속이려고 만든 프라임을 판단하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5acf5649dd4748b450f268e217b8fc03d7e5d83" translate="yes" xml:space="preserve">
          <source>ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.</source>
          <target state="translated">ProbablyPrime은 x가 아마도 소수인지를보고, 무작위로 선택된 n 개의 염기와 Baillie-PSW 테스트로 Miller-Rabin 테스트를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f565348ea6c07ff9cfffba23f4ddef524854d6c5" translate="yes" xml:space="preserve">
          <source>ProcAttr holds attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr에는 StartProcess에 의해 시작된 새 프로세스에 적용될 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12810a35fd4b52423e92a433b314e79f5156c70" translate="yes" xml:space="preserve">
          <source>ProcAttr holds the attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr은 StartProcess에 의해 시작된 새 프로세스에 적용될 속성을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="5373df2ffeb91866eef2c38e2502d77f1e33d970" translate="yes" xml:space="preserve">
          <source>Process stores the information about a process created by StartProcess.</source>
          <target state="translated">Process는 StartProcess에 의해 생성 된 프로세스에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7be9488d8073639c8b5c8f975d63715a76c9482d" translate="yes" xml:space="preserve">
          <source>ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).</source>
          <target state="translated">ProcessEnv는 요청 자체에 포함되지 않은 요청 r과 연관된 FastCGI 환경 변수를 리턴합니다. 데이터는 요청 컨텍스트에 숨겨져 있습니다. 예를 들어, REMOTE_USER가 요청에 대해 설정된 경우 r의 어느 곳에서도 찾을 수 없지만 r의 컨텍스트를 통해 ProcessEnv의 응답에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9471e4ecfd3d8f84d8e198229a6e563cc60bb5bd" translate="yes" xml:space="preserve">
          <source>ProcessState stores information about a process, as reported by Wait.</source>
          <target state="translated">ProcessState는 Wait에 의해보고 된 프로세스에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="1ccb21389489c4ce498c4e53d4d69158c5c216b7" translate="yes" xml:space="preserve">
          <source>Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.</source>
          <target state="translated">프로파일은 pprof 형식의 CPU 프로파일로 응답합니다. 프로파일 링은 GET 매개 변수 (초)로 지정된 지속 시간 동안, 또는 지정되지 않은 경우 30 초 동안 지속됩니다. 패키지 초기화는 / debug / pprof / profile로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="a111deba4cb386ad7d27a3a5da110f46f90e53f3" translate="yes" xml:space="preserve">
          <source>Profiles are only as good as the kernel support used to generate them. See &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; for details about known problems.</source>
          <target state="translated">프로파일은 프로파일을 생성하는 데 사용 된 커널 지원만큼 우수합니다. 알려진 문제점에 대한 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f633a064ff1568b947a4aec717cb8ff7b8d5f4c3" translate="yes" xml:space="preserve">
          <source>Profiles can then be visualized with the pprof tool:</source>
          <target state="translated">그러면 pprof 도구를 사용하여 프로파일을 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43cf39e026d58fac3cfa9c9d78bd864d77127ed" translate="yes" xml:space="preserve">
          <source>Profiles returns a slice of all the known profiles, sorted by name.</source>
          <target state="translated">프로파일은 알려진 모든 프로파일의 슬라이스를 이름별로 정렬하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e204c80d31036e0e024c0b7ffd8999a887af815c" translate="yes" xml:space="preserve">
          <source>Profiling a Go program</source>
          <target state="translated">Go 프로그램 프로파일 링</target>
        </trans-unit>
        <trans-unit id="cd24f23a82cfebc48d38726d6b4c3ec7db051af8" translate="yes" xml:space="preserve">
          <source>Prog.Flag</source>
          <target state="translated">Prog.Flag</target>
        </trans-unit>
        <trans-unit id="48f3611555518363414a9b1db2fa49f474f76e67" translate="yes" xml:space="preserve">
          <source>Prog.Type</source>
          <target state="translated">Prog.Type</target>
        </trans-unit>
        <trans-unit id="2301ced48f29c8456865c04cd47334c707828d9b" translate="yes" xml:space="preserve">
          <source>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:</source>
          <target state="translated">컨텍스트를 사용하는 프로그램은 다음 규칙을 따라 패키지 간 인터페이스의 일관성을 유지하고 정적 분석 도구가 컨텍스트 전파를 점검 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ac27ec45d4018361c7d594bf7eaa91a1292edd0" translate="yes" xml:space="preserve">
          <source>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.</source>
          <target state="translated">시간을 사용하는 프로그램은 일반적으로 포인터가 아닌 값으로 저장하고 전달해야합니다. 즉, 시간 변수 및 구조체 필드는 * time.Time이 아니라 time.Time 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9ee0039dcc32da9c4cde1d419e8461ac1dfbdc7" translate="yes" xml:space="preserve">
          <source>Properties is the set of Unicode property tables.</source>
          <target state="translated">속성은 유니 코드 속성 테이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="8768305a872da3684ae4bda3f68612735ba56c08" translate="yes" xml:space="preserve">
          <source>Properties of basic types.</source>
          <target state="translated">기본 유형의 속성.</target>
        </trans-unit>
        <trans-unit id="8a0d90b2918aadcefa0c95820abf21b6534492f2" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.</source>
          <target state="translated">ProtoAtLeast는 요청에 사용 된 HTTP 프로토콜이 major.minor 이상인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="ff9e390e5de482119dc42236df206efa900791fc" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.</source>
          <target state="translated">ProtoAtLeast는 응답에 사용 된 HTTP 프로토콜이 major.minor 이상인지보고합니다.</target>
        </trans-unit>
        <trans-unit id="5829d5d1675f9485036e8bdae05dd67dac955b66" translate="yes" xml:space="preserve">
          <source>ProtocolError represents an HTTP protocol error.</source>
          <target state="translated">ProtocolError는 HTTP 프로토콜 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c78f3a99754e80287f834beff8dcfd502a6d93a8" translate="yes" xml:space="preserve">
          <source>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:</source>
          <target state="translated">T2가 T1보다 크지 않고 둘이 동등한 메모리 레이아웃을 공유하는 경우이 변환을 통해 한 유형의 데이터를 다른 유형의 데이터로 재 해석 할 수 있습니다. 예는 math.Float64bits의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="2667527e2309cea50315245bf9e96ef013a2321b" translate="yes" xml:space="preserve">
          <source>ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.</source>
          <target state="translated">ProxyFromEnvironment는 환경 변수 HTTP_PROXY, HTTPS_PROXY 및 NO_PROXY (또는 소문자 버전)로 표시되는 지정된 요청에 사용할 프록시의 URL을 반환합니다. https 요청의 경우 HTTPS_PROXY가 HTTP_PROXY보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ce1c8acc8d3a18105ad805c3050485bfd7af1196" translate="yes" xml:space="preserve">
          <source>ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.</source>
          <target state="translated">ProxyURL은 항상 동일한 URL을 반환하는 프록시 함수 (전송에 사용)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="256df6693e9938b002805ef141a169ee9b0517c0" translate="yes" xml:space="preserve">
          <source>Pt is shorthand for Point{X, Y}.</source>
          <target state="translated">Pt는 Point {X, Y}의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="72df9c957a8f34680bd544544cf16bd450f7c686" translate="yes" xml:space="preserve">
          <source>PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</source>
          <target state="translated">PtrTo는 요소 t와 함께 포인터 유형을 리턴합니다. 예를 들어, t가 Foo 유형을 나타내는 경우 PtrTo (t)는 * Foo를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b89d49d722a1ef7d3c4ddfb234a1400f1a92cf6" translate="yes" xml:space="preserve">
          <source>Public returns the PublicKey corresponding to priv.</source>
          <target state="translated">Public은 priv에 해당하는 PublicKey를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2649f0278f57fd7af2dbdfb64c901b42e9d9789a" translate="yes" xml:space="preserve">
          <source>Public returns the public key corresponding to priv.</source>
          <target state="translated">공개는 개인에 해당하는 공개 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d04adf8945e312c7d47fec2108c21b2684c9af5" translate="yes" xml:space="preserve">
          <source>PublicKey is the type of Ed25519 public keys.</source>
          <target state="translated">PublicKey는 Ed25519 공개 키의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5001eedc91686ba11ee390e67cd1a676465f5d14" translate="yes" xml:space="preserve">
          <source>PublicKey represents a DSA public key.</source>
          <target state="translated">PublicKey는 DSA 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3acd186c84de8cd73322d4669ae9a4bf40b59d13" translate="yes" xml:space="preserve">
          <source>PublicKey represents a public key using an unspecified algorithm.</source>
          <target state="translated">PublicKey는 지정되지 않은 알고리즘을 사용하여 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2f28570f8dc7131bd19dca1ee8af4ed1f0eeb1b5" translate="yes" xml:space="preserve">
          <source>PublicKey represents an ECDSA public key.</source>
          <target state="translated">PublicKey는 ECDSA 공개 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b2140dd5a5a558ac28d58aa5d36d6a21620f906f" translate="yes" xml:space="preserve">
          <source>PublicSuffixList provides the public suffix of a domain. For example:</source>
          <target state="translated">PublicSuffixList는 도메인의 공개 접미사를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edb82c4a8bbcf78c8a1448e29c8d98e501e15f1e" translate="yes" xml:space="preserve">
          <source>Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.</source>
          <target state="translated">게시는 명명 된 내 보낸 변수를 선언합니다. 이것은 Var을 생성 할 때 패키지의 init 함수에서 호출되어야합니다. 이름이 이미 등록되어 있으면 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf5378cf82463ae57e7e9a30e9ba5b326dba3d6" translate="yes" xml:space="preserve">
          <source>Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">푸시는 요소 x를 힙으로 푸시합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="f4b202999ae2b93ddb6f5cd751aefdf3cb3293cf" translate="yes" xml:space="preserve">
          <source>PushBack inserts a new element e with value v at the back of list l and returns e.</source>
          <target state="translated">푸시 백은리스트 l의 뒤에 값 v를 가진 새로운 요소 e를 삽입하고 e를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a50f3f664eb834d0bdb9f4d025dcb754c041066d" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList는 목록 l의 뒷면에 다른 목록의 사본을 삽입합니다. 리스트 l 및 기타는 동일 할 수있다. 그들은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8c99a25179d82d5afa3406e22b548a0252f1474" translate="yes" xml:space="preserve">
          <source>PushFront inserts a new element e with value v at the front of list l and returns e.</source>
          <target state="translated">PushFront는 목록 l 앞에 v 값을 가진 새로운 요소 e를 삽입하고 e를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13a7ef38dc8b3d5639e9784f576b7dc8f0a8b795" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList는 목록 l의 앞에 다른 목록의 사본을 삽입합니다. 리스트 l 및 기타는 동일 할 수있다. 그들은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="5520408cb4fcced642940bef6746727866edb323" translate="yes" xml:space="preserve">
          <source>PushOptions describes options for Pusher.Push.</source>
          <target state="translated">PushOptions는 Pusher.Push에 대한 옵션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="192422b7c0ce1637e319052ddc27aa0f79641ec0" translate="yes" xml:space="preserve">
          <source>Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;.</source>
          <target state="translated">Pusher는 HTTP / 2 서버 푸시를 지원하는 ResponseWriter가 구현 한 인터페이스입니다. 자세한 배경은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5810d2cea2c4c839a1cbc6f93eed06050e059bdc" translate="yes" xml:space="preserve">
          <source>Put adds x to the pool.</source>
          <target state="translated">Put은 풀에 x를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b32dae99e29878f191b30318e13ee160e3e9c11" translate="yes" xml:space="preserve">
          <source>PutUvarint</source>
          <target state="translated">PutUvarint</target>
        </trans-unit>
        <trans-unit id="d471216e431bf21e4cd2b9153a740d7d8a93b34a" translate="yes" xml:space="preserve">
          <source>PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.</source>
          <target state="translated">PutUvarint는 uint64를 buf로 인코딩하고 쓴 바이트 수를 반환합니다. 버퍼가 너무 작 으면 PutUvarint가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="88299e1b8aa44f2b22e86375ae77e2d6a8112536" translate="yes" xml:space="preserve">
          <source>PutVarint</source>
          <target state="translated">PutVarint</target>
        </trans-unit>
        <trans-unit id="bd00eee1df8f0b67019e2ad70e9156e5fa1de99c" translate="yes" xml:space="preserve">
          <source>PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.</source>
          <target state="translated">PutVarint는 int64를 buf로 인코딩하고 쓴 바이트 수를 반환합니다. 버퍼가 너무 작 으면 PutVarint가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="95ab58079356ed9aa8893c2df192745f32d71297" translate="yes" xml:space="preserve">
          <source>Quantizer produces a palette for an image.</source>
          <target state="translated">양자화 기는 이미지의 팔레트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="05437837ec4647b7c23a7c5944b51f3ac43e58c7" translate="yes" xml:space="preserve">
          <source>Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">Query는 주어진 인수로 준비된 쿼리 문을 실행하고 쿼리 결과를 * Rows로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d610ca285b8521b4fbaa375322142cf95d05446a" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">쿼리는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e1388b391779ee3280bdae6ba4b75470fb85b182" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">쿼리는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="73ccd82bfd6eca331cabb2dba278895a7773c1c8" translate="yes" xml:space="preserve">
          <source>Query is expected to be a list of key=value settings separated by ampersands or semicolons. A setting without an equals sign is interpreted as a key set to an empty value.</source>
          <target state="translated">쿼리는 앰퍼샌드 또는 세미콜론으로 구분 된 키 = 값 설정 목록이어야합니다. 등호가없는 설정은 빈 값으로 설정된 키로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4501151d792df2b730db74682f29db9657ef7ffb" translate="yes" xml:space="preserve">
          <source>Query may return ErrSkip.</source>
          <target state="translated">쿼리가 ErrSkip을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b497d6ece5d419609d5ec0635dc46c1d21b395" translate="yes" xml:space="preserve">
          <source>Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.</source>
          <target state="translated">쿼리는 RawQuery를 구문 분석하고 해당 값을 반환합니다. 잘못된 값 쌍을 자동으로 버립니다. 오류를 확인하려면 ParseQuery를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8a08387889457a5be56952e049ecbbf787ca1008" translate="yes" xml:space="preserve">
          <source>QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">QueryContext는 주어진 인수로 준비된 쿼리 문을 실행하고 쿼리 결과를 * Rows로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90f64cb7930640d89ee4991b926e5cee52278a6e" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">QueryContext는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="610270ccdd5f9415ac6596bb377b874f11fadbf3" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">QueryContext는 행 (일반적으로 SELECT)을 반환하는 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7370d9d4f8639b69a2498dbee7578b05f64c38fb" translate="yes" xml:space="preserve">
          <source>QueryEscape escapes the string so it can be safely placed inside a URL query.</source>
          <target state="translated">QueryEscape는 문자열을 이스케이프하여 URL 쿼리 내에 안전하게 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddc8a6f5079b6c63ba14548ae3605122eaf2692" translate="yes" xml:space="preserve">
          <source>QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow는 주어진 인수로 준비된 쿼리 문을 실행합니다. 명령문을 실행하는 동안 오류가 발생하면 리턴 된 * Row에서 Scan을 호출하여 해당 오류가 리턴되며 이는 항상 0이 아닙니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="0573144afbb38c9c195cafc127ff8c5f7fcc98f1" translate="yes" xml:space="preserve">
          <source>QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow는 최대 하나의 행을 반환 할 것으로 예상되는 쿼리를 실행합니다. QueryRow는 항상 0이 아닌 값을 반환합니다. Row의 Scan 메서드가 호출 될 때까지 오류가 지연됩니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="5b9f01963f310c9b55f64de5af1de9e922ab703a" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext는 주어진 인수로 준비된 쿼리 문을 실행합니다. 명령문을 실행하는 동안 오류가 발생하면 리턴 된 * Row에서 Scan을 호출하여 해당 오류가 리턴되며 이는 항상 0이 아닙니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="297d4c57ac1fe022d65f3f9afe2a0b04f607cea7" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext는 최대 하나의 행을 리턴 할 것으로 예상되는 쿼리를 실행합니다. QueryRowContext는 항상 0이 아닌 값을 리턴합니다. Row의 Scan 메서드가 호출 될 때까지 오류가 지연됩니다. 조회가 행을 선택하지 않으면 * Row의 스캔은 ErrNoRows를 리턴합니다. 그렇지 않으면 * 행 스캔은 선택된 첫 번째 행을 스캔하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="dcdd15a746401ad098faa59578b02f667ab6f1ed" translate="yes" xml:space="preserve">
          <source>QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">QueryUnescape는 QueryEscape의 역변환을 수행하여 &quot;% AB&quot;형식의 각 3 바이트 인코딩 서브 스트링을 16 진 디코딩 된 바이트 0xAB로 변환합니다. % 뒤에 두 개의 16 진수가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02d2728197191f99f0589563ffe142aff0d31057" translate="yes" xml:space="preserve">
          <source>Queryer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Queryer는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="1c47ac983cb47637ae28fbb6e2c18b4b8c42e06e" translate="yes" xml:space="preserve">
          <source>QueryerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">QueryerContext는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0013523fcda039d68ac4ad5f69b453c942a978cf" translate="yes" xml:space="preserve">
          <source>QueryerContext may return ErrSkip.</source>
          <target state="translated">QueryerContext는 ErrSkip을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63975c9274fd71acb9468b157e86657fe44318f" translate="yes" xml:space="preserve">
          <source>QueryerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">QueryerContext는 컨텍스트 제한 시간을 준수하고 컨텍스트가 취소되면 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="9769d5fe0c55a8ef8d81aaad984f657373379c37" translate="yes" xml:space="preserve">
          <source>Quit sends the QUIT command and closes the connection to the server.</source>
          <target state="translated">종료는 QUIT 명령을 전송하고 서버에 대한 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="7e1aae2dbf075bb68d93d724ad6566e5e4a1c5e3" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">Quo는 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7929eb506dd3242d50cf4b52d276a4b8cb9c07b" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.</source>
          <target state="translated">Quo는 y! = 0에 대해 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Quo는 Go와 같은 잘린 나누기를 구현합니다. 자세한 내용은 QuoRem을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1572bc36f1694a28504f4543686c15ca4cc42af5" translate="yes" xml:space="preserve">
          <source>Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.</source>
          <target state="translated">Quo는 z를 둥근 몫 x / y로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. 두 피연산자가 모두 0이거나 무한대 인 경우 ErrNaN을 사용한 쿼닉이 발생합니다. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e212957f2d4b215b9b3d9954ca4d24b4f7b7f8" translate="yes" xml:space="preserve">
          <source>QuoRem implements T-division and modulus (like Go):</source>
          <target state="translated">QuoRem은 T- 분할과 모듈러스 (Go와 같은)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9ddbdd15bfd376c21e0a62b9370cde6334dc1f4" translate="yes" xml:space="preserve">
          <source>QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">QuoRem은 z를 몫 x / y로 설정하고 r을 나머지 x % y로 설정하고 y! = 0에 대한 쌍 (z, r)을 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="309028a9e01273ac7a88142bf26446f3f2a8f06c" translate="yes" xml:space="preserve">
          <source>Quote</source>
          <target state="translated">Quote</target>
        </trans-unit>
        <trans-unit id="02a6b721c3cbad5a2ac35c25089d53ad320899bd" translate="yes" xml:space="preserve">
          <source>Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:</source>
          <target state="translated">Quote 및 QuoteToASCII는 문자열을 인용 된 Go 문자열 리터럴로 변환합니다. 후자는 ASCII가 아닌 유니 코드를 \ u로 이스케이프 처리하여 결과가 ASCII 문자열임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="3617a988d68c2550b56a0533be32b6f532f0c980" translate="yes" xml:space="preserve">
          <source>Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">Quote는 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 제어 문자 및 IsPrint에 의해 정의 된 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f31dc77f679cfa7aaf16ecb978ab9c3d8982f6f" translate="yes" xml:space="preserve">
          <source>QuoteMeta</source>
          <target state="translated">QuoteMeta</target>
        </trans-unit>
        <trans-unit id="37da03d2f50ceab91ce8002d89f395e8b70d32e3" translate="yes" xml:space="preserve">
          <source>QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.</source>
          <target state="translated">QuoteMeta는 인수 텍스트 내부의 모든 정규식 메타 문자를 이스케이프하는 문자열을 반환합니다. 반환 된 문자열은 리터럴 텍스트와 일치하는 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="e4b2ad9113103116d841b51eb9a5a4bb79d43dd5" translate="yes" xml:space="preserve">
          <source>QuoteRune</source>
          <target state="translated">QuoteRune</target>
        </trans-unit>
        <trans-unit id="642db102936be1179d9fd316324babf33d424684" translate="yes" xml:space="preserve">
          <source>QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.</source>
          <target state="translated">QuoteRune 및 QuoteRuneToASCII는 유사하지만 룬을 허용하고 인용 된 Go 룬 리터럴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="279cda9da221d3eced1baaee13fb941915b0ad94" translate="yes" xml:space="preserve">
          <source>QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRune은 룬을 나타내는 작은 따옴표로 묶인 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 제어 문자 및 IsPrint에 의해 정의 된 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c3b760977eead2353634f7488bfbfd8e6f53c7d3" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII</source>
          <target state="translated">QuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="53e2d039ada874ffb648eee9f937362314f5598e" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRuneToASCII는 룬을 나타내는 작은 따옴표 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 IsPrint에 의해 정의 된 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0b7fc6950d658f88c7fbca21f506d8678210ba4b" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic</source>
          <target state="translated">QuoteRuneToGraphic</target>
        </trans-unit>
        <trans-unit id="d7acc4ec0f4c890982546aed330f635d958aaa08" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteRuneToGraphic은 룬을 나타내는 작은 따옴표 Go 문자 리터럴을 리턴합니다. 반환 된 문자열은 IsGraphic에서 정의한 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1c5941bc9d5a3819ff2354cecea7900bb16d81ce" translate="yes" xml:space="preserve">
          <source>QuoteToASCII</source>
          <target state="translated">QuoteToASCII</target>
        </trans-unit>
        <trans-unit id="1903845d523cb092b2910db9e417c9681642b306" translate="yes" xml:space="preserve">
          <source>QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteToASCII는 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 IsPrint에 의해 정의 된 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4621ad4d6c0a75793529926b49a9e0ff472d7a25" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic</source>
          <target state="translated">QuoteToGraphic</target>
        </trans-unit>
        <trans-unit id="29d4d4e582c2a53b8be9f8063c3bfb0f71cbfd71" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteToGraphic은 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 반환합니다. 반환 된 문자열은 IsGraphic에서 정의한 비 ASCII 문자 및 인쇄 할 수없는 문자에 Go 이스케이프 시퀀스 (\ t, \ n, \ xFF, \ u0100)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd12f86a63d23d37e2246e2c7fa6e414286f5f3b" translate="yes" xml:space="preserve">
          <source>RC4 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">RC4는 암호화 방식으로 손상되어 안전한 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc475e86eb000cdc90e36723f96df5f3d9198891" translate="yes" xml:space="preserve">
          <source>RGBA is an in-memory image whose At method returns color.RGBA values.</source>
          <target state="translated">RGBA는 At 메서드가 color.RGBA 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="04d387f558acb0866f18159db1f3ea813711e9ce" translate="yes" xml:space="preserve">
          <source>RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA는 빨강, 녹색, 파랑 및 알파 각각에 대해 8 비트를 갖는 기존의 32 비트 알파 사전 곱셈 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46da93f2d89b5f7316108ef78fe128ccbb04c72c" translate="yes" xml:space="preserve">
          <source>RGBA64 is an in-memory image whose At method returns color.RGBA64 values.</source>
          <target state="translated">RGBA64는 At 메서드가 color.RGBA64 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="dd5b935255bb5c16c695e848211ad0d21f5142a6" translate="yes" xml:space="preserve">
          <source>RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA64는 빨강, 초록, 파랑 ​​및 알파 각각에 대해 16 비트를 갖는 64 비트 알파 사전 곱셈 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33f4c44fe26c52f4a8501dd0d6638972bee0c02a" translate="yes" xml:space="preserve">
          <source>RGBToCMYK converts an RGB triple to a CMYK quadruple.</source>
          <target state="translated">RGBToCMYK는 RGB 트리플을 CMYK 쿼드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b770a15a910f2bcdc5fe9614ef9593fa435bc817" translate="yes" xml:space="preserve">
          <source>RGBToYCbCr converts an RGB triple to a Y'CbCr triple.</source>
          <target state="translated">RGBToYCbCr은 RGB 트리플을 Y'CbCr 트리플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="80bfa68e1e388f84eb032cb18125580dfa1ad40c" translate="yes" xml:space="preserve">
          <source>RLock locks rw for reading.</source>
          <target state="translated">RLock은 읽기를 위해 rw를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="437fa597804ed80cc48e0b7bbfe7afd323e52a8f" translate="yes" xml:space="preserve">
          <source>RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</source>
          <target state="translated">RLocker는 rw.RLock 및 rw.RUnlock을 호출하여 Lock 및 Unlock 메서드를 구현하는 Locker 인터페이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9e1378ed0c7150ba139600e4e6dab65e5c1015c" translate="yes" xml:space="preserve">
          <source>RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.</source>
          <target state="translated">RSA는이 패키지에서 공개 키 암호화 또는 공개 키 서명을 구현하는 데 사용되는 단일의 기본 작업입니다.</target>
        </trans-unit>
        <trans-unit id="c5491899defb867c4967ebbebdd0bd5970a6aab7" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA는 매우 제한된 양의 데이터 만 암호화 할 수 있습니다. 합리적인 양의 데이터를 암호화하기 위해 하이브리드 체계가 일반적으로 사용됩니다. RSA는 AES-GCM과 같은 대칭 기본 요소의 키를 암호화하는 데 사용됩니다. 암호화하기 전에 데이터를 알려진 구조에 포함시켜 데이터를 &quot;패딩&quot;합니다. 이것은 여러 가지 이유로 수행되지만, 가장 명백한 것은 지수가 계수보다 큰 값이 충분히 큰지 확인하는 것입니다. (그렇지 않으면 제곱근으로 해독 할 수 있습니다.) 이러한 설계에서 PKCS # 1 v1.5를 사용할 때는 수신 된 RSA 메시지의 형식이 올바른지 (즉, 해독 결과의 여부)를 공개하지 않는 것이 중요합니다. 은 비밀 정보를 유출하기 때문에 올바르게 채워진 메시지입니다. DecryptPKCS1v15SessionKey는이 상황을 위해 설계되었으며 해독 된임의의 키를 포함하는 버퍼에 대해 일정한 시간에 대칭 키 (성공한 경우). 따라서 RSA 결과가 제대로 구성되지 않으면 구현시 일정한 시간에 임의의 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d73a3a42eb35fcb3f1a5896de985a3713b16b03" translate="yes" xml:space="preserve">
          <source>RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.</source>
          <target state="translated">RUnlock은 단일 RLock 호출을 취소합니다. 다른 동시 독자에게는 영향을 미치지 않습니다. RUnlock 시작시 읽기를 위해 rw가 잠기지 않은 경우 런타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b74aed63ef335b4d50b7ff503e63deda9fc37c24" translate="yes" xml:space="preserve">
          <source>Rand sets z to a pseudo-random number in [0, n) and returns z.</source>
          <target state="translated">Rand는 z를 [0, n)의 의사 난수로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd54bd9d380c9fc6a34adb64461692fb6d87443f" translate="yes" xml:space="preserve">
          <source>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.</source>
          <target state="translated">난수는 소스에 의해 생성됩니다. Float64 및 Int와 같은 최상위 기능은 프로그램이 실행될 때마다 결정적인 값 시퀀스를 생성하는 기본 공유 소스를 사용합니다. 각 실행마다 다른 동작이 필요한 경우 Seed 기능을 사용하여 기본 소스를 초기화하십시오. 기본 소스는 여러 고 루틴에서 동시에 사용하기에 안전하지만 NewSource에서 만든 소스는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8185befebe4b99fc7f08cc0f98bec64eff9d397b" translate="yes" xml:space="preserve">
          <source>Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.</source>
          <target state="translated">범위는 맵에있는 각 키와 값에 대해 순차적으로 f를 호출합니다. f가 false를 반환하면 range는 반복을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="e20ffc43a19a831487646a9ec91a15662b93326d" translate="yes" xml:space="preserve">
          <source>Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.</source>
          <target state="translated">범위는 맵 내용의 일관된 스냅 샷과 반드시 ​​일치하지는 않습니다. 키를 두 번 이상 방문하지 않지만, 키 값이 동시에 저장되거나 삭제 된 경우 범위는 범위 동안 임의의 지점에서 해당 키에 대한 매핑을 반영 할 수 있습니다 요구.</target>
        </trans-unit>
        <trans-unit id="faec537bfdedcf391dd6afc93a601559afbe0c69" translate="yes" xml:space="preserve">
          <source>Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls.</source>
          <target state="translated">일정 횟수의 호출 후 f가 false를 반환하더라도 맵의 요소 수와 함께 범위는 O (N) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc094bef8459881bcfd6a354dcd57e410a9ea71d" translate="yes" xml:space="preserve">
          <source>Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.</source>
          <target state="translated">Range16은 16 비트 유니 코드 코드 포인트 범위를 나타냅니다. 범위는 Lo에서 Hi까지이며 범위는 넓습니다.</target>
        </trans-unit>
        <trans-unit id="8ceb0b8d7c66b188254058f3e47e0188e8c2c9ca" translate="yes" xml:space="preserve">
          <source>Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &amp;gt;= 1&amp;lt;&amp;lt;16.</source>
          <target state="translated">Range32는 유니 코드 코드 포인트 범위를 나타내며 하나 이상의 값이 16 비트에 맞지 않을 때 사용됩니다. 범위는 Lo에서 Hi까지이며 범위는 넓습니다. Lo와 Hi는 항상&amp;gt; = 1 &amp;lt;&amp;lt; 16이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c231e0e20b34ad9b3302a62e18606f8e55490f0" translate="yes" xml:space="preserve">
          <source>RangeNode represents a {{range}} action and its commands.</source>
          <target state="translated">RangeNode는 {{range}} 작업 및 해당 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="abf434f30dd2288f852577f0e6ac91164ff1a3d8" translate="yes" xml:space="preserve">
          <source>RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &amp;gt;= 0x10000 (1&amp;lt;&amp;lt;16).</source>
          <target state="translated">RangeTable은 세트 내의 코드 포인트 범위를 나열하여 유니 코드 코드 포인트 세트를 정의합니다. 범위는 공간을 절약하기 위해 두 개의 슬라이스로 나열됩니다. 16 비트 범위의 슬라이스와 32 비트 범위의 슬라이스. 두 슬라이스는 정렬 순서와 겹치지 않아야합니다. 또한 R32는&amp;gt; = 0x10000 (1 &amp;lt;&amp;lt; 16) 값만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2ee87a3ff54a0745b9a4a39ad5daff79dc82bc0" translate="yes" xml:space="preserve">
          <source>Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.</source>
          <target state="translated">Ranges는 [낮음, 높음] 쌍의 조각 인 e로 덮여있는 PC 범위를 반환합니다. TagCompileUnit 또는 TagSubprogram과 같은 일부 항목 유형에만 PC 범위가 있습니다. 다른 사람들에게는 오류없이 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81de462dc83f2812dc32eb06897fa3d4b38ae7e7" translate="yes" xml:space="preserve">
          <source>Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.</source>
          <target state="translated">Rat는 x에 해당하는 유리수를 반환합니다. x가 무한대이면 nil. x가 Inf가 아닌 경우 결과는 정확합니다. 0이 아닌 * Rat 인수 z가 제공되면 Rat는 새 Rat을 할당하는 대신 z에 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="50ea5863423e0f2515585dcf8c4cb2e31c788a51" translate="yes" xml:space="preserve">
          <source>Rat.Scan</source>
          <target state="translated">Rat.Scan</target>
        </trans-unit>
        <trans-unit id="c5f08baa94ad88996a91c67be38be8fe61b40881" translate="yes" xml:space="preserve">
          <source>Rat.SetString</source>
          <target state="translated">Rat.SetString</target>
        </trans-unit>
        <trans-unit id="ef746adb638d3b60d53628e5d2f1455b1d2e8157" translate="yes" xml:space="preserve">
          <source>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1, and in the form &quot;a&quot; if b == 1.</source>
          <target state="translated">RatString은 b! = 1 인 경우 &quot;a / b&quot;형식으로, b == 1 인 경우 &quot;a&quot;형식으로 x의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="641d010f14e2f18c1619afc2268deaff20c97455" translate="yes" xml:space="preserve">
          <source>Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.</source>
          <target state="translated">Raw는 f 동안 기본 드라이버 연결을 노출하여 f를 실행합니다. driverConn을 f 외부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="26c83b72700cdd4952e72476a8d6589b2a87a210" translate="yes" xml:space="preserve">
          <source>RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.</source>
          <target state="translated">RawBytes는 데이터베이스 자체가 소유 한 메모리에 대한 참조를 보유하는 바이트 슬라이스입니다. RawBytes로 스캔 한 후 슬라이스는 다음, 다음 스캔 또는 닫기를 호출 할 때까지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3e2984f789eabe0509843f2607db31c184bddf19" translate="yes" xml:space="preserve">
          <source>RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.</source>
          <target state="translated">RawContent는 구조체에 대해 디코딩되지 않은 DER 데이터를 보존해야한다는 신호를 보내는 데 사용됩니다. 이를 사용하려면 구조체의 첫 번째 필드에이 유형이 있어야합니다. 다른 필드가이 유형을 갖는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="40ee0825120347a6625b948e8e5d6cf21e430f3f" translate="yes" xml:space="preserve">
          <source>RawMessage (Marshal)</source>
          <target state="translated">RawMessage (마셜)</target>
        </trans-unit>
        <trans-unit id="d988676cc711a8df55ed7c79d1c3ecdfedc6d2cd" translate="yes" xml:space="preserve">
          <source>RawMessage (Unmarshal)</source>
          <target state="translated">RawMessage (비 정렬)</target>
        </trans-unit>
        <trans-unit id="1b6da1274d970ef16e862ce3a549bfc22e374a82" translate="yes" xml:space="preserve">
          <source>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</source>
          <target state="translated">RawMessage는 원시 인코딩 된 JSON 값입니다. Marshaler 및 Unmarshaler를 구현하며 JSON 디코딩을 지연 시키거나 JSON 인코딩을 사전 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92ccd29d9bf661a3766af996d8af025383bbfe8" translate="yes" xml:space="preserve">
          <source>RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters.</source>
          <target state="translated">RawStdEncoding은 RFC 4648 섹션 3.2에 정의 된 표준 원시, 패딩되지 않은 base64 인코딩입니다. 이것은 StdEncoding과 동일하지만 패딩 문자는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="6e753058a412394f90ee90228dcf31c4e858e385" translate="yes" xml:space="preserve">
          <source>RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.</source>
          <target state="translated">RawToken은 토큰과 유사하지만 시작 및 끝 요소가 일치하며 네임 스페이스 접 두부를 해당 URL로 변환하지 않는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="166fbd6be28a6fdfe4f94b440b329268727101a8" translate="yes" xml:space="preserve">
          <source>RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters.</source>
          <target state="translated">RawURLEncoding은 RFC 4648에 정의 된 패딩되지 않은 대체 base64 인코딩입니다. 일반적으로 URL 및 파일 이름에 사용됩니다. URLEncoding과 동일하지만 패딩 문자는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="b05c645148a5f30bf1ff0257be7322f1e5b30562" translate="yes" xml:space="preserve">
          <source>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</source>
          <target state="translated">Rcpt는 제공된 이메일 주소를 사용하여 RCPT 명령을 서버에 발행합니다. Rcpt 호출은 Mail 호출 앞에 와야하며 데이터 호출 또는 다른 Rcpt 호출이 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="1fab142ac33b47994d5f7bd4bebd0d391e21aa89" translate="yes" xml:space="preserve">
          <source>Read (Multi)</source>
          <target state="translated">읽기 (멀티)</target>
        </trans-unit>
        <trans-unit id="7d9a4bfe253412dcb5fa31eea7ed6b71a69c4521" translate="yes" xml:space="preserve">
          <source>Read calls decode to deserialize a file set into s; s must not be nil.</source>
          <target state="translated">읽기 호출은 파일 세트를 s로 직렬화 해제하기 위해 디코드합니다. s는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf8ca129127382252f21178b2e38598c4c8bdae5" translate="yes" xml:space="preserve">
          <source>Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.</source>
          <target state="translated">시간 제한을 읽은 후 net을 반환 할 수 있습니다. 고정 시간 제한 후 Timeout () == true 인 경우 오류; SetDeadline 및 SetReadDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1410843edc88c2b9c942b455b313f9ec9a6aa42" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.</source>
          <target state="translated">Read는 len (p) 임의의 바이트를 생성하여 p에 씁니다. 항상 len (p) 및 nil 오류를 반환합니다. 다른 Rand 메소드와 동시에 읽기를 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1059017001f226c432850be91279c7915ab436ce" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.</source>
          <target state="translated">읽기는 기본 소스에서 len (p) 임의 바이트를 생성하여 p에 씁니다. 항상 len (p) 및 nil 오류를 반환합니다. Rand.Read 방법과 달리 읽기는 동시 사용에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a6208c052d923f9826a6caa2665b94a206f4ce81" translate="yes" xml:space="preserve">
          <source>Read implements io.Reader, reading uncompressed bytes from its underlying Reader.</source>
          <target state="translated">Read는 io.Reader를 구현하여 기본 Reader에서 압축되지 않은 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="702bfd00bb1c14225a9197a21d99befbae954266" translate="yes" xml:space="preserve">
          <source>Read implements the Conn Read method.</source>
          <target state="translated">Read는 Conn Read 메서드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="516c851188aa6fc002db294d7651c5ec750120d8" translate="yes" xml:space="preserve">
          <source>Read implements the io.Reader interface.</source>
          <target state="translated">읽기는 io.Reader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="13632ff4ca176eb49e2ded2120c8bd44145f6430" translate="yes" xml:space="preserve">
          <source>Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.</source>
          <target state="translated">읽기는 표준 읽기 인터페이스를 구현합니다. 파이프에서 데이터를 읽고 기록기가 도착하거나 쓰기 끝이 닫힐 때까지 차단합니다. 쓰기 종료가 오류와 함께 닫히면 해당 오류가 err로 리턴됩니다. 그렇지 않으면 err는 EOF입니다.</target>
        </trans-unit>
        <trans-unit id="852b19fc6db1a887a68fe0a33719da8f3df7f6a7" translate="yes" xml:space="preserve">
          <source>Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.</source>
          <target state="translated">Read는 io.ReadFull을 사용하여 Reader.Read를 호출하는 도우미 기능입니다. 리턴시, err == nil 인 경우에만 n == len (b).</target>
        </trans-unit>
        <trans-unit id="6027400201b1aeffebb229f97e47437dd5103716" translate="yes" xml:space="preserve">
          <source>Read reads and decodes quoted-printable data from the underlying reader.</source>
          <target state="translated">읽기는 기본 판독기에서 인용 인쇄 가능한 데이터를 읽고 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="099ba490bf08acc0d4ea27ba7af0e8caf12990cd" translate="yes" xml:space="preserve">
          <source>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). At EOF, the count will be zero and err will be io.EOF.</source>
          <target state="translated">읽기는 p로 데이터를 읽습니다. p로 읽은 바이트 수를 리턴합니다. 바이트는 기본 Reader에서 최대 하나의 읽기에서 가져 오므로 n은 len (p)보다 작을 수 있습니다. 정확히 len (p) 바이트를 읽으려면 io.ReadFull (b, p)를 사용하십시오. EOF에서 카운트는 0이되고 err는 io.EOF가됩니다.</target>
        </trans-unit>
        <trans-unit id="16ce634004d504a55e55d47a3800c80b22768a4e" translate="yes" xml:space="preserve">
          <source>Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.</source>
          <target state="translated">tar 아카이브의 현재 파일에서 읽습니다. 다음 파일로 진행하기 위해 Next가 호출 될 때까지 해당 파일의 끝에 도달하면 (0, io.EOF)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8672c69a1ddaf5ba6848a36cbea552f79e4309ae" translate="yes" xml:space="preserve">
          <source>Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.</source>
          <target state="translated">읽기 r에서 하나의 레코드 (한 조각의 필드)를 읽습니다. 레코드에 예기치 않은 수의 필드가 있으면 Read는 오류 ErrFieldCount와 함께 레코드를 반환합니다. 이 경우를 제외하고 Read는 항상 넌이 아닌 레코드 또는 넌이 아닌 오류를 반환하지만 둘 다를 반환하지는 않습니다. 읽을 데이터가 남아 있지 않으면 Read는 nil, io.EOF를 반환합니다. ReuseRecord가 true 인 경우 반환 된 슬라이스는 여러 번의 읽기 호출간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7ebad97783211e0c50dee195a81d2fcc00a21a" translate="yes" xml:space="preserve">
          <source>Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.</source>
          <target state="translated">읽기는 r에서 데이터로 구조화 된 이진 데이터를 읽습니다. 데이터는 고정 크기 값 또는 고정 크기 값 조각에 대한 포인터 여야합니다. r에서 읽은 바이트는 지정된 바이트 순서를 사용하여 디코딩되어 데이터의 연속 필드에 기록됩니다. 부울 값을 디코딩 할 때 0 바이트는 false로 디코딩되고 0이 아닌 다른 바이트는 true로 디코딩됩니다. 구조체를 읽을 때 공백 (_) 필드 이름을 가진 필드의 필드 데이터는 건너 뜁니다. 즉, 빈 필드 이름이 패딩에 사용될 수 있습니다. 구조체를 읽을 때 모든 비 공백 필드를 내보내거나 읽기 패닉 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13d3208ebb1aa7a1ba1e0de8a255452e3b6f8318" translate="yes" xml:space="preserve">
          <source>Read reads the body of a part, after its headers and before the next part (if any) begins.</source>
          <target state="translated">읽기는 헤더 뒤 및 다음 파트 (있는 경우)가 시작되기 전에 파트의 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bbca8871624a3fc59330b4b25dd8f3ecce95f77a" translate="yes" xml:space="preserve">
          <source>Read reads the index from r into x; x must not be nil.</source>
          <target state="translated">읽기 r에서 x로 색인을 읽습니다. x는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="f50cd5c21ed9fed72a69eacf7363def3849c51d8" translate="yes" xml:space="preserve">
          <source>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.</source>
          <target state="translated">읽기는 버퍼에서 또는 버퍼가 비워 질 때까지 다음 len (p) 바이트를 읽습니다. 리턴 값 n은 읽은 바이트 수입니다. 버퍼에 반환 할 데이터가없는 경우 err은 io.EOF입니다 (len (p)가 0이 아닌 경우). 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="dd7574617c7b02af539a5115f14c74adf24afa51" translate="yes" xml:space="preserve">
          <source>Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.</source>
          <target state="translated">읽기는 와이어에서 다음 응답을 읽습니다. 유효한 응답이 ErrPersistEOF와 함께 리턴 될 수 있습니다. 이는 리모트가 요청 된 마지막 요청임을 원격에 요청했음을 의미합니다. Read는 Write와 동시에 호출 될 수 있지만 다른 Read와는 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e877852fb33acd1c13bf6498df79e2e968ae525c" translate="yes" xml:space="preserve">
          <source>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</source>
          <target state="translated">읽기는 파일에서 len (b) 바이트까지 읽습니다. 읽은 바이트 수와 발생한 오류를 반환합니다. 파일 끝에서 Read는 0, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d839b22857eca34207c84ba0a055c6ee9c74ec5" translate="yes" xml:space="preserve">
          <source>Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered. Even if Read returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.</source>
          <target state="translated">읽기는 최대 len (p) 바이트를 p로 읽습니다. 읽은 바이트 수 (0 &amp;lt;= n &amp;lt;= len (p))와 발생한 오류를 반환합니다. Read가 n &amp;lt;len (p)를 반환하더라도 호출 중에 모든 p를 스크래치 공간으로 사용할 수 있습니다. 일부 데이터를 사용할 수 있지만 len (p) 바이트는 사용할 수없는 경우 Read는 일반적으로 더 많은 것을 기다리는 대신 사용 가능한 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="232135a13eb14d8c77efc7e8763b8a54f14d853d" translate="yes" xml:space="preserve">
          <source>Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).</source>
          <target state="translated">읽기는 와이어에서 다음 요청을 반환합니다. ErrPersistEOF는 더 이상 요청이 없다고 판단되면 (예 : HTTP / 1.0 연결에서 첫 번째 요청 후 또는 HTTP / 1.1 연결에서 Connection : close 후) 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8577ab4df6483a129452d0551a62e50aac1ada00" translate="yes" xml:space="preserve">
          <source>ReadAll</source>
          <target state="translated">ReadAll</target>
        </trans-unit>
        <trans-unit id="c220dc4ba473358c1d6061cf0c9c7708ee93e92a" translate="yes" xml:space="preserve">
          <source>ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.</source>
          <target state="translated">ReadAll은 r에서 나머지 모든 레코드를 읽습니다. 각 레코드는 한 조각의 필드입니다. 성공적인 호출은 err == io.EOF가 아니라 err == nil을 리턴합니다. ReadAll은 EOF까지 읽도록 정의되므로 파일 끝을보고 할 오류로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2e746d4cfb2608d3ae0cefc64ac787887ba2c28" translate="yes" xml:space="preserve">
          <source>ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadAll은 오류 또는 EOF가 될 때까지 r에서 읽고 읽은 데이터를 반환합니다. 성공적인 호출은 err == EOF가 아니라 err == nil을 리턴합니다. ReadAll은 EOF까지 src에서 읽도록 정의되므로 Read의 EOF를보고 할 오류로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4cbf689398d7442e9b49d9483e3d4cc75c10fd1" translate="yes" xml:space="preserve">
          <source>ReadAt implements the io.ReaderAt interface.</source>
          <target state="translated">ReadAt은 io.ReaderAt 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="64ae50d9b868e0114af3da28a0f440e42207678f" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &amp;lt; len(b). At end of file, that error is io.EOF.</source>
          <target state="translated">ReadAt은 바이트 오프셋 오프에서 시작하여 파일에서 len (b) 바이트를 읽습니다. 읽은 바이트 수와 오류 (있는 경우)를 반환합니다. n &amp;lt;len (b) 인 경우 ReadAt는 항상 non-nil 오류를 반환합니다. 파일 끝에서 해당 오류는 io.EOF입니다.</target>
        </trans-unit>
        <trans-unit id="c0bb2352984c400f258aa80aba0c3141b53cce96" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered.</source>
          <target state="translated">ReadAt는 기본 입력 소스에서 오프셋 off에서 시작하여 len (p) 바이트를 p로 읽습니다. 읽은 바이트 수 (0 &amp;lt;= n &amp;lt;= len (p))와 발생한 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e76e529805447d2ff346a5397f1147a3e02108f4" translate="yes" xml:space="preserve">
          <source>ReadAtLeast</source>
          <target state="translated">ReadAtLeast</target>
        </trans-unit>
        <trans-unit id="dde64f711702d58fa68344cc075ded7169e93092" translate="yes" xml:space="preserve">
          <source>ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &amp;gt;= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.</source>
          <target state="translated">ReadAtLeast는 최소 최소 바이트를 읽을 때까지 r에서 buf로 읽습니다. 적은 바이트를 읽은 경우 복사 된 바이트 수와 오류를 반환합니다. 읽은 바이트가없는 경우에만 오류가 EOF입니다. 최소 바이트 미만을 읽은 후 EOF가 발생하면 ReadAtLeast는 ErrUnexpectedEOF를 반환합니다. min이 buf의 길이보다 크면 ReadAtLeast는 ErrShortBuffer를 반환합니다. 리턴시, err == nil 인 경우에만 n&amp;gt; = min. r이 최소 최소 바이트를 읽은 오류를 리턴하면 오류가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5eb984a81bf137b794c952d3bb6893f123d7859e" translate="yes" xml:space="preserve">
          <source>ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.</source>
          <target state="translated">ReadBuildInfo는 실행중인 바이너리에 포함 된 빌드 정보를 반환합니다. 이 정보는 모듈 지원으로 빌드 된 바이너리에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60f1ee86705e93ab48e53804a8b6eaae8d1a5a6" translate="yes" xml:space="preserve">
          <source>ReadByte implements the io.ByteReader interface.</source>
          <target state="translated">ReadByte는 io.ByteReader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="88fc89f806641e6821f93c159732d09d121182a0" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns a single byte. If no byte is available, returns an error.</source>
          <target state="translated">ReadByte는 단일 바이트를 읽고 반환합니다. 사용 가능한 바이트가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ccc7f3f4551a8da89db7d7f4659a2bcc7f6f5b1" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.</source>
          <target state="translated">ReadByte는 버퍼에서 다음 바이트를 읽고 반환합니다. 사용 가능한 바이트가 없으면 오류 io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="159679671477045d937418ced34fc2e8ac5df5f4" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.</source>
          <target state="translated">ReadByte는 입력 또는 발생한 오류에서 다음 바이트를 읽고 반환합니다. ReadByte가 오류를 반환하면 입력 바이트가 사용되지 않고 반환 된 바이트 값이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d347b2a2e7f91e4c72a8f8310b1aba11bc78e6c" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadBytes는 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 슬라이스를 반환합니다. 구분 기호를 찾기 전에 ReadBytes에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadBytes는 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aba4d297566c98e6e0d191f056016ef94b731d93" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadBytes는 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 슬라이스를 반환합니다. 구분 기호를 찾기 전에 ReadBytes에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadBytes는 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다. 간단한 사용을 위해 스캐너가 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2f66b132ca8c3970b58c8bfa0ea1a17d65ac03b4" translate="yes" xml:space="preserve">
          <source>ReadCloser is the interface that groups the basic Read and Close methods.</source>
          <target state="translated">ReadCloser는 기본 Read 및 Close 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="db676df84bb4b6b56dfdcd9f6b6ecaede84207b6" translate="yes" xml:space="preserve">
          <source>ReadCodeLine reads a response code line of the form</source>
          <target state="translated">ReadCodeLine은 양식의 응답 코드 행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8ff6713d1fd28b36b70ff99ddd8c0b4506ace228" translate="yes" xml:space="preserve">
          <source>ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.</source>
          <target state="translated">ReadContinuedLine은 r에서 가능한 연속적인 행을 읽고 마지막 후행 ASCII 공백을 제거합니다. 공백이나 탭 문자로 시작하면 첫 번째 이후의 줄은 연속으로 간주됩니다. 반환 된 데이터에서 연속 줄은 단일 줄로만 이전 줄과 구분됩니다. 줄 바꿈과 선행 공백은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1e5b6ed6dd4e790ba932357704f154ece64c0736" translate="yes" xml:space="preserve">
          <source>ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadContinuedLineBytes는 ReadContinuedLine과 유사하지만 문자열 대신 [] 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5967a3c48bcceae8eab866aea588318eebdf12d2" translate="yes" xml:space="preserve">
          <source>ReadDir</source>
          <target state="translated">ReadDir</target>
        </trans-unit>
        <trans-unit id="72f7f069b44009fbb8ef194258dfcf70cde80055" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.</source>
          <target state="translated">ReadDir은 dirname으로 이름 지정된 디렉토리를 읽고 filename별로 정렬 된 디렉토리 항목 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e66536e5f97de59d6908b95e869d13fc9d1ef4b6" translate="yes" xml:space="preserve">
          <source>ReadDotBytes reads a dot-encoding and returns the decoded data.</source>
          <target state="translated">ReadDotBytes는 도트 인코딩을 읽고 디코딩 된 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fa4950dafc4de63dd721dcb4ac0ca1c8418dcbe" translate="yes" xml:space="preserve">
          <source>ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \r\n or \n elided from each.</source>
          <target state="translated">ReadDotLines는 도트 인코딩을 읽고 마지막 \ r \ n 또는 \ n을 각각 빼고 디코딩 된 라인을 포함하는 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7fd01a502310e8357802950d90a33ad1c88b094" translate="yes" xml:space="preserve">
          <source>ReadFile</source>
          <target state="translated">ReadFile</target>
        </trans-unit>
        <trans-unit id="e3227226a36d1c67d762cccdcef04ee8eaa0dc15" translate="yes" xml:space="preserve">
          <source>ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadFile은 filename으로 이름이 지정된 파일을 읽고 내용을 반환합니다. 성공적인 호출은 err == EOF가 아니라 err == nil을 리턴합니다. ReadFile은 전체 파일을 읽으므로 Read의 EOF를보고 할 오류로 취급하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af2c9d5288821671fae0d9ea11877f8aa4dfd64b" translate="yes" xml:space="preserve">
          <source>ReadForm parses an entire multipart message whose parts have a Content-Disposition of &quot;form-data&quot;. It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.</source>
          <target state="translated">ReadForm은 파트가 &quot;form-data&quot;의 Content-Disposition을 갖는 전체 멀티 파트 메시지를 구문 분석합니다. 최대 maxMemory 바이트 + 10MB (비 파일 부분 용으로 예약 됨)를 메모리에 저장합니다. 메모리에 저장할 수없는 파일 부분은 디스크에 임시 파일로 저장됩니다. 파일이 아닌 모든 부분을 메모리에 저장할 수 없으면 ErrMessageTooLarge를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e93b4927342ab7184e8df9a62d919ab56aa652d" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.</source>
          <target state="translated">ReadFrom은 io.ReaderFrom을 구현합니다. 기본 작성기가 ReadFrom 메소드를 지원하고 b에 아직 버퍼링 된 데이터가없는 경우 버퍼링없이 기본 ReadFrom을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="deeb7efc315fb646ef56c6fc1f93867b106373b0" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the PacketConn ReadFrom method.</source>
          <target state="translated">ReadFrom은 PacketConn ReadFrom 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f608142e8cc80b99bfcbe865eecfbb0322dd6e96" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the io.ReaderFrom ReadFrom method.</source>
          <target state="translated">ReadFrom은 io.ReaderFrom ReadFrom 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="00b3806bd8fc8bcfbcad0f6f7f7286cb5b8785f4" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.</source>
          <target state="translated">ReadFrom은 r에서 EOF까지 데이터를 읽고 버퍼에 추가하여 필요에 따라 버퍼를 증가시킵니다. 리턴 값 n은 읽은 바이트 수입니다. 읽기 중에 발생한 io.EOF를 제외한 모든 오류도 반환됩니다. 버퍼가 너무 커지면 ReadFrom은 ErrTooLarge와 함께 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="454fdea2d34a8c45cb668b5c543dbc3f7058787c" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.</source>
          <target state="translated">ReadFrom은 r에서 EOF 또는 오류까지 데이터를 읽습니다. 리턴 값 n은 읽은 바이트 수입니다. 읽기 중에 발생한 io.EOF를 제외한 모든 오류도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea32f98cbdf74be7e58789bf5c2555022985c09b" translate="yes" xml:space="preserve">
          <source>ReadFromIP acts like ReadFrom but returns an IPAddr.</source>
          <target state="translated">ReadFromIP는 ReadFrom처럼 작동하지만 IPAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95ff932341b82ae81f7960462c1442dddf49af3c" translate="yes" xml:space="preserve">
          <source>ReadFromUDP acts like ReadFrom but returns a UDPAddr.</source>
          <target state="translated">ReadFromUDP는 ReadFrom처럼 작동하지만 UDPAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="715d754a562178b348b7a0a9528cfbf66635230e" translate="yes" xml:space="preserve">
          <source>ReadFromUnix acts like ReadFrom but returns a UnixAddr.</source>
          <target state="translated">ReadFromUnix는 ReadFrom처럼 작동하지만 UnixAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b877746bfc4fdb60829d292eb383e9e72074e71" translate="yes" xml:space="preserve">
          <source>ReadFull</source>
          <target state="translated">ReadFull</target>
        </trans-unit>
        <trans-unit id="f41363ee55bdca4d655d8c43955b9b66f37cac52" translate="yes" xml:space="preserve">
          <source>ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.</source>
          <target state="translated">ReadFull은 r에서 buf로 정확히 len (buf) 바이트를 읽습니다. 적은 바이트를 읽은 경우 복사 된 바이트 수와 오류를 반환합니다. 읽은 바이트가없는 경우에만 오류가 EOF입니다. 일부 바이트 만 읽은 후 EOF가 발생하면 ReadFull은 ErrUnexpectedEOF를 반환합니다. 리턴시, err == nil 인 경우에만 n == len (buf). r이 len (buf) 바이트 이상을 읽은 오류를 리턴하면 오류가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4528be7d31ac119b15adb0d44e8e10acc6a61277" translate="yes" xml:space="preserve">
          <source>ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.</source>
          <target state="translated">ReadGCStats는 가비지 수집에 대한 통계를 통계로 읽습니다. 일시 정지 히스토리의 항목 수는 시스템에 따라 다릅니다. 일시 정지 슬라이스는 충분히 큰 경우 재사용되고, 그렇지 않으면 재 할당됩니다. ReadGCStats는 통계의 전체 용량을 사용할 수 있습니다. stats.PauseQuantiles가 비어 있지 않으면 ReadGCStats는 일시 정지 시간의 분포를 요약하는 Quantile로 채 웁니다. 예를 들어 len (stats.PauseQuantiles)이 5 인 경우 최소, 25 %, 50 %, 75 % 및 최대 일시 정지 시간으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a6882fab97e53a8d3c4b1deb078269fff567ed19" translate="yes" xml:space="preserve">
          <source>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</source>
          <target state="translated">ReadLine은 저수준 라인 판독 프리미티브입니다. 대부분의 호출자는 대신 ReadBytes ( '\ n') 또는 ReadString ( '\ n')을 사용하거나 스캐너를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="70e3e4d68a5bd26786fe6816067d028f52581c71" translate="yes" xml:space="preserve">
          <source>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</source>
          <target state="translated">ReadLine은 r에서 단일 행을 읽고 리턴 된 문자열에서 최종 \ n 또는 \ r \ n을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d5bdeff155b2aec65cb49ea2eabeba1181d7c31c" translate="yes" xml:space="preserve">
          <source>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.</source>
          <target state="translated">ReadLine은 행 끝 바이트를 포함하지 않고 단일 행을 리턴하려고합니다. 행이 버퍼에 비해 너무 길면 isPrefix가 설정되고 행의 시작이 리턴됩니다. 나머지 회선은 향후 통화에서 반환됩니다. 줄의 마지막 조각을 반환하면 isPrefix는 false입니다. 반환 된 버퍼는 다음에 ReadLine을 호출 할 때까지만 유효합니다. ReadLine은 0이 아닌 행을 리턴하거나 오류를 리턴합니다 (둘다는 아님).</target>
        </trans-unit>
        <trans-unit id="30af98b166430a4d07ac11a60a37dce8c9897d44" translate="yes" xml:space="preserve">
          <source>ReadLineBytes is like ReadLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadLineBytes는 ReadLine과 유사하지만 문자열 대신 [] 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34955aedc1edab445c06914ea85435c83aa1659d" translate="yes" xml:space="preserve">
          <source>ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.</source>
          <target state="translated">ReadMIMEHeader는 r에서 MIME 스타일 헤더를 읽습니다. 헤더는 가능한 연속 키입니다. 빈 줄로 끝나는 값 줄. 리턴 된 맵 m은 CanonicalMIMEHeaderKey (key)를 입력에서 발견 된 것과 동일한 순서로 일련의 값으로 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="e81ba86f59e436daff158e41fbec08f65b2c4f42" translate="yes" xml:space="preserve">
          <source>ReadMemStats populates m with memory allocator statistics.</source>
          <target state="translated">ReadMemStats는 m을 메모리 할당 자 통계로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="acb49a6f36fe4a7034527475afbfe7647980d6b9" translate="yes" xml:space="preserve">
          <source>ReadMessage</source>
          <target state="translated">ReadMessage</target>
        </trans-unit>
        <trans-unit id="1551b34da55e8d458cfae44e4a334da9f414dea8" translate="yes" xml:space="preserve">
          <source>ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.</source>
          <target state="translated">ReadMessage는 r에서 메시지를 읽습니다. 헤더가 구문 분석되고 메시지 본문을 msg.Body에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f05b0c16954598270f35347bda5383a6c522b11" translate="yes" xml:space="preserve">
          <source>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgIP는 c에서 메시지를 읽고 페이로드를 b에 복사하고 관련 대역 외 데이터를 oob에 복사합니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="47bd88248b7a6aeb9fe7003935965fcbc4c14b6e" translate="yes" xml:space="preserve">
          <source>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUDP는 c에서 메시지를 읽고 페이로드를 b에 복사하고 연관된 대역 외 데이터를 oob에 복사합니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f80f0770ba07805dfad9fed9021802994b16c79f" translate="yes" xml:space="preserve">
          <source>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUnix는 페이로드를 b에 복사하고 연관된 대역 외 데이터를 oob에 복사하여 c에서 메시지를 읽습니다. b에 복사 된 바이트 수, oob에 복사 된 바이트 수, 메시지에 설정된 플래그 및 메시지의 소스 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="25bb46ad3055b508b0608be3bcb05d4dc7a218ac" translate="yes" xml:space="preserve">
          <source>ReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</source>
          <target state="translated">ReadRequest는 저수준 기능이며 특수 응용 프로그램에만 사용해야합니다. 대부분의 코드는 서버를 사용하여 요청을 읽고 처리기 인터페이스를 통해 처리해야합니다. ReadRequest는 HTTP / 1.x 요청 만 지원합니다. HTTP / 2의 경우 golang.org/x/net/http2를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b66f29f0f459c92aabcbebb68a77d5a6970744" translate="yes" xml:space="preserve">
          <source>ReadRequest reads and parses an incoming request from b.</source>
          <target state="translated">ReadRequest는 b에서 들어오는 요청을 읽고 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="25d27159145d0774b1fadc397fe48b995c46c5de" translate="yes" xml:space="preserve">
          <source>ReadResponse reads a multi-line response of the form:</source>
          <target state="translated">ReadResponse는 다음 형식의 여러 줄 응답을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ee99ce8c11934415337cdc7bec2e604ef18e71ae" translate="yes" xml:space="preserve">
          <source>ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.</source>
          <target state="translated">ReadResponse는 r에서 HTTP 응답을 읽고 리턴합니다. req 매개 변수는 선택적으로이 응답에 해당하는 요청을 지정합니다. nil 인 경우 GET 요청이 가정됩니다. resp.Body를 읽었 으면 클라이언트는 resp.Body.Close를 호출해야합니다. 이 호출 후 고객은 응답 트레일러에 포함 된 키 / 값 쌍을 찾기 위해 resp.Trailer를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="476255423e82d011c96cc157a1f2c1336b3b2a0a" translate="yes" xml:space="preserve">
          <source>ReadRune implements the io.RuneReader interface.</source>
          <target state="translated">ReadRune은 io.RuneReader 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2149703d832b9af2c76dd9abfe510fdf6ec21b40" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.</source>
          <target state="translated">ReadRune은 UTF-8로 인코딩 된 단일 유니 코드 문자를 읽고 룬과 크기를 바이트 단위로 반환합니다. 사용 가능한 문자가 없으면 err이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6414ea883495287275cdc53b35ffd14e0008ac3b" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</source>
          <target state="translated">ReadRune은 UTF-8로 인코딩 된 단일 유니 코드 문자를 읽고 룬과 크기를 바이트 단위로 반환합니다. 인코딩 된 룬이 유효하지 않은 경우 1 바이트를 소비하고 크기가 1 인 unicode.ReplacementChar (U + FFFD)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6486828e56b295be35e03a3674dd21e96b49a79c" translate="yes" xml:space="preserve">
          <source>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.</source>
          <target state="translated">ReadRune은 버퍼에서 다음 UTF-8로 인코딩 된 유니 코드 코드 포인트를 읽고 리턴합니다. 사용 가능한 바이트가 없으면 반환 된 오류는 io.EOF입니다. 바이트가 잘못된 UTF-8 인코딩 인 경우 1 바이트를 소비하고 U + FFFD, 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78176debea1a291ba3e7ca916182c7ec7d43ab66" translate="yes" xml:space="preserve">
          <source>ReadSeeker is the interface that groups the basic Read and Seek methods.</source>
          <target state="translated">ReadSeeker는 기본 Read 및 Seek 메소드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="6f83dddca1aa94fb6e401f10df5bd11c4e328c97" translate="yes" xml:space="preserve">
          <source>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.</source>
          <target state="translated">ReadSlice는 입력에서 delim이 처음 나타날 때까지 읽고 버퍼의 바이트를 가리키는 슬라이스를 반환합니다. 바이트는 다음에 읽을 때 유효하지 않습니다. 분리 문자를 찾기 전에 ReadSlice에서 오류가 발생하면 버퍼의 모든 데이터와 오류 자체 (종종 io.EOF)를 리턴합니다. 버퍼가 제한없이 채워지면 ReadSlice가 오류 ErrBufferFull과 함께 실패합니다. ReadSlice에서 반환 된 데이터는 다음 I / O 작업으로 덮어 쓰므로 대부분의 클라이언트는 ReadBytes 또는 ReadString을 대신 사용해야합니다. 라인이 delim로 끝나지 않는 경우에만 ReadSlice가 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="396715e6dd5c32bdbbf83af9027e47c30dc1faa8" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadString은 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 문자열을 반환합니다. 구분 기호를 찾기 전에 ReadString에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadString은 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aaa3e0c7b34f04c5ff175180dbf3748d0757b57f" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadString은 입력에서 delim이 처음 나타날 때까지 읽고 구분 기호까지 포함 된 데이터를 포함하는 문자열을 반환합니다. 구분 기호를 찾기 전에 ReadString에서 오류가 발생하면 오류 이전에 읽은 데이터와 오류 자체 (종종 io.EOF)를 반환합니다. ReadString은 반환 된 데이터가 delim로 끝나지 않는 경우에만 err! = nil을 반환합니다. 간단한 사용을 위해 스캐너가 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="24714d7c8185be718fff60550f6b7e029b2b159c" translate="yes" xml:space="preserve">
          <source>ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.</source>
          <target state="translated">ReadTrace는 다음 이진 추적 데이터 청크를 반환하여 데이터를 사용할 수있을 때까지 차단합니다. 추적이 꺼져 있고 켜져있는 동안 누적 된 모든 데이터가 반환되면 ReadTrace는 nil을 반환합니다. 호출자는 ReadTrace를 다시 호출하기 전에 반환 된 데이터를 복사해야합니다. 한 번에 하나의 고 루틴에서 ReadTrace를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="989bf43b9a2dfe020990e99dd409325328b3ade3" translate="yes" xml:space="preserve">
          <source>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</source>
          <target state="translated">ReadUvarint는 r에서 인코딩 된 부호없는 정수를 읽고 uint64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="675541f596de4c802da653f83b46f8b7718858d0" translate="yes" xml:space="preserve">
          <source>ReadVarint reads an encoded signed integer from r and returns it as an int64.</source>
          <target state="translated">ReadVarint는 r에서 인코딩 된 부호있는 정수를 읽고 int64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="069fcaa32c060bf9bd8bfac5e82274aaead1bc50" translate="yes" xml:space="preserve">
          <source>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</source>
          <target state="translated">ReadWriteCloser는 기본 Read, Write 및 Close 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="341b30c9c3b78089bcaa44b8a26a94b9bc0c8ea6" translate="yes" xml:space="preserve">
          <source>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</source>
          <target state="translated">ReadWriteSeeker는 기본 Read, Write 및 Seek 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="eb7ce11fb3f6f0101cd6b5288463e8de90a96b51" translate="yes" xml:space="preserve">
          <source>ReadWriter is the interface that groups the basic Read and Write methods.</source>
          <target state="translated">ReadWriter는 기본 Read 및 Write 메서드를 그룹화하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="dfaac4087d8cb10eb5b8f29ddefebdcafd42a5af" translate="yes" xml:space="preserve">
          <source>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.</source>
          <target state="translated">ReadWriter는 Reader 및 Writer에 대한 포인터를 저장합니다. io.ReadWriter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="79f16a4d9874784deac866dfbd0ce6545be6e239" translate="yes" xml:space="preserve">
          <source>Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.</source>
          <target state="translated">Readdir은 파일과 연관된 디렉토리의 내용을 읽고 Lstat에 의해 리턴되는 최대 n 개의 FileInfo 값의 슬라이스를 디렉토리 순서로 리턴합니다. 동일한 파일에 대한 후속 호출은 추가 FileInfo를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="501d22e73b2af73a4cd2cda27f0147a879d2d29f" translate="yes" xml:space="preserve">
          <source>Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.</source>
          <target state="translated">Readdirnames는 파일과 연관된 디렉토리의 내용을 읽고 디렉토리에있는 디렉토리에서 최대 n 개의 파일 이름 슬라이스를 디렉토리 순서로 리턴합니다. 동일한 파일에 대한 후속 호출은 추가 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="a764e12131a971febc3401d23317f0234b4049b8" translate="yes" xml:space="preserve">
          <source>Reader (Options)</source>
          <target state="translated">리더 (옵션)</target>
        </trans-unit>
        <trans-unit id="df3472ca3dd5a57262b56d74dcad15e820ebf2eb" translate="yes" xml:space="preserve">
          <source>Reader implements buffering for an io.Reader object.</source>
          <target state="translated">Reader는 io.Reader 객체에 대한 버퍼링을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="96784a034a712bc8c815b4587872dbfdfd0582a9" translate="yes" xml:space="preserve">
          <source>Reader is a global, shared instance of a cryptographically secure random number generator.</source>
          <target state="translated">Reader는 암호로 안전한 난수 생성기의 글로벌 공유 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="bf613e0e0a803852368392b2dfe7b4682657c458" translate="yes" xml:space="preserve">
          <source>Reader is a quoted-printable decoder.</source>
          <target state="translated">Reader는 인용 인쇄 가능한 디코더입니다.</target>
        </trans-unit>
        <trans-unit id="b49691ad8407ed7de43e614957e75ec4095c4b28" translate="yes" xml:space="preserve">
          <source>Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.</source>
          <target state="translated">Reader는 MIME 멀티 파트 바디의 파트에 대한 반복자입니다. Reader의 기본 파서는 필요에 따라 입력을 사용합니다. 검색이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21dadd14b38a36c18741cf2c47ad38cb0675eedf" translate="yes" xml:space="preserve">
          <source>Reader is the interface that wraps the basic Read method.</source>
          <target state="translated">Reader는 기본 Read 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9bdf18ff83881db62f68bf47e6ac4c6f41d55f66" translate="yes" xml:space="preserve">
          <source>Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.</source>
          <target state="translated">Reader는 tar 아카이브의 내용에 순차적으로 액세스 할 수 있습니다. Reader.Next는 아카이브의 다음 파일 (첫 번째 파일 포함)로 진행 한 다음 Reader를 io.Reader로 처리하여 파일 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cac70aa62b26f1281fbe4d19090a262412eed7e3" translate="yes" xml:space="preserve">
          <source>Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Reader는 새로운 Reader for Data를 반환합니다. 리더는 DWARF&amp;ldquo;정보&amp;rdquo;섹션에서 바이트 오프셋 0에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8049ec93e81c7083091b44ed801d9d9d92c309d9" translate="yes" xml:space="preserve">
          <source>Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.</source>
          <target state="translated">숫자 응답 코드 행, 키 : 값 헤더, 연속 행에서 선행 공백으로 줄 바꿈 된 행 및 행 자체로 점으로 끝나는 전체 텍스트 블록을 읽는 판독기</target>
        </trans-unit>
        <trans-unit id="d0009a603321ffa4322fc5ace74c08013f3502dc" translate="yes" xml:space="preserve">
          <source>Reader.Len</source>
          <target state="translated">Reader.Len</target>
        </trans-unit>
        <trans-unit id="52b9ae6b2c685e2a877bd9bbf8defead7e5d5ac7" translate="yes" xml:space="preserve">
          <source>Reader.Multistream</source>
          <target state="translated">Reader.Multistream</target>
        </trans-unit>
        <trans-unit id="23e9cef150e9609032f02dcc6e3ec9a05ca806c3" translate="yes" xml:space="preserve">
          <source>Reader.ReadAll</source>
          <target state="translated">Reader.ReadAll</target>
        </trans-unit>
        <trans-unit id="976c7b59d336efab6bbe07f071aa8d432cb7a047" translate="yes" xml:space="preserve">
          <source>ReaderAt is the interface that wraps the basic ReadAt method.</source>
          <target state="translated">ReaderAt는 기본 ReadAt 메소드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="29ae6f40e1ba95a55db0a9760f63eada1ab4e398" translate="yes" xml:space="preserve">
          <source>ReaderFrom is the interface that wraps the ReadFrom method.</source>
          <target state="translated">ReaderFrom은 ReadFrom 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b5bdadfe357edf2d398dc3767642063de731a14c" translate="yes" xml:space="preserve">
          <source>Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Readlink는 명명 된 심볼릭 링크의 대상을 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3680e45cb759e7b231139c55beb835dcb36f290f" translate="yes" xml:space="preserve">
          <source>Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.</source>
          <target state="translated">파이프의 읽기 및 쓰기는 단일 쓰기를 소비하기 위해 여러 읽기가 필요한 경우를 제외하고 일대일로 일치합니다. 즉, PipeWriter에 대한 각 쓰기는 작성된 데이터를 완전히 소비하는 PipeReader의 하나 이상의 읽기를 만족할 때까지 차단됩니다. 데이터는 쓰기에서 해당 읽기 (또는 읽기)로 직접 복사됩니다. 내부 버퍼링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="96964e0a893395e3b89017fa3370fe50203e0f58" translate="yes" xml:space="preserve">
          <source>Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">실수는 x의 실수 부분을 반환하며, 숫자 또는 알 수없는 값이어야합니다. x가 알 수없는 경우 결과는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4e7e73832091a1dd0eb45c5e3535f9fc0bb0385" translate="yes" xml:space="preserve">
          <source>ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.</source>
          <target state="translated">ReceiverName은이 심볼의 수신자 유형 이름을 반환하거나 존재하지 않는 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76042968d1a5f484d7ec99013213446b06dc9be8" translate="yes" xml:space="preserve">
          <source>Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:</source>
          <target state="translated">수신기는 타이밍 사이드 채널을 피하기 위해 Equal을 사용하여 MAC을 비교하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="baede57b4fd75bbaf39e019c76771e5b57cbf06e" translate="yes" xml:space="preserve">
          <source>RecordHeaderError is returned when a TLS record header is invalid.</source>
          <target state="translated">TLS 레코드 헤더가 유효하지 않으면 RecordHeaderError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2614b13193f400f1a9992deddc528f2f896c1029" translate="yes" xml:space="preserve">
          <source>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Rectangle {Pt (x0, y0), Pt (x1, y1)}의 약어입니다. 반환 된 사각형에는 필요한 경우 올바른 최소값과 최대 좌표가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1937bfd09178388c39ec43cf08d134d3d9d1898f" translate="yes" xml:space="preserve">
          <source>Rect returns the complex number x with polar coordinates r, &amp;theta;.</source>
          <target state="translated">Rect는 극좌표 r, &amp;theta;를 갖는 복소수 x를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94dab483158e13564ee6a455c353913588b6dbd1" translate="yes" xml:space="preserve">
          <source>Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</source>
          <target state="translated">Recv는 채널 v에서 값을 받아서 반환합니다. v의 Kind가 Chan이 아닌 경우 패닉이 발생합니다. 값이 준비 될 때까지 수신이 차단됩니다. 부울 값 ok는 값 x가 채널의 전송에 해당하면 true이고, 채널이 닫혀서 수신 된 0 값이면 false입니다.</target>
        </trans-unit>
        <trans-unit id="03b8f406324956c22ef3f439d41bfd0bef6159ba" translate="yes" xml:space="preserve">
          <source>Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.</source>
          <target state="translated">Recv는 서명의 수신자 (메소드 인 경우) 또는 함수 인 경우 nil을 리턴합니다. 신원에 대한 서명을 비교할 때는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae5c546dd23f367221f8f4d367950523d9cf3bb" translate="yes" xml:space="preserve">
          <source>Recv returns the type of x in x.f.</source>
          <target state="translated">Recv는 xf의 x 유형을 반환합니다</target>
        </trans-unit>
        <trans-unit id="9250d7c2a971eb24cc4eedcfff481ae3439946cf" translate="yes" xml:space="preserve">
          <source>Redirect replies to the request with a redirect to url, which may be a path relative to the request path.</source>
          <target state="translated">리디렉션은 요청 경로에 상대적인 경로 일 수있는 url로 리디렉션하여 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="c909a75a26a89b05691be1108e0ab3c2e1bcdb1a" translate="yes" xml:space="preserve">
          <source>RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.</source>
          <target state="translated">RedirectHandler는 주어진 상태 코드를 사용하여 수신 한 각 요청을 지정된 URL로 경로 재지 정하는 요청 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d6ec8155461c38d823e4b635ac46022ba360bb68" translate="yes" xml:space="preserve">
          <source>Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[&quot;Referer&quot;]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[&quot;Referrer&quot;].</source>
          <target state="translated">요청 자체에서와 같이 리퍼러의 철자가 잘못되었습니다. HTTP 초기 시절의 실수입니다. 이 값은 헤더 맵에서 Header [ &quot;Referer&quot;]로 가져올 수도 있습니다. 메소드로 사용 가능하게하는 이점은 컴파일러에서 대체 (올바른 영어) 철자 req.Referrer ()를 사용하는 프로그램을 진단 할 수 있지만 Header [ &quot;Referrer&quot;]를 사용하는 프로그램은 진단 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07d5e3dfcd70520a1bbdb2fa9dbe2bae91c99a57" translate="yes" xml:space="preserve">
          <source>Referer returns the referring URL, if sent in the request.</source>
          <target state="translated">리퍼러는 요청에서 전송 된 경우 참조 URL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ac251dfde6b7c655d39dbc21c40c658e7f0e5ba" translate="yes" xml:space="preserve">
          <source>Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:</source>
          <target state="translated">동사에 관계없이 피연산자가 인터페이스 값이면 인터페이스 자체가 아니라 내부 콘크리트 값이 사용됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="ae8b91c59ed7a48ada5b7396ec353e27cc7c57cd" translate="yes" xml:space="preserve">
          <source>Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.</source>
          <target state="translated">정규 표현식은 컴파일 된 정규 표현식을 나타냅니다. Regexp는 Longest와 같은 구성 방법을 제외하고 여러 고 루틴이 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84f40722bc57d5dce890a8a11e5c4fee08f3c9c" translate="yes" xml:space="preserve">
          <source>Regexp.Expand</source>
          <target state="translated">Regexp.Expand</target>
        </trans-unit>
        <trans-unit id="3dd017106e6cb747b2a0cd305e5bb9fdade3a8d1" translate="yes" xml:space="preserve">
          <source>Regexp.ExpandString</source>
          <target state="translated">Regexp.ExpandString</target>
        </trans-unit>
        <trans-unit id="ec3956758c005d81eaf9415a4c61a2390b4ec0f2" translate="yes" xml:space="preserve">
          <source>Regexp.Find</source>
          <target state="translated">Regexp.Find</target>
        </trans-unit>
        <trans-unit id="5a4d1168fbbea65dfa0185be8ce3c71cdc597f4b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAll</source>
          <target state="translated">Regexp.FindAll</target>
        </trans-unit>
        <trans-unit id="9a7a55d789a0b84db34a38b56a2f4242a4cf127c" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllString</source>
          <target state="translated">Regexp.FindAllString</target>
        </trans-unit>
        <trans-unit id="f7e56583e4dcc297ccf2aa23c322191411764c7e" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatch</source>
          <target state="translated">Regexp.FindAllStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e4337ecbd053cf4beaa55b4111d3d25165c547a3" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatchIndex</source>
          <target state="translated">Regexp.FindAllStringSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="55182b4c005261d0e66f0c8c4df35946648e43bd" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatch</source>
          <target state="translated">Regexp.FindAllSubmatch</target>
        </trans-unit>
        <trans-unit id="752406799d805cf76b21ac4473155fcd9c435cf1" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatchIndex</source>
          <target state="translated">Regexp.FindAllSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="ca21e70b0b76817fc6bc10e7f6cc4170f855d5aa" translate="yes" xml:space="preserve">
          <source>Regexp.FindIndex</source>
          <target state="translated">Regexp.FindIndex</target>
        </trans-unit>
        <trans-unit id="21fdf1e48587944dc1c11b68645cfe5138e0b116" translate="yes" xml:space="preserve">
          <source>Regexp.FindString</source>
          <target state="translated">Regexp.FindString</target>
        </trans-unit>
        <trans-unit id="dc52dbc2324ccd5021b173c341b811e2472a4206" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringIndex</source>
          <target state="translated">Regexp.FindStringIndex</target>
        </trans-unit>
        <trans-unit id="a2b5fabc1cf5de45d659c3142098c4fde4339cdc" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringSubmatch</source>
          <target state="translated">Regexp.FindStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e27002b196cee520413e84f76c97dc77b353b852" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatch</source>
          <target state="translated">Regexp.FindSubmatch</target>
        </trans-unit>
        <trans-unit id="0008582d6bb9067aadd263f03da910a66e6e0e19" translate="yes" xml:space="preserve">
          <source>Regexp.Match</source>
          <target state="translated">Regexp.Match</target>
        </trans-unit>
        <trans-unit id="2c0eada8b9cfbb5d24aadca2e8fa445cbe3b7e2b" translate="yes" xml:space="preserve">
          <source>Regexp.MatchString</source>
          <target state="translated">Regexp.MatchString</target>
        </trans-unit>
        <trans-unit id="4c687a2a42e7f3d60c9f98f0993362b9c2735490" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllLiteralString</source>
          <target state="translated">Regexp.ReplaceAllLiteralString</target>
        </trans-unit>
        <trans-unit id="9fececaf13096d7dc9ffe3d2d93e25169cf762e1" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllString</source>
          <target state="translated">Regexp.ReplaceAllString</target>
        </trans-unit>
        <trans-unit id="5f97458d8e33d7f5f2c52b953c172d5ccb890b23" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllStringFunc</source>
          <target state="translated">Regexp.ReplaceAllStringFunc</target>
        </trans-unit>
        <trans-unit id="60f05fd13196ffa4dd89663cf41abb4f862a263c" translate="yes" xml:space="preserve">
          <source>Regexp.Split</source>
          <target state="translated">Regexp.Split</target>
        </trans-unit>
        <trans-unit id="b36b7852ff6e5f89fe309ce0324c7c9f6dac2ab6" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpNames</source>
          <target state="translated">Regexp.SubexpNames</target>
        </trans-unit>
        <trans-unit id="96a2105b6d183387bea55013dc84567e629210a2" translate="yes" xml:space="preserve">
          <source>Region is a region of code whose execution time interval is traced.</source>
          <target state="translated">Region은 실행 시간 간격이 추적되는 코드 영역입니다.</target>
        </trans-unit>
        <trans-unit id="95c213e4f5521f3f5195554245abca05424ff590" translate="yes" xml:space="preserve">
          <source>Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.</source>
          <target state="translated">등록하면 제공된 이름으로 데이터베이스 드라이버를 사용할 수 있습니다. 같은 이름으로 Register를 두 번 호출하거나 드라이버가 nil이면 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="64aef767785d208425e3e70c5d2194fcd9c84c85" translate="yes" xml:space="preserve">
          <source>Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:</source>
          <target state="translated">레지스터는 다음 조건을 만족하는 수신자 값의 메소드 세트를 서버에 공개합니다.</target>
        </trans-unit>
        <trans-unit id="cbe295e9d864bc0bca7f28c205cb5395eba55d05" translate="yes" xml:space="preserve">
          <source>Register publishes the receiver's methods in the DefaultServer.</source>
          <target state="translated">Register는 DefaultServer에 수신자의 메소드를 공개합니다.</target>
        </trans-unit>
        <trans-unit id="c181d095749a9fa33757c1798befea770ef8d4eb" translate="yes" xml:space="preserve">
          <source>Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.</source>
          <target state="translated">Register는 내부 유형 이름 아래 해당 유형의 값으로 식별되는 유형을 기록합니다. 이 이름은 인터페이스 변수로 보내거나받는 값의 구체적인 유형을 식별합니다. 인터페이스 값의 구현으로 전송 될 유형 만 등록하면됩니다. 초기화 중에 만 사용될 것으로 예상되는 경우 유형과 이름 사이의 매핑이 형용사가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fceb2cf0f9b16aaaaa6d86b667b93fcaf25ae6c9" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterCompressor는 지정된 메소드 ID에 대한 사용자 지정 압축기를 등록합니다. Store 및 Deflate의 일반적인 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a803c7a9e0d15c2a5bd92b06180759964dddc4a" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.</source>
          <target state="translated">RegisterCompressor는 특정 방법 ID에 대한 사용자 지정 압축기를 등록하거나 무시합니다. 주어진 방법에 대한 컴프레서를 찾을 수없는 경우 기본적으로 Writer는 패키지 수준에서 컴프레서를 조회합니다.</target>
        </trans-unit>
        <trans-unit id="75b2829cabbf108c3c7f621e80ccf782333f2745" translate="yes" xml:space="preserve">
          <source>RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">RegisterCover는 테스트를위한 커버리지 데이터 누산기를 기록합니다. 참고 :이 기능은 테스트 인프라 내부에 있으며 변경 될 수 있습니다. Go 1 호환성 가이드 라인은 아직 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0efe5941ddd4024eca3486bcfdaa1b04b1d68c96" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterDecompressor는 지정된 메소드 ID에 대한 사용자 정의 압축 해제기를 허용합니다. Store 및 Deflate의 일반적인 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8201de27600ded04eed1497b03a93af78ab1356" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.</source>
          <target state="translated">RegisterDecompressor는 특정 메소드 ID에 대한 사용자 정의 압축 풀기를 등록하거나 재정의합니다. 주어진 방법에 대한 압축 해제기를 찾을 수 없으면 Reader는 기본적으로 압축 해제기를 패키지 수준에서 조회합니다.</target>
        </trans-unit>
        <trans-unit id="9306a2a96e5923311a823aa140641259832a6493" translate="yes" xml:space="preserve">
          <source>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;. Magic is the magic prefix that identifies the format's encoding. The magic string can contain &quot;?&quot; wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.</source>
          <target state="translated">RegisterFormat은 Decode에서 사용할 이미지 형식을 등록합니다. 이름은 &quot;jpeg&quot;또는 &quot;png&quot;와 같은 형식의 이름입니다. Magic은 형식의 인코딩을 식별하는 마법 접두사입니다. 매직 스트링에는 &quot;?&quot;가 포함될 수 있습니다. 각각 1 바이트와 일치하는 와일드 카드 디코딩은 인코딩 된 이미지를 디코딩하는 기능입니다. DecodeConfig는 해당 구성 만 디코딩하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d2728f688707b63db693060d8790bf4683f92102" translate="yes" xml:space="preserve">
          <source>RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.</source>
          <target state="translated">RegisterHash는 주어진 해시 함수의 새 인스턴스를 반환하는 함수를 등록합니다. 이것은 해시 함수를 구현하는 패키지의 init 함수에서 호출하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f205fffb3fe13999a49ce9f8f1c25ec589135c4d" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.</source>
          <target state="translated">RegisterName은 Register와 비슷하지만 수신자의 구체적 유형 대신 유형에 제공된 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="25332b231573649cd9dd5719e7982ea3f0248d42" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name rather than the type's default.</source>
          <target state="translated">RegisterName은 Register와 비슷하지만 유형의 기본값 대신 제공된 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50c9507f9819b5006da79dc0a05071eebeda3b66" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown은 종료시 호출 할 기능을 등록합니다. 이것은 NPN / ALPN 프로토콜 업그레이드를 받았거나 하이재킹 된 연결을 정상적으로 종료하는 데 사용할 수 있습니다. 이 기능은 프로토콜 별 정상 종료를 시작해야하지만 종료가 완료 될 때까지 기다리지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f09b3e8729145f382cce24a789165716e1f6f581" translate="yes" xml:space="preserve">
          <source>RegisterProtocol can be used by other packages to provide implementations of protocol schemes like &quot;ftp&quot; or &quot;file&quot;.</source>
          <target state="translated">RegisterProtocol은 &quot;ftp&quot;또는 &quot;file&quot;과 같은 프로토콜 체계의 구현을 제공하기 위해 다른 패키지에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbed30c09a7f4317da85a08f890897f3a240daa9" translate="yes" xml:space="preserve">
          <source>RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.</source>
          <target state="translated">RegisterProtocol은 체계를 사용하여 새 프로토콜을 등록합니다. 전송은 주어진 체계를 사용하여 요청을 rt로 전달합니다. HTTP 요청 시맨틱을 시뮬레이션하는 것은 RT의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="95f136e8903a5338ba8f8a6eba4b4b48f4b69ff6" translate="yes" xml:space="preserve">
          <source>Regs386 is the Mach-O 386 register structure.</source>
          <target state="translated">Regs386은 Mach-O 386 레지스터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="2fcecaafbea673f4dcd43eda2b8e308980d372b2" translate="yes" xml:space="preserve">
          <source>RegsAMD64 is the Mach-O AMD64 register structure.</source>
          <target state="translated">RegsAMD64는 Mach-O AMD64 레지스터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="e042b10a368397c92fb60dbef856be3d5a1c4f5c" translate="yes" xml:space="preserve">
          <source>Rel</source>
          <target state="translated">Rel</target>
        </trans-unit>
        <trans-unit id="1fb867ac152e76d351e8dfda8aca4022a73396b3" translate="yes" xml:space="preserve">
          <source>Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.</source>
          <target state="translated">Rel은 중간 구분 기호를 사용하여 기본 경로에 결합 된 경우 targpath와 어휘 적으로 동등한 상대 경로를 반환합니다. 즉, Join (basepath, Rel (basepath, targpath))은 targpath 자체와 동일합니다. 성공하면 반환 된 경로는 basepath와 targpath가 요소를 공유하지 않더라도 항상 basepath에 상대적입니다. targpath를 기준 경로와 관련하여 만들 수 없거나 현재 작업 디렉토리를 알고 있어야 계산할 경우 오류가 리턴됩니다. Rel은 결과에 대해 Clean을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c91ec177ba02dafca5c024ef643b47566dd89ce7" translate="yes" xml:space="preserve">
          <source>Relationship between Tok value and Specs element type:</source>
          <target state="translated">Tok 값과 Specs 요소 유형의 관계 :</target>
        </trans-unit>
        <trans-unit id="b6abe7b7ff14b910183c9aec85ce50c4ba39a8a2" translate="yes" xml:space="preserve">
          <source>RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg.</source>
          <target state="translated">RelativeTo는 pkg 이외의 모든 패키지 멤버를 완전히 규정하는 규정자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97b37138ea9a73172899c8018d830214258b5899" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release.</source>
          <target state="translated">릴리스는 기능에 할당 된 자원을 해제합니다. Release를 호출 한 후 함수를 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c955e9bb05dd10804916da733d223f9b35d93831" translate="yes" xml:space="preserve">
          <source>Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.</source>
          <target state="translated">릴리스는 프로세스 p와 연관된 모든 자원을 릴리스하여 나중에 사용할 수 없게합니다. 대기가 아닌 경우에만 릴리스를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="74b4353ac8d321669700f92b4b41fd9bf3c282ea" translate="yes" xml:space="preserve">
          <source>Reloc represents a PE COFF relocation. Each section contains its own relocation list.</source>
          <target state="translated">재배치는 PE COFF 재배치를 나타냅니다. 각 섹션에는 자체 재배치 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f15fe6a2a2d8aaac59472278e750857f76ab13" translate="yes" xml:space="preserve">
          <source>Relocation types for 386.</source>
          <target state="translated">386의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="d75a9d4eea543b3382ef4c2ebb9e3847ab91fd45" translate="yes" xml:space="preserve">
          <source>Relocation types for 64-bit PowerPC or Power Architecture processors.</source>
          <target state="translated">64 비트 PowerPC 또는 Power Architecture 프로세서의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="cf64299a5f4f83507314f139a3920dac3975ef27" translate="yes" xml:space="preserve">
          <source>Relocation types for AArch64 (aka arm64)</source>
          <target state="translated">AArch64 (일명 arm64)의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="ef97dc2ae262d8f689d2dbae4ceb64c7c62edcc6" translate="yes" xml:space="preserve">
          <source>Relocation types for ARM.</source>
          <target state="translated">ARM의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="2557c954121a635ff74fb9af9fe06dc80e27b715" translate="yes" xml:space="preserve">
          <source>Relocation types for Alpha.</source>
          <target state="translated">알파의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="1a1e40660756b62ef3239b6ced113d0caf0dbeda" translate="yes" xml:space="preserve">
          <source>Relocation types for MIPS.</source>
          <target state="translated">MIPS의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="37b372c8b8cafc23d3fe71c2d91eeb8c48e4e130" translate="yes" xml:space="preserve">
          <source>Relocation types for PowerPC.</source>
          <target state="translated">PowerPC의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="515822ec7faf1b82351dd8cb58bc45abc27332b8" translate="yes" xml:space="preserve">
          <source>Relocation types for RISC-V processors.</source>
          <target state="translated">RISC-V 프로세서의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="28595645ef003fbc741125cd77426e420a3c93bb" translate="yes" xml:space="preserve">
          <source>Relocation types for SPARC.</source>
          <target state="translated">SPARC의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="c8eeb8ad932e590ca3c9a184613db792a1b7d221" translate="yes" xml:space="preserve">
          <source>Relocation types for s390x processors.</source>
          <target state="translated">s390x 프로세서의 재배치 유형.</target>
        </trans-unit>
        <trans-unit id="65d84f2017b766a2f893b1d9391a10aba054030c" translate="yes" xml:space="preserve">
          <source>Relocation types for x86-64.</source>
          <target state="translated">x86-64의 재배치 유형</target>
        </trans-unit>
        <trans-unit id="f46f12d749f237f3883c4c5a62ab9b4f4409ae12" translate="yes" xml:space="preserve">
          <source>Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.</source>
          <target state="translated">Rem은 y! = 0에 대해 z를 나머지 x % y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Rem은 잘린 모듈러스 (Go와 같은)를 구현합니다. 자세한 내용은 QuoRem을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a90835af9526ee1f92955fe811ed706ded57897" translate="yes" xml:space="preserve">
          <source>Remainder returns the IEEE 754 floating-point remainder of x/y.</source>
          <target state="translated">나머지는 x / y의 IEEE 754 부동 소수점 나머지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2dbe95bdd28a0d327a2826a1eef6ea3b725d6372" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address.</source>
          <target state="translated">RemoteAddr은 원격 네트워크 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f214e8a0c44c6dd9e0f980e84dc95f63540d94a" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.</source>
          <target state="translated">RemoteAddr은 원격 네트워크 주소를 반환합니다. 리턴 된 Addr은 RemoteAddr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="90f28a6964f1d3561d308698fa02c4f609406cc1" translate="yes" xml:space="preserve">
          <source>Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">제거는 힙에서 인덱스 i의 요소를 제거하고 리턴합니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="63f1e9035000ecf346c434c7cac5dc81f24b1fd9" translate="yes" xml:space="preserve">
          <source>Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil.</source>
          <target state="translated">e가 목록 l의 요소 인 경우 제거는 l에서 e를 제거합니다. 요소 값 e.Value를 리턴합니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="e157d0f3ede189bf26b7e5070547dae063fd8af3" translate="yes" xml:space="preserve">
          <source>Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile.</source>
          <target state="translated">제거는 값과 연관된 실행 스택을 프로파일에서 제거합니다. 값이 프로파일에없는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="737a090d3844bc76afa279471870777ff484d715" translate="yes" xml:space="preserve">
          <source>Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">제거는 명명 된 파일 또는 (빈) 디렉토리를 제거합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2570a819a5c470bfe2d2d19b6aafa9194f77567b" translate="yes" xml:space="preserve">
          <source>RemoveAll removes any temporary files associated with a Form.</source>
          <target state="translated">RemoveAll은 양식과 관련된 모든 임시 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4fad214b70e3f0d318c435f74dd889aca7ef4dce" translate="yes" xml:space="preserve">
          <source>RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type *PathError.</source>
          <target state="translated">RemoveAll은 경로와 여기에 포함 된 모든 자식을 제거합니다. 가능한 모든 것을 제거하지만 발생한 첫 번째 오류를 반환합니다. 경로가 없으면 RemoveAll은 nil을 반환합니다 (오류 없음). 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a4df6c6f5aeda6e3a5e7e46422d0e2c2213a3c07" translate="yes" xml:space="preserve">
          <source>RemoveMultiples sorts an ErrorList and removes all but the first error per line.</source>
          <target state="translated">RemoveMultiples는 ErrorList를 정렬하고 행당 첫 번째 오류를 제외한 모든 오류를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c2642ac096483cfaf0dfa99c4fbd35ae36daa1eb" translate="yes" xml:space="preserve">
          <source>Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">이름 바꾸기는 oldpath의 이름을 newpath로 변경 (이동)합니다. newpath가 이미 존재하고 디렉토리가 아닌 경우 이름 바꾸기가이를 대체합니다. oldpath와 newpath가 다른 디렉토리에있는 경우 OS 특정 제한 사항이 적용될 수 있습니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fdd5e93217a24d0127aee52fa57edae8bdb219bf" translate="yes" xml:space="preserve">
          <source>Renegotiation is not defined in TLS 1.3.</source>
          <target state="translated">재협상은 TLS 1.3에 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="592ed73cf658d5bb06fa571424af0b382c1c93a8" translate="yes" xml:space="preserve">
          <source>RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.</source>
          <target state="translated">재협상 지원은 TLS 재협상에 대한 서로 다른 수준의 지원을 열거합니다. TLS 재협상은 첫 번째 연결 후 연결에서 후속 핸드 셰이크를 수행하는 작업입니다. 이것은 상태 머신을 상당히 복잡하게 만들고 수많은 미묘한 보안 문제의 원인이되었습니다. 재협상 시작은 지원되지 않지만 재협상 요청 수락 지원이 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659eba121958f4a29fab3d29d61cedc55a892334" translate="yes" xml:space="preserve">
          <source>Repeat</source>
          <target state="translated">Repeat</target>
        </trans-unit>
        <trans-unit id="599d1421a3d35ed387e2145047d3b7a4416981b0" translate="yes" xml:space="preserve">
          <source>Repeat returns a new byte slice consisting of count copies of b.</source>
          <target state="translated">반복은 b의 카운트 사본으로 구성된 새 바이트 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0843316565926f24e0d78b098353e903c702fd32" translate="yes" xml:space="preserve">
          <source>Repeat returns a new string consisting of count copies of the string s.</source>
          <target state="translated">반복은 문자열의 개수 사본으로 구성된 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b93ec95436616b79bd94ec117ace8a646628d209" translate="yes" xml:space="preserve">
          <source>Repetitions:</source>
          <target state="translated">Repetitions:</target>
        </trans-unit>
        <trans-unit id="a7cf7b25a703b308887c7f1d100c4326ef20ac46" translate="yes" xml:space="preserve">
          <source>Replace</source>
          <target state="translated">Replace</target>
        </trans-unit>
        <trans-unit id="14a86b576c43d99c7af38126a244d77d20b45014" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of s with all replacements performed.</source>
          <target state="translated">Replace는 모든 교체가 수행 된 s 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="486c15b931366bdf03143c243ee2b4d97be57dd7" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace는 슬라이스의 사본을 겹치지 않는 오래된 n 개의 인스턴스를 new로 바꿉니다. old가 비어 있으면 슬라이스 시작시 및 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 슬라이스를 k + 1로 대체합니다. n &amp;lt;0이면 교체 횟수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="db4d7af1ecfbb4c54ae4d472073701051302c13a" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace는 문자열 s의 복사본을 겹치지 않는 오래된 n 개의 인스턴스를 new로 대체합니다. old가 비어 있으면 문자열의 시작 부분과 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 문자열의 최대 k + 1 대체를 생성합니다. n &amp;lt;0이면 교체 횟수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eadb25ec304f683e79d867595086d352904b5b3" translate="yes" xml:space="preserve">
          <source>ReplaceAll</source>
          <target state="translated">ReplaceAll</target>
        </trans-unit>
        <trans-unit id="73ca5d06cabf37b075a8580fb5101f87650ad229" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAll은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 텍스트 repl로 바꿉니다. repl 내에서 $ 부호는 Expand와 같이 해석되므로 예를 들어 $ 1은 첫 번째 하위 일치 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="506447353e7b3822dcf4613a0f93ab71e29d1735" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice.</source>
          <target state="translated">ReplaceAll은 겹치지 않는 모든 이전 인스턴스가 new로 대체 된 슬라이스 사본을 반환합니다. old가 비어 있으면 슬라이스 시작시와 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 슬라이스를 k + 1로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="435dc323288417e80211f8927c3695e3ce359257" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.</source>
          <target state="translated">ReplaceAll은 겹치지 않는 모든 오래된 인스턴스가 new로 대체 된 문자열 s를 반환합니다. old가 비어 있으면 문자열의 시작 부분과 각 UTF-8 시퀀스 이후에 일치하여 k- 룬 문자열의 최대 k + 1 대체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3d66ecd6da17fab5c8cd96769f904257ef13a398" translate="yes" xml:space="preserve">
          <source>ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllFunc는 Regexp의 모든 일치 항목이 일치하는 바이트 슬라이스에 적용된 repl 함수의 반환 값으로 대체 된 src의 복사본을 반환합니다. repl에 의해 반환 된 대체는 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2a17131c7994cd05d7daea07beea0ef31e257581" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteral은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 바이트 repl로 바꿉니다. 대체 repl은 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="87232f03b040c072f8f75219db9d85c61ff38e7c" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteralString은 Regexp의 일치 항목을 대체 문자열 repl로 바꾸어 src 사본을 리턴합니다. 대체 repl은 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bef70f919214d0f77e4d3a42c824dfffa5202cf4" translate="yes" xml:space="preserve">
          <source>ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAllString은 src의 복사본을 반환하고 Regexp의 일치 항목을 대체 문자열 repl로 바꿉니다. repl 내에서 $ 부호는 Expand와 같이 해석되므로 예를 들어 $ 1은 첫 번째 하위 일치 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3e275047465f9460cb043d0b2093b457293bb06" translate="yes" xml:space="preserve">
          <source>ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllStringFunc는 Regexp의 모든 일치 항목이 일치하는 하위 문자열에 적용된 repl 함수의 반환 값으로 대체 된 src의 복사본을 반환합니다. repl에 의해 반환 된 대체는 Expand를 사용하지 않고 직접 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="15e8ece6d83eb79a1b1a825152f49a545610894e" translate="yes" xml:space="preserve">
          <source>Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Replacer는 문자열 목록을 대체로 바꿉니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5cf96ab71fbe348ef9fe46121c7813b382500496" translate="yes" xml:space="preserve">
          <source>Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:</source>
          <target state="translated">형식으로 부호를 Z로 바꾸면 UTC 영역에 대한 오프셋 대신 Z 인쇄의 ISO 8601 동작이 트리거됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="4b4d5cf4e6e2109de9a6b60e939d3a3fb07ec141" translate="yes" xml:space="preserve">
          <source>ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.</source>
          <target state="translated">ReportAllocs는이 벤치 마크에 대한 malloc 통계를 사용합니다. -test.benchmem 설정과 동일하지만 ReportAllocs를 호출하는 벤치 마크 함수에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="ca2f164e5206d2fe2c80e762a870dbd7b150154b" translate="yes" xml:space="preserve">
          <source>ReportMetric adds &quot;n unit&quot; to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in &quot;/op&quot;. ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as &quot;allocs/op&quot;), ReportMetric will override that metric. Setting &quot;ns/op&quot; to 0 will suppress that built-in metric.</source>
          <target state="translated">ReportMetric은보고 된 벤치 마크 결과에 &quot;n 단위&quot;를 추가합니다. 메트릭이 반복 단위 인 경우 호출자는 bN으로 나누고 컨벤션 단위는 &quot;/ op&quot;로 끝나야합니다. ReportMetric은 동일한 단위에 대해 이전에보고 된 값을 무시합니다. unit이 빈 문자열이거나 unit에 공백이 있으면 ReportMetric 패닉이 발생합니다. 단위가 벤치 마크 프레임 워크 자체 (예 : &quot;allocs / op&quot;)에 의해 일반적으로보고되는 단위 인 경우 ReportMetric은 해당 메트릭을 재정의합니다. &quot;ns / op&quot;를 0으로 설정하면 내장 메트릭이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="bbfd1ef8b32af00f36af4ce56ffc90aaec2642df" translate="yes" xml:space="preserve">
          <source>Representations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.</source>
          <target state="translated">GobEncode, MarshalBinary, MarshalJSON 및 MarshalText 메소드에 의해 저장된 시간 값의 표현은 Time.Location의 오프셋을 저장하지만 위치 이름은 저장하지 않습니다. 따라서 일광 절약 시간제에 대한 정보가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="034f490ecab4d9730ca1969131b6a78b84d524bf" translate="yes" xml:space="preserve">
          <source>Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">요청은 모든 RPC 호출 전에 작성된 헤더입니다. 내부적으로 사용되지만 네트워크 트래픽을 분석 할 때와 같이 디버깅을 돕기 위해 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe490925acca7c7d2d43d098e092cfd78223216" translate="yes" xml:space="preserve">
          <source>Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.</source>
          <target state="translated">요청은 현재 환경에 표시된대로 HTTP 요청을 반환합니다. 이것은 현재 프로그램이 CGI 환경의 웹 서버에 의해 실행되고 있다고 가정합니다. 해당되는 경우 반환 된 요청 본문이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d122cdaacba1573bfe57f160ca47386cbda87132" translate="yes" xml:space="preserve">
          <source>RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated.</source>
          <target state="translated">RequestFromMap은 CGI 변수에서 http.Request를 작성합니다. 반환 된 요청 본문 필드가 채워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27b1cff1ae1ef7bb8ea746c0ebbfe176f573422d" translate="yes" xml:space="preserve">
          <source>RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u.</source>
          <target state="translated">RequestURI는 u에 대한 HTTP 요청에 사용될 인코딩 된 경로 쿼리 또는 불투명 쿼리 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b21fedf00a3371e3f28d17145c5a692c6831e7c" translate="yes" xml:space="preserve">
          <source>Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</source>
          <target state="translated">재설정은 지속 시간 후에 타이머가 만료되도록 변경합니다. d. 타이머가 활성화 된 경우 true를, 타이머가 만료되었거나 중지 된 경우 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1eaa7c3f868073620d91cca86ce9b81e6921a9e0" translate="yes" xml:space="preserve">
          <source>Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w.</source>
          <target state="translated">Reset은 Writer z의 상태를 지워 NewWriterLevel 또는 NewWriterLevelDict의 초기 상태와 같지만 대신 w에 씁니다.</target>
        </trans-unit>
        <trans-unit id="8fad0a06171db3d325d00805f309209741be9985" translate="yes" xml:space="preserve">
          <source>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.</source>
          <target state="translated">Reset은 버퍼링 된 데이터를 버리고 모든 상태를 재설정 한 다음 r에서 읽도록 버퍼링 된 리더를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ddec4089b2023a9f5966b6899a6d86b3c6ba6d0e" translate="yes" xml:space="preserve">
          <source>Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.</source>
          <target state="translated">재설정은 버퍼링되지 않은 버퍼링 된 데이터를 버리고 오류를 지우고 b를 재설정하여 출력을 w에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0f6193249698e8c1cc414024f184ff9d63a0b799" translate="yes" xml:space="preserve">
          <source>Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one.</source>
          <target state="translated">Reset은 Reader z의 상태를 버리고 NewReader의 원래 상태 결과와 동일하지만 대신 r에서 읽습니다. 이를 통해 새로운 리더를 할당하는 대신 리더를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8366944feb20881339d2bc39051aaaff11ba2e7" translate="yes" xml:space="preserve">
          <source>Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one.</source>
          <target state="translated">Reset은 Writer z의 상태를 버리고 NewWriter 또는 NewWriterLevel의 원래 상태 결과와 동일하지만 대신 w에 쓰는 것입니다. 이를 통해 새로운 것을 할당하는 대신 라이터를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1192ba3cfdd5644c337b189600cac9374ed9f399" translate="yes" xml:space="preserve">
          <source>Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary.</source>
          <target state="translated">Reset은 기록기의 상태를 버리고 dst 및 w의 수준 및 사전으로 호출 된 NewWriter 또는 NewWriterDict의 결과와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f44016b53cb6e5efb7b07f97bdd7a58a3f9acd27" translate="yes" xml:space="preserve">
          <source>Reset repositions the line table reader at the beginning of the line table.</source>
          <target state="translated">재설정은 행 테이블의 시작 부분에서 행 테이블 판독기를 재배치합니다.</target>
        </trans-unit>
        <trans-unit id="fc5e1e89a723101da37c5f7cdde61464338d0205" translate="yes" xml:space="preserve">
          <source>Reset resets an ErrorList to no errors.</source>
          <target state="translated">Reset은 ErrorList를 오류없이 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="06a254b1693f024953c4504eb0ab4b1efccfe485" translate="yes" xml:space="preserve">
          <source>Reset resets the Builder to be empty.</source>
          <target state="translated">재설정은 빌더가 비어 있도록 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="e5afd25b08aea0811ed90f3f30191e4fc43f9115" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from b.</source>
          <target state="translated">재설정은 판독기에서 읽을 판독기를 재설정합니다. b.</target>
        </trans-unit>
        <trans-unit id="15670331b1298dacd5ea205176b1269922b3d2b5" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from s.</source>
          <target state="translated">재설정은 리더가 s에서 읽을 수 있도록 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="170c10bab8e54e5cf030eb670497e5196563378e" translate="yes" xml:space="preserve">
          <source>Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).</source>
          <target state="translated">Reset은 버퍼를 비우도록 재설정하지만 나중에 쓸 때 사용할 기본 스토리지를 유지합니다. 재설정은 Truncate (0)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cf78ba3d25ca4518fc926a9a64e46d873a5c2b0" translate="yes" xml:space="preserve">
          <source>Reset sends the RSET command to the server, aborting the current mail transaction.</source>
          <target state="translated">Reset은 RSET 명령을 서버로 전송하여 현재 메일 트랜잭션을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="a8bd7c2aca0a58855a450ef3c393b7f8dd845541" translate="yes" xml:space="preserve">
          <source>Reset should be invoked only on stopped or expired timers with drained channels. If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="translated">채널이 비워진 중지 또는 만료 된 타이머에서만 재설정을 호출해야합니다. 프로그램이 이미 tC로부터 값을 수신 한 경우 타이머가 만료되고 채널이 비워진 것으로 알려져 있으므로 t.Reset을 직접 사용할 수 있습니다. 그러나 프로그램이 아직 tC로부터 값을받지 못한 경우 타이머를 중지해야하며 중지가 타이머가 중지되기 전에 타이머가 만료되었다고보고하면 채널이 명시 적으로 비워집니다.</target>
        </trans-unit>
        <trans-unit id="c62db3fae7c3e711fbf34aadc1b1afc1b9253c1a" translate="yes" xml:space="preserve">
          <source>Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset.</source>
          <target state="translated">재설정은 제공된 신호에 대한 알림 호출에 대한 이전 호출의 효과를 취소합니다. 신호가 제공되지 않으면 모든 신호 처리기가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="27fa1b9793c51dfd946a69a14c0ddb57c10ad547" translate="yes" xml:space="preserve">
          <source>Reset zeros the key data and makes the Cipher unusable.</source>
          <target state="translated">Reset은 키 데이터를 0으로 만들고 암호를 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="f310c59e5a0084054073df7b5f573d812cdd0fd8" translate="yes" xml:space="preserve">
          <source>ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running.</source>
          <target state="translated">ResetTimer는 경과 된 벤치 마크 시간 및 메모리 할당 카운터를 0으로 만들고 사용자가보고 한 메트릭을 삭제합니다. 타이머가 실행 중인지 여부에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33ee9712ca346c749995f4d74bcd18ae6c0b0650" translate="yes" xml:space="preserve">
          <source>Resetter resets a ReadCloser returned by NewReader or NewReaderDict to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.</source>
          <target state="translated">Resetter는 NewReader 또는 NewReaderDict에서 반환 된 ReadCloser를 재설정하여 새로운 기본 Reader로 전환합니다. 이를 통해 새로운 것을 할당하는 대신 ReadCloser를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7007d754cde94120e44343157ab76b14a831c26c" translate="yes" xml:space="preserve">
          <source>ResolveIPAddr returns an address of IP end point.</source>
          <target state="translated">ResolveIPAddr은 IP 엔드 포인트의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07b69306928a5a3a0b8c2314c2531e10de93c9cf" translate="yes" xml:space="preserve">
          <source>ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref.</source>
          <target state="translated">ResolveReference는 RFC 3986 섹션 5.2에 따라 절대 기본 URI u에서 절대 URI에 대한 URI 참조를 분석합니다. URI 참조는 상대적이거나 절대적 일 수 있습니다. 반환 된 URL이 기본 또는 참조와 동일하더라도 ResolveReference는 항상 새 URL 인스턴스를 반환합니다. ref가 절대 URL 인 경우 ResolveReference는 base를 무시하고 ref의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3273804861eaad79df80c3d22cf109398eb595c4" translate="yes" xml:space="preserve">
          <source>ResolveTCPAddr returns an address of TCP end point.</source>
          <target state="translated">ResolveTCPAddr은 TCP 끝점의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d940491c716336f4aaf080189bdb0c28cf1b6ec4" translate="yes" xml:space="preserve">
          <source>ResolveUDPAddr returns an address of UDP end point.</source>
          <target state="translated">ResolveUDPAddr은 UDP 엔드 포인트의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2928800c224397786b541e4886439dcdc0ecfc66" translate="yes" xml:space="preserve">
          <source>ResolveUnixAddr returns an address of Unix domain socket end point.</source>
          <target state="translated">ResolveUnixAddr은 Unix 도메인 소켓 끝점의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3dd3f1ec80ee28cb3dd53e5b932daca2d3fdd951" translate="yes" xml:space="preserve">
          <source>Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">응답은 모든 RPC가 반환되기 전에 작성된 헤더입니다. 내부적으로 사용되지만 네트워크 트래픽을 분석 할 때와 같이 디버깅을 돕기 위해 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fa8e7076763a708a759f35e6fdf9c8c2792c3e" translate="yes" xml:space="preserve">
          <source>Response represents the response from an HTTP request.</source>
          <target state="translated">응답은 HTTP 요청의 응답을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c870a02afd7772b1a5c1104af64d975949d9837" translate="yes" xml:space="preserve">
          <source>ResponseRecorder</source>
          <target state="translated">ResponseRecorder</target>
        </trans-unit>
        <trans-unit id="294d856644ce3293fbb784b42f79f661b3d60595" translate="yes" xml:space="preserve">
          <source>ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests.</source>
          <target state="translated">ResponseRecorder는 테스트에서 나중에 검사 할 수 있도록 돌연변이를 기록하는 http.ResponseWriter의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d0d0da2350df38e89f18eec0c8c277a390ef8032" translate="yes" xml:space="preserve">
          <source>ResponseWriter (Trailers)</source>
          <target state="translated">ResponseWriter (예고편)</target>
        </trans-unit>
        <trans-unit id="3f9f60a3d963394dba2b9af5ad21d7cf9b8efc40" translate="yes" xml:space="preserve">
          <source>Responses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.</source>
          <target state="translated">1xx 범위의 상태 코드가있는 응답은 자동으로 처리되거나 (예상 100 계속) 무시됩니다. 한 가지 예외는 HTTP 상태 코드 101 (스위칭 프로토콜)이며, 이는 터미널 상태로 간주되어 RoundTrip에 의해 반환됩니다. 무시 된 1xx 응답을 보려면 httptrace 추적 패키지의 ClientTrace.Got1xxResponse를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c92c6b4dd981d78fca3ec0b5b13d22c3c7e3c9ff" translate="yes" xml:space="preserve">
          <source>Result is the result of a query execution.</source>
          <target state="translated">결과는 쿼리 실행의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="1f4d7bab508f22f797e449d5f6998b16e4434cbe" translate="yes" xml:space="preserve">
          <source>Result must only be called after the handler has finished running.</source>
          <target state="translated">핸들러 실행이 완료된 후에 만 ​​결과를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5febf7558713f1ecb2fbd2c227fbc55af9bbed" translate="yes" xml:space="preserve">
          <source>Result returns the response generated by the handler.</source>
          <target state="translated">결과는 핸들러가 생성 한 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2d5559e8af761fd8963b92d10b52cc8627380cc7" translate="yes" xml:space="preserve">
          <source>ResultNoRows is a pre-defined Result for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and RowsAffected.</source>
          <target state="translated">ResultNoRows는 DDL 명령 (예 : CREATE TABLE)이 성공할 때 드라이버가 반환 할 미리 정의 된 결과입니다. LastInsertId 및 RowsAffected 모두에 대해 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3b838adfac99fd155c663831ad38556581e0407" translate="yes" xml:space="preserve">
          <source>Results returns the results of signature s, or nil.</source>
          <target state="translated">Results는 서명 결과 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="962f14cb7eca51d5151fcfbeb4ab3ed937db54aa" translate="yes" xml:space="preserve">
          <source>Return the most recent call to Scan as a []byte.</source>
          <target state="translated">Scan에 대한 가장 최근 호출을 [] 바이트로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="57f9933768794f845d000833d367d5698393211d" translate="yes" xml:space="preserve">
          <source>Reverse</source>
          <target state="translated">Reverse</target>
        </trans-unit>
        <trans-unit id="902e55a122fa4891a6dae083e18230ea968dc9a3" translate="yes" xml:space="preserve">
          <source>Reverse returns the reverse order for data.</source>
          <target state="translated">역순은 데이터의 역순을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78b0b4cb759dec2da3c6713767fbf6f4bc040c4d" translate="yes" xml:space="preserve">
          <source>Reverse returns the value of x with its bits in reversed order.</source>
          <target state="translated">역순으로 비트의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92de4737778eb41e55ca2f7a627a47fd6ba4a889" translate="yes" xml:space="preserve">
          <source>Reverse16</source>
          <target state="translated">Reverse16</target>
        </trans-unit>
        <trans-unit id="b383f837c66d7bdba479cd898a8ff90df6a54bdc" translate="yes" xml:space="preserve">
          <source>Reverse16 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse16은 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc5bc5fb62f24a53fcf7486ea47cb526c49ed16b" translate="yes" xml:space="preserve">
          <source>Reverse32</source>
          <target state="translated">Reverse32</target>
        </trans-unit>
        <trans-unit id="31e983ab5d2fdae281f62da27af16c6410c88366" translate="yes" xml:space="preserve">
          <source>Reverse32 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse32는 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b8d738bc3f5b572852bef49d9d1b74649451478" translate="yes" xml:space="preserve">
          <source>Reverse64</source>
          <target state="translated">Reverse64</target>
        </trans-unit>
        <trans-unit id="0a95ddc6b008b1c60668050345ad2bbd0048d26d" translate="yes" xml:space="preserve">
          <source>Reverse64 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse64는 비트와 함께 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b7d623b04231c73d009937cc199213fab60a116" translate="yes" xml:space="preserve">
          <source>Reverse8</source>
          <target state="translated">Reverse8</target>
        </trans-unit>
        <trans-unit id="4e2cfa80f1f3211b8d7b8f97b9c866dc8e5602ee" translate="yes" xml:space="preserve">
          <source>Reverse8 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse8은 비트가있는 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be39e968e6f8b02161cf145a91c2242f8ac3e738" translate="yes" xml:space="preserve">
          <source>ReverseBytes returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes는 바이트와 함께 x의 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3a8220fbdce3c882a295efbc513cc8d73cb1a7a" translate="yes" xml:space="preserve">
          <source>ReverseBytes16</source>
          <target state="translated">ReverseBytes16</target>
        </trans-unit>
        <trans-unit id="2a7c652af5267d559395a2d601cef862d0dc08f3" translate="yes" xml:space="preserve">
          <source>ReverseBytes16 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes16은 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b3b6869428b45a4008a611a88e1d858c7f82ca5" translate="yes" xml:space="preserve">
          <source>ReverseBytes32</source>
          <target state="translated">ReverseBytes32</target>
        </trans-unit>
        <trans-unit id="bd4bbc4dc35b34c8851580c4ed26f1553540d805" translate="yes" xml:space="preserve">
          <source>ReverseBytes32 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes32는 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27b3c718307e25ebd0df6355d5ba2181fe72066f" translate="yes" xml:space="preserve">
          <source>ReverseBytes64</source>
          <target state="translated">ReverseBytes64</target>
        </trans-unit>
        <trans-unit id="2bfe4d5fab882bedb4ed52db5659be4b630cad79" translate="yes" xml:space="preserve">
          <source>ReverseBytes64 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes64는 바이트 단위의 x 값을 역순으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08e888d81afdf833be45fe65662c8198e86a5832" translate="yes" xml:space="preserve">
          <source>ReverseProxy</source>
          <target state="translated">ReverseProxy</target>
        </trans-unit>
        <trans-unit id="9bfcf9ccffddea8678782d891a9bd8387a2cdb0f" translate="yes" xml:space="preserve">
          <source>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</source>
          <target state="translated">ReverseProxy는 들어오는 요청을 가져 와서 다른 서버로 보내서 클라이언트에게 응답을 프록시하는 HTTP 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="36bf57062b0695082d5c3ab1cea707663eb8d688" translate="yes" xml:space="preserve">
          <source>RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">RevokedCertificate는 같은 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 5.1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1dbb08e5127fb312affa46a438163965fc7ebf23" translate="yes" xml:space="preserve">
          <source>RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString.</source>
          <target state="translated">RightAlign은 패딩 비트가 시작 부분 인 슬라이스를 반환합니다. 슬라이스는 메모리를 BitString과 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86681d4d51562a20e98b2b7ff856763c761235e0" translate="yes" xml:space="preserve">
          <source>Ring.Do</source>
          <target state="translated">Ring.Do</target>
        </trans-unit>
        <trans-unit id="c3de3d65f1bf374c9d07b4dfcda75c2206063f2b" translate="yes" xml:space="preserve">
          <source>Ring.Len</source>
          <target state="translated">Ring.Len</target>
        </trans-unit>
        <trans-unit id="ef738e03a934b3cea0ed8b70a7545fe51b5d290c" translate="yes" xml:space="preserve">
          <source>Ring.Link</source>
          <target state="translated">Ring.Link</target>
        </trans-unit>
        <trans-unit id="7fd8ab417197e9dee9db859427b5d7f544203d42" translate="yes" xml:space="preserve">
          <source>Ring.Move</source>
          <target state="translated">Ring.Move</target>
        </trans-unit>
        <trans-unit id="0851656843c7ec1e30ec39e3f0f5e84ae6a75fcd" translate="yes" xml:space="preserve">
          <source>Ring.Next</source>
          <target state="translated">Ring.Next</target>
        </trans-unit>
        <trans-unit id="61b297ba7e636a60d4221303b63f5d9cc41422d9" translate="yes" xml:space="preserve">
          <source>Ring.Prev</source>
          <target state="translated">Ring.Prev</target>
        </trans-unit>
        <trans-unit id="d7d905b26d8d9e9d4ae570e8e8161e643805b969" translate="yes" xml:space="preserve">
          <source>Ring.Unlink</source>
          <target state="translated">Ring.Unlink</target>
        </trans-unit>
        <trans-unit id="1a9da6de639f9bb2699bfe42d158358d7d6e5dc9" translate="yes" xml:space="preserve">
          <source>Rollback aborts the transaction.</source>
          <target state="translated">롤백이 트랜잭션을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b1d06a98df3a5bd7537bc07af57648fbe210073d" translate="yes" xml:space="preserve">
          <source>RotateLeft returns the value of x rotated left by (k mod UintSize) bits. To rotate x right by k bits, call RotateLeft(x, -k).</source>
          <target state="translated">RotateLeft는 왼쪽으로 x 회전 한 값을 (k mod UintSize) 비트만큼 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="761f01b6be4cc6f5188ea10477b0dc7cd1161d8c" translate="yes" xml:space="preserve">
          <source>RotateLeft16</source>
          <target state="translated">RotateLeft16</target>
        </trans-unit>
        <trans-unit id="d66c06db349417bfddd607ad14fa9bf5a5638d62" translate="yes" xml:space="preserve">
          <source>RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).</source>
          <target state="translated">RotateLeft16은 (k mod 16) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft16 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="60bcbc4fb2bbce0ec43078cea8be747ff9281e19" translate="yes" xml:space="preserve">
          <source>RotateLeft32</source>
          <target state="translated">RotateLeft32</target>
        </trans-unit>
        <trans-unit id="c60016746c6ad6b197ec5092101071fc87f7021a" translate="yes" xml:space="preserve">
          <source>RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).</source>
          <target state="translated">RotateLeft32는 (k mod 32) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft32 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6dc01719e1f445b08ee2ebc7136ef6822502932a" translate="yes" xml:space="preserve">
          <source>RotateLeft64</source>
          <target state="translated">RotateLeft64</target>
        </trans-unit>
        <trans-unit id="c0ff555090cb3bc9a90815cda1f96719ce3d40be" translate="yes" xml:space="preserve">
          <source>RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).</source>
          <target state="translated">RotateLeft64는 (k mod 64) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft64 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fdef633274845494879cbf0afeac8f854e3ba879" translate="yes" xml:space="preserve">
          <source>RotateLeft8</source>
          <target state="translated">RotateLeft8</target>
        </trans-unit>
        <trans-unit id="26ebe86c57d1d128d3a27bb9fd4358573f445da7" translate="yes" xml:space="preserve">
          <source>RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).</source>
          <target state="translated">RotateLeft8은 (k mod 8) 비트만큼 왼쪽으로 회전 한 x 값을 반환합니다. x를 k 비트 씩 오른쪽으로 회전하려면 RotateLeft8 (x, -k)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ec7b59833520bb2b53fd4d44b3d581720b55c442" translate="yes" xml:space="preserve">
          <source>Round</source>
          <target state="translated">Round</target>
        </trans-unit>
        <trans-unit id="000868eccd1432acf77f6949a96b4844d59b1fce" translate="yes" xml:space="preserve">
          <source>Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">라운드는 제로 시간 이후 절대 지속 시간으로 시간에 작동합니다. 프리젠 테이션 형식으로는 작동하지 않습니다. 따라서 Round (Hour)는 시간의 위치에 따라 0이 아닌 분으로 시간을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b948ea2f553b57093a9dabad37c8d45230573ca2" translate="yes" xml:space="preserve">
          <source>Round returns the nearest integer, rounding half away from zero.</source>
          <target state="translated">Round는 0에서 반으로 반올림하여 가장 가까운 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09b508228bc941d31ad58d40d683a414360f74b0" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m &amp;lt;= 0, Round returns d unchanged.</source>
          <target state="translated">Round는 d를 가장 가까운 m의 배수로 반올림 한 결과를 반환합니다. 반값의 반올림 동작은 0에서 반올림하는 것입니다. 결과가 Duration에 저장할 수있는 최대 (또는 최소) 값을 초과하면 Round는 최대 (또는 최소) 지속 시간을 반환합니다. m &amp;lt;= 0이면 Round는 변경되지 않은 d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46948003a0f2b7ed98f113a7c6a561fd40784b4d" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &amp;lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Round는 t를 가장 가까운 d의 배수로 반올림 한 결과를 반환합니다 (제로 시간 이후). 반값의 반올림 동작은 반올림하는 것입니다. d &amp;lt;= 0 인 경우 Round는 단조로운 클럭 판독 값에서 t를 제거하지만 달리 변경하지 않은 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd8a6768cc1684f5b293529415380ca31ee44b5b" translate="yes" xml:space="preserve">
          <source>RoundToEven</source>
          <target state="translated">RoundToEven</target>
        </trans-unit>
        <trans-unit id="721a33257fa34d285056f870605bb51c3b9a00a0" translate="yes" xml:space="preserve">
          <source>RoundToEven returns the nearest integer, rounding ties to even.</source>
          <target state="translated">RoundToEven은 가장 가까운 정수를 반올림하여 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="31fa67ead55ff94cd48d5e48d25e6ab30cbcca05" translate="yes" xml:space="preserve">
          <source>RoundTrip implements the RoundTripper interface.</source>
          <target state="translated">RoundTrip은 RoundTripper 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aef4d01bc99ecc3d07fd6dbc9d4b0127aaa57cd4" translate="yes" xml:space="preserve">
          <source>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</source>
          <target state="translated">RoundTripper는 단일 HTTP 트랜잭션을 실행하여 주어진 요청에 대한 응답을 얻는 기능을 나타내는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="14ab950eb98caa165c8e3b8a580c9eeda3c87fc0" translate="yes" xml:space="preserve">
          <source>RoundingMode</source>
          <target state="translated">RoundingMode</target>
        </trans-unit>
        <trans-unit id="e0448d85da96897c679953ae05b1d33acf337b63" translate="yes" xml:space="preserve">
          <source>RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy.</source>
          <target state="translated">RoundingMode는 Float 값이 원하는 정밀도로 반올림되는 방법을 결정합니다. 반올림은 Float 값을 변경할 수 있습니다. 반올림 오차는 Float의 정확도로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b1898ce5b72c9fe9acbd96617227555ca58001da" translate="yes" xml:space="preserve">
          <source>Row is the result of calling QueryRow to select a single row.</source>
          <target state="translated">행은 단일 행을 선택하기 위해 QueryRow를 호출 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="52d0b35277ee4b2b66ec4016620c658d99c7b57a" translate="yes" xml:space="preserve">
          <source>Rows</source>
          <target state="translated">Rows</target>
        </trans-unit>
        <trans-unit id="40bc6f7b056d7162e958bb7c34f2141aad10960f" translate="yes" xml:space="preserve">
          <source>Rows are always in order of increasing entry.Address, but entry.Line may go forward or backward.</source>
          <target state="translated">행은 항상 entry.Address를 증가시키는 순서이며, entry.Line은 앞뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136224253b0a1cede998fd8310adbf37059cd8b9" translate="yes" xml:space="preserve">
          <source>Rows is an iterator over an executed query's results.</source>
          <target state="translated">행은 실행 된 쿼리 결과에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5bf0da8d1e143c858970004b1d4e4fc2c3190c46" translate="yes" xml:space="preserve">
          <source>Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row.</source>
          <target state="translated">행은 쿼리 결과입니다. 커서는 결과 세트의 첫 번째 행보다 먼저 시작됩니다. 행을 진행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e43ca77abe23e5cf32ea7c3a359b9f55d612a0" translate="yes" xml:space="preserve">
          <source>RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows.</source>
          <target state="translated">영향을받는 행은 여러 행을 변경하는 INSERT 또는 UPDATE 작업에 대한 결과를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ef8ccf0ef3b6629b0198be9228cd5d4456951fd1" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[]BIGINT&quot;, &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</source>
          <target state="translated">RowsColumnTypeDatabaseTypeName은 Rows로 구현 될 수 있습니다. 길이가없는 데이터베이스 시스템 유형 이름을 리턴해야합니다. 유형 이름은 대문자 여야합니다. 리턴 된 유형의 예 : &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[] BIGINT&quot; , &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</target>
        </trans-unit>
        <trans-unit id="3c91b4c84603ef829584c3342618f9e341f34eef" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeLength may be implemented by Rows. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return math.MaxInt64. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypeLength는 Rows로 구현 될 수 있습니다. 열이 가변 길이 유형 인 경우 열 유형의 길이를 리턴해야합니다. 열이 가변 길이 유형이 아닌 경우 ok는 false를 리턴해야합니다. 시스템 제한 이외의 길이가 제한되지 않으면 math.MaxInt64를 반환해야합니다. 다음은 다양한 유형에 대한 리턴 값의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e25b9be843083730384947899329e16d7e8ce2ee" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeNullable may be implemented by Rows. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.</source>
          <target state="translated">RowsColumnTypeNullable은 Rows로 구현 될 수 있습니다. 널 입력 가능 값은 컬럼이 널 (null) 일 수있는 경우 true이거나 컬럼이 널 입력 가능하지 않은 경우 false입니다. 열 Null 허용 여부를 알 수없는 경우 ok는 false 여야합니다.</target>
        </trans-unit>
        <trans-unit id="11e1119cb21771faadd92c0fac63385e0fabd647" translate="yes" xml:space="preserve">
          <source>RowsColumnTypePrecisionScale may be implemented by Rows. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypePrecisionScale은 Rows로 구현 될 수 있습니다. 10 진수 유형의 정밀도와 스케일을 반환해야합니다. 해당되지 않는 경우 ok는 false 여야합니다. 다음은 다양한 유형에 대한 리턴 값의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c4ef56c355e3d98c76299376ceea4adea3479a58" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeScanType may be implemented by Rows. It should return the value type that can be used to scan types into. For example, the database column type &quot;bigint&quot; this should return &quot;reflect.TypeOf(int64(0))&quot;.</source>
          <target state="translated">RowsColumnTypeScanType은 Rows로 구현 될 수 있습니다. 유형을 스캔하는 데 사용할 수있는 값 유형을 리턴해야합니다. 예를 들어 데이터베이스 열 유형 &quot;bigint&quot;는 &quot;reflect.TypeOf (int64 (0))&quot;을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7efce4893f3ac361f87721da26fe098b878a1c27" translate="yes" xml:space="preserve">
          <source>RowsNextResultSet extends the Rows interface by providing a way to signal the driver to advance to the next result set.</source>
          <target state="translated">RowsNextResultSet는 다음 결과 세트로 진행하도록 드라이버에 신호를 보내는 방법을 제공하여 Rows 인터페이스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="1ab76c953a9e273e85fb13e73235ab1aa106b9cd" translate="yes" xml:space="preserve">
          <source>Rsh sets z = x &amp;gt;&amp;gt; n and returns z.</source>
          <target state="translated">Rsh는 z = x &amp;gt;&amp;gt; n을 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="64578d8b2d51c5abcc22005302c8d44dd6d930ad" translate="yes" xml:space="preserve">
          <source>Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.</source>
          <target state="translated">주어진 이름으로 하위 벤치 마크로 벤치 마크 f를 실행하십시오. 실패가 있었는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="872b6e9fc5c925d028b4808b5136d4cf35164f22" translate="yes" xml:space="preserve">
          <source>Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:</source>
          <target state="translated">병렬 하위 테스트가 완료 될 때까지 실행이 반환되지 않으므로 병렬 테스트 그룹 후에 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c556db4b76966a7511e9f2b360cd616f36f626" translate="yes" xml:space="preserve">
          <source>Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns.</source>
          <target state="translated">Run은 여러 고 루틴에서 동시에 호출 될 수 있지만 t와 같은 외부 호출 함수 전에 이러한 모든 호출을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d90bfc177fd90c93bbd1a663aa066ee65d25e1b1" translate="yes" xml:space="preserve">
          <source>Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).</source>
          <target state="translated">run은 f라는 t의 하위 테스트로 f를 실행합니다. 그것은 별도의 고 루틴에서 f를 실행하고 f가 t.Parallel을 호출하거나 병렬 테스트가 될 때까지 차단합니다. f가 성공했는지 (또는 적어도 t.Parallel을 호출하기 전에 실패하지 않았는지)보고합니다.</target>
        </trans-unit>
        <trans-unit id="53e0451894d3b3781ea079b9077c47afbf558128" translate="yes" xml:space="preserve">
          <source>Run runs the tests. It returns an exit code to pass to os.Exit.</source>
          <target state="translated">실행은 테스트를 실행합니다. os.Exit에 전달할 종료 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="48c893a581570ffe26dfe952410c12f6cdc2e260" translate="yes" xml:space="preserve">
          <source>Run starts the specified command and waits for it to complete.</source>
          <target state="translated">실행은 지정된 명령을 시작하고 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="452df5dd646b599a67dd36e4b5527c206ddf15e5" translate="yes" xml:space="preserve">
          <source>RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.</source>
          <target state="translated">RunParallel은 벤치 마크를 병렬로 실행합니다. 여러 고 루틴을 생성하고 이들 사이에 bN 반복을 분산시킵니다. 고 루틴의 수는 기본적으로 GOMAXPROCS입니다. 비 CPU 바인딩 벤치 마크에 대한 병렬 처리를 늘리려면 RunParallel 전에 SetParallelism을 호출하십시오. RunParallel은 일반적으로 go test -cpu 플래그와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1304d4ae46895f99bd865fe49bce5376fb7e0b6" translate="yes" xml:space="preserve">
          <source>RuneCount</source>
          <target state="translated">RuneCount</target>
        </trans-unit>
        <trans-unit id="ed1038ffbfe375ac70c3f1a1ca67f29234afffbf" translate="yes" xml:space="preserve">
          <source>RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.</source>
          <target state="translated">RuneCount는 p의 룬 수를 반환합니다. 잘못되고 짧은 인코딩은 너비가 1 바이트 인 단일 룬으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="78c4e1dde9ab6b8f5586f9612a115ee5d698d2fb" translate="yes" xml:space="preserve">
          <source>RuneCountInString</source>
          <target state="translated">RuneCountInString</target>
        </trans-unit>
        <trans-unit id="f740d84fa32707ddc183ab07c7c8f221a896cf18" translate="yes" xml:space="preserve">
          <source>RuneCountInString is like RuneCount but its input is a string.</source>
          <target state="translated">RuneCountInString은 RuneCount와 유사하지만 입력은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7f39387ee01e0d6561f94fb1cc196d068d979052" translate="yes" xml:space="preserve">
          <source>RuneLen</source>
          <target state="translated">RuneLen</target>
        </trans-unit>
        <trans-unit id="da827d364b8d785022152482b581a5b08129882b" translate="yes" xml:space="preserve">
          <source>RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.</source>
          <target state="translated">RuneLen은 룬을 인코딩하는 데 필요한 바이트 수를 반환합니다. 룬이 UTF-8로 인코딩하기에 유효한 값이 아닌 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf36c219da8d056dc79efd005cdbeaf40198de2a" translate="yes" xml:space="preserve">
          <source>RuneReader is the interface that wraps the ReadRune method.</source>
          <target state="translated">RuneReader는 ReadRune 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8dce52bc0fa438508ccfe7940691e478794d8014" translate="yes" xml:space="preserve">
          <source>RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.</source>
          <target state="translated">RuneScanner는 UnreadRune 메소드를 기본 ReadRune 메소드에 추가하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="48c879258018813f4ec13050feaaab65a67d910b" translate="yes" xml:space="preserve">
          <source>RuneStart</source>
          <target state="translated">RuneStart</target>
        </trans-unit>
        <trans-unit id="6b79de7db8117808de36133366c8ef414e9c5c82" translate="yes" xml:space="preserve">
          <source>RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.</source>
          <target state="translated">RuneStart는 바이트가 인코딩 된 유효하지 않은 룬의 첫 번째 바이트 일 수 있는지보고합니다. 두 번째 및 이후 바이트는 항상 상위 2 비트가 10으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6756bd3e1a442e2ce0d16a235b1d5c8c2882b1e6" translate="yes" xml:space="preserve">
          <source>Runes</source>
          <target state="translated">Runes</target>
        </trans-unit>
        <trans-unit id="9a62b7b5f90f9e424bb04160b8de2eb558ee92a9" translate="yes" xml:space="preserve">
          <source>Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.</source>
          <target state="translated">Runes는 s를 일련의 UTF-8 인코딩 코드 포인트로 해석합니다. s에 해당하는 룬 조각 (유니 코드 코드 포인트)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5d45a3fe840544aad462798c4e4ed8942f7ef58" translate="yes" xml:space="preserve">
          <source>Running &quot;go vet&quot; can help find uses of Pointer that do not conform to these patterns, but silence from &quot;go vet&quot; is not a guarantee that the code is valid.</source>
          <target state="translated">&quot;go vet&quot;을 실행하면 이러한 패턴에 맞지 않는 포인터 사용을 찾는 데 도움이되지만 &quot;go vet&quot;의 침묵은 코드가 유효하다는 것을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeacdbd801cd3a6c88be9cbc91df0dca2b46aba8" translate="yes" xml:space="preserve">
          <source>SHA-1 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">SHA-1은 암호화 방식으로 손상되어 보안 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7b3caa78fa594eb19ef5d1955f9e6f4a06aac1d4" translate="yes" xml:space="preserve">
          <source>SIGPIPE</source>
          <target state="translated">SIGPIPE</target>
        </trans-unit>
        <trans-unit id="91d8535876524df724c0df972b3fd914eb03fb2f" translate="yes" xml:space="preserve">
          <source>SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.</source>
          <target state="translated">SameFile은 fi1과 fi2가 동일한 파일을 설명하는지 여부를보고합니다. 예를 들어, Unix에서 이것은 두 기본 구조의 디바이스와 inode 필드가 동일하다는 것을 의미합니다. 다른 시스템에서는 결정이 경로 이름을 기반으로 할 수 있습니다. SameFile은이 패키지의 Stat에 의해 반환 된 결과에만 적용됩니다. 다른 경우에는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f57e34c6960ba52fd743b2bc0ff1557eb707bd2" translate="yes" xml:space="preserve">
          <source>SameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.</source>
          <target state="translated">SameSite를 사용하면 서버가 쿠키 속성을 정의하여 브라우저가 사이트 간 요청과 함께이 쿠키를 보낼 수 없습니다. 주요 목표는 출처 간 정보 유출 위험을 완화하고 사이트 간 요청 위조 공격에 대한 보호 기능을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b8abf172daab8b3ea3c6865151b033d1cd5e837c" translate="yes" xml:space="preserve">
          <source>Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set.</source>
          <target state="translated">스캔은 Init으로 설정된 파일에 추가 된 파일에 행 정보를 추가합니다. 토큰 위치는 해당 파일을 기준으로하므로 파일 세트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="e4ac4597c96634ebcbf4b7a158793f756f373f9c" translate="yes" xml:space="preserve">
          <source>Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.</source>
          <target state="translated">스캔은 스캐너를 다음 토큰으로 진행 한 다음 바이트 또는 텍스트 방법을 통해 사용할 수 있습니다. 입력이 끝나거나 오류가 발생하여 스캔이 중지되면 false를 반환합니다. Scan이 false를 반환하면 Err 메서드는 io.EOF 인 경우 Err이 nil을 반환한다는 점을 제외하고 검색 중에 발생한 오류를 반환합니다. split 함수가 입력을 진행하지 않고 빈 토큰을 너무 많이 반환하면 패닉을 스캔하십시오. 스캐너의 일반적인 오류 모드입니다.</target>
        </trans-unit>
        <trans-unit id="19b1c6ecbd861a4833fc5e32bbb8df547210090f" translate="yes" xml:space="preserve">
          <source>Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value &quot;300&quot; can scan into a uint16, but not into a uint8, though float64(255) or &quot;255&quot; can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64.</source>
          <target state="translated">또한 정보가 손실되지 않는 한 스캔은 문자열과 숫자 유형 사이를 변환합니다. 스캔은 숫자 데이터베이스 열에서 스캔 된 모든 숫자를 * 문자열로 문자열 화하는 반면 숫자 유형으로 스캔하면 오버 플로우를 검사합니다. 예를 들어, 값이 300 인 float64 또는 값이 &quot;300&quot;인 문자열은 uint16으로 스캔 할 수 있지만 uint8로는 스캔 할 수 없지만 float64 (255) 또는 &quot;255&quot;는 uint8로 스캔 할 수 있습니다. 한 가지 예외는 문자열로 일부 float64 숫자를 스캔하면 스트링화할 때 정보가 유실 될 수 있다는 것입니다. 일반적으로 부동 소수점 열을 * float64로 스캔하십시오.</target>
        </trans-unit>
        <trans-unit id="feb542d2e67b91b0880c1fd1b4cf7b50af77bd5b" translate="yes" xml:space="preserve">
          <source>Scan can also convert a cursor returned from a query, such as &quot;select cursor(select * from my_table) from dual&quot;, into a *Rows value that can itself be scanned from. The parent select query will close any cursor *Rows if the parent *Rows is closed.</source>
          <target state="translated">스캔은 또한 쿼리에서 리턴 된 커서 (예 : &quot;select cursor (select * from my_table) from dual&quot;)를 자체적으로 스캔 할 수있는 * Rows 값으로 변환 할 수 있습니다. 부모 * 행이 닫히면 부모 선택 쿼리는 커서 * 행을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="48ec4d9dec15d05d875f1baa84e9dcd1d7cc9f07" translate="yes" xml:space="preserve">
          <source>Scan converts columns read from the database into the following common Go types and special types provided by the sql package:</source>
          <target state="translated">스캔은 데이터베이스에서 읽은 열을 sql 패키지에서 제공하는 다음 공통 Go 유형 및 특수 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2677a1f2dd5662fd0ec43cba40359a57293f1867" translate="yes" xml:space="preserve">
          <source>Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.</source>
          <target state="translated">Scan은 일치하는 행의 열을 dest가 가리키는 값으로 복사합니다. 자세한 내용은 Rows.Scan 설명서를 참조하십시오. 둘 이상의 행이 쿼리와 일치하면 Scan은 첫 번째 행을 사용하고 나머지는 버립니다. 쿼리와 일치하는 행이 없으면 Scan은 ErrNoRows를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d701545494296850286215953fde0ddf540061d1" translate="yes" xml:space="preserve">
          <source>Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.</source>
          <target state="translated">Scan은 현재 행의 열을 dest가 가리키는 값으로 복사합니다. dest의 값 수는 행의 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a799e57e8d283a9aa1ec133950cd6bd3e127332" translate="yes" xml:space="preserve">
          <source>Scan implements the Scanner interface.</source>
          <target state="translated">스캔은 스캐너 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bd92cac731a36521f9119e135b2c47485aabb150" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. 'e', 'E', 'f', 'F', 'g', 'G'및 'v'형식을 허용합니다. 모든 형식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d953d557a4046bfc8df6c55ce44c304f6ff14a59" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle &amp;plusmn;Inf.</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. z를 스캔 된 숫자 값으로 설정합니다. fmt.에서 동사를 지원하는 형식을 허용합니다. 'b'(이진), 'e', ​​'E', 'f', 'F', 'g'및 'G'와 같은 부동 소수점 값을 스캔합니다. 스캔이 &amp;plusmn; Inf를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac6efbbbf8b516bb14977cb03cef43746936b2f5" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).</source>
          <target state="translated">스캔은 fmt.Scanner 지원 루틴입니다. z를 스캔 된 숫자 값으로 설정합니다. 'b'(2 진), 'o'(8 진), 'd'(10 진), 'x'(16 진 소문자) 및 'X'(16 진 대문자) 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="386a7678b7de663dffac69cf7ab3e1a7092be8f9" translate="yes" xml:space="preserve">
          <source>Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1&amp;lt;&amp;lt;-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr.</source>
          <target state="translated">스캔은 소스에서 다음 토큰 또는 유니 코드 문자를 읽고 리턴합니다. 각 모드 비트 (1 &amp;lt;&amp;lt;-t)가 설정된 토큰 t 만 인식합니다. 소스의 끝에 EOF를 리턴합니다. nil이 아닌 경우 s.Error를 호출하여 스캐너 오류 (읽기 및 토큰 오류)를보고합니다. 그렇지 않으면 오류 메시지를 os.Stderr에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="981608b22833d116739df1bad639bfec043f4338" translate="yes" xml:space="preserve">
          <source>Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">스캔은 표준 입력에서 읽은 텍스트를 스캔하여 연속 공백으로 구분 된 값을 연속 인수에 저장합니다. 줄 바꿈은 공백으로 계산됩니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9421db6432c3608ab7d6333584635bf58a2d9300" translate="yes" xml:space="preserve">
          <source>Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by token.EOF.</source>
          <target state="translated">스캔은 다음 토큰을 스캔하고 해당되는 경우 토큰 위치, 토큰 및 리터럴 문자열을 리턴합니다. 소스 엔드는 token.EOF로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3d5e9556bfff0957b67d0485be76ef988e69293" translate="yes" xml:space="preserve">
          <source>Scan, Fscan, Sscan treat newlines in the input as spaces.</source>
          <target state="translated">스캔, Fscan, Sscan은 입력의 개행을 공백으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f2ef262aa067e44dfcde945e7bebf0433b1baaed" translate="yes" xml:space="preserve">
          <source>ScanBytes is a split function for a Scanner that returns each byte as a token.</source>
          <target state="translated">ScanBytes는 각 바이트를 토큰으로 반환하는 스캐너의 분할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d509b35e48ef6a5d396ee01678b179a959774867" translate="yes" xml:space="preserve">
          <source>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline.</source>
          <target state="translated">ScanLines는 스캐너의 분할 기능으로, 모든 텍스트 줄을 반환하여 줄 끝 마커를 제거합니다. 반환 된 줄이 비어있을 수 있습니다. 줄 끝 마커는 하나의 선택적인 캐리지 리턴과 하나의 필수 개행입니다. 정규 표현식 표기법에서는`\ r? \ n`입니다. 비어 있지 않은 마지막 입력 줄은 줄 바꿈이 없어도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b4049bc82d2e16ae520fd9c175cc98d3e8214592" translate="yes" xml:space="preserve">
          <source>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;. Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.</source>
          <target state="translated">ScanRunes는 UTF-8로 인코딩 된 각 룬을 토큰으로 반환하는 검사기의 분할 기능입니다. 리턴 된 룬 순서는 입력에 대한 범위 루프에서 문자열로 표시되는 순서와 동일합니다. 이는 잘못된 UTF-8 인코딩이 U + FFFD = &quot;\ xef \ xbf \ xbd&quot;로 변환됨을 의미합니다. 스캔 인터페이스로 인해 클라이언트가 인코딩 된 대체 룬을 인코딩 오류와 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4641d488fdcb83f61b3c11fd542f4c6a3c4ffa5" translate="yes" xml:space="preserve">
          <source>ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.</source>
          <target state="translated">ScanState는 사용자 정의 스캐너로 전달 된 스캐너 상태를 나타냅니다. 스캐너는 한 번에 한 번씩 스캔을 수행하거나 ScanState에 다음으로 구분 된 토큰을 찾도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59161b57fccdcbdd902cc6d57c2979e0dc44f79e" translate="yes" xml:space="preserve">
          <source>ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface.</source>
          <target state="translated">ScanType은 Rows.Scan을 사용하여 스캔하기에 적합한 Go 유형을 반환합니다. 드라이버가이 속성을 지원하지 않으면 ScanType은 빈 인터페이스의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="faa25d7e517bfa0b7ebed36b40faf73e8faf8ace" translate="yes" xml:space="preserve">
          <source>ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.</source>
          <target state="translated">ScanWords는 스캐너를위한 분할 기능으로, 공백으로 구분 된 각 단어를 반환하고 주변 공백은 삭제합니다. 빈 문자열을 반환하지 않습니다. 공간 정의는 unicode.IsSpace로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0d545831527f222a939e3851bf7f5c1605d659" translate="yes" xml:space="preserve">
          <source>Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.</source>
          <target state="translated">Scanf는 표준 입력에서 읽은 텍스트를 스캔하여 형식으로 결정된 연속 공백으로 구분 된 값을 연속 인수로 저장합니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다. 입력의 개행은 형식의 개행과 일치해야합니다. 한 가지 예외 : 동사 % c는 공백 (또는 탭 등) 또는 줄 바꿈 인 경우에도 입력에서 다음 룬을 항상 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="6f640beb056a4e8e9aa6bfcd8d1f5bf1b4feaaee" translate="yes" xml:space="preserve">
          <source>Scanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.</source>
          <target state="translated">Scanf, Fscanf 및 Sscanf는 Printf와 유사한 형식 문자열에 따라 인수를 구문 분석합니다. 다음 텍스트에서 'space'는 줄 바꿈을 제외한 모든 유니 코드 공백 문자를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8ed7e72e9070ffbdd1df56f018a211791f2dcc9" translate="yes" xml:space="preserve">
          <source>Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Scanln은 스캔과 비슷하지만 줄 바꿈에서 스캔을 중지하며 마지막 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="22a932411390fa7368633b6d040508332e0196e9" translate="yes" xml:space="preserve">
          <source>Scanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.</source>
          <target state="translated">Scanln, Fscanln 및 Sscanln은 줄 바꿈에서 스캔을 중지하고 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="01c8580ef4911b472b2f5804014f5bd82d1af7aa" translate="yes" xml:space="preserve">
          <source>Scanner (Custom)</source>
          <target state="translated">스캐너 (사용자 정의)</target>
        </trans-unit>
        <trans-unit id="1d4892a40553aaa21bb91693fe76c51b9f51e530" translate="yes" xml:space="preserve">
          <source>Scanner (EmptyFinalToken)</source>
          <target state="translated">스캐너 (EmptyFinalToken)</target>
        </trans-unit>
        <trans-unit id="d1ca38099d8459b3cc3f6b48eaf9fc6b340ae9b4" translate="yes" xml:space="preserve">
          <source>Scanner (Lines)</source>
          <target state="translated">스캐너 (라인)</target>
        </trans-unit>
        <trans-unit id="ab67b93c24c839ac0830f79b29ad7b412a9dc7b4" translate="yes" xml:space="preserve">
          <source>Scanner (Words)</source>
          <target state="translated">스캐너 (워드)</target>
        </trans-unit>
        <trans-unit id="2192924325d3946492271abc8671373e1f38daa1" translate="yes" xml:space="preserve">
          <source>Scanner is an interface used by Scan.</source>
          <target state="translated">스캐너는 스캔에서 사용되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="16f1f8a9cae9f1e07478a7953ec158b0c2b03d9c" translate="yes" xml:space="preserve">
          <source>Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.</source>
          <target state="translated">스캐너는 Scan 메서드가있는 값으로 구현됩니다.이 메서드는 값 표현을 위해 입력을 스캔하고 결과를 수신기에 저장합니다. 이는 유용한 포인터 여야합니다. Scan 메서드는 Scan, Scanf 또는 Scanln을 구현하는 모든 인수에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="76f47cb3079e4595ce1c03abbd158345ae636c90" translate="yes" xml:space="preserve">
          <source>Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.</source>
          <target state="translated">스캐너는 줄 바꿈으로 구분 된 텍스트 줄과 같은 데이터를 읽기위한 편리한 인터페이스를 제공합니다. Scan 메서드에 대한 연속적인 호출은 파일의 '토큰'을 단계별로 실행하여 토큰 사이의 바이트를 건너 뜁니다. 토큰의 사양은 SplitFunc 유형의 split 함수로 정의됩니다. 기본 스플릿 기능은 라인 터미네이션이 제거 된 라인으로 입력을 분리합니다. 이 패키지에는 파일을 행, 바이트, UTF-8로 인코딩 된 룬 및 공백으로 구분 된 단어로 스캔하기위한 분할 기능이 정의되어 있습니다. 클라이언트는 대신 사용자 정의 스플릿 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221c21d253261d097c5eddd34e07f0e854f9f8be" translate="yes" xml:space="preserve">
          <source>Scanner.Bytes</source>
          <target state="translated">Scanner.Bytes</target>
        </trans-unit>
        <trans-unit id="db2650dfa50b9653ed3b24b83e400aa246e21e57" translate="yes" xml:space="preserve">
          <source>Scanner.Scan</source>
          <target state="translated">Scanner.Scan</target>
        </trans-unit>
        <trans-unit id="e230f66cb2480e61c70e7940e1168e3d3dc1b2cf" translate="yes" xml:space="preserve">
          <source>Scanning</source>
          <target state="translated">Scanning</target>
        </trans-unit>
        <trans-unit id="0e43a71fd5dc304b08b8c37610739914b52545a4" translate="yes" xml:space="preserve">
          <source>Scanning stops if the function returns an error, in which case some of the input may be discarded.</source>
          <target state="translated">함수가 오류를 반환하면 스캔이 중지되며이 경우 일부 입력이 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3672319a15266023841ffc344b2b9ae68437119" translate="yes" xml:space="preserve">
          <source>Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.</source>
          <target state="translated">EOF, 첫 번째 I / O 오류 또는 버퍼에 비해 너무 큰 토큰에서 스캔이 복구 불가능하게 중지됩니다. 스캔이 중지되면 리더가 마지막 토큰을 지나쳐 임의로 이동했을 수 있습니다. 오류 처리 또는 큰 토큰에 대해 더 많은 제어가 필요하거나 리더에서 순차적 스캔을 실행해야하는 프로그램은 bufio.Reader를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="2ebfb1a9903c43a33373f64197eeaf8911c9f134" translate="yes" xml:space="preserve">
          <source>Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs).</source>
          <target state="translated">Scope는 패키지 수준에서 선언 된 객체 (TypeNames, Consts, Vars 및 Funcs)를 포함하는 (완전 또는 불완전) 패키지 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f31d3986ec66463fe9a83dfd9a2accc1b70877c7" translate="yes" xml:space="preserve">
          <source>Scope returns the scope of the function's body block.</source>
          <target state="translated">범위는 함수 본문 블록의 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="caf135bc624d4b0feb9650ec0d00441eafcdc77d" translate="yes" xml:space="preserve">
          <source>Scripts is the set of Unicode script tables.</source>
          <target state="translated">스크립트는 유니 코드 스크립트 테이블 세트입니다.</target>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f3e40d362f51c406a8e1778fc061f0dd3ad57de4" translate="yes" xml:space="preserve">
          <source>Search (DescendingOrder)</source>
          <target state="translated">검색 (내림차순)</target>
        </trans-unit>
        <trans-unit id="fdbb604a543d329419799366cc3a9af7390d3bcf" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchFloat64s to the receiver and x.</source>
          <target state="translated">검색은 SearchFloat64를 수신기와 x에 적용한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ab6c8f0fd768a91b3e79c036cb01cc452193fe2" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchInts to the receiver and x.</source>
          <target state="translated">검색은 SearchInts를 수신자와 x에 적용한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c4f638fca65e5a738654ac393880f806f3b7f65" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchStrings to the receiver and x.</source>
          <target state="translated">검색은 SearchStrings를 수신자와 x에 적용한 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="794b977a863a1d9dc8d7b0fd80d6eef6736bd69e" translate="yes" xml:space="preserve">
          <source>Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the &quot;not found&quot; return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).</source>
          <target state="translated">검색은 이진 검색을 사용하여 [0, n) 범위에서 f (i) == true 인 경우 f (i + 1) == 참. 즉, 검색에서는 입력 범위 [0, n)의 일부 (비어있을 수있는) 접두어에 대해 f가 false이고 나머지 (비어있을 수 있음) 나머지에 대해서는 true가되어야합니다. 검색은 첫 번째 실제 인덱스를 반환합니다. 그러한 색인이 없으면 검색은 n을 리턴합니다. &quot;찾을 수 없음&quot;반환 값은 예를 들어 strings.Index와 같이 -1이 아닙니다. 검색은 [0, n) 범위의 i에 대해서만 f (i)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="895f11590a6ed175f7bac01b38c2ec5640f6fc28" translate="yes" xml:space="preserve">
          <source>SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchFloat64s는 정렬 된 float64 조각에서 x를 검색하고 검색에 지정된대로 색인을 리턴합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="b48f643546b25f6e6918e845a0e8a3ab0175ad09" translate="yes" xml:space="preserve">
          <source>SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchInts는 정렬 된 int 슬라이스에서 x를 검색하고 Search에 지정된 인덱스를 반환합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed762c6e866455b20a9bc0ff477d563626862413" translate="yes" xml:space="preserve">
          <source>SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchStrings는 정렬 된 문자열 조각에서 x를 검색하고 검색에 지정된대로 색인을 리턴합니다. 반환 값은 x가 없으면 x를 삽입하는 인덱스입니다 (len (a) 일 수 있음). 슬라이스는 오름차순으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1110c735a627c55e67957485addfcd1740c3fa1" translate="yes" xml:space="preserve">
          <source>Searching data sorted in descending order would use the &amp;lt;= operator instead of the &amp;gt;= operator.</source>
          <target state="translated">내림차순으로 정렬 된 데이터를 검색하면&amp;gt; = 연산자 대신 &amp;lt;= 연산자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0feecc756efff0f52e43fa2ad18e92887874359a" translate="yes" xml:space="preserve">
          <source>Second returns the second offset within the minute specified by t, in the range [0, 59].</source>
          <target state="translated">Second는 t로 지정된 분 내에서 [0, 59] 범위에서 두 번째 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aec1eca3aa532659c858922be555e4b78f91472b" translate="yes" xml:space="preserve">
          <source>Seconds returns the duration as a floating point number of seconds.</source>
          <target state="translated">초는 지속 시간을 부동 소수점 수 (초)로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="883d7225a5feea9c004792c2e5762e5e8b90b937" translate="yes" xml:space="preserve">
          <source>Section compression type.</source>
          <target state="translated">섹션 압축 유형.</target>
        </trans-unit>
        <trans-unit id="23c76af95b6f5d08de2ecfd9a9b5758fd241b4b6" translate="yes" xml:space="preserve">
          <source>Section flags.</source>
          <target state="translated">섹션 플래그.</target>
        </trans-unit>
        <trans-unit id="62f89d87896d7ef06a64cbb776d3fd356378e295" translate="yes" xml:space="preserve">
          <source>Section provides access to PE COFF section.</source>
          <target state="translated">섹션은 PE COFF 섹션에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a9d0e16d038258c30fb66c2551ff2e94b6e8ab2" translate="yes" xml:space="preserve">
          <source>Section returns a section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section은 주어진 이름의 섹션을 반환하거나 해당 섹션이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc54ab0b090fa88e8cee7f8d9e554c227fd11b85" translate="yes" xml:space="preserve">
          <source>Section returns the first section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section은 주어진 이름의 첫 번째 섹션을 반환하거나, 해당 섹션이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8743382bf5087384ab8d5b7b47a198bf1c224282" translate="yes" xml:space="preserve">
          <source>Section type.</source>
          <target state="translated">섹션 유형.</target>
        </trans-unit>
        <trans-unit id="d498edd9cfc2fe612ccd52dd5a6b59dfb6cad8e5" translate="yes" xml:space="preserve">
          <source>SectionByType returns the first section in f with the given type, or nil if there is no such section.</source>
          <target state="translated">SectionByType은 주어진 유형을 가진 f의 첫 번째 섹션을 리턴하거나 해당 섹션이없는 경우 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dbabe3978d24b41c968a7e3b657294f716964e11" translate="yes" xml:space="preserve">
          <source>SectionHeader is similar to SectionHeader32 with Name field replaced by Go string.</source>
          <target state="translated">SectionHeader는 이름 필드가 Go 문자열로 대체 된 SectionHeader32와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="236a39825c17abffb62d175c97b2ff1d1ddf6257" translate="yes" xml:space="preserve">
          <source>SectionHeader32 represents real PE COFF section header.</source>
          <target state="translated">SectionHeader32는 실제 PE COFF 섹션 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36fac8b648a8b963f174eff7d8e38ad8b061b47f" translate="yes" xml:space="preserve">
          <source>SectionReader</source>
          <target state="translated">SectionReader</target>
        </trans-unit>
        <trans-unit id="7c71d38d1e94fa11b5d9d25b519a23c96d399f77" translate="yes" xml:space="preserve">
          <source>SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.</source>
          <target state="translated">SectionReader는 기본 ReaderAt의 섹션에서 Read, Seek 및 ReadAt를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="559bf9fc1a7e8d17f180e11f63d09376be0206a5" translate="yes" xml:space="preserve">
          <source>SectionReader.ReadAt</source>
          <target state="translated">SectionReader.ReadAt</target>
        </trans-unit>
        <trans-unit id="665de6075b0f11336eab3dd46baf160774a5a70d" translate="yes" xml:space="preserve">
          <source>SectionReader.Seek</source>
          <target state="translated">SectionReader.Seek</target>
        </trans-unit>
        <trans-unit id="0f309ea1521bd5ca8e406b86f34f3a7a0ebff642" translate="yes" xml:space="preserve">
          <source>Security Model</source>
          <target state="translated">보안 모델</target>
        </trans-unit>
        <trans-unit id="01953de86431ce77344577ae5495196d927df9a0" translate="yes" xml:space="preserve">
          <source>See &quot;Gobs of data&quot; for a design discussion of the gob wire format: &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</source>
          <target state="translated">gob 와이어 형식에 대한 설계 토론은 &quot;데이터의 gobs&quot;를 참조하십시오. &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3774cda758049661070b6c5a6625f40ce94f1003" translate="yes" xml:space="preserve">
          <source>See &quot;JSON and Go&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</source>
          <target state="translated">이 패키지에 대한 소개는 &quot;JSON and Go&quot;를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2434441ee0019a17c985accfc44984c0fc83f78c" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image package&quot; for more details: &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &quot;Go 이미지 패키지&quot;를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5ff28b5d6f4a465abbce4a3d8096187a236d24e" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image/draw package&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https://golang.org/doc/articles/image_draw.html&lt;/a&gt;</source>
          <target state="translated">이 패키지에 대한 소개는 &quot;Go 이미지 / 그리기 패키지&quot;를 &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;참조하십시오&lt;/a&gt; : https://golang.org/doc/articles/image_draw.html</target>
        </trans-unit>
        <trans-unit id="f837700d9a3417d92fc3f9f0548fd849b9aa7119" translate="yes" xml:space="preserve">
          <source>See &quot;The Laws of Reflection&quot; for an introduction to reflection in Go: &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</source>
          <target state="translated">Go의 리플렉션에 대한 소개는 &quot;리플렉션 법칙&quot;을 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd38865133cd9a5c006edfe52fb23197b681651e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; for example code for a server that uses Contexts.</source>
          <target state="translated">컨텍스트를 사용하는 서버의 코드 예제는 &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8fa4b86ca7a1947812b5144ad80bb7923b98b76" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; for more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="55fd6381c1e6f556a9d9a122b9ddab024cd5623c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b6207cb402edce8d859bdca9debb6fc32598a7f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; for information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="822defb6e38c1c8b51e3bd857cd8e75be7930a08" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="012d19a411e4e0484271ae09bcb7f34da4a9a591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; for an unofficial mirror of the original documentation.</source>
          <target state="translated">원본 문서의 비공식 미러는 &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c591b3698d1803b8997f519f5ea5ff42b510cd7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe2d422131406c7b8b8363b0278a5d60f19e086" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfeb891e01c83428f5fff33780366881bea259da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; and &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; 및 &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b12c5bb65217a01227ad162d33c3fed71b0401c9" translate="yes" xml:space="preserve">
          <source>See MarshalIndent for an example.</source>
          <target state="translated">예를 들어 MarshalIndent를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a1e97ca1a62398cd193e09c77540d6a3a116112" translate="yes" xml:space="preserve">
          <source>See also &amp;ldquo;A Layman's Guide to a Subset of ASN.1, BER, and DER,&amp;rdquo; &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;ASN.1, BER 및 DER의 하위 집합에 대한 Layman 's Guide&amp;rdquo;( &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html)도 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f35fe0b7c2e4d6b79cc655771a00378e8038d6ad" translate="yes" xml:space="preserve">
          <source>See also Rob Pike, &amp;ldquo;Lexical File Names in Plan 9 or Getting Dot-Dot Right,&amp;rdquo; &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</source>
          <target state="translated">Rob Pike,&amp;ldquo;계획 9의 성명 파일 이름 또는 올바른 점 찍기&amp;rdquo; &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c57c543e703b305eac0e44a135198463dbeead16" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the host and port parameters.</source>
          <target state="translated">호스트 및 포트 매개 변수에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9538b240ebef42fb9902c82f39f4d8fe015d462" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the hostport parameter, and host and port results.</source>
          <target state="translated">hostport 매개 변수 및 호스트 및 포트 결과에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f55bd52960d8a9b74f8c169b63b303f83068df0d" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func Dial을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27af5de3a2347f6faceaa84c4b1f14ae1dbd0c9d" translate="yes" xml:space="preserve">
          <source>See func Listen for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func Listen을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6b3dee4908b79bcc47570b27eb5ceec2a78402" translate="yes" xml:space="preserve">
          <source>See func ListenPacket for a description of the network and address parameters.</source>
          <target state="translated">네트워크 및 주소 매개 변수에 대한 설명은 func ListenPacket을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4f4bb8708490d77806cbbb7379b205b4ed91be" translate="yes" xml:space="preserve">
          <source>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.</source>
          <target state="translated">JavaScript 컨텍스트에 포함하기 위해 문자열이 아닌 컨텐츠를 마샬링하는 방법을 이해하려면 패키지 json을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e66c2f2a3fcd4dca444d07ce7d1a4b916782623" translate="yes" xml:space="preserve">
          <source>See page 36 of RFC 959 (&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;) for details of another form of response accepted:</source>
          <target state="translated">허용되는 다른 형태의 응답에 대한 자세한 내용 은 RFC 959 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt; )의 36 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89753a3f5bb64713c93e9dd202de0a7448a21cee" translate="yes" xml:space="preserve">
          <source>See the Client.Do method documentation for details on how redirects are handled.</source>
          <target state="translated">리디렉션 처리 방법에 대한 자세한 내용은 Client.Do 메서드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca6b0bd4889c5a06e76626f48ec79733e1fde8b5" translate="yes" xml:space="preserve">
          <source>See the Decoder.Strict and Decoder.Entity fields' documentation.</source>
          <target state="translated">Decoder.Strict 및 Decoder.Entity 필드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69633a7324ac73d11db8887864a0a74fd2f5588f" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to JSON.</source>
          <target state="translated">Go 값을 JSON으로 변환하는 방법에 대한 자세한 내용은 Marshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45c89cab840adb83eec8d88d66bfe51744007d64" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to XML.</source>
          <target state="translated">Go 값을 XML로 변환하는 방법에 대한 자세한 내용은 Marshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6ad8d64ce7abf48e48759b114cf5bbde1ec1217" translate="yes" xml:space="preserve">
          <source>See the documentation for Reader's DotReader method for details about dot-encoding.</source>
          <target state="translated">도트 인코딩에 대한 자세한 내용은 Reader의 DotReader 방법 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07bb2782143cae54efbc20f97e601c6258fdfa3a" translate="yes" xml:space="preserve">
          <source>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</source>
          <target state="translated">JSON을 Go 값으로 변환하는 방법에 대한 자세한 내용은 Unmarshal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b7d9e398b9767ef1472ee8144b5fcbf7154f428" translate="yes" xml:space="preserve">
          <source>See the documentation for the DotReader method for details about dot-encoding.</source>
          <target state="translated">도트 인코딩에 대한 자세한 내용은 DotReader 메서드 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20a56feb05a514c49115ca9854f4e8b6ab081007" translate="yes" xml:space="preserve">
          <source>See the documentation of ErrorCode for details.</source>
          <target state="translated">자세한 내용은 ErrorCode 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="130b144345eef54088939126445f2041356e9967" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details about all of the debug endpoints installed by this import.</source>
          <target state="translated">이 가져 오기로 설치된 모든 디버그 엔드 포인트에 대한 자세한 내용은 net / http / pprof 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ea13af2c476fd8c34b53410467a8c4eec967244" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details.</source>
          <target state="translated">자세한 내용은 net / http / pprof 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d95f74a97d247876324f75dbbfb30fd3fdf53de6" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="421cab07939e4ef921a875d22fec2c50b6b26cc4" translate="yes" xml:space="preserve">
          <source>Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">Seed는 priv에 해당하는 개인 키 시드를 반환합니다. RFC 8032와의 상호 운용성을 위해 제공됩니다. RFC 8032의 개인 키는이 패키지의 시드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a2daea0c21550e6b91614c2942780e2e38582d89" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Seed는 제공된 seed 값을 사용하여 기본 소스를 결정적 상태로 초기화합니다. Seed가 호출되지 않으면 생성기는 Seed (1)에 의해 시드 된 것처럼 동작합니다. 2 ^ 31-1로 나눈 나머지가 동일한 시드 값은 동일한 의사 랜덤 시퀀스를 생성합니다. Rand.Seed 방법과 달리 씨앗은 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="06599ffd87d9ecfcc5955a8a8f6f2e80af71b779" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.</source>
          <target state="translated">Seed는 제공된 seed 값을 사용하여 생성기를 결정적 상태로 초기화합니다. 다른 Rand 메소드와 동시에 Seed를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="63eada0c1ee90c191cced8ff6a478d23ec01c7bb" translate="yes" xml:space="preserve">
          <source>Seek implements the io.Seeker interface.</source>
          <target state="translated">Seek는 io.Seeker 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="410f9d629b5b2020b5303452364dec83676d0a30" translate="yes" xml:space="preserve">
          <source>Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.</source>
          <target state="translated">찾기는 인코딩 된 입력 스트림에서 판독기를 오프셋으로 끕니다. 첫 번째 항목을 나타 내기 위해 오프셋 0을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73550a62d2076f2c392030c22ea826a5948745a2" translate="yes" xml:space="preserve">
          <source>Seek restores the line table reader to a position returned by Tell.</source>
          <target state="translated">Seek은 Line 테이블 리더를 Tell이 리턴 한 위치로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="6d637ad9eaafe14fbed4d5e3bc3eb33df03f11cb" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.</source>
          <target state="translated">Seek는 다음에 따라 파일에 대한 다음 읽기 또는 쓰기에 대한 오프셋을 오프셋으로 설정합니다. 새 오프셋과 오류 (있는 경우)를 반환합니다. O_APPEND로 열린 파일에서 찾기 동작이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e00a273e91af976fc6df810663ccae8e6326bc28" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.</source>
          <target state="translated">Seek는 다음 읽기 또는 쓰기 오프셋에 대한 오프셋을 설정합니다. Seek는 파일의 시작과 관련된 새 오프셋과 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2691430f4c04cd93d687e7abb0ccf591170c83f" translate="yes" xml:space="preserve">
          <source>Seek whence values.</source>
          <target state="translated">whence 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="69cfaf772b14f0b576e9cb0bbd8f02155636d19d" translate="yes" xml:space="preserve">
          <source>SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.</source>
          <target state="translated">SeekPC는 pc가 포함 된 컴파일 단위에 대한 항목을 반환하고 리더가 해당 단위의 자식을 읽도록 위치를 지정합니다. pc가 어떤 장치로도 보호되지 않으면 SeekPC는 ErrUnknownPC를 반환하고 판독기의 위치는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce674d68613294249c458dda3fd950d087fbda52" translate="yes" xml:space="preserve">
          <source>SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.</source>
          <target state="translated">SeekPC는 pc를 포함하는 LineEntry로 * entry를 설정하고 행 테이블의 다음 항목에 판독기를 배치합니다. 필요한 경우 pc를 찾기 위해 뒤로 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="9d91685eee68f0702fc5f565a2ad58bdb01cbd6c" translate="yes" xml:space="preserve">
          <source>Seeker is the interface that wraps the basic Seek method.</source>
          <target state="translated">Seeker는 기본 Seek 메소드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="c221b3bf48536c91e36f1aa582e0e6ad14671a86" translate="yes" xml:space="preserve">
          <source>Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.</source>
          <target state="translated">파일을 시작하기 전에 오프셋을 찾는 것은 오류입니다. 포지티브 오프셋을 찾는 것은 합법적이지만 기본 개체에 대한 후속 I / O 작업의 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d283b12149f88184eedb3514ba9c006d88d9d635" translate="yes" xml:space="preserve">
          <source>Segment returns the first Segment with the given name, or nil if no such segment exists.</source>
          <target state="translated">세그먼트는 주어진 이름을 가진 첫 번째 세그먼트를 반환하거나, 해당 세그먼트가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ee9c170709717ea62d8ec2ac63808bf3b81d532" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</source>
          <target state="translated">Select는 케이스 목록에 설명 된 선택 조작을 실행합니다. Go select 문과 같이, 적어도 하나의 경우가 진행될 때까지 차단하고 균일 한 의사 랜덤 선택을 한 다음 해당 경우를 실행합니다. 선택된 케이스의 색인을 리턴하고, 해당 케이스가 수신 조작 인 경우, 값이 수신되고 값이 채널의 송신에 해당하는지 여부를 나타내는 부울 (채널이 닫혀서 수신 된 0 값이 아닌)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7716a94c0a405511b91cc23c646dfce03e542371" translate="yes" xml:space="preserve">
          <source>SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).</source>
          <target state="translated">SelectionKind는 선택기 표현식 xf의 종류를 설명합니다 (제한된 식별자 제외).</target>
        </trans-unit>
        <trans-unit id="656dfc577aeb6e9f277a9a8820fcfc6e5db75f21" translate="yes" xml:space="preserve">
          <source>SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">SelectionString은 s의 문자열 형식을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad40365c9764afdd964f9245649f6856af2d11" translate="yes" xml:space="preserve">
          <source>Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">Send는 채널 v에서 x를 보냅니다. v의 종류가 Chan이 아니거나 x의 유형이 v의 요소 유형과 같지 않으면 패닉 상태가됩니다. Go에서와 같이 x의 값은 채널의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="2750b0f06411195ed08fefe45f59d520ab6f8353" translate="yes" xml:space="preserve">
          <source>SendMail</source>
          <target state="translated">SendMail</target>
        </trans-unit>
        <trans-unit id="1a5bbac84e0744da338847af3ed794816ef236ce" translate="yes" xml:space="preserve">
          <source>SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">SendMail은 addr에서 서버에 연결하고 가능한 경우 TLS로 전환하고 가능한 경우 선택적 메커니즘을 사용하여 인증 한 다음 메시지 msg를 사용하여 전자 메일을 주소에서 전자 메일로 보냅니다. 주소는 &quot;mail.example.com:smtp&quot;와 같이 포트를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="9866b4faed06fd643cf801f0e203a46a3fe6c756" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.</source>
          <target state="translated">Serve는 리스너에서 들어오는 FastCGI 연결을 수락하여 각각에 대해 새로운 고 루틴을 만듭니다. goroutine은 요청을 읽은 후 핸들러를 호출하여 응답합니다. l이 nil이면 Serve는 os.Stdin의 연결을 수락합니다. 핸들러가 nil이면 http.DefaultServeMux가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8de44e0fb5292324dadb958bb0ec67283e1e920" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">서브는 리스너에서 들어오는 HTTP 연결을 받아 들여 각각에 대해 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽고 처리기를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="fb2fbb4a3d173feafc83e986b5d91f4c043b98cd" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</source>
          <target state="translated">Serve는 리스너 l에서 들어오는 연결을 받아 들여 각각에 대한 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽은 다음 srv.Handler를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="f65496b12ef6ef062ca261d02fdcc1afec4ce5ea" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">Serve는 항상 nil이 아닌 오류를 반환하고 l을 닫습니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="4671511496e9d853a658f8c526e4dbf184a2c34c" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error.</source>
          <target state="translated">검색은 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="497078ba977bfc095dad2477b3172dcb26f1c0ab" translate="yes" xml:space="preserve">
          <source>Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.</source>
          <target state="translated">Serve는 현재 활성화 된 CGI 요청에서 제공된 처리기를 실행합니다 (있는 경우). 현재 CGI 환경이 없으면 오류가 반환됩니다. 제공된 핸들러는 http.DefaultServeMux를 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfb7d2b5b789e7fe76f3c2462b4817839783a1b" translate="yes" xml:space="preserve">
          <source>ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.</source>
          <target state="translated">ServeCodec은 ServeConn과 유사하지만 지정된 코덱을 사용하여 요청을 디코딩하고 응답을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="09ac76223546ffdd3d100d24b6bc49c0b7956df0" translate="yes" xml:space="preserve">
          <source>ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn은 단일 연결에서 DefaultServer를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다. ServeConn은 연결에 gob 와이어 형식 (패키지 gob 참조)을 사용합니다. 대체 코덱을 사용하려면 ServeCodec을 사용하십시오. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d136d0992046f83551cea5f2576de13dc7e39384" translate="yes" xml:space="preserve">
          <source>ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.</source>
          <target state="translated">ServeConn은 단일 연결에서 JSON-RPC 서버를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2f01374418f76760c6cb616cbabd675e38909787" translate="yes" xml:space="preserve">
          <source>ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn은 단일 연결에서 서버를 실행합니다. 클라이언트가 전화를 끊을 때까지 연결을 제공하는 ServeConn 블록. 호출자는 일반적으로 go 문에서 ServeConn을 호출합니다. ServeConn은 연결에 gob 와이어 형식 (패키지 gob 참조)을 사용합니다. 대체 코덱을 사용하려면 ServeCodec을 사용하십시오. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef53643ab98faf2b116983a1f327c585aaa8a435" translate="yes" xml:space="preserve">
          <source>ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.</source>
          <target state="translated">ServeContent는 제공된 ReadSeeker의 컨텐츠를 사용하여 요청에 응답합니다. io.Copy에 비해 ServeContent의 주요 이점은 Range 요청을 올바르게 처리하고 MIME 유형을 설정하며 If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since 및 If-Range를 처리한다는 것입니다. 요청.</target>
        </trans-unit>
        <trans-unit id="cfd658fe667ad1d964897018a5c4cf11bec05335" translate="yes" xml:space="preserve">
          <source>ServeFile replies to the request with the contents of the named file or directory.</source>
          <target state="translated">ServeFile은 명명 된 파일 또는 디렉토리의 내용으로 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="049197d23952867737fe7bc77daa12a248c70057" translate="yes" xml:space="preserve">
          <source>ServeHTTP calls f(w, r).</source>
          <target state="translated">ServeHTTP는 f (w, r)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4c4916bc850460672f4222f24dda17f824b214d6" translate="yes" xml:space="preserve">
          <source>ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.</source>
          <target state="translated">ServeHTTP는 요청 URL과 가장 일치하는 패턴을 가진 처리기로 요청을 발송합니다.</target>
        </trans-unit>
        <trans-unit id="21deb32922a44f4fb534ed8afc10e377cb3ed92e" translate="yes" xml:space="preserve">
          <source>ServeHTTP implements an http.Handler that answers RPC requests.</source>
          <target state="translated">ServeHTTP는 RPC 요청에 응답하는 http.Handler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6b5f212880feffc9d4b20ece24bb964f1dfe9a0e" translate="yes" xml:space="preserve">
          <source>ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.</source>
          <target state="translated">ServeHTTP는 응답 헤더와 데이터를 ResponseWriter에 쓴 다음 반환해야합니다. 요청이 완료되었다는 신호를 반환합니다. ServeHTTP 호출 완료 후 또는 동시에 ResponseWriter를 사용하거나 Request.Body에서 읽는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="643b76d4394a8e8ca4ec7165cbad824736ed0dab" translate="yes" xml:space="preserve">
          <source>ServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL.</source>
          <target state="translated">ServeMux는 또한 URL 요청 경로와 호스트 헤더를 정리하여 포트 번호를 제거하고을 포함하는 요청을 리디렉션합니다. 또는 .. 요소 또는 반복되는 동일한 슬래시 URL 로의 슬래시.</target>
        </trans-unit>
        <trans-unit id="c2c623da8699103087cc62f3c47b54b0c6fbdef4" translate="yes" xml:space="preserve">
          <source>ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.</source>
          <target state="translated">ServeMux는 HTTP 요청 멀티플렉서입니다. 등록 된 패턴 목록과 각 수신 요청의 URL을 일치시키고 URL과 가장 일치하는 패턴의 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d57d6d29bc00d69dcb5016e00c29678f29b25c20" translate="yes" xml:space="preserve">
          <source>ServeMux.Handle</source>
          <target state="translated">ServeMux.Handle</target>
        </trans-unit>
        <trans-unit id="a2ccb85e8b555a7018f6848932b3cf1638f89e04" translate="yes" xml:space="preserve">
          <source>ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.</source>
          <target state="translated">ServeRequest는 ServeCodec와 유사하지만 단일 요청을 동 기적으로 제공합니다. 완료시 코덱을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="914b527f3acbaa5705eeffe44b971ef90f12446b" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">ServeTLS는 리스너에서 들어오는 HTTPS 연결을 수락하여 각각에 대해 새로운 서비스 고 루틴을 만듭니다. 서비스는 요청을 읽고 처리기를 호출하여 응답합니다.</target>
        </trans-unit>
        <trans-unit id="0a96e454a3074cfb2a672bba732fc55cf3ace063" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.</source>
          <target state="translated">ServeTLS는 리스너 l에서 들어오는 연결을 받아 들여 각각에 대한 새로운 서비스 고 루틴을 만듭니다. 서비스 goroutines는 TLS 설정을 수행 한 다음 srv.Handler를 호출하여 요청을 읽고 응답합니다.</target>
        </trans-unit>
        <trans-unit id="5d05c42df2acb99153f40488ff8b30bf621e7c31" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error.</source>
          <target state="translated">ServeTLS는 항상 0이 아닌 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49b6a1abd7e8e016f95152133848467bef1659cf" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ServeTLS는 항상 0이 아닌 오류를 반환합니다. 종료 또는 닫기 후 반환 된 오류는 ErrServerClosed입니다.</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="4ddf4403b77024142dd6473786b6571dc8b196f9" translate="yes" xml:space="preserve">
          <source>Server represents an RPC Server.</source>
          <target state="translated">서버는 RPC 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="313ac33490fd78320856fae075839a276bcab472" translate="yes" xml:space="preserve">
          <source>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">서버는 conn을 기본 전송으로 사용하여 새 TLS 서버 측 연결을 반환합니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0b4e659e40eb8a8a1e289fa3271bf98ef6e2706" translate="yes" xml:space="preserve">
          <source>Server.Shutdown</source>
          <target state="translated">Server.Shutdown</target>
        </trans-unit>
        <trans-unit id="e8983457da1ab21a6c85c2a9507e94af92a8934d" translate="yes" xml:space="preserve">
          <source>ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ServerConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="e48e77ca43f54c7c217d619efb9bd95f1a1f8aba" translate="yes" xml:space="preserve">
          <source>ServerError represents an error that has been returned from the remote side of the RPC connection.</source>
          <target state="translated">ServerError는 RPC 연결의 원격 쪽에서 반환 된 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="547b92e886182f3f71367607ff47558fb0fe8029" translate="yes" xml:space="preserve">
          <source>ServerInfo records information about an SMTP server.</source>
          <target state="translated">ServerInfo는 SMTP 서버에 대한 정보를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="870594a7b5d015bba7a8d2c0875c56f2fce85f71" translate="yes" xml:space="preserve">
          <source>SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.</source>
          <target state="translated">Conn에 의해 SessionResetter가 구현되어 드라이버가 연결과 관련된 세션 상태를 재설정하고 연결 상태가 불량하다는 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab8e5c4d0aeae85893fd621bc37db1b1a73696a" translate="yes" xml:space="preserve">
          <source>Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.</source>
          <target state="translated">Set는 x를 값 v에 할당합니다. CanSet이 false를 반환하면 패닉이 발생합니다. Go에서와 같이 x의 값은 v의 유형에 지정할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d2a8709f5b7f411cc9ba583a652581b21b6d185" translate="yes" xml:space="preserve">
          <source>Set is called once, in command line order, for each flag present. The flag package may call the String method with a zero-valued receiver, such as a nil pointer.</source>
          <target state="translated">Set는 각 플래그가 존재하는 경우 명령 행 순서로 한 번 호출됩니다. 플래그 패키지는 nil 포인터와 같이 값이 0 인 수신자로 String 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8fb40cfeae3d73e6b30e01495ac2c9fe7ff8cc2" translate="yes" xml:space="preserve">
          <source>Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">Set 값 v의 JavaScript 속성 p를 ValueOf (x)로 설정합니다. v가 JavaScript 객체가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="87f6096d8457ac4b04a70faa68ba0c62c9f61ecc" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.</source>
          <target state="translated">설정은 키와 연관된 헤더 항목을 단일 요소 값으로 설정합니다. 키와 관련된 기존 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="82fcf24728ab76cc9481c998a3f5414cead1eb36" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.</source>
          <target state="translated">설정은 키와 연관된 헤더 항목을 단일 요소 값으로 설정합니다. 키와 관련된 기존 값을 대체합니다. 키는 대소 문자를 구분하지 않습니다. textproto.CanonicalMIMEHeaderKey로 정규화됩니다. 비정규 키를 사용하려면 맵에 직접 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="ac88d8d813ac589b26e82c68ebe23a65cc8513a6" translate="yes" xml:space="preserve">
          <source>Set sets the key to value. It replaces any existing values.</source>
          <target state="translated">설정은 키를 값으로 설정합니다. 기존 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="03d2da815b81b3b89a818437487ee57f67fe7d66" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named command-line flag.</source>
          <target state="translated">Set은 명명 된 명령 줄 플래그의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f73f9638b07619a017d2f6dac015fd0d243d8333" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named flag.</source>
          <target state="translated">이름 지정된 플래그의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2c301753363dd5c13e85e87be14b65f72e0bdbb9" translate="yes" xml:space="preserve">
          <source>Set sets v to value.</source>
          <target state="translated">v를 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0e0649c67f5fc5e092366b50d2ec623dd85834a8" translate="yes" xml:space="preserve">
          <source>Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.</source>
          <target state="translated">z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 z를 설정하기 전에 x의 정밀도로 변경됩니다 (반올림은 적용되지 않습니다). 반올림은 z의 정밀도 및 반올림 모드에 따라 수행됩니다. z의 정확도는 정확한 (반올림되지 않은) 결과에 대한 결과 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="74c097d8a8db6198a9f30d1da9cc40810faf97ea" translate="yes" xml:space="preserve">
          <source>Set sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">x를 복사하여 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2de2c16a0340db2bee0118ccf9d1587fd704cd50" translate="yes" xml:space="preserve">
          <source>Set sets z to x and returns z.</source>
          <target state="translated">z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd19264e05439f601808981687979a9cbd55329f" translate="yes" xml:space="preserve">
          <source>SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.</source>
          <target state="translated">SetBasicAuth는 요청의 Authorization 헤더가 제공된 사용자 이름과 비밀번호로 HTTP 기본 인증을 사용하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="22bdae472d3db85cab5c57989c6be910d803a01e" translate="yes" xml:space="preserve">
          <source>SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &amp;lt;&amp;lt; i); if b is 0 SetBit sets z = x &amp;amp;^ (1 &amp;lt;&amp;lt; i). If b is not 0 or 1, SetBit will panic.</source>
          <target state="translated">SetBit은 z를 x로 설정하고 x의 i 번째 비트를 b (0 또는 1)로 설정합니다. 즉, b가 1이면 SetBit은 z = x를 설정합니다. | (1 &amp;lt;&amp;lt; i); b가 0이면 SetBit은 z = x &amp;amp; ^ (1 &amp;lt;&amp;lt; i)를 설정합니다. b가 0 또는 1이 아니면 SetBit이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="feba31f1e1635889b9235c6993fbb340077ba325" translate="yes" xml:space="preserve">
          <source>SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">SetBits는 값을 abs로 설정하고 리틀 엔디안 워드 슬라이스로 해석 한 다음 z를 반환하여 z에 대한 원시 (확인되지 ​​않았지만 빠른) 액세스를 제공합니다. 결과와 abs는 동일한 기본 배열을 공유합니다. SetBits는이 패키지 외부에서 누락 된 저수준 Int 기능의 구현을 지원하기위한 것입니다. 그렇지 않으면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a90ede61cca8ba0e26af9fe2c3c6480079bf80" translate="yes" xml:space="preserve">
          <source>SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</source>
          <target state="translated">SetBlockProfileRate는 차단 프로파일에보고되는 고 루틴 차단 이벤트의 비율을 제어합니다. 프로파일 러는 차단 된 나노 초당 속도 당 평균 1 회의 차단 이벤트를 샘플링하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="459d3a69d65d385fb3b3fbe398bb9c85138ddcc2" translate="yes" xml:space="preserve">
          <source>SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.</source>
          <target state="translated">SetBool은 v의 기본 값을 설정합니다. v의 Kind가 Bool이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e2455227631da0419c37dea6613f51644e9e03d" translate="yes" xml:space="preserve">
          <source>SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long.</source>
          <target state="translated">부품을 만들기 전에 SetBoundary를 호출해야하며 특정 ASCII 문자 만 포함 할 수 있으며 비어 있지 않아야하며 최대 70 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b06cf4ca1fda2091c2541de19f0b4a515ade4ba9" translate="yes" xml:space="preserve">
          <source>SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.</source>
          <target state="translated">SetBoundary는 Writer의 무작위로 생성 된 기본 경계 분리자를 명시 적 값으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="6106f2ae31464af3b2e7f9b63e64b76356750152" translate="yes" xml:space="preserve">
          <source>SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.</source>
          <target state="translated">SetBytes는 buf를 부호없는 빅 엔디안 정수의 바이트로 해석하고 z를 해당 값으로 설정 한 다음 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a0583b12bc86b9434e36c34c4ce6e8b5c26ba75" translate="yes" xml:space="preserve">
          <source>SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.</source>
          <target state="translated">SetBytes는 단일 작업에서 처리 된 바이트 수를 기록합니다. 이것이 호출되면 벤치 마크는 ns / op 및 MB / s를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bba92654aa999e9512f4dfa6313cb2838144dfe3" translate="yes" xml:space="preserve">
          <source>SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">SetBytes는 v의 기본 값을 설정합니다. v의 기본 값이 바이트 슬라이스가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="344d8ddf2a696d0cf0cc16a1825af1241c772a89" translate="yes" xml:space="preserve">
          <source>SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &amp;lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.</source>
          <target state="translated">SetCPUProfileRate는 CPU 프로파일 링 속도를 초당 hz 샘플로 설정합니다. hz &amp;lt;= 0이면 SetCPUProfileRate가 프로파일 링을 끕니다. 프로파일 러가 켜져 있으면 먼저 끄지 않고 속도를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1afcde63337e23e05a9b84c1c7b85f57c0092cd7" translate="yes" xml:space="preserve">
          <source>SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</source>
          <target state="translated">SetCap은 v의 용량을 n으로 설정합니다. v의 종류가 슬라이스가 아니거나 n이 슬라이스의 길이보다 작거나 용량보다 큰 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44731bc16b3d80516224c7c852f64732d07d62c1" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.</source>
          <target state="translated">SetCgoTraceback은 C 코드에서 역 추적 정보를 수집하고 해당 역 추적 정보를 기호 정보로 변환하는 데 사용되는 세 가지 C 함수를 기록합니다. cgo를 사용하는 프로그램의 스택 추적을 인쇄 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="348727b9cf484ab1b9762cea6ba0daa8dde8a933" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback should be called only once, ideally from an init function.</source>
          <target state="translated">SetCgoTraceback은 init 함수에서 이상적으로 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="67fdfbbba9d56846727e0eb32ef8332c0bf20f53" translate="yes" xml:space="preserve">
          <source>SetComment sets the end-of-central-directory comment field. It can only be called before Close.</source>
          <target state="translated">SetComment는 중앙 디렉토리 끝 주석 필드를 설정합니다. 닫기 전에 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f03250bccb0b87aeb45d79cb945d1dd0319cb9" translate="yes" xml:space="preserve">
          <source>SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.</source>
          <target state="translated">SetComplex는 v의 기본 값을 x로 설정합니다. v의 Kind가 Complex64 또는 Complex128이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac6f79734771b4e3adca460b8931ae634206e20f" translate="yes" xml:space="preserve">
          <source>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</source>
          <target state="translated">SetConnMaxLifetime은 연결을 재사용 할 수있는 최대 시간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cdfc398e60b71e846a0a56ba3b1860f275a8c713" translate="yes" xml:space="preserve">
          <source>SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.</source>
          <target state="translated">SetCookie는 Set-Cookie 헤더를 제공된 ResponseWriter의 헤더에 추가합니다. 제공된 쿠키는 유효한 이름을 가져야합니다. 유효하지 않은 쿠키가 자동으로 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b53737e17baa71a51a0e5ede6a121ccba30720" translate="yes" xml:space="preserve">
          <source>SetCookies implements the SetCookies method of the http.CookieJar interface.</source>
          <target state="translated">SetCookies는 http.CookieJar 인터페이스의 SetCookies 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d3cec8d8761e8a9c75efaa51883455428c208775" translate="yes" xml:space="preserve">
          <source>SetDeadline implements the Conn SetDeadline method.</source>
          <target state="translated">SetDeadline은 Conn SetDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c0b50695667af085ed75f6ae0d7d496b50008cd3" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.</source>
          <target state="translated">SetDeadline은 리스너와 관련된 최종 기한을 설정합니다. 시간 값이 0이면 최종 기한이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b4723a8859169359d85b5290587d68a0fc3307" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetDeadline은 연결과 관련된 읽기 및 쓰기 기한을 설정합니다. t 값이 0이면 읽기 및 쓰기 시간이 초과되지 않습니다. 쓰기 시간이 초과되면 TLS 상태가 손상되고 이후의 모든 쓰기에서 동일한 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="883b1167470e9a9bc17df175940ef7113ec71b15" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.</source>
          <target state="translated">SetDeadline은 파일의 읽기 및 쓰기 기한을 설정합니다. SetReadDeadline 및 SetWriteDeadline을 모두 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7aad8c47d1ea7eb52b60d62c5b63c9894a7f6a08" translate="yes" xml:space="preserve">
          <source>SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;amp;, &amp;lt;, and &amp;gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</source>
          <target state="translated">SetEscapeHTML은 문제가있는 HTML 문자를 JSON 인용 문자열 내에서 이스케이프해야하는지 여부를 지정합니다. 기본 동작은 JSON을 HTML에 임베드 할 때 발생할 수있는 특정 안전 문제를 피하기 위해 &amp;amp;, &amp;lt;및&amp;gt;를 \ u0026, \ u003c 및 \ u003e로 이스케이프하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd27241a174aea4c1fb70802e55de9c35c7e1aca" translate="yes" xml:space="preserve">
          <source>SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</source>
          <target state="translated">SetFinalizer는 obj와 관련된 종료자를 제공된 종료 자 기능으로 설정합니다. 가비지 콜렉터는 연관된 종료자가있는 도달 할 수없는 블록을 찾으면 연관을 지우고 별도의 goroutine에서 finalizer (obj)를 실행합니다. 이렇게하면 obj에 다시 도달 할 수 있지만 관련 finalizer가 없어집니다. SetFinalizer가 다시 호출되지 않는다고 가정하면 다음에 가비지 수집기가 obj에 도달 할 수 없음을 확인하면 obj를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="516de8a9b6e7300def0c0d80a14119cce09c9af1" translate="yes" xml:space="preserve">
          <source>SetFinalizer(obj, nil) clears any finalizer associated with obj.</source>
          <target state="translated">SetFinalizer (obj, nil)는 obj와 관련된 종료자를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="fce6aef209330cc8b12176816b79927fb4cacd60" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger.</source>
          <target state="translated">SetFlags는 로거의 출력 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dd0ec7930cc082a2a1ef8ed98443be56c5746d85" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger.</source>
          <target state="translated">SetFlags는 표준 로거의 출력 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a44e49f661219c769f20780167a6964483f17f7a" translate="yes" xml:space="preserve">
          <source>SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.</source>
          <target state="translated">SetFloat는 v의 기본 값을 x로 설정합니다. v의 Kind가 Float32 또는 Float64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e47d96a49d3af2841a8dc184d5134cb1a32de48" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.</source>
          <target state="translated">SetFloat64는 z를 정확히 f로 설정하고 z를 반환합니다. f가 유한하지 않으면 SetFloat는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d8e2534e02690c3fed1859413bf2f8f63c436f1" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.</source>
          <target state="translated">SetFloat64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 53으로 변경되며 반올림은 적용되지 않습니다. x가 NaN 인 경우 ErrNaN으로 Float64 패닉을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b801568b0fa82e3d000c6cfdb98f7b328836a9b" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z.</source>
          <target state="translated">SetFrac은 z를 a / b로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45fde5eac415722d6b8394ea7547d400d1373021" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z.</source>
          <target state="translated">SetFrac64는 z를 a / b로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="805636f93a7dd0b6aa2183e35b0d00ca6d7104e9" translate="yes" xml:space="preserve">
          <source>SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.</source>
          <target state="translated">SetGCPercent는 가비지 콜렉션 대상 백분율을 설정합니다. 이전 콜렉션이 남아있는 후 새로 할당 된 데이터 대 라이브 데이터의 비율이이 백분율에 도달하면 콜렉션이 트리거됩니다. SetGCPercent는 이전 설정을 반환합니다. 초기 설정은 시작시 GOGC 환경 변수의 값이거나 변수가 설정되지 않은 경우 100입니다. 음수 백분율은 가비지 수집을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="906978195b1fb386902e36080f453c88d02f6211" translate="yes" xml:space="preserve">
          <source>SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than Do, which should be used instead when possible.</source>
          <target state="translated">SetGoroutineLabels는 현재 goroutine의 레이블을 ctx와 일치하도록 설정합니다. 새로운 고 루틴은 그것을 생성 한 고 루틴의 레이블을 상속합니다. 이 API는 Do보다 낮은 수준의 API이며 가능한 경우 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c95fdd46823686f50f0d15060d185e4b4e5d563" translate="yes" xml:space="preserve">
          <source>SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.</source>
          <target state="translated">SetImports는 명시 적으로 가져온 패키지 목록을 나열하도록 설정합니다. 목록 요소가 고유한지 확인하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="e7fb2cb55e4274d490452e6757d30cb84eb70855" translate="yes" xml:space="preserve">
          <source>SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &quot;&quot;) disables indentation.</source>
          <target state="translated">SetIndent는 패키지 레벨 함수 Indent (dst, src, prefix, indent)에 의해 들여 쓰기 된 것처럼 각 후속 인코딩 된 값을 포맷하도록 인코더에 지시합니다. SetIndent ( &quot;&quot;, &quot;&quot;)를 호출하면 들여 쓰기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="17d73d2c7105e3ec880ec1de340daf4f290af178" translate="yes" xml:space="preserve">
          <source>SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">SetIndex는 값 v의 JavaScript 인덱스 i를 ValueOf (x)로 설정합니다. v가 JavaScript 객체가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="cea11721fc2a69428fc01f2bd7212d126248c97a" translate="yes" xml:space="preserve">
          <source>SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.</source>
          <target state="translated">SetInf는 부호 비트가 설정되어 있으면 z를 무한 Float -Inf로 설정하고 부호 비트가 설정되어 있지 않으면 + Inf로 설정하고 z를 반환합니다. z의 정밀도는 변경되지 않으며 결과는 항상 정확합니다.</target>
        </trans-unit>
        <trans-unit id="7fbe79d67709b54bb947c5fb56d1678d22a06e68" translate="yes" xml:space="preserve">
          <source>SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</source>
          <target state="translated">SetInt는 v의 기본 값을 x로 설정합니다. v의 Kind가 Int, Int8, Int16, Int32 또는 Int64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9791f172aed7c20562244430ee2933689079ec7" translate="yes" xml:space="preserve">
          <source>SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 x.BitLen () 또는 64보다 크게 변경됩니다 (반올림은 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="512491a3910b089e941ff0967a1c4600d38512e1" translate="yes" xml:space="preserve">
          <source>SetInt sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">SetInt는 z를 x로 설정하고 (x를 복사하여) z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e98bca88644a6b411de0d879f43c3dc3a73ef347" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 64로 변경되며 반올림은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8bc149266ba57391034d803e65399926af1a382" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to x and returns z.</source>
          <target state="translated">SetInt64는 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8ce7465b1093a7258c6cd344217beee671aa978" translate="yes" xml:space="preserve">
          <source>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection.</source>
          <target state="translated">SetKeepAlive는 운영 체제가 연결에서 연결 유지 메시지를 보내야하는지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="89bf3d4dd275ff44ab7379e669050fce6f5a7eee" translate="yes" xml:space="preserve">
          <source>SetKeepAlivePeriod sets period between keep-alives.</source>
          <target state="translated">SetKeepAlivePeriod는 연결 유지 기간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="582102a7fa3d8dd186ee22dfa213a701e54c1846" translate="yes" xml:space="preserve">
          <source>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.</source>
          <target state="translated">SetKeepAlivesEnabled는 HTTP 연결 유지를 사용할지 여부를 제어합니다. 기본적으로 연결 유지는 항상 활성화되어 있습니다. 시스템을 종료하는 과정에서 리소스가 제한된 환경이나 서버 만 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="26dfe6afebdd675610dd8f1d4858b29cc7ee92db" translate="yes" xml:space="preserve">
          <source>SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.</source>
          <target state="translated">SetLen은 v의 길이를 n으로 설정합니다. v의 종류가 슬라이스가 아니거나 n이 음수이거나 슬라이스의 용량보다 큰 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="549c2b676df9b698394503e0fb62c18e8fa20e0b" translate="yes" xml:space="preserve">
          <source>SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content &quot;ab\nc\n&quot; the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.</source>
          <target state="translated">SetLines는 파일의 행 오프셋을 설정하고 파일의 성공 여부를보고합니다. 행 오프셋은 각 행의 첫 문자의 오프셋입니다. 예를 들어 컨텐츠 &quot;ab \ nc \ n&quot;의 경우 라인 오프셋은 {0, 3}입니다. 빈 파일에는 빈 줄 오프셋 테이블이 있습니다. 각 줄 오프셋은 이전 줄의 오프셋보다 크고 파일 크기보다 작아야합니다. 그렇지 않으면 SetLines가 실패하고 false를 반환합니다. SetLines가 반환 된 후 호출자는 제공된 슬라이스를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d21966bc8423cbdfca9062e709a1e1bfe2b23f9c" translate="yes" xml:space="preserve">
          <source>SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.</source>
          <target state="translated">SetLinesForContent는 주어진 파일 내용에 대한 줄 오프셋을 설정합니다. 위치 변경 // 줄 주석은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7ead5ff3e458c012090db0e3e46dd956293c59f9" translate="yes" xml:space="preserve">
          <source>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.</source>
          <target state="translated">SetLinger는 여전히 데이터 전송 또는 승인 대기중인 연결에서 닫기 동작을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="be9cec1a054bdf6dae13515b712cb92bca8f03d8" translate="yes" xml:space="preserve">
          <source>SetMantExp sets z to mant &amp;times; 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Specifically:</source>
          <target state="translated">SetMantExp는 z를 mant &amp;times; 2 ** exp로 설정하고 z를 반환합니다. 결과 z는 mant와 동일한 정밀도 및 반올림 모드를 갖습니다. SetMantExp는 MantExp의 역수이지만 0.5 &amp;lt;= | mant | &amp;lt;1.0. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="e756f252cafbddbad755f1c06583ad4489564d92" translate="yes" xml:space="preserve">
          <source>SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type.</source>
          <target state="translated">SetMapIndex는 맵 v의 키와 관련된 요소를 elem으로 설정합니다. v의 종류가지도가 아닌 경우 패닉 상태가됩니다. elem이 0 값이면 SetMapIndex는 맵에서 키를 삭제합니다. 그렇지 않으면 v에 nil 맵이 있으면 SetMapIndex가 패닉 상태가됩니다. Go와 마찬가지로 키의 elem은지도의 키 유형에 할당 할 수 있어야하고 elem의 값은지도의 elem 유형에 할당 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b83dfa89acb5e3c977158b5fc2760de63b71e48b" translate="yes" xml:space="preserve">
          <source>SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</source>
          <target state="translated">SetMaxIdleConns는 유휴 연결 풀의 최대 연결 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="aa3863aa142a9c48791c290f00a7c4c3d76f3b6e" translate="yes" xml:space="preserve">
          <source>SetMaxOpenConns sets the maximum number of open connections to the database.</source>
          <target state="translated">SetMaxOpenConns는 데이터베이스에 대한 최대 열린 연결 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f71d21e95f096f232e72fff30f80b920b1e3f9f5" translate="yes" xml:space="preserve">
          <source>SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.</source>
          <target state="translated">SetMaxStack은 무한 재귀에 들어가는 고 루틴에 의한 피해를 제한하는 데 주로 유용합니다. 향후 스택 증가 만 제한합니다.</target>
        </trans-unit>
        <trans-unit id="eeacbe78a8fd0d4396f1b6456e34f5857612c565" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.</source>
          <target state="translated">SetMaxStack은 단일 고 루틴 스택에서 사용할 수있는 최대 메모리 양을 설정합니다. 스택이 커지는 동안 goroutine이이 한계를 초과하면 프로그램이 충돌합니다. SetMaxStack은 이전 설정을 반환합니다. 초기 설정은 64 비트 시스템에서 1GB, 32 비트 시스템에서 250MB입니다.</target>
        </trans-unit>
        <trans-unit id="67aff5f59d34d3ecd519adad914c8c6423eaf752" translate="yes" xml:space="preserve">
          <source>SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.</source>
          <target state="translated">SetMaxThreads는 무한한 수의 스레드를 생성하는 프로그램으로 인한 손상을 제한하는 데 주로 유용합니다. 아이디어는 운영 체제를 중단하기 전에 프로그램을 중단하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6d8bc8cae003fe5d78cf6cda31fbae67e36c482" translate="yes" xml:space="preserve">
          <source>SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.</source>
          <target state="translated">SetMaxThreads는 Go 프로그램이 사용할 수있는 최대 운영 체제 스레드 수를 설정합니다. 이보다 많은 수를 사용하려고하면 프로그램이 중단됩니다. SetMaxThreads는 이전 설정을 반환합니다. 초기 설정은 10,000 개의 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="806ff185f3a93cc6a21f24b12259c49de358388c" translate="yes" xml:space="preserve">
          <source>SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.</source>
          <target state="translated">SetModTime은 Modified, ModifiedTime 및 ModifiedDate 필드를 UTC로 지정된 시간으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e9c592771061ffaaa3d588fb3aae3da84d0635b8" translate="yes" xml:space="preserve">
          <source>SetMode changes the permission and mode bits for the FileHeader.</source>
          <target state="translated">SetMode는 FileHeader의 권한 및 모드 비트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="de45da11e316c622a3816956315a15e8817585f9" translate="yes" xml:space="preserve">
          <source>SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.</source>
          <target state="translated">SetMode는 z의 반올림 모드를 mode로 설정하고 정확한 z를 반환합니다. 그렇지 않으면 z는 변경되지 않습니다. z.SetMode (z.Mode ())는 z의 정확도를 정확한 값으로 설정하는 가장 저렴한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b01a08220867d2b1a3c66f3bf6f8b7ca7ea5c1ae" translate="yes" xml:space="preserve">
          <source>SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.</source>
          <target state="translated">SetMutexProfileFraction은 뮤텍스 프로파일에보고되는 뮤텍스 경합 이벤트의 비율을 제어합니다. 평균 1 / 속도 이벤트가보고됩니다. 이전 요금이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8c38b4a404d96b417f171861cd9ebaba18b51eaf" translate="yes" xml:space="preserve">
          <source>SetName sets the package name.</source>
          <target state="translated">SetName은 패키지 이름을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d31306f3f7eb161aa0c0b28fdb6eed5363c589c3" translate="yes" xml:space="preserve">
          <source>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.</source>
          <target state="translated">SetNoDelay는 더 적은 수의 패킷을 전송하기 위해 운영 체제가 패킷 전송을 지연해야하는지 여부를 제어합니다 (Nagle 알고리즘). 기본값은 true (지연 없음)입니다. 즉, 쓰기 후 가능한 빨리 데이터가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="27a3c03ba54fb2a44f36a6c425cfa58520c56752" translate="yes" xml:space="preserve">
          <source>SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.</source>
          <target state="translated">SetOffset은 기본 작성기 내에서 zip 데이터 시작의 오프셋을 설정합니다. zip 데이터가 2 진 실행 파일과 같은 기존 파일에 추가 될 때 사용해야합니다. 데이터를 작성하기 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="004613f6cff6f004aabdb462fd19757cc3df0edb" translate="yes" xml:space="preserve">
          <source>SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.</source>
          <target state="translated">SetOutput은 사용법 및 오류 메시지의 대상을 설정합니다. 출력이 nil이면 os.Stderr이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36faf63cafa162e1ef49476325f422ab20f856dd" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the logger.</source>
          <target state="translated">SetOutput은 로거의 출력 대상을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="76988d10d7783ed1525981a82207c054e24adba8" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the standard logger.</source>
          <target state="translated">SetOutput은 표준 로거의 출력 대상을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2547ce0f12468d65a113d53c2cfbf0ddbb6dc9bb" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">SetPanicOnFault는 프로그램이 예기치 않은 (0이 아닌) 주소에서 오류가 발생할 때 런타임 동작을 제어합니다. 이러한 결함은 일반적으로 런타임 메모리 손상과 같은 버그로 인해 발생하므로 기본 응답은 프로그램 충돌입니다. 메모리 매핑 된 파일을 사용하거나 안전하지 않은 메모리 조작을하는 프로그램은 덜 극적인 상황에서 0이 아닌 주소에서 오류를 일으킬 수 있습니다. SetPanicOnFault를 사용하면 이러한 프로그램에서 런타임이 충돌이 아닌 패닉 만 트리거하도록 요청할 수 있습니다. SetPanicOnFault는 현재 고 루틴에만 적용됩니다. 이전 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72fac8e6222bd170971f1f697af6f11d0715e763" translate="yes" xml:space="preserve">
          <source>SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.</source>
          <target state="translated">SetParallelism은 RunParallel이 사용하는 고 루틴 수를 p * GOMAXPROCS로 설정합니다. 일반적으로 CPU 바인딩 벤치 마크를 위해 SetParallelism을 호출 할 필요가 없습니다. p가 1보다 작 으면이 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bcdfe56d7b7abb5a2feda191bae07f8cec5d4b8" translate="yes" xml:space="preserve">
          <source>SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.</source>
          <target state="translated">SetPointer는 안전하지 않은 Pointer 값 v를 x로 설정합니다. v의 종류가 UnsafePointer가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59bd457f6414829faae9decbaede734f70a9845c" translate="yes" xml:space="preserve">
          <source>SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetPos는 위치를 설정합니다. NewIdentifier는 공개 메소드이므로 서명을 수정할 수 없습니다. 편의를 위해 연결되었습니다. TODO : 언젠가 고쳐?</target>
        </trans-unit>
        <trans-unit id="d6d5511f09814008767ff9cfe0f77abca174ef5c" translate="yes" xml:space="preserve">
          <source>SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to &amp;plusmn;0; infinite values remain unchanged. If prec &amp;gt; MaxPrec, it is set to MaxPrec.</source>
          <target state="translated">SetPrec은 z의 정밀도를 prec로 설정하고 z의 반올림 값을 반환합니다. 가수가 정밀도 손실없이 prec 비트로 표현 될 수없는 경우 z의 반올림 모드에 따라 반올림이 발생합니다. SetPrec (0)은 모든 유한 값을 &amp;plusmn; 0에 매핑합니다. 무한 값은 변경되지 않습니다. prec&amp;gt; MaxPrec이면 MaxPrec로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2d0c71771db3b5022796766d08921a2f8600461" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the logger.</source>
          <target state="translated">SetPrefix는 로거의 출력 접 두부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6bbad9fae1ec236892af0fd5032d525acd1599d4" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the standard logger.</source>
          <target state="translated">SetPrefix는 표준 로거의 출력 접두사를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ad88a7e02a294ade703b1e817a40a72d93a7117f" translate="yes" xml:space="preserve">
          <source>SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.</source>
          <target state="translated">SetRat는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 최대 a.BitLen (), b.BitLen () 또는 64로 변경됩니다. x = a / b로.</target>
        </trans-unit>
        <trans-unit id="6d4064f9d933c367ae2ed00ed675edff7a545a0e" translate="yes" xml:space="preserve">
          <source>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.</source>
          <target state="translated">SetReadBuffer는 연결과 관련된 운영 체제의 수신 버퍼 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ccd6113cf88478a21eac0a31572f18b8edd4bad3" translate="yes" xml:space="preserve">
          <source>SetReadDeadline implements the Conn SetReadDeadline method.</source>
          <target state="translated">SetReadDeadline은 Conn SetReadDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="73112eb9e955bd18073b2a5d03cd0dc0569c7e77" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetReadDeadline은 향후 읽기 호출 및 현재 차단 된 읽기 호출에 대한 최종 기한을 설정합니다. t 값이 0이면 읽기 시간이 초과되지 않습니다. 모든 파일이 마감일 설정을 지원하지는 않습니다. SetDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fed46b093271b3a5ec6430ef1d4235557caf69e8" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.</source>
          <target state="translated">SetReadDeadline은 기본 연결에서 읽기 최종 기한을 설정합니다. t 값이 0이면 읽기 시간이 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c85e891cbcac943a2a1c3092ec5cc6bdcd4ebc48" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">SetSessionTicketKeys는 서버의 세션 티켓 키를 업데이트합니다. 첫 번째 키는 새 티켓을 만들 때 사용되며 모든 키는 티켓을 해독하는 데 사용할 수 있습니다. 세션 티켓 키를 회전시키기 위해 서버가 실행되는 동안이 기능을 호출하는 것이 안전합니다. 키가 비어 있으면 기능이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="8a945e442cacd2fa72eff38e8c9f6290d8ddbda2" translate="yes" xml:space="preserve">
          <source>SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.</source>
          <target state="translated">SetString은 v의 기본 값을 x로 설정합니다. v의 Kind가 String이 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e889ea521a067b34dab32ac1ec6528fffbf097cc" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of &amp;ldquo;0b&amp;rdquo;, &amp;ldquo;0&amp;rdquo; or &amp;ldquo;0o&amp;rdquo;, or &amp;ldquo;0x&amp;rdquo; (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for &amp;ldquo;0&amp;rdquo; to denote a non-decimal mantissa. A leading &amp;ldquo;0&amp;rdquo; is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 &amp;ldquo;e&amp;rdquo; or base-2 &amp;ldquo;p&amp;rdquo; (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) &amp;ldquo;p&amp;rdquo; exponent (because an &amp;ldquo;e&amp;rdquo; or &amp;ldquo;E&amp;rdquo; cannot be distinguished from a mantissa digit). The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 s 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. s는 (아마 부호있는) 분수 &quot;a / b&quot;로, 또는 선택적으로 지수 다음에 오는 부동 소수점 숫자로 제공 될 수 있습니다. 분수가 제공되는 경우, 피제수와 제수는 모두 10 진수 정수이거나 &quot;0b&quot;, &quot;0&quot;또는 &quot;0o&quot;또는 &quot;0x&quot;(또는 대문자 변형)의 접두사를 독립적으로 사용하여 이진수, 8 진수 또는 16 진수 정수입니다. 제수는 서명 할 수 없습니다. 부동 소수점 숫자가 제공되면 10 진수 형식이거나 위와 동일한 접두사를 사용할 수 있지만 &quot;0&quot;은 10 진수가 아닌 가수를 나타냅니다. 선행 &quot;0&quot;은 10 진 선행 0으로 간주됩니다. 이 경우 8 진수 표현을 나타내지 않습니다. 선택적인 base-10 &quot;e&quot;또는 base-2 &quot;p&quot;(또는 대문자 변형) 지수도 제공 될 수 있습니다.(선택적) &quot;p&quot;지수 만 허용하는 16 진 부동 소수점을 제외하고 ( &quot;e&quot;또는 &quot;E&quot;는 가수 자리와 구별 할 수 없기 때문에). 접두사뿐만 아니라 전체 문자열이 성공하려면 유효해야합니다. 조작이 실패한 경우 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="efbb232582df792d37509713c9b27b267d546a58" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 s 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. s는 기본 인수 0을 사용하여 Parse에 허용 된 형식과 동일한 형식의 부동 소수점 숫자 여야합니다. 접두사뿐만 아니라 전체 문자열이 성공을 위해 유효해야합니다. 조작이 실패한 경우 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="63e18202e9d9aea4fa241b783984e3dc354de835" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString은 z를 주어진 밑에서 해석되는 s의 값으로 설정하고 z와 성공을 나타내는 부울을 리턴합니다. 접두사뿐만 아니라 전체 문자열이 성공하려면 유효해야합니다. SetString이 실패하면 z 값은 정의되지 않지만 리턴 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="38dbbaefe7e4a783f76cb46c7ca92c9417de8b66" translate="yes" xml:space="preserve">
          <source>SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(&quot;all&quot;) ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.</source>
          <target state="translated">SetTraceback은 복구되지 않은 패닉이나 내부 런타임 오류로 인해 종료하기 전에 인쇄하는 트레이스 백에서 런타임에 의해 인쇄되는 세부 정보의 양을 설정합니다. level 인수는 GOTRACEBACK 환경 변수와 동일한 값을 갖습니다. 예를 들어, SetTraceback ( &quot;all&quot;)은 프로그램이 충돌 할 때 모든 고 루틴을 인쇄하도록합니다. 자세한 내용은 패키지 런타임 설명서를 참조하십시오. SetTraceback이 환경 변수보다 낮은 레벨로 호출되면 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fefbf475ce2643229d0cfdbfe83dace76ec0745" translate="yes" xml:space="preserve">
          <source>SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetTree는 노드의 부모 트리를 설정합니다. NewIdentifier는 공개 메소드이므로 서명을 수정할 수 없습니다. 편의를 위해 연결되었습니다. TODO : 언젠가 고쳐?</target>
        </trans-unit>
        <trans-unit id="c67115f13df235c71277ca4e4cc4cdf9edef929f" translate="yes" xml:space="preserve">
          <source>SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</source>
          <target state="translated">SetUint는 v의 기본 값을 x로 설정합니다. v의 Kind가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아니거나 CanSet ()이 false 인 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0d44c574be3e0563cede63a8860a8c3c9c0ea08" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetUint64는 z를 x의 (둥근 반올림) 값으로 설정하고 z를 반환합니다. z의 정밀도가 0이면 64로 변경되며 반올림은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0241edc0d224ec2868d9f80a9b9550102e93ffe8" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to x and returns z.</source>
          <target state="translated">SetUint64는 z를 x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d938745882d5a8df95a9972a3a9bbbee174d3301" translate="yes" xml:space="preserve">
          <source>SetUnderlying sets the underlying type and marks t as complete.</source>
          <target state="translated">SetUnderlying은 기본 유형을 설정하고 t를 완료로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6743e47079d741cfccfdce2738e02e6efcdc6dc1" translate="yes" xml:space="preserve">
          <source>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.</source>
          <target state="translated">SetUnlinkOnClose는 리스너가 닫힐 때 기본 소켓 파일을 파일 시스템에서 제거해야하는지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3a7d70c082a7c060c7f1583bead1a8cb995d2129" translate="yes" xml:space="preserve">
          <source>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.</source>
          <target state="translated">SetWriteBuffer는 연결과 관련된 운영 체제의 전송 버퍼 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ce72366b97c1e87523bdc3b4986d2a5ed5efea78" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline implements the Conn SetWriteDeadline method.</source>
          <target state="translated">SetWriteDeadline은 Conn SetWriteDeadline 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="94da0323d7e4b44c2641176fd8ed70132d7e560c" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &amp;gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetWriteDeadline은 향후 쓰기 호출 및 현재 차단 된 쓰기 호출에 대한 최종 기한을 설정합니다. 쓰기 시간이 초과 되더라도 일부 데이터가 성공적으로 작성되었음을 나타내는 n&amp;gt; 0을 반환 할 수 있습니다. t의 값이 0이면 쓰기 시간이 초과되지 않음을 의미합니다. 모든 파일이 마감일 설정을 지원하지는 않습니다. SetDeadline을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e383d386b9651b389cbae33232566bb47ae2af13" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetWriteDeadline은 기본 연결에서 쓰기 기한을 설정합니다. t의 값이 0이면 쓰기 시간이 초과되지 않음을 의미합니다. 쓰기 시간이 초과되면 TLS 상태가 손상되고 이후의 모든 쓰기에서 동일한 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="308be1977132bdbc81c0f89a2767dd32da76c702" translate="yes" xml:space="preserve">
          <source>Setenv sets the value of the environment variable named by the key. It returns an error, if any.</source>
          <target state="translated">Setenv는 키로 명명 된 환경 변수의 값을 설정합니다. 오류가있는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="509f2c6d0467d5d83c9526f638c505af46797567" translate="yes" xml:space="preserve">
          <source>Setters, numeric operations and predicates are represented as methods of the form:</source>
          <target state="translated">세터, 숫자 연산 및 술어는 다음 형식의 메소드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b84f9f04ca185b4b399c76c8fc7c01ef4f564e3" translate="yes" xml:space="preserve">
          <source>Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;). x must be an Int or an Unknown. If x is Unknown, the result is x.</source>
          <target state="translated">Shift는 op == token.SHL 또는 token.SHR (&amp;lt;&amp;lt; 또는 &amp;gt;&amp;gt;)을 사용하여 시프트 표현식 x op s의 결과를 리턴합니다. x는 Int 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 x입니다.</target>
        </trans-unit>
        <trans-unit id="fde43f2305da307b56958af17198c21e47808653" translate="yes" xml:space="preserve">
          <source>Short reports whether the -test.short flag is set.</source>
          <target state="translated">Short는 -test.short 플래그가 설정되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="5b772b7bfd0a43273fb7c5f49a6c16d837261f35" translate="yes" xml:space="preserve">
          <source>Shuffle</source>
          <target state="translated">Shuffle</target>
        </trans-unit>
        <trans-unit id="79a2c163367d393e517ed372229f5d310534a9d9" translate="yes" xml:space="preserve">
          <source>Shuffle (SlicesInUnison)</source>
          <target state="translated">셔플 (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="732d9d1b7fa9ce160a254c0eec34ec29c54e1b79" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">의사 셔플은 기본 소스를 사용하여 요소의 순서를 무작위로 지정합니다. n은 요소 수입니다. n &amp;lt;0 인 경우 패닉 셔플. swap은 요소를 인덱스 i 및 j로 교체합니다.</target>
        </trans-unit>
        <trans-unit id="6d3cd15e0fd6a7a5b1756b9af5c51872006c475b" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">의사 셔플은 요소의 순서를 무작위로 지정합니다. n은 요소 수입니다. n &amp;lt;0 인 경우 패닉 셔플. swap은 요소를 인덱스 i 및 j로 교체합니다.</target>
        </trans-unit>
        <trans-unit id="8e0c7b7cdf248102d52e5f44dcd474d4d82c359e" translate="yes" xml:space="preserve">
          <source>Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.</source>
          <target state="translated">종료는 WebSockets와 같은 하이재킹 된 연결을 닫거나 기다리지 않습니다. 종료 호출자는 이러한 오래 지속 된 연결 종료를 별도로 알리고 원하는 경우 종료 될 때까지 기다려야합니다. 종료 알림 기능을 등록하는 방법은 RegisterOnShutdown을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38dcf86ad76a9ad474561d4239201b3f812c81b9" translate="yes" xml:space="preserve">
          <source>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">종료는 활성 연결을 방해하지 않고 서버를 정상적으로 종료합니다. 종료는 먼저 열려있는 모든 리스너를 닫은 다음 모든 유휴 연결을 닫은 다음 연결이 유휴 상태로 돌아간 다음 무기한으로 종료 될 때까지 작동합니다. 종료가 완료되기 전에 제공된 컨텍스트가 만료되면 Shutdown은 컨텍스트의 오류를 반환하고, 그렇지 않으면 서버의 기본 리스너를 닫으면 반환 된 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="4dc2181e93ae969f803429357fe579abd176b4b4" translate="yes" xml:space="preserve">
          <source>Sign returns -1, 0, or 1 depending on whether x &amp;lt; 0, x == 0, or x &amp;gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.</source>
          <target state="translated">부호는 x &amp;lt;0, x == 0 또는 x&amp;gt; 0에 따라 -1, 0 또는 1을 반환합니다. x는 숫자이거나 알 수없는 것이어야합니다. 복소수 값 x의 경우 x == 0이면 부호가 0이고 그렇지 않으면! = 0입니다. x가 알 수없는 경우 결과는 1입니다.</target>
        </trans-unit>
        <trans-unit id="b52aac6f1207124113d4a678eb49a1b5cf712f7a" translate="yes" xml:space="preserve">
          <source>Sign returns:</source>
          <target state="translated">부호 반환 :</target>
        </trans-unit>
        <trans-unit id="6589591f2f20ffb39adee81e8ba10edbe7dacc2e" translate="yes" xml:space="preserve">
          <source>Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign은 개인 키 priv를 사용하여 해시 (더 큰 메시지를 해시 한 결과 여야 함)에 서명합니다. 해시가 개인 키 곡선 순서의 비트 길이보다 길면 해시가 해당 길이로 잘립니다. 서명을 정수 쌍으로 리턴합니다. 개인 키의 보안은 랜드의 엔트로피에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="311212195f2e7e53bfbdc1974b3a767400f6e3ff" translate="yes" xml:space="preserve">
          <source>Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">부호는 개인 키 priv를 사용하여 임의 길이의 해시 (더 큰 메시지를 해시 한 결과 여야 함)에 서명합니다. 서명을 정수 쌍으로 리턴합니다. 개인 키의 보안은 랜드의 엔트로피에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd714756dfd32673e7a5fdf4e7a7d3f4c1f0476c" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.</source>
          <target state="translated">표지판은 사적으로 소화하여 랜드에서 무작위로 읽습니다. opts가 * PSSOptions이면 PSS 알고리즘이 사용되며, 그렇지 않으면 PKCS # 1 v1.5가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="725a324c83bff5484063c9fb79ed06b1a642a7c9" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.</source>
          <target state="translated">표지판은 사적으로 소화하여 랜드에서 무작위로 읽습니다. opts 인수는 현재 사용되지 않지만 crypto.Signer 인터페이스와 함께 메시지를 요약하는 데 사용되는 해시 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5cc6baa9959aae2928064eeabac37026d1fdd3" translate="yes" xml:space="preserve">
          <source>Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts.</source>
          <target state="translated">Sign은 주어진 메시지를 priv에 서명합니다. Ed25519는 서명 할 메시지를 두 번 전달하므로 미리 해시 된 메시지를 처리 ​​할 수 ​​없습니다. 따라서 opts.HashFunc ()는 메시지가 해시되지 않았 음을 나타 내기 위해 0을 반환해야합니다. 이것은 opts의 값으로 crypto.Hash (0)을 전달하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d9bc9097d624689f3abd051873c0827e390ddd8" translate="yes" xml:space="preserve">
          <source>Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize.</source>
          <target state="translated">서명은 메시지를 privateKey로 서명하고 서명을 리턴합니다. len (privateKey)가 PrivateKeySize가 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="73058d5661f51255d2d044bad5e22d1dbeb1615f" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15</source>
          <target state="translated">SignPKCS1v15</target>
        </trans-unit>
        <trans-unit id="76a7f1a903c9bd79d05146e331e0afbf510916e4" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15는 RSA PKCS # 1 v1.5의 RSASSA-PKCS1-V1_5-SIGN을 사용하여 해시 된 서명을 계산합니다. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과 여야합니다. 해시가 0이면 해시가 직접 서명됩니다. 상호 운용성을 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dc02ffb85c827150cad191cf75b74252c850c11" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">SignPSS는 RSASSA-PSS를 사용하여 해시 된 서명을 계산합니다 [1]. 해시는 주어진 해시 함수를 사용하여 입력 메시지를 해시 한 결과 여야합니다. opts 인수는 nil 일 수 있으며이 경우 적절한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="456ecb37c3fc5855213ab977448f009637d487e9" translate="yes" xml:space="preserve">
          <source>Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.</source>
          <target state="translated">신호는 프로세스로 신호를 보냅니다. Windows에서 전송 인터럽트가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="113054b65e3d478c55ce8ee9e7136eef91adbb6a" translate="yes" xml:space="preserve">
          <source>Signal wakes one goroutine waiting on c, if there is any.</source>
          <target state="translated">신호가 있으면 c에서 하나의 고 루틴 대기를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="9a761dffcc7f2df5b531ae01c6e9c1d10354c3aa" translate="yes" xml:space="preserve">
          <source>Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.</source>
          <target state="translated">신호는 주로 유닉스 계열 시스템에서 사용됩니다. Windows 및 Plan 9에서이 패키지를 사용하려면 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be08fe4d5181cd9a339446858cf8e98d5d370ad9" translate="yes" xml:space="preserve">
          <source>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.</source>
          <target state="translated">SignatureScheme은 TLS가 지원하는 서명 알고리즘을 식별합니다. RFC 8446, 섹션 4.2.3을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72364e765319ca6184606bdfcbeaf4bae3efe083" translate="yes" xml:space="preserve">
          <source>Signbit reports whether x is negative or negative zero.</source>
          <target state="translated">Signbit은 x가 음수인지 음수인지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="06f0622cc55ee3b1ba8ef5291dd67f388a633bbf" translate="yes" xml:space="preserve">
          <source>Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.</source>
          <target state="translated">부호있는 정수는 부호있는 정수 변수 int, int16 등으로 수신 될 수 있습니다. 부호없는 정수는 부호없는 정수 변수로 수신 될 수 있습니다. 부동 소수점 값은 임의의 부동 소수점 변수로 수신 될 수있다. 그러나 대상 변수가 값을 나타낼 수 있어야합니다. 그렇지 않으면 디코딩 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae900b849a1bf306b492bb9034be4bb3bc19b163" translate="yes" xml:space="preserve">
          <source>Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.</source>
          <target state="translated">서명자는 서명 작업에 사용할 수있는 불투명 개인 키에 대한 인터페이스입니다. 예를 들어, RSA 키는 하드웨어 모듈에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="38f4531ed194c331b7b23a6d3502ef6906c2f74a" translate="yes" xml:space="preserve">
          <source>SignerOpts contains options for signing with a Signer.</source>
          <target state="translated">SignerOpts에는 서명자와의 서명을위한 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="966d50452c96c3fa11f316a011f44cf776d22a17" translate="yes" xml:space="preserve">
          <source>SimpleFold</source>
          <target state="translated">SimpleFold</target>
        </trans-unit>
        <trans-unit id="8bf97e6e8efa121264307227008493331dea504d" translate="yes" xml:space="preserve">
          <source>SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &amp;gt; r if one exists, or else the smallest rune &amp;gt;= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.</source>
          <target state="translated">SimpleFold는 유니 코드로 정의 된 간단한 대소 문자 접음에서 동등한 유니 코드 코드 포인트를 반복합니다. 룬 (루프 자체 포함)과 동등한 코드 포인트 중에서 SimpleFold는 가장 작은 룬&amp;gt; r (있는 경우) 또는 가장 작은 룬&amp;gt; = 0을 반환합니다. r이 유효한 유니 코드 코드 포인트가 아닌 경우 SimpleFold (r)는 r을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b27adf68197f928a987f44243ba3dcfcda229444" translate="yes" xml:space="preserve">
          <source>Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.</source>
          <target state="translated">Simplify는 반복 횟수를 제외하고 / (?: a +) + /를 / a + /로 다시 쓰는 것과 같은 다양한 다른 단순화를 사용하여 정규 표현식을 반환합니다. 결과 정규 표현식은 올바르게 실행되지만 캡처 괄호가 복제되거나 제거되었을 수 있으므로 문자열 표현이 동일한 구문 분석 트리를 생성하지 않습니다. 예를 들어, / (x) {1,2} /의 단순화 된 형식은 / (x) (x)? /이지만 두 괄호는 $ 1로 캡처됩니다. 반환 된 정규 표현식은 구조를 공유하거나 원본 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1baaf4288309b641acaf8ca1164546c4028a35a7" translate="yes" xml:space="preserve">
          <source>Sin</source>
          <target state="translated">Sin</target>
        </trans-unit>
        <trans-unit id="60fef841296be9ebf7de4bce978c61ea99668ac2" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of the radian argument x.</source>
          <target state="translated">Sin은 라디안 인수 x의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d7deeeba21d579c050c2a33e2db608612f16ced" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of x.</source>
          <target state="translated">Sin은 x의 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="032d0e9143af25fee0463a47b08e83403e61fbe1" translate="yes" xml:space="preserve">
          <source>Since os.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="translated">os.FileInfo의 Name 메소드는 설명하는 파일의 기본 이름 만 리턴하므로 파일의 전체 경로 이름을 제공하도록 Header.Name을 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67e676cda98cae04b5ce1604ab8e9db4fbb0636" translate="yes" xml:space="preserve">
          <source>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).</source>
          <target state="translated">이후 t 이후 경과 된 시간을 리턴합니다. time.Now (). Sub (t)의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="4aada6d4483746dcd60dcf298d86136630d9cd91" translate="yes" xml:space="preserve">
          <source>Sincos</source>
          <target state="translated">Sincos</target>
        </trans-unit>
        <trans-unit id="602eea7f1523e01bb1b745122d12becc2cb4a99c" translate="yes" xml:space="preserve">
          <source>Sincos returns Sin(x), Cos(x).</source>
          <target state="translated">Sincos는 Sin (x), Cos (x)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc9965f20c0e26db0501d3424c1430869ed3389f" translate="yes" xml:space="preserve">
          <source>Single characters:</source>
          <target state="translated">단일 문자 :</target>
        </trans-unit>
        <trans-unit id="e5d65368cdcef8d43d81f8b1167171bcc9e4d453" translate="yes" xml:space="preserve">
          <source>Sinh</source>
          <target state="translated">Sinh</target>
        </trans-unit>
        <trans-unit id="f35b8f7d99b41bcac88dc066f89ded4a25031767" translate="yes" xml:space="preserve">
          <source>Sinh returns the hyperbolic sine of x.</source>
          <target state="translated">Sinh는 x의 쌍곡 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d9b9bb8ffbb101e667ceeb0c6df4b2d00eca63e" translate="yes" xml:space="preserve">
          <source>Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.</source>
          <target state="translated">Size는 값 v를 고정하기 위해 Write가 생성 할 바이트 수를 반환합니다. v는 고정 크기 값 또는 고정 크기 값의 슬라이스이거나 이러한 데이터에 대한 포인터 여야합니다. v가이 중 하나가 아닌 경우 Size는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07f99b9766acbd34a40dce6ae52199b1df82e565" translate="yes" xml:space="preserve">
          <source>Size returns r's width and height.</source>
          <target state="translated">크기는 r의 너비와 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08603885cb8f4581e6caff80c9587384030d6fb2" translate="yes" xml:space="preserve">
          <source>Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.</source>
          <target state="translated">Size는 주어진 해시 함수로 인한 다이제스트의 길이를 바이트 단위로 반환합니다. 문제의 해시 함수가 프로그램에 연결될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e25ab5f340eca2d7c5b223c77e15ee75cde585ef" translate="yes" xml:space="preserve">
          <source>Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.</source>
          <target state="translated">크기는 계수 크기를 바이트 단위로 반환합니다. 이 공개 키에 대한 원시 서명 및 암호문의 크기는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e670e1a5854b86fb3e790eec7802ceb4072867ce" translate="yes" xml:space="preserve">
          <source>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.</source>
          <target state="translated">Size는 마스크의 선행 및 총 비트 수를 반환합니다. 마스크가 정식 형식이 아닌 경우 (1과 0), Size는 0, 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e50e49a71b6948817b0c75a5802d436dcfbbd3d4" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size는 기본 바이트 슬라이스의 원래 길이를 반환합니다. 크기는 ReadAt를 통해 읽을 수있는 바이트 수입니다. 리턴 된 값은 항상 동일하며 다른 메소드에 대한 호출의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20090954ae229cf40fcf85ad90018bc0a50c14a6" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size는 기본 문자열의 원래 길이를 반환합니다. 크기는 ReadAt를 통해 읽을 수있는 바이트 수입니다. 리턴 된 값은 항상 동일하며 다른 메소드에 대한 호출의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a0d609fe825a666e200f379bb9b290e727375b4" translate="yes" xml:space="preserve">
          <source>Size returns the size of file f as registered with AddFile.</source>
          <target state="translated">Size는 AddFile에 등록 된 파일 f의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5716d3e163196d9c451e87a39bff7287017defa9" translate="yes" xml:space="preserve">
          <source>Size returns the size of the section in bytes.</source>
          <target state="translated">Size는 섹션의 크기를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33687cc2c12d65398be28bdfb49be5c9af20dea4" translate="yes" xml:space="preserve">
          <source>Size returns the size of the underlying buffer in bytes.</source>
          <target state="translated">Size는 기본 버퍼의 크기를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad326c620cb25aa3f6f88fe50584af3756cb7137" translate="yes" xml:space="preserve">
          <source>Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. The return value of Sizeof is a Go constant.</source>
          <target state="translated">Sizeof는 모든 유형의 표현식 x를 취하고 마치 v가 var v = x를 통해 선언 된 것처럼 가상 변수 v의 크기를 바이트 단위로 반환합니다. 크기는 x가 참조 할 수있는 메모리를 포함하지 않습니다. 예를 들어, x가 슬라이스 인 경우 Sizeof는 슬라이스가 참조하는 메모리의 크기가 아니라 슬라이스 디스크립터의 크기를 반환합니다. Sizeof의 반환 값은 Go 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b19905df7d36355c364fc4d465be7029063705c6" translate="yes" xml:space="preserve">
          <source>Sizes defines the sizing functions for package unsafe.</source>
          <target state="translated">크기는 안전하지 않은 패키지의 크기 조정 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="58588dd4d69fcc2bebbb32cb3311a65197ef6d80" translate="yes" xml:space="preserve">
          <source>SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.</source>
          <target state="translated">SizesFor는 아키텍처에서 컴파일러가 사용한 크기를 반환합니다. 컴파일러 / 아키텍처 쌍을 알 수없는 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="f2bf90f6b1f23cb7aca2de8f99806d297f79d8f6" translate="yes" xml:space="preserve">
          <source>Skip is equivalent to Log followed by SkipNow.</source>
          <target state="translated">건너 뛰기는 Log 다음에 SkipNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="16403f951a4dfc8a1c243a0f8eb301e145aaacf2" translate="yes" xml:space="preserve">
          <source>Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.</source>
          <target state="translated">Skip은 이미 사용한 가장 최근의 시작 요소와 일치하는 끝 요소를 사용할 때까지 토큰을 읽습니다. 시작 요소가 발견되면 반복되므로 중첩 구조를 건너 뛰는 데 사용할 수 있습니다. 시작 요소와 일치하는 끝 요소를 찾으면 nil을 리턴합니다. 그렇지 않으면 문제를 설명하는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70514769bf0cf43aa1fd9a8170e861cfc268114d" translate="yes" xml:space="preserve">
          <source>SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.</source>
          <target state="translated">SkipChildren은 Next에서 반환 한 마지막 항목과 관련된 하위 항목을 건너 뜁니다. 해당 항목에 자식이 없거나 다음이 호출되지 않은 경우 SkipChildren은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="306f2cf9cd44bb1158534a5fe5beb03317afa4af" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="translated">SkipDir은 WalkFuncs의 반환 값으로 사용되어 호출에 이름이 지정된 디렉토리를 건너 뛸 것임을 나타냅니다. 어떤 함수에서도 오류로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9f977172633094ba7da3e08af3ab05c0c517aa4" translate="yes" xml:space="preserve">
          <source>SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.</source>
          <target state="translated">SkipNow는 테스트를 건너 뛴 것으로 표시하고 runtime.Goexit를 호출하여 실행을 중지합니다. 테스트가 실패하고 (오류, 오류, 실패 참조) 건너 뛴 경우 여전히 실패한 것으로 간주됩니다. 다음 테스트 또는 벤치 마크에서 실행이 계속됩니다. FailNow를 참조하십시오. SkipNow는 테스트 중에 생성 된 다른 고 루틴이 아니라 테스트를 실행하는 고 루틴에서 호출해야합니다. SkipNow를 호출해도 다른 고 루틴은 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="332b0733aeb219d3842af5da1737b4332e8bb58a" translate="yes" xml:space="preserve">
          <source>Skipf is equivalent to Logf followed by SkipNow.</source>
          <target state="translated">Skipf는 Logf 다음에 SkipNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="416b07f26916aed7cb9e2ecd9aa8ab976885e47e" translate="yes" xml:space="preserve">
          <source>Skipped reports whether the test was skipped.</source>
          <target state="translated">생략은 테스트를 생략했는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="22c22c92516b167e48a8850862fd9d43b049ad6a" translate="yes" xml:space="preserve">
          <source>Skipping</source>
          <target state="translated">Skipping</target>
        </trans-unit>
        <trans-unit id="3cac34e674464c2b62286054cd9a2d2c81149efc" translate="yes" xml:space="preserve">
          <source>Sleep</source>
          <target state="translated">Sleep</target>
        </trans-unit>
        <trans-unit id="53bb6e499b626b0d907f8d7f80059af55f685b40" translate="yes" xml:space="preserve">
          <source>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</source>
          <target state="translated">휴면은 최소 지속 시간 동안 현재 고 루틴을 일시 중지합니다 d. 기간이 음수이거나 0이면 절전 모드가 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="4972372ab292852581dde17e7410c1a0a34536d2" translate="yes" xml:space="preserve">
          <source>Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">슬라이스는 v [i : j]를 반환합니다. v의 종류가 배열, 슬라이스 또는 문자열이 아니거나 v가 주소를 지정할 수없는 배열이거나 인덱스가 범위를 벗어난 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f664f65e07ee83c0603b67c75f98aa98e653bee6" translate="yes" xml:space="preserve">
          <source>Slice sorts the provided slice given the provided less function.</source>
          <target state="translated">슬라이스는 제공된 축소 기능을 제공하여 제공된 슬라이스를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="c9c2b1fb38f90f114fb07f736146472316c1fd01" translate="yes" xml:space="preserve">
          <source>Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;amp;x[0] == &amp;amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.</source>
          <target state="translated">다음 값이 모두 참이면 슬라이스 값이 완전히 동일합니다.이 값은 모두 0이거나 0이 아닌 값이며 모두 같은 길이이며 동일한 기본 배열의 동일한 초기 항목을 가리 킵니다 (즉, &amp;amp; x [0 ] == &amp;amp; y [0]) 또는 해당 요소 (최대 길이)는 매우 같습니다. 0이 아닌 빈 슬라이스와 0이 아닌 슬라이스 (예 : [] byte {} 및 [] byte (nil))는 서로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187ce922ba02cf6f5feb1dc1495c357805a44a28" translate="yes" xml:space="preserve">
          <source>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice3은 슬라이스 작업의 3 가지 인덱스 형식으로 v [i : j : k]를 반환합니다. v의 Kind가 배열 또는 슬라이스가 아니거나 v가 주소를 지정할 수없는 배열이거나 인덱스가 범위를 벗어난 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="036571bfad79ab866cb35b30d706649dfea91e3e" translate="yes" xml:space="preserve">
          <source>Slice:</source>
          <target state="translated">Slice:</target>
        </trans-unit>
        <trans-unit id="0294a1ce63eca0958f1a3380376dd5b3772daeaa" translate="yes" xml:space="preserve">
          <source>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">SliceHeader는 슬라이스의 런타임 표현입니다. 안전하게 또는 이식 가능하게 사용할 수 없으며 이후 릴리스에서 표현이 변경 될 수 있습니다. 또한 데이터 필드는 참조하는 데이터가 가비지 수집되지 않도록 보장하기에 충분하지 않으므로 프로그램은 기본 데이터에 대해 올바르게 입력 된 별도의 포인터를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="c22ee253fc38582e76e1a487b795c3ec911e294a" translate="yes" xml:space="preserve">
          <source>SliceIsSorted tests whether a slice is sorted.</source>
          <target state="translated">SliceIsSorted는 슬라이스가 정렬되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="45eaaaf070f6c38ebb684650d2e76ac52a7e3905" translate="yes" xml:space="preserve">
          <source>SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</source>
          <target state="translated">SliceOf는 요소 유형이 t 인 슬라이스 유형을 반환합니다. 예를 들어, t가 int를 나타내는 경우 SliceOf (t)는 [] int를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3f5d8267a68290ad1478266ac0100b64a9ec9d9" translate="yes" xml:space="preserve">
          <source>SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).</source>
          <target state="translated">SlicePtrFromStrings는 문자열 슬라이스를 NUL 종료 바이트 배열에 대한 포인터 슬라이스로 변환합니다. 문자열에 NUL 바이트가 포함되어 있으면 (nil, EINVAL)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c864d92c212ef8abfd9b5a7229b7d9cb38de7a2" translate="yes" xml:space="preserve">
          <source>SliceStable</source>
          <target state="translated">SliceStable</target>
        </trans-unit>
        <trans-unit id="291aafdf1861d62c9bc50f1c83d1800a3cb0913c" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.</source>
          <target state="translated">SliceStable은 동일한 요소의 원래 순서를 유지하면서 제공된 적은 기능을 제공하여 제공된 슬라이스를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="24220363f4bcd3c6462dbe1e7e4afff4012817f0" translate="yes" xml:space="preserve">
          <source>Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method.</source>
          <target state="translated">리턴 된 토큰 데이터의 바이트 조각은 구문 분석기의 내부 버퍼를 참조하고 다음에 토큰을 호출 할 때까지만 유효합니다. 바이트의 복사본을 얻으려면 CopyToken 또는 토큰의 Copy 메서드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fc7f681747838baecdc0ee29795205530bc0b270" translate="yes" xml:space="preserve">
          <source>SocketControlMessage represents a socket control message.</source>
          <target state="translated">SocketControlMessage는 소켓 제어 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4457c2edf950c3c3e9063b3a5f5427cad62d71ba" translate="yes" xml:space="preserve">
          <source>Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.</source>
          <target state="translated">일부 프로토콜은 사용자 이름과 비밀번호를 미리 이스케이프 처리하는 데 추가 요구 사항을 부과 할 수 있습니다. 예를 들어, OAuth2와 함께 사용되는 경우 두 인수 모두 url.QueryEscape로 먼저 URL 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c5ca797beb6df3a3a7d32f3dea277a5bafd3c" translate="yes" xml:space="preserve">
          <source>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.</source>
          <target state="translated">일부 유효한 레이아웃은 시간에 대해 유효하지 않은 시간 값입니다. 공간 패딩의 경우 _, 영역 정보의 경우 Z와 같은 형식으로 인해 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="89fbdcfdf1cfcd667a49cfe3f7c3c0bdc4ce5124" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method.</source>
          <target state="translated">정렬은 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f520ad1ca9ea89523277ded79bfeb4e271e735a8" translate="yes" xml:space="preserve">
          <source>Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.</source>
          <target state="translated">정렬은 ErrorList를 정렬합니다. * 오류 항목은 위치별로 정렬되고 다른 오류는 오류 메시지 및 * 오류 항목보다 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bf7dfcfaee16c58648d64101d25f3215cc22e2" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="translated">정렬은 데이터를 정렬합니다. 데이터를 한 번 호출합니다 .n을 결정하려면 렌을, O (n * log (n))는 데이터를 호출합니다 .Less and data.Swap. 정렬이 안정적으로 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="decd49ac7a46241d55346a11f6d2fb74335dc7a9" translate="yes" xml:space="preserve">
          <source>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.</source>
          <target state="translated">SortImports는 f의 가져 오기 블록에서 연속 가져 오기 행 실행을 정렬합니다. 또한 데이터 손실없이 가능한 경우 중복 가져 오기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6e2693fb2fa2b916dd95d972bbcb32b0b6b566ec" translate="yes" xml:space="preserve">
          <source>Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.</source>
          <target state="translated">소스는 표준 gofmt 스타일로 src를 포맷하고 결과 또는 (I / O 또는 구문) 오류를 반환합니다. src는 구문 상 올바른 Go 소스 파일이거나 Go 선언 또는 명령문 목록이어야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
