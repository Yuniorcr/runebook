<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="a91bed1365204e8353c0f745ca77893ae1b1305d" translate="yes" xml:space="preserve">
          <source>Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes.</source>
          <target state="translated">bool 유형의 소스 값은 * bool, * interface {}, * string, * [] byte 또는 * RawBytes 유형으로 스캔 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd3cd23d4f7a4635c360a861ee7be174fed76cc" translate="yes" xml:space="preserve">
          <source>Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.RFC3339Nano is used.</source>
          <target state="translated">time.Time 유형의 소스 값 * time.Time, * interface {}, * string 또는 * [] byte 유형의 값으로 스캔 될 수 있습니다. 후자 2 개로 변환 할 때는 time.RFC3339Nano가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdf6d7926b72078af0c191b3c6238538d7b0cb1" translate="yes" xml:space="preserve">
          <source>Special case is:</source>
          <target state="translated">특별한 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38cf2e1ac5d0bfa814379b9cb5b1a8aad4c71895" translate="yes" xml:space="preserve">
          <source>Special cases are (in order):</source>
          <target state="translated">특별한 경우는 (순서대로) :</target>
        </trans-unit>
        <trans-unit id="36ff1c61fcf6a6f96273c5129f496e6e2d52bc61" translate="yes" xml:space="preserve">
          <source>Special cases are the same as Exp.</source>
          <target state="translated">특별한 경우는 Exp와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb4f18f6f604123235431e09b3313991f0bb526d" translate="yes" xml:space="preserve">
          <source>Special cases are:</source>
          <target state="translated">특별한 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46044fc293a1827aa7aed188a242765b1470a9ed" translate="yes" xml:space="preserve">
          <source>Special section indices.</source>
          <target state="translated">특별 섹션 지수.</target>
        </trans-unit>
        <trans-unit id="a2fde335dab74ce6562dfce419b45cb58e70ab07" translate="yes" xml:space="preserve">
          <source>SpecialCase</source>
          <target state="translated">SpecialCase</target>
        </trans-unit>
        <trans-unit id="47398a3a12335bdb3df057e3646557b1b5841333" translate="yes" xml:space="preserve">
          <source>SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.</source>
          <target state="translated">SpecialCase는 터키어와 같은 언어 별 사례 매핑을 나타냅니다. SpecialCase의 메소드는 표준 맵핑을 사용자 정의 (재정의)합니다.</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="23392488f19a5d0be8c39d3cfafde4dd76bd94be" translate="yes" xml:space="preserve">
          <source>Split panics if it is called after scanning has started.</source>
          <target state="translated">스캔이 시작된 후 호출되면 패닉이 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="96e564d2bf5c731af05562ed176616a9d55a5e64" translate="yes" xml:space="preserve">
          <source>Split sets the split function for the Scanner. The default split function is ScanLines.</source>
          <target state="translated">분할은 스캐너의 분할 기능을 설정합니다. 기본 분할 기능은 ScanLines입니다.</target>
        </trans-unit>
        <trans-unit id="eb475bc85cdb49a4c4de00518ab4efe39bcec33e" translate="yes" xml:space="preserve">
          <source>Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">슬라이스를 sep로 분리 한 모든 하위 슬라이스로 분할하고 해당 구분 기호 사이에서 하위 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 Split은 각 UTF-8 시퀀스 후에 분할됩니다. 카운트가 -1 인 SplitN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67dbafd6c3b93902b18d8f321af8549a1b6ad6e7" translate="yes" xml:space="preserve">
          <source>Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">슬라이스를 sep로 구분 된 모든 하위 문자열로 분할하고 해당 구분 기호 사이의 하위 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a1469b01e576340018d58bd7e3d302e90dee09f" translate="yes" xml:space="preserve">
          <source>Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.</source>
          <target state="translated">슬라이스를 표현식으로 구분 된 서브 스트링으로 분할하고 해당 표현식 일치 사이의 서브 스트링 슬라이스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="817430fe1883828acde2ae90d1a5b512a8d87c1e" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">분할은 최종 구분 기호 바로 다음에 경로를 디렉토리와 파일 이름 구성 요소로 분리하여 분할합니다. 경로에 구분 기호가 없으면 Split은 빈 디렉토리와 파일 세트를 경로로 반환합니다. 리턴 된 값에는 path = dir + file 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04097266465adc5300d2bc3091a77206398acddf" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">분할은 마지막 슬래시 바로 다음에 경로를 분할하여 디렉토리와 파일 이름 구성 요소로 분리합니다. 경로에 슬래시가 없으면 Split은 빈 디렉토리와 파일 세트를 경로로 반환합니다. 리턴 된 값에는 path = dir + file 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f645051fa0ea9f5fba674ae30e0eb8228c563bbb" translate="yes" xml:space="preserve">
          <source>SplitAfter</source>
          <target state="translated">SplitAfter</target>
        </trans-unit>
        <trans-unit id="af6f57e26d6655b8a560ff5a1ea503e038967615" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">SplitAfter 슬라이스는 sep의 각 인스턴스 이후에 모든 서브 슬라이스로 슬라이스하고 해당 서브 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 SplitAfter는 각 UTF-8 시퀀스 후에 분할됩니다. 카운트가 -1 인 SplitAfterN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b96a1319471e70dc0744f490b304d8e5292e091" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfter는 sep의 각 인스턴스 다음에있는 모든 하위 문자열로 슬라이스하고 해당 하위 문자열의 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="183e10127881bddc63e39844aca6fde7b55ad84d" translate="yes" xml:space="preserve">
          <source>SplitAfterN</source>
          <target state="translated">SplitAfterN</target>
        </trans-unit>
        <trans-unit id="71c5d7e2f9fd13201867043dfefbd28be7cef909" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitAfterN 슬라이스는 sep의 각 인스턴스 후에 s를 서브 슬라이스로 슬라이스하고 해당 서브 슬라이스의 슬라이스를 반환합니다. sep가 비어 있으면 SplitAfterN은 각 UTF-8 시퀀스 후에 분할됩니다. 개수는 반환 할 하위 슬라이스 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b953b958d37f7636fa29a91139b9e599462e7d0a" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfterN은 sep의 각 인스턴스 후에 s를 하위 문자열로 자르고 해당 하위 문자열의 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c42d1c66abbb920d11fa3452a55d6b02ca57969f" translate="yes" xml:space="preserve">
          <source>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.</source>
          <target state="translated">SplitFunc는 입력을 토큰 화하는 데 사용되는 split 함수의 서명입니다. 인수는 처리되지 않은 나머지 데이터의 초기 서브 스트링과 Reader에 더 이상 제공 할 데이터가 없는지 여부를보고하는 플래그 atEOF입니다. 리턴 값은 입력을 진행시키기위한 바이트 수와 사용자에게 리턴 할 다음 토큰 (있는 경우)과 오류 (있는 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="b4cd81f732cbd3a8923ecb19ba58f0f16cb90789" translate="yes" xml:space="preserve">
          <source>SplitHostPort splits a network address of the form &quot;host:port&quot;, &quot;host%zone:port&quot;, &quot;[host]:port&quot; or &quot;[host%zone]:port&quot; into host or host%zone and port.</source>
          <target state="translated">SplitHostPort는 &quot;host : port&quot;, &quot;host % zone : port&quot;, &quot;[host] : port&quot;또는 &quot;[host % zone] : port&quot;형식의 네트워크 주소를 호스트 또는 호스트 % zone 및 포트로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="83d28a087df2085b354d9219f029b5d90cf38ec4" translate="yes" xml:space="preserve">
          <source>SplitList</source>
          <target state="translated">SplitList</target>
        </trans-unit>
        <trans-unit id="2810f9f5e2566aed968386693eafb51ff308b597" translate="yes" xml:space="preserve">
          <source>SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.</source>
          <target state="translated">SplitList는 일반적으로 PATH 또는 GOPATH 환경 변수에있는 OS 별 ListSeparator로 조인 된 경로 목록을 분할합니다. 문자열과 달리 SplitList는 빈 문자열을 전달하면 빈 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84cfaf9bc325cc024ba8d73b2f03f1f0b940f375" translate="yes" xml:space="preserve">
          <source>SplitN</source>
          <target state="translated">SplitN</target>
        </trans-unit>
        <trans-unit id="36c3c8ea011f7ef62da6893e010962d6852bd07a" translate="yes" xml:space="preserve">
          <source>SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitN 슬라이스는 sep로 분리 된 서브 슬라이스로 분리하고 해당 분리 기호 사이의 서브 슬라이스 슬라이스를 반환합니다. sep가 비어 있으면 SplitN은 각 UTF-8 시퀀스 후에 분할됩니다. 개수는 반환 할 하위 슬라이스 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="de01961453e6bcc30ddd7714ed914f746f011fab" translate="yes" xml:space="preserve">
          <source>SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">SplitN 슬라이스는 sep로 구분 된 하위 문자열로 분리하고 해당 구분 기호 사이의 하위 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ca15484a6a50617febf823f3fa1c9e7038688ee" translate="yes" xml:space="preserve">
          <source>Sprint</source>
          <target state="translated">Sprint</target>
        </trans-unit>
        <trans-unit id="d0775164f7f53356c293723cd9c1222468d3a49b" translate="yes" xml:space="preserve">
          <source>Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.</source>
          <target state="translated">피연산자에 기본 형식을 사용하여 스프린트 형식을 지정하고 결과 문자열을 반환합니다. 문자열이 아닌 경우 피연산자 사이에 공백이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5fe7cc61bbb8158ad630a3820e3c126928a4a6" translate="yes" xml:space="preserve">
          <source>Sprintf</source>
          <target state="translated">Sprintf</target>
        </trans-unit>
        <trans-unit id="5bfb46358289368784772aa4aa5a217258b76236" translate="yes" xml:space="preserve">
          <source>Sprintf formats according to a format specifier and returns the resulting string.</source>
          <target state="translated">Sprintf는 형식 지정자에 따라 형식을 지정하고 결과 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5446f67533b2f88354fccb3b84fed81fd676a9d5" translate="yes" xml:space="preserve">
          <source>Sprintln</source>
          <target state="translated">Sprintln</target>
        </trans-unit>
        <trans-unit id="d0bd83b3300fd81e26aa39c136cc9d6ce11bb5a7" translate="yes" xml:space="preserve">
          <source>Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.</source>
          <target state="translated">피연산자에 기본 형식을 사용하여 Sprintln 형식을 지정하고 결과 문자열을 반환합니다. 피연산자 사이에 공백이 항상 추가되고 줄 바꾸기가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6bbb118b36018412cea4de47bc914f00685c9ac5" translate="yes" xml:space="preserve">
          <source>Sqrt</source>
          <target state="translated">Sqrt</target>
        </trans-unit>
        <trans-unit id="1b795ae9b134bc8c4c0b446e88fecc1f3b41d092" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x.</source>
          <target state="translated">Sqrt는 x의 제곱근을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b85c9b396b0e4464f48aa17058f2b1082008ae70" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x. The result r is chosen so that real(r) &amp;ge; 0 and imag(r) has the same sign as imag(x).</source>
          <target state="translated">Sqrt는 x의 제곱근을 반환합니다. 결과 r은 real (r) &amp;ge; 0 및 imag (r)이 imag (x)와 같은 부호를 갖도록 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="41b5f4c2f86ca750aabbdd4d6bdb915be0584893" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to &amp;lfloor;&amp;radic;x&amp;rfloor;, the largest integer such that z&amp;sup2; &amp;le; x, and returns z. It panics if x is negative.</source>
          <target state="translated">Sqrt는 z를 &amp;sup2;&amp;radic;x&amp;rfloor;로 설정하여 z&amp;sup2; &amp;le; x와 같은 가장 큰 정수이며 z를 반환합니다. x가 음수이면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e519fcfbc6a90ddf75f1394fae55598d7af8898" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to the rounded square root of x, and returns it.</source>
          <target state="translated">Sqrt는 z를 x의 둥근 제곱근으로 설정하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b183229b8a0007179105ee23f98db0fa35e992ca" translate="yes" xml:space="preserve">
          <source>SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist.</source>
          <target state="translated">SrcDirs는 패키지 소스 루트 디렉토리 목록을 리턴합니다. 현재 Go 루트 및 Go 경로에서 가져 오지만 존재하지 않는 디렉토리는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ace37ead62176f4b0fef73d8a4e6eefe6e4e0808" translate="yes" xml:space="preserve">
          <source>Srcset encapsulates a known safe srcset attribute (see &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;).</source>
          <target state="translated">Srcset은 알려진 안전한 srcset 속성을 캡슐화합니다 ( &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="608729966442ded3bea906aefa46d7a131fb981c" translate="yes" xml:space="preserve">
          <source>Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Sscan은 공백으로 구분 된 연속 값을 연속 인수로 저장하여 인수 문자열을 스캔합니다. 줄 바꿈은 공백으로 계산됩니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다.</target>
        </trans-unit>
        <trans-unit id="390342df3a9580b3ab53916d8e78ce9a67e05f51" translate="yes" xml:space="preserve">
          <source>Sscanf</source>
          <target state="translated">Sscanf</target>
        </trans-unit>
        <trans-unit id="61a716d2775c775cb5be05f41652e9aaaad32358" translate="yes" xml:space="preserve">
          <source>Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Sscanf는 인수 문자열을 스캔하여 형식에 의해 결정된대로 연속 공백으로 구분 된 값을 연속 인수로 저장합니다. 성공적으로 구문 분석 된 항목 수를 반환합니다. 입력의 개행은 형식의 개행과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="af4732932dde6aa0c1e4ad7d04d2e2382ec0a0b6" translate="yes" xml:space="preserve">
          <source>Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Sscanln은 Sscan과 비슷하지만 줄 바꿈에서 스캔을 중지하며 마지막 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f3e4b56a56750c728e3e2463bad931f8918a9d7" translate="yes" xml:space="preserve">
          <source>Stable sorts data while keeping the original order of equal elements.</source>
          <target state="translated">안정적인 동일한 요소의 원래 순서를 유지하면서 데이터를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="c9e8e2e8cb17ec7f99a9db77c101e60f6136c3a5" translate="yes" xml:space="preserve">
          <source>Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.</source>
          <target state="translated">Stack은 호출 goroutine의 스택 추적을 buf로 포맷하고 buf에 쓴 바이트 수를 반환합니다. 모두 참이면, 스택은 현재 고 루틴 추적 후 다른 모든 고 루틴의 흔적을 buf로 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="1cffafd303a34a6584721e138e5265f842cb505a" translate="yes" xml:space="preserve">
          <source>Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace.</source>
          <target state="translated">스택은 그것을 호출하는 고 루틴의 형식화 된 스택 추적을 반환합니다. 전체 트레이스를 캡처하기에 충분히 큰 버퍼로 runtime.Stack을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="418aa94a169d739e57a35d99f93d9138e0bb4b62" translate="yes" xml:space="preserve">
          <source>Stack returns the stack trace associated with the record, a prefix of r.Stack0.</source>
          <target state="translated">스택은 r.Stack0의 접두사 인 레코드와 관련된 스택 추적을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="687cb3d7c249eff01be44167736a622ba61578c9" translate="yes" xml:space="preserve">
          <source>Standard colors.</source>
          <target state="translated">표준 색상.</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb1a9f741b4439135087b938ed47613619d8e54" translate="yes" xml:space="preserve">
          <source>Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.</source>
          <target state="translated">시작은 현재 프로그램에 대한 추적을 활성화합니다. 추적하는 동안 추적이 버퍼링되고 w에 기록됩니다. 추적이 이미 사용 가능한 경우 시작은 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d84f21e1e9935e064f3eccc25d6db5d4fb64a86a" translate="yes" xml:space="preserve">
          <source>Start starts a server from NewUnstartedServer.</source>
          <target state="translated">시작은 NewUnstartedServer에서 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b61ef15d781bf8c860427db7964980f61966535c" translate="yes" xml:space="preserve">
          <source>Start starts the specified command but does not wait for it to complete.</source>
          <target state="translated">시작은 지정된 명령을 시작하지만 완료 될 때까지 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f51b09c0923a4603b545c471069b55e22a62f34" translate="yes" xml:space="preserve">
          <source>StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.</source>
          <target state="translated">StartCPUProfile은 현재 프로세스에 대한 CPU 프로파일 링을 활성화합니다. 프로파일 링 중에 프로파일이 버퍼링되고 w에 기록됩니다. 프로파일 링이 이미 활성화 된 경우 StartCPUProfile은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3753321843c42ccf0d93028e612610280e12d5e" translate="yes" xml:space="preserve">
          <source>StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible.</source>
          <target state="translated">StartCond는 일치하는 모든 빈 너비 조건을 반환합니다. 일치하는 항목이 없으면 ^ EmptyOp (0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e00bec2778efe9f0a1a92501d76b773c7dc58166" translate="yes" xml:space="preserve">
          <source>StartProcess is a low-level interface. The os/exec package provides higher-level interfaces.</source>
          <target state="translated">StartProcess는 저수준 인터페이스입니다. os / exec 패키지는보다 높은 수준의 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4656baf99c52e7677cc8f68ccbc8052e39ef42e9" translate="yes" xml:space="preserve">
          <source>StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name.</source>
          <target state="translated">StartProcess는 name, argv 및 attr로 지정된 프로그램, 인수 및 속성으로 새 프로세스를 시작합니다. 새로운 프로세스에서 argv 슬라이스는 os.Args가되므로 일반적으로 프로그램 이름으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d3d2be7776a3d003cee77683d05001ec6ef09966" translate="yes" xml:space="preserve">
          <source>StartProcess wraps ForkExec for package os.</source>
          <target state="translated">StartProcess는 패키지 os를 위해 ForkExec을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="4593c93bfc9fb8dacabfc8b4a1731d4454969f64" translate="yes" xml:space="preserve">
          <source>StartRegion starts a region and returns a function for marking the end of the region. The returned Region's End function must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is</source>
          <target state="translated">StartRegion은 영역을 시작하고 영역의 끝을 표시하는 함수를 반환합니다. 리턴 된 Region의 End 함수는 영역이 시작된 동일한 고 루틴에서 호출되어야합니다. 각 고 루틴 내에서 영역은 중첩되어야합니다. 즉,이 영역 이후에 시작된 영역은이 영역을 종료하기 전에 종료해야합니다. 권장 사용법은</target>
        </trans-unit>
        <trans-unit id="3b719a81fa9e5ddcbfba4cb3fb45c729f487d09e" translate="yes" xml:space="preserve">
          <source>StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id.</source>
          <target state="translated">StartRequest는 주어진 ID로 요청을 보낼 때까지 (또는 서버 인 경우)받을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="338c8f94474f010aa4669ab2c0ae55a5c3a8c12a" translate="yes" xml:space="preserve">
          <source>StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id.</source>
          <target state="translated">StartResponse는 주어진 ID로 요청을 수신 (또는 서버 인 경우 전송) 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="7ea714fe33f9c8708b382ac24930c9134895c05e" translate="yes" xml:space="preserve">
          <source>StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function.</source>
          <target state="translated">StartTLS는 STARTTLS 명령을 전송하고 이후의 모든 통신을 암호화합니다. STARTTLS 확장을 알리는 서버 만이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d062840c5c4653552407064d11c812b2dfbbac16" translate="yes" xml:space="preserve">
          <source>StartTLS starts TLS on a server from NewUnstartedServer.</source>
          <target state="translated">StartTLS는 NewUnstartedServer의 서버에서 TLS를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="01903002ac73fdbc83cec8f016e70281a8a03041" translate="yes" xml:space="preserve">
          <source>StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer.</source>
          <target state="translated">StartTimer는 테스트 타이밍을 시작합니다. 이 기능은 벤치 마크가 시작되기 전에 자동으로 호출되지만 StopTimer 호출 후 타이밍을 재개하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb33cf53f4e568db572c687d22b2ff2888d74df9" translate="yes" xml:space="preserve">
          <source>StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.</source>
          <target state="translated">StartTrace는 현재 프로세스에 대한 추적을 활성화합니다. 추적하는 동안 데이터는 버퍼링되고 ReadTrace를 통해 사용 가능합니다. 추적이 이미 활성화 된 경우 StartTrace는 오류를 반환합니다. 대부분의 클라이언트는 StartTrace를 직접 호출하는 대신 런타임 / 추적 패키지 또는 테스트 패키지의 -test.trace 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de552c394748272d237ee2909c17f8a5fd51503" translate="yes" xml:space="preserve">
          <source>Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported:</source>
          <target state="translated">Go 1.6부터 HTTP 패키지는 HTTPS를 사용할 때 HTTP / 2 프로토콜을 투명하게 지원합니다. HTTP / 2를 비활성화해야하는 프로그램은 Transport.TLSNextProto (클라이언트) 또는 Server.TLSNextProto (서버)를 0이 아닌 빈 맵으로 설정하면됩니다. 또는 다음 GODEBUG 환경 변수가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9c555084811f017d34d2693472b49bb062306f30" translate="yes" xml:space="preserve">
          <source>Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat는 명명 된 파일을 설명하는 FileInfo를 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e4a95458fc56105197c2a964b9366157865cbb1b" translate="yes" xml:space="preserve">
          <source>Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat는 파일을 설명하는 FileInfo 구조를 반환합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6ed6c9c2af9ffd2ea1bfb59989c27d85db3a34df" translate="yes" xml:space="preserve">
          <source>State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.</source>
          <target state="translated">상태는 사용자 정의 포맷터에 전달 된 프린터 상태를 나타냅니다. 피연산자의 형식 지정자에 대한 플래그 및 옵션에 대한 정보와 io.Writer 인터페이스에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6c898e0bae6ae6e6a509998b0d70b717982994c3" translate="yes" xml:space="preserve">
          <source>Static reports whether this symbol is static (not visible outside its file).</source>
          <target state="translated">정적은이 심볼이 정적인지 여부를보고합니다 (파일 외부에서는 볼 수 없음).</target>
        </trans-unit>
        <trans-unit id="f107d6fd99e84eaeb4014efe73efa78374b13f61" translate="yes" xml:space="preserve">
          <source>Stats returns database statistics.</source>
          <target state="translated">통계는 데이터베이스 통계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="473cf8363b9a9dc6de8f9778203d0b0d99ffe820" translate="yes" xml:space="preserve">
          <source>StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.</source>
          <target state="translated">StatusText는 HTTP 상태 코드에 대한 텍스트를 반환합니다. 코드를 알 수 없으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d95efd4b66df751ef4f7e7c0d6a981a761feec31" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding은 RFC 4648에 정의 된 표준 base32 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="a9197d0bbe7d5f346c8fce4d5958e4af36331be4" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base64 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding은 RFC 4648에 정의 된 표준 base64 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="c30cba7f2a4c150acfe65c8a3aa36a9ff709ad57" translate="yes" xml:space="preserve">
          <source>StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:</source>
          <target state="translated">StdSizes는 일반적으로 사용되는 크기를 만들기위한 편리한 유형입니다. 다음과 같은 간단한 가정을합니다.</target>
        </trans-unit>
        <trans-unit id="34f196b4b0f694cd0a2f21247970027005c1305c" translate="yes" xml:space="preserve">
          <source>StderrPipe returns a pipe that will be connected to the command's standard error when the command starts.</source>
          <target state="translated">StderrPipe는 명령이 시작될 때 명령의 표준 오류에 연결될 파이프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9c5224ebb81b29f683fd0f89569f0498e209b24" translate="yes" xml:space="preserve">
          <source>Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.</source>
          <target state="translated">Stdin, Stdout 및 Stderr은 표준 입력, 표준 출력 및 표준 오류 파일 설명자를 가리키는 열린 파일입니다.</target>
        </trans-unit>
        <trans-unit id="eaaa7d5358fae0ad4ea6507594efa4e1fe1938f3" translate="yes" xml:space="preserve">
          <source>StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe.</source>
          <target state="translated">StdinPipe는 명령이 시작될 때 명령의 표준 입력에 연결될 파이프를 반환합니다. 대기 명령이 종료 된 후 파이프가 자동으로 닫힙니다. 호출자는 파이프를 더 빨리 닫으려면 Close 만 호출하면됩니다. 예를 들어, 표준 입력이 닫힐 때까지 실행중인 명령이 종료되지 않으면 호출자는 파이프를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e34e1f63d532ddcb966f6992c5d243530bff512e" translate="yes" xml:space="preserve">
          <source>StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts.</source>
          <target state="translated">StdoutPipe는 명령이 시작될 때 명령의 표준 출력에 연결될 파이프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="35cb1f2f3090469fddd290f48f6f6f66f6cfbf71" translate="yes" xml:space="preserve">
          <source>Stmt</source>
          <target state="translated">Stmt</target>
        </trans-unit>
        <trans-unit id="e8d756b195575772804ef522d92696943863af82" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Stmt는 준비된 진술입니다. Stmt는 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0bb26a3ab8d8618ecc81beec5115670b66a970d5" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently.</source>
          <target state="translated">Stmt는 준비된 진술입니다. Conn에 바인딩되어 있으며 여러 고 루틴에서 동시에 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e8123e57a051d77d8becac273756b24f947f7c4" translate="yes" xml:space="preserve">
          <source>Stmt returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">Stmt는 기존 명령문에서 트랜잭션 별 준비된 명령문을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e2e6090b163c6036190ffea94ddcfbb24b8b882" translate="yes" xml:space="preserve">
          <source>Stmt.QueryRowContext</source>
          <target state="translated">Stmt.QueryRowContext</target>
        </trans-unit>
        <trans-unit id="70af1d64e33ba2bc94ac6b94c7823d3046a2e685" translate="yes" xml:space="preserve">
          <source>StmtContext returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">StmtContext는 기존 명령문에서 트랜잭션 별 준비된 명령문을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a70153fdc2043d42cd12ca46ccb4c33b57b300d4" translate="yes" xml:space="preserve">
          <source>StmtExecContext enhances the Stmt interface by providing Exec with context.</source>
          <target state="translated">StmtExecContext는 Exec에 컨텍스트를 제공하여 Stmt 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="1004fd52a4b277314a44a4efa023effe4416d3f8" translate="yes" xml:space="preserve">
          <source>StmtQueryContext enhances the Stmt interface by providing Query with context.</source>
          <target state="translated">StmtQueryContext는 Query에 컨텍스트를 제공하여 Stmt 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="4e7e607354865ab06dac634d86cb1266a005b9e3" translate="yes" xml:space="preserve">
          <source>Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals.</source>
          <target state="translated">중지는 패키지 신호가 들어오는 신호를 릴레이하는 것을 중지시킵니다. c. c를 사용하여 알림에 대한 모든 이전 호출의 효과를 취소합니다. Stop이 반환되면 c는 더 이상 신호를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94f72ec5a9e9e46f0269677088e9aed4dc6bf0c7" translate="yes" xml:space="preserve">
          <source>Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.</source>
          <target state="translated">중지하면 타이머가 실행되지 않습니다. 호출이 타이머를 중지하면 true를, 타이머가 이미 만료되었거나 중지 된 경우 false를 반환합니다. 채널에서 읽히지 못하도록 채널이 닫히지 않아 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="96e4cceff229f7d0b6242e33e40b44c6e1f954ad" translate="yes" xml:space="preserve">
          <source>Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.</source>
          <target state="translated">중지는 현재 추적을 중지합니다 (있는 경우). 중지는 추적에 대한 모든 쓰기가 완료된 후에 만 ​​리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f869959cdbddc758676d9a0b40b1ccec00a007e0" translate="yes" xml:space="preserve">
          <source>Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous &quot;tick&quot;.</source>
          <target state="translated">중지는 시세를 끕니다. 중지 후에는 더 이상 틱이 전송되지 않습니다. 채널에서 동시 goroutine 판독 값에 잘못된 &quot;틱&quot;이 표시되지 않도록 중지하면 채널이 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c60cc11ce6206ba7285eea9b92d5192efe41d39" translate="yes" xml:space="preserve">
          <source>StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.</source>
          <target state="translated">StopCPUProfile은 현재 CPU 프로필을 중지합니다 (있는 경우). StopCPUProfile은 프로파일에 대한 모든 쓰기가 완료된 후에 만 ​​리턴합니다.</target>
        </trans-unit>
        <trans-unit id="921647073cddc48eae81cacd6f73563cc3719e6f" translate="yes" xml:space="preserve">
          <source>StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.</source>
          <target state="translated">StopTimer는 테스트 타이밍을 중지합니다. 측정하지 않으려는 복잡한 초기화를 수행하는 동안 타이머를 일시 중지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84dbe4eb021745433f9d6bb9432228e77ba19099" translate="yes" xml:space="preserve">
          <source>StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.</source>
          <target state="translated">StopTrace는 이전에 활성화 된 경우 추적을 중지합니다. StopTrace는 추적에 대한 모든 읽기가 완료된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e64cf11d9830120b60f240aa4b7f7791804376a7" translate="yes" xml:space="preserve">
          <source>Store sets the value for a key.</source>
          <target state="translated">Store는 키 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0576297e57bdd6afa5e5d4f4c53fb27987cf20cb" translate="yes" xml:space="preserve">
          <source>Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil).</source>
          <target state="translated">Store는 Value의 값을 x로 설정합니다. 주어진 값에 대한 모든 Store 호출은 동일한 콘크리트 유형의 값을 사용해야합니다. Store (nil)와 마찬가지로 일관성이없는 유형 패닉을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="61fc43e10839248a6ca4c0ad01079c0c4ad0ec37" translate="yes" xml:space="preserve">
          <source>StoreInt32 atomically stores val into *addr.</source>
          <target state="translated">StoreInt32는 원자를 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7914e40a268c91ed6c78dd3a0c674684e23beca2" translate="yes" xml:space="preserve">
          <source>StoreInt64 atomically stores val into *addr.</source>
          <target state="translated">StoreInt64는 원자를 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3bd4e783553f00f03c188a415e3661fa8de191b3" translate="yes" xml:space="preserve">
          <source>StorePointer atomically stores val into *addr.</source>
          <target state="translated">StorePointer는 원자 적으로 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9cc88c9dca1de73040dfd90e6d827a5b531c64fe" translate="yes" xml:space="preserve">
          <source>StoreUint32 atomically stores val into *addr.</source>
          <target state="translated">StoreUint32는 원자 적으로 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e11c1fe521ea309905b20e2bda18135e66472a1e" translate="yes" xml:space="preserve">
          <source>StoreUint64 atomically stores val into *addr.</source>
          <target state="translated">StoreUint64는 원자 적으로 val을 * addr에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="644096d645019d8a2ba6cbc4d305a2699fe9059f" translate="yes" xml:space="preserve">
          <source>StoreUintptr atomically stores val into *addr.</source>
          <target state="translated">StoreUintptr은 val을 * addr에 원자 적으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="cab8594aca23f91dcc0728ca91d9d20dcd26b690" translate="yes" xml:space="preserve">
          <source>StreamReader</source>
          <target state="translated">StreamReader</target>
        </trans-unit>
        <trans-unit id="2a7fc943079fc92f6a989794ba51133e347d57cd" translate="yes" xml:space="preserve">
          <source>StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through.</source>
          <target state="translated">StreamReader는 Stream을 io.Reader로 래핑합니다. XORKeyStream을 호출하여 통과하는 각 데이터 조각을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="232a89f73446348f72f684c82d07ed788b848a3a" translate="yes" xml:space="preserve">
          <source>StreamWriter</source>
          <target state="translated">StreamWriter</target>
        </trans-unit>
        <trans-unit id="fc13aaf005c735ab0e4aa5176b6af67540be3a8b" translate="yes" xml:space="preserve">
          <source>StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data.</source>
          <target state="translated">StreamWriter는 Stream을 io.Writer로 래핑합니다. XORKeyStream을 호출하여 통과하는 각 데이터 조각을 처리합니다. 쓰기 호출이 짧으면 StreamWriter가 동기화되지 않아 버려야합니다. StreamWriter에는 내부 버퍼링이 없습니다. 쓰기 데이터를 플러시하기 위해 Close를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="61135993a6e29b59a8df3075ca0d3838f94b8d90" translate="yes" xml:space="preserve">
          <source>Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.</source>
          <target state="translated">Strict는 엄격한 디코딩이 활성화 된 경우를 제외하고 enc와 동일한 새 인코딩을 만듭니다. 이 모드에서 디코더는 RFC 4648 섹션 3.5에 설명 된대로 후행 패딩 비트가 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="396b00d6c7e8c1194e27297cd11ae3108cdacd84" translate="yes" xml:space="preserve">
          <source>String Conversions</source>
          <target state="translated">문자열 변환</target>
        </trans-unit>
        <trans-unit id="bd47be7c94487cbe10dfe0be4138815d0017463a" translate="yes" xml:space="preserve">
          <source>String and slice of bytes (treated equivalently with these verbs):</source>
          <target state="translated">문자열과 바이트 조각 (이 동사와 동일하게 처리됨) :</target>
        </trans-unit>
        <trans-unit id="8296a76a0e5d96744b29fe69547a88fb9387440d" translate="yes" xml:space="preserve">
          <source>String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.</source>
          <target state="translated">문자열은 지정된 이름, 기본값 및 사용 문자열로 문자열 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 문자열 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="9e4dec141cb0219423f92167f6932232e80cdb9e" translate="yes" xml:space="preserve">
          <source>String extracts string from COFF string table st at offset start.</source>
          <target state="translated">문자열은 오프셋 시작시 COFF 문자열 테이블 st에서 문자열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dcd688eb0f2fbd5e407777a28042b64595f0fef8" translate="yes" xml:space="preserve">
          <source>String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047.</source>
          <target state="translated">문자열은 주소를 유효한 RFC 5322 주소로 형식화합니다. 주소 이름에 ASCII가 아닌 문자가 포함되어 있으면 RFC 2047에 따라 이름이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8d105c469495a5d5f8062e63371ab613869f1e04" translate="yes" xml:space="preserve">
          <source>String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.)</source>
          <target state="translated">x.Text ( 'g', 10)과 같은 문자열 형식 x. 문자열은 명시 적으로 호출해야합니다. Float.Format은 % s 동사를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01748cd6407645feded183980c6258bbb0d669e6" translate="yes" xml:space="preserve">
          <source>String implements the Var interface. To get the unquoted string use Value.</source>
          <target state="translated">문자열은 Var 인터페이스를 구현합니다. 따옴표없는 문자열을 얻으려면 Value를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c388848919b90e3a01d2d3408f1ebde77b3f2a74" translate="yes" xml:space="preserve">
          <source>String is a ValueConverter that converts its input to a string. If the value is already a string or []byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(&quot;%v&quot;, v).</source>
          <target state="translated">String은 입력을 문자열로 변환하는 ValueConverter입니다. 값이 이미 문자열 또는 [] 바이트 인 경우 변경되지 않습니다. 값이 다른 유형 인 경우 문자열 변환은 fmt.Sprintf ( &quot;% v&quot;, v)를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="014933e8c2aa543fd850622d80731a6a9386778b" translate="yes" xml:space="preserve">
          <source>String is a string variable, and satisfies the Var interface.</source>
          <target state="translated">문자열은 문자열 변수이며 Var 인터페이스를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="83826ec6cada0ae1502e1aff2c5460723f559354" translate="yes" xml:space="preserve">
          <source>String reassembles the URL into a valid URL string. The general form of the result is one of:</source>
          <target state="translated">문자열은 URL을 유효한 URL 문자열로 재 조립합니다. 결과의 일반적인 형태는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1a1a1e5164ab79c22ae49942d67ef810bdba6ad9" translate="yes" xml:space="preserve">
          <source>String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.</source>
          <target state="translated">String은 표준 시간대 정보의 이름을 LoadLocation 또는 FixedZone의 이름 인수에 해당하는 설명 적 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d82115db66e350e92f539c5427c79fdfb58ed" translate="yes" xml:space="preserve">
          <source>String returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases.</source>
          <target state="translated">문자열은 사람이 읽을 수있는 c에 대한 설명을 반환합니다. 디버깅 전용입니다. 특히, 쉘 입력으로 사용하기에 적합하지 않습니다. 문자열의 출력은 Go 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bb95d4983983ad2bde74eafe604eb90028dc18" translate="yes" xml:space="preserve">
          <source>String returns a string in one of several forms:</source>
          <target state="translated">문자열은 여러 형식 중 하나로 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="345f70fca28ee043619061f7f87c019dadbba1fa" translate="yes" xml:space="preserve">
          <source>String returns a string representation of p like &quot;(3,4)&quot;.</source>
          <target state="translated">문자열은 &quot;(3,4)&quot;와 같이 p의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3448960ebb659e656c5021f0b36127dab5b9d619" translate="yes" xml:space="preserve">
          <source>String returns a string representation of r like &quot;(3,4)-(6,5)&quot;.</source>
          <target state="translated">문자열은 &quot;(3,4)-(6,5)&quot;와 같은 r의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b35bdca294966810231e9db40a5c473f629af73" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the scope, for debugging.</source>
          <target state="translated">문자열은 디버깅을 위해 범위의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40800a9640894f3a3149f9e54d890572a4beda8c" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">문자열은 대략 RFC 2253 식별 이름 구문에 따라 시퀀스 r의 문자열 표현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a196811cde011797851e8bcd4ea585d5971e7d9" translate="yes" xml:space="preserve">
          <source>String returns a string representation of x in the form &quot;a/b&quot; (even if b == 1).</source>
          <target state="translated">String은 &quot;a / b&quot;형식으로 x의 문자열 표현을 반환합니다 (b == 1 인 경우에도).</target>
        </trans-unit>
        <trans-unit id="7b4474871a59eadc44e6ad3cc370b5d1fd6eabd1" translate="yes" xml:space="preserve">
          <source>String returns a string representing the duration in the form &quot;72h3m0.5s&quot;. Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.</source>
          <target state="translated">문자열은 지속 시간을 나타내는 문자열을 &quot;72h3m0.5s&quot;형식으로 반환합니다. 선행 0 단위는 생략됩니다. 특별한 경우, 1 초 미만의 지속 시간은 더 작은 단위 (밀리 초, 마이크로 초 또는 나노초)를 사용하여 선행 숫자가 0이 아닌지 확인합니다. 지속 시간이 0 인 형식은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f5e00dac202df16525dc65e74932811ab9752d4e" translate="yes" xml:space="preserve">
          <source>String returns a summary of the benchmark results. It follows the benchmark result line format from &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt;, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString.</source>
          <target state="translated">문자열은 벤치 마크 결과의 요약을 반환합니다. 벤치 마크 이름을 포함하지 않고 &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt; 의 벤치 마크 결과 라인 형식을 따릅니다 . 추가 메트릭은 동일한 이름의 내장 메트릭보다 우선합니다. 문자열은 allocs / op 또는 B / op를 포함하지 않습니다. 이러한 문자열은 MemString에 의해보고되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a1320f96272e68242e45787bdcf443a45a5d4acb" translate="yes" xml:space="preserve">
          <source>String returns the CIDR notation of n like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/48&quot; as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like &quot;198.51.100.0/c000ff00&quot;.</source>
          <target state="translated">문자열은 RFC 4632 및 RFC 4291에 정의 된대로 &quot;192.0.2.0/24&quot;또는 &quot;2001 : db8 :: / 48&quot;과 같이 n의 CIDR 표기법을 반환합니다. 마스크가 정식 형식이 아닌 경우에는 구성된 문자열을 반환합니다. &quot;198.51.100.0/c000ff00&quot;과 같이 구두점없이 16 진수 형식으로 표현 된 슬래시 문자와 마스크가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f55b73801df68c7614969aee1732afd9d5e38010" translate="yes" xml:space="preserve">
          <source>String returns the English name of the day (&quot;Sunday&quot;, &quot;Monday&quot;, ...).</source>
          <target state="translated">문자열은 요일의 영어 이름 ( &quot;일요일&quot;, &quot;월요일&quot;, ...)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ffc4d02cde72706d98e09a395ce956d9d89dd7b5" translate="yes" xml:space="preserve">
          <source>String returns the English name of the month (&quot;January&quot;, &quot;February&quot;, ...).</source>
          <target state="translated">문자열은 월의 영어 이름 ( &quot;1 월&quot;, &quot;2 월&quot;, ...)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d35cab9a7681d28fe5cfa98797f716ccf4a8148e" translate="yes" xml:space="preserve">
          <source>String returns the accumulated string.</source>
          <target state="translated">문자열은 누적 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a561a9c0ca3a5d45a6220d79144ae4e4f68eaba" translate="yes" xml:space="preserve">
          <source>String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">문자열은 버퍼의 읽지 않은 부분의 내용을 문자열로 반환합니다. 버퍼가 nil 포인터이면 &quot;&amp;lt;nil&amp;gt;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20281079c25e7469dba253811f0a64eb9af0ad50" translate="yes" xml:space="preserve">
          <source>String returns the decimal representation of x as generated by x.Text(10).</source>
          <target state="translated">String은 x.Text (10)에 의해 생성 된 x의 10 진수 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1f7f34151f59a07d632aef98f6cf3db75ca331f" translate="yes" xml:space="preserve">
          <source>String returns the encoded userinfo information in the standard form of &quot;username[:password]&quot;.</source>
          <target state="translated">문자열은 &quot;username [: password]&quot;의 표준 형식으로 인코딩 된 userinfo 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c9f4b613c07a2c7f71577fe196567617d0abff90" translate="yes" xml:space="preserve">
          <source>String returns the hexadecimal form of m, with no punctuation.</source>
          <target state="translated">문자열은 문장 부호없이 16 진수 형식의 m을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a803d186b1c90a1c53ad70e26c40836efc312842" translate="yes" xml:space="preserve">
          <source>String returns the literal text of the number.</source>
          <target state="translated">문자열은 숫자의 리터럴 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efd718d51f4b6dbacf2db82a320892ae4b63a670" translate="yes" xml:space="preserve">
          <source>String returns the name of k.</source>
          <target state="translated">문자열은 k의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="750dd1515ee90a846665f6d5d112993b3669e476" translate="yes" xml:space="preserve">
          <source>String returns the name of the transaction isolation level.</source>
          <target state="translated">문자열은 트랜잭션 격리 수준의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e794984ac30a476fc607ba49d30074600724b1fd" translate="yes" xml:space="preserve">
          <source>String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.</source>
          <target state="translated">문자열은 쿠키 헤더 (이름 및 값만 설정된 경우) 또는 Set-Cookie 응답 헤더 (다른 필드가 설정된 경우)에 사용하기 위해 쿠키의 직렬화를 반환합니다. c가 nil이거나 c.Name이 유효하지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fe713a69a5fd2ac5cb84c706517fb895d0d57913" translate="yes" xml:space="preserve">
          <source>String returns the source text used to compile the regular expression.</source>
          <target state="translated">문자열은 정규식을 컴파일하는 데 사용되는 소스 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34bacca8ec4eef4ee78833a67f79a6eef6da5be0" translate="yes" xml:space="preserve">
          <source>String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is &quot;+&quot;). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is &quot;IDENT&quot;).</source>
          <target state="translated">문자열은 토큰 토큰에 해당하는 문자열을 반환합니다. 연산자, 구분 기호 및 키워드의 경우 문자열은 실제 토큰 문자 시퀀스입니다 (예 : 토큰 ADD의 경우 문자열은 &quot;+&quot;). 다른 모든 토큰의 경우 문자열은 토큰 상수 이름에 해당합니다 (예 : 토큰 IDENT의 경우 문자열은 &quot;IDENT&quot;입니다).</target>
        </trans-unit>
        <trans-unit id="2d88168daac6375a514f336433bd215fb612a6a9" translate="yes" xml:space="preserve">
          <source>String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">문자열은 대략 RFC 2253 식별 이름 구문에 따라 n의 문자열 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65a433aa544a0c7b3431068c5cc7f107bc02e8c8" translate="yes" xml:space="preserve">
          <source>String returns the string form of the IP address ip. It returns one of 4 forms:</source>
          <target state="translated">문자열은 IP 주소 ip의 문자열 형식을 반환합니다. 다음 4 가지 형식 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77e4b34a03bfe1d41ef0627a6a3eef76345118dd" translate="yes" xml:space="preserve">
          <source>String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form &quot;&amp;lt;T value&amp;gt;&quot; where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.</source>
          <target state="translated">문자열은 문자열 v의 기본 값을 문자열로 반환합니다. 문자열은 Go의 문자열 메소드 규칙으로 인해 특별한 경우입니다. 다른 getter와 달리 v의 Kind가 String이 아닌 경우 당황하지 않습니다. 대신 &quot;&amp;lt;T value&amp;gt;&quot;형식의 문자열을 반환합니다. 여기서 T는 v 형식입니다. fmt 패키지는 값을 특별히 취급합니다. String 메서드를 암시 적으로 호출하지는 않지만 보유하고있는 구체적인 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="da3ada59fed13cf9c42e28f35ce824b152ed6695" translate="yes" xml:space="preserve">
          <source>String returns the time formatted using the format string</source>
          <target state="translated">문자열은 형식 문자열을 사용하여 형식화 된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7582d0695c8835ce2d6fd48b6b11691af0fd874b" translate="yes" xml:space="preserve">
          <source>String returns the value v as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Type is not TypeString. Instead, it returns a string of the form &quot;&amp;lt;T&amp;gt;&quot; or &quot;&amp;lt;T: V&amp;gt;&quot; where T is v's type and V is a string representation of v's value.</source>
          <target state="translated">문자열은 값 v를 문자열로 반환합니다. 문자열은 Go의 문자열 메소드 규칙으로 인해 특별한 경우입니다. 다른 getter와 달리 v의 Type이 TypeString이 아닌 경우 당황하지 않습니다. 대신 &quot;&amp;lt;T&amp;gt;&quot;또는 &quot;&amp;lt;T : V&amp;gt;&quot;형식의 문자열을 반환합니다. 여기서 T는 v의 유형이고 V는 v의 값을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b5780fb112a6b774b6985415c1ab7539f30b0d21" translate="yes" xml:space="preserve">
          <source>String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags, the string is encoded using HTMLEscape, which replaces &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U+2028, and U+2029 are escaped to &quot;\u003c&quot;,&quot;\u003e&quot;, &quot;\u0026&quot;, &quot;\u2028&quot;, and &quot;\u2029&quot;. This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).</source>
          <target state="translated">문자열 값은 유효한 UTF-8로 강제 변환 된 JSON 문자열로 인코딩되어 유효하지 않은 바이트를 유니 코드 대체 룬으로 대체합니다. JSON이 HTML &amp;lt;script&amp;gt; 태그에 안전하게 포함되도록 문자열은 HTMLEscape를 사용하여 인코딩되며 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U + 2028 및 U + 2029를 &quot;\로 대체합니다. u003c &quot;,&quot;\ u003e &quot;,&quot;\ u0026 &quot;,&quot;\ u2028 &quot;및&quot;\ u2029 &quot;. 이 대체는 인코더를 사용할 때 SetEscapeHTML (false)을 호출하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86940bb85d221e97a38bc1e113fc6bce034c8750" translate="yes" xml:space="preserve">
          <source>StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringBytePtr은 NUL로 끝나는 바이트 배열에 대한 포인터를 반환합니다. s에 NUL 바이트가 포함 된 경우이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0623ccf68cc35082d287f89796544274ff86c91" translate="yes" xml:space="preserve">
          <source>StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringByteSlice는 문자열을 NUL 종료 [] 바이트로 변환합니다. s에 NUL 바이트가 포함되어 있으면이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf1e10cb60d4363fb37f7da731443afa2a654e2" translate="yes" xml:space="preserve">
          <source>StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">StringHeader는 문자열의 런타임 표현입니다. 안전하게 또는 이식 가능하게 사용할 수 없으며 이후 릴리스에서 표현이 변경 될 수 있습니다. 또한 데이터 필드는 참조하는 데이터가 가비지 수집되지 않도록 보장하기에 충분하지 않으므로 프로그램은 기본 데이터에 대해 올바르게 입력 된 별도의 포인터를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="a97933503d7359e70c5bcc6d71f20f23e72ff484" translate="yes" xml:space="preserve">
          <source>StringNode holds a string constant. The value has been &quot;unquoted&quot;.</source>
          <target state="translated">StringNode는 문자열 상수를 보유합니다. 값이 &quot;인용되지 않았습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="4e2dc56d882f4e247f4c8c91d09f7ca7c92151b0" translate="yes" xml:space="preserve">
          <source>StringSlice attaches the methods of Interface to []string, sorting in increasing order.</source>
          <target state="translated">StringSlice는 [] 문자열에 인터페이스의 메소드를 첨부하여 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="0ccdd69f6b44471ac8719f7a4d5092264f1d1540" translate="yes" xml:space="preserve">
          <source>StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringSlicePtr은 문자열 조각을 NUL 종료 바이트 배열에 대한 포인터 조각으로 변환합니다. 문자열에 NUL 바이트가 포함 된 경우이 함수는 오류를 반환하는 대신 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="58cd2c4c0c64b3e8b63116e619c1216921aee8f5" translate="yes" xml:space="preserve">
          <source>StringTable is a COFF string table.</source>
          <target state="translated">StringTable은 COFF 문자열 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="cf2c21cf4463c1c95fd9d9c1165bec97a40c80e4" translate="yes" xml:space="preserve">
          <source>StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is &quot;&quot;.</source>
          <target state="translated">StringVal은 x의 Go 문자열 값을 반환합니다.이 값은 String 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d9073eff948f092d1e822cdc4b90545ac7f58c79" translate="yes" xml:space="preserve">
          <source>StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.</source>
          <target state="translated">StringVar는 지정된 이름, 기본값 및 사용 문자열로 문자열 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 문자열 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8523e16e4f3d17cbbcc1796a5175f67569825d49" translate="yes" xml:space="preserve">
          <source>StringWriter is the interface that wraps the WriteString method.</source>
          <target state="translated">StringWriter는 WriteString 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="2968f2bfae46d2fc485efc7b71be92497e030111" translate="yes" xml:space="preserve">
          <source>Stringer</source>
          <target state="translated">Stringer</target>
        </trans-unit>
        <trans-unit id="58829a9ebd1b847fb0ad45cdde0851c334ed441d" translate="yes" xml:space="preserve">
          <source>Stringer is implemented by any value that has a String method, which defines the &amp;ldquo;native&amp;rdquo; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.</source>
          <target state="translated">Stringer는 String 메소드가있는 값으로 구현되며, 해당 값의 &quot;기본&quot;형식을 정의합니다. 문자열 메소드는 문자열을 허용하는 형식이나 인쇄와 같은 형식화되지 않은 프린터에 피연산자로 전달 된 값을 인쇄하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="906a27ee40bd23a1553b39eb16be0c8e8ac3e949" translate="yes" xml:space="preserve">
          <source>Strings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value.</source>
          <target state="translated">문자열과 바이트 조각은 부호없는 카운트로 전송되고 그 뒤에 해석되지 않은 많은 바이트 값이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="faac2cc38ba743bbc17ba9acb7964aa6cee65d73" translate="yes" xml:space="preserve">
          <source>Strings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format.</source>
          <target state="translated">문자열은 UTF-8로 인코딩되어야하며 GZIP 파일 형식의 제한으로 인해 유니 코드 코드 포인트 U + 0001 ~ U + 00FF 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76921542e09ce2202753a5d0b5a9e24e8b8a263" translate="yes" xml:space="preserve">
          <source>Strings sorts a slice of strings in increasing order.</source>
          <target state="translated">문자열은 문자열 조각을 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="3d93c8594f1a8a4b01949156c04f8f3f3ae7fd2a" translate="yes" xml:space="preserve">
          <source>StringsAreSorted tests whether a slice of strings is sorted in increasing order.</source>
          <target state="translated">StringsAreSorted는 문자열 조각이 오름차순으로 정렬되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="13ae2dda2de94ac9d40b6ba17fece2797835c04a" translate="yes" xml:space="preserve">
          <source>StripPrefix</source>
          <target state="translated">StripPrefix</target>
        </trans-unit>
        <trans-unit id="e0a5f88c187543f04de90ac6fd0379250c9778df" translate="yes" xml:space="preserve">
          <source>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error.</source>
          <target state="translated">StripPrefix는 요청 URL의 경로에서 지정된 접 두부를 제거하고 핸들러 h를 호출하여 HTTP 요청을 처리하는 핸들러를 리턴합니다. StripPrefix는 HTTP 404를 찾을 수 없음 오류로 응답하여 접두어로 시작하지 않는 경로 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="39170b61b74a11d6a192ff9863dfa73aaecba21c" translate="yes" xml:space="preserve">
          <source>Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.</source>
          <target state="translated">반출 및 반출되지 않은 해당 필드가 완전히 동일한 경우 구조 값은 매우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb5bb421400cdac0575f807d47566c64d1f46c0f" translate="yes" xml:space="preserve">
          <source>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</source>
          <target state="translated">구조 값은 JSON 객체로 인코딩됩니다. 아래의 이유로 인해 필드를 생략하지 않으면 내 보낸 각 구조체 필드는 필드 이름을 개체 키로 사용하여 개체의 멤버가됩니다.</target>
        </trans-unit>
        <trans-unit id="0b823e55e4d9782e91674576a6c2dba2dbfb679a" translate="yes" xml:space="preserve">
          <source>StructOf</source>
          <target state="translated">StructOf</target>
        </trans-unit>
        <trans-unit id="cbecd3176d1c216f7d05eaf053a4641373b34f6b" translate="yes" xml:space="preserve">
          <source>StructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version.</source>
          <target state="translated">StructOf는 현재 내 보내지 않은 StructField를 전달한 경우 포함 된 필드 및 패닉에 대한 래퍼 메서드를 생성하지 않습니다. 이러한 제한은 향후 버전에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e272272dfcabba6b0a57032693b1247f7d907d03" translate="yes" xml:space="preserve">
          <source>StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.</source>
          <target state="translated">StructOf는 필드를 포함하는 구조체 유형을 반환합니다. 오프셋 및 색인 필드는 컴파일러에서와 같이 무시되고 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="642ea82e69d222e31d0a11979f4762edc849aa8f" translate="yes" xml:space="preserve">
          <source>StructTag</source>
          <target state="translated">StructTag</target>
        </trans-unit>
        <trans-unit id="666cf050832b24dac5a22e670aae0c296886ba23" translate="yes" xml:space="preserve">
          <source>StructTag.Lookup</source>
          <target state="translated">StructTag.Lookup</target>
        </trans-unit>
        <trans-unit id="5f4f3284caaeebe32585ec344848f50378d011bc" translate="yes" xml:space="preserve">
          <source>Structs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00).</source>
          <target state="translated">Structs는 일련의 (필드 번호, 필드 값) 쌍으로 전송됩니다. 필드 값은 해당 유형에 표준 gob 인코딩을 사용하여 재귀 적으로 전송됩니다. 필드가 해당 유형에 대해 0 값을 갖는 경우 (배열 제외; 위 참조) 전송에서 생략됩니다. 필드 번호는 인코딩 된 구조체의 유형에 의해 정의됩니다. 인코딩 된 유형의 첫 번째 필드는 필드 0, 두 번째는 필드 1 등입니다. 값을 인코딩 할 때 필드 번호는 효율성을 위해 델타 인코딩되며 필드는 항상 필드 번호가 증가하는 순서대로 전송됩니다. 따라서 델타는 부호가 없습니다. 델타 인코딩의 초기화는 필드 번호를 -1로 설정하므로, 값이 7 인 부호없는 정수 필드 0은 부호없는 델타 = 1, 부호없는 값 = 7 또는 (01 07)로 전송됩니다. 마지막으로, 모든 필드가 전송 된 후 종료 표시는 구조체의 끝을 나타냅니다.이 마크는 델타 = 0 값이며, 표현은 (00)입니다.</target>
        </trans-unit>
        <trans-unit id="7dc46671ebabbdf3c46aadccd97f8c490eefc52c" translate="yes" xml:space="preserve">
          <source>Structs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded.</source>
          <target state="translated">구조, 배열 및 슬라이스도 지원됩니다. Structs는 내 보낸 필드 만 인코딩하고 디코딩합니다. 문자열과 바이트 배열은 특별하고 효율적인 표현으로 지원됩니다 (아래 참조). 슬라이스가 디코딩 될 때, 기존 슬라이스가 용량을 가지면 슬라이스가 제자리에서 확장됩니다. 그렇지 않은 경우 새 배열이 할당됩니다. 어쨌든, 결과 슬라이스의 길이는 디코딩 된 요소의 수를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ad78f09f9c6b3087d8e72e4530ecc70c4956979a" translate="yes" xml:space="preserve">
          <source>Structure Preservation Property: &quot;... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.&quot;</source>
          <target state="translated">구조 보존 속성 : &quot;... 템플릿 작성자가 안전한 템플릿 언어로 HTML 태그를 작성할 때 브라우저는 신뢰할 수없는 데이터의 값과 상관없이 출력의 해당 부분을 태그로 해석합니다. 속성 경계와 JS 및 CSS 문자열 경계. &quot;</target>
        </trans-unit>
        <trans-unit id="a3c9ca613cd987d897ef5275ec8d3b6be7186d1f" translate="yes" xml:space="preserve">
          <source>Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub는 x, y 및 차용의 차이를 반환합니다. diff = x-y-차용. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="61c41cb657724bf35da0dad82b0d5dee3326e95d" translate="yes" xml:space="preserve">
          <source>Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).</source>
          <target state="translated">Sub는 기간 tu를 반환합니다. 결과가 Duration에 저장할 수있는 최대 (또는 최소) 값을 초과하면 최대 (또는 최소) 지속 시간이 반환됩니다. 지속 시간 d 동안 td를 계산하려면 t.Add (-d)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a9cccdf849236c7b5afc32fedeaf0e730cf15fd" translate="yes" xml:space="preserve">
          <source>Sub returns the rectangle r translated by -p.</source>
          <target state="translated">Sub는 -p로 변환 된 사각형 r을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c74b307e6862c7c0fdbabb48e4f241316eca6f53" translate="yes" xml:space="preserve">
          <source>Sub returns the vector p-q.</source>
          <target state="translated">Sub는 벡터 pq를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2660992e01b4593ff7e0d2ea96dbc6a6fcdbbc82" translate="yes" xml:space="preserve">
          <source>Sub sets z to the difference x-y and returns z.</source>
          <target state="translated">Sub는 z를 차이 xy로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07c120e2c4cb601d9bfe9da745d95ee84f5c8f23" translate="yes" xml:space="preserve">
          <source>Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case.</source>
          <target state="translated">Sub는 z를 둥근 차이 xy로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. x와 y가 같은 부호를 갖는 무한대 인 경우 ErrNaN을 사용한 하위 패닉. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="821524c66883b61b23da230e1f7ac6f247b61c28" translate="yes" xml:space="preserve">
          <source>Sub-repositories</source>
          <target state="translated">Sub-repositories</target>
        </trans-unit>
        <trans-unit id="027b254161eaa851d3de87e3e3811c330b4b1cfe" translate="yes" xml:space="preserve">
          <source>Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub32는 x, y 및 차용, diff = x-y-차용의 차이를 반환합니다. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="19abe5243ff65ef214d8cfd1ed7dd0d253eaaf1e" translate="yes" xml:space="preserve">
          <source>Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub64는 x, y 및 차용의 차이를 반환합니다. diff = x-y-차용. 차용 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 차용 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc6e21e27e1d98c4a46c59e21cbbbe634de9bcb" translate="yes" xml:space="preserve">
          <source>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.</source>
          <target state="translated">SubImage는 r을 통해 보이는 이미지 p의 일부를 나타내는 이미지를 반환합니다. 반환 된 값은 원본 이미지와 픽셀을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="19b094dbedb2add32a27c12c5c0b06b9d304fb7c" translate="yes" xml:space="preserve">
          <source>Subdirectories</source>
          <target state="translated">Subdirectories</target>
        </trans-unit>
        <trans-unit id="abb46f6f4b961e90d924a27858c117c84efd6aae" translate="yes" xml:space="preserve">
          <source>SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.</source>
          <target state="translated">SubexpNames는이 Regexp에서 괄호로 묶인 하위 표현식의 이름을 리턴합니다. 첫 번째 하위 표현식의 이름은 names [1]이므로 m이 일치 슬라이스 인 경우 m [i]의 이름은 SubexpNames () [i]입니다. 전체적으로 정규 표현식의 이름을 지정할 수 없으므로 names [0]은 항상 빈 문자열입니다. 슬라이스를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c047b864469812cfb4b3b886d30b5376a4d0df" translate="yes" xml:space="preserve">
          <source>Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.</source>
          <target state="translated">주체는 풀에있는 모든 인증서의 DER 인코딩 된 주체 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91e8bbbf1ff4c8e821148581549206c9787e494e" translate="yes" xml:space="preserve">
          <source>Subtests and Sub-benchmarks</source>
          <target state="translated">하위 테스트 및 하위 벤치 마크</target>
        </trans-unit>
        <trans-unit id="05cc8697fcb7ccef149a7858e8bd798cb2cd774f" translate="yes" xml:space="preserve">
          <source>Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:</source>
          <target state="translated">하위 테스트를 사용하여 병렬 처리를 제어 할 수도 있습니다. 부모 테스트는 모든 하위 테스트가 완료된 후에 만 ​​완료됩니다. 이 예제에서 정의 할 수있는 다른 최상위 테스트에 관계없이 모든 테스트는 서로 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb672ca35fe1893eef6f12fcd0a8efff47a2478c" translate="yes" xml:space="preserve">
          <source>Success reports whether the program exited successfully, such as with exit status 0 on Unix.</source>
          <target state="translated">성공은 Unix에서 종료 상태 0과 같이 프로그램이 성공적으로 종료되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="07eda2eb03735678c89d2490ea6410dd3ad1a43b" translate="yes" xml:space="preserve">
          <source>Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint:</source>
          <target state="translated">이러한 파일은 일반적으로 다른 시스템의 기본 기능을 구현하는 다른 파일과 쌍을 이루어이 경우 제약 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="1037d5e9f233e3f6a6a25104581ccd4bbd6ac1c7" translate="yes" xml:space="preserve">
          <source>Sum returns the MD5 checksum of the data.</source>
          <target state="translated">Sum은 데이터의 MD5 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8eeaf2ada0e780d70b60f2e9edbd46ef59d4a13" translate="yes" xml:space="preserve">
          <source>Sum returns the SHA-1 checksum of the data.</source>
          <target state="translated">Sum은 데이터의 SHA-1 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dca98b14fcbfeb34897e7396c1a6dfa98d521b4" translate="yes" xml:space="preserve">
          <source>Sum224 returns the SHA224 checksum of the data.</source>
          <target state="translated">Sum224는 데이터의 SHA224 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba05916088015c0f1b00b88d9415ebfa726370d8" translate="yes" xml:space="preserve">
          <source>Sum256</source>
          <target state="translated">Sum256</target>
        </trans-unit>
        <trans-unit id="087b1fabd67b489187e993cab88dfd4147ea385d" translate="yes" xml:space="preserve">
          <source>Sum256 returns the SHA256 checksum of the data.</source>
          <target state="translated">Sum256은 데이터의 SHA256 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bd95a96de2d8140b4ada3f2d7b194594facee01" translate="yes" xml:space="preserve">
          <source>Sum384 returns the SHA384 checksum of the data.</source>
          <target state="translated">Sum384는 데이터의 SHA384 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf1f6e0b5ced478fca66b19297a0e98baeedd390" translate="yes" xml:space="preserve">
          <source>Sum512 returns the SHA512 checksum of the data.</source>
          <target state="translated">Sum512는 데이터의 SHA512 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3357361c0e72e316aab24916d39ed7d14bdb335d" translate="yes" xml:space="preserve">
          <source>Sum512_224 returns the Sum512/224 checksum of the data.</source>
          <target state="translated">Sum512_224는 데이터의 Sum512 / 224 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff71eecde6b5c686475ebd821438cf7dd50ffe32" translate="yes" xml:space="preserve">
          <source>Sum512_256 returns the Sum512/256 checksum of the data.</source>
          <target state="translated">Sum512_256은 데이터의 Sum512 / 256 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4442b8443612835fd9bd367eb3496bb5cfec606a" translate="yes" xml:space="preserve">
          <source>Support for tracing tests and benchmarks built with the standard testing package is built into `go test`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).</source>
          <target state="translated">표준 테스트 패키지로 구축 된 추적 테스트 및 벤치 마크 지원은`go test`에 내장되어 있습니다. 예를 들어 다음 명령은 현재 디렉토리에서 테스트를 실행하고 추적 파일 (trace.out)을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="05492c0a57ea2d63ba2b476c7222b6bcdddbb676" translate="yes" xml:space="preserve">
          <source>Supported architectures for compiler &quot;gc&quot;: &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le&quot;, &quot;riscv64&quot;, &quot;s390x&quot;, &quot;sparc64&quot;, &quot;wasm&quot;.</source>
          <target state="translated">컴파일러 &quot;gc&quot;에 지원되는 아키텍처 : &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le &quot;,&quot;riscv64 &quot;,&quot;s390x &quot;,&quot;sparc64 &quot;,&quot;wasm &quot;.</target>
        </trans-unit>
        <trans-unit id="e8b59b633a995b7dd6a0e84deb15f21ce9bf242a" translate="yes" xml:space="preserve">
          <source>SwapInt32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt32는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="96490065dc4e2e645c8a89627e673eb95f4aaa28" translate="yes" xml:space="preserve">
          <source>SwapInt64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt64는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da115593d3ae663bb42ff237dd86576dfdedf6ad" translate="yes" xml:space="preserve">
          <source>SwapPointer atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapPointer는 원자 적으로 new를 * addr에 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c0f6214095877962c7da65a2c141bf3b6cbecc8" translate="yes" xml:space="preserve">
          <source>SwapUint32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint32는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="899e9c7e854930b5577e53934a16009339f15457" translate="yes" xml:space="preserve">
          <source>SwapUint64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint64는 * addr에 새로운 것을 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18cdfb91a16523313759a1c794de0eb9712ac2b2" translate="yes" xml:space="preserve">
          <source>SwapUintptr atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUintptr은 * addr에 new를 원자 적으로 저장하고 이전 * addr 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c2b73e847c3ed8be17c9afe2788c2fedb5bc635" translate="yes" xml:space="preserve">
          <source>Swapper panics if the provided interface is not a slice.</source>
          <target state="translated">제공된 인터페이스가 슬라이스가 아닌 경우 스위퍼 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0485bba36620f415adb72d21b9eac171cd9aadf1" translate="yes" xml:space="preserve">
          <source>Swapper returns a function that swaps the elements in the provided slice.</source>
          <target state="translated">Swapper는 제공된 슬라이스의 요소를 바꾸는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="baf85dad7e64d73c6dc3f04eb46803a601b907a7" translate="yes" xml:space="preserve">
          <source>SymByAddr returns the text, data, or bss symbol starting at the given address.</source>
          <target state="translated">SymByAddr은 주어진 주소에서 시작하는 텍스트, 데이터 또는 bss 기호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6a580ed077335806f8a72f4c91bc2108aa36618" translate="yes" xml:space="preserve">
          <source>Symbol Binding - ELFNN_ST_BIND - st_info</source>
          <target state="translated">심볼 바인딩-ELFNN_ST_BIND-st_info</target>
        </trans-unit>
        <trans-unit id="998290f1606e44ec99b08646525255987ca67dd9" translate="yes" xml:space="preserve">
          <source>Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.</source>
          <target state="translated">기호는 이름 필드가 Go 문자열로 대체 된 COFFSymbol과 유사합니다. Symbol에는 NumberOfAuxSymbols도 없습니다.</target>
        </trans-unit>
        <trans-unit id="e746caac18fb8c9ece11fba1c3858dd24402cee1" translate="yes" xml:space="preserve">
          <source>Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.</source>
          <target state="translated">Symbol은 요청에 나열된 프로그램 카운터를 찾아 함수 이름에 대한 테이블 맵핑 프로그램 카운터로 응답합니다. 패키지 초기화는이를 / debug / pprof / symbol로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="9183912a1c8677ccbfeafe4a95bb81fdaf9d6c67" translate="yes" xml:space="preserve">
          <source>Symbol type - ELFNN_ST_TYPE - st_info</source>
          <target state="translated">심볼 유형-ELFNN_ST_TYPE-st_info</target>
        </trans-unit>
        <trans-unit id="300ae1bf65f5418188fead7a4f6227a1a8cb17ab" translate="yes" xml:space="preserve">
          <source>Symbol visibility - ELFNN_ST_VISIBILITY - st_other</source>
          <target state="translated">기호 표시-ELFNN_ST_VISIBILITY-st_other</target>
        </trans-unit>
        <trans-unit id="e0dd57ca387a759e2499962eadf5f79f0eaa8ee2" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f.</source>
          <target state="translated">기호는 f에 대한 기호 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40ab78f946263d95260d4886b240965a4da98f61" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="translated">기호는 f에 대한 기호 테이블을 반환합니다. 기호는 f에 표시된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="2377d81c04be24a887c20fd3bd69bc0f09f37db5" translate="yes" xml:space="preserve">
          <source>Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Symlink는 newname을 oldname에 대한 심볼릭 링크로 만듭니다. 오류가 있으면 * LinkError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0aceec11151392e3e912ee288231038c58c328b4" translate="yes" xml:space="preserve">
          <source>Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.</source>
          <target state="translated">동기화는 파일의 현재 내용을 안정적인 저장소에 커밋합니다. 일반적으로 이것은 파일 시스템의 메모리에 최근에 쓴 데이터의 사본을 디스크로 플러시하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e15b4a502540aca9807844244039f56ac0ff96c5" translate="yes" xml:space="preserve">
          <source>Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.</source>
          <target state="translated">동기 신호는 프로그램 실행 오류 SIGBUS, SIGFPE 및 SIGSEGV에 의해 트리거되는 신호입니다. os.Process.Kill 또는 kill 프로그램 또는 이와 유사한 메커니즘을 사용하여 전송 된 경우가 아니라 프로그램 실행으로 인해 발생하는 경우에만 동기화 된 것으로 간주됩니다. 일반적으로 아래 설명 된 것을 제외하고 Go 프로그램은 동기 신호를 런타임 패닉으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="14251985329004226786245f7238c38c1ab2c9f9" translate="yes" xml:space="preserve">
          <source>Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \n, \r, or \t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string.</source>
          <target state="translated">개요는 첫 번째 문장의 정리 된 버전을 s로 반환합니다. 이 문장은 첫 번째 마침표 뒤에 공백으로 끝나고 정확히 하나의 대문자가 앞에 오지 않습니다. 결과 문자열에는 \ n, \ r 또는 \ t 문자가 없으며 단어 사이에 단일 공백 ​​만 사용합니다. s가 IllegalPrefixes로 시작하면 결과는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="94881bde696c81108db9e992f3357d3d70383bb4" translate="yes" xml:space="preserve">
          <source>Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.</source>
          <target state="translated">Sys는 프로세스에 대한 시스템 종속 종료 정보를 리턴합니다. 컨텐츠에 액세스하려면 Unix의 syscall.WaitStatus와 같은 적절한 기본 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ce82965024d89928bce7d20275a546fd15078072" translate="yes" xml:space="preserve">
          <source>SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).</source>
          <target state="translated">SysProcIDMap은 Linux에서 사용자 네임 스페이스에 사용되는 컨테이너 ID 대 호스트 ID 맵핑을 보유합니다. user_namespaces (7)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ffbaaa01464f1d0b5846f06e745037abe0d8cb8" translate="yes" xml:space="preserve">
          <source>SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)</source>
          <target state="translated">SysUsage는 종료 된 프로세스에 대한 시스템 종속 자원 사용 정보를 리턴합니다. 컨텐츠에 액세스하려면 Unix의 * syscall.Rusage와 같은 적절한 기본 유형으로 변환하십시오. Unix에서 * syscall.Rusage는 getrusage (2) 매뉴얼 페이지에 정의 된대로 struct rusage와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e293cc54d1f1c47b6fdb1085033440055e2faa2b" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw file. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn은 원시 파일을 반환합니다. syscall.Conn 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="93d325a9a596e81112db1a88f6cf17706c8e91ec" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw network connection. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn은 원시 네트워크 연결을 반환합니다. syscall.Conn 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aa615b3f3de4dc13fa4173050b52db98916467bd" translate="yes" xml:space="preserve">
          <source>SyscallError records an error from a specific system call.</source>
          <target state="translated">SyscallError는 특정 시스템 호출의 오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="de57d6136b78d4b44c51a17ce5f47f730586e6a6" translate="yes" xml:space="preserve">
          <source>SystemCertPool returns a copy of the system cert pool.</source>
          <target state="translated">SystemCertPool은 시스템 인증서 풀의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bc8f6a9ab808b5aa99fa9f5b51afdf83e241a9c" translate="yes" xml:space="preserve">
          <source>SystemRootsError results when we fail to load the system root certificates.</source>
          <target state="translated">시스템 루트 인증서를로드하지 못하면 SystemRootsError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="326b735dbfcf185462598a45a443d5db5a2c18cd" translate="yes" xml:space="preserve">
          <source>SystemTime returns the system CPU time of the exited process and its children.</source>
          <target state="translated">SystemTime은 종료 된 프로세스 및 해당 자식의 시스템 CPU 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd9dc41e485032cb18e9d13d513ba555be1b33c2" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.</source>
          <target state="translated">T는 테스트 상태를 관리하고 형식화 된 테스트 로그를 지원하기 위해 테스트 기능에 전달되는 유형입니다. 실행 중에 로그가 누적되고 완료되면 표준 출력으로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="d71f7f3fa4e9f0ba0065f39db28f69d358c4b941" translate="yes" xml:space="preserve">
          <source>TB is the interface common to T and B.</source>
          <target state="translated">TB는 T와 B에 공통적 인 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="671a2dd281c27979f8b5f140c5da50e321430a64" translate="yes" xml:space="preserve">
          <source>TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">TBSCertificateList는 동일한 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 5.1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2984ada09d0c49745872575be1763fe615cf3de7" translate="yes" xml:space="preserve">
          <source>TCPAddr represents the address of a TCP end point.</source>
          <target state="translated">TCPAddr은 TCP 엔드 포인트의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="623c2c8aa88d77780fe4e0bcba75694b81bcf2ad" translate="yes" xml:space="preserve">
          <source>TCPConn is an implementation of the Conn interface for TCP network connections.</source>
          <target state="translated">TCPConn은 TCP 네트워크 연결을위한 Conn 인터페이스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="1bbfc48812fe8aa4d93c086976c0d5cdc5424e43" translate="yes" xml:space="preserve">
          <source>TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.</source>
          <target state="translated">TCPListener는 TCP 네트워크 수신기입니다. 클라이언트는 일반적으로 TCP를 가정하는 대신 리스너 유형의 변수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0df2a7fffd9d8cf03b29589d0b72452730e5dd3" translate="yes" xml:space="preserve">
          <source>TLS 1.3 is available on an opt-out basis in Go 1.13. To disable it, set the GODEBUG environment variable (comma-separated key=value options) such that it includes &quot;tls13=0&quot;.</source>
          <target state="translated">TLS 1.3은 Go 1.13에서 옵트 아웃 방식으로 제공됩니다. 사용하지 않으려면 &quot;tls13 = 0&quot;을 포함하도록 GODEBUG 환경 변수 (쉼표로 구분 된 키 = 값 옵션)를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="daa5896e5821b88d0d9b26d2bc85c2d021b848c8" translate="yes" xml:space="preserve">
          <source>TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed.</source>
          <target state="translated">TLSConnectionState는 클라이언트의 TLS 연결 상태를 반환합니다. StartTLS가 실패한 경우 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ed012370216d609d48fc2b869f8a011268923cad" translate="yes" xml:space="preserve">
          <source>TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).</source>
          <target state="translated">TODO는 비어 있지 않은 빈 컨텍스트를 반환합니다. 사용할 컨텍스트가 확실하지 않거나 아직 사용할 수없는 경우 코드는 context.TODO를 사용해야합니다 (주변 함수가 아직 컨텍스트 매개 변수를 허용하도록 확장되지 않았기 때문).</target>
        </trans-unit>
        <trans-unit id="1f541ebdf888dacb11e44ff51c13846474081ba9" translate="yes" xml:space="preserve">
          <source>Tab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab):</source>
          <target state="translated">인접한 줄의 탭으로 끝나는 셀이 열을 구성합니다. Writer는 열의 모든 셀이 동일한 너비를 가지도록 효과적으로 패딩을 삽입하여 열을 효과적으로 정렬합니다. tabwidth를 지정해야하는 탭을 제외하고 모든 문자의 너비가 동일하다고 가정합니다. 열 셀은 탭으로 구분되지 않고 탭으로 끝나야합니다. 줄 끝에서 탭으로 끝나지 않는 후행 텍스트는 셀을 형성하지만 해당 셀은 정렬 된 열의 일부가 아닙니다. 예를 들어,이 예에서 | |는 가로 탭을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9baa6d565b56c1e4861e3df81a8fd8df65d699d4" translate="yes" xml:space="preserve">
          <source>Table 1 in [2] suggests maximum numbers of primes for a given size.</source>
          <target state="translated">[2]의 표 1은 주어진 크기에 대한 최대 소수의 수를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ba3ee22bd3b233bdb404d63bfe71ba0cb11ae0a4" translate="yes" xml:space="preserve">
          <source>Table is a 256-word table representing the polynomial for efficient processing.</source>
          <target state="translated">Table은 효율적인 처리를위한 다항식을 나타내는 256 워드 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="599b448991ae5ae6d130b6356ce6b00630c5cefb" translate="yes" xml:space="preserve">
          <source>Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.</source>
          <target state="translated">표는 이동 기호 표를 나타냅니다. 프로그램에서 디코딩 된 모든 심볼을 저장하고 심볼, 이름 및 주소 간을 변환하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfc4ba347929d28c193a400550bae587488f16cd" translate="yes" xml:space="preserve">
          <source>Tag returns the i'th field tag for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="translated">Tag는 0 &amp;lt;= i &amp;lt;NumFields ()에 대한 i 번째 필드 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a39b84c91d8c550355f46b331fdfde2ffca5ba7" translate="yes" xml:space="preserve">
          <source>Tag sizes between 12 and 16 bytes are allowed.</source>
          <target state="translated">12-16 바이트 사이의 태그 크기가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9dda0ce21be12978cbb42d63ed48bd36a71555e8" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt; 에서 가져옴</target>
        </trans-unit>
        <trans-unit id="133552ebfbcce8310f8920695422699d5256bac9" translate="yes" xml:space="preserve">
          <source>Tan</source>
          <target state="translated">Tan</target>
        </trans-unit>
        <trans-unit id="c442668b04fe0d2fb49d4d83b1b51198b583f812" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of the radian argument x.</source>
          <target state="translated">Tan은 라디안 인수 x의 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f8f5243ed4843c5154158c2ff20cd9a586739e0" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of x.</source>
          <target state="translated">Tan은 x의 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19bff9fbbbadd7b339e0ee0ae1715d62fea9cae0" translate="yes" xml:space="preserve">
          <source>Tanh</source>
          <target state="translated">Tanh</target>
        </trans-unit>
        <trans-unit id="dc8ae90d27ce708b07a5ac10906ccc3ed208c4a5" translate="yes" xml:space="preserve">
          <source>Tanh returns the hyperbolic tangent of x.</source>
          <target state="translated">Tanh는 x의 쌍곡 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f0a22a02d454a68d024fa67fa9340156799d88b" translate="yes" xml:space="preserve">
          <source>Tape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</source>
          <target state="translated">테이프 아카이브 (tar)는 스트리밍 방식으로 읽고 쓸 수있는 일련의 파일을 저장하기위한 파일 형식입니다. 이 패키지는 GNU 및 BSD tar 도구로 작성된 형식을 포함하여 대부분의 형식을 다루는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="f11f02db734667c97fad6ffb5c8e393a00b87399" translate="yes" xml:space="preserve">
          <source>Task is a data type for tracing a user-defined, logical operation.</source>
          <target state="translated">작업은 사용자 정의 논리 연산을 추적하기위한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a9e55d223a3d4713691d397b40624caef60d5252" translate="yes" xml:space="preserve">
          <source>TeeReader</source>
          <target state="translated">TeeReader</target>
        </trans-unit>
        <trans-unit id="c3ce03ea658d6ce846ba37ed8673f608fd0ba578" translate="yes" xml:space="preserve">
          <source>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</source>
          <target state="translated">TeeReader는 r에서 읽은 내용을 w에 쓰는 Reader를 반환합니다. r을 통해 수행 된 모든 읽기는 w에 해당하는 쓰기와 일치합니다. 내부 버퍼링이 없습니다. 읽기가 완료되기 전에 쓰기가 완료되어야합니다. 쓰는 동안 발생한 오류는 읽기 오류로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="d5aae156b3babace54749a4ff370cbf166528804" translate="yes" xml:space="preserve">
          <source>Tell returns the current position in the line table.</source>
          <target state="translated">Tell은 행 테이블에서 현재 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="243b371792899304742de51767e5e63dc878faba" translate="yes" xml:space="preserve">
          <source>TempDir</source>
          <target state="translated">TempDir</target>
        </trans-unit>
        <trans-unit id="99e70473aa5b1571f3701ff2584745139273d8ab" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="translated">TempDir은 접두사로 시작하는 이름으로 디렉토리 dir에 새 임시 디렉토리를 작성하고 새 디렉토리의 경로를 리턴합니다. dir이 빈 문자열 인 경우 TempDir은 임시 파일의 기본 디렉토리를 사용합니다 (os.TempDir 참조). TempDir을 동시에 호출하는 여러 프로그램은 동일한 디렉토리를 선택하지 않습니다. 더 이상 필요하지 않은 경우 디렉토리를 제거하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="275584eb4c05e91a05657287b9e5e68b19aedf60" translate="yes" xml:space="preserve">
          <source>TempDir returns the default directory to use for temporary files.</source>
          <target state="translated">TempDir은 임시 파일에 사용할 기본 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7cc1fbb5a71addb97fa8de33ce419d1f28b35a1" translate="yes" xml:space="preserve">
          <source>TempFile</source>
          <target state="translated">TempFile</target>
        </trans-unit>
        <trans-unit id="ba14fe997bc74680fd4532ceead516a44881c27a" translate="yes" xml:space="preserve">
          <source>TempFile (Suffix)</source>
          <target state="translated">TempFile (접미사)</target>
        </trans-unit>
        <trans-unit id="db71768a24bbe351f05252c3b917cc624a9ef1b3" translate="yes" xml:space="preserve">
          <source>TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.</source>
          <target state="translated">TempFile은 디렉토리 dir에 새 임시 파일을 작성하고 읽고 쓸 파일을 열고 결과 * os.File을 리턴합니다. 파일 이름은 패턴을 취하고 끝에 임의의 문자열을 추가하여 생성됩니다. 패턴에 &quot;*&quot;가 포함되어 있으면 임의의 문자열이 마지막 &quot;*&quot;를 대체합니다. dir이 빈 문자열 인 경우 TempFile은 임시 파일의 기본 디렉토리를 사용합니다 (os.TempDir 참조). TempFile을 동시에 호출하는 여러 프로그램은 동일한 파일을 선택하지 않습니다. 호출자는 f.Name ()을 사용하여 파일의 경로 이름을 찾을 수 있습니다. 더 이상 필요하지 않은 경우 파일을 제거하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="52ee9ac00f43714b0b4818dd84d35b8b6557c7c3" translate="yes" xml:space="preserve">
          <source>Template (Block)</source>
          <target state="translated">템플릿 (블록)</target>
        </trans-unit>
        <trans-unit id="74122feafa7458ac08ce0eb420614965c6703346" translate="yes" xml:space="preserve">
          <source>Template (Func)</source>
          <target state="translated">템플릿 (Func)</target>
        </trans-unit>
        <trans-unit id="2682dd16a44a1aa85841c66918e903265b4a3cd6" translate="yes" xml:space="preserve">
          <source>Template (Glob)</source>
          <target state="translated">템플릿 (글로벌)</target>
        </trans-unit>
        <trans-unit id="b329235171f350105da0e424a6e94302aadf509f" translate="yes" xml:space="preserve">
          <source>Template (Helpers)</source>
          <target state="translated">템플릿 (도움말)</target>
        </trans-unit>
        <trans-unit id="f6c8b5d715e6b1e91ba606c90a46ade44fbfcfc3" translate="yes" xml:space="preserve">
          <source>Template (Parsefiles)</source>
          <target state="translated">템플릿 (구문 파일)</target>
        </trans-unit>
        <trans-unit id="57600593178e53d1b30c9ce35cfc8c0a348f3a2c" translate="yes" xml:space="preserve">
          <source>Template (Share)</source>
          <target state="translated">템플릿 (공유)</target>
        </trans-unit>
        <trans-unit id="85b91409ae0c75ad6a8c43a15d791cc0c6067ae4" translate="yes" xml:space="preserve">
          <source>Template is a specialized Template from &quot;text/template&quot; that produces a safe HTML document fragment.</source>
          <target state="translated">템플릿은 안전한 HTML 문서 조각을 생성하는 &quot;text / template&quot;의 특수 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="d8a89275d0782e6367eafd96ad18e35d72254fb0" translate="yes" xml:space="preserve">
          <source>Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients.</source>
          <target state="translated">템플릿은 구문 분석 된 템플릿을 나타냅니다. * parse.Tree 필드는 html / template에서만 사용하기 위해 내보내지며 다른 모든 클라이언트에서는 내 보내지 않은 것으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="19cafd4f58542bc1848a2bc09f68f32df89aaeb6" translate="yes" xml:space="preserve">
          <source>Template.Delims</source>
          <target state="translated">Template.Delims</target>
        </trans-unit>
        <trans-unit id="a8aa430f1c13b8e8ba33d56534b8f8c54974c35f" translate="yes" xml:space="preserve">
          <source>TemplateNode represents a {{template}} action.</source>
          <target state="translated">TemplateNode는 {{template}} 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6272b08c56a555c9301dfcc377b8ee08eca7de29" translate="yes" xml:space="preserve">
          <source>Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called &quot;dot&quot;, to the value at the current location in the structure as execution proceeds.</source>
          <target state="translated">템플릿은 데이터 구조에 적용하여 실행됩니다. 템플릿의 주석은 실행을 제어하고 표시 할 값을 도출하기 위해 데이터 구조의 요소 (일반적으로 구조체의 필드 또는 맵의 키)를 나타냅니다. 템플릿을 실행하면 구조를 따라 가고 마침표 '.'로 표시되는 커서를 설정합니다. 실행이 진행됨에 따라 구조에서 현재 위치의 값으로 &quot;도트&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="d659d268d0b2876b00930d9cefac00e94082414d" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">t 또는 관련 템플릿에서 Execute를 처음 사용하기 전에 Parse를 연속적으로 호출하여 템플릿을 다시 정의 할 수 있습니다. 공백과 주석 만 포함 된 본문이있는 템플릿 정의는 비어있는 것으로 간주되며 기존 템플릿의 본문을 대체하지 않습니다. 이렇게하면 구문 분석을 사용하여 기본 템플릿 본문을 덮어 쓰지 않고 새로운 명명 된 템플릿 정의를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0dad97eb547b69ff6ae16e7728cdc906f69fe6a" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">Parse를 연속적으로 호출하여 템플릿을 재정의 할 수 있습니다. 공백과 주석 만 포함 된 본문이있는 템플릿 정의는 비어있는 것으로 간주되며 기존 템플릿의 본문을 대체하지 않습니다. 이렇게하면 구문 분석을 사용하여 기본 템플릿 본문을 덮어 쓰지 않고 새로운 명명 된 템플릿 정의를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b101f8846f53e53dd0074ea44ad4ea7b299215d" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of defined templates associated with t.</source>
          <target state="translated">템플릿은 t와 관련된 정의 된 템플릿 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef678e78b264d52108e80621ab16809ee2f68f32" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of the templates associated with t, including t itself.</source>
          <target state="translated">템플릿은 t 자체를 포함하여 t와 연결된 템플릿 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63499f131caeb094b508fda158f4d32cdfc15875" translate="yes" xml:space="preserve">
          <source>Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.</source>
          <target state="translated">임시는 DNS 오류가 일시적인 것으로 알려 졌는지보고합니다. 이것이 항상 알려진 것은 아닙니다. 일시적인 오류로 인해 DNS 조회가 실패하고 Temporary가 false를 반환하는 DNSError를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102ab778dfcf2daa890ddca81b62a6c8c57e866c" translate="yes" xml:space="preserve">
          <source>Tests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B:</source>
          <target state="translated">테스트 또는 벤치 마크는 * T 또는 * B의 Skip 메소드를 호출하여 런타임에 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fb2cdb8c84498e97b67876bcf9179f6c6a0681c" translate="yes" xml:space="preserve">
          <source>Text and spaces</source>
          <target state="translated">텍스트와 공백</target>
        </trans-unit>
        <trans-unit id="7c3578369bc9761a19920ddfd71d5074fb77328e" translate="yes" xml:space="preserve">
          <source>Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:</source>
          <target state="translated">텍스트는 주어진 형식 및 정밀도에 따라 부동 소수점 숫자 x를 문자열로 변환합니다. 형식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9714bb7b9d9dc65203e2f28091e607a38d20869a" translate="yes" xml:space="preserve">
          <source>Text in the format string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.</source>
          <target state="translated">참조 시간의 일부로 인식되지 않는 형식 문자열의 텍스트는 형식 중 그대로 에코되며 구문 분석 입력에 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a87e174a24b19b122c0ab179b85b925e794409f" translate="yes" xml:space="preserve">
          <source>Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.</source>
          <target state="translated">텍스트는 Scan 호출에 의해 생성 된 최신 토큰을 바이트를 보유하는 새로 할당 된 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9757ee25c7224af6e75db771ea323fc05ac31e21" translate="yes" xml:space="preserve">
          <source>Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as &quot;0x&quot;) is added to the string. If x is a nil pointer it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">텍스트는 주어진 밑에서 x의 문자열 표현을 반환합니다. 밑은 2에서 62 사이 여야합니다. 결과는 숫자 값 10-35에 소문자 'a'- 'z'를 사용하고 숫자 값 36-61에 대문자 'A'- 'Z'를 사용합니다. 접두사 없음 (예 : &quot;0x&quot; )가 문자열에 추가됩니다. x가 nil 포인터이면 &quot;&amp;lt;nil&amp;gt;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42341adeec7d736d3551b283379c31741e77e4f9" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="translated">텍스트는 주석의 텍스트를 반환합니다. 주석 주석 (//, / * 및 * /), 줄 주석의 첫 번째 공백 및 선행 및 후행 빈 줄이 제거됩니다. 여러 개의 빈 줄이 하나로 축소되고 줄의 후행 공간이 잘립니다. 결과가 비어 있지 않으면 개행 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="02af2db9a5ef05bc960487d876c4df951f9ad592" translate="yes" xml:space="preserve">
          <source>Text types have the charset parameter set to &quot;utf-8&quot; by default.</source>
          <target state="translated">텍스트 유형에는 기본적으로 charset 매개 변수가 &quot;utf-8&quot;로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44c08e7f92ae7b5fe535298ff7558bf9d8a0cab" translate="yes" xml:space="preserve">
          <source>TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.</source>
          <target state="translated">TextMarshaler는 텍스트 형식으로 마샬링 할 수있는 개체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ae8b7afc36cfb51ffddc286e90577602c85186e4" translate="yes" xml:space="preserve">
          <source>TextNode holds plain text.</source>
          <target state="translated">TextNode는 일반 텍스트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="48668880c8086b3c4c912b1de227b18b3d9a93e1" translate="yes" xml:space="preserve">
          <source>TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.</source>
          <target state="translated">TextUnmarshaler는 텍스트 표현을 마샬링 해제 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="33b69b32d53f67278f1556c03b99ca73467e15b3" translate="yes" xml:space="preserve">
          <source>That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies.</source>
          <target state="translated">즉, 텍스트와 일치하는 경우 정규 표현식은 입력 (가장 왼쪽)에서 가능한 한 빨리 시작되는 일치를 반환하고 그 중에서 가능한 한 긴 일치를 선택합니다. 이 소위 가장 긴 일치 항목은 초기 정규식 구현에서 사용하고 POSIX에서 지정한 것과 동일한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="1fe9add248f3617655fdc8371d42751cba2e4007" translate="yes" xml:space="preserve">
          <source>The &quot;omitempty&quot; option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</source>
          <target state="translated">&quot;omitempty&quot;옵션은 필드에 빈 값 (false, 0, nil 포인터, nil 인터페이스 값 및 빈 배열, 슬라이스, 맵 또는 문자열)이있는 경우 인코딩에서 필드를 생략하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="71d19b0f94317203bba62dcd8f10cd68c650f96b" translate="yes" xml:space="preserve">
          <source>The &quot;string&quot; option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</source>
          <target state="translated">&quot;string&quot;옵션은 필드가 JSON 인코딩 문자열 내에 JSON으로 저장됨을 나타냅니다. 문자열, 부동 소수점, 정수 또는 부울 유형의 필드에만 적용됩니다. 이 추가 수준의 인코딩은 JavaScript 프로그램과 통신 할 때 가끔 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1ee29ca2c06802f34981d89493c0bb6f1d6d312" translate="yes" xml:space="preserve">
          <source>The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">%! s는 실패가 발생했을 때 사용중인 인쇄 동사를 보여줍니다. 그러나 패닉이 nil 수신자에 의해 Error 또는 String 메소드에 의해 발생하는 경우 출력은 데코 레이팅되지 않은 문자열 &quot;&amp;lt;nil&amp;gt;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="743e4c8e9a91e391bfa222546fd5a23a69c683b9" translate="yes" xml:space="preserve">
          <source>The *Basic type for Typ[Byte] will have the name &quot;uint8&quot;. Use Universe.Lookup(&quot;byte&quot;).Type() to obtain the specific alias basic type named &quot;byte&quot; (and analogous for &quot;rune&quot;).</source>
          <target state="translated">Typ [Byte]의 * Basic 유형은 &quot;uint8&quot;입니다. Universe.Lookup ( &quot;byte&quot;). Type ()을 사용하여 &quot;byte&quot;라는 특정 별칭 기본 유형 ( &quot;rune&quot;과 유사)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="850dd1df743a69c63fe9886362ac383beaaa22a7" translate="yes" xml:space="preserve">
          <source>The AES block size in bytes.</source>
          <target state="translated">바이트 단위의 AES 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5673ab8326600fbbe495a6285dd8ced305ce9de8" translate="yes" xml:space="preserve">
          <source>The AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.</source>
          <target state="translated">이 패키지의 AES 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다. 이러한 작업을 일정하게 유지하는 AES에 대한 하드웨어 지원이 가능한 시스템에서 실행되는 경우는 예외입니다. 예는 AES-NI 확장을 사용하는 amd64 시스템과 Message-Security-Assist 확장을 사용하는 s390x 시스템입니다. 이러한 시스템에서 NewCipher의 결과가 cipher.NewGCM으로 전달되면 GCM에서 사용하는 GHASH 조작도 일정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="6adb0b7099e3661b5d507077f904503946e1529a" translate="yes" xml:space="preserve">
          <source>The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.</source>
          <target state="translated">AuthorityKeyId는 결과 인증서가 자체 서명되지 않은 경우 상위의 SubjectKeyId (있는 경우)에서 가져옵니다. 그렇지 않으면 템플릿의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef02c253bf1371acc1a3bc5ebf403abe9da8e69d" translate="yes" xml:space="preserve">
          <source>The CPU profile is not available as a Profile. It has a special API, the StartCPUProfile and StopCPUProfile functions, because it streams output to a writer during profiling.</source>
          <target state="translated">CPU 프로파일은 프로파일로 사용할 수 없습니다. 프로파일 링 중에 출력을 출력기로 스트리밍하므로 특수 API 인 StartCPUProfile 및 StopCPUProfile 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bb730fcee3dc3ab8099094b237b4e5ff536824" translate="yes" xml:space="preserve">
          <source>The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.</source>
          <target state="translated">Call 메소드는 원격 호출이 완료 될 때까지 대기하는 반면 Go 메소드는 호출을 비동기 적으로 시작하고 Call 구조의 완료 채널을 사용하여 완료 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fa9c5434f905167654701708a6911e94eaa76597" translate="yes" xml:space="preserve">
          <source>The Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.</source>
          <target state="translated">클라이언트와 전송은 응답 헤더를 받으면 서버에서 응답을 반환합니다. 응답 본문은 본문 필드를 읽을 때 요청시 스트리밍됩니다.</target>
        </trans-unit>
        <trans-unit id="a06861d55f6598b58fca7ecb30c8e99763835023" translate="yes" xml:space="preserve">
          <source>The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">클라이언트의 전송에는 일반적으로 내부 상태 (캐시 된 TCP 연결)가 있으므로 필요에 따라 클라이언트를 작성하는 대신 재사용해야합니다. 클라이언트는 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="ceca2d7732940705f6d00b5d32a4fb0ac5b5ffee" translate="yes" xml:space="preserve">
          <source>The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.</source>
          <target state="translated">CloseNotifier 인터페이스는 ResponseWriters에 의해 구현되어 기본 연결이 끊어진 시점을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e611d14841eea36df4afcbef6632f0e94c16f389" translate="yes" xml:space="preserve">
          <source>The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.</source>
          <target state="translated">주석 목록에는 문서 및 주석 필드를 통해 다른 노드에서 가리키는 주석을 포함하여 소스 파일의 모든 주석이 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7243291c556ac8dd62df98afdad8c3760dcef423" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do.</source>
          <target state="translated">Content-Type 헤더는 application / x-www-form-urlencoded로 설정되어 있습니다. 다른 헤더를 설정하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c8514b948c44917ccd4528524ea490c8df7afe9" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Content-Type 헤더는 application / x-www-form-urlencoded로 설정되어 있습니다. 다른 헤더를 설정하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e64fbf6aec6e290cb2a86c841a198b35f0414494" translate="yes" xml:space="preserve">
          <source>The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.</source>
          <target state="translated">현재 프로그램 실행 지점에서 역 추적을 수집하려면 컨텍스트 필드가 0이됩니다. 이 경우 C 코드에서 역 추적 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4ab0b54e24df8d963181a5b8f48a80c3f0be3b" translate="yes" xml:space="preserve">
          <source>The Copy function uses ReaderFrom if available.</source>
          <target state="translated">복사 기능은 사용 가능한 경우 ReaderFrom을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64b7a752d1105251970c527872a99e908894fe83" translate="yes" xml:space="preserve">
          <source>The Copy function uses WriterTo if available.</source>
          <target state="translated">복사 기능은 가능한 경우 WriterTo를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4068b76cb1fd1e06d5771c04e2c02b7fd65472c1" translate="yes" xml:space="preserve">
          <source>The DES block size in bytes.</source>
          <target state="translated">바이트 단위의 DES 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1b8c2351859f5d138662581cb4874dd621eef345" translate="yes" xml:space="preserve">
          <source>The DSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">이 패키지의 DSA 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d5a6f0be8af4ae349714dde142378b2b0dd32c1" translate="yes" xml:space="preserve">
          <source>The Data fields contains object-specific data:</source>
          <target state="translated">데이터 필드에는 객체 별 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d70280d8e959481aa07b78bca8cd9c9158da0c1f" translate="yes" xml:space="preserve">
          <source>The Decoder does only basic sanity checking on decoded input sizes, and its limits are not configurable. Take caution when decoding gob data from untrusted sources.</source>
          <target state="translated">디코더는 디코딩 된 입력 크기에 대한 기본 상태 검사 만 수행하며 한계는 구성 할 수 없습니다. 신뢰할 수없는 소스에서 gob 데이터를 디코딩 할 때주의하십시오.</target>
        </trans-unit>
        <trans-unit id="1a3dcfbdb85a6eb02179c9d5c4dd5b3efbbb6016" translate="yes" xml:space="preserve">
          <source>The Dial function connects to a server:</source>
          <target state="translated">다이얼 기능은 서버에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="e5af1dd969514f431da9aefdd41666a5f815fd72" translate="yes" xml:space="preserve">
          <source>The Error interface identifies a run time error.</source>
          <target state="translated">오류 인터페이스는 런타임 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="8e437b0bdb4841542eba2f049276dee573f887b3" translate="yes" xml:space="preserve">
          <source>The Errorf function lets us use formatting features to create descriptive error messages.</source>
          <target state="translated">Errorf 기능을 사용하면 형식화 기능을 사용하여 설명적인 오류 메시지를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc7e273196b60c7b327e2a1e7c92da50e59b611" translate="yes" xml:space="preserve">
          <source>The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.</source>
          <target state="translated">설명서의 예제 섹션에는 MakeFunc를 사용하여 다양한 유형의 스왑 기능을 작성하는 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4103d71ff7738d060819734b8440840f86eb6a7" translate="yes" xml:space="preserve">
          <source>The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.</source>
          <target state="translated">Flusher 인터페이스는 HTTP 핸들러가 버퍼링 된 데이터를 클라이언트로 플러시 할 수 있도록하는 ResponseWriters에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8989cf7d3fb3d7f0d686b9d17d09faeb78214543" translate="yes" xml:space="preserve">
          <source>The GIF specification is at &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;.</source>
          <target state="translated">GIF 사양은 &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="413f2e2abeee0cebf1b4d1ac0f711038cf2ef825" translate="yes" xml:space="preserve">
          <source>The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; and &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.</source>
          <target state="translated">GOARCH, GOOS, GOPATH 및 GOROOT 환경 변수는 일련의 Go 환경 변수를 완성합니다. 이들은 Go 프로그램 작성에 영향을줍니다 ( &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; 및 &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build 참조&lt;/a&gt; ). GOARCH, GOOS 및 GOROOT는 컴파일시 기록되며이 패키지의 상수 또는 함수에 의해 사용 가능하지만 런타임 시스템의 실행에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="980859c522964a8cbb3109a2a563d54c04b37667" translate="yes" xml:space="preserve">
          <source>The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:</source>
          <target state="translated">GODEBUG 변수는 런타임 내의 디버깅 변수를 제어합니다. 이 명명 된 변수를 설정하는 쉼표로 구분 된 name = val 쌍의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="854b96235a6d258614ac621d5a074c350962980a" translate="yes" xml:space="preserve">
          <source>The GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</source>
          <target state="translated">GODEBUG 변수는 Go의 API 호환성 약속에 포함되지 않습니다. HTTP / 2 지원을 비활성화하기 전에 문제를보고하십시오 : &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07350ebc65d6866cf7470b34fa919f4c89a12e5a" translate="yes" xml:space="preserve">
          <source>The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;.</source>
          <target state="translated">GOGC 변수는 초기 가비지 콜렉션 대상 백분율을 설정합니다. 이전 수집 후 남아있는 새로 할당 된 데이터 대 실시간 데이터의 비율이이 백분율에 도달하면 수집이 트리거됩니다. 기본값은 GOGC = 100입니다. GOGC = off를 설정하면 가비지 수집기가 완전히 비활성화됩니다. 런타임 / 디버그 패키지의 SetGCPercent 함수를 사용하면 런타임에이 백분율을 변경할 수 있습니다. &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="23644add17b2d4ea82387647518fec703dd62cda" translate="yes" xml:space="preserve">
          <source>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit.</source>
          <target state="translated">GOMAXPROCS 변수는 사용자 레벨 Go 코드를 동시에 실행할 수있는 운영 체제 스레드 수를 제한합니다. Go 코드 대신 시스템 호출에서 차단 될 수있는 스레드 수에는 제한이 없습니다. 그것들은 GOMAXPROCS 제한에 포함되지 않습니다. 이 패키지의 GOMAXPROCS 함수는 한계를 쿼리하고 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2dc1829c430b9fe1fcd42a5d7af5182478e7df72" translate="yes" xml:space="preserve">
          <source>The GORACE variable configures the race detector, for programs built using -race. See &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; for details.</source>
          <target state="translated">GORACE 변수는 -race를 사용하여 작성된 프로그램에 대해 레이스 탐지기를 구성합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="895a2c86582e638542cc835d086a523cf9768898" translate="yes" xml:space="preserve">
          <source>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like &amp;ldquo;all&amp;rdquo; but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like &amp;ldquo;system&amp;rdquo; but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See &lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;.</source>
          <target state="translated">GOTRACEBACK 변수는 복구되지 않은 패닉 또는 예기치 않은 런타임 조건으로 인해 Go 프로그램이 실패 할 때 생성되는 출력량을 제어합니다. 기본적으로 실패는 현재 고 루틴에 대한 스택 추적을 인쇄하고 런타임 시스템 내부의 기능을 생략 한 다음 종료 코드 2로 종료합니다. 현재 고 루틴이 없거나 실패하면 모든 고 루틴에 대한 스택 추적을 인쇄합니다. 런타임 내부. GOTRACEBACK = 없음은 고 루틴 스택 추적을 완전히 생략하지 않습니다. GOTRACEBACK = 단일 (기본값)은 위에서 설명한대로 동작합니다. GOTRACEBACK = all은 모든 사용자 생성 고 루틴에 대한 스택 추적을 추가합니다. GOTRACEBACK = system은&amp;ldquo;all&amp;rdquo;과 유사하지만 런타임 기능을위한 스택 프레임을 추가하고 런타임에 의해 내부에 생성 된 고 루틴을 보여줍니다.GOTRACEBACK = crash는&amp;ldquo;시스템&amp;rdquo;과 비슷하지만 종료하는 대신 운영 체제 별 방식으로 충돌합니다. 예를 들어, Unix 시스템에서 충돌은 SIGABRT를 발생시켜 코어 덤프를 트리거합니다. 이전의 이유로 GOTRACEBACK 설정 0, 1 및 2는 각각 none, all 및 system의 동의어입니다. 런타임 / 디버그 패키지의 SetTraceback 함수를 사용하면 런타임시 출력량을 늘릴 수 있지만 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다그러나 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다그러나 환경 변수에 지정된 것보다 적은 양을 줄일 수는 없습니다. 보다&lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="201ea9b13c6c1b11811e547f191be7e93f488ebd" translate="yes" xml:space="preserve">
          <source>The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead.</source>
          <target state="translated">Go 1 호환성 지침으로 인해 이러한 방법의 동작을 변경할 수 없습니다. 대신 Read 또는 ReadMsgIP를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7566eb3c6d36d40991cd457887383d73c8d32f6" translate="yes" xml:space="preserve">
          <source>The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).</source>
          <target state="translated">Go 경로는 Go 소스 코드가 포함 된 디렉토리 트리 목록입니다. 표준 Go 트리에서 찾을 수없는 가져 오기를 해결하기 위해 참조됩니다. 기본 경로는 운영 체제에 적합한 경로 목록으로 해석되는 GOPATH 환경 변수의 값입니다 (유닉스의 경우 변수는 콜론으로 구분 된 문자열, Windows에서는 세미콜론으로 구분 된 문자열, 계획 9에서는 목록) ).</target>
        </trans-unit>
        <trans-unit id="b3cf2d68365e20d0973a301087cdd0150f378764" translate="yes" xml:space="preserve">
          <source>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</source>
          <target state="translated">마샬링하거나 언 마샬링 할 필드를 결정할 때 JSON에 대해 구조체 필드의 가시성 규칙이 수정됩니다. 같은 수준에 여러 개의 필드가 있고 해당 수준이 가장 낮은 중첩 수준이므로 일반적인 Go 규칙에서 선택한 중첩 수준이되면 다음과 같은 추가 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd6453ed937237b824b9a18906363db4d73b2a6" translate="yes" xml:space="preserve">
          <source>The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.</source>
          <target state="translated">HandlerFunc 유형은 일반 함수를 HTTP 핸들러로 사용할 수 있도록하는 어댑터입니다. f가 적절한 서명을 가진 함수이면 HandlerFunc (f)는 f를 호출하는 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="dcde06a75814cbd2f82c57451a15f7098bfdc1f6" translate="yes" xml:space="preserve">
          <source>The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.</source>
          <target state="translated">Hijacker 인터페이스는 HTTP 처리기가 연결을 인계 할 수 있도록하는 ResponseWriters에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3370b385b8e5dd84393ea8ba4a384825a13db61b" translate="yes" xml:space="preserve">
          <source>The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):</source>
          <target state="translated">인터페이스 유형은이 패키지의 루틴을 사용하여 유형에 대한 요구 사항을 설명합니다. 이를 구현하는 모든 유형은 다음과 같은 변형이있는 최소 힙으로 사용될 수 있습니다 (Init가 호출 된 후 또는 데이터가 비어 있거나 정렬 된 경우).</target>
        </trans-unit>
        <trans-unit id="0aee04eced9ac7c3fac2de601ac7413fde3bf654" translate="yes" xml:space="preserve">
          <source>The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean &amp;ldquo;not present,&amp;rdquo; unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.</source>
          <target state="translated">JSON null 값은 해당 Go 값을 nil로 설정하여 인터페이스, 맵, 포인터 또는 슬라이스로 마샬링 해제합니다. null은 종종 &quot;존재하지 않음&quot;을 의미하기 위해 JSON에서 사용되므로 JSON null을 다른 Go 유형으로 마샬링 해제해도 값에 영향을 미치지 않으며 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22f4320ee94c207b6f6c1bf76ec0cc99a4e78e12" translate="yes" xml:space="preserve">
          <source>The Listen function creates servers:</source>
          <target state="translated">청취 기능은 서버를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1e8051445ee7295f2015e153c91e6e9f468a7b9" translate="yes" xml:space="preserve">
          <source>The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</source>
          <target state="translated">맵 유형은 두 가지 일반적인 사용 사례에 최적화되어 있습니다. (1) 주어진 키에 대한 항목이 한 번만 기록되었지만 계속 커지는 캐시 에서처럼 여러 번 읽히는 경우 또는 (2) 여러 고 루틴이 읽고 쓰거나 분리 된 키 세트에 대한 항목을 겹쳐 씁니다. 이 두 가지 경우에 맵을 사용하면 별도의 Mutex 또는 RWMutex와 쌍을 이루는 Go 맵에 비해 잠금 경합이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="93c1aea237df8273d73d6b2b1db4e7c127b7fdb2" translate="yes" xml:space="preserve">
          <source>The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.</source>
          <target state="translated">지도 유형이 특화되어 있습니다. 대부분의 코드는 별도의 잠금 또는 조정 기능이있는 일반 Go 맵을 대신 사용하여 유형 안전성을 높이고 맵 내용과 함께 다른 불변을 쉽게 유지 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="0006e6725a631489c9423aa1f192586acc3a14d6" translate="yes" xml:space="preserve">
          <source>The MergeMode flags control the behavior of MergePackageFiles.</source>
          <target state="translated">MergeMode 플래그는 MergePackageFiles의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="46419978a96c95f07df701b47af9ce0c381fb8e5" translate="yes" xml:space="preserve">
          <source>The New function creates errors whose only content is a text message.</source>
          <target state="translated">New 함수는 내용 만 문자 메시지 인 오류를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ed989955d8475da0903bbb33a13d3c6797487592" translate="yes" xml:space="preserve">
          <source>The PC field will be a value returned by a call to the traceback function.</source>
          <target state="translated">PC 필드는 역 추적 함수 호출에 의해 리턴 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="886ce6ce1a2e11f65b175c91749f88d574c43226" translate="yes" xml:space="preserve">
          <source>The PNG specification is at &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;.</source>
          <target state="translated">PNG 사양은 &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01da8fcfe6b3b9e18fc8125aed80da656d99c50" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when adding the file to the file set via AddFile.</source>
          <target state="translated">지정된 파일의 Pos 값은 [base, base + size] 범위의 숫자이며, AddFile을 통해 파일 세트에 파일을 추가 할 때 base 및 size가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="24b49c8f6cf4d6923667f2f4ded23d7140a2b9f0" translate="yes" xml:space="preserve">
          <source>The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN.</source>
          <target state="translated">우선 순위는 syslog 기능과 심각도의 조합입니다. 예를 들면 다음과 같습니다. LOG_ALERT | LOG_FTP는 FTP 기능에서 경고 심각도 메시지를 보냅니다. 기본 심각도는 LOG_EMERG입니다. 기본 기능은 LOG_KERN입니다.</target>
        </trans-unit>
        <trans-unit id="c56c9b0bbe08c95a239dcc95eda30597b6ca619e" translate="yes" xml:space="preserve">
          <source>The Process it returns can be used to obtain information about the underlying operating system process.</source>
          <target state="translated">반환 된 프로세스는 기본 운영 체제 프로세스에 대한 정보를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10801c2ff1093f1ce7c760ba00803c382474a94e" translate="yes" xml:space="preserve">
          <source>The RSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">이 패키지의 RSA 작업은 상수 시간 알고리즘을 사용하여 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e75efacd08116681c05f3907c86c9cdff60db179" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReader also implements Resetter.</source>
          <target state="translated">NewReader가 반환 한 ReadCloser도 Resetter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3bfc20a3944403086f24f5757939a8cbd9b7c5ac" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReaderDict also implements Resetter.</source>
          <target state="translated">NewReaderDict에 의해 반환 된 ReadCloser도 Resetter를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c4f8edaea822742e73d1aca6a1265098af5d579e" translate="yes" xml:space="preserve">
          <source>The Reader converts all \r\n sequences in its input to plain \n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.</source>
          <target state="translated">Reader는 여러 줄 필드 값을 포함하여 입력의 모든 \ r \ n 시퀀스를 일반 \ n으로 변환하므로 반환 된 데이터는 입력 파일이 사용하는 줄 끝 규칙에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41c2e3518894534a6a634c57bbad5ea70224c3de" translate="yes" xml:space="preserve">
          <source>The Reader.Header fields will be valid in the Reader returned.</source>
          <target state="translated">Reader.Header 필드는 반환 된 Reader에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9fd8011df0852a1e27b3907bd2a3f82247ef31e5" translate="yes" xml:space="preserve">
          <source>The Request.Proto is always HTTP/1.1.</source>
          <target state="translated">Request.Proto는 항상 HTTP / 1.1입니다.</target>
        </trans-unit>
        <trans-unit id="09c4e81d433af7e0ae48c721f621859a4e5a3317" translate="yes" xml:space="preserve">
          <source>The Response Body is closed after it is sent.</source>
          <target state="translated">응답 본문은 전송 된 후 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="041fd8da9679545d4de46a3a12d665330f551006" translate="yes" xml:space="preserve">
          <source>The Response.Body is guaranteed to be non-nil and Body.Read call is guaranteed to not return any error other than io.EOF.</source>
          <target state="translated">Response.Body는 0이 아니며 Body.Read 호출은 io.EOF 이외의 오류를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc99bfa959e73d9ff72d10e54ecd5ffaa2259252" translate="yes" xml:space="preserve">
          <source>The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write.</source>
          <target state="translated">Response.Header는 첫 번째 쓰기 호출 시점 또는 핸들러가 쓰기를 수행하지 않은 경우이 호출 시점의 헤더 스냅 샷입니다.</target>
        </trans-unit>
        <trans-unit id="18a3ebac1f2c2059df0438aac114025f62ecfbf9" translate="yes" xml:space="preserve">
          <source>The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:</source>
          <target state="translated">T 및 B의 Run 방법을 사용하면 각각에 대해 별도의 기능을 정의하지 않고도 하위 테스트 및 하위 벤치 마크를 정의 할 수 있습니다. 이를 통해 테이블 ​​중심 벤치 마크 및 계층 적 테스트 작성과 같은 사용이 가능합니다. 또한 일반적인 설정 및 해제 코드를 공유하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2fdffd1148a25e94f2ea65756e345947d69016d2" translate="yes" xml:space="preserve">
          <source>The SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library.</source>
          <target state="translated">SendMail 기능 및 net / smtp 패키지는 저수준 메커니즘이며 DKIM 서명, MIME 첨부 파일 (mime / multipart 패키지 참조) 또는 기타 메일 기능을 지원하지 않습니다. 더 높은 수준의 패키지는 표준 라이브러리 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a92bd5980ed21b3a625476d07c987591bfa7d7" translate="yes" xml:space="preserve">
          <source>The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.</source>
          <target state="translated">스펙 유형은 * ImportSpec, * ValueSpec 및 * TypeSpec을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4919a225e3add39379ff15a9bce358f52cae5ffb" translate="yes" xml:space="preserve">
          <source>The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.</source>
          <target state="translated">패키지 syscall의 Syscall 함수는 uintptr 인수를 운영 체제에 직접 전달한 다음 호출 세부 사항에 따라 일부를 포인터로 해석 할 수 있습니다. 즉, 시스템 호출 구현은 특정 인수를 uintptr에서 포인터로 암시 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3e332fd0096a988b6619d722b0818e386abfd30a" translate="yes" xml:space="preserve">
          <source>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation.</source>
          <target state="translated">TIFF 파일 형식은 비슷하지만 호환되지 않는 LZW 알고리즘 버전을 사용합니다. 구현 방법은 golang.org/x/image/tiff/lzw 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58336a8c0934089954efcd803d6fca80fefa9eb4" translate="yes" xml:space="preserve">
          <source>The TLS field is set to a non-nil dummy value if target has scheme &quot;https&quot;.</source>
          <target state="translated">대상에 &quot;https&quot;체계가있는 경우 TLS 필드는 0이 아닌 더미 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d581afca4a5305392d28788d2eee7630e8dc138a" translate="yes" xml:space="preserve">
          <source>The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</source>
          <target state="translated">시간에 의해 반환 된 시간. 이제 단조로운 시계 판독 값이 포함됩니다. 시간 t에 단조로운 시계 판독 값이있는 경우, t.Add는 벽시계와 단조로운 시계 판독 값에 동일한 지속 시간을 추가하여 결과를 계산합니다. t.AddDate (y, m, d), t.Round (d) 및 t.Truncate (d)는 월 시간 계산이므로 항상 결과에서 단조로운 시계 판독 값을 제거합니다. t.In, t.Local 및 t.UTC는 벽 시간 해석에 영향을주기 위해 사용되므로 결과에서 단조로운 시계 판독 값도 제거합니다. 단조로운 시계 판독 값을 제거하는 일반적인 방법은 t = t.Round (0)를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="33e81456d15715e940a5919174eaa3f7637dcde7" translate="yes" xml:space="preserve">
          <source>The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.</source>
          <target state="translated">타이머 유형은 단일 이벤트를 나타냅니다. 타이머가 만료되면 AfterFunc에서 타이머를 만들지 않은 경우 현재 시간이 C로 전송됩니다. 타이머는 NewTimer 또는 AfterFunc를 사용하여 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf73d1723f31995bde582871be9d0a7a3c49f2e8" translate="yes" xml:space="preserve">
          <source>The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes.</source>
          <target state="translated">유니버스 범위에는 미리 선언 된 모든 Go 개체가 포함됩니다. 중첩 된 범위 체인 중 가장 바깥 쪽 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d2217feb010f2a9e20eb107dc97fbe00b28a97e3" translate="yes" xml:space="preserve">
          <source>The Unsafe package is the package returned by an importer for the import path &quot;unsafe&quot;.</source>
          <target state="translated">안전하지 않은 패키지는 가져 오기 경로 &quot;안전하지 않은&quot;에 대해 수입자가 반환 한 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="82e1a6db6a2ce451395a30960fcbaa8d447276c7" translate="yes" xml:space="preserve">
          <source>The Unwrap, Is and As functions work on errors that may wrap other errors. An error wraps another error if its type has the method</source>
          <target state="translated">Unwrap, Is 및 As 기능은 다른 오류를 감쌀 수있는 오류에 대해 작동합니다. 유형에 메소드가있는 경우 오류가 다른 오류를 줄임</target>
        </trans-unit>
        <trans-unit id="84a102639d5d98f811fc502808b53b881ef02020" translate="yes" xml:space="preserve">
          <source>The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.</source>
          <target state="translated">Userinfo 유형은 URL의 사용자 이름 및 비밀번호 세부 사항을 변경할 수없는 캡슐화입니다. 기존 Userinfo 값은 사용자 이름 설정 (RFC 2396에서 허용하는대로 비어있을 수 있음) 및 선택적으로 암호를 갖도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd19f3117c4f5404c3dc4318c570ed741a162cd" translate="yes" xml:space="preserve">
          <source>The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.</source>
          <target state="translated">Value.Call 메서드를 사용하면 호출자가 값으로 입력 된 함수를 호출 할 수 있습니다. 반대로 MakeFunc를 사용하면 호출자가 값으로 형식화 된 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b671f0d2f06db5c55a3ebed77ddd3e1fdacf58bc" translate="yes" xml:space="preserve">
          <source>The Wait method will return the exit code and release associated resources once the command exits.</source>
          <target state="translated">Wait 메소드는 종료 코드를 리턴하고 명령이 종료되면 연관된 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f996448ff14d875bb2a49935e2e1a1c11597d19a" translate="yes" xml:space="preserve">
          <source>The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</source>
          <target state="translated">WithCancel, WithDeadline 및 WithTimeout 함수는 컨텍스트 (부모)를 가져오고 파생 된 컨텍스트 (자식) 및 CancelFunc를 반환합니다. CancelFunc를 호출하면 자식과 그 자식을 취소하고 자식에 대한 부모의 참조를 제거하며 관련된 타이머를 중지합니다. CancelFunc를 호출하지 않으면 부모가 취소되거나 타이머가 실행될 때까지 자식과 자식이 누출됩니다. Go Vet 도구는 CancelFuncs가 모든 제어 흐름 경로에 사용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7ad67f6f0923ebfa2c780fb9b0118879fff918f1" translate="yes" xml:space="preserve">
          <source>The Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters.</source>
          <target state="translated">라이터는 모든 유니 코드 코드 포인트의 너비가 같다고 가정합니다. 일부 글꼴 또는 문자열에 결합 문자가 포함 된 경우에는 해당되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b495842c9aa071c7e0475777b24079ec5d06f2" translate="yes" xml:space="preserve">
          <source>The Writer currently provides no support for sparse files.</source>
          <target state="translated">Writer는 현재 스파 스 파일을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53af9c2eed3edf32c0f1e34e826ade2723d6ef7e" translate="yes" xml:space="preserve">
          <source>The Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling Write.</source>
          <target state="translated">한 줄의 적절한 간격은 향후 줄의 셀에 따라 달라질 수 있으므로 Writer는 입력을 내부적으로 버퍼링해야합니다. 클라이언트는 쓰기 호출이 끝나면 Flush를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="628a74097036f85303a5350ae981dc164e95f20b" translate="yes" xml:space="preserve">
          <source>The Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\t') or vertical ('\v') tabs, and newline ('\n') or formfeed ('\f') characters; both newline and formfeed act as line breaks.</source>
          <target state="translated">Writer는 들어오는 바이트를 가로 ( '\ t') 또는 세로 ( '\ v') 탭으로 끝나는 셀과 줄 바꿈 ( '\ n') 또는 폼 피드 ( '\ f')로 구성된 UTF-8 인코딩 텍스트로 처리합니다. 문자; 줄 바꿈과 폼 피드 모두 줄 바꿈 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="ff09099a8f170cf0d12905fa7c7238d645a38332" translate="yes" xml:space="preserve">
          <source>The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:</source>
          <target state="translated">구조체의 XML 요소에는 다음과 같은 예외를 제외하고 구조체의 내 보낸 각 필드에 대한 마샬링 된 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="79336ab4324d9f5dfdaefa0128d6e4be21b88b75" translate="yes" xml:space="preserve">
          <source>The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the &quot;.debug_abbrev&quot; section.</source>
          <target state="translated">[] 바이트 인수는 오브젝트 파일에서 해당 디버그 섹션의 데이터입니다. 예를 들어 ELF 객체의 경우 abbrev는 &quot;.debug_abbrev&quot;섹션의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="76c0ad8d05ede9a06fba9319e4883b6c3aed9f8a" translate="yes" xml:space="preserve">
          <source>The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering.</source>
          <target state="translated">NewReader에 필요한 실제 읽기 인터페이스. 전달 된 io.Reader에 ReadByte도없는 경우 NewReader는 자체 버퍼링을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="c853d84a15cfc8c913087ccf677e5edf1ca53e04" translate="yes" xml:space="preserve">
          <source>The add operation, implemented by the AddT functions, is the atomic equivalent of:</source>
          <target state="translated">AddT 함수로 구현 된 추가 작업은 다음과 같은 원자 적 요소입니다.</target>
        </trans-unit>
        <trans-unit id="7b4a22ebac17d94f75fe50addbae480c54b8e412" translate="yes" xml:space="preserve">
          <source>The addresses in the to parameter are the SMTP RCPT addresses.</source>
          <target state="translated">to 매개 변수의 주소는 SMTP RCPT 주소입니다.</target>
        </trans-unit>
        <trans-unit id="fa78f066db9b3a5524ca42a8affe77f75da9d63e" translate="yes" xml:space="preserve">
          <source>The allocs profile is the same as the heap profile but changes the default pprof display to -alloc_space, the total number of bytes allocated since the program began (including garbage-collected bytes).</source>
          <target state="translated">allocs 프로파일은 힙 프로파일과 동일하지만 기본 pprof 표시를 -alloc_space (프로그램이 시작된 이후 할당 된 총 바이트 수 (가비지 수집 된 바이트 포함))로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="7b7e2adce610eba0eb46d47752259233e509b5f5" translate="yes" xml:space="preserve">
          <source>The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:</source>
          <target state="translated">내장 기능 추가 기능은 슬라이스 끝에 요소를 추가합니다. 용량이 충분하면 대상이 새 요소를 수용하도록 슬라이스됩니다. 그렇지 않은 경우 새로운 기본 배열이 할당됩니다. 추가는 업데이트 된 슬라이스를 반환합니다. 따라서 추가 결과를 종종 슬라이스 자체를 보유하는 변수에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="319121c4cf28a1a73f5a5d055a29a23993940f46" translate="yes" xml:space="preserve">
          <source>The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.</source>
          <target state="translated">인수 obj는 new를 호출하거나 복합 리터럴의 주소를 사용하거나 로컬 변수의 주소를 사용하여 할당 된 객체에 대한 포인터 여야합니다. 인수 finalizer는 obj의 유형을 지정할 수있는 단일 인수를 가져오고 임의의 무시 된 반환 값을 가질 수있는 함수 여야합니다. 둘 중 하나라도 해당되지 않으면 SetFinalizer가 프로그램을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8b4269726f03ea74d83f3435788f2723fca1f6" translate="yes" xml:space="preserve">
          <source>The argument pos must have been returned by a call to Tell on this line table.</source>
          <target state="translated">이 행 테이블에서 Tell을 호출하면 pos 인수가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b92996537add2723dc45807913fd63c71882192d" translate="yes" xml:space="preserve">
          <source>The argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using &quot;matching&quot; to mean &quot;whose name contains&quot;:</source>
          <target state="translated">-run 및 -bench 명령 행 플래그에 대한 인수는 테스트 이름과 일치하는 고정되지 않은 정규식입니다. 하위 테스트와 같이 슬래시로 구분 된 여러 요소가있는 테스트의 경우 인수는 슬래시로 구분되며 각 이름 요소와 차례로 일치하는 표현식이 사용됩니다. 고정되지 않았으므로 빈 표현식은 모든 문자열과 일치합니다. 예를 들어, &quot;일치하는&quot;을 사용하여 &quot;이름이 포함 된&quot;을 의미하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e79a98521fd13244e0b154d938bb00c75c9b0451" translate="yes" xml:space="preserve">
          <source>The base argument must be 0 or a value between 2 and MaxBase. For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0&amp;rdquo;, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the selected base is 10 and no prefix is accepted.</source>
          <target state="translated">기본 인수는 0 또는 2와 MaxBase 사이의 값이어야합니다. 기수 0의 경우, 숫자 접두어가 실제 염기를 결정합니다. &quot;0b&quot;또는 &quot;0B&quot;의 접두어는 기수 2를 선택하고 &quot;0&quot;, &quot;0o&quot;또는 &quot;0O&quot;는 기수 8을 선택하고 &quot;0x&quot;또는 &quot;0X&quot;는 선택합니다 그렇지 않으면 선택한 기준은 10이고 접두사는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f5bc3650196f245f397cccfe0b715471a484024" translate="yes" xml:space="preserve">
          <source>The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic.</source>
          <target state="translated">기본 인수는 0, 2, 8, 10 또는 16이어야합니다. 잘못된 기본 인수를 제공하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="999251e457607fde479613cc188e10bb8aa35ffc" translate="yes" xml:space="preserve">
          <source>The behavior of Close after the first call is undefined. Specific implementations may document their own behavior.</source>
          <target state="translated">첫 번째 호출 후 닫기 동작은 정의되지 않습니다. 특정 구현은 자체 동작을 문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5501fbd34c66d8be25df49275f9a5880a90030a" translate="yes" xml:space="preserve">
          <source>The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output</source>
          <target state="translated">벤치 마크 함수는 대상 코드를 bN 회 실행해야합니다. 벤치 마크 실행 동안 bN은 벤치 마크 기능이 안정적으로 시간을 초과 할 정도로 오래 지속될 때까지 조정됩니다. 출력</target>
        </trans-unit>
        <trans-unit id="5d5239994cd75391745c3ffd216fe5a8cda11e2c" translate="yes" xml:space="preserve">
          <source>The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.</source>
          <target state="translated">bin / 디렉토리에는 컴파일 된 명령이 있습니다. 각 명령의 이름은 소스 디렉토리로 지정되지만 전체 경로가 아닌 최종 요소 만 사용합니다. 즉, DIR / src / foo / quux에 소스가있는 명령은 DIR / bin / foo / quux가 아닌 DIR / bin / quux에 설치됩니다. foo /는 제거되어 PATH에 DIR / bin을 추가하여 설치된 명령을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb2943938d895315eb0861e562b65ec37e4257a" translate="yes" xml:space="preserve">
          <source>The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.</source>
          <target state="translated">bitSize 인수는 결과가 적합해야하는 정수 유형을 지정합니다. 비트 크기 0, 8, 16, 32 및 64는 int, int8, int16, int32 및 int64에 해당합니다. bitSize가 0보다 작거나 64보다 크면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="73a023e42c8f449dd9afceb038f53730f09d0f3a" translate="yes" xml:space="preserve">
          <source>The blocksize of MD5 in bytes.</source>
          <target state="translated">MD5의 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="b15f9638286bf74ad9f05789a97346025af52de4" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA-1 in bytes.</source>
          <target state="translated">SHA-1의 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a7b36663bea360572efce2e38cb3e1eb26ceecf3" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA256 and SHA224 in bytes.</source>
          <target state="translated">SHA256 및 SHA224의 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="97aa274f72b6214d58f8cac268e6604a5f6faa7b" translate="yes" xml:space="preserve">
          <source>The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run.</source>
          <target state="translated">신체 기능은 각 고 루틴에서 실행됩니다. goroutine-local 상태를 설정 한 다음 pb.Next가 false를 리턴 할 때까지 반복해야합니다. StartTimer, StopTimer 또는 ResetTimer 함수는 전역 효과가 있으므로 사용하지 않아야합니다. 또한 Run을 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="af7dc8ebb6f00c62864546d31e047f12c2a2774d" translate="yes" xml:space="preserve">
          <source>The boolean functions take any zero value to be false and a non-zero value to be true.</source>
          <target state="translated">부울 함수는 0을 false로, 0이 아닌 값을 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0ca3ec8906bf9075e98bceae22793965b445ac42" translate="yes" xml:space="preserve">
          <source>The boundary is usually obtained from the &quot;boundary&quot; parameter of the message's &quot;Content-Type&quot; header. Use mime.ParseMediaType to parse such headers.</source>
          <target state="translated">경계는 일반적으로 메시지 &quot;Content-Type&quot;헤더의 &quot;boundary&quot;매개 변수에서 가져옵니다. 이러한 헤더를 구문 분석하려면 mime.ParseMediaType을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93f9cb3d63de38d1cca4d1f9efd9ca872f4716ce" translate="yes" xml:space="preserve">
          <source>The built-in table is small but on unix it is augmented by the local system's mime.types file(s) if available under one or more of these names:</source>
          <target state="translated">내장 테이블은 작지만 유닉스에서는 다음 이름 중 하나 이상에서 사용 가능한 경우 로컬 시스템의 mime.types 파일로 기능이 보강됩니다.</target>
        </trans-unit>
        <trans-unit id="e3abe768a37a21ebff40b7c9151a7b3edc6c44e0" translate="yes" xml:space="preserve">
          <source>The calendrical calculations always assume a Gregorian calendar, with no leap seconds.</source>
          <target state="translated">달력 계산은 항상 윤초가없는 그레고리력을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dd3a4f20159bb2231f4a88b4a45f4b772e80ba3c" translate="yes" xml:space="preserve">
          <source>The caller should call Close when finished, to shut it down.</source>
          <target state="translated">호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="257fee20f0af9c58c89645e121bcb859cd7d2ba2" translate="yes" xml:space="preserve">
          <source>The cap built-in function returns the capacity of v, according to its type:</source>
          <target state="translated">cap 내장 함수는 유형에 따라 v의 용량을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e553ed25dbd923acc16eb919df1e53d3eec5c8ba" translate="yes" xml:space="preserve">
          <source>The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer.</source>
          <target state="translated">인증서는 부모가 서명합니다. 부모가 템플릿과 같으면 인증서가 자체 서명됩니다. 매개 변수 pub는 서명자의 공개 키이고 priv는 서명자의 개인 키입니다.</target>
        </trans-unit>
        <trans-unit id="dc1a26e65aace69e5a0db7ec46a4e897871c5c8e" translate="yes" xml:space="preserve">
          <source>The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.</source>
          <target state="translated">체인은 err 자체와 Unwrap을 반복적으로 호출하여 얻은 일련의 오류로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="784fcd80e08909ffdec4906c1c0dba2f7d623904" translate="yes" xml:space="preserve">
          <source>The client must close the response body when finished with it:</source>
          <target state="translated">클라이언트는 다음과 같이 응답 본문을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="7b4dd52e8c63aa6987cf8c226672c7d4edb96f82" translate="yes" xml:space="preserve">
          <source>The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form</source>
          <target state="translated">내장 기능 닫기 기능은 양방향 또는 전송 전용 채널이어야합니다. 송신자는 수신자가 아닌 송신자 만 실행해야하며 마지막 송신 된 값을 수신 한 후 채널을 종료하는 효과가 있습니다. 닫힌 채널 c에서 마지막 값을 수신 한 후 c로부터의 모든 수신은 차단하지 않고 채널 요소의 0 값을 반환합니다. 형태</target>
        </trans-unit>
        <trans-unit id="0c580a2c87e0f2186896309d301dc63aad975a10" translate="yes" xml:space="preserve">
          <source>The command must have been started by Start.</source>
          <target state="translated">명령은 시작으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8e35ecfe346ef37bdb6a41007c64b491f6581e" translate="yes" xml:space="preserve">
          <source>The comment prefix &quot;Unordered output:&quot; is like &quot;Output:&quot;, but matches any line order:</source>
          <target state="translated">주석 접두어 &quot;정렬되지 않은 출력 :&quot;은 &quot;출력 :&quot;과 비슷하지만 모든 행 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="af6f6bfe9472d6cd742ab07f4d13576c62ddc94c" translate="yes" xml:space="preserve">
          <source>The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:</source>
          <target state="translated">CompareAndSwapT 함수로 구현 된 비교 및 ​​스왑 작업은 다음과 같은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">비교 함수는 기본 유형 (또는 &quot;celsius float32&quot;와 같은 명명 된 기본 유형)에서만 작동합니다. 크기와 정확한 유형이 무시되는 것을 제외하고 값 비교를 위해 Go 규칙을 구현하므로 부호가 있거나 부호가없는 정수 값을 다른 정수 값과 비교할 수 있습니다. (산술 값은 비트 패턴이 아니라 비교되므로 모든 음의 정수는 부호없는 모든 정수보다 작습니다.) 그러나 평소와 같이 int를 float32 등과 비교하지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">컴파일러는 참조 된 할당 된 객체가있는 경우 유지되고 호출이 완료 될 때까지 이동하지 않도록 배열에 구현 된 함수에 대한 호출의 인수 목록에서 uintptr로 변환 된 포인터를 처리합니다. 통화 중에 객체가 더 이상 필요하지 않은 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">복합 내장 함수는 두 개의 부동 소수점 값으로 복합 값을 구성합니다. 실수와 허수 부분의 크기는 float32 또는 float64 (또는 할당 가능)와 동일해야하며 반환 값은 해당 복합 유형 (float32의 경우 complex64, float64의 경우 complex128)이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">압축 수준은 DefaultCompression, NoCompression, HuffmanOnly 또는 BestSpeed와 BestCompression 사이의 정수 값일 수 있습니다. 수준이 유효하면 반환 된 오류는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">상수 UpperLower는 불가능한 델타 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">콘텐츠의 Seek 메서드가 작동해야합니다. ServeContent는 콘텐츠의 끝을 탐색하여 크기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">컨텍스트 함수는 단일 인수, 구조체에 대한 포인터와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">변환 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">내장 복사 기능은 소스 슬라이스에서 대상 슬라이스로 요소를 복사합니다. 특수한 경우에는 문자열에서 바이트 조각으로 바이트를 복사하기도합니다. 소스와 대상이 겹칠 수 있습니다. 복사는 복사 된 요소 수를 리턴하며, 최소 len (src) 및 len (dst)입니다.</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">개수는 반환 할 부분 문자열의 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">crypto / tls 패키지는 CBC 모드 암호화 및 SHA1 변형에 대한 Lucky13 공격에 대한 일부 대책 만 구현합니다. &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; 및 &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">암호화 작업은 상수 시간 알고리즘을 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">암호화 작업은 상수 시간 알고리즘을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PublicKey, * ecdsa.PublicKey 및 ed25519.PublicKey입니다. pub는 지원되는 키 유형이어야하며 priv는 지원되는 공개 키가있는 crypto.Signer 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">디버그 매개 변수는 추가 출력을 사용 가능하게합니다. debug = 0을 전달하면 pprof에 필요한 16 진 주소 만 인쇄됩니다. debug = 1을 전달하면 프로그래머가 도구없이 프로파일을 읽을 수 있도록 주소를 함수 이름 및 행 번호로 변환하는 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">netgo 또는 netcgo 빌드 태그를 설정하여 Go 소스 트리를 구축하는 동안 결정을 강제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">Reader의 Read 메서드에 의해 반환 된 디코딩 된 형식은 &quot;\ r \ n&quot;줄 끝을 더 간단한 &quot;\ n&quot;으로 다시 쓰고, 존재하는 경우 선행 점 이스케이프를 제거하고, io.EOF 오류와 함께 종료합니다. 시퀀스 라인.</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">디코더는 자체 버퍼링을 도입하고 요청 된 JSON 값을 넘어 r에서 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">기본 HTTP / 1.x 및 HTTP / 2 ResponseWriter 구현은 Flusher를 지원하지만 ResponseWriter 랩퍼는 지원하지 않을 수 있습니다. 처리기는 항상 런타임에이 기능을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">HTTP / 1.x 연결 용 기본 ResponseWriter는 Hijacker를 지원하지만 HTTP / 2 연결은 의도적으로 지원하지 않습니다. ResponseWriter 랩퍼도 Hijacker를 지원하지 않을 수 있습니다. 처리기는 항상 런타임에이 기능을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">기본 동작은 package net에서 소켓 파일을 만든 경우에만 연결 해제하는 것입니다. 즉, 리스너 및 기본 소켓 파일이 Listen 또는 ListenUnix에 대한 호출로 작성되면 기본적으로 리스너를 닫으면 소켓 파일이 제거됩니다. 그러나 기존 소켓 파일을 사용하기 위해 FileListener를 호출하여 리스너를 작성한 경우 기본적으로 리스너를 닫으면 소켓 파일이 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">% v의 기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">기본 최대 유휴 연결은 현재 2입니다. 이것은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">기본 명령 줄 플래그 집합은 최상위 기능에 의해 제어됩니다. FlagSet 유형을 사용하면 명령 줄 인터페이스에서 하위 명령을 구현하는 등 독립적 인 플래그 집합을 정의 할 수 있습니다. FlagSet의 메소드는 명령 행 플래그 세트의 최상위 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">정의 조치는 문자열 상수를 제공하여 작성중인 템플리트의 이름을 지정합니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">정의 된 파일 모드 비트는 FileMode의 최상위 비트입니다. 9 개의 최하위 비트는 표준 Unix rwxrwxrwx 권한입니다. 이 비트 값은 공개 API의 일부로 간주되어야하며 유선 프로토콜 또는 디스크 표현에 사용될 수 있습니다. 새 비트가 추가 될 수는 있지만 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">내장 기능 삭제 기능은 지정된 키 (m [key])를 가진 요소를 맵에서 삭제합니다. m이 nil이거나 그러한 요소가없는 경우 delete는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">사전이 없을 수 있습니다. 그렇지 않으면 기록기가 닫힐 때까지 내용을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">채널의 방향은 이러한 상수 중 하나로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">채널 유형의 방향은 다음 상수 중 하나 또는 둘 다를 포함하는 비트 마스크로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">디렉토리가 존재한다고 보증 할 수 없으며 액세스 가능한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">http.Request.Write에 대한 문서는 덤프에 포함 된 req 필드를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">이 문서는 패키지의 보안 기능에 중점을 둡니다. 템플릿 자체를 프로그래밍하는 방법에 대한 자세한 내용은 텍스트 / 템플릿 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">이전 색인 항목은 임베드 깊이 0부터 시작하여 x에서 f까지 유형을 암시 적으로 순회하는 임베드 된 필드의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">이전 색인 항목은 깊이 0에서 시작하여 찾은 항목에 도달하기 위해 순회 된 임베드 된 struct 필드의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">인코딩 된 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 마지막 조각에 대한 특수 인코딩을 사용하여 4 바이트 청크를 처리하므로 큰 데이터 스트림의 개별 블록에 사용하기에는 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">각 구조체 필드의 인코딩은 구조체 필드의 태그에서 &quot;json&quot;키 아래에 저장된 형식 문자열로 사용자 정의 할 수 있습니다. 형식 문자열은 필드 이름을 제공하며 쉼표로 구분 된 옵션 목록이 나옵니다. 기본 필드 이름을 재정의하지 않고 옵션을 지정하기 위해 이름이 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 출력을 4 바이트의 배수로 채 웁니다. 따라서 인코딩은 큰 데이터 스트림의 개별 블록에 사용하기에 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">인코딩은 출력을 8 바이트의 배수로 채 웁니다. 따라서 인코딩은 큰 데이터 스트림의 개별 블록에 사용하기에 적합하지 않습니다. 대신 NewEncoder ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">전체 테스트 파일은 단일 예제 함수, 하나 이상의 다른 함수, 유형, 변수 또는 상수 선언을 포함하고 테스트 또는 벤치 마크 함수가없는 경우 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">환경 값은 완전한 URL 또는 &quot;host [: port]&quot;일 수 있으며,이 경우 &quot;http&quot;체계가 가정됩니다. 값이 다른 형식이면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">오류 내장 인터페이스 유형은 오류 조건을 나타내는 일반적인 인터페이스이며, nil 값은 오류가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">읽은 바이트가없는 경우에만 오류가 EOF입니다. 일부 바이트 만 읽은 후 EOF가 발생하면 Read는 ErrUnexpectedEOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseFloat가 리턴하는 오류에는 구체적인 유형 * NumError가 있으며 err.Num = s가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">ParseInt가 리턴하는 오류에는 구체적인 유형 * NumError가 있으며 err.Num = s가 포함됩니다. s가 비어 있거나 유효하지 않은 숫자가 포함 된 경우 err.Err = ErrSyntax이며 반환 값은 0입니다. s에 해당하는 값이 지정된 크기의 부호있는 정수로 표시 될 수없는 경우 err.Err = ErrRange이고 리턴 된 값은 해당 bitSize 및 부호의 최대 크기 정수입니다.</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">바이너리를 별도의 Objs로 나누는 정확한 방법은 심볼 테이블 형식의 내부 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Time.Format의 실행 예제는 레이아웃 문자열의 작동을 자세하게 보여 주며 좋은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">실행 추적은 고 루틴 생성 / 차단 / 차단 해제, syscall 입력 / 종료 / 차단, GC 관련 이벤트, 힙 크기 변경, 프로세서 시작 / 중지 등과 같은 광범위한 실행 이벤트를 캡처합니다. 정밀한 나노초 정밀도 타임 스탬프 및 스택 추적은 대부분의 이벤트에 대해 캡처됩니다. 생성 된 트레이스는`go tool trace`를 사용하여 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">친숙한 기본 설정 접두사 0b (2 진), 0o 및 0 (8 진) 및 0x (16 진)는 숫자 구분 밑줄과 같이 형식이 없거나 % v 동사를 사용하여 정수를 스캔 할 때 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">필드 의미는 클라이언트와 서버 사용간에 약간 다릅니다. 아래 필드에 대한 참고 사항 외에도 Request.Write 및 RoundTripper에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">그런 다음 파일의 데이터를 바이트 조각으로 읽을 수 있습니다. 읽기 및 쓰기는 인수 슬라이스의 길이에서 바이트 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">파일 경로 패키지는 운영 체제에 따라 슬래시 또는 백 슬래시를 사용합니다. 운영 체제와 상관없이 항상 슬래시를 사용하는 URL과 같은 경로를 처리하려면 경로 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">종료자는 프로그램이 더 이상 obj가 가리키는 객체에 도달 할 수없는 후 임의의 시간에 실행되도록 예약됩니다. 종료자는 프로그램이 종료되기 전에 실행된다는 보장이 없으므로 일반적으로 장기 실행 프로그램 중에 오브젝트와 연관된 비 메모리 자원을 해제하는 경우에만 유용합니다. 예를 들어, os.File 객체는 프로그램이 Close를 호출하지 않고 os.File을 버릴 때 종료자를 사용하여 관련 운영 체제 파일 설명자를 닫을 수 있지만 메모리 내 I를 플러시하기 위해 종료자를 의존하는 것은 실수입니다 프로그램 종료시 버퍼가 플러시되지 않으므로 bufio.Writer와 같은 / O 버퍼</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">ReadContinuedLine에 대한 첫 번째 호출은 &quot;Line 1 continue ...&quot;를 반환하고 두 번째 호출은 &quot;Line 2&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">첫 번째 통화는 현재 사용자 정보를 캐시합니다. 후속 통화는 캐시 된 값을 반환하며 현재 사용자의 변경 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">Go 프로그램 프로파일 링의 첫 번째 단계는 프로파일 링을 활성화하는 것입니다. 표준 테스트 패키지로 구축 된 프로파일 링 벤치 마크 지원은 go test에 내장되어 있습니다. 예를 들어 다음 명령은 현재 디렉토리에서 벤치 마크를 실행하고 CPU 및 메모리 프로파일을 cpu.prof 및 mem.prof에 씁니다.</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">fmt 패키지의 Errorf 기능을 사용하면 패키지의 포맷 기능을 사용하여 설명적인 오류 메시지를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">다음 환경 변수 (호스트 운영 체제에 따라 $ name 또는 % name %)는 Go 프로그램의 런타임 동작을 제어합니다. 의미와 사용은 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">다음 예는 copy-on-write 관용구를 사용하여 확장 가능하고 자주 읽지 만 자주 업데이트되지 않는 데이터 구조를 유지 관리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">다음 예제는 주기적 프로그램 구성 업데이트 및 변경 사항을 작업자 goroutines에 전파하기 위해 Value를 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">다음과 같은 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PrivateKey, * ecdsa.PrivateKey 및 ed25519.PrivateKey입니다. 지원되지 않는 키 유형으로 인해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">현재 지원되는 키 유형은 * rsa.PublicKey, * ecdsa.PublicKey 및 ed25519.PublicKey입니다. 지원되지 않는 키 유형으로 인해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">포인터와 관련된 다음 패턴이 유효합니다. 이러한 패턴을 사용하지 않는 코드는 현재 유효하지 않거나 향후 유효하지 않을 수 있습니다. 아래의 유효한 패턴조차도 중요한 경고와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">다음 표는 각 형식의 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">구조체 필드의 다음 태그는 비 정렬 화에 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">fmt 형식은 'b'(-ddddp &amp;plusmn; ddd, 이진 지수), 'e'(-d.dddde &amp;plusmn; dd, 십진 지수), 'E'(-d.ddddE &amp;plusmn; dd, 십진 지수) 중 하나입니다. ), 'f'(-ddd.dddd, 지수 없음), 'g'(큰 지수의 경우 'e', ​​그렇지 않은 경우 'f'), 'G'(큰 지수의 경우 'E', 그렇지 않은 경우 'f'), ' x '(-0xd.ddddp &amp;plusmn; ddd, 16 진 분수 및 이진 지수) 또는'X '(-0Xd.ddddP &amp;plusmn; ddd, 16 진 분수 및 이진 지수)</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">형식 2, _2 및 02는 채워지지 않고 공백으로 채워지며 0으로 채워진 요일입니다. __2 및 002 형식은 공백으로 채워지고 0으로 채워진 3 문자 일입니다. 패딩되지 않은 요일 형식은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">폼 피드 문자는 줄 바꿈처럼 작동하지만 현재 행의 모든 ​​열을 종료합니다 (효과적으로 Flush 호출). 다음 줄의 탭으로 끝나는 셀은 새 열을 시작합니다. HTML 태그 나 이스케이프 처리 된 텍스트 세그먼트에서 찾을 수없는 경우, 양식 공급 문자가 출력에서 ​​줄 바꿈으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">atEOF가 true가 아니면 함수는 빈 데이터 조각으로 호출되지 않습니다. 그러나 atEOF가 true이면 데이터가 비어 있지 않을 수 있으며 항상 그렇듯이 처리되지 않은 텍스트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">함수는 예를 들어 (전체 결과가 작성되기 전에) 일찍 반환되고 잘못된 AST로 인해 형식 오류가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">제공된 인터페이스가 슬라이스가 아닌 경우 기능 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">z &amp;lt;0 인 경우 함수 패닉이 발생합니다.이 경우 z 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">이 패키지의 기능을 통해 프로그램은 Go 프로그램이 신호를 처리하는 방식을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">기본 인터페이스를 이미지라고합니다. 이미지는 이미지 / 컬러 패키지에 설명 된 색상을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">gc 런타임은 채널 요소 유형에 64KB의 제한을 부과합니다. t의 크기가이 한계와 같거나 초과하면 ChanOf 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">대표되는 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">gzip 파일은 압축 파일에 대한 메타 데이터를 제공하는 헤더를 저장합니다. 이 헤더는 Writer 및 Reader 구조체의 필드로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">핸들러는 일반적으로 nil이며,이 경우 DefaultServeMux가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">공백과 개행 처리는 C의 scanf 패밀리와 처리 방식이 다릅니다. C에서 개행은 다른 공백으로 취급되며 형식 문자열에서 공백이 입력에서 소비되는 공백을 찾지 못하면 결코 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">힙 덤프 형식은 &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">힙 프로파일은 가장 최근에 완료된 가비지 콜렉션으로 통계를보고합니다. 실시간 데이터와 가비지로 프로파일이 기울어지지 않도록 최신 할당을 생략합니다. 가비지 콜렉션이 전혀없는 경우 힙 프로파일은 알려진 모든 할당을보고합니다. 이 예외는 주로 가비지 수집을 사용하지 않고 실행중인 프로그램에서 주로 디버깅 목적으로 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">힙 프로파일은 응용 프로그램 메모리의 모든 활성 오브젝트 및 프로그램 시작 이후 할당 된 모든 오브젝트에 대한 할당 사이트를 모두 추적합니다. Pprof의 -inuse_space, -inuse_objects, -alloc_space 및 -alloc_objects 플래그는 표시 할 항목을 선택하고 기본값은 -inuse_space (실제 오브젝트, 크기별로 조정 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">http 패키지의 전송 및 서버는 간단한 구성을 위해 HTTP / 2 지원을 자동으로 활성화합니다. 보다 복잡한 구성을 위해 HTTP / 2를 사용하도록 설정하거나, 더 낮은 수준의 HTTP / 2 기능을 사용하거나, 최신 버전의 Go http2 패키지를 사용하려면 &quot;golang.org/x/net/http2&quot;를 직접 가져와 ConfigureTransport 및 / 또는 ConfigureServer 기능. golang.org/x/net/http2 패키지를 통한 HTTP / 2 수동 구성은 net / http 패키지의 내장 HTTP / 2 지원보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">글로벌 유니 캐스트 주소 식별은 IPv4 지정 브로드 캐스트 주소를 제외하고 RFC 1122, RFC 4632 및 RFC 4291에 정의 된 주소 유형 식별을 사용합니다. ip가 IPv4 개인 주소 공간 또는 로컬 IPv6 유니 캐스트 주소 공간에 있더라도 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">imag 내장 함수는 복소수 c의 허수 부분을 반환합니다. 리턴 값은 c의 유형에 해당하는 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">이 구현은 스트림의 각 데이터 유형에 대한 사용자 지정 코덱을 컴파일하며 단일 인코더를 사용하여 값 스트림을 전송하여 컴파일 비용을 상쇄 할 때 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">구현 fn은 인수 Value 슬라이스에 typ에서 제공 한 인수의 수와 유형이 있다고 가정 할 수 있습니다. typ이 variadic 함수를 설명하는 경우 최종 Value 자체는 variadic 함수 본문에서와 같이 variadic 인수를 나타내는 슬라이스입니다. fn에 의해 반환 된 결과 값 조각에는 typ에서 제공 한 결과의 수와 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">구현은 HTTP (RFC 2388) 및 널리 사용되는 브라우저에서 생성 된 멀티 파트 바디에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">구현시 읽기 중에 압축을 풀고 쓰기 중에 압축하는 필터를 제공합니다. 예를 들어, 압축 된 데이터를 버퍼에 쓰려면 :</target>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">입력 스트림은 배열 및 객체의 시작과 끝을 표시하기 위해 Delim 유형의 구분 기호 [] {}와 함께 기본 JSON 값 (bool, string, number 및 null)으로 구성됩니다. 쉼표와 콜론이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">템플릿의 입력 텍스트는 모든 형식의 UTF-8 인코딩 텍스트입니다. &quot;작업&quot;(데이터 평가 또는 제어 구조)은 &quot;{{&quot;및 &quot;}}&quot;로 구분됩니다. 조치 외부의 모든 텍스트는 변경되지 않은 출력으로 복사됩니다. 원시 문자열을 제외하고 작업은 줄 바꿈에 해당하지 않지만 주석은 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">키 이름은 인용 부호, 백 슬래시 및 쉼표를 제외하고 유니 코드 문자, 숫자 및 ASCII 문장 부호로만 구성된 비어 있지 않은 문자열 인 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">CanonicalHeaderKey에서 반환 한 키는 정식 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">label 매개 변수에는 암호화되지 않지만 메시지에 중요한 컨텍스트를 제공하는 임의의 데이터가 포함될 수 있습니다. 예를 들어, 주어진 공개 키를 사용하여 두 가지 유형의 메시지를 해독하는 경우 고유 한 레이블 값을 사용하여 한 목적의 암호 텍스트를 공격자가 다른 목적으로 사용할 수 없도록 할 수 있습니다. 필요하지 않은 경우 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">레이블 매개 변수는 암호화 할 때 제공된 값과 일치해야합니다. 자세한 내용은 EncryptOAEP를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">마지막 색인 항목은 항목이 발견 된 (포함될 수있는) 유형의 필드 또는 메소드 색인입니다.</target>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">len 내장 함수는 유형에 따라 v의 길이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">제한은 고 루틴 수가 아닌 운영 체제 스레드 수를 제어합니다. Go 프로그램은 goroutine을 실행할 준비가되었을 때만 새 스레드를 작성하지만 기존의 모든 스레드는 시스템 호출, cgo 호출에서 차단되거나 런타임 사용으로 인해 다른 고 루틴에 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">가능한 객체 종류의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">토큰 목록.</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">LoadT 및 StoreT 함수로 구현 된로드 및 저장 조작은 &quot;return * addr&quot;및 &quot;* addr = val&quot;과 같은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">조회 기능은 결과 임포터가 임포트 경로를 분석해야 할 때마다 호출됩니다. 이 모드에서 임포터는 정식 임포트 경로 (상대 또는 절대 경로는 아님)로만 호출 할 수 있습니다. 표준 임포트 경로로의 변환은 임포터의 클라이언트에 의해 수행되고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">따라서 낮은 비트는 부호 비트와 유사하지만,이를 보완 비트로 만들면 가장 큰 음의 정수가 특별한 경우가 아닙니다. 예를 들어, -129 = ^ 128 = (^ 256 &amp;gt;&amp;gt; 1)은 (FE 01 01)로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">주요 사용 사례는 실행 파일과 관련된 리소스를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">내장 함수 작성은 slice, map 또는 chan 유형의 오브젝트를 할당하고 초기화합니다 (전용). new와 마찬가지로 첫 번째 인수는 값이 아닌 유형입니다. new와 달리 make의 반환 유형은 포인터의 형식이 아니라 인수의 유형과 동일합니다. 결과 사양은 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">매개 변수 fset, pkg 및 pos의 의미는 CheckExpr과 동일합니다. expr을 성공적으로 구문 분석 할 수 없거나 결과 expr AST를 유형 검사 할 수없는 경우 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">메시지는 공용 모듈러스 길이에서 해시 길이의 두 배를 뺀 길이보다 길지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">Dial과 같은 기능을 사용하거나 LookupHost 및 LookupAddr와 같은 기능을 사용하여 간접적으로 도메인 이름을 확인하는 방법은 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">메소드의 첫 번째 인수는 호출자가 제공 한 인수를 나타냅니다. 두 번째 인수는 호출자에게 리턴되는 결과 매개 변수를 나타냅니다. nil이 아닌 경우, 메소드의 리턴 값은 클라이언트가 오류에 의해 생성 된 것처럼 보이는 문자열로 다시 전달됩니다. 오류가 리턴되면 응답 매개 변수가 클라이언트로 다시 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">메소드는 * os.File의 메소드와 동일하게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">따라서 바이너리 전용 패키지의 최소 소스 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">트리의 최소 요소는 인덱스 0의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">mode 매개 변수는 구문 분석 된 소스 텍스트의 양 및 기타 선택적 구문 분석기 기능을 제어합니다. 위치 정보는 파일 세트 fset에 기록되며 이는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">월, 일,시, 최소, 초 및 nsec 값은 일반적인 범위를 벗어날 수 있으며 변환 중에 정규화됩니다. 예를 들어 10 월 32 일은 11 월 1 일로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">가장 일반적인 숫자 변환은 Atoi (string to int) 및 Itoa (int to string)입니다.</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">이 패턴의 가장 일반적인 용도는 구조체의 구조체 나 배열의 요소에 액세스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">msg 매개 변수는 먼저 헤더가있는 RFC 822 스타일 이메일이어야하며, 빈 줄과 메시지 본문이 있어야합니다. msg 줄은 CRLF로 종료되어야합니다. msg 헤더는 일반적으로 &quot;보낸 사람&quot;, &quot;받는 사람&quot;, &quot;제목&quot;및 &quot;Cc&quot;와 같은 필드를 포함해야합니다. &quot;숨은 참조&quot;메시지는 to 매개 변수에 전자 메일 주소를 포함하지만 msg 헤더에는 포함하지 않으면됩니다.</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">XML 요소의 이름은 기본 설정 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">패키지에 대한 예제, 함수 F, 유형 T 및 유형 T의 메소드 M을 선언하는 이름 지정 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">net, net / http 및 crypto / tls 패키지는 GODEBUG의 변수 디버깅을 참조합니다. 자세한 내용은 해당 패키지의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">net / http / cookiejar 패키지는 CookieJar 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">net / rpc 패키지가 정지되어 새로운 기능을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot;또는 &quot;unixpacket&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">네트워크는 &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;또는 IP 전송이어야합니다. IP 전송은 &quot;ip : 1&quot;또는 &quot;ip : icmp&quot;와 같이 &quot;ip&quot;, &quot;ip4&quot;또는 &quot;ip6&quot;다음에 콜론과 리터럴 프로토콜 번호 또는 프로토콜 이름이옵니다.</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 &quot;unix&quot;또는 &quot;unixpacket&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">네트워크는 &quot;unixgram&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">네트워크는 TCP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 TCP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">네트워크는 UDP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 UDP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">네트워크는 Unix 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">네트워크는 Unix 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">네트워크는 IP 네트워크 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">네트워크는 IP 네트워크 이름이어야합니다. 자세한 내용은 func 다이얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">새 처리기는 h.ServeHTTP를 호출하여 각 요청을 처리하지만 호출이 시간 제한보다 오래 실행되면 처리기는 503 서비스 사용 불가능 오류와 본문에 제공된 메시지로 응답합니다. (msg가 비어 있으면 적절한 기본 메시지가 전송됩니다.) 이러한 시간 초과 후 h가 ResponseWriter에 기록하면 ErrHandlerTimeout이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">새로운 내장 함수는 메모리를 할당합니다. 첫 번째 인수는 값이 아닌 유형이며 반환 된 값은 해당 유형의 새로 할당 된 0 값에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">노드 유형은 * ast.File, * printer.CommentedNode, [] ast.Decl, [] ast.Stmt 또는 ast.Expr, ast.Decl, ast.Spec 또는 ast.Stmt에 지정 호환 가능해야합니다. 노드는 노드를 수정하지 않습니다. 부분 소스 파일을 나타내는 노드 (예 : 노드가 * ast.File 또는 * ast.File을 랩핑하지 않은 * printer.CommentedNode가 아닌 경우)에 대해서는 가져 오기가 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">비 Go 코드는 Go 런타임에 의해 생성 된 스레드에서 신호 마스크를 변경해서는 안됩니다. 비 Go 코드가 자체 스레드를 새로 시작하면 원하는대로 신호 마스크를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">모든 시스템에서 os 패키지에 존재하는 것으로 보장되는 유일한 신호 값은 os.Interrupt (프로세스 중단 보내기) 및 os.Kill (프로세스 강제 종료)입니다. Windows에서는 os.Process.Signal을 사용하여 프로세스에 os.Interrupt를 보내는 것이 구현되지 않습니다. 신호를 보내는 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">RSA를 사용한 암호화 및 서명의 원래 사양은 PKCS # 1이며 기본적으로 &quot;RSA 암호화&quot;및 &quot;RSA 서명&quot;이라는 용어는 PKCS # 1 버전 1.5를 나타냅니다. 그러나이 사양에는 결함이 있으며 새로운 디자인은 가능한 경우 일반적으로 OAEP 및 PSS에 의해 호출되는 버전 2를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">원래 tar 형식은 Unix V7에서 도입되었습니다. 그 이후로 V7 형식을 표준화하거나 확장하여 한계를 극복하려는 여러 경쟁 형식이있었습니다. 가장 일반적인 형식은 각각 고유 한 장점과 제한이있는 USTAR, PAX 및 GNU 형식입니다.</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">os 인터페이스는 모든 운영 체제에서 균일하도록 설계되었습니다. 일반적으로 사용할 수없는 기능은 시스템 별 패키지 syscall에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Log 및 Error의 변형과 같은 다른보고 방법은 여러 고 루틴에서 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">명령의 출력은 하나의 값이거나 두 개의 값이며 두 번째 값은 유형 오류입니다. 해당 두 번째 값이 존재하고 nil이 아닌 것으로 평가되면 실행이 종료되고 Execute 호출자에게 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">패키지는 또한 예제 코드를 실행하고 확인합니다. 예제 함수에는 &quot;출력 :&quot;으로 시작하고 테스트가 실행될 때 함수의 표준 출력과 비교되는 최종 행 주석이 포함될 수 있습니다. (비교는 앞뒤 공백을 무시합니다.) 다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">오류가 발생하지 않으면 패키지가 완료된 것으로 표시되고, 그렇지 않으면 완료되지 않은 패키지입니다. 오류가있을 때 동작을 제어하려면 구성 오류를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">패키지는 때로는 HTTP 처리기와 위 변수를 등록 할 때의 부작용으로 만 가져옵니다. 이 방법으로 사용하려면이 패키지를 프로그램에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">패키지는 * ast.Files 및 해당 파일 세트의 목록과 패키지가 식별 된 패키지 경로로 지정됩니다. 정리 경로는 비어 있거나 점 ( &quot;.&quot;)이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">패키지는 일반적으로 HTTP 핸들러 등록의 부작용으로 만 가져옵니다. 처리 된 경로는 모두 / debug / pprof /로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html에&lt;/a&gt; 설명 된 Elastic Tabstops 알고리즘을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">패키지는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">패키지 golang.org/x/net/ipv4 및 golang.org/x/net/ipv6을 사용하여 oob의 IP 레벨 소켓 옵션을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">패닉 내장 기능은 현재 고 루틴의 정상적인 실행을 중지합니다. 함수 F가 패닉을 호출하면 F의 정상적인 실행이 즉시 중지됩니다. F에 의해 실행이 지연된 함수는 일반적인 방식으로 실행 된 다음 F가 호출자에게 리턴됩니다. 호출자 G에게 F의 호출은 공황에 대한 호출처럼 행동하여 G의 실행을 종료하고 지연된 함수를 실행합니다. 실행중인 고 루틴의 모든 기능이 역순으로 중지 될 때까지 계속됩니다. 이 시점에서 프로그램은 0이 아닌 종료 코드로 종료됩니다. 이 종료 시퀀스를 패닉이라고하며 내장 함수 복구로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">구문 분석 함수는 가장 넓은 유형 (float64, int64 및 uint64)을 반환하지만 size 인수가 더 좁은 폭을 지정하면 결과는 데이터 손실없이 더 좁은 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">파서는 Go 사양에 의해 구문 상 허용되는 것보다 더 큰 언어를 받아들이고, 간결하고 구문 오류가있을 때의 견고성을 향상시킵니다. 예를 들어, 메소드 선언에서 수신자는 일반 매개 변수 목록처럼 취급되므로 스펙이 정확히 하나를 허용하는 여러 항목을 포함 할 수 있습니다. 따라서 AST (ast.FuncDecl.Recv) 필드의 해당 필드는 하나의 항목으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">경로 및 호스트는 CONNECT 요청에 변경되지 않은 상태로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">경로 패키지는 URL의 경로와 같이 슬래시로 구분 된 경로에만 사용해야합니다. 이 패키지는 드라이브 문자 나 백 슬래시가있는 Windows 경로를 처리하지 않습니다. 운영 체제 경로를 조작하려면 경로 / 파일 경로 패키지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">pkg / 디렉토리에는 설치된 패키지 객체가 있습니다. 이동 트리에서와 같이 각 대상 운영 체제 및 아키텍처 쌍에는 고유 한 pkg (pkg / GOOS_GOARCH) 하위 디렉토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">정밀 정밀도는 'e', ​​'E', 'f', 'g', 'G', 'x'및 'X'형식으로 인쇄 된 자릿수 (지수 제외)를 제어합니다. 'e', 'E', 'f', 'x'및 'X'의 경우 소수점 뒤의 자릿수입니다. 'g'및 'G'의 경우 최대 유효 자릿수입니다 (후행 0은 제거됨). 특수 정밀도 -1은 ParseFloat가 f를 정확하게 반환하는 데 필요한 최소 자릿수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">정밀 정밀도는 'e', ​​'E', 'f', 'g', 'G'및 'x'형식으로 인쇄 된 자릿수 (지수 제외)를 제어합니다. 'e', 'E', 'f'및 'x'의 경우 소수점 뒤의 자릿수입니다. 'g'와 'G'는 총 자릿수입니다. 음의 정밀도는 x.Prec () 가수 비트를 사용하여 값 x를 고유하게 식별하는 데 필요한 최소 소수 자릿수를 선택합니다. 'b'및 'p'형식의 경우 prec 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">미리 정의 된 프로파일은 다른 디버그 값에 의미를 할당 할 수 있습니다. 예를 들어, &quot;goroutine&quot;프로필을 인쇄 할 때 debug = 2는 복구되지 않은 패닉으로 인해 Go 프로그램이 죽을 때 사용하는 것과 같은 형식으로 고 루틴 스택을 인쇄하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">인쇄 내장 함수는 인수를 구현 별 방식으로 형식화하고 결과를 표준 오류에 기록합니다. 인쇄는 부트 스트랩 및 디버깅에 유용합니다. 언어를 유지한다고 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">println 내장 함수는 인수를 구현 별 방식으로 형식화하고 결과를 표준 오류에 기록합니다. 인수 사이에 공백이 항상 추가되고 개행이 추가됩니다. Println은 부트 스트랩 및 디버깅에 유용합니다. 언어를 유지한다고 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">제공된 컨텍스트는 0이 아니어야합니다. 연결이 완료되기 전에 컨텍스트가 만료되면 오류가 반환됩니다. 성공적으로 연결되면 컨텍스트 만료는 연결에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">제공된 TxOptions는 선택 사항이며 기본값을 사용해야하는 경우에는 nil 일 수 있습니다. 드라이버가 지원하지 않는 기본 격리 수준이 아닌 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">제공된 본체가 없을 수 있습니다. 본문이 * bytes.Reader, * strings.Reader 또는 * bytes.Buffer 유형 인 경우 Request.ContentLength가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">제공된 코드는 3xx 범위에 있어야하며 일반적으로 StatusMovedPermanently, StatusFound 또는 StatusSeeOther입니다.</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">제공된 컨텍스트는 명령문 실행이 아닌 명령문 준비에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">제공된 컨텍스트는 명령이 자체적으로 완료되기 전에 컨텍스트가 완료되면 os.Process.Kill을 호출하여 프로세스를 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">제공된 컨텍스트는 트랜잭션이 커밋되거나 롤백 될 때까지 사용됩니다. 컨텍스트가 취소되면 SQL 패키지는 트랜잭션을 롤백합니다. BeginTx에 제공된 컨텍스트가 취소되면 Tx.Commit에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">제공된 컨텍스트는 리턴 된 명령문 실행이 아니라 컨텍스트 준비에 사용됩니다. 리턴 된 명령문은 트랜잭션 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">제공된 키는 비교 가능해야하며 컨텍스트를 사용하여 패키지간에 충돌을 피하기 위해 문자열 유형 또는 기타 내장 유형이 아니어야합니다. WithValue 사용자는 자신의 키 유형을 정의해야합니다. 인터페이스 {}에 할당 할 때 할당을 피하기 위해 컨텍스트 키는 종종 구체적인 유형 struct {}를 갖습니다. 또는 내 보낸 컨텍스트 키 변수의 정적 유형은 포인터 또는 인터페이스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">경주 탐지기는 동시 고 루틴이 8192 개를 초과하면 프로그램을 종료하므로 -race 플래그가 설정된 병렬 테스트를 실행할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">rand 매개 변수는 동일한 메시지를 두 번 암호화해도 동일한 암호문이 생성되지 않도록 엔트로피 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">무작위 매개 변수는 동일한 메시지를 두 번 암호화해도 동일한 암호문이 생성되지 않도록 엔트로피 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">nil이 아닌 경우 임의의 매개 변수는 개인 키 조작을 블라인드하고 타이밍 부 채널 공격을 피하기 위해 사용됩니다. 블라인드는이 기능의 내부에 있습니다. 무작위 데이터는 암호화 할 때 사용한 데이터와 일치 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">rawurl은 상대적 (호스트가없는 경로)이거나 절대적 (구성표로 시작) 일 수 있습니다. 스키마없이 호스트 이름과 경로를 구문 분석하는 것은 유효하지 않지만 모호한 구문 분석으로 인해 오류를 리턴하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">연결의 읽기 및 쓰기 절반은 독립적으로 직렬화되므로 인터 로킹이 필요하지 않습니다. 그러나 각 절반에 동시에 액세스 할 수 있으므로 conn 구현은 동시 읽기 또는 동시 쓰기로부터 보호해야합니다.</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">실제 내장 함수는 복소수 c의 실수 부분을 반환합니다. 리턴 값은 c의 유형에 해당하는 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">인식되는 요일 형식은 &quot;월&quot;및 &quot;월요일&quot;입니다. 인식되는 월 형식은 &quot;Jan&quot;및 &quot;January&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">내장 기능 복구 기능을 통해 프로그램은 당황한 고 루틴의 동작을 관리 할 수 ​​있습니다. 지연된 함수 내에서 복구하기 위해 호출을 실행하면 (이에 의해 호출 된 함수는 아님) 정상 실행을 복원하여 패닉 시퀀스를 중지하고 패닉 호출에 전달 된 오류 값을 검색합니다. 지연된 함수 외부에서 recover를 호출하면 패닉 시퀀스가 ​​중지되지 않습니다. 이 경우 또는 goroutine이 당황하지 않거나 패닉에 제공된 인수가 nil 인 경우 recover는 nil을 리턴합니다. 따라서 recover의 리턴 값은 고 루틴이 당황하는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">이 패키지가 제공하는 정규 표현식 구현은 입력 크기에 따라 선형으로 실행됩니다. (이는 정규 표현식의 대부분의 오픈 소스 구현에서 보장되지 않는 특성입니다.)이 특성에 대한 자세한 정보는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">regionType은 지역을 분류하는 데 사용되므로 소수의 고유 지역 유형 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">Perl 플래그로 구문 분석 할 때이 패키지가 이해하는 정규식 구문은 다음과 같습니다. 구문 분석에 대체 플래그를 전달하여 구문의 일부를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">나머지 패턴은 uintptr에서 Pointer 로의 유효한 변환 만 열거합니다.</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">나머지 신호는 비동기 신호입니다. 그것들은 프로그램 오류에 의해 트리거되지 않지만 대신 커널이나 다른 프로그램에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">유형의 표현은 아래에 설명되어 있습니다. 엔코더와 디코더 사이의 주어진 연결에서 유형이 정의되면 부호있는 정수 유형 ID가 지정됩니다. Encoder.Encode (v)가 호출되면 v 유형과 모든 요소에 지정된 ID가 있는지 확인한 다음 typeid가 인코딩 된 유형의 유형 id 인 쌍 (typeid, encrypted-v)을 보냅니다. v와 encoding-v는 값 v의 gob 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">요청 본문이 0이 아닌 경우 기본 전송에서 오류가 발생하더라도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">다음과 같이 GODEBUG 환경 변수 (패키지 런타임 참조)의 netdns 값을 go 또는 cgo로 설정하여 해결 프로그램 결정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">이 패키지 주석의 나머지 부분은 처음 읽을 때 건너 뛸 수 있습니다. 이스케이프 컨텍스트 및 오류 메시지를 이해하는 데 필요한 세부 사항이 포함되어 있습니다. 대부분의 사용자는 이러한 세부 사항을 이해할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 작업이 단조로운 시계를 사용하는 방법에 대한 정확한 세부 정보를 제공하지만이 패키지를 사용하기 위해 해당 세부 정보를 이해하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">스캔 결과는 이러한 토큰 중 하나이거나 유니 코드 문자입니다.</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">벤치 마크 실행 결과.</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">리턴 된 * Float f는 nil이고 z의 값은 유효하지만 오류가보고되면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">반환 된 Cmd의 Args 필드는 명령 이름과 arg 요소로 구성되므로 arg는 명령 이름 자체를 포함하지 않아야합니다. 예를 들어 Command ( &quot;echo&quot;, &quot;hello&quot;)입니다. Args [0]은 항상 해결 된 Path가 아닌 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">반환 된 DB는 여러 고 루틴이 동시에 사용할 수 있으며 자체 유휴 연결 풀을 유지 관리합니다. 따라서 Open 함수는 한 번만 호출해야합니다. DB를 닫을 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">반환 된 DB는 여러 고 루틴이 동시에 사용할 수 있으며 자체 유휴 연결 풀을 유지 관리합니다. 따라서 OpenDB 함수는 한 번만 호출해야합니다. DB를 닫을 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">반환 된 RawConn은 Control 호출 만 지원합니다. 읽기 및 쓰기는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">반환 된 응답에는 최소한 StatusCode, 헤더, 본문 및 선택적으로 예고편이 채워집니다. 앞으로 더 많은 필드가 채워질 수 있으므로 호출자는 테스트에서 결과를 깊게 같지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">돌려 주어진 문맥은 항상 비논리입니다. 기본적으로 배경 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">반환 된 종료 기능은 작업의 종료를 표시하는 데 사용됩니다. 추적 도구는 작업 작성과 종료 기능이 호출 될 때까지의 시간으로 작업 대기 시간을 측정하고 작업 유형별 대기 시간 분포를 제공합니다. 종료 기능이 여러 번 호출되면 대기 시간 측정에 첫 번째 호출 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">명령이 실행되고 stdin, stdout 및 stderr를 복사하는 데 문제가없고 종료 상태가 0 인 경우 리턴되는 오류는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">리턴 된 목록은 연관된 인터페이스를 식별하지 않습니다. 자세한 내용은 Interfaces and Interface.Addrs를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">반환 된 메모리 할당 자 통계는 ReadMemStats를 호출 할 때 최신 상태입니다. 이것은 가장 최근에 완료된 가비지 콜렉션주기의 스냅 샷 인 힙 프로파일과 대조됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">반환 된 os.File의 파일 디스크립터가 연결의 파일 디스크립터와 다릅니다. 이 복제본을 사용하여 원본의 속성을 변경하려고하면 원하는 효과가 있거나 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">리턴 된 경로는 루트 &quot;/&quot;인 경우에만 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">리턴 된 경로는 루트 디렉토리 (예 : Unix의 &quot;/&quot;또는 Windows의 경우 C : \)를 나타내는 경우에만 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">리턴 된 프로파일은 최대 두 개의 가비지 콜렉션주기 이전 일 수 있습니다. 이는 프로파일이 할당쪽으로 기울어지지 않도록하기위한 것입니다. 할당은 실시간으로 발생하지만 가비지 수집기가 스위핑을 수행 할 때까지 해제가 지연되기 때문에 프로필은 가비지 수집기에 의해 해제 될 수있는 할당 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">반환 된 슬라이스는 DER 인코딩의 인증서입니다.</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">반환 된 슬라이스는 DER 인코딩의 인증서 요청입니다.</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">리턴 된 명령문은 트랜잭션 내에서 작동하며 트랜잭션이 커미트되거나 롤백되면 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">리턴 된 명령문은 트랜잭션 내에서 작동하며 트랜잭션이 커미트되거나 롤백 될 때 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">반환 된 문자열은 디버깅을위한 것입니다. 안정적인 직렬화 표현을 위해서는 명시 적 형식 문자열과 함께 t.MarshalText, t.MarshalBinary 또는 t.Format을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">제목에서 단어 경계에 사용하는 규칙은 유니 코드 문장 부호를 올바르게 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">동일한 컨텍스트가 다른 고 루틴에서 실행되는 함수에 전달 될 수 있습니다. 문맥은 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">두 번째 인수 인 quote는 구문 분석되는 리터럴의 유형을 지정하므로 이스케이프 된 인용 문자가 허용됩니다. 작은 따옴표로 설정하면 \ '시퀀스를 허용하고 이스케이프 처리되지 않은'을 허용하지 않습니다. 큰 따옴표로 설정하면 \ &quot;를 허용하고 이스케이프되지 않은&quot;을 허용하지 않습니다. 0으로 설정하면 이스케이프를 허용하지 않으며 두 인용 부호가 모두 이스케이프되지 않은 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">이 패키지에서 사용하는 보안 모델은 템플릿 작성자가 신뢰할 수 있다고 가정하지만 Execute의 data 매개 변수는 그렇지 않습니다. 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">서버는 (HTTP 서비스를 위해) 호출합니다 :</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">서버는 ServeConn을 호출하여 단일 연결에서 요청을 처리 할 수 ​​있습니다. 보다 일반적으로 네트워크 리스너를 작성하고 Accept 또는 HTTP 리스너의 경우 HandleHTTP 및 http.Serve를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">사용 가능한 CPU 세트는 프로세스 시작시 운영 체제를 조회하여 확인합니다. 프로세스 시작 후 운영 체제 CPU 할당에 대한 변경 사항은 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">SIGKILL 및 SIGSTOP 신호는 프로그램에 의해 포착되지 않을 수 있으므로이 패키지의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">표준 입력을 라인 세트로 읽는 스캐너의 가장 간단한 사용.</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">바이트 단위의 CRC-32 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">바이트 단위의 CRC-64 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA-1 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA224 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">바이트 단위의 SHA256 체크섬 크기입니다.</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">Adler-32 체크섬의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">MD5 체크섬의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">skip 매개 변수는 런타임과 동일한 의미를 갖습니다. 건너 뛰기 및 스택 추적 시작 위치를 제어합니다. skip = 0을 전달하면 Add를 호출하는 함수에서 추적이 시작됩니다. 예를 들어,이 실행 스택이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">이 메소드에 의해 리턴 된 슬라이스는 FindAllString에 의해 리턴 된 슬라이스에 포함되지 않은의 모든 서브 스트링으로 구성됩니다. 메타 문자가없는 표현식에서 호출되면 strings.SplitN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">smtp 패키지가 정지되었으며 새로운 기능을 허용하지 않습니다. 일부 외부 패키지는 더 많은 기능을 제공합니다. 보다:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">정렬이 안정적으로 보장되지는 않습니다. 안정적인 정렬을 위해서는 SliceStable을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">소스 및 대상 값 / 유형이 정확히 일치 할 필요는 없습니다. 구조체의 경우 소스에 있지만 수신 변수가없는 필드 (이름으로 식별)는 무시됩니다. 수신 변수에 있지만 전송 된 유형 또는 값에서 누락 된 필드는 대상에서 무시됩니다. 동일한 이름을 가진 필드가 둘 다 존재하는 경우 해당 유형이 호환 가능해야합니다. 수신기와 송신기 모두 gobs와 실제 Go 값 사이를 변환하기 위해 필요한 모든 간접 및 역 참조를 수행합니다. 예를 들어, 개략적 인 gob 유형은</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">소스 코드에는 추가 Go 코드가 포함될 수 있습니다. 이 코드는 컴파일되지 않았지만 godoc과 같은 도구로 처리되며 최종 사용자 문서로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">출처 :</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">SQL 패키지는 Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter와 같이 첫 번째 발견 된 일치 항목에서 중지하여 값 검사기를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">sql 패키지는 자동으로 연결을 작성하고 해제합니다. 또한 유휴 연결의 사용 가능한 풀을 유지 관리합니다. 데이터베이스에 연결 별 상태 개념이있는 경우 트랜잭션 (Tx) 또는 연결 (Conn) 내에서 이러한 상태를 안정적으로 관찰 할 수 있습니다. DB.Begin이 호출되면 반환 된 Tx는 단일 연결에 바인딩됩니다. 트랜잭션에서 커밋 또는 롤백이 호출되면 해당 트랜잭션의 연결이 DB의 유휴 연결 풀로 반환됩니다. 풀 크기는 SetMaxIdleConns로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">SQL 패키지는 데이터베이스 드라이버와 함께 사용해야합니다. 드라이버 목록은 &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">src / 디렉토리에는 소스 코드가 있습니다. 'src'아래의 경로는 가져 오기 경로 또는 실행 파일 이름을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">트랜잭션의 Prepare 또는 Stmt 메소드를 호출하여 트랜잭션을 위해 준비된 명령문은 확약 또는 롤백 호출로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">SwapT 함수로 구현 된 스왑 작업은 다음과 같은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">심볼 라이저 기능은 nil 일 수 있으며,이 경우 트레이스 백 기능의 결과가 숫자로 표시됩니다. 역 추적 기능이 nil이면 심볼 라이저 기능이 호출되지 않습니다. 컨텍스트 함수는 nil 일 수 있으며,이 경우 컨텍스트 필드가 0으로 설정된 경우에만 역 추적 함수가 호출됩니다. 컨텍스트 함수가 nil 인 경우 Go to C에서 Go 로의 호출은 호출 스택의 C 부분에 대한 역 추적을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">심볼 라이저 함수는 구조체에 대한 포인터 인 단일 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">이러한 정의의 구문은 각 템플리트 선언을 &quot;정의&quot;및 &quot;종료&quot;조치로 둘러싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">허용되는 정규 표현식의 구문은 Perl, Python 및 기타 언어에서 사용되는 것과 동일한 일반 구문입니다. 더 정확하게 말하면, 이것은 RE2에 의해 허용되고 \ C를 제외하고 &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax에&lt;/a&gt; 설명 된 구문 입니다. 구문에 대한 개요를 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">syslog 패키지가 정지되었으며 새 기능을 허용하지 않습니다. 일부 외부 패키지는 더 많은 기능을 제공합니다. 보다:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">표 하단에는 지원되는 문자열 인코딩, 1 초 미만의 타임 스탬프 지원 또는 스파 스 파일 지원과 같은 각 형식의 특수 기능이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">표 상단에는 헤더 필드가 표시되며, 각 형식은 각 문자열 필드에 허용되는 최대 바이트 수와 각 숫자 필드를 저장하는 데 사용되는 정수 유형 (타임 스탬프가 유닉스 시대 이후의 초 수로 저장 됨)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">태그는 문자열 값인 DT_NEEDED, DT_SONAME, DT_RPATH 또는 DT_RUNPATH를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">대상은 RFC 7230 &quot;요청 대상&quot;입니다. 경로이거나 절대 URL 일 수 있습니다. 대상이 절대 URL 인 경우 URL의 호스트 이름이 사용됩니다. 그렇지 않으면 &quot;example.com&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">taskType은 작업 인스턴스를 분류하는 데 사용됩니다. Go 실행 추적 프로그램과 같은 분석 도구는 시스템에 제한된 수의 고유 한 작업 유형 만 있다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">테스트 / 빠른 패키지가 정지되었으며 새 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">ReadLine에서 반환 된 텍스트는 줄 끝 ( &quot;\ r \ n&quot;또는 &quot;\ n&quot;)을 포함하지 않습니다. 입력이 최종 라인 끝없이 종료되면 표시 또는 오류가 발생하지 않습니다. ReadLine 이후에 UnreadByte를 호출하면 해당 바이트가 ReadLine에 의해 리턴 된 행의 일부가 아니더라도 항상 마지막 바이트 읽기 (행 끝에 속하는 문자)를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">텍스트 / 탭 라이터 패키지가 정지되었으며 새 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">LoadLocation에 필요한 시간대 데이터베이스가 일부 시스템, 특히 비 유닉스 시스템에 존재하지 않을 수 있습니다. LoadLocation은 ZONEINFO 환경 변수로 이름이 지정된 디렉토리 또는 압축되지 않은 zip 파일을 찾은 다음 Unix 시스템의 알려진 설치 위치를 찾은 다음 $ GOROOT / lib / time / zoneinfo.zip을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">필요한 경우 시간 초과에 이름 확인이 포함됩니다. TCP를 사용할 때 address 매개 변수의 호스트가 여러 IP 주소로 확인되면 각 연속 다이얼에 시간 초과가 분산되어 각 연결 시간에 적절한 비율이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">메모리 프로파일을 처리하는 도구는 프로파일 수명이 프로그램 수명 동안 일정하고 현재 값과 같다고 가정합니다. 메모리 프로파일 링 속도를 변경하는 프로그램은 프로그램 실행시 가능한 한 빨리 (예 : 메인 시작시) 한 번만 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">추적 도구는 작업 작성과 작업 종료 사이의 시간을 측정하여 작업의 대기 시간을 계산하고 추적에서 찾은 각 작업 유형에 대한 대기 시간 분포를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">역 추적 및 컨텍스트 함수는 신호 핸들러에서 호출 될 수 있으므로 비동기 신호 안전 함수 만 사용해야합니다. 프로그램이 충돌하는 동안 심볼 라이저 함수가 호출 될 수 있으므로 메모리 사용에주의해야합니다. 어떤 함수도 Go를 다시 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">역 추적 함수는 단일 인수, 구조체에 대한 포인터와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Network와 String의 두 가지 방법은 일반적으로 Dial에 인수로 전달할 수있는 문자열을 반환하지만 문자열의 정확한 형식과 의미는 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">typ 인수는 정의 된 (명명 된) 유형 또는 별명 유형일 수 있습니다. 반환 된 TypeName을 NewNamed에 대한 인수로 사용할 수 있도록 nil 일 수도 있습니다. 이렇게하면 TypeName의 유형이 부작용으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">NewFileTransport의 일반적인 사용 사례는 다음과 같이 &quot;파일&quot;프로토콜을 Transport에 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">기본 파일 시스템은 값을 덜 정확한 시간 단위로 자르거나 반올림 할 수 있습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">사용법 메시지는 1 바이트 이름을 가진 부울 플래그 외에는 별도의 행에 나타납니다. bool 플래그의 경우 유형이 생략되고 플래그 이름이 1 바이트 인 경우 사용법 메시지가 동일한 행에 나타납니다. 기본값이 유형의 0 값인 경우 괄호 기본값은 생략됩니다. 열거 된 유형 (여기서 int)은 플래그의 사용 문자열에 백 따옴표로 묶은 이름을 넣어서 변경할 수 있습니다. 메시지의 첫 번째 항목은 메시지에 표시 할 매개 변수 이름으로 사용되며 표시 될 때 메시지에서 백 따옴표가 제거됩니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">0xff 값은 유효한 UTF-8 순서로 표시 될 수 없으므로 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">variadic 인수는 함수가 variadic인지 여부를 제어합니다. in [len (in) -1]이 슬라이스를 나타내지 않고 가변성 인 경우 FuncOf 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">varint 함수는 가변 길이 인코딩을 사용하여 단일 정수 값을 인코딩 및 디코딩합니다. 값이 작을수록 더 적은 바이트가 필요합니다. 사양은 &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">동사는 Printf의 동사와 유사하게 동작합니다. 예를 들어, % x는 정수를 16 진수로 스캔하고 % v는 기본 표현 형식을 스캔합니다. Printf 동사 % p 및 % T와 플래그 # 및 +는 구현되지 않습니다. 부동 소수점 및 복소수 값의 경우 모든 유효한 형식 동사 (% b % e % E % f % F % g % G % x % X 및 % v)는 동일하며 10 진수 및 16 진수 표기법을 모두 사용할 수 있습니다 (예 : &quot;2.3 e + 7 &quot;,&quot;0x4.5p-8 &quot;) 및 숫자 분리 밑줄 (예 :&quot;3.14159_26535_89793 &quot;).</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">동사 :</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">개별 레코드의 쓰기가 버퍼링됩니다. 모든 데이터가 작성된 후 클라이언트는 Flush 메소드를 호출하여 모든 데이터가 기본 io.Writer로 전달되도록해야합니다. 발생한 모든 오류는 Error 메서드를 호출하여 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Float의 0 (초기화되지 않은) 값은 사용할 준비가되었으며 정밀도 0 및 반올림 모드 ToNearestEven과 함께 +0.0을 정확하게 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">제로 맵이 비어 있고 사용할 준비가되었습니다. 처음 사용한 후 맵을 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">0 값은 값이 없음을 나타냅니다. IsValid 메서드는 false를 반환하고 Kind 메서드는 Invalid를 반환하고 String 메서드는 &quot;&amp;lt;invalid Value&amp;gt;&quot;를 반환하며 다른 모든 메서드는 패닉 상태입니다. 대부분의 함수와 메소드는 유효하지 않은 값을 반환하지 않습니다. 그럴 경우 문서에 조건이 명시 적으로 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos의 0 값은 NoPos입니다. 연관된 파일 및 행 정보가 없으며 NoPos.IsValid ()가 false입니다. NoPos는 항상 다른 Pos 값보다 작습니다. NoPos의 해당 위치 값은 위치의 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int, Rat 또는 Float의 0 값은 0에 해당합니다. 따라서 새로운 값은 일반적인 방법으로 선언 할 수 있으며 추가 초기화없이 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">각 필드의 0 값은 해당 옵션이없는 다이얼링과 같습니다. 따라서 다이얼러의 0 값을 사용한 다이얼링은 다이얼 기능을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time 유형의 0 값은 1 년 1 월 1 일 00 : 00 : 00.000000000 UTC입니다. 이 시간이 실제로 시작되지는 않기 때문에 IsZero 방법은 명시 적으로 초기화되지 않은 시간을 간단하게 감지 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">그런 다음 원격 전화를 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">그런 다음 pprof 도구를 사용하여 힙 프로파일을보십시오.</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">정규식과 일치하고 일치하는 텍스트를 식별하는 16 가지 정규식 방법이 있습니다. 그들의 이름은이 정규식과 일치합니다 :</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">pprof 명령 행에서 사용 가능한 많은 명령이 있습니다. 일반적으로 사용되는 명령에는 최상위 프로그램 핫스팟 요약을 인쇄하는 &quot;top&quot;과 핫스팟의 대화식 그래프 및 해당 호출 그래프를 여는 &quot;web&quot;이 포함됩니다. 모든 pprof 명령에 대한 정보는 &quot;help&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">베타 또는 부 릴리스에 대한 빌드 태그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">사용자 주석에는 세 가지 유형 인 로그 메시지, 리전 및 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">함수로 정의 된 이진 비교 연산자 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">데이터 프로파일 링을위한 표준 HTTP 인터페이스도 있습니다. 다음 줄을 추가하면 / debug / pprof / URL 아래에 처리기가 설치되어 라이브 프로필을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">데이터를 추적하기위한 표준 HTTP 인터페이스도 있습니다. 다음 행을 추가하면 라이브 추적을 다운로드하기 위해 / debug / pprof / trace URL 아래에 핸들러가 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">RuneReader에서 읽은 텍스트에 적용 할 수있는 메소드의 서브 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">대소 문자 접힘, 즉 입력 또는 출력에 여러 룬이 포함 된 문자에 대한 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">이들은 Time.Format 및 time.Parse에서 사용하기 위해 미리 정의 된 레이아웃입니다. 레이아웃에 사용 된 참조 시간은 특정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">ParseError.Err에 반환 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">이들은 10 진수 및 Go int 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이러한 상수는 flate 패키지에서 복사되므로 &quot;compress / gzip&quot;을 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">이러한 상수는 flate 패키지에서 복사되므로 &quot;compress / zlib&quot;를 가져 오는 코드도 &quot;compress / flate&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">이러한 상수로 인해 구문 분석에 실패한 경우 FlagSet.Parse가 설명 된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">이 상수는 지원되는 반올림 모드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">이 예는 형식 문자열을 사용한 인쇄 기본 사항을 보여줍니다. Printf, Sprintf 및 Fprintf는 모두 후속 인수의 형식을 지정하는 방법을 지정하는 형식 문자열을 사용합니다. 예를 들어, % d ( '동사'라고 함)는 해당 인수를 인쇄하도록 지시합니다.이 인수는 정수 (또는 정수 슬라이스와 같은 정수를 포함하는 것) 여야합니다. 동사 % v ( 'value'의 경우 'v')는 항상 Print 또는 Println이 표시하는 방식과 같이 기본 형식으로 인수의 형식을 지정합니다. 특수 동사 % T ( 'Type'의 경우 'T')는 값이 아닌 인수의 유형을 인쇄합니다. 예제는 완전하지 않습니다. 자세한 내용은 패키지 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">이 플래그는 로거에 의해 생성 된 각 로그 항목 앞에 붙일 텍스트를 정의합니다. 인쇄되는 것을 제어하기 위해 비트들이 함께 또는 결합되어있다. 표시되는 순서 (여기에 나열된 순서) 또는 표시되는 형식 (주석에 설명 된대로)은 제어 할 수 없습니다. 접 두부 뒤에는 Llongfile 또는 Lshortfile이 지정된 경우에만 콜론이옵니다. 예를 들어, 플래그 Ldate | Ltime (또는 LstdFlags)은</target>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">이러한 기능은 RFC 8032에 정의 된 &quot;Ed25519&quot;기능과도 호환됩니다. 그러나 RFC 8032의 공식과 달리이 패키지의 개인 키 표현에는 공개 키 접미사가 포함되어 동일한 키로 여러 서명 작업을보다 효율적으로 수행 할 수 있습니다. 이 패키지는 RFC 8032 개인 키를 &quot;시드&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">이러한 기능을 올바르게 사용하려면 세심한주의가 필요합니다. 특수한 저수준 응용 프로그램을 제외하고 동기화 패키지의 채널 또는 기능을 사용하여 동기화하는 것이 좋습니다. 통신하여 메모리를 공유하십시오. 메모리를 공유하여 통신하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">이 패키지는 Go 프로젝트의 일부이지만 기본 Go 트리 외부에 있습니다. Go 코어 보다 &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;호환성 요구 사항&lt;/a&gt; 이 더 낮은 환경에서 개발되었습니다 . &quot; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &quot;으로 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">이러한 사전 정의 된 프로파일은 명시적인 Add 또는 Remove 메소드 호출에서 자체적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">이러한 서비스를 통해 커뮤니티에서 제공하는 오픈 소스 패키지를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">이 세 가지 형식 지정 루틴은 각 패키지 수준 개체 O에 대해 한정자를 호출하고 한정자가 비어 있지 않은 문자열 p를 반환하면 개체는 pO 형식으로 인쇄됩니다. 빈 문자열을 반환하면 개체 이름 O 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">이 변수에는 * RangeTable 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머 채널에서 다른 수신과 동시에 수행 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">이것은 * int 유형으로 포인터 ip에 저장된 정수 플래그 -flagname을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">이것은 T1과 T2의 두 템플릿과 다른 두 템플릿이 실행될 때 호출하는 세 번째 T3을 정의합니다. 마지막으로 T3을 호출합니다. 이 템플릿을 실행하면 텍스트가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">이 예에서는 일부 항목으로 PriorityQueue를 작성하고 항목을 추가 및 조작 한 다음 우선 순위에 따라 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">이 예제는 템플릿 텍스트를 처리하는 사용자 정의 함수를 보여줍니다. 제목 기능을 설치하고 템플릿의 출력에서 ​​제목 텍스트를보기 좋게 만드는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">이 예제는 값을 컨텍스트에 전달하는 방법과 값이있는 경우이를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">이 예는 Go 프로그램의 AST를 검사하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">이 예는 big.Int를 사용하여 10 진수 100으로 가장 작은 피보나치 수를 계산하고 소수인지 테스트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">이 예는 big.Rat을 사용하여 상수 e (자연 로그의 밑수)에 대한 합리적인 수렴 시퀀스에서 처음 15 개의 항을 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">이 예는 고유 한 도우미 템플릿 집합과 함께 하나의 드라이버 템플릿 그룹을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">이 예제는 일부 템플릿을 공유하고 다른 컨텍스트에서 사용하는 한 가지 방법을 보여줍니다. 이 변형에서는 기존 템플릿 번들에 여러 드라이버 템플릿을 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">이 예는 오름차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">이 예는 내림차순으로 정렬 된 목록을 검색하는 방법을 보여줍니다. 이 방법은 목록을 오름차순으로 검색하는 것과 동일하지만 조건이 반전 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">이 예는 고 루틴 누출을 방지하기 위해 취소 가능한 컨텍스트를 사용하는 방법을 보여줍니다. 예제 함수의 끝에서 gen에 의해 시작된 goroutine은 누출없이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">이 예제는 미리 설정된 일부 필드를 사용하여 XML 발췌를 마샬링 해제하는 방법을 보여줍니다. 전화 필드는 수정되지 않으며 XML &amp;lt;Company&amp;gt; 요소는 무시됩니다. 또한 그룹 필드는 태그에 제공된 요소 경로를 고려하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">이 예에서는 모든 가져 오기가 완료 될 때까지 WaitGroup을 사용하여 여러 URL을 동시에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">이 예제는 ast.CommentMap을 사용하여 올바른 주석 연관을 유지하면서 Go 프로그램에서 변수 선언을 제거하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">이 예제는 IntHeap에 여러 개의 int를 삽입하고 최소값을 확인한 후 우선 순위에 따라 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">이 예는 시간 초과가 발생한 후 작업을 포기해야한다는 차단 기능을 알리기 위해 시간 초과가있는 컨텍스트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">이 예제는 임의의 최종 기한이있는 컨텍스트를 전달하여 차단 기능에 도달하자마자 작업을 포기해야한다는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">이 예제는 rand.Reader에서 암호로 안전한 10 개의 의사 난수를 읽고 바이트 슬라이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">이 예는 다른 유형의 CSV 파일을 처리하도록 csv.Reader를 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">이 예제는 인터페이스 값을 인코딩하는 방법을 보여줍니다. 일반 유형과의 주요 차이점은 인터페이스를 구현하는 구체적 유형을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">이 예는 big.Float를 사용하여 정밀도 200 비트로 2의 제곱근을 계산하는 방법과 결과를 10 진수로 인쇄하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">이 예제는 패키지의 기본 사용법을 보여줍니다. 인코더를 생성하고, 일부 값을 전송하고, 디코더로이를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">이 예는 * Rand에서 각 메소드의 사용을 보여줍니다. 전역 기능의 사용은 수신자없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">이 예는 디버깅을 위해 인쇄 할 때 AST의 모습을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">이 예제는 사용자 정의 인코딩 및 디코딩 방법을 구현하는 값을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 JSON 메시지의 구문 분석 부분을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">이 예제는 RawMessage를 사용하여 마샬링 중에 사전 계산 된 JSON을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">이 예제는 디코더를 사용하여 고유 한 JSON 값의 스트림을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">이 예제는 디코더를 사용하여 JSON 객체의 스트리밍 배열을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">이 기능은 결정적입니다. 따라서 가능한 메시지 집합이 작 으면 공격자가 메시지에서 서명으로 맵을 작성하고 서명 된 메시지를 식별 할 수 있습니다. 그 어느 때보 다 서명은 기밀이 아닌 진정성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">이 기능의 실행 시간은 입력에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">이 기능은 레거시 웹 사이트에서만 사용해야합니다. RFC 2396은 Userinfo를 이런 방식으로 해석하는 것은 &quot;권장되지 않음&quot;이라고 경고합니다. URI와 같은 일반 텍스트로 인증 정보를 전달하는 것은 거의 모든 경우에 보안 위험으로 판명 되었기 때문입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">이 구현은 ChopMD (256, SHA2-512 (priv.D || entropy || hash))가 입력 한 AES-CTR CSPRNG에서 nonce를 파생합니다. CSPRNG 키는 Coron의 결과로 IRO입니다. AES-CTR 스트림은 표준 가정 하에서 IRO입니다.</target>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">비표준 위치에 핸들러를 설치하는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">WriteHeader 또는 Close에 대한 다음 호출이 내재적으로 파일의 패딩을 플러시하므로 이는 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. EC 고유가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;EC PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PRIVATE KEY&quot;유형의 PEM 블록으로 인코딩됩니다. RSA가 아닌보다 유연한 키 형식을 사용하려면 MarshalPKCS8PrivateKey를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">이러한 종류의 키는 일반적으로 &quot;RSA PUBLIC KEY&quot;유형의 PEM 블록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">즉, 기본적으로 명령 줄 프로그램은 일반적인 Unix 명령 줄 프로그램처럼 작동하지만 다른 프로그램은 닫힌 네트워크 연결에 쓸 때 SIGPIPE와 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">응답이 준비되기 전에 클라이언트 연결이 끊어진 경우이 메커니즘을 사용하여 서버에서 긴 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">이 메커니즘은 헤더를 작성하기 전에 알려지지 않은 예고편에만 적용됩니다. 헤더가 작성되기 전에 트레일러 세트가 고정되거나 알려진 경우 일반적인 Go 트레일러 메커니즘이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">이 방법은 응답 r의 다음 필드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">이 방법은 crypto.Signer를 구현하는데, 이는 개인 부품이 보관되는 키 (예 : 하드웨어 모듈)를 지원하는 인터페이스입니다. 일반적인 용도는이 패키지의 Sign * 기능을 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">이 패키지는 템플릿 작성자가 신뢰할 수 있고 Execute의 data 매개 변수가 신뢰할 수 없다고 가정하고 신뢰할 수없는 데이터에 직면하여 아래 속성을 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">이 패키지는 여러 아키텍처에서 비트와 동일한 결과를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">이 패키지는 디스크 스패닝을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">이 패키지는 효율성보다 단순성을 선호합니다. 특히 대규모 데이터 구조의 경우 고성능 직렬화가 필요한 클라이언트는 인코딩 / gob 패키지 또는 프로토콜 버퍼와 같은 고급 솔루션을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">이 패키지는 실험적입니다. 현재 범위는 테스트 실행만을 허용하지만 아직 사용자에게 포괄적 인 API를 제공하지는 않습니다. Go 호환성 약속에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">이 패키지는 NaCl (Native Client)에서 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">이 패키지는 플랜 9에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 Windows에서 구현되지 않습니다. syslog 패키지가 고정되면 Windows 사용자는 표준 라이브러리 외부에서 패키지를 사용하는 것이 좋습니다. 배경은 &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">이 패키지는 HTML, CSS, JavaScript 및 URI를 이해합니다. 각 간단한 행동 파이프 라인에 살균 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">이 패키지는 패키지 텍스트 / 템플릿을 래핑하여 템플릿 API를 공유하여 HTML 템플릿을 안전하게 구문 분석하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">이 팔레트는 &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color에&lt;/a&gt; 설명 된 Plan 9 운영 체제에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">파일 내용을 써야 할 라이터를 돌려줍니다. 다음에 Create, CreateHeader 또는 Close를 호출하기 전에 파일 내용을 io.Writer에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">이 런타임 / 추적 패키지는 독립형 프로그램에 동등한 추적 지원을 추가하기위한 API를 제공합니다. 이 API를 사용하여 추적을 사용하는 방법을 보여주는 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">이 섹션에서는 인코딩, 대부분의 사용자에게 중요하지 않은 세부 사항에 대해 설명합니다. 세부 사항은 상향식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">이 세트는 커질 수 있습니다. 정규식 일치는 일치에서 반환 된 텍스트 이외의 텍스트를 검사해야 할 수 있으므로 RuneReader의 텍스트와 일치하는 메서드는 반환하기 전에 입력에서 임의로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">이것은 타이머의 채널로부터 다른 수신과 동시에 수행되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">이 유형은 sql.IsolationLevel과 정의 된 값과 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">이 유형은 sql.TxOptions와 동일한 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile은 스레드 작성 프로파일의 레코드 수인 n을 리턴합니다. len (p)&amp;gt; = n 인 경우 ThreadCreateProfile은 프로파일을 p에 복사하고 n을 true로 리턴합니다. len (p) &amp;lt;n이면 ThreadCreateProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick은 NewTicker의 편의 래퍼로서 티킹 채널에만 액세스 할 수 있습니다. Tick은 Ticker를 종료 할 필요가없는 클라이언트에 유용하지만,이를 종료 할 수있는 방법이 없으면 기본 Ticker를 가비지 수집기에서 복구 할 수 없습니다. &quot;누설&quot;. NewTicker와 달리 Tick은 d &amp;lt;= 0이면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">Before, After 및 Equal 메서드를 사용하여 시간 인스턴트를 비교할 수 있습니다. Sub 메소드는 두 개의 순간을 빼서 Duration을 생성합니다. Add 메서드는 시간과 지속 시간을 추가하여 시간을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat은 HTTP 헤더에서 시간을 생성 할 때 사용하는 시간 형식입니다. RFC1123과 같지만 GMT를 표준 시간대로 하드 코딩합니다. 형식이 올바른 형식을 생성하려면 형식 시간이 UTC 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">시간 초과는 DNS 조회가 시간 초과 된 것으로 알려 진지 여부를보고합니다. 이것이 항상 알려진 것은 아닙니다. 시간 초과로 인해 DNS 조회가 실패하고 시간 초과가 false를 반환하는 DNSError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">시간 초과는이 오류가 시간 초과를 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler는 주어진 시간 제한으로 h를 실행하는 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler는 Flusher 및 Pusher 인터페이스를 지원하지만 Hijacker 인터페이스는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader는 두 번째 읽기에서 데이터없이 ErrTimeout을 반환합니다. 후속 호출은 성공합니다.</target>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec는 Timespec 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec은 Timeval 값을 Unix 시대 이후 수 나노초로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title은 유니 코드 제목 대 / 소문자로 매핑 된 단어를 시작하는 모든 유니 코드 문자가 포함 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 단어를 매핑하는 모든 유니 코드 문자가 포함 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">독립형 프로그램에 동등한 프로파일 링 지원을 추가하려면 다음과 같은 코드를 기본 기능에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">서비스 거부 공격을 피하려면 제공된 bufio.Reader가 io.LimitReader 또는 이와 유사한 Reader에서 읽고 응답 크기를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">다음과 같은 경우 재귀를 피하기 위해</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">하위 호환성을 위해 FileHeader에는 32 및 64 비트 크기 필드가 있습니다. 64 비트 필드는 항상 올바른 값을 포함하며 일반 아카이브의 경우 두 필드가 동일합니다. ZIP64 형식이 필요한 파일의 경우 32 비트 필드는 0xffffffff이며 64 비트 필드를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">cgo를 사용할 때만 Linux 및 OS X에서만 파일을 빌드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">보다 효율적으로 문자열을 작성하려면 strings.Builder 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">플래그 메시지의 대상을 변경하려면 CommandLine.SetOutput을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">두 값을 비교하려면 인터페이스 방법의 결과를 비교하십시오. 두 개의 값에 ==를 사용하면 해당 값이 나타내는 기본 값이 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">위의 예제를 완료하기 위해 다음 코드는 오름차순으로 정렬 된 정수 슬라이스 데이터에서 x 값을 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">할당 수를 계산하기 위해이 기능은 먼저 예열로 한 번 실행됩니다. 그런 다음 지정된 실행 횟수에 대한 평균 할당 수를 측정하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">정수의 단위를 Duration으로 변환하려면 다음을 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">지속 시간의 단위 수를 계산하려면 다음을 나누십시오.</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">컨텍스트를 사용하여 새 요청을 작성하려면 NewRequestWithContext를 사용하십시오. 요청 컨텍스트 (예 : 수신)를 변경 한 후 다시 보내도록 수정하려면 Request.Clone을 사용하십시오. 이 두 가지 용도 사이에 WithContext가 필요한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">바이트 단위로 측정 된 특정 소스 오프셋에 대한 Pos 값을 만들려면 먼저 FileSet.AddFile을 사용하여 각 파일을 현재 파일 세트에 추가 한 다음 해당 파일에 대해 File.Pos (offset)를 호출하십시오. 특정 파일 세트 fset에 대해 Pos 값 p가 주어지면 해당 위치 값은 fset.Position (p)를 호출하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">유형을 정의하기 위해 인코더는 사용되지 않은 양의 유형 ID를 선택하고 pair-type id, encode-type을 전송합니다. 여기서 encoding-type은 다음 유형으로 구성된 wireType 설명의 gob 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">자신의 형식을 정의하려면 참조 시간이 형식이 어떻게 표시되는지 기록하십시오. 예제는 ANSIC, StampMicro 또는 Kitchen과 같은 상수 값을 참조하십시오. 이 모델은 Format 및 Parse 메서드가 동일한 변환을 일반 시간 값에 적용 할 수 있도록 참조 시간이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">빌드 제한 조건을 패키지 문서와 구별하려면 일련의 빌드 제한 조건 다음에 빈 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">Stop 호출 후 채널이 비어 있는지 확인하려면 리턴 값을 확인하고 채널을 비우십시오. 예를 들어, 프로그램이 tC로부터 이미 수신되지 않았다고 가정하면 :</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">텍스트 세그먼트를 이스케이프하려면 이스케이프 문자로 묶습니다. 예를 들어이 문자열의 탭 &quot;이 탭 무시 : \ xff \ t \ xff&quot;는 셀을 종료하지 않으며 형식화를 위해 하나의 너비 문자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">Int 피연산자를 정수로 나누려면 token.QUO 대신 op == token.QUO_ASSIGN을 사용하십시오. 이 경우 결과는 Int입니다. 0으로 나누면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">HTML 출력을 생성하려면이 패키지와 인터페이스는 동일하지만 특정 공격에 대해 HTML 출력을 자동으로 보호하는 html / template 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">서버 요청 대신 클라이언트 HTTP 요청을 생성하려면 net / http 패키지의 NewRequest 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">프로파일에 할당 된 모든 블록을 포함하려면 MemProfileRate를 1로 설정하십시오. 프로파일 링을 완전히 해제하려면 MemProfileRate를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">프로파일에 모든 차단 이벤트를 포함 시키려면 전달 속도 = 1입니다. 프로파일 링을 완전히 끄려면 전달 속도 &amp;lt;= 0입니다.</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">출력에 리터럴 $를 삽입하려면 템플리트에서 $$를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">리스트를 반복하려면 (여기서 l은 * List 임) :</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">빌드에 파일이 고려되지 않도록하려면 :</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 사용하여 요청하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더로 요청하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">룬을 UpperCase, LowerCase 또는 TitleCase와 같이 지정된 케이스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">중복 작업을 방지하기 위해 데이터베이스 서버가 작업을 수행했을 가능성이있는 경우 ErrBadConn이 반환되지 않아야합니다. 서버가 오류를 다시 보내더라도 ErrBadConn을 반환해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">접두사를 제거하려면 대신 TrimPrefix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">접미사를 제거하려면 대신 TrimSuffix를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 Client.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">사용자 정의 헤더를 설정하려면 NewRequest 및 DefaultClient.Do를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">이러한 PC를 기능 이름 및 행 번호와 같은 기호 정보로 변환하려면 CallersFrames를 사용하십시오. CallersFrames는 인라인 된 기능을 설명하고 리턴 프로그램 카운터를 호출 프로그램 카운터로 조정합니다. 반환 된 PC 슬라이스를 직접 반복하는 것은 반환 된 PC 중 하나에서 FuncForPC를 사용하는 것과 같이 인라인 또는 리턴 프로그램 카운터 조정을 설명 할 수 없으므로 권장하지 않습니다. go : noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">프로파일 링을 완전히 끄려면 속도 0을 전달하십시오. 현재 속도를 읽으려면 속도 &amp;lt;0을 전달하십시오. (n&amp;gt; 1의 경우 샘플링 세부 사항이 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">JSON을 포인터로 비 정렬 화하기 위해 Unmarshal은 먼저 JSON이 JSON 리터럴 널인 경우를 처리합니다. 이 경우 Unmarshal은 포인터를 nil로 설정합니다. 그렇지 않으면 Unmarshal은 포인터가 가리키는 값으로 JSON을 비 정렬 화합니다. 포인터가 nil이면 Unmarshal은 포인터가 가리 키도록 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">JSON을 구조체로 비 정렬 화하기 위해 Unmarshal은 들어오는 객체 키를 Marshal이 사용하는 키 (구조체 필드 이름 또는 태그)와 일치시키고 정확한 일치를 선호하지만 대소 문자를 구분하지 않습니다. 기본적으로 해당 구조체 필드가없는 객체 키는 무시됩니다 (대안은 Decoder.DisallowUnknownFields 참조).</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">Unmarshaler 인터페이스를 구현하는 값으로 JSON을 비 정렬 화하기 위해 Unmarshal은 입력이 JSON null 인 경우를 포함하여 해당 값의 UnmarshalJSON 메서드를 호출합니다. 그렇지 않으면 값이 encoding.TextUnmarshaler를 구현하고 입력이 JSON 인용 문자열 인 경우 Unmarshal은 인용되지 않은 문자열 형식으로 해당 값의 UnmarshalText 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">Unmarshal은 JSON을 인터페이스 값으로 비 정렬 화하기 위해 인터페이스 값에 다음 중 하나를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">JSON 배열을 Go 배열로 비 정렬 화하기 위해 Unmarshal은 JSON 배열 요소를 해당 Go 배열 요소로 디코딩합니다. Go 배열이 JSON 배열보다 작은 경우 추가 JSON 배열 요소가 삭제됩니다. JSON 배열이 Go 배열보다 작은 경우 추가 Go 배열 요소가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스 길이를 0으로 재설정 한 다음 각 요소를 슬라이스에 추가합니다. 특별한 경우 빈 JSON 배열을 슬라이스로 비 정렬 화하기 위해 Unmarshal은 슬라이스를 새로운 빈 슬라이스로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">JSON 객체를 맵에서 비 정렬 화하기 위해 Unmarshal은 먼저 사용할 맵을 설정합니다. 맵이 nil이면 Unmarshal은 새 맵을 할당합니다. 그렇지 않으면 비 정렬 화는 기존 항목을 유지하면서 기존 맵을 재사용합니다. Unmarshal은 JSON 객체의 키-값 쌍을 맵에 저장합니다. 지도의 키 유형은 문자열, 정수 또는 encoding.TextUnmarshaler를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">파이프 라인 p를 사용하여 연결에서 여러 클라이언트를 관리하려면 각 클라이언트가 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">이 트랜잭션에서 기존 준비된 명령문을 사용하려면 Tx.Stmt를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">gob를 사용하려면 Encoder를 생성하고 값으로 참조 할 수있는 일련의 데이터 항목을 값 또는 주소로 표시하십시오. 인코더는 모든 유형 정보가 필요하기 전에 전송되도록합니다. 수신 측에서 디코더는 인코딩 된 스트림에서 값을 검색하여 로컬 변수로 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">pprof를 사용하려면이 패키지를 프로그램에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">운영 체제의 파일 시스템 구현을 사용하려면 http.Dir을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">사용 가능한 모든 프로필을 보려면 브라우저에서 &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http : // localhost : 6060 / debug / pprof /&lt;/a&gt; 를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">새 테스트 스위트를 작성하려면 여기에 설명 된대로 TestXxx 함수를 포함하는 이름이 _test.go로 끝나는 파일을 작성하십시오. 테스트 할 파일과 동일한 패키지에 파일을 넣습니다. 파일은 일반 패키지 빌드에서 제외되지만 &quot;go test&quot;명령이 실행될 때 포함됩니다. 자세한 내용은&amp;ldquo;go help test&amp;rdquo;및&amp;ldquo;go help testflag&amp;rdquo;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16은 IP 주소 ip를 16 바이트 표현으로 변환합니다. ip가 IP 주소가 아닌 경우 (잘못된 길이) To16은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4는 IPv4 주소 ip를 4 바이트 표현으로 변환합니다. ip가 IPv4 주소가 아닌 경우 To4는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Complex로 표현 될 수있는 경우 ToComplex는 x를 Complex 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">x가 Float로 표현 가능한 경우 ToFloat는 x를 Float 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML은 주석 텍스트를 형식이 지정된 HTML로 변환합니다. 주석은 DocReader에 의해 작성되었으므로 선행, 후행 공백 행이 없거나 행 끝에 후행 공백이없는 것으로 알려져 있습니다. 주석 마커가 이미 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">ToInt는 x가 Int로 표현 될 수있는 경우 x를 Int 값으로 변환합니다. 그렇지 않으면 알 수 없음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower는 룬을 소문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자가 소문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower는 모든 유니 코드 문자를 소문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 소문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 소문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash는 경로의 각 구분 문자를 슬래시 ( '/') 문자로 바꾼 결과를 반환합니다. 여러 구분 기호는 여러 슬래시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText는 텍스트 출력으로 표시 할 주석 텍스트를 준비합니다. 텍스트의 단락을 너비 이하의 유니 코드 코드 포인트로 감싸고 각 줄 앞에 들여 쓰기를 붙입니다. 미리 형식이 지정된 섹션 (예 : 프로그램 텍스트)에서는 공백이 아닌 각 줄 앞에 preIndent가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle은 룬을 제목 케이스에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle은 모든 유니 코드 문자가 해당 유니 코드 제목 케이스에 매핑 된 문자열 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 모든 유니 코드 문자가 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 모든 유니 코드 문자가 유니 코드 제목 케이스에 매핑되어 특수한 케이싱 규칙에 우선 순위를 둔 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 제목 케이스에 매핑 된 모든 유니 코드 문자가있는 사본을 반환하여 특수한 케이싱 규칙에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑하여 특수 매핑에 우선 순위를 둡니다.</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper는 룬을 대문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자가 대문자로 매핑 된 바이트 슬라이스의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper는 모든 유니 코드 문자를 대문자로 매핑하여을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial은 c로 지정된 대소 문자 매핑을 사용하여 모든 유니 코드 문자가 대문자로 매핑 된 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial은 s를 UTF-8로 인코딩 된 바이트로 취급하고 특수한 케이싱 규칙에 우선 순위를두고 모든 유니 코드 문자가 대문자로 매핑 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8은 유효하지 않은 UTF-8 바이트 시퀀스의 각 실행이 대체 문자열로 바뀌고 비어있을 수있는 문자열의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8은 s를 UTF-8로 인코딩 된 바이트로 취급하고 유효하지 않은 UTF-8을 나타내는 각 바이트 실행이 대체 된 바이트로 대체 된 사본을 리턴합니다. 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">토큰은 &amp;lt;br/&amp;gt;와 같은 자체 결산 요소를 연속 호출에 의해 반환되는 별도의 시작 및 끝 요소로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">토큰은 반환하는 StartElement 및 EndElement 토큰이 올바로 중첩되고 일치하도록 보장합니다. 토큰에 예상치 못한 끝 요소 또는 EOF가 예상되는 끝 요소보다 먼저 발생하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">토큰은 반환 된 분리 문자 [] {}가 올바르게 중첩되고 일치되도록 보장합니다. 토큰에 입력에서 예기치 않은 분리 문자가 발생하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">토큰은 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/에&lt;/a&gt; 설명 된대로 XML 네임 스페이스를 구현합니다 . 토큰에 포함 된 각 이름 구조에는 이름 공간을 알 수있는 URL로 설정된 공간이 있습니다. 토큰이 인식 할 수없는 네임 스페이스 접 두부를 발견하면 오류를보고하지 않고 접 두부를 스페이스로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">토큰은 Go 프로그래밍 언어의 어휘 토큰 세트입니다.</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 JSON 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">토큰은 입력 스트림에서 다음 XML 토큰을 반환합니다. 입력 스트림의 끝에서 토큰은 nil, io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString은 토큰 또는 유니 코드 문자에 대해 인쇄 가능한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText는 가장 최근에 스캔 한 토큰에 해당하는 문자열을 반환합니다. Scan을 호출 한 후 스캐너를 호출 할 때 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir은 빌드 도구가 포함 된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">추적은 실행 추적에 이진 형식으로 응답합니다. 추적은 GET 매개 변수 (초)로 지정된 지속 시간 동안, 또는 지정되지 않은 경우 1 초 동안 지속됩니다. 패키지 초기화는 패키지를 / debug / pprof / trace로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">런타임 활동 추적</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix는 ResponseWriter의 마술 접두사입니다. 헤더 맵 키 (있는 경우)는 맵 항목이 실제로 응답 트레일러가 아니라 응답 헤더 용임을 나타내는 신호입니다. ServeHTTP 호출이 완료된 후 접두어가 제거되고 값이 트레일러로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits는 | x |의 연속 최하위 0 비트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros는 x의 후행 0 비트 수를 반환합니다. 결과는 x == 0에 대한 UintSize입니다.</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16은 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 16입니다.</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 32입니다.</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64는 x의 후행 0 비트 수를 반환합니다. x == 0의 경우 결과는 64입니다.</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8은 x의 후행 0 비트 수를 반환합니다. 결과는 x == 0에 대해 8입니다.</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">전송은 HTTP, HTTPS 및 HTTP 프록시 (CONNECT를 사용하는 HTTP 또는 HTTPS)를 지원하는 RoundTripper의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">전송은 요청이 and 등원이고 본문이 없거나 Request.GetBody가 정의 된 경우 네트워크 오류가 발생하면 요청을 재 시도합니다. HTTP 요청에 HTTP 메소드 GET, HEAD, OPTIONS 또는 TRACE가있는 경우 HTTP 요청은 dem 등원으로 간주됩니다. 또는 헤더 맵에 &quot;Idempotency-Key&quot;또는 &quot;X-Idempotency-Key&quot;항목이 포함 된 경우 dem 등원 키 값이 길이가 0 인 슬라이스 인 경우 요청은 dem 등원으로 취급되지만 헤더는 유선으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">전송은 서버가 HTTP / 2를 지원하는지 여부와 전송 구성 방법에 따라 HTTP URL에 HTTP / 1.1을 사용하고 HTTPS URL에 HTTP / 1.1 또는 HTTP / 2를 사용합니다. DefaultTransport는 HTTP / 2를 지원합니다. 전송에서 HTTP / 2를 명시 적으로 사용 가능하게하려면 golang.org/x/net/http2를 사용하고 ConfigureTransport를 호출하십시오. HTTP / 2에 대한 자세한 내용은 패키지 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">필요에 따라 전송을 작성하는 대신 전송을 재사용해야합니다. 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">트리는 단일 구문 분석 된 템플리트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">트림은 컷셋에 포함 된 모든 선행 및 후행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim은 cutset에 포함 된 모든 선행 및 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes는 선행 및 후행 ASCII 공간없이 b를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc는 f (c)를 만족하는 모든 선행 및 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft는 컷셋에 포함 된 모든 선행 유니 코드 코드 포인트가 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft는 cutset에 포함 된 모든 선행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc는 f (c)를 만족하는 모든 선행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc는 s를 UTF-8 인코딩 된 바이트로 취급하고 f (c)를 만족하는 모든 선행 UTF-8 인코딩 된 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix는 제공된 선행 접두사 문자열없이 s를 반환합니다. s가 접두사로 시작하지 않으면 s가 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 유니 코드 코드 포인트가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight는 컷셋에 포함 된 모든 후행 UTF-8 인코딩 코드 포인트를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 유니 코드 코드 포인트 c가 제거 된 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc는 f (c)를 만족하는 모든 후행 UTF-8 인코딩 코드 포인트 c를 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백이 제거 된 문자열 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace는 유니 코드로 정의 된대로 모든 선행 및 후행 공백을 슬라이스하여 s의 하위 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString은 선행 및 후행 ASCII 공간없이 s를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix는 제공된 후행 접미사 문자열없이 s를 리턴합니다. s가 접미사로 끝나지 않으면 s는 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc는 x의 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">자르기는 파일 크기를 변경합니다. I / O 오프셋은 변경되지 않습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">잘림은 명명 된 파일의 크기를 변경합니다. 파일이 심볼릭 링크 인 경우 링크 대상의 크기가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">잘림은 버퍼에서 처음 n 개의 읽지 않은 바이트를 제외한 모든 메모리를 삭제하지만 동일한 할당 된 스토리지를 계속 사용합니다. n이 음수이거나 버퍼 길이보다 길면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">잘라내 기는 0 시간 이후의 절대 지속 시간으로 시간에 작동합니다. 시간의 프리젠 테이션 형식에서는 작동하지 않습니다. 따라서 Truncate (Hour)는 시간 위치에 따라 0이 아닌 분으로 시간을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">자르기 d를 0으로 반올림 한 결과를 m의 배수로 반환합니다. m &amp;lt;= 0이면 Truncate는 변경되지 않은 d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">잘라내 기는 t를 d의 배수로 내림 한 결과를 리턴합니다 (0부터). d &amp;lt;= 0 인 경우 Truncate는 단조로운 클럭 판독 값에서 t를 제거하지만 달리 변경하지 않은 t를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter는 w에 쓰지만 n 바이트 후에 자동으로 중지되는 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy는 값 v의 JavaScript &quot;진실성&quot;을 반환합니다. JavaScript에서 false, 0, &quot;&quot;, null, undefined 및 NaN은 &quot;거짓&quot;이며 다른 모든 것은 &quot;거짓&quot;입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv는 채널 v에서 값을 받으려고 시도하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 수신이 값을 전달하면 x가 전송 된 값이고 ok는 true입니다. 수신이 차단없이 완료 될 수 없으면 x는 0 값이고 ok는 false입니다. 채널이 닫히면 x는 채널 요소 유형의 0 값이고 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend는 채널 v에서 x를 보내려고하지만 차단하지는 않습니다. v 's Kind가 Chan이 아니면 패닉 상태입니다. 값이 전송되었는지 여부를보고합니다. Go에서와 같이 x의 값은 채널의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">이 패키지에는 2 개의 인터페이스 세트가 포함되어 있습니다. 보다 추상적 인 인터페이스가 필요하지 않은 경우 v1.5 / OAEP로 암호화 / 복호화하고 v1.5 / PSS로 서명 / 확인하는 기능이 있습니다. 공개 키 프리미티브를 추상화해야 할 경우 PrivateKey 구조체는 암호화 패키지에서 Decrypter 및 Signer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx는 거래입니다.</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx는 진행중인 데이터베이스 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions에는 DB.BeginTx에서 사용할 트랜잭션 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions는 트랜잭션 옵션을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ에는 해당 BasicKind에 의해 색인 된 사전 선언 된 * 기본 유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag에 대한 유형 플래그.</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">형식 유추는 모든 식 (ast.Expr)의 형식 (Type)을 계산하고 언어 사양을 준수하는지 확인합니다. 형식 유추의 결과에 Info.Types [expr] .Type을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">형식은 Header.Type에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">유형은 문서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">Type은 형식 선언에 대한 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">유형은 Go 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">유형은 DWARF&amp;ldquo;정보&amp;rdquo;섹션에서 유형을 끕니다.</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type은 Value의 JavaScript 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">유형 자체를 반환하고 노드에 포함하기위한 쉬운 기본 구현을 제공합니다. 모든 사소한 노드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type은 값 v의 JavaScript 유형을 반환합니다.이 값은 null에 대해 TypeObject 대신 TypeNull을 반환한다는 점을 제외하면 JavaScript의 typeof 연산자와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type은 객체의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type은 xf의 유형을 반환하며 f의 유형과 다를 수 있습니다. 자세한 내용은 선택을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">타입은 v 타입을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">== 연산자와 같은 유형 값은 비교 가능하므로 맵 키로 사용할 수 있습니다. 두 유형 값이 동일한 유형을 나타내는 경우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">유형 검사는 여러 개의 상호 의존적 인 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1은 설명서 목적으로 만 사용됩니다. 모든 Go 유형에 대한 스탠드 인이지만 주어진 함수 호출에 대해 동일한 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue는 해당 표현식의 유형과 값 (상수의 경우)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension은 파일 확장자 ext와 연관된 MIME 유형을 리턴합니다. 확장자 ext는 &quot;.html&quot;과 같이 선행 점으로 시작해야합니다. ext에 연결된 유형이 없으면 TypeByExtension은 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
