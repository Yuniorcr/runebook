<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="0b1b5b05fec2cd6d8e78c93f5a64f37706828f50" translate="yes" xml:space="preserve">
          <source>ModelFunc returns a Model that invokes f to implement the conversion.</source>
          <target state="translated">ModelFunc는 f를 호출하여 변환을 구현하는 Model을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5361e7791528a917952293ec5274927cfb3ce5f8" translate="yes" xml:space="preserve">
          <source>Models for the standard color types.</source>
          <target state="translated">표준 색상 유형에 대한 모델.</target>
        </trans-unit>
        <trans-unit id="e56d540b050862c318d1aab05d9e382cf0a4c4af" translate="yes" xml:space="preserve">
          <source>Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.</source>
          <target state="translated">Modf는 f에 해당하는 정수 및 소수 부동 소수점 숫자를 반환합니다. 두 값 모두 f와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8fdb64fd7614b420c244d4e876ef3defb57abcc" translate="yes" xml:space="preserve">
          <source>Modular exponentation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="translated">특정 크기의 입력에 대한 모듈 식 지수는 암호 적으로 일정한 시간 연산이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2dd5487e8328e8658b359aa63c39e650ee5e1172" translate="yes" xml:space="preserve">
          <source>Module represents a module.</source>
          <target state="translated">모듈은 모듈을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1156729972d424016ec9426afb303f681b9f79f" translate="yes" xml:space="preserve">
          <source>Monotonic Clocks</source>
          <target state="translated">단조로운 시계</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="66f2529dffac9fbc9ec633022a5f8b0bedc8c37f" translate="yes" xml:space="preserve">
          <source>Month returns the month of the year specified by t.</source>
          <target state="translated">Month는 t로 지정된 연도의 달을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="668403e4d2bd4eddcb9aed021f2a174eb200dc88" translate="yes" xml:space="preserve">
          <source>More control over the server's behavior is available by creating a custom Server:</source>
          <target state="translated">사용자 정의 서버를 작성하여 서버 작동을보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e92ae26cba75c5b6d8d17d26d228885ce889bf" translate="yes" xml:space="preserve">
          <source>More intricate examples appear below.</source>
          <target state="translated">더 복잡한 예가 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="544eaf68f34e5f73c2388e2ae8096fe2204e2585" translate="yes" xml:space="preserve">
          <source>More reports whether there is another element in the current array or object being parsed.</source>
          <target state="translated">현재 배열 또는 구문 분석중인 객체에 다른 요소가 있는지 더보고합니다.</target>
        </trans-unit>
        <trans-unit id="0f3ee8adfe02375a24e073f00bd7e8a1f885bbc4" translate="yes" xml:space="preserve">
          <source>Most callers should instead use Open, which transparently decompresses data and verifies checksums.</source>
          <target state="translated">대부분의 호출자는 대신 데이터를 투명하게 압축 해제하고 체크섬을 확인하는 Open을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="204dcf13599d817427dd2073f0e35f29dec05bc1" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling GoroutineProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 GoroutineProfile을 직접 호출하는 대신 runtime / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d4c0e8a354401dd8233b4356c1a0bfb3bef2533" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling MutexProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 MutexProfile을 직접 호출하는 대신 runtime / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd55cd96fc64e1ee33e5ec28f8d3ef1539755bd8" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 ThreadCreateProfile을 직접 호출하는 대신 런타임 / pprof 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="646d3b37e5e676f43944b0bc1ef49ce31304c768" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 BlockProfile을 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.blockprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb5152386c9af905d8957add4efa5a79dbea3046" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly.</source>
          <target state="translated">대부분의 클라이언트는 SetCPUProfileRate를 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.cpuprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc35c049e953a9f16068abcc035a22ebd5b44d39" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly.</source>
          <target state="translated">대부분의 클라이언트는 MemProfile을 직접 호출하는 대신 runtime / pprof 패키지 또는 테스트 패키지의 -test.memprofile 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ec46c99b7f54aae4ce499a3028a52ae6552a566" translate="yes" xml:space="preserve">
          <source>Most code should use package sql.</source>
          <target state="translated">대부분의 코드는 sql 패키지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="19ad74392792ed9739e1d28d7638006df3165986" translate="yes" xml:space="preserve">
          <source>Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of third-party drivers.</source>
          <target state="translated">대부분의 사용자는 * DB를 반환하는 드라이버 별 연결 도우미 함수를 통해 데이터베이스를 엽니 다. Go 표준 라이브러리에는 데이터베이스 드라이버가 포함되어 있지 않습니다. 타사 드라이버 목록은 &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ed633024d8dc0b448fbe281ca6b8177fe27c56" translate="yes" xml:space="preserve">
          <source>Move moves n % r.Len() elements backward (n &amp;lt; 0) or forward (n &amp;gt;= 0) in the ring and returns that ring element. r must not be empty.</source>
          <target state="translated">이동은 링에서 n % r.Len () 요소를 뒤로 (n &amp;lt;0) 또는 앞으로 (n&amp;gt; = 0) 이동하고 해당 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b69d844fd11e170cd47ef8ff2a97178038b339b" translate="yes" xml:space="preserve">
          <source>MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveAfter는 요소 e를 마크 뒤 새 위치로 이동합니다. e 또는 mark가 l의 요소가 아니거나 e == mark 인 경우 목록이 수정되지 않습니다. 요소와 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="33d96c6050800194a8407c20b5ca64f6846c7299" translate="yes" xml:space="preserve">
          <source>MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveBefore는 요소 e를 마크 이전의 새 위치로 이동합니다. e 또는 mark가 l의 요소가 아니거나 e == mark 인 경우 목록이 수정되지 않습니다. 요소와 마크는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="48e25efa9d98fcd9ecb09e7fe7ed87eb426e273a" translate="yes" xml:space="preserve">
          <source>MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToBack은 요소 e를 목록 l의 뒤로 이동합니다. e가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f362d110c32c4c4500cf8d4c490f31132fbb839" translate="yes" xml:space="preserve">
          <source>MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToFront는 요소 e를 목록 l의 맨 앞으로 이동합니다. e가 l의 요소가 아닌 경우 목록이 수정되지 않습니다. 요소는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="90114025b275cbc4bcd8b562c1a58b937341fdfb" translate="yes" xml:space="preserve">
          <source>Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul은 x와 y의 전각 곱을 반환합니다 : (hi, lo) = x * y는 제품 비트의 상반신이 hi로, 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26a6e266f6cfb3f2f503215e9850aa02f8f9da06" translate="yes" xml:space="preserve">
          <source>Mul returns the vector p*k.</source>
          <target state="translated">Mul은 벡터 p * k를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da7ddc591d70c1b455e617b48abf92f18b455b2b" translate="yes" xml:space="preserve">
          <source>Mul sets z to the product x*y and returns z.</source>
          <target state="translated">Mul은 z를 곱 x * y로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77d0b9f0608c4902ed59d2c704e92843cbc28318" translate="yes" xml:space="preserve">
          <source>Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case.</source>
          <target state="translated">Mul은 z를 둥근 제품 x * y로 설정하고 z를 반환합니다. 정밀도, 반올림 및 정확도보고는 추가와 같습니다. 하나의 피연산자가 0이고 다른 피연산자가 무한대이면 ErrNaN으로 다중 패닉. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b861b19bddbd0bc8bab01f2fb9899e8f0de45d9e" translate="yes" xml:space="preserve">
          <source>Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul32는 x와 y의 64 비트 곱을 반환합니다 : (hi, lo) = x * y는 제품 비트의 상반신이 hi로 반환되고 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a25ed66383b36d2221150102c89edba8efbb0c02" translate="yes" xml:space="preserve">
          <source>Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul64는 x와 y의 128 비트 곱을 반환합니다. (hi, lo) = x * y는 제품 비트의 상반부가 hi로, 하반부는 lo로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4ec4f00f8b7fc0f34cde307521a1856a53aa0b" translate="yes" xml:space="preserve">
          <source>MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a &amp;gt; b (empty range), the result is 1.</source>
          <target state="translated">MulRange는 z를 [a, b] 범위에있는 모든 정수의 곱으로 설정하고 z를 반환합니다. a&amp;gt; b (빈 범위) 인 경우 결과는 1입니다.</target>
        </trans-unit>
        <trans-unit id="9eaaace92dc7df7151a8f45536ad19d09279e182" translate="yes" xml:space="preserve">
          <source>MultiReader</source>
          <target state="translated">MultiReader</target>
        </trans-unit>
        <trans-unit id="5d860fccf2fdf207ce3f3ccf216ed942057c9707" translate="yes" xml:space="preserve">
          <source>MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.</source>
          <target state="translated">MultiReader는 제공된 입력 판독기의 논리적 연결 인 Reader를 반환합니다. 순차적으로 읽습니다. 모든 입력이 EOF를 반환하면 Read는 EOF를 반환합니다. 판독기가 non-non, EOF 이외의 오류를 반환하면 Read는 해당 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4faad6c802b39e83086bf59c7e2903092d5a691b" translate="yes" xml:space="preserve">
          <source>MultiWriter</source>
          <target state="translated">MultiWriter</target>
        </trans-unit>
        <trans-unit id="0e1b7f58a5f86256f9545cb408ae583680594854" translate="yes" xml:space="preserve">
          <source>MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.</source>
          <target state="translated">MultiWriter는 Unix tee (1) 명령과 유사하게 제공된 모든 기록기에 기록을 복제하는 기록기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3688e77a9282752c7dda127e113710f59d4dafc0" translate="yes" xml:space="preserve">
          <source>MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.</source>
          <target state="translated">MulticastAddrs는 특정 인터페이스에 대해 결합 된 멀티 캐스트 그룹 주소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9bb2b61e03ad9524ce2fff2bf8e39b44ea3373a" translate="yes" xml:space="preserve">
          <source>MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream.</source>
          <target state="translated">MultipartReader는 multipart / form-data 또는 multipart / mixed POST 요청 인 경우 MIME multipart reader를 반환하고, 그렇지 않으면 nil과 오류를 반환합니다. 요청 본문을 스트림으로 처리하려면 ParseMultipartForm 대신이 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a782cf6ce52ba3c0409a2a494107b5e5d1c07de1" translate="yes" xml:space="preserve">
          <source>Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.</source>
          <target state="translated">패키지 / 유형 / 기능 / 방법에 대한 복수의 예시적인 기능은 명칭에 별개의 접미사를 추가함으로써 제공 될 수있다. 접미사는 소문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="97b40210f32960166bd52edfda4ec341de71235b" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Conn simultaneously.</source>
          <target state="translated">여러 고 루틴이 동시에 Conn에서 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6556b625ec1c61ad052df5128208f619bcfcc88f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Listener simultaneously.</source>
          <target state="translated">다수의 고 루틴은 리스너에서 동시에 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58239811314fdc4f9e0084cf7b627a6e3f8ff5f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a PacketConn simultaneously.</source>
          <target state="translated">여러 고 루틴이 PacketConn에서 동시에 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df2c141b4f12a4ff075a8eeb676ff9cf5032e4dc" translate="yes" xml:space="preserve">
          <source>MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.</source>
          <target state="translated">MultiplePackageError는 여러 패키지에 대해 여러 빌드 가능한 Go 소스 파일을 포함하는 디렉토리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="79a3dc65878a83d5c3f20c9bd1c6028718af5b1b" translate="yes" xml:space="preserve">
          <source>Multistream controls whether the reader supports multistream files.</source>
          <target state="translated">멀티 스트림은 리더가 멀티 스트림 파일을 지원하는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5d72b823f6e2f60a18b59bcf20086228b774dfee" translate="yes" xml:space="preserve">
          <source>Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as</source>
          <target state="translated">오류가 0이 아닌 경우 반환하는 함수 (* 템플릿, 오류) 및 패닉에 대한 호출을 래핑하는 도우미 여야합니다. 다음과 같은 변수 초기화에 사용하기위한 것입니다</target>
        </trans-unit>
        <trans-unit id="a51f1ed56a509883e121438647786188d9af7d2f" translate="yes" xml:space="preserve">
          <source>MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompile은 Compile과 비슷하지만 표현식을 구문 분석 할 수없는 경우 패닉 상태입니다. 컴파일 된 정규식을 보유하는 전역 변수의 안전한 초기화를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="9116a0a3a6e98be619745d64aa7d73bda9c8d13e" translate="yes" xml:space="preserve">
          <source>MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompilePOSIX는 CompilePOSIX와 유사하지만 표현식을 구문 분석 할 수없는 경우 패닉 상태입니다. 컴파일 된 정규식을 보유하는 전역 변수의 안전한 초기화를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="3784bc24f8a3c7e8d169e2b4535e09805ebe5ca0" translate="yes" xml:space="preserve">
          <source>MutexProfile returns n, the number of records in the current mutex profile. If len(p) &amp;gt;= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.</source>
          <target state="translated">MutexProfile은 현재 뮤텍스 프로파일의 레코드 수인 n을 반환합니다. len (p)&amp;gt; = n 인 경우 MutexProfile은 프로파일을 p에 복사하고 n, true를 리턴합니다. 그렇지 않으면 MutexProfile은 p를 변경하지 않고 n, false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d847ec5889f3982ffb9b7ffa72ed90e47750577" translate="yes" xml:space="preserve">
          <source>NArg is the number of arguments remaining after flags have been processed.</source>
          <target state="translated">NArg는 플래그가 처리 된 후 남아있는 인수의 수입니다.</target>
        </trans-unit>
        <trans-unit id="2f24c1c2739257b059d4d3dc9321f1cdf1115063" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of command-line flags that have been set.</source>
          <target state="translated">NFlag는 설정된 명령 줄 플래그 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="810e97bcf54f7c38d780b8018b94bedc96063ac9" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of flags that have been set.</source>
          <target state="translated">NFlag는 설정된 플래그 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c725fb1ef92b939b16dd002af225b2de23e38031" translate="yes" xml:space="preserve">
          <source>NRGBA is an in-memory image whose At method returns color.NRGBA values.</source>
          <target state="translated">NRGBA는 At 메서드가 color.NRGBA 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="d8bb0d248591faba7b18624bf05d5a4e94d4a0a2" translate="yes" xml:space="preserve">
          <source>NRGBA represents a non-alpha-premultiplied 32-bit color.</source>
          <target state="translated">NRGBA는 비 알파 미리 곱셈 된 32 비트 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b8e9eaa83b4e60710ae3746671221d4b97e37ff" translate="yes" xml:space="preserve">
          <source>NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.</source>
          <target state="translated">NRGBA64는 At 메서드가 color.NRGBA64 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="0c537b2ac3425dc17a66dbbf5b63bd3a7a48fb29" translate="yes" xml:space="preserve">
          <source>NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">NRGBA64는 빨강, 초록, 파랑 ​​및 알파 각각에 대해 16 비트를 갖는 비 알파 미리 곱셈 된 64 비트 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cacdaed348d8c69a0481b79dcd2e483e182ae7b" translate="yes" xml:space="preserve">
          <source>NType values; used in core files.</source>
          <target state="translated">N 형 값; 핵심 파일에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe809819a7c3bc6a6cb826d8f87edea50d7df8a" translate="yes" xml:space="preserve">
          <source>NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.</source>
          <target state="translated">NYCbCrA는 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 색상의 메모리 내 이미지입니다. A 및 AStride는 내장 된 YCbCr의 Y 및 YStride 필드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="381ced7e52d37e0dab6bd72178c010245712478e" translate="yes" xml:space="preserve">
          <source>NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.</source>
          <target state="translated">NYCbCrA는 하나의 루마, 2 개의 크로마 및 1 개의 알파 성분에 대해 각각 8 비트를 갖는 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 컬러를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="3ddf7ce6d18dffcfd157667c9d84e86a1c6b7d4e" translate="yes" xml:space="preserve">
          <source>NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha colors.</source>
          <target state="translated">NYCbCrAModel은 알파가 아닌 미리 곱셈 된 Y'CbCr- 알파 색상에 대한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="57d5b53b7b3ad276283b2d42d51634e430be6df3" translate="yes" xml:space="preserve">
          <source>NaN returns a complex &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN은 복잡한 숫자가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01647cea0fd9639449467ddb347270a0682c015d" translate="yes" xml:space="preserve">
          <source>NaN returns an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN은 IEEE 754 &quot;숫자가 아님&quot;값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="translated">이름 확인</target>
        </trans-unit>
        <trans-unit id="99409b3041e22d0d0c5a802c5fd9d08e77da5379" translate="yes" xml:space="preserve">
          <source>Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.</source>
          <target state="translated">중간체의 이름 제약은 opts.DNSName뿐만 아니라 체인에서 주장하는 모든 이름에 적용됩니다. 따라서 잎이 example.com이 유효한 이름이 아니더라도 중간에 허용되지 않으면 example.com의 소유권을 주장하는 것은 유효하지 않습니다. DirectoryName 제약 조건은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fba782366c931b096922fa065c94888533271bf" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID.</source>
          <target state="translated">이름은 X.509 고유 이름을 나타냅니다. 여기에는 DN의 공통 요소 만 포함됩니다. 구문 분석 할 때 모든 요소가 이름에 저장되고 비표준 요소를 추출 할 수 있습니다. 마샬링 할 때 ExtraNames의 요소가 추가되고 동일한 OID로 다른 값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="e3f01020dd86fefd968bc57f34e6cf3dc39dbcdc" translate="yes" xml:space="preserve">
          <source>Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution.</source>
          <target state="translated">이름 확인은 프로그램의 각 식별자 (ast.Ident)를 나타내는 언어 개체 (Object)에 매핑합니다. 이름 확인 결과에 Info. {Defs, Uses, Implicits}를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dff2bc150a13aad1afbb3a0e77b91c6f29404d25" translate="yes" xml:space="preserve">
          <source>Name returns the file name of file f as registered with AddFile.</source>
          <target state="translated">이름은 AddFile에 등록 된 파일 f의 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbf0685fdc3e1fc7383fb6378b40c72d45ba31cf" translate="yes" xml:space="preserve">
          <source>Name returns the name of basic type b.</source>
          <target state="translated">이름은 기본 유형의 이름을 반환합니다. b.</target>
        </trans-unit>
        <trans-unit id="8fcb1133e9348f92420cdfc4678a083c2132530b" translate="yes" xml:space="preserve">
          <source>Name returns the name of the file as presented to Open.</source>
          <target state="translated">이름은 Open에 표시되는 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8f3d9e671d5c8526b346806d1b0aee8900f60" translate="yes" xml:space="preserve">
          <source>Name returns the name of the flag set.</source>
          <target state="translated">이름은 플래그 세트의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2302d490bb5c27edeb93f2429b3dd3925a94667d" translate="yes" xml:space="preserve">
          <source>Name returns the name of the function.</source>
          <target state="translated">이름은 함수의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e85527ce244650d2eef45c942c6fb4c49d00958" translate="yes" xml:space="preserve">
          <source>Name returns the name of the running test or benchmark.</source>
          <target state="translated">이름은 실행중인 테스트 또는 벤치 마크의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae31bd0a4e13087d9881916ed12efd37cc202962" translate="yes" xml:space="preserve">
          <source>Name returns the name of the template.</source>
          <target state="translated">이름은 템플릿의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d0afdb2756b72089c5803a1fea5a6f6af89abf2" translate="yes" xml:space="preserve">
          <source>Name returns the name or alias of the column.</source>
          <target state="translated">이름은 열의 이름 또는 별명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6fdae4adddc5e0ab59190994aa36753a8da75cde" translate="yes" xml:space="preserve">
          <source>Name returns the object's (package-local, unqualified) name.</source>
          <target state="translated">이름은 객체의 (패키지 로컬, 규정되지 않은) 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="715e38c6f54ac0414267875866ec7639f2185b6c" translate="yes" xml:space="preserve">
          <source>Name returns the package name.</source>
          <target state="translated">이름은 패키지 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2f1501e711468701351739094e89f2faaa9754b" translate="yes" xml:space="preserve">
          <source>Name returns this profile's name, which can be passed to Lookup to reobtain the profile.</source>
          <target state="translated">Name은이 프로파일의 이름을 반환하며,이 프로파일은 Lookup으로 전달되어 프로파일을 다시 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ef5638500e255787c53cfed76765c95ef368f8" translate="yes" xml:space="preserve">
          <source>Named character classes as character class elements:</source>
          <target state="translated">문자 클래스 요소로 명명 된 문자 클래스 :</target>
        </trans-unit>
        <trans-unit id="5214e3c70b9463e72846eff24f10e0e17205139c" translate="yes" xml:space="preserve">
          <source>Named provides a more concise way to create NamedArg values.</source>
          <target state="translated">Named는 NamedArg 값을 작성하는보다 간결한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c1c1ca0e676e9e2072afd4d97cad1c4edafd2" translate="yes" xml:space="preserve">
          <source>NamedValue holds both the value name and value.</source>
          <target state="translated">NamedValue는 값 이름과 값을 모두 보유합니다.</target>
        </trans-unit>
        <trans-unit id="c99f38d2678a853989d8a832348bdca952de6c49" translate="yes" xml:space="preserve">
          <source>NamedValueChecker may be optionally implemented by Conn or Stmt. It provides the driver more control to handle Go and database types beyond the default Values types allowed.</source>
          <target state="translated">NamedValueChecker는 선택적으로 Conn 또는 Stmt에 의해 구현 될 수 있습니다. 허용되는 기본 값 유형 이외의 Go 및 데이터베이스 유형을 처리하도록 드라이버에 더 많은 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4abb0014fb99c3ea27630821804136f4a291ddd2" translate="yes" xml:space="preserve">
          <source>Names returns the scope's element names in sorted order.</source>
          <target state="translated">이름은 범위의 요소 이름을 정렬 된 순서로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68be7148b1d69811d870e9714f9a627c5b3b1099" translate="yes" xml:space="preserve">
          <source>Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86.</source>
          <target state="translated">파일 dns_windows.go의 이름을 지정하면 Windows 용 패키지를 빌드 할 때만 파일이 포함됩니다. 마찬가지로 math_386.s는 32 비트 x86 용 패키지를 빌드 할 때만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cabaa7d294786796f928e96fc93a4f221988121e" translate="yes" xml:space="preserve">
          <source>Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano는 유닉스 시대 이후로 경과 된 나노초 수로 ts를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cc13f72d19e3af8ee9e16f480775aaded9f3087" translate="yes" xml:space="preserve">
          <source>Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano는 유닉스 시대 이후로 경과 한 나노초 수로 tv를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e6c24671bd350d239a637f4eb004b1ac035f0f6" translate="yes" xml:space="preserve">
          <source>Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].</source>
          <target state="translated">나노초는 [0, 999999999] 범위에서 t로 지정된 초 이내에 나노초 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9254412c6c417a32ffd67afde8a4d3f64458a58f" translate="yes" xml:space="preserve">
          <source>Nanoseconds returns the duration as an integer nanosecond count.</source>
          <target state="translated">나노초는 지속 시간을 정수 나노초 카운트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba032ae40abdc5925e0860a082adf4aba20cf4c6" translate="yes" xml:space="preserve">
          <source>Neg sets z to -x and returns z.</source>
          <target state="translated">Neg는 z를 -x로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="381b641c01f8a09410b41524ec6b9c342099d866" translate="yes" xml:space="preserve">
          <source>Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z.</source>
          <target state="translated">Neg는 z를 부호가 무시 된 x의 (올림 된) 값으로 설정하고 z를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8646ff662d17d59189bbe1c09e1b45ec2fcbe881" translate="yes" xml:space="preserve">
          <source>Nested template definitions</source>
          <target state="translated">중첩 템플릿 정의</target>
        </trans-unit>
        <trans-unit id="d8c5cfb403999ea3c1717d789cd51587c786bc53" translate="yes" xml:space="preserve">
          <source>NetlinkMessage represents a netlink message.</source>
          <target state="translated">NetlinkMessage는 netlink 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c4870d25f2151dc7bae14a92d6848398da82d87" translate="yes" xml:space="preserve">
          <source>NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.</source>
          <target state="translated">NetlinkRIB는 RIB로 알려진 라우팅 정보 기반을 반환하며, 이는 네트워크 기능 정보, 상태 및 매개 변수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="602233e97016bb5f79aa0bd9f5a926d8f7889c93" translate="yes" xml:space="preserve">
          <source>NetlinkRouteAttr represents a netlink route attribute.</source>
          <target state="translated">NetlinkRouteAttr은 netlink 경로 속성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44279944636fb5149ee9e75b524255aa96e79a4e" translate="yes" xml:space="preserve">
          <source>NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.</source>
          <target state="translated">NetlinkRouteRequest는 커널로부터 라우팅 및 링크 상태를 수신하기위한 요청 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="884a4650baee52e272bb3c5efceff09f71b0dc8c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;ip&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="872aebe8ec9741bc61a3685b3731dbde3529008c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip+net&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;ip + net&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa465c71127a452dc67c99401e7bc2d64148685d" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;tcp&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;tcp&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="985257f66305f39d2139512f1ac004ba3741bdd6" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;udp&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;udp&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85eeab19d1e5738f817203c5a4d550375f022dc2" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;unix&quot;, &quot;unixgram&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">네트워크는 주소의 네트워크 이름 &quot;unix&quot;, &quot;unixgram&quot;또는 &quot;unixpacket&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="73e705a3151bc08fd1addfd7992ec83ec85bc2d3" translate="yes" xml:space="preserve">
          <source>New (Errorf)</source>
          <target state="translated">새로운 (Errorf)</target>
        </trans-unit>
        <trans-unit id="ce9f1f28f9b789d29a4ccd4ff058458cc3933476" translate="yes" xml:space="preserve">
          <source>New (File)</source>
          <target state="translated">새로운 파일)</target>
        </trans-unit>
        <trans-unit id="13a673772e81bed6fd77076f80c7ff1f6ee89e61" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">새로 만들기는 지정된 것과 동일한 구분 기호를 사용하여 새 HTML 템플릿을 할당합니다. 전 이적 연관은 한 템플리트가 {{template}} 조치로 다른 템플리트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1c98d75d213247ac29168d2da24b2789a4dbb7a8" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template with the given name.</source>
          <target state="translated">New는 주어진 이름으로 새로운 HTML 템플릿을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="34bc55c1fb0c505ee8f76b87c91bd2fc06fc027b" translate="yes" xml:space="preserve">
          <source>New allocates a new parse tree with the given name.</source>
          <target state="translated">New는 주어진 이름으로 새로운 구문 분석 트리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="685d42b22fd5f12d0d18a35ac55a1b6c69615a8a" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">새로 만들기는 지정된 템플릿과 동일한 구분 기호와 관련된 새 정의되지 않은 템플릿을 할당합니다. 전 이적 연관은 한 템플리트가 {{template}} 조치로 다른 템플리트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1bfbe44c21200e9acb8918513405e990a5ad64ec" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template with the given name.</source>
          <target state="translated">새로 만들기는 주어진 이름으로 정의되지 않은 새 템플릿을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d58e7e7be4ff87f86b4026a755b5a08e8395893d" translate="yes" xml:space="preserve">
          <source>New changes in the system cert pool might not be reflected in subsequent calls.</source>
          <target state="translated">시스템 인증서 풀의 새로운 변경 사항은 후속 호출에 반영되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8732c118b0cc7bc660fa4e5273983e4bed17a5c" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it.</source>
          <target state="translated">New는 주어진 패키지 AST에 대한 패키지 문서를 계산합니다. New는 AST pkg의 소유권을 가지며이를 편집하거나 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a02872376b9cd15170d6472cf48d2f256d4269" translate="yes" xml:space="preserve">
          <source>New creates a new Index for data. Index creation time is O(N) for N = len(data).</source>
          <target state="translated">새로 작성하면 데이터에 대한 새 색인이 작성됩니다. 인덱스 생성 시간은 N = len (data)에 대해 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="1938bcca0d3c4801a22481ce59e7278f4b6da953" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties.</source>
          <target state="translated">새로 작성하면 새 로거가 작성됩니다. out 변수는 로그 데이터가 기록 될 대상을 설정합니다. 접두사는 생성 된 각 로그 줄의 시작 부분에 나타납니다. 플래그 인수는 로깅 특성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9a296c49d13ddf053bb1930fb55493ded12e0b12" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 생성합니다. Table로 표시되는 다항식을 사용하여 CRC-32 체크섬을 계산합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f96eb28144daf2fb90bf412860be6e76ca52cf10" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 생성합니다. Table로 표시되는 다항식을 사용하여 CRC-64 체크섬을 계산합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash64는 해시의 내부 상태를 마샬링하고 마샬링 해제하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="44ec7b7b536da273869e89c5cb90df2959fd9688" translate="yes" xml:space="preserve">
          <source>New creates a ring of n elements.</source>
          <target state="translated">새로 만들기는 n 개의 요소의 고리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e7fd8b4c480fbc496999332eaae2de8518c1f830" translate="yes" xml:space="preserve">
          <source>New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the os.Args[0] is used.</source>
          <target state="translated">새로 작성하면 시스템 로그 디먼에 대한 새 연결이 설정됩니다. 리턴 된 기록기에 대한 각 쓰기는 주어진 우선 순위 (syslog 기능과 심각도의 조합) 및 접 두부 태그가있는 로그 메시지를 보냅니다. 태그가 비어 있으면 os.Args [0]이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c433bff47e0e23c62ed805b07cbec0f2f0b6f46" translate="yes" xml:space="preserve">
          <source>New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).</source>
          <target state="translated">New는 지정된 유형의 새 0 값에 대한 포인터를 나타내는 Value를 반환합니다. 즉, 반환 된 Value의 Type은 PtrTo (typ)입니다.</target>
        </trans-unit>
        <trans-unit id="0c3bbfe7ec852d2a1508f7c286818c11369b8298" translate="yes" xml:space="preserve">
          <source>New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe.</source>
          <target state="translated">New는 주어진 매개 변수에서 초기화 된 새로운 Data 객체를 반환합니다. 클라이언트는이 함수를 직접 호출하는 대신 일반적으로 적절한 패키지 디버그 / elf, 디버그 / 마초 또는 디버그 / pe의 파일 유형의 DWARF 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="34063232a48f53eca99c828d036ef36cf5de37bb" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="translated">New는 주어진 hash.Hash 유형과 키를 사용하여 새로운 HMAC 해시를 반환합니다. 표준 라이브러리의 다른 해시 구현과 달리 반환 된 Hash는 encoding.BinaryMarshaler 또는 encoding.BinaryUnmarshaler를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dae1d45948f3340a826a534080ea715da59576dc" translate="yes" xml:space="preserve">
          <source>New returns a new Rand that uses random values from src to generate other random values.</source>
          <target state="translated">New는 src에서 임의의 값을 사용하여 다른 임의의 값을 생성하는 새 랜드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99c2c428e0dc030c03d2e8b41267ed3ddbe36dfb" translate="yes" xml:space="preserve">
          <source>New returns a new cookie jar. A nil *Options is equivalent to a zero Options.</source>
          <target state="translated">New는 새로운 쿠키 항아리를 반환합니다. nil * Options는 제로 Options와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f821272946e1801b5f1d4a05a86314806248536" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. 해시는 주어진 해시 함수를 계산합니다. 해시 함수가 바이너리에 연결되지 않은 경우 새로운 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1098b04617924fcea48eac93732552bb3d10a9b9" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the MD5 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. MD5 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f0a16128a32aa274883c639054d37ccdc6937e39" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA-512 checksum.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA-512 체크섬을 계산하는 해시.</target>
        </trans-unit>
        <trans-unit id="cf1f289ea19766f37df0d90899ff5c24c8ae2c4a" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA1 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4fd916c9b4b6d94508616e145a5d3f06d397cd5d" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. SHA256 체크섬을 계산하는 해시. 해시는 또한 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f8209c7edf904061031f392b03dfd5924df101b5" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New는 새로운 해시를 반환합니다. Adler-32 체크섬을 계산하는 Hash32. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e84f60f6e65d95fd4ece96b0004a9de85df6b343" translate="yes" xml:space="preserve">
          <source>New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical.</source>
          <target state="translated">새로 작성은 주어진 텍스트로 형식화되는 오류를 리턴합니다. 텍스트가 동일하더라도 New를 호출 할 때마다 고유 한 오류 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d8951b361a0209c54ff9386028d34a39773602f" translate="yes" xml:space="preserve">
          <source>New returns an initialized list.</source>
          <target state="translated">New는 초기화 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5801fe069c8fe2aaa55fda0624f44928b4775b87" translate="yes" xml:space="preserve">
          <source>New uses JavaScript's &quot;new&quot; operator with value v as constructor and the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">New는 생성자와 주어진 인수로 값 v를 가진 JavaScript의 &quot;new&quot;연산자를 사용합니다. v가 JavaScript 함수가 아닌 경우 패닉 상태가됩니다. 인수는 ValueOf 함수에 따라 JavaScript 값에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="de47e55b8079b059389f17b105e9ffd1afb3a3e3" translate="yes" xml:space="preserve">
          <source>New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128은 새로운 128 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a8005a100f6b39010fda63d549052f17d08741bd" translate="yes" xml:space="preserve">
          <source>New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128a는 새로운 128 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="0ce753ca8c15a0a1b2e753ae81ad1104c1644498" translate="yes" xml:space="preserve">
          <source>New224 returns a new hash.Hash computing the SHA224 checksum.</source>
          <target state="translated">New224는 새 해시를 반환하고 SHA224 체크섬을 계산하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="ccc0f5023730b0e5ae85216a310b3047f4aa8ea2" translate="yes" xml:space="preserve">
          <source>New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32는 새로운 32 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="d56753001efd2485e723a8e5a73fff58d273b67c" translate="yes" xml:space="preserve">
          <source>New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32a는 새로운 32 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="7d5d99bcf25b2336b4de3cdadf8a35eaf7a0c199" translate="yes" xml:space="preserve">
          <source>New384 returns a new hash.Hash computing the SHA-384 checksum.</source>
          <target state="translated">New384는 새로운 해시를 반환하고 SHA-384 체크섬을 계산하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="4b7f283752df73a2e87a9802891e3f0dd0c8d4d7" translate="yes" xml:space="preserve">
          <source>New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.</source>
          <target state="translated">New512_224는 새 해시를 반환합니다. SHA-512 / 224 체크섬을 계산하는 해시</target>
        </trans-unit>
        <trans-unit id="825abc60343f43e649b2364900655dff3568736f" translate="yes" xml:space="preserve">
          <source>New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.</source>
          <target state="translated">New512_256은 새로운 해시를 반환합니다. SHA-512 / 256 체크섬을 계산하는 해시.</target>
        </trans-unit>
        <trans-unit id="d87077707d6ea0d456a51c30f664d7873c8bd355" translate="yes" xml:space="preserve">
          <source>New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64는 새로운 64 비트 FNV-1 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="46dd6ddaccb45d3f0be1865973ec33eaa9f63cd3" translate="yes" xml:space="preserve">
          <source>New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64a는 새로운 64 비트 FNV-1a 해시를 반환합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="7b22f1177470c7c4e87fe25b4cd79c1fd84c6501" translate="yes" xml:space="preserve">
          <source>NewAlpha returns a new Alpha image with the given bounds.</source>
          <target state="translated">NewAlpha는 주어진 범위를 가진 새로운 알파 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="add0bb0be61493133a58e39dd7700e6c9889401b" translate="yes" xml:space="preserve">
          <source>NewAlpha16 returns a new Alpha16 image with the given bounds.</source>
          <target state="translated">NewAlpha16은 주어진 범위를 가진 새로운 Alpha16 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c61d8963b5a530bd472131f346eba16878a4408" translate="yes" xml:space="preserve">
          <source>NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.</source>
          <target state="translated">NewArray는 주어진 요소 유형과 길이에 대해 새로운 배열 유형을 반환합니다. 음수 길이는 알 수없는 길이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="638c31aba3c5c6f8398df36fb530211241e94c4c" translate="yes" xml:space="preserve">
          <source>NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.</source>
          <target state="translated">NewAt는 p를 해당 포인터로 사용하여 지정된 형식의 값에 대한 포인터를 나타내는 Value를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72dec367b963904f8628c7bf12ee4335879a75b8" translate="yes" xml:space="preserve">
          <source>NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.</source>
          <target state="translated">NewBuffer는 buf를 초기 내용으로 사용하여 새로운 버퍼를 생성하고 초기화합니다. 새로운 버퍼는 buf의 소유권을 가지며 호출자는이 호출 후에 buf를 사용해서는 안됩니다. NewBuffer는 기존 데이터를 읽을 수있는 버퍼를 준비하기위한 것입니다. 또한 쓰기를위한 내부 버퍼의 초기 크기를 설정하는 데 사용될 수도 있습니다. 이를 위해 buf는 원하는 용량을 가져야하지만 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ed5f25f81fed45774081165b1641415b15da1746" translate="yes" xml:space="preserve">
          <source>NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.</source>
          <target state="translated">NewBufferString은 문자열 s를 초기 내용으로 사용하여 새 버퍼를 작성하고 초기화합니다. 기존 문자열을 읽을 수 있도록 버퍼를 준비하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="22844417cd1bd7e56381df290ad9aba37327ed60" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter</source>
          <target state="translated">NewCBCDecrypter</target>
        </trans-unit>
        <trans-unit id="ca52eb6c91f944ba65ea2ffb0b84fcc2a10abe90" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.</source>
          <target state="translated">NewCBCDecrypter는 주어진 블록을 사용하여 암호 블록 체인 모드에서 해독하는 BlockMode를 반환합니다. iv의 길이는 블록의 블록 크기와 같아야하며 데이터를 암호화하는 데 사용 된 iv와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="255e7115ae5f4d3fbd66659d8c19d19341701776" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter</source>
          <target state="translated">NewCBCEncrypter</target>
        </trans-unit>
        <trans-unit id="fa88ee5beeb923f46e28b0b6307e4efcac6244ff" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCBCEncrypter는 주어진 블록을 사용하여 암호 블록 체인 모드로 암호화하는 BlockMode를 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="38ff31a554e5558a01b8168178cf0796b7209a44" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter</source>
          <target state="translated">NewCFBDecrypter</target>
        </trans-unit>
        <trans-unit id="2d168991a51faf9df3fede3ceed6622acdae5d65" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBDecrypter는 주어진 블록을 사용하여 암호 피드백 모드로 해독하는 Stream을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="08b4648ba8de6f7a55002e90d7740de77aaee124" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter</source>
          <target state="translated">NewCFBEncrypter</target>
        </trans-unit>
        <trans-unit id="46ae2754dd56eaa723f258dcc13d30b6a837033a" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBEncrypter는 주어진 블록을 사용하여 암호 피드백 모드로 암호화하는 스트림을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="253cccaa3711561810055bfc51a9b95d2ac7b353" translate="yes" xml:space="preserve">
          <source>NewCMYK returns a new CMYK image with the given bounds.</source>
          <target state="translated">NewCMYK는 주어진 범위를 가진 새로운 CMYK 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f23a2508c9195bfe11e43b2f877a2121ff4896e8" translate="yes" xml:space="preserve">
          <source>NewCTR</source>
          <target state="translated">NewCTR</target>
        </trans-unit>
        <trans-unit id="48cf25f578fd7e4d9bde53a1056264acc0f6565d" translate="yes" xml:space="preserve">
          <source>NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCTR은 카운터 모드에서 지정된 블록을 사용하여 암호화 / 암호 해독하는 스트림을 반환합니다. iv의 길이는 블록의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="78b43a9ea76afd66f0e904c5af7000251dc2615e" translate="yes" xml:space="preserve">
          <source>NewCertPool returns a new, empty CertPool.</source>
          <target state="translated">NewCertPool은 비어있는 새 CertPool을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24df68fca6c4873d326ba2cccc1b01b5610f3e8e" translate="yes" xml:space="preserve">
          <source>NewChan returns a new channel type for the given direction and element type.</source>
          <target state="translated">NewChan은 주어진 방향과 요소 유형에 대한 새 채널 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62fa4bf0653f8c5396d1118a3de960d9396357d1" translate="yes" xml:space="preserve">
          <source>NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files.</source>
          <target state="translated">NewChecker는 주어진 패키지에 대한 새로운 Checker 인스턴스를 반환합니다. 패키지 파일은 checker.Files를 통해 점진적으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2380ca2f8a09151f6aa44494bd0336745a8e73ba" translate="yes" xml:space="preserve">
          <source>NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedReader가 필요하지 않습니다. http 패키지는 응답 본문을 읽을 때 청킹을 자동으로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f0cf338b02e3e48fa365cda270fb9dee555b3d17" translate="yes" xml:space="preserve">
          <source>NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP &quot;chunked&quot; format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.</source>
          <target state="translated">NewChunkedReader는 r에서 읽은 데이터를 HTTP &quot;chunked&quot;형식으로 변환하여 반환하기 전에 새로운 chunkedReader를 반환합니다. chunkedReader는 최종 0 길이 청크를 읽을 때 io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="349a471f1f7196f4cd28f8d83c309c02f591534f" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedWriter가 필요하지 않습니다. 핸들러가 Content-Length 헤더를 설정하지 않으면 http 패키지는 자동으로 청크를 추가합니다. 핸들러 내에서 NewChunkedWriter를 사용하면 Content-Length 길이의 이중 청크 또는 청크가 발생하며 둘 다 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="b746b9ef76b22845d6f63dc9d95e97e36a08dd5c" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">일반 응용 프로그램에는 NewChunkedWriter가 필요하지 않습니다. 핸들러가 Content-Length 헤더를 설정하지 않으면 http 패키지는 자동으로 청크를 추가합니다. 핸들러 내에서 newChunkedWriter를 사용하면 Content-Length 길이의 이중 청크 또는 청크가 발생하며 둘 다 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bbde3c49be540aed6f3b9a07213ce9f0f0985a47" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP &quot;chunked&quot; format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.</source>
          <target state="translated">NewChunkedWriter는 쓰기를 w에 쓰기 전에 HTTP &quot;청크&quot;형식으로 변환하는 새로운 chunkedWriter를 반환합니다. 반환 된 chunkedWriter를 닫으면 스트림의 끝을 표시하지만 트레일러 뒤에 나타나는 최종 CRLF를 보내지 않는 최종 길이가 0 인 청크를 보냅니다. 트레일러와 마지막 CRLF는 별도로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f92d63907abdded9ec398f437e0cf965d51343f" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다. 키 인수는 RC4 키 (최소 1 바이트, 최대 256 바이트) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8328cb0f867c2e756f382b0ca63e4950d8850883" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b22b2787fd6b2ed8659da500429f9fa3fe86072" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.</source>
          <target state="translated">NewCipher는 새로운 암호를 생성하고 반환합니다. AES-128, AES-192 또는 AES-256을 선택하려면 키 인수는 16, 24 또는 32 바이트 인 AES 키 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b860dfa2340445fd2cf308e5a3748fea60faee9b" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.</source>
          <target state="translated">NewClient는 연결의 다른 쪽 끝에서 요청을 처리하기 위해 새 클라이언트를 반환합니다. 연결의 쓰기 측에 버퍼를 추가하여 헤더와 페이로드가 단위로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b078c0d5ff1e636af20c5c0ed8dd22f85b7f4282" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating.</source>
          <target state="translated">NewClient는 인증시 사용할 기존 연결 및 호스트를 서버 이름으로 사용하여 새 클라이언트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8fb1181ae8a229864a05cfebb15c90112fff65c" translate="yes" xml:space="preserve">
          <source>NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection.</source>
          <target state="translated">NewClient는 연결의 다른 쪽 끝에있는 서비스 집합에 대한 요청을 처리하기 위해 새로운 rpc.Client를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="856bbb45168cae23811fbc886f1b4d3be27846fe" translate="yes" xml:space="preserve">
          <source>NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.</source>
          <target state="translated">NewClientCodec는 conn에서 JSON-RPC를 사용하여 새로운 rpc.ClientCodec를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7383a602fa795d357297b4de95d8575b00a78ab" translate="yes" xml:space="preserve">
          <source>NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewClientConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4aa403c83da74918792480724a9f264584f0a604" translate="yes" xml:space="preserve">
          <source>NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses.</source>
          <target state="translated">NewClientWithCodec는 NewClient와 유사하지만 지정된 코덱을 사용하여 요청을 인코딩하고 응답을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="413a5b89d02aeac4a6363a735de94f49289195bd" translate="yes" xml:space="preserve">
          <source>NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.</source>
          <target state="translated">NewCommentMap은 주석 목록의 주석 그룹을 node로 지정된 AST의 노드와 연관시켜 새 주석 맵을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9378822df6d0b7340f61509bcb85e6fd00318896" translate="yes" xml:space="preserve">
          <source>NewCommentMap tries to associate a comment group to the &quot;largest&quot; node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment.</source>
          <target state="translated">NewCommentMap은 주석 그룹을 가능한 &quot;가장 큰&quot;노드에 연결하려고 시도합니다. 예를 들어, 주석이 할당 후행 줄 주석 인 경우, 주석은 할당의 마지막 피연산자보다는 전체 할당과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="4fd7049b9f856641359b9b5ca0cbb7b1cd2c0fac" translate="yes" xml:space="preserve">
          <source>NewCond returns a new Cond with Locker l.</source>
          <target state="translated">NewCond는 Locker l이있는 새로운 Cond를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eee961cdebdc3886242b174d6b32a3a25041270b" translate="yes" xml:space="preserve">
          <source>NewConn returns a new Conn using conn for I/O.</source>
          <target state="translated">NewConn은 I / O에 conn을 사용하여 새 Conn을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f81c5ab59d9f6c3c64039d6d5945f0e9cc54b88d" translate="yes" xml:space="preserve">
          <source>NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewConst는 값이 val 인 새로운 상수를 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bdc96fab96f7e5d7b8628b8398bba38bf6580815" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new ascii85 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 ascii85 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="369f6e69c20c8e4d13528053c51cd1d3a61e68de" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base32 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 base32 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d864a240d883e7dc24b71e88a8d5c0c1948d801c" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base64 stream decoder.</source>
          <target state="translated">NewDecoder는 새로운 base64 스트림 디코더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="060a7de61a5514feea18b0489167470b12d0112a" translate="yes" xml:space="preserve">
          <source>NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering.</source>
          <target state="translated">NewDecoder는 r에서 새로운 XML 파서를 읽는다. r이 io.ByteReader를 구현하지 않으면 NewDecoder는 자체 버퍼링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="89572a28c9f62f14398327362d699001d2142b0d" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from r.</source>
          <target state="translated">NewDecoder는 r에서 읽는 새 디코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96af6984e1ed3c2ee798e01c4c02872b06029e89" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.</source>
          <target state="translated">NewDecoder는 io.Reader에서 읽는 새 디코더를 반환합니다. r이 io.ByteReader도 구현하지 않으면 bufio.Reader에 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="56f76b42c4fa44e21b83722e16f9a4c656264781" translate="yes" xml:space="preserve">
          <source>NewDecoder returns an io.Reader that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.</source>
          <target state="translated">NewDecoder는 r에서 16 진수 문자를 해독하는 io.Reader를 반환합니다. NewDecoder는 r에 짝수의 16 진 문자 만 포함 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="815c279b763f19acec3e56299892af2ccb9c6e0b" translate="yes" xml:space="preserve">
          <source>NewDecoder wraps an io.Reader interface around Decode.</source>
          <target state="translated">NewDecoder는 Decode 주위에 io.Reader 인터페이스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="415b5e5928dc67ca5917ce4d88ceda8c89e1b092" translate="yes" xml:space="preserve">
          <source>NewEncoder</source>
          <target state="translated">NewEncoder</target>
        </trans-unit>
        <trans-unit id="018ed3a7983059a17dab1b137a9844370d5a2b74" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.</source>
          <target state="translated">NewEncoder는 새로운 ascii85 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 인코딩 된 다음 w에 기록됩니다. Ascii85 인코딩은 32 비트 블록에서 작동합니다. 쓰기가 끝나면 호출자는 후행 부분 블록을 플러시하기 위해 반환 된 인코더를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="dd7f4a301864c468eb1cb40a57cdfbd02a050c05" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder는 새로운 base32 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 enc를 사용하여 인코딩 된 다음 w에 기록됩니다. Base32 인코딩은 5 바이트 블록으로 작동합니다. 쓰기가 끝나면 호출자는 반환 된 인코더를 닫아 부분적으로 작성된 블록을 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="44ee1dd433d92306638dd13e3127df94408d4089" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder는 새로운 base64 스트림 인코더를 반환합니다. 반환 된 기록기에 기록 된 데이터는 enc를 사용하여 인코딩 된 다음 w에 기록됩니다. Base64 인코딩은 4 바이트 블록으로 작동합니다. 쓰기가 끝나면 호출자는 반환 된 인코더를 닫아 부분적으로 작성된 블록을 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="d754a23d4130a807a013e53a62e7006beaa7e442" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that will transmit on the io.Writer.</source>
          <target state="translated">NewEncoder는 io.Writer에서 전송할 새 인코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d092172077c4670e0835be93cc4b418229db1d7a" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that writes to w.</source>
          <target state="translated">NewEncoder는 w에 쓰는 새 인코더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc807b2bebb618f92c16dd28d4ba73b4801ef86" translate="yes" xml:space="preserve">
          <source>NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.</source>
          <target state="translated">NewEncoder는 소문자 16 진 문자를 w에 쓰는 io.Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec3215d4f7a860c50c96d8ebe05c612fbb607223" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string.</source>
          <target state="translated">NewEncoding은 주어진 알파벳으로 정의 된 새로운 인코딩을 반환하며, 이는 32 바이트 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a225db48b3273b7eabd0d6e7950dc3ffe5785055" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that does not contain the padding character or CR / LF ('\r', '\n'). The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding.</source>
          <target state="translated">NewEncoding은 주어진 알파벳으로 정의 된 새로운 패딩 된 인코딩을 반환하며, 이는 패딩 문자 나 CR / LF ( '\ r', '\ n')를 포함하지 않는 64 바이트 문자열이어야합니다. 결과 인코딩은 기본 패딩 문자 ( '=')를 사용하며 WithPadding을 통해 변경하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3eb6effd2379105d96f5ae281be769ac968f9b4" translate="yes" xml:space="preserve">
          <source>NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFatFile은 범용 바이너리로 모든 Mach-O 이미지에 액세스하기위한 새로운 FatFile을 생성합니다. Mach-O 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d86df188426dbb1a1da9539d4f76b961b9e5801b" translate="yes" xml:space="preserve">
          <source>NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible.</source>
          <target state="translated">NewField는 구조체 필드를 나타내는 새 변수를 반환합니다. 임베드 된 필드의 경우 이름은 필드에 액세스 할 수있는 규정되지 않은 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fa49724aa2bb7b06a7e49b7b14c21627f72f66fe" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 리더에서 Mach-O 바이너리에 액세스하기위한 새 파일을 만듭니다. Mach-O 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c4cb0bcb5da3b7cb9c222f07d952f1deb79331f9" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a PE binary in an underlying reader.</source>
          <target state="translated">NewFile은 기본 리더에서 PE 바이너리에 액세스하기위한 새 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fb3c69eb6155088ad1b0a5da31e3f5031165ea55" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 판독기에서 Plan 9 바이너리에 액세스하기위한 새 파일을 작성합니다. Plan 9 바이너리는 ReaderAt의 0 위치에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="02c382510f60f7ac0e7f9dd332c2062d9f122bae" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile은 기본 리더에서 ELF 바이너리에 액세스하기위한 새 파일을 만듭니다. ELF 바이너리는 ReaderAt의 위치 0에서 시작될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7d78c4172dcb2fe6cfcff9bb7e67f44f614ee3" translate="yes" xml:space="preserve">
          <source>NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).</source>
          <target state="translated">NewFile은 주어진 파일 기술자와 이름을 가진 새로운 File을 반환합니다. fd가 유효한 파일 디스크립터가 아닌 경우 리턴 값은 nil입니다. Unix 시스템에서 파일 디스크립터가 비 블로킹 모드 인 경우 NewFile은 폴링 가능 파일 (SetDeadline 메소드가 작동하는 파일)을 리턴하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="146b2f1f1201d86650233642cb2b7d8638ac3e22" translate="yes" xml:space="preserve">
          <source>NewFileSet creates a new file set.</source>
          <target state="translated">NewFileSet은 새로운 파일 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="39ae9e749e1c008bbfaf63f08fa2bb4e930b56b2" translate="yes" xml:space="preserve">
          <source>NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.</source>
          <target state="translated">NewFileTransport는 제공된 FileSystem을 제공하는 새로운 RoundTripper를 반환합니다. 반환 된 RoundTripper는 들어오는 요청의 URL 호스트와 요청의 다른 대부분의 속성을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f495b9657d10d27f36446d430fd6f4942c405b7b" translate="yes" xml:space="preserve">
          <source>NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.</source>
          <target state="translated">NewFlagSet은 지정된 이름 및 오류 처리 속성으로 설정된 새로운 빈 플래그를 반환합니다. 이름이 비어 있지 않으면 기본 사용 메시지와 오류 메시지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1be2205981424ac6113bbac1c50ddc8e645067" translate="yes" xml:space="preserve">
          <source>NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.</source>
          <target state="translated">NewFloat는 정밀도 53과 반올림 모드 ToNearestEven을 사용하여 x로 설정된 새 Float를 할당하고 반환합니다. x가 NaN 인 경우 ErrNaN으로 NewFloat 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62cad2834cd366b48375257d77d59b7e9a0915c1" translate="yes" xml:space="preserve">
          <source>NewFunc returns a new function with the given signature, representing the function's type.</source>
          <target state="translated">NewFunc는 함수의 타입을 나타내는 주어진 서명을 가진 새로운 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ab1fbb5a4b914ad66a4cae1cb655fa076b9ba96" translate="yes" xml:space="preserve">
          <source>NewGCM (Decrypt)</source>
          <target state="translated">NewGCM (암호 해독)</target>
        </trans-unit>
        <trans-unit id="88779115714f813ff34a3c2fff6aef4d291f21ae" translate="yes" xml:space="preserve">
          <source>NewGCM (Encrypt)</source>
          <target state="translated">NewGCM (암호화)</target>
        </trans-unit>
        <trans-unit id="d8e7f4fd8eb6323a1d235af8804d7f84b6c49124" translate="yes" xml:space="preserve">
          <source>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.</source>
          <target state="translated">NewGCM은 표준 nonce 길이로 Galois Counter Mode로 래핑 된 지정된 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1973de63c4df3596c58655e33db1f26efd7af742" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length.</source>
          <target state="translated">NewGCMWithNonceSize는 지정된 길이의 nonces를 허용하는 Galois Counter Mode로 래핑 된 지정된 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c89798890939059366d5fe1d2975869f4976a143" translate="yes" xml:space="preserve">
          <source>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.</source>
          <target state="translated">NewGCMWithTagSize는 지정된 길이의 태그를 생성하는 Galois Counter Mode로 래핑 된 지정된 128 비트 블록 암호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="454b2fc86978be3ab7ad864f00d10ff49dc84b08" translate="yes" xml:space="preserve">
          <source>NewGray returns a new Gray image with the given bounds.</source>
          <target state="translated">NewGray는 주어진 범위를 가진 새로운 회색 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f20d3a865eb95651d9773b55020e283c7cda789" translate="yes" xml:space="preserve">
          <source>NewGray16 returns a new Gray16 image with the given bounds.</source>
          <target state="translated">NewGray16은 주어진 범위를 가진 새로운 Gray16 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7063568571cff8011c550348a1d249dbcd1b3164" translate="yes" xml:space="preserve">
          <source>NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">NewIEEE는 IEEE 다항식을 사용하여 CRC-32 체크섬을 계산하여 새 해시를 생성합니다. Sum 메소드는 값을 빅 엔디안 바이트 순서로 배치합니다. 반환 된 Hash32는 해시의 내부 상태를 마샬링하고 언 마샬링하기 위해 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4d0116b71b732a25476a4fce3bfdd9a186665b0a" translate="yes" xml:space="preserve">
          <source>NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser.</source>
          <target state="translated">NewIdent는 위치없이 새 식별자를 만듭니다. Go 구문 분석기 이외의 코드로 생성 된 AST에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1da620d7851b36eddceb2d1155bd10520ef1e3d" translate="yes" xml:space="preserve">
          <source>NewIdentifier returns a new IdentifierNode with the given identifier name.</source>
          <target state="translated">NewIdentifier는 주어진 식별자 이름으로 새로운 IdentifierNode를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="525b5936156155224309c259d63dc7a201bbb3b9" translate="yes" xml:space="preserve">
          <source>NewInt allocates and returns a new Int set to x.</source>
          <target state="translated">NewInt는 x로 설정된 새로운 Int를 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce33b2838258d1a7fb77fc3c2496c70b71309e0c" translate="yes" xml:space="preserve">
          <source>NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterface는 주어진 메소드와 임베디드 타입에 대해 새로운 (불완전한) 인터페이스를 반환합니다. 각 임베디드 유형에는 기본 유형의 인터페이스 유형이 있어야합니다. NewInterface는 제공된 메소드의 소유권을 가지며 누락 된 수신자를 설정하여 해당 유형을 수정할 수 있습니다. 인터페이스의 메소드 세트를 계산하려면 Complete를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1879314ab1ca85d9a540a3d842506cb8e3d5935" translate="yes" xml:space="preserve">
          <source>NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterfaceType은 주어진 메소드와 임베디드 타입에 대해 새로운 (불완전한) 인터페이스를 반환합니다. 각 임베디드 유형에는 기본 유형의 인터페이스 유형이 있어야합니다 (이 특성은 정의 된 유형에 대해 검증되지 않았으며, 설정중인 프로세스에 아직 유효한 기본 유형이없는 경우). NewInterfaceType은 제공된 메소드의 소유권을 가지며 누락 된 수신자를 설정하여 해당 유형을 수정할 수 있습니다. 인터페이스의 메소드 세트를 계산하려면 Complete를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="412fcf56e8322a2530a374f7516c3ab81d822a6e" translate="yes" xml:space="preserve">
          <source>NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not SeedSize. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">NewKeyFromSeed는 시드에서 개인 키를 계산합니다. len (seed)가 SeedSize가 아닌 경우 패닉 상태가됩니다. 이 기능은 RFC 8032와의 상호 운용성을 위해 제공됩니다. RFC 8032의 개인 키는이 패키지의 시드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7f204c9bcbc69e7346a4be4a91e71094cadba874" translate="yes" xml:space="preserve">
          <source>NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &amp;lt; 1, a default capacity is used instead.</source>
          <target state="translated">NewLRUClientSessionCache는 LRU 전략을 사용하는 지정된 용량으로 ClientSessionCache를 리턴합니다. 용량이 &amp;lt;1 인 경우 기본 용량이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e85de83deae1f6ea413617fafa918347032b364d" translate="yes" xml:space="preserve">
          <source>NewLabel returns a new label.</source>
          <target state="translated">NewLabel은 새 레이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c00322f2990498c11eaea48009e4263db8d2b147" translate="yes" xml:space="preserve">
          <source>NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment.</source>
          <target state="translated">NewLineTable은 인코딩 된 데이터에 해당하는 새로운 PC / 라인 테이블을 반환합니다. 텍스트는 해당 텍스트 세그먼트의 시작 주소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ee273ce2cc40669abe88f8cbd5b969c8b99cc1d8" translate="yes" xml:space="preserve">
          <source>NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">NewListener는 내부 리스너로부터 연결을 수락하고 각 연결을 서버와 랩핑하는 리스너를 작성합니다. 구성 구성은 0이 아니어야하며 하나 이상의 인증서를 포함하거나 GetCertificate를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8ae0fc1fd1b3795d43931c769132b8b76d67124" translate="yes" xml:space="preserve">
          <source>NewLogger creates a log.Logger whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to log.New to create the Logger.</source>
          <target state="translated">NewLogger는 syslog 기능과 심각도의 조합으로 지정된 우선 순위로 시스템 로그 서비스에 출력이 기록되는 log.Logger를 작성합니다. logFlag 인수는 log.New에 전달 된 플래그 집합으로 Logger를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c2cf8bf27d6896fb60a3c00c2f29046150140e53" translate="yes" xml:space="preserve">
          <source>NewMap returns a new map for the given key and element types.</source>
          <target state="translated">NewMap은 주어진 키 및 요소 유형에 대한 새 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02aaaae9f75a28f52b63beb3faa08f1c64a67962" translate="yes" xml:space="preserve">
          <source>NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.</source>
          <target state="translated">NewMethodSet은 주어진 유형 T에 대해 설정된 메소드를 반환합니다. 비어 있지 않은 경우에도 항상 넌이 아닌 메소드 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a80c96af1db7665cca4280156494ace76054fb6" translate="yes" xml:space="preserve">
          <source>NewNRGBA returns a new NRGBA image with the given bounds.</source>
          <target state="translated">NewNRGBA는 주어진 범위를 가진 새로운 NRGBA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91846ee562c7c231bc0d057ad08777b2cf971613" translate="yes" xml:space="preserve">
          <source>NewNRGBA64 returns a new NRGBA64 image with the given bounds.</source>
          <target state="translated">NewNRGBA64는 주어진 범위를 가진 새로운 NRGBA64 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="808f42c5f206bd7e6ba827599de3fbf867803134" translate="yes" xml:space="preserve">
          <source>NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.</source>
          <target state="translated">NewNYCbCrA는 주어진 범위와 서브 샘플 비율로 새로운 NYCbCrA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fd8ffb265de65f1861cce1196f85b25e1d6856a" translate="yes" xml:space="preserve">
          <source>NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named.</source>
          <target state="translated">NewNamed는 지정된 형식 이름, 기본 형식 및 관련 메서드에 대해 새로운 명명 된 형식을 반환합니다. 주어진 타입 이름 obj에 아직 타입이 없다면, 타입은 반환 된 명명 된 타입으로 설정됩니다. 기본 유형은 * Named가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="e782c15bb55a8ae8ebce9f874df5b1a0c46216d1" translate="yes" xml:space="preserve">
          <source>NewOFB</source>
          <target state="translated">NewOFB</target>
        </trans-unit>
        <trans-unit id="b57f2ce3c1f5586132093d982185af2e0ee68f6c" translate="yes" xml:space="preserve">
          <source>NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.</source>
          <target state="translated">NewOFB는 출력 피드백 모드에서 블록 암호 b를 사용하여 암호화하거나 해독하는 Stream을 반환합니다. 초기화 벡터 iv의 길이는 b의 블록 크기와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec79b70c4182bbf15d13c7ed9c2f93fc95d113e" translate="yes" xml:space="preserve">
          <source>NewObj creates a new object of a given kind and name.</source>
          <target state="translated">NewObj는 주어진 종류와 이름의 새 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36552f14153f539c86094444ec1ce5a1a1e5bd03" translate="yes" xml:space="preserve">
          <source>NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors.</source>
          <target state="translated">NewPackage는 파일 노드 세트에서 새 패키지 노드를 작성합니다. 파일 전체에서 확인되지 않은 식별자를 확인하고 그에 따라 각 파일의 확인되지 않은 목록을 업데이트합니다. 가져 오기가 아닌 가져 오기 및 유니버스 범위가 제공되면 패키지 파일에 선언되지 않은 식별자를 확인하는 데 사용됩니다. 남아있는 해결되지 않은 식별자는 선언되지 않은 것으로보고됩니다. 파일이 다른 패키지에 속하는 경우 하나의 패키지 이름이 선택되고 다른 패키지 이름을 가진 파일이보고 된 다음 무시됩니다. 결과는 패키지 노드와 scanner.ErrorList입니다 (오류가있는 경우).</target>
        </trans-unit>
        <trans-unit id="8b93023f444decd83a57effbd1356f40d43944cd" translate="yes" xml:space="preserve">
          <source>NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.</source>
          <target state="translated">NewPackage는 지정된 패키지 경로 및 이름에 대한 새 패키지를 반환합니다. 패키지가 완전하지 않으며 명시 적으로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7604882861f8171ac92bb5a0ff3402c04452837d" translate="yes" xml:space="preserve">
          <source>NewPaletted returns a new Paletted image with the given width, height and palette.</source>
          <target state="translated">NewPaletted는 주어진 너비, 높이 및 팔레트를 가진 새로운 Paletted 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8157edaefd4d8244aead4c748c2239a1e9cdf406" translate="yes" xml:space="preserve">
          <source>NewParam returns a new variable representing a function parameter.</source>
          <target state="translated">NewParam은 함수 매개 변수를 나타내는 새 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="760c953eeca5555c276ff2137d11f1ac464a3878" translate="yes" xml:space="preserve">
          <source>NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewPkgName은 가져온 패키지를 나타내는 새로운 PkgName 객체를 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7267fd8d7fb296d4d49d2c7f2fba8f9caa6a9909" translate="yes" xml:space="preserve">
          <source>NewPointer returns a new pointer type for the given element (base) type.</source>
          <target state="translated">NewPointer는 주어진 요소 (기본) 유형에 대한 새로운 포인터 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad8326fa0e1c2920bea4e6fdd7be9537d18c5951" translate="yes" xml:space="preserve">
          <source>NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.</source>
          <target state="translated">NewProfile은 주어진 이름으로 새 프로필을 만듭니다. 해당 이름의 프로필이 이미 존재하면 NewProfile이 패닉 상태가됩니다. 규칙은 '가져 오기 / 경로'를 사용하는 것입니다. 접두사를 사용하여 각 패키지에 대해 별도의 네임 스페이스를 만듭니다. pprof 데이터를 읽는 다양한 도구와의 호환성을 위해 프로파일 이름에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="7dee9fd54a2c7c0d2e2445231875724a5129fb2a" translate="yes" xml:space="preserve">
          <source>NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewProxyClientConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="7013b5c7630f0f9aff6a55861942f65a617ff634" translate="yes" xml:space="preserve">
          <source>NewRGBA returns a new RGBA image with the given bounds.</source>
          <target state="translated">NewRGBA는 주어진 범위를 가진 새로운 RGBA 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06634c84293e78aa59af4c55605513918ba019e7" translate="yes" xml:space="preserve">
          <source>NewRGBA64 returns a new RGBA64 image with the given bounds.</source>
          <target state="translated">NewRGBA64는 주어진 범위를 가진 새로운 RGBA64 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00d97e53207565a29c223d381563f8ace2580585" translate="yes" xml:space="preserve">
          <source>NewRat creates a new Rat with numerator a and denominator b.</source>
          <target state="translated">NewRat은 분자 a와 분모 b를 가진 새로운 쥐를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8b51e66ddf0c0bc242e2972b3ed47f8e19aa8aff" translate="yes" xml:space="preserve">
          <source>NewReadLogger returns a reader that behaves like r except that it logs (using log.Printf) each read to standard error, printing the prefix and the hexadecimal data read.</source>
          <target state="translated">NewReadLogger는 r과 같이 동작하는 리더를 반환합니다 (log.Printf를 사용하여) 각 읽기를 표준 오류에 기록하고 접두사와 16 진수 데이터를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4ddd20c3c7ab3b134b41334b4749254502eec73c" translate="yes" xml:space="preserve">
          <source>NewReadWriter allocates a new ReadWriter that dispatches to r and w.</source>
          <target state="translated">NewReadWriter는 r과 w에 디스패치하는 새로운 ReadWriter를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="abdd552b8a6a378c711658cbda39673b4658c843" translate="yes" xml:space="preserve">
          <source>NewReader</source>
          <target state="translated">NewReader</target>
        </trans-unit>
        <trans-unit id="656b7888dc8300d6258cc09514612ef897a06356" translate="yes" xml:space="preserve">
          <source>NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.</source>
          <target state="translated">NewReader는 새로운 ReadCloser를 만듭니다. 리턴 된 ReadCloser에서 읽기를 수행하고 r에서 데이터를 압축 해제합니다. r이 io.ByteReader를 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 완료되면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="03de0f94de657abcdcd727d93d1385934f4b4c2a" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading from r.</source>
          <target state="translated">NewReader는 r에서 새로운 Reader 판독 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9310cd05d389a1e08ddfb9e4317d864d066d18ff" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader는 지정된 리더를 읽는 새 리더를 만듭니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afded549345ec0238483e2ba55aa75ed2ded5bd" translate="yes" xml:space="preserve">
          <source>NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.</source>
          <target state="translated">NewReader는 새로운 io.ReadCloser를 만듭니다. 반환 된 io에서 읽습니다 .ReadCloser는 r에서 데이터를 읽고 압축 해제합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 읽기가 끝나면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다. 리터럴 코드에 사용되는 비트 수인 litWidth는 [2,8] 범위에 있어야하며 일반적으로 8이어야합니다. 압축하는 데 사용되는 litWidth와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="104785202390e0ba0e171f6e70831714a74466f6" translate="yes" xml:space="preserve">
          <source>NewReader creates a new multipart Reader reading from r using the given MIME boundary.</source>
          <target state="translated">NewReader는 주어진 MIME 경계를 사용하여 r에서 새로운 multipart Reader 판독 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c18de38552330a3ffd438fa2e288016ca23d0e4e" translate="yes" xml:space="preserve">
          <source>NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading.</source>
          <target state="translated">NewReader는 압축되지 않은 r 버전을 읽는 데 사용할 수있는 새로운 ReadCloser를 반환합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다. 읽기가 끝나면 ReadCloser에서 Close를 호출하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="36241ff4da2c1821f96dba25272112a2ddbe76ee" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from b.</source>
          <target state="translated">NewReader는 b에서 새로운 판독 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e007e6c23a0a667f419ff954033af0ca806b580" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes.</source>
          <target state="translated">NewReader는 r에서 새로운 판독 값을 반환합니다.이 판독 값은 주어진 크기를 바이트 단위로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0a237744e6cd622e08bcaadcb57e9896c2c1bd36" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r.</source>
          <target state="translated">NewReader는 r에서 새로운 Reader 판독 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8809e71360f0f480fd09d2bb6c73d758eb20bf24" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.</source>
          <target state="translated">NewReader는 s에서 읽은 새 Reader를 반환합니다. bytes.NewBufferString과 유사하지만보다 효율적이고 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4b591a6aa8b2fa42d203301d41858890dc4a8ba3" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader that reads from r.</source>
          <target state="translated">NewReader는 r에서 읽는 새 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c08939cbf0fe51e296c0a2ccf3a3311832697807" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader whose buffer has the default size.</source>
          <target state="translated">NewReader는 버퍼의 기본 크기를 가진 새로운 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab008cb6047aabfffe29520f5a1d9f6947d1bb37" translate="yes" xml:space="preserve">
          <source>NewReader returns a quoted-printable reader, decoding from r.</source>
          <target state="translated">NewReader는 r에서 디코딩 된 인용 인쇄 가능한 리더를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15423ba5dc90eb7ca320aa86b1e4769688d373ee" translate="yes" xml:space="preserve">
          <source>NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader는 r에서 bzip2 데이터를 압축 해제하는 io.Reader를 반환합니다. r이 io.ByteReader도 구현하지 않으면 압축 해제 기는 r에서 필요한 것보다 많은 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceca3110c418c227d4c22c9ca1803e30b1fbc6a9" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.</source>
          <target state="translated">NewReaderDict는 NewReader와 유사하지만 사전 설정 사전으로 리더를 초기화합니다. 리턴 된 Reader는 압축되지 않은 데이터 스트림이 이미 읽은 주어진 사전으로 시작된 것처럼 작동합니다. NewReaderDict는 일반적으로 NewWriterDict에 의해 압축 된 데이터를 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15dcb5ef9b327e52dad13c8a81c8c78369449efa" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.</source>
          <target state="translated">NewReaderDict는 NewReader와 비슷하지만 사전 사전을 사용합니다. 압축 된 데이터가이를 참조하지 않으면 NewReaderDict는 사전을 무시합니다. 압축 된 데이터가 다른 사전을 참조하면 NewReaderDict는 ErrDictionary를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62226d4a3a7ef180876e33ca9f9e3e5dd9d4d275" translate="yes" xml:space="preserve">
          <source>NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.</source>
          <target state="translated">NewReaderSize는 버퍼가 지정된 크기 이상인 새 Reader를 반환합니다. io.Reader 인수가 이미 충분히 큰 크기의 Reader 인 경우 기본 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a90b37d52d4387ba6d3b8a70e9b4fe0675a973d" translate="yes" xml:space="preserve">
          <source>NewRecorder returns an initialized ResponseRecorder.</source>
          <target state="translated">NewRecorder는 초기화 된 ResponseRecorder를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc38b91034f7148cfc66856688fcf7b15792b799" translate="yes" xml:space="preserve">
          <source>NewReplacer</source>
          <target state="translated">NewReplacer</target>
        </trans-unit>
        <trans-unit id="98fb98214a91e4f9ae6ab220237b228d86508a63" translate="yes" xml:space="preserve">
          <source>NewReplacer panics if given an odd number of arguments.</source>
          <target state="translated">홀수 개의 인수가 제공되면 NewReplacer 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2061a29533176cb14bbeea4aaacbdde390807809" translate="yes" xml:space="preserve">
          <source>NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order.</source>
          <target state="translated">NewReplacer는 기존의 새 문자열 쌍 목록에서 새 Replacer를 반환합니다. 대체는 일치하는 항목없이 대상 문자열에 나타나는 순서대로 수행됩니다. 이전 문자열 비교는 인수 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="06ae50f5cf1308acbe8676644fb3a80e68b35dfc" translate="yes" xml:space="preserve">
          <source>NewRequest panics on error for ease of use in testing, where a panic is acceptable.</source>
          <target state="translated">패닉이 허용되는 테스트에서 사용하기 쉽도록 오류에 대한 패닉을 새로 요청합니다.</target>
        </trans-unit>
        <trans-unit id="dbad5b531961f7dd8c542979ba9a9f6fb56fe9e3" translate="yes" xml:space="preserve">
          <source>NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing.</source>
          <target state="translated">NewRequest는 테스트를 위해 http.Handler로 전달하기에 적합한 새로운 수신 서버 요청을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c6d605363051e92ce514815fc8e9cdd4cb00b63" translate="yes" xml:space="preserve">
          <source>NewRequest wraps NewRequestWithContext using the background context.</source>
          <target state="translated">NewRequest는 백그라운드 컨텍스트를 사용하여 NewRequestWithContext를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="9035fed12b576aa1b44e2c5e5447b9c7c51d7382" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the NewRequest function in the net/http/httptest package, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.</source>
          <target state="translated">NewRequestWithContext는 Client.Do 또는 Transport.RoundTrip과 함께 사용하기에 적합한 Request를 반환합니다. 서버 핸들러 테스트에 사용할 요청을 작성하려면 net / http / httptest 패키지의 NewRequest 함수를 사용하거나 ReadRequest를 사용하거나 요청 필드를 수동으로 업데이트하십시오. 발신 클라이언트 요청의 경우 컨텍스트는 요청의 전체 수명과 응답을 제어합니다. 연결 확보, 요청 전송 및 응답 헤더 및 본문 읽기. 인바운드 요청과 아웃 바운드 요청 필드의 차이점에 대해서는 요청 유형 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c9af43cdfcafd0e3590f3e143e4db860b3e1b49" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a new Request given a method, URL, and optional body.</source>
          <target state="translated">NewRequestWithContext는 메소드, URL 및 선택적 본문이 지정된 새 요청을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6032a09b3acaf432867b7a2e2a1165faa7e1e7a1" translate="yes" xml:space="preserve">
          <source>NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.</source>
          <target state="translated">NewScanner는 r에서 읽을 새 스캐너를 반환합니다. 분할 기능은 기본적으로 ScanLines입니다.</target>
        </trans-unit>
        <trans-unit id="95df7c8275be1758c09804f6f255a61f60fde088" translate="yes" xml:space="preserve">
          <source>NewScope creates a new scope nested in the outer scope.</source>
          <target state="translated">NewScope는 외부 범위에 중첩 된 새 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="80fe301e9f5c51453bef4cd9884ae93f5be56853" translate="yes" xml:space="preserve">
          <source>NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.</source>
          <target state="translated">NewScope는 주어진 상위 범위에 포함 된 비어있는 새 범위를 반환합니다 (있는 경우). 주석은 디버깅 전용입니다.</target>
        </trans-unit>
        <trans-unit id="11c7ae4097aa2447e01ff30db2236f8b8bdd3d07" translate="yes" xml:space="preserve">
          <source>NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.</source>
          <target state="translated">NewSectionReader는 오프셋 오프에서 r부터 시작하여 n 바이트 후에 EOF로 중지되는 SectionReader를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="92cc00b8df6d155a718390d6b132a73074091695" translate="yes" xml:space="preserve">
          <source>NewServeMux allocates and returns a new ServeMux.</source>
          <target state="translated">NewServeMux는 새로운 ServeMux를 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4c25e90df416fbb8a0117d35fe5407fe24aa713" translate="yes" xml:space="preserve">
          <source>NewServer returns a new Server.</source>
          <target state="translated">NewServer는 새 서버를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="babde56071601a12e116397bafca814c40fa7cd4" translate="yes" xml:space="preserve">
          <source>NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewServer가 시작되고 새 서버를 반환합니다. 호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2a60c8cf74ea37683e9a87d1c42a435ef059ce9" translate="yes" xml:space="preserve">
          <source>NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.</source>
          <target state="translated">NewServerCodec는 conn에서 JSON-RPC를 사용하여 새로운 rpc.ServerCodec을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ce930cf303061e4c3d16d518dfb921dd3f19755" translate="yes" xml:space="preserve">
          <source>NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewServerConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="af189f332f7b93936d5df009ddc216614f2c215d" translate="yes" xml:space="preserve">
          <source>NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.</source>
          <target state="translated">NewSignature는 지정된 수신자, 매개 변수 및 결과에 대해 새 함수 유형을 리턴하며, 둘 중 하나는 nil 일 수 있습니다. variadic이 설정되어 있으면 함수는 variadic이고, 하나 이상의 매개 변수가 있어야하며 마지막 매개 변수는 이름이없는 슬라이스 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f456531de00193a99678056eea0c8fcdbfa6dfa5" translate="yes" xml:space="preserve">
          <source>NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is &quot;/base&quot; and the incoming request was for &quot;/dir&quot;, the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy.</source>
          <target state="translated">NewSingleHostReverseProxy는 URL을 대상에 제공된 체계, 호스트 및 기본 경로로 라우팅하는 새로운 ReverseProxy를 반환합니다. 대상의 경로가 &quot;/ base&quot;이고 수신 요청이 &quot;/ dir&quot;인 ​​경우 대상 요청은 / base / dir입니다. NewSingleHostReverseProxy는 호스트 헤더를 다시 쓰지 않습니다. 호스트 헤더를 다시 쓰려면 사용자 지정 디렉터 정책과 함께 ReverseProxy를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="881af40d9181550600eb2130180e0aa0b7ef4fc9" translate="yes" xml:space="preserve">
          <source>NewSlice returns a new slice type for the given element type.</source>
          <target state="translated">NewSlice는 주어진 요소 유형에 대해 새로운 슬라이스 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e721e99b1b2d7da11daa968d62a8bde773167ca1" translate="yes" xml:space="preserve">
          <source>NewSource returns a new pseudo-random Source seeded with the given value. Unlike the default Source used by top-level functions, this source is not safe for concurrent use by multiple goroutines.</source>
          <target state="translated">NewSource는 주어진 값으로 시드 된 새로운 의사 랜덤 소스를 반환합니다. 최상위 기능에서 사용하는 기본 소스와 달리이 소스는 여러 고 루틴이 동시에 사용하기에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2632cf950aa513ee1017bf4dcbadbfbcd59a77fb" translate="yes" xml:space="preserve">
          <source>NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.</source>
          <target state="translated">NewStruct는 주어진 필드와 해당 필드 태그가있는 새 구조체를 반환합니다. 인덱스 i가있는 필드에 태그가있는 경우 tags [i]는 해당 태그 여야하지만 len (tags)은 인덱스 i가 가장 큰 태그를 보유하는 데 필요한 길이만큼만있을 수 있습니다. 따라서 태그가있는 필드가 없으면 태그가 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103ea95c3f50f8126d8830a74f99ac0e3f79bcc5" translate="yes" xml:space="preserve">
          <source>NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.</source>
          <target state="translated">NewSyscallError는 지정된 시스템 호출 이름 및 오류 세부 사항을 가진 새 SyscallError를 오류로 리턴합니다. 편의상 err이 nil이면 NewSyscallError는 nil을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15af8e116827b7526d8d125b743d53ce97e9ccf0" translate="yes" xml:space="preserve">
          <source>NewTLSServer</source>
          <target state="translated">NewTLSServer</target>
        </trans-unit>
        <trans-unit id="ee9c0929ee87d66c85d071ce6743847eebd27e1d" translate="yes" xml:space="preserve">
          <source>NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewTLSServer는 TLS를 사용하여 새 서버를 시작하고 리턴합니다. 호출자가 종료되면 닫기를 호출하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="00d18b3ba661f69ed9cfe9015dd706b999fa00de" translate="yes" xml:space="preserve">
          <source>NewTable decodes the Go symbol table (the &quot;.gosymtab&quot; section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.</source>
          <target state="translated">NewTable은 이동 기호 표 (ELF의 &quot;.gosymtab&quot;섹션)를 디코딩하여 메모리 내 표현을 반환합니다. Go 1.3부터 ​​Go 심볼 테이블에는 더 이상 심볼 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3faf897ce3b4d9467485319643370fa9199652" translate="yes" xml:space="preserve">
          <source>NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.</source>
          <target state="translated">NewTask는 taskType 유형의 태스크 인스턴스를 작성하고 태스크를 전달하는 컨텍스트와 함께이를 리턴합니다. 입력 컨텍스트에 작업이 포함 된 경우 새 작업은 해당 하위 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b8fb5e998a5bfa39f457a0e00d00ff8fbdd42ef8" translate="yes" xml:space="preserve">
          <source>NewTicker</source>
          <target state="translated">NewTicker</target>
        </trans-unit>
        <trans-unit id="b035640e964a55296a2efb5506fa864ce9c9bfff" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="translated">NewTicker는 duration 인수로 지정된 기간으로 시간을 보내는 채널이 포함 된 새 티커를 반환합니다. 수신기를 느리게 만들기 위해 간격을 조정하거나 틱을 떨어 뜨립니다. 지속 시간 d는 0보다 커야합니다. 그렇지 않으면 NewTicker가 패닉 상태가됩니다. 관련 리소스를 해제하려면 티커를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="bf6547887c37f917a009906b59fe98e227a67450" translate="yes" xml:space="preserve">
          <source>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</source>
          <target state="translated">NewTimer는 최소한 지속 시간이 지난 후 채널에서 현재 시간을 보내는 새 타이머를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="09aa7464c6b6cfad4c77e4bd499188c3746a2702" translate="yes" xml:space="preserve">
          <source>NewTokenDecoder creates a new XML parser using an underlying token stream.</source>
          <target state="translated">NewTokenDecoder는 기본 토큰 스트림을 사용하여 새 XML 파서를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a23d472e6b06cb6e963edf429927add90a46a91" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher</source>
          <target state="translated">NewTripleDESCipher</target>
        </trans-unit>
        <trans-unit id="84af04213903c43ab9d1e733d66e68af85c238b7" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewTripleDESCipher는 새로운 암호를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f40b69134a3f0736deea2eaa2750678b0c5b55ae" translate="yes" xml:space="preserve">
          <source>NewTuple returns a new tuple for the given variables.</source>
          <target state="translated">NewTuple은 주어진 변수에 대한 새로운 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c765721cc8a5281c315a4053b16ddc74c0799a82" translate="yes" xml:space="preserve">
          <source>NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewTypeName은 지정된 유형을 나타내는 새 유형 이름을 반환합니다. 나머지 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fc82f99da3f381417b3f2ddf213f8678bc887a05" translate="yes" xml:space="preserve">
          <source>NewUnstartedServer returns a new Server but doesn't start it.</source>
          <target state="translated">NewUnstartedServer는 새 서버를 반환하지만 시작하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="077e4a879a7f7aeb3402f9e60fcfed25d2f462f1" translate="yes" xml:space="preserve">
          <source>NewVar returns a new variable. The arguments set the attributes found with all Objects.</source>
          <target state="translated">NewVar는 새 변수를 반환합니다. 인수는 모든 객체에서 찾은 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="931cae5ffd260d5017ab39bc76af1f4af39d3c45" translate="yes" xml:space="preserve">
          <source>NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written.</source>
          <target state="translated">NewWriteLogger는 각 쓰기를 표준 오류에 기록하고 (log.Printf를 사용하여) 기록 된 접두사와 16 진 데이터를 인쇄하는 것을 제외하고 w와 같이 작동하는 기록기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32dc084c221b7ac68250900d07e80ef98477176c" translate="yes" xml:space="preserve">
          <source>NewWriter</source>
          <target state="translated">NewWriter</target>
        </trans-unit>
        <trans-unit id="db406b8d211203f1503f7b49dc65e93e6c1d2ac9" translate="yes" xml:space="preserve">
          <source>NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function.</source>
          <target state="translated">NewWriter는 새 tabwriter.Writer를 할당하고 초기화합니다. 파라미터는 초기화 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb99a0a4fd37c15275e7565ffb0b13403d80a96e" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer writing to w.</source>
          <target state="translated">NewWriter는 w에 새 Writer를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3c66bbe4244d139551b9b86abb1f943bea6cca3c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.</source>
          <target state="translated">NewWriter는 새로운 작가를 만듭니다. 리턴 된 Writer에 대한 쓰기는 압축되어 w에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d237dd5c37ca4fbda972f04e6f597bc8e44916c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1&amp;lt;&amp;lt;litWidth.</source>
          <target state="translated">NewWriter는 새로운 io.WriteCloser를 만듭니다. 반환 된 io.WriteCloser에 기록하고 w에 기록합니다. 쓰기가 끝나면 WriteCloser에서 Close를 호출하는 것은 호출자의 책임입니다. 리터럴 코드에 사용할 비트 수인 litWidth는 [2,8] 범위에 있어야하며 일반적으로 8입니다. 입력 바이트는 1 &amp;lt;&amp;lt; litWidth보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="5d8c71239de18e81bb2408f6be3d174f8b53cc5b" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.</source>
          <target state="translated">NewWriter는 주어진 수준에서 데이터를 압축하는 새로운 Writer를 반환합니다. zlib에 이어 레벨의 범위는 1 (BestSpeed)에서 9 (BestCompression)입니다. 높은 수준은 일반적으로 느리게 실행되지만 더 많이 압축합니다. 레벨 0 (NoCompression)은 압축을 시도하지 않습니다. 필요한 DEFLATE 프레이밍 만 추가합니다. Level -1 (DefaultCompression)은 기본 압축 수준을 사용합니다. 레벨 -2 (HuffmanOnly)는 Huffman 압축 만 사용하므로 모든 유형의 입력에 대해 매우 빠른 압축을 제공하지만 상당한 압축 효율을 희생합니다.</target>
        </trans-unit>
        <trans-unit id="77a9ef9463dc28c378543b4ca1ab833768dcb916" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer that writes to w.</source>
          <target state="translated">NewWriter는 w에 쓰는 새 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ed1faccc6afb2894578d5ce15a1b66df2ed7562" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer whose buffer has the default size.</source>
          <target state="translated">NewWriter는 버퍼의 기본 크기가 새로운 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28df5b8c07e84a79a10bcd4ad1689f3c9f232d1d" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing a zip file to w.</source>
          <target state="translated">NewWriter는 zip 파일을 쓰는 새로운 Writer를 w에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15d873b5f31a0567bb2f33a96b73193d43330bbf" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing to w.</source>
          <target state="translated">NewWriter는 새로운 Writer writing을 w에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8553cec920a1bbc2b884d29ae54a45cdb28b9a7f" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w.</source>
          <target state="translated">NewWriter는 새로운 Writer를 반환합니다. 리턴 된 기록기에 대한 쓰기는 압축되어 w에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="41a8b4d0cc45c1f4744d9ed11afc5cc850ba9075" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new multipart Writer with a random boundary, writing to w.</source>
          <target state="translated">NewWriter는 w에 쓰는 임의의 경계를 가진 새로운 multipart Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba4df4f4844996231636be43db04ad5d9a575122" translate="yes" xml:space="preserve">
          <source>NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary.</source>
          <target state="translated">NewWriterDict는 NewWriter와 비슷하지만 사전 설정 사전을 사용하여 새 Writer를 초기화합니다. 리턴 된 Writer는 압축 된 출력을 생성하지 않고 사전이 작성된 것처럼 작동합니다. w에 기록 된 압축 데이터는 동일한 사전으로 초기화 된 Reader를 통해서만 압축 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66b95134ebabf02390f85e665bafa07e307f028" translate="yes" xml:space="preserve">
          <source>NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.</source>
          <target state="translated">NewWriterLevel은 NewWriter와 비슷하지만 DefaultCompression을 가정하는 대신 압축 수준을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2244762bcd986f7cb2bc9adec833aa8f04c34752" translate="yes" xml:space="preserve">
          <source>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.</source>
          <target state="translated">NewWriterLevelDict는 NewWriterLevel과 비슷하지만 압축 할 사전을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fba4df7d4f867ec10b6be90ace669ea6f21a1c64" translate="yes" xml:space="preserve">
          <source>NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.</source>
          <target state="translated">NewWriterSize는 버퍼가 지정된 크기 이상인 새 작성기를 반환합니다. io.Writer 인수가 이미 충분히 큰 크기의 Writer 인 경우 기본 Writer를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a8e1967a776dd6bc255e00e323e531b785051db" translate="yes" xml:space="preserve">
          <source>NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.</source>
          <target state="translated">NewYCbCr은 주어진 범위와 서브 샘플 비율로 새로운 YCbCr 이미지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24448d424137595a3746992f824b6edb3b30eda0" translate="yes" xml:space="preserve">
          <source>NewZipf returns a Zipf variate generator. The generator generates values k &amp;isin; [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s &amp;gt; 1 and v &amp;gt;= 1.</source>
          <target state="translated">NewZipf는 Zipf 변형 생성기를 반환합니다. 발생기는 P (k)가 (v + k) ** (-s)에 비례하도록 k &amp;isin; [0, imax] 값을 생성합니다. 요구 사항 : s&amp;gt; 1 및 v&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="7ce32fccbc1a59952ff2a17d5ecf204917f2f0f8" translate="yes" xml:space="preserve">
          <source>Newlines and commas may be included in a quoted-field</source>
          <target state="translated">줄 바꿈과 쉼표는 인용 필드에 포함될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="680ad9f662c74a9364f8a6a8275f58c7b8082fcd" translate="yes" xml:space="preserve">
          <source>Next advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic.</source>
          <target state="translated">다음으로 맵 반복기를 진행시키고 다른 항목이 있는지보고합니다. 반복자가 소진되면 false를 리턴합니다. 이후에 Key, Value 또는 Next를 호출하면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3886733d4cb9e8e0a30e9e159418bfd55e791d5" translate="yes" xml:space="preserve">
          <source>Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded.</source>
          <target state="translated">다음은 tar 아카이브의 다음 항목으로 진행합니다. Header.Size는 다음 파일에 대해 읽을 수있는 바이트 수를 결정합니다. 현재 파일에 남아있는 모든 데이터는 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4901308d5dc25a2990110e9739d7a18a2e5ad01b" translate="yes" xml:space="preserve">
          <source>Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases.</source>
          <target state="translated">다음은 스캔 방법으로 읽을 다음 결과 행을 준비합니다. 성공하면 true를 반환하고 다음 결과 행이 없거나 준비하는 동안 오류가 발생하면 false를 반환합니다. 두 경우를 구별하기 위해 Err을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b13fef4541a1e8d67cdfed20bd2375d09afaf54" translate="yes" xml:space="preserve">
          <source>Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position.</source>
          <target state="translated">다음은 다음 유니 코드 문자를 읽고 반환합니다. 소스의 끝에 EOF를 리턴합니다. nil이 아닌 경우 s.Error를 호출하여 읽기 오류를보고합니다. 그렇지 않으면 오류 메시지를 os.Stderr에 인쇄합니다. 다음은 스캐너 위치 필드를 업데이트하지 않습니다. 현재 위치를 얻으려면 Pos ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9300d09b7df4ad5d5720f19adfdc038ac61f1df" translate="yes" xml:space="preserve">
          <source>Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry.</source>
          <target state="translated">다음은 인코딩 된 항목 스트림에서 다음 항목을 읽습니다. 섹션의 끝에 도달하면 nil, nil을 리턴합니다. 현재 오프셋이 유효하지 않거나 오프셋의 데이터를 유효한 항목으로 디코딩 할 수없는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e6ab5cae4a8ae2aa846c67f99d971fa518e2e06" translate="yes" xml:space="preserve">
          <source>Next reports whether there are more iterations to execute.</source>
          <target state="translated">다음으로 실행할 반복이 더 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="93f915543eeb533b1a50713e83a0f24c2c27db55" translate="yes" xml:space="preserve">
          <source>Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.</source>
          <target state="translated">Next는 버퍼에서 다음 n 바이트를 포함하는 슬라이스를 반환하여 마치 바이트가 Read에 의해 반환 된 것처럼 버퍼를 진행시킵니다. 버퍼에 n 바이트 미만이 있으면 Next는 전체 버퍼를 반환합니다. 슬라이스는 다음에 읽기 또는 쓰기 메소드를 호출 할 때까지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c448db08820ee5a2da21a99a2f7ee9ecfecee2a6" translate="yes" xml:space="preserve">
          <source>Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).</source>
          <target state="translated">다음은 다음 발신자의 프레임 정보를 반환합니다. 더 이상 거짓이면 더 이상 발신자가 없습니다 (프레임 값이 유효 함).</target>
        </trans-unit>
        <trans-unit id="330b3e94c1faae753e446839e4e00b09aaa021f5" translate="yes" xml:space="preserve">
          <source>Next returns the next id for a request/response pair.</source>
          <target state="translated">다음은 요청 / 응답 쌍의 다음 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31070c09d9898d8d82df0861c7359cedd6d1bee8" translate="yes" xml:space="preserve">
          <source>Next returns the next list element or nil.</source>
          <target state="translated">다음은 다음 목록 요소 또는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="835c3bdc06b3af77ee23ce1cd0bc1f932319b6e0" translate="yes" xml:space="preserve">
          <source>Next returns the next ring element. r must not be empty.</source>
          <target state="translated">다음은 다음 링 요소를 반환합니다. r은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3515095d5db1d9b6b3020f18bccf17c7141a06e9" translate="yes" xml:space="preserve">
          <source>Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF.</source>
          <target state="translated">다음은이 행 테이블에서 * 항목을 다음 행으로 설정하고 다음 행으로 이동합니다. 더 이상 항목이없고 회선 테이블이 올바르게 종료되면 io.EOF를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="59243d78d75adcc23308fcf3c7522b53b0e48d6d" translate="yes" xml:space="preserve">
          <source>NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="translated">NextPart는 멀티 파트의 다음 파트 또는 오류를 반환합니다. 더 이상 부품이 없으면 오류 io.EOF가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe82d0a11eaa23908a02323edde641d4f84c09e" translate="yes" xml:space="preserve">
          <source>NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases.</source>
          <target state="translated">NextResultSet은 읽을 다음 결과 세트를 준비합니다. 추가 결과 세트가 있는지 여부를보고하거나 추가 결과 세트가 없거나 오류가 발생하면 false를보고합니다. 두 경우를 구별하기 위해 Err 방법을 참고해야합니다.</target>
        </trans-unit>
        <trans-unit id="98468e4766dcce0e39d3ad725e6449c114807ef7" translate="yes" xml:space="preserve">
          <source>Nextafter returns the next representable float64 value after x towards y.</source>
          <target state="translated">Nextafter는 x 다음에 y를 향한 다음 표현 가능한 float64 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="75d1da7ce66cd551626a0d105347dbf7bbebadb0" translate="yes" xml:space="preserve">
          <source>Nextafter32 returns the next representable float32 value after x towards y.</source>
          <target state="translated">Nextafter32는 x 다음에 y를 향한 다음 표현 가능한 float32 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f22ed1e707c4376c926b166081941a42b8018a27" translate="yes" xml:space="preserve">
          <source>Nil represents the predeclared value nil.</source>
          <target state="translated">Nil은 미리 선언 된 값 nil을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b09d67cac8107c868d3a3b7af77e77ea7720296" translate="yes" xml:space="preserve">
          <source>NilNode holds the special identifier 'nil' representing an untyped nil constant.</source>
          <target state="translated">NilNode는 형식화되지 않은 nil 상수를 나타내는 특수 식별자 'nil'을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b524d9a99adffa02a516e6aa0d4d13aac2897fdc" translate="yes" xml:space="preserve">
          <source>NoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set Request.Body to nil.</source>
          <target state="translated">NoBody는 바이트가없는 io.ReadCloser입니다. 읽기는 항상 EOF를 반환하고 닫기는 항상 nil을 반환합니다. 요청이 0 바이트임을 명시 적으로 알리기 위해 발신 클라이언트 요청에서 사용될 수 있습니다. 그러나 다른 방법은 Request.Body를 nil로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52ef1a3746a958c4a53a19c9d87395684668883e" translate="yes" xml:space="preserve">
          <source>NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)</source>
          <target state="translated">NoGoError는 가져 오기에서 빌드 가능한 Go 소스 파일이없는 디렉토리를 설명하기 위해 사용하는 오류입니다. (여전히 테스트 파일, 빌드 태그로 숨겨진 파일 등이 포함될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="14b0e62d6fc1422eb757516da0b18c46890cfc16" translate="yes" xml:space="preserve">
          <source>Node formats node in canonical gofmt style and writes the result to dst.</source>
          <target state="translated">노드는 표준 gofmt 스타일로 노드를 형식화하고 결과를 dst에 씁니다.</target>
        </trans-unit>
        <trans-unit id="da15215d50f0207cc3f3bf867716d8b653cbbf4d" translate="yes" xml:space="preserve">
          <source>NodeType identifies the type of a parse tree node.</source>
          <target state="translated">NodeType은 구문 분석 트리 노드의 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b2c069378b3bfe6ff1e505ef1691402f0b8b4e2b" translate="yes" xml:space="preserve">
          <source>Non-Go programs that call Go code</source>
          <target state="translated">Go 코드를 호출하는 비 Go 프로그램</target>
        </trans-unit>
        <trans-unit id="902b501103969363a75f55b1d4ea5e8e3aaa9ff5" translate="yes" xml:space="preserve">
          <source>Non-string values can be used in JavaScript contexts. If {{.}} is</source>
          <target state="translated">문자열이 아닌 값은 JavaScript 컨텍스트에서 사용할 수 있습니다. {{.}}이 (가)</target>
        </trans-unit>
        <trans-unit id="3d2c97b640a04b4cfaa42b436b4f88eedd1e3354" translate="yes" xml:space="preserve">
          <source>Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.</source>
          <target state="translated">Noop은 NOOP 명령을 서버로 보냅니다. 서버에 대한 연결이 올바른지 확인하는 것 외에는 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="85cca9a9c13590980a1e26da797767deb94d87fd" translate="yes" xml:space="preserve">
          <source>NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.</source>
          <target state="translated">NopCloser는 제공된 Reader r을 랩핑하지 않은 Close 메소드가없는 ReadCloser를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7bc360841341e5ff79e2d9db0ccaba1681a641e9" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64는 표준 정규 분포 (평균 = 0, stddev = 1)를 사용하여 -math.MaxFloat64에서 + math.MaxFloat64 범위의 정규 분포 float64를 반환합니다. 다른 정규 분포를 생성하기 위해 호출자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584a03e17a58b140265f4319a3b8d37d0b326573" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64는 기본 소스에서 표준 정규 분포 (평균 = 0, stddev = 1)를 사용하여 [-math.MaxFloat64, + math.MaxFloat64] 범위의 정규 분포 float64를 반환합니다. 다른 정규 분포를 생성하기 위해 호출자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ef8f27fb77f3e3923ae623df4ac9f719342330" translate="yes" xml:space="preserve">
          <source>Not all drivers and databases support OUTPUT value parameters.</source>
          <target state="translated">모든 드라이버와 데이터베이스가 OUTPUT 값 매개 변수를 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="28197ebc86a75fec0d20747340a0a7790f4e6e65" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.</source>
          <target state="translated">모든 방법이 모든 유형의 유형에 적용되는 것은 아닙니다. 제한 사항이있는 경우 각 방법에 대한 설명서에 명시되어 있습니다. 종류별 메서드를 호출하기 전에 Kind 메서드를 사용하여 종류를 확인하십시오. 이런 종류의 유형에 부적절한 메서드를 호출하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aebe464c9e025a8d065addc9b1418e295beb91ab" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.</source>
          <target state="translated">모든 방법이 모든 종류의 값에 적용되는 것은 아닙니다. 제한 사항이있는 경우 각 방법에 대한 설명서에 명시되어 있습니다. 종류별 메서드를 호출하기 전에 Kind 메서드를 사용하여 종류의 값을 찾으십시오. 이런 종류의 유형에 부적절한 메서드를 호출하면 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ad6482316efeb0367fac0cef294df9931657e21" translate="yes" xml:space="preserve">
          <source>Not sets z = ^x and returns z.</source>
          <target state="translated">z = ^ x를 설정하지 않고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7742382b9eb1d24a7003bcf20989045729354b55" translate="yes" xml:space="preserve">
          <source>NotFound replies to the request with an HTTP 404 not found error.</source>
          <target state="translated">NotFound는 HTTP 404를 찾을 수 없음 오류와 함께 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="d73243f8dff55155dc23697de39081a99659e339" translate="yes" xml:space="preserve">
          <source>NotFoundHandler</source>
          <target state="translated">NotFoundHandler</target>
        </trans-unit>
        <trans-unit id="4cb94eae88a4f55a499c64d3eb533d60d5f636a3" translate="yes" xml:space="preserve">
          <source>NotFoundHandler returns a simple request handler that replies to each request with a &amp;ldquo;404 page not found&amp;rdquo; reply.</source>
          <target state="translated">NotFoundHandler는 &quot;404 페이지를 찾을 수 없음&quot;응답으로 각 요청에 응답하는 간단한 요청 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fa1f72946015817c3defa6f9ca3e62b13a4cbe23" translate="yes" xml:space="preserve">
          <source>NotNilFilter returns true for field values that are not nil; it returns false otherwise.</source>
          <target state="translated">NotNilFilter는 nil이 아닌 필드 값에 대해 true를 리턴합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48697afd9134ab8c796d4134241a98bd8c0e1e0e" translate="yes" xml:space="preserve">
          <source>NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">NotNull은 nil 값을 허용하지 않고 다른 ValueConverter에 위임하여 ValueConverter를 구현하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ea5ffd3d5d924f61e0aab5c8328c4565de280e8f" translate="yes" xml:space="preserve">
          <source>Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).</source>
          <target state="translated">표기법 : 수신 메소드 매개 변수 (수신자 포함)는 API에서 일관성있게 이름을 지정하여 사용법을 명확하게합니다. 들어오는 피연산자의 이름은 일반적으로 x, y, a, b 등으로 지정되지만 z는 지정되지 않습니다. 결과를 지정하는 매개 변수의 이름은 z (일반적으로 수신자)입니다.</target>
        </trans-unit>
        <trans-unit id="08dfc0b4556c0a1e642330802e9a9fdabdeafde7" translate="yes" xml:space="preserve">
          <source>Note that *os.File implements the io.ReadSeeker interface.</source>
          <target state="translated">* os.File은 io.ReadSeeker 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c7438b24f5f10d8ed5111e3a3eeea38cdce805d1" translate="yes" xml:space="preserve">
          <source>Note that DWARF line tables only permit sequential, forward scans. Hence, in the worst case, this takes time linear in the size of the line table. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index of the line table.</source>
          <target state="translated">DWARF 라인 테이블은 순방향 순방향 스캔 만 허용합니다. 따라서 최악의 경우 라인 테이블의 크기에서 시간이 선형으로 걸립니다. 발신자가 빠른 PC 검색을 반복하려면 적절한 회선 테이블 색인을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d08c2aea787a35db90158742ee5e75a3c73282a4" translate="yes" xml:space="preserve">
          <source>Note that Dir will allow access to files and directories starting with a period, which could expose sensitive directories like a .git directory or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="translated">Dir은 마침표로 시작하는 파일 및 디렉토리에 대한 액세스를 허용하므로 .git 디렉토리와 같은 민감한 디렉토리 또는 .htpasswd와 같은 민감한 파일을 노출시킬 수 있습니다. 선행 기간이있는 파일을 제외하려면 서버에서 파일 / 디렉토리를 제거하거나 사용자 정의 FileSystem 구현을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="74976bc5278e7780a62cf9ceb79267a86a939300" translate="yes" xml:space="preserve">
          <source>Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.</source>
          <target state="translated">FIPS 186-3 섹션 4.6은 해시가 하위 그룹의 바이트 길이로 잘 리도록 지정합니다. 이 기능은 해당 잘림 자체를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbf97d3b36e492a77bf717cf84e9406daab3263a" translate="yes" xml:space="preserve">
          <source>Note that Init may call err if there is an error in the first character of the file.</source>
          <target state="translated">파일의 첫 문자에 오류가 있으면 Init에서 err을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0c39680eb9df4d26108a728fd58d66d7905a72" translate="yes" xml:space="preserve">
          <source>Note that LineContinuations are not allowed. JSStr(&quot;foo\\nbar&quot;) is fine, but JSStr(&quot;foo\\\nbar&quot;) is not.</source>
          <target state="translated">LineContinuations는 허용되지 않습니다. JSStr ( &quot;foo \\ nbar&quot;)는 좋지만 JSStr ( &quot;foo \\\ nbar&quot;)는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b706c905f9e49dd39547ae798a12e332969a754b" translate="yes" xml:space="preserve">
          <source>Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop.</source>
          <target state="translated">이 인터페이스의 Push 및 Pop은 패키지 힙 구현을 호출하기위한 것입니다. 힙에서 항목을 추가하고 제거하려면 heap.Push 및 heap.Pop을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57724cba67b0754543683d705a43db50bcf5c63d" translate="yes" xml:space="preserve">
          <source>Note that both conversions must appear in the same expression, with only the intervening arithmetic between them:</source>
          <target state="translated">두 변환은 모두 같은 식으로 나타나야하며 그 사이에 산술 연산 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="00d2f4b507ea636132af470ff7c66414d9db9755" translate="yes" xml:space="preserve">
          <source>Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example.</source>
          <target state="translated">카운터가 0 일 때 발생하는 양의 델타가있는 호출은 대기 전에 발생해야합니다. 음수가 델타 인 통화 또는 카운터가 0보다 클 때 시작하는 플러스 델타 인 통화는 언제든지 발생할 수 있습니다. 일반적으로 이것은 goroutine 또는 대기 할 다른 이벤트를 작성하는 명령문 전에 Add 호출이 실행되어야 함을 의미합니다. WaitGroup이 여러 개의 독립적 인 이벤트 세트를 기다리는 데 재사용되는 경우, 모든 이전 대기 호출이 리턴 된 후 새로운 추가 호출이 발생해야합니다. WaitGroup 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5455acc6a0156c4dfa920acddbd7ebf8cf932467" translate="yes" xml:space="preserve">
          <source>Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.</source>
          <target state="translated">Flush를 지원하는 ResponseWriter의 경우에도 클라이언트가 HTTP 프록시를 통해 연결된 경우 응답이 완료 될 때까지 버퍼링 된 데이터가 클라이언트에 도달하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c3bd0ea640e306f27d50ba34f2f7b783e999786" translate="yes" xml:space="preserve">
          <source>Note that formatting of Go source code changes over time, so tools relying on consistent formatting should execute a specific version of the gofmt binary instead of using this package. That way, the formatting will be stable, and the tools won't need to be recompiled each time gofmt changes.</source>
          <target state="translated">Go 소스 코드의 형식은 시간이 지남에 따라 변경되므로 일관된 형식을 사용하는 도구는이 패키지를 사용하는 대신 특정 버전의 gofmt 바이너리를 실행해야합니다. 이렇게하면 서식이 안정적이되고 변경 될 때마다 도구를 다시 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e22ab49cba234a39b62136e423150811ceaf9eb2" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still read (and discard) 1 byte from the connection.</source>
          <target state="translated">len (b) == 0 및 len (oob)&amp;gt; 0 인 경우이 함수는 여전히 연결에서 1 바이트를 읽고 버립니다.</target>
        </trans-unit>
        <trans-unit id="1c2f06f3a5255f8d8b8129f0755c03b6610969a5" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still write 1 byte to the connection.</source>
          <target state="translated">len (b) == 0이고 len (oob)&amp;gt; 0 인 경우이 함수는 여전히 연결에 1 바이트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="6530be365312a7c4f8e32cd5888520ad9f3f1f1d" translate="yes" xml:space="preserve">
          <source>Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This defeats the point of this function. Using at least a 16-byte key will protect against this attack.</source>
          <target state="translated">세션 키가 너무 작 으면 공격자가 무차별 공격을 할 수 있습니다. 그들이 그렇게 할 수 있다면, 임의의 값이 사용되었는지 (같은 암호문에 대해 다르기 때문에) 패딩이 올바른지 여부를 알 수 있습니다. 이것은이 기능의 요점을 무너 뜨립니다. 16 바이트 이상의 키를 사용하면이 공격으로부터 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344ecaa4cf851728d938597c41196d419ce8996a" translate="yes" xml:space="preserve">
          <source>Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address.</source>
          <target state="translated">이 문서에서 IP 주소를 IPv4 주소 또는 IPv6 주소라고하는 것은 바이트 슬라이스의 길이가 아니라 주소의 의미 적 속성입니다. 16 바이트 슬라이스는 여전히 IPv4 주소가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a249db9e2c9671edb18dbf9a7216586dc071e0a3" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs.</source>
          <target state="translated">채널 드레인과 새 타이머 만료 사이에 경쟁 조건이 있으므로 리셋의 반환 값을 올바르게 사용할 수 없습니다. 위에서 설명한대로 정지 또는 만료 된 채널에서 항상 리셋을 호출해야합니다. 리턴 값은 기존 프로그램과의 호환성을 유지하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="cbcbc6dbbe1cd946285db0917941f30791e5e34b" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert, below). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="translated">obj.Parent ()는 객체가 스코프에 삽입되어 있고 그 당시 이미 부모가있는 경우 반환 된 스코프와 다를 수 있습니다 (아래 삽입 참조). 이것은 범위가 객체를 내 보낸 패키지의 범위 인 도트 가져 오기 된 객체에만 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295b47a82aa942008478736d689df68628de7e25" translate="yes" xml:space="preserve">
          <source>Note that since a pattern ending in a slash names a rooted subtree, the pattern &quot;/&quot; matches all paths not matched by other registered patterns, not just the URL with Path == &quot;/&quot;.</source>
          <target state="translated">슬래시로 끝나는 패턴은 루트 하위 트리의 이름을 가지므로 &quot;/&quot;패턴은 Path == &quot;/&quot;인 URL뿐만 아니라 다른 등록 된 패턴과 일치하지 않는 모든 경로와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5f4e1f66b103f275a7a85fe240ec0793b18c4588" translate="yes" xml:space="preserve">
          <source>Note that the 'x' form is the one used by most other languages and libraries.</source>
          <target state="translated">'x'형식은 대부분의 다른 언어 및 라이브러리에서 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="62af18353b85ece5ad43a8e2791ac7b4ef16a2b9" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.</source>
          <target state="translated">Go == 연산자는 시간 순간뿐만 아니라 위치 및 단조로운 시계 판독 값을 비교합니다. 시간 값에 대한 동등성 테스트에 대한 설명은 시간 유형에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bc5465e665f7d6206122a236966d74814c47dbc" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.</source>
          <target state="translated">Go == 연산자는 시간 순간뿐만 아니라 위치 및 단조로운 시계 판독 값을 비교합니다. 따라서 UTC 또는 로컬 방법을 사용하여 달성 할 수있는 모든 위치에 동일한 위치가 설정되어 있고 단조로운 시계 판독 값이 제거되었음을 보장하지 않고는 시간 값을 맵 또는 데이터베이스 키로 사용해서는 안됩니다. t = t.Round (0) 설정. t.Equal은 사용 가능한 가장 정확한 비교를 사용하고 인수 중 하나에 만 단조로운 시계 판독 값이있는 경우를 올바르게 처리하므로 일반적으로 t.Equal (u)에서 t == u를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="f47d1736b65573bc0db0e46ddb437d8586c42dc1" translate="yes" xml:space="preserve">
          <source>Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.</source>
          <target state="translated">Go 런타임은 패닉 및 충돌에 대한 표준 오류에 기록합니다. Stderr를 닫으면 해당 메시지가 나중에 다른 파일로 이동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b94d521ccf655c50db2b1ef784ea75e16313781" translate="yes" xml:space="preserve">
          <source>Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use RawPath, an optional field which only gets set if the default encoding is different from Path.</source>
          <target state="translated">경로 필드는 디코딩 된 형식으로 저장됩니다. / % 47 % 6f % 2f는 / Go /가됩니다. 결과적으로 경로의 슬래시가 원시 URL에서 슬래시이고 어떤 것이 % 2f인지 알 수 없습니다. 이 구별은 거의 중요하지 않지만 코드가 기본 인코딩이 경로와 다른 경우에만 설정되는 선택적 필드 인 RawPath를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fb073049f21533864d69200a5feb9b782ae4382" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="translated">RFC822, RFC850 및 RFC1123 형식은 현지 시간에만 적용해야합니다. UTC 시간에 적용하면 시간대 약어로 &quot;UTC&quot;가 사용되지만 RFC를 엄격하게 말하면이 경우 &quot;GMT&quot;가 필요합니다. 일반적으로 해당 형식을 요구하는 서버의 경우 RFC1123 대신 RFC1123Z를 사용해야하며 새 프로토콜에는 RFC3339를 선호해야합니다. RFC3339, RFC822, RFC822Z, RFC1123 및 RFC1123Z는 형식화에 유용합니다. 구문 분석은 RFC에서 허용하는 모든 시간 형식을 허용하지 않습니다. RFC3339Nano 형식은 초 필드에서 후행 0을 제거하므로 일단 형식화되면 올바르게 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf45110f19f93211e34437dda6c947478fbddd92" translate="yes" xml:space="preserve">
          <source>Note that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org.</source>
          <target state="translated">이 패키지의 예제는 Unix 시스템을 가정합니다. Windows에서는 실행되지 않을 수 있으며 golang.org 및 godoc.org에서 사용하는 Go Playground에서는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cabbff14cb2952c80edb181213c130b459a02692" translate="yes" xml:space="preserve">
          <source>Note that the pointer must point into an allocated object, so it may not be nil.</source>
          <target state="translated">포인터는 할당 된 객체를 가리켜 야하므로 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee73d643f6fa22eddd036e602800c4d837e9ec70" translate="yes" xml:space="preserve">
          <source>Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.</source>
          <target state="translated">CGI를 사용한다는 것은 각 요청을 처리하기 위해 새로운 프로세스를 시작한다는 것을 의미합니다. 이는 일반적으로 장기 실행 서버를 사용하는 것보다 덜 효율적입니다. 이 패키지는 주로 기존 시스템과의 호환성을 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="e229bb3e45eb0475b8c930c1335cc5ff4dab911b" translate="yes" xml:space="preserve">
          <source>Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem.</source>
          <target state="translated">이 함수가 오류를 반환하는지 여부는 비밀 정보를 공개합니다. 공격자가이 기능을 반복적으로 실행하고 각 인스턴스가 오류를 반환했는지 여부를 알게되면 개인 키가있는 것처럼 서명을 해독하고 위조 할 수 있습니다. 이 문제를 해결하는 방법은 DecryptPKCS1v15SessionKey를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="916171d84342fed453d228a3166add2d096261bc" translate="yes" xml:space="preserve">
          <source>Note: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type.</source>
          <target state="translated">참고 : 형식 및 값을 계산하기 위해 Check를 실행하는 대신 Eval 및 CheckExpr을 사용해서는 안되며, 이러한 함수는식이 사용되는 컨텍스트 (예 : 할당)를 무시하므로 Check 이외에도 사용해야합니다. 따라서 최상위 수준의 형식화되지 않은 상수는 각 컨텍스트 별 형식이 아닌 형식화되지 않은 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd05f6d0d39a629d554e37dad544b0971bdc2e22" translate="yes" xml:space="preserve">
          <source>Note: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.</source>
          <target state="translated">참고 : Fscan 등은 반환 된 입력을지나 한 문자 (룬)를 읽을 수 있습니다. 이는 스캔 루틴을 호출하는 루프가 일부 입력을 건너 뛸 수 있음을 의미합니다. 일반적으로 입력 값 사이에 공백이없는 경우에만 문제가됩니다. Fscan에 제공된 판독기가 ReadRune을 구현하는 경우 해당 메소드를 사용하여 문자를 읽습니다. 리더가 UnreadRune도 구현하는 경우 해당 메소드는 문자를 저장하는 데 사용되며 연속적인 호출은 데이터를 잃지 않습니다. 해당 기능이없는 리더에 ReadRune 및 UnreadRune 메소드를 첨부하려면 bufio.NewReader를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2262c6082b97775886bda26c19137facc9855b36" translate="yes" xml:space="preserve">
          <source>Note: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding.</source>
          <target state="translated">참고 : gob는 영구적으로 저장할 수 있으므로 소프트웨어가 발전함에 따라 GobEncoder에서 사용하는 인코딩이 안정적으로 유지되도록하는 것이 좋습니다. 예를 들어 GobEncode가 인코딩에 버전 번호를 포함시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a1a8b94ea000b0ee13d1c73b1460cd401f581d14" translate="yes" xml:space="preserve">
          <source>Note: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues.</source>
          <target state="translated">참고 : 파일에 대한 최대 동시 작업 수는 OS 또는 시스템에 따라 제한 될 수 있습니다. 숫자는 높아야하지만이를 초과하면 성능이 저하되거나 다른 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e27a7e32b7a1bd280289613fd2ddd6c441487040" translate="yes" xml:space="preserve">
          <source>Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New.</source>
          <target state="translated">통지는 심각도가 LOG_NOTICE 인 메시지를 기록하며 심각도는 새로 작성에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6c03ee54ad3a51fc92a1d69943e99667847705b6" translate="yes" xml:space="preserve">
          <source>Notify</source>
          <target state="translated">Notify</target>
        </trans-unit>
        <trans-unit id="f32ad9d0db01cf6742ecb4a7f760ed9166d4e428" translate="yes" xml:space="preserve">
          <source>Notify (AllSignals)</source>
          <target state="translated">알림 (모든 신호)</target>
        </trans-unit>
        <trans-unit id="ec0a8c1ae8d23b04c5ac40659f605bd7d0769148" translate="yes" xml:space="preserve">
          <source>Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.</source>
          <target state="translated">알림은 패키지 신호가 들어오는 신호를 릴레이하도록합니다. c. 신호가 제공되지 않으면 들어오는 모든 신호가 c로 릴레이됩니다. 그렇지 않으면 제공된 신호 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1dd2e9632e1d54f09b183732b58f92622a16dfc8" translate="yes" xml:space="preserve">
          <source>Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.</source>
          <target state="translated">알림은 지정된 비동기 신호 세트에 대한 기본 동작을 비활성화하고 대신 하나 이상의 등록 된 채널을 통해 전달합니다. 특히 SIGHUP, SIGINT, SIGQUIT, SIGABRT 및 SIGTERM 신호에 적용됩니다. 작업 제어 신호 SIGTSTP, SIGTTIN 및 SIGTTOU에도 적용되며,이 경우 시스템 기본 동작이 발생하지 않습니다. SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING SISIGIZE SIGISR1, SIGUSR2, SIGPILD SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2 및 시스템에서 사용되는 모든 실시간 신호. 모든 시스템에서 이러한 신호를 모두 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a03da0ac3a6fe09e0b74b0584dcf52f14832da35" translate="yes" xml:space="preserve">
          <source>Now returns the current local time.</source>
          <target state="translated">이제 현재 현지 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12f30fd28d8fbc7bdfb188f1073bae8ad0c81a0a" translate="yes" xml:space="preserve">
          <source>NsPerOp returns the &quot;ns/op&quot; metric.</source>
          <target state="translated">NsPerOp는 &quot;ns / op&quot;메트릭을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3f04b0789ea5fe434b5bac945daef8d6c790ae0" translate="yes" xml:space="preserve">
          <source>NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.</source>
          <target state="translated">NsecToTimespec은 유닉스 시대 이후 많은 나노초를 가져와 해당 Timespec 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba97613a512663d90a9d8bf323b048ee6483da36" translate="yes" xml:space="preserve">
          <source>NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.</source>
          <target state="translated">NsecToTimeval은 Unix 시대 이후 많은 나노초를 가져와 해당 Timeval 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50a5fe209ccfd051610f95a63741ad7f7b729cb1" translate="yes" xml:space="preserve">
          <source>Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">Null은 nil 값을 허용하지만 다른 ValueConverter에 위임하여 ValueConverter를 구현하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="98cd8ff39a93a75c21d65e0a235ee463a7bbb829" translate="yes" xml:space="preserve">
          <source>Null returns the JavaScript value &quot;null&quot;.</source>
          <target state="translated">Null은 JavaScript 값 &quot;null&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f8b0f41b489cc3f5ce2776f939ca31dc0509085" translate="yes" xml:space="preserve">
          <source>NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullBool은 null 일 수있는 bool을 나타냅니다. NullBool은 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6792a3139e23717e375cad9a592c4bd259439184" translate="yes" xml:space="preserve">
          <source>NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.</source>
          <target state="translated">NullBytes는 DER로 인코딩 된 ASN.1 NULL 유형을 나타내는 바이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5f6d3dcfb1e3aa678952637bbe19fdc90b78b127" translate="yes" xml:space="preserve">
          <source>NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullFloat64는 null 일 수있는 float64를 나타냅니다. NullFloat64는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e472847699046a5829bc4e4e7c408ab93169a01" translate="yes" xml:space="preserve">
          <source>NullInt32 represents an int32 that may be null. NullInt32 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt32는 null 일 수있는 int32를 나타냅니다. NullInt32는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9129057ccbbeafcc9b65fe6615ea2dfe0d92de58" translate="yes" xml:space="preserve">
          <source>NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt64는 null 일 수있는 int64를 나타냅니다. NullInt64는 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0dce04dd9159fa0b0caa17ec78453211e1469bd" translate="yes" xml:space="preserve">
          <source>NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).</source>
          <target state="translated">NullRawValue는 태그가 ASN.1 NULL 유형 태그 (5)로 설정된 RawValue입니다.</target>
        </trans-unit>
        <trans-unit id="74f3d9e74fdee0a23974ea8f9c10c75b52420438" translate="yes" xml:space="preserve">
          <source>NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination:</source>
          <target state="translated">NullString은 null 일 수있는 문자열을 나타냅니다. NullString은 스캐너 인터페이스를 구현하여 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="764711d7b7a7e05fa628aa8a88164882909b5ea1" translate="yes" xml:space="preserve">
          <source>NullTime represents a time.Time that may be null. NullTime implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullTime은 시간을 나타내며 null 일 수 있습니다. NullTime은 스캐너 인터페이스를 구현하므로 NullString과 유사한 스캔 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04c9d785121ddad7627d64968a461809b36b14b" translate="yes" xml:space="preserve">
          <source>Nullable reports whether the column may be null. If a driver does not support this property ok will be false.</source>
          <target state="translated">널 입력 가능은 열이 널인지 여부를보고합니다. 드라이버가이 속성을 지원하지 않으면 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="b616503fdba110413e1c79f07f22ca93729b1af0" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; it may be &amp;lt;= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x.</source>
          <target state="translated">Num은 x의 분자를 반환합니다. &amp;lt;= 0 일 수 있습니다. 결과는 x의 분자에 대한 참조입니다. x에 새로운 값이 할당되면 변경 될 수 있습니다. 분자의 부호는 x의 부호에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="49dfb6250d5c5b7065edd1796c9ba60b2981b754" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x.</source>
          <target state="translated">Num은 x의 분자를 반환합니다. x는 Int, Float 또는 Unknown이어야합니다. x가 알 수없는 경우 또는 분수로 나타내기에는 너무 크거나 작은 경우 결과는 알 수 없습니다. 그렇지 않으면 결과는 x와 같은 부호를 가진 Int입니다.</target>
        </trans-unit>
        <trans-unit id="07e8e8142272a14853fc3d4225faf1955a80ec0e" translate="yes" xml:space="preserve">
          <source>NumCPU returns the number of logical CPUs usable by the current process.</source>
          <target state="translated">NumCPU는 현재 프로세스에서 사용할 수있는 논리 CPU 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bdcf0e9793febfba96be526d3f799da8d6c4599" translate="yes" xml:space="preserve">
          <source>NumCgoCall returns the number of cgo calls made by the current process.</source>
          <target state="translated">NumCgoCall은 현재 프로세스에서 수행 한 cgo 호출 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99d769aca95925934bfe7234523a8e266cfa3e86" translate="yes" xml:space="preserve">
          <source>NumChildren returns the number of scopes nested in s.</source>
          <target state="translated">NumChildren은에 중첩 된 범위 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f8d5fa9c98c840bdcabc50036c605aaa61914fa" translate="yes" xml:space="preserve">
          <source>NumEmbeddeds returns the number of embedded types in interface t.</source>
          <target state="translated">NumEmbeddeds는 인터페이스 t에 포함 된 유형의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48274f29256d93bd977745ada6c383a46661d04c" translate="yes" xml:space="preserve">
          <source>NumError</source>
          <target state="translated">NumError</target>
        </trans-unit>
        <trans-unit id="085f257e02817fe0403777855cdf9b9d714c7182" translate="yes" xml:space="preserve">
          <source>NumExplicitMethods returns the number of explicitly declared methods of interface t.</source>
          <target state="translated">NumExplicitMethods는 인터페이스 t의 명시 적으로 선언 된 메소드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc69c4938a12562dfc9db7decbe294fadc96a88a" translate="yes" xml:space="preserve">
          <source>NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.</source>
          <target state="translated">NumField는 struct v의 필드 수를 반환합니다. v의 Kind가 Struct가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37d55c8516ca892bb76b586c5b36e164d3bfee83" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of fields in the struct (including blank and embedded fields).</source>
          <target state="translated">NumFields는 구조체의 필드 수 (공백 및 포함 필드 포함)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67aa508431878c89dfc1facabaf28776d55930aa" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of parameters or struct fields represented by a FieldList.</source>
          <target state="translated">NumFields는 FieldList로 표시되는 매개 변수 또는 구조체 필드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="64877a16861b7f92b7b931c3dd32e6bffe105163" translate="yes" xml:space="preserve">
          <source>NumGoroutine returns the number of goroutines that currently exist.</source>
          <target state="translated">NumGoroutine은 현재 존재하는 고 루틴의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20f482d6f3d78d176b8cba126c2420b8ebb6a1e9" translate="yes" xml:space="preserve">
          <source>NumMethod returns the number of exported methods in the value's method set.</source>
          <target state="translated">NumMethod는 값의 메소드 세트에서 내 보낸 메소드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e16da0849c5c39aaf5008c6fb5c0acd6258e7143" translate="yes" xml:space="preserve">
          <source>NumMethods returns the number of explicit methods whose receiver is named type t.</source>
          <target state="translated">NumMethods는 수신자의 이름이 t 인 명시 적 메소드의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="efca93e8ccf5085b691b876b60dbb50f530aac0f" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t.</source>
          <target state="translated">NumMethods는 인터페이스 t의 총 메서드 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f56f8cd32be5e8eed5e5b31f9ccdc038bef949c9" translate="yes" xml:space="preserve">
          <source>NumSubexp returns the number of parenthesized subexpressions in this Regexp.</source>
          <target state="translated">NumSubexp는이 Regexp에서 괄호로 묶인 하위 표현식의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8bd18a7cf0e1d4bc6bca5d9c1e222116af743cd5" translate="yes" xml:space="preserve">
          <source>NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.</source>
          <target state="translated">NumberNode는 부호있는 또는 부호없는 정수, 부동 소수점 또는 복소수와 같은 숫자를 보유합니다. 값을 구문 분석하고 값을 나타낼 수있는 모든 유형으로 저장합니다. 이것은 소량의 코드에서 Go의 이상적인 상수의 동작을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="aebc8ea3b91ff7b79f4c3ee912e30d014d9c0e7c" translate="yes" xml:space="preserve">
          <source>Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.</source>
          <target state="translated">고정 크기 값을 읽고 쓰면 숫자가 변환됩니다. 고정 크기 값은 고정 크기 산술 유형 (bool, int8, uint8, int16, float32, complex64, ...)이거나 고정 크기 값만 포함하는 배열 또는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="514d0c82a993264caef98a3606fa7dc9d584da1d" translate="yes" xml:space="preserve">
          <source>Numbers fundamental to the encoding.</source>
          <target state="translated">인코딩에 필수적인 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">숫자 변환</target>
        </trans-unit>
        <trans-unit id="294de652150e65884a04c4fc22af8edbb1682a0b" translate="yes" xml:space="preserve">
          <source>Numeric time zone offsets format as follows:</source>
          <target state="translated">숫자 시간대 오프셋 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42abdd30b855d13cdf926751fede5f671a054974" translate="yes" xml:space="preserve">
          <source>OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.</source>
          <target state="translated">OAEP는 임의 오라클로 사용되는 해시 함수에 의해 매개 변수화됩니다. 지정된 메시지의 암호화 및 암호 해독에는 동일한 해시 함수를 사용해야하며 sha256.New ()는 합리적인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="7c5f4d9d83e4f742a8c6f7a878b2a58947298d00" translate="yes" xml:space="preserve">
          <source>OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.</source>
          <target state="translated">OAEPOptions는 crypto.Decrypter 인터페이스를 사용하여 옵션을 OAEP 암호 해독에 전달하기위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ad8427a11879cfd2d8db1b9e8e8f59a37957814e" translate="yes" xml:space="preserve">
          <source>OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)</source>
          <target state="translated">OCSPResponse는 TLS 서버에서 스테이플 된 OCSP 응답을 리턴합니다 (있는 경우). (클라이언트 연결에만 유효합니다.)</target>
        </trans-unit>
        <trans-unit id="e8520e97ccf3aeee86e1f8ac2f743514a534e58a" translate="yes" xml:space="preserve">
          <source>OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.</source>
          <target state="translated">OSABI는 Header.Ident [EI_OSABI] 및 Header.OSABI에 있습니다.</target>
        </trans-unit>
        <trans-unit id="68fe95dd58ed02ddd93208f0b1d291299be0c119" translate="yes" xml:space="preserve">
          <source>Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases.</source>
          <target state="translated">Obj는 xf로 표시된 객체를 반환합니다. 필드 선택에 * Var, 다른 모든 경우에 * Func</target>
        </trans-unit>
        <trans-unit id="9eb16182993cc59927b4da07ba021ca619da9eaa" translate="yes" xml:space="preserve">
          <source>Obj returns the type name for the named type t.</source>
          <target state="translated">Obj는 명명 된 유형 t의 유형 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea5997c7d13deb46517727f9e2dc50eb58fb0ac9" translate="yes" xml:space="preserve">
          <source>ObjKind describes what an object represents.</source>
          <target state="translated">ObjKind는 객체가 나타내는 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="148bd125b03ec79b1e809f1705cff50161dd08f8" translate="yes" xml:space="preserve">
          <source>ObjectOf returns the object denoted by the specified id, or nil if not found.</source>
          <target state="translated">ObjectOf는 지정된 ID로 표시된 객체를 반환하거나 찾지 못하면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="696fabf5d47e7927b31c4529cb32de76645f9e45" translate="yes" xml:space="preserve">
          <source>ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">ObjectString은 obj의 문자열 형식을 반환합니다. 한정자는 패키지 수준 개체의 인쇄를 제어하며 nil 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0a0f32e63d21edc60ea1562ca9a173b5386b67" translate="yes" xml:space="preserve">
          <source>Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\.</source>
          <target state="translated">비동기 신호 중 SIGHUP 신호는 프로그램이 제어 터미널을 잃을 때 전송됩니다. SIGINT 신호는 제어 터미널의 사용자가 인터럽트 문자를 누를 때 전송되며 기본적으로 ^ C (Control-C)입니다. SIGQUIT 신호는 제어 터미널의 사용자가 종료 문자를 누를 때 전송되며 기본적으로 ^ \ (Control-Backslash)입니다. 일반적으로 ^ C를 누르면 프로그램이 종료되고 ^ \를 누르면 스택 덤프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="65a759f4644d298e31d53fd1d1620c7a2eccb79e" translate="yes" xml:space="preserve">
          <source>Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset.</source>
          <target state="translated">오프셋은 주어진 파일 위치 p에 대한 오프셋을 반환합니다. p는 해당 파일에서 유효한 Pos 값이어야합니다. f. 오프셋 (f.Pos (offset)) == 오프셋.</target>
        </trans-unit>
        <trans-unit id="e668fecf796eebcf71860aea79f4acfd32998a26" translate="yes" xml:space="preserve">
          <source>Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant.</source>
          <target state="translated">Offsetof는 x로 표시되는 필드의 구조체 내에서 오프셋을 반환하며 이는 structValue.field 형식이어야합니다. 즉, 구조체의 시작과 필드의 시작 사이의 바이트 수를 반환합니다. Offsetof의 반환 값은 Go 상수입니다.</target>
        </trans-unit>
        <trans-unit id="0ac54daba3530c56c22c7ab5fd0f77563ce7acd3" translate="yes" xml:space="preserve">
          <source>Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Encode does not add these.</source>
          <target state="translated">종종 ascii85로 인코딩 된 데이터는 &amp;lt;~ 및 ~&amp;gt; 기호로 래핑됩니다. 인코딩은 이것을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23cc25224e88c84b965606d1525d366853ed4824" translate="yes" xml:space="preserve">
          <source>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented.</source>
          <target state="translated">AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 및 Solaris에서는 인터페이스의 MulticastAddrs 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1d045aa427adecabc2fe461f86a4e36227e3495" translate="yes" xml:space="preserve">
          <source>On ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="translated">ARM, x86-32 및 32 비트 MIPS에서 원자 적으로 액세스 된 64 비트 단어의 64 비트 정렬을 정렬하는 것은 호출자의 책임입니다. 변수 또는 할당 된 구조체, 배열 또는 슬라이스의 첫 번째 단어는 64 비트로 정렬 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d4a89f2d2e09c9cf23ea8b902790da4d5ff91d" translate="yes" xml:space="preserve">
          <source>On DragonFly BSD and OpenBSD, listening on the &quot;tcp&quot; and &quot;udp&quot; networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details.</source>
          <target state="translated">DragonFly BSD 및 OpenBSD에서 &quot;tcp&quot;및 &quot;udp&quot;네트워크를 수신하면 IPv4 및 IPv6 연결을 모두 수신 할 수 없습니다. 이는 IPv4 트래픽이 IPv6 소켓으로 라우팅되지 않기 때문입니다. 두 주소 계열을 모두 지원하려면 두 개의 별도 소켓이 필요합니다. 자세한 내용은 inet6 (4)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc2494255e41ee3a52e5ab617366af15ab263764" translate="yes" xml:space="preserve">
          <source>On JS and NaCl, methods and functions related to Interface are not implemented.</source>
          <target state="translated">JS 및 NaCl에서는 인터페이스와 관련된 메소드 및 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a22fcd32dddc8742d71eeb00fd66a97a307dec2b" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 IPConn 관련 메소드 및 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c330a67c6571f090abbe696684e69b144f23ffce" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 UnixConn 및 UnixListener와 관련된 메소드 및 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187bea53a3943264ca3ab448938a9eb5588890ad" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="translated">JS, NaCl 및 Plan 9에서는 syscall.RawConn의 Control, Read 및 Write 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8af01a3a36621e313c89de20d229f16557b6c642" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="translated">JS, NaCl 및 Windows에서는 TCPConn 및 TCPListener의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a3c87314e5ae7220ae61af7b9a4aaad742b9fa" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="translated">JS, NaCl 및 Windows에서는 FileConn, FileListener 및 FilePacketConn 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50eadbc0d323969884ecf9cc0009e49c34ea969b" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to UDPConn are not implemented.</source>
          <target state="translated">JS에서는 UDPConn과 관련된 메소드 및 함수가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1c684d38068da43548a6ff99a071652823f3627" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the CryptGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="translated">Linux 및 FreeBSD에서 Reader는 사용 가능한 경우 getrandom (2)을 사용하고, 그렇지 않은 경우 / dev / urandom을 사용합니다. OpenBSD에서 Reader는 getentropy (2)를 사용합니다. 다른 유닉스 계열 시스템에서는 Reader가 / dev / urandom에서 읽습니다. Windows 시스템에서 Reader는 CryptGenRandom API를 사용합니다. Wasm에서 Reader는 Web Crypto API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c8ff5cc97c5ee66d154a1695c234ed4080927ad5" translate="yes" xml:space="preserve">
          <source>On NaCl and Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="translated">NaCl 및 Plan 9에서는 UDPConn의 ReadMsgUDP 및 WriteMsgUDP 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87e667c5ede44ae5764673fc28b292659a0f5bd8" translate="yes" xml:space="preserve">
          <source>On NaCl, the ListenMulticastUDP function is not implemented.</source>
          <target state="translated">NaCl에서는 ListenMulticastUDP 기능이 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a330e696a92e2d53090bac7c262b179695141719" translate="yes" xml:space="preserve">
          <source>On POSIX systems Gid contains a decimal number representing the group ID.</source>
          <target state="translated">POSIX 시스템에서 Gid는 그룹 ID를 나타내는 10 진수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2703d3b45f73f82bdf72e3fead14e53678acde02" translate="yes" xml:space="preserve">
          <source>On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.</source>
          <target state="translated">플랜 9에서 신호의 유형은 syscall.Note이며 문자열입니다. syscall.Note로 Notify를 호출하면 해당 문자열이 메모로 게시 될 때 해당 값이 채널에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="4b29c33c1c929a09e8c06f8cea419c82c9628ed0" translate="yes" xml:space="preserve">
          <source>On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.</source>
          <target state="translated">계획 9에서는 모드의 권한 비트, ModeAppend, ModeExclusive 및 ModeTemporary가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8763fb392ab0ac0ea38c3b25946a7a1236134b7" translate="yes" xml:space="preserve">
          <source>On Plan 9, the resolver always accesses /net/cs and /net/dns.</source>
          <target state="translated">계획 9에서 확인자는 항상 / net / cs 및 / net / dns에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="a1fe82f792d7b21f9ebd6296c1d86e735f0892e1" translate="yes" xml:space="preserve">
          <source>On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName.</source>
          <target state="translated">Solaris에서는 논리 데이터 링크를 공유하는 논리 네트워크 인터페이스 중 하나를 리턴합니다. 더 정밀하게하려면 InterfaceByName을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d85518513a854a5111d381e48be350b2e36728b6" translate="yes" xml:space="preserve">
          <source>On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively.</source>
          <target state="translated">UNIX 시스템에서 SSL_CERT_FILE 및 SSL_CERT_DIR 환경 변수를 사용하여 SSL 인증서 파일 및 SSL 인증서 파일 디렉토리의 시스템 기본 위치를 각각 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88f58a825e10f84944f638859f6290d9816daa64" translate="yes" xml:space="preserve">
          <source>On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists.</source>
          <target state="translated">유닉스 시스템에서 FindProcess는 프로세스의 존재 여부에 관계없이 항상 주어진 pid에 대해 Process를 성공하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98e3b9345fcee9a653cd9ea250ff090f5fd5a0bd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.</source>
          <target state="translated">유닉스 시스템에서는 비어 있지 않으면 $ TMPDIR을, 그렇지 않으면 / tmp를 반환합니다. Windows에서는 GetTempPath를 사용하여 % TMP %, % TEMP %, % USERPROFILE % 또는 Windows 디렉토리에서 비어 있지 않은 첫 번째 값을 리턴합니다. 계획 9에서는 / tmp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a069a183e2963c2a249b77ad664c6a016ed84b52" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="translated">Unix 시스템에서는 비어 있지 않은 경우 &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CACHE_HOME을 반환 하고 그렇지 않으면 $ HOME / .cache를 반환합니다 . 다윈에서는 $ HOME / Library / Caches를 반환합니다. Windows에서는 % LocalAppData %를 리턴합니다. 계획 9에서는 $ home / lib / cache를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1807151e52b0b2b36b5236bbf2d0ef14a9ec1abc" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="translated">Unix 시스템에서는 비어 있지 않은 경우 &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html에&lt;/a&gt; 지정된대로 $ XDG_CONFIG_HOME을 반환 하고 그렇지 않으면 $ HOME / .config를 반환합니다 . Darwin에서는 $ HOME / Library / Application Support를 리턴합니다. Windows에서는 % AppData %를 리턴합니다. 계획 9에서는 $ home / lib를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2893f193d590bc3c2b7840d64034a29f26c7240a" translate="yes" xml:space="preserve">
          <source>On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.</source>
          <target state="translated">유닉스 시스템에서 리졸버는 이름을 확인하기위한 두 가지 옵션이 있습니다. /etc/resolv.conf에 나열된 서버로 직접 DNS 요청을 보내는 순수 Go 리졸버를 사용하거나 getaddrinfo 및 getnameinfo와 같은 C 라이브러리 루틴을 호출하는 cgo 기반 리졸버를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c7408069288e442b0e9334096b1f9423749a2cb" translate="yes" xml:space="preserve">
          <source>On Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.</source>
          <target state="translated">macOS를 포함한 Unix에서는 $ HOME 환경 변수를 반환합니다. Windows에서는 % USERPROFILE %을 리턴합니다. 계획 9에서는 $ home 환경 변수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c4d1d5958d138a86f133f67425aa5377e82d717" translate="yes" xml:space="preserve">
          <source>On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.</source>
          <target state="translated">Unix에서는 모드의 권한 비트, ModeSetuid, ModeSetgid 및 ModeSticky가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3748b447fc18cd33fa72cfd10ff7a8e4c810a41" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program.</source>
          <target state="translated">Unix 계열 시스템에서 StartCPUProfile은 기본적으로 -buildmode = c-archive 또는 -buildmode = c-shared로 빌드 된 Go 코드에 대해 작동하지 않습니다. StartCPUProfile은 SIGPROF 신호에 의존하지만 해당 신호는 Go에서 사용 된 것이 아닌 주 프로그램의 SIGPROF 신호 처리기 (있는 경우)로 전달됩니다. 작동 시키려면 syscall.SIGPROF에 대해 os / signal.Notify를 호출하십시오. 그러나 그렇게하면 기본 프로그램이 수행하는 프로파일 링이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c48a0935e355c448766738061267dd6c7374a5" translate="yes" xml:space="preserve">
          <source>On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause os.Interrupt to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.</source>
          <target state="translated">Windows에서 ^ C (Control-C) 또는 ^ BREAK (Control-Break)는 일반적으로 프로그램을 종료시킵니다. os.Interrupt에 대해 Notify를 호출하면 ^ C 또는 ^ BREAK로 인해 채널에서 os.Interrupt가 전송되고 프로그램이 종료되지 않습니다. Notify에 전달 된 모든 채널에서 Reset이 호출되거나 Stop이 호출되면 기본 동작이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="84cb9183f88acab7f0a3e8615676023c95cfe1f4" translate="yes" xml:space="preserve">
          <source>On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.</source>
          <target state="translated">Windows 또는 Plan 9에서 Chown은 항상 * PathError로 래핑 된 syscall.EWINDOWS 또는 EPLAN9 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5c6a1e271d70b402bf7e630854ac58bbcf34f9f" translate="yes" xml:space="preserve">
          <source>On Windows, MIME types are extracted from the registry.</source>
          <target state="translated">Windows에서는 MIME 유형이 레지스트리에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="5350be8357b453f05f4ce5a07cf3bf1dba9318a4" translate="yes" xml:space="preserve">
          <source>On Windows, escaping is disabled. Instead, '\\' is treated as path separator.</source>
          <target state="translated">Windows에서는 이스케이프가 비활성화되어 있습니다. 대신 '\\'는 경로 구분 기호로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="a41bed9c4201556ec574f1ac26f677457e930cdc" translate="yes" xml:space="preserve">
          <source>On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError.</source>
          <target state="translated">Windows에서는 항상 * PathError로 랩핑 된 syscall.EWINDOWS 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f31a978cb1a7e83893ce791c5aa32ff7ac495fa" translate="yes" xml:space="preserve">
          <source>On Windows, it returns -1.</source>
          <target state="translated">Windows에서는 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a02f4fe5f583e59f31f6cbc5e10b9216b10a0af" translate="yes" xml:space="preserve">
          <source>On Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative.</source>
          <target state="translated">Windows에서는 syscall.EWINDOWS를 리턴합니다. 가능한 대안은 os / user 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3a0f41f0df73942f4fecfe70a64ca015408110" translate="yes" xml:space="preserve">
          <source>On Windows, methods and functions related to UnixConn and UnixListener don't work for &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">Windows에서 &quot;unixgram&quot;및 &quot;unixpacket&quot;에는 UnixConn 및 UnixListener와 관련된 메소드 및 기능이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd2981a73df24a936314bf6d1873afd69dc8adde" translate="yes" xml:space="preserve">
          <source>On Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.</source>
          <target state="translated">Windows에서는 0200 비트 (소유자 쓰기 가능) 모드 만 사용됩니다. 파일의 읽기 전용 속성 설정 여부를 제어합니다. 다른 비트는 현재 사용되지 않습니다. Go 1.12 및 이전 버전과의 호환성을 위해 0이 아닌 모드를 사용하십시오. 읽기 전용 파일에는 모드 0400을 사용하고 읽기 가능하고 쓰기 가능한 파일에는 0600을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2612d030cdd95b20b0743477158be3874169bfe3" translate="yes" xml:space="preserve">
          <source>On Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty.</source>
          <target state="translated">Windows에서 프로세스는 전체 명령 행을 단일 문자열로 수신하고 자체 구문 분석을 수행합니다. Command는 CommandLineToArgvW (가장 일반적인 방법)를 사용하는 응용 프로그램과 호환되는 알고리즘을 사용하여 Args를 명령 줄 문자열로 결합하고 인용합니다. 주목할만한 예외는 인용 부호 매김 알고리즘이 다른 msiexec.exe 및 cmd.exe (및 모든 배치 파일)입니다. 이러한 경우 또는 다른 유사한 경우 직접 인용을하고 SysProcAttr.CmdLine에 전체 명령 줄을 제공하고 Args는 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0058230d55ce789eb5612e2b93e4da6eea793a83" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of IPConn is not implemented.</source>
          <target state="translated">Windows에서는 IPConn의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d755b555a5935f43a3d90e65b76056dcf10027ed" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of UDPConn is not implemented.</source>
          <target state="translated">Windows에서는 UDPConn의 File 메소드가 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f31f810d1a4482b639a8bee446be568ce053ee4a" translate="yes" xml:space="preserve">
          <source>On Windows, the Write method of syscall.RawConn does not integrate with the runtime's network poller. It cannot wait for the connection to become writeable, and does not respect deadlines. If the user-provided callback returns false, the Write method will fail immediately.</source>
          <target state="translated">Windows에서 syscall.RawConn의 Write 메소드는 런타임의 네트워크 폴러와 통합되지 않습니다. 연결이 쓰기 가능할 때까지 기다릴 수 없으며 마감 기한을 지키지 않습니다. 사용자 제공 콜백이 false를 반환하면 Write 메서드가 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8b8fbd99e87c243a50d7f3fe8f96df26bcf452aa" translate="yes" xml:space="preserve">
          <source>On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.</source>
          <target state="translated">Windows에서 리졸버는 항상 GetAddrInfo 및 DnsQuery와 같은 C 라이브러리 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf70d5852ec76636f3807a9db0f77a9465a35084" translate="yes" xml:space="preserve">
          <source>On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.</source>
          <target state="translated">모든 플랫폼에서 Go to C에서 Go 로의 호출이 스택 추적을 요청할 때 역 추적 기능이 호출됩니다. linux / amd64, linux / ppc64le 및 freebsd / amd64에서 cgo 호출을 실행중인 스레드가 신호를 수신하면 역 추적 기능도 호출됩니다. 향후 버전의 Go에서 추가 호출을 수행 할 수 있으므로 역 추적 기능은 호출 시점에 대해 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6c40e8d8a1cb9c0f6c9d4c03dcd550161059582" translate="yes" xml:space="preserve">
          <source>On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as &quot;writev&quot;).</source>
          <target state="translated">특정 컴퓨터에서 특정 유형의 연결에 대해 OS 별 배치 쓰기 작업 (예 : &quot;writev&quot;)에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77b73816658f653733e14c2986094f012e8e513" translate="yes" xml:space="preserve">
          <source>On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed.</source>
          <target state="translated">오류가 발생하면 모든 응답을 무시할 수 있습니다. nil이 아닌 오류가있는 nil이 아닌 응답은 CheckRedirect가 실패한 경우에만 발생하며 반환 된 Response.Body가 이미 닫혀있는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13e02db1965a04d36b6a5db4b5d676787f23298f" translate="yes" xml:space="preserve">
          <source>On every POSIX platform, reads from the &quot;ip4&quot; network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet.</source>
          <target state="translated">모든 POSIX 플랫폼에서 사용 가능한 공간이 있어도 ReadFrom 또는 ReadFromIP 메소드를 사용하여 &quot;ip4&quot;네트워크에서 읽기는 헤더를 포함한 전체 IPv4 패킷을 반환하지 않을 수 있습니다. Read 또는 ReadMsgIP가 완전한 패킷을 반환 할 수있는 경우에도 발생할 수 있습니다. 따라서 전체 패킷을받는 것이 중요한 경우 이러한 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3c23c9c1e399b461c8c28a7144948fd27bdb61bb" translate="yes" xml:space="preserve">
          <source>On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function.</source>
          <target state="translated">많은 Linux 시스템에서 /etc/ssl/cert.pem은이 기능에 적합한 형식으로 시스템 전체 루트 CA 세트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ca1a155daae24035a913fb63720c32b8136a4b91" translate="yes" xml:space="preserve">
          <source>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.</source>
          <target state="translated">Linux 이외의 ARM에서 64 비트 함수는 ARMv6k 코어 이전에는 사용할 수없는 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1357e885cae46582ed3a6ff4521cb427fb02bd90" translate="yes" xml:space="preserve">
          <source>On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.</source>
          <target state="translated">일부 시스템에서는 컴퓨터가 절전 모드로 전환되면 단조로운 시계가 중지됩니다. 이러한 시스템에서 t.Sub (u)는 t와 u 사이를 통과 한 실제 시간을 정확하게 반영하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c05351e7478785f8f137c02ebcef5c050b614d" translate="yes" xml:space="preserve">
          <source>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</source>
          <target state="translated">반면, 수명이 짧은 개체의 일부로 유지 관리되는 사용 가능 목록은 해당 시나리오에서 오버 헤드가 잘 상각되지 않기 때문에 풀에 적합하지 않습니다. 이러한 객체가 자체 자유 목록을 구현하도록하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="389950f4460ec73a72ec78dde5ba3b73d32c35ab" translate="yes" xml:space="preserve">
          <source>On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="translated">x86-32에서 64 비트 기능은 Pentium MMX 이전에는 사용할 수없는 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="d104fb961a8c78122b2f62dee3ef43757b182f86" translate="yes" xml:space="preserve">
          <source>Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.</source>
          <target state="translated">서버에서 시스템 종료가 호출되면 재사용되지 않을 수 있습니다. 나중에 Serve와 같은 메소드를 호출하면 ErrServerClosed가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="843e914dc9185fa382b5f053202ed67b742aeba3" translate="yes" xml:space="preserve">
          <source>Once f returns and err is nil, the Conn will continue to be usable until Conn.Close is called.</source>
          <target state="translated">f가 반환되고 err이 nil이면 Conn.Close가 호출 될 때까지 Conn을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c1d5279ebafd6b3423844bd2276728e8cc52fbd" translate="yes" xml:space="preserve">
          <source>Once is an object that will perform exactly one action.</source>
          <target state="translated">한 번만 정확히 하나의 동작을 수행하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="7227e9a075a44764452a578989f4cc83bbee577f" translate="yes" xml:space="preserve">
          <source>Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">구문 분석 된 후에는 병렬 실행이 라이터를 공유하는 경우 출력이 인터리브 될 수 있지만 템플릿은 병렬로 안전하게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0281f78c03be67c1f2a3acafcdaa61c0cdc49c86" translate="yes" xml:space="preserve">
          <source>One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command</source>
          <target state="translated">하나 또는 두 개의 빼기 부호가 사용될 수 있습니다. 그것들은 동등합니다. 명령의 의미 때문에 마지막 형식은 부울 플래그에 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69577389d4c08755d52755f4e17faf59267dd621" translate="yes" xml:space="preserve">
          <source>OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.</source>
          <target state="translated">OneByteReader는 r에서 1 바이트를 읽음으로써 비어 있지 않은 각 Read를 구현하는 Reader를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99aaec6fa8f2d0bdb9045bd117dd6c71497e9a74" translate="yes" xml:space="preserve">
          <source>OnesCount</source>
          <target state="translated">OnesCount</target>
        </trans-unit>
        <trans-unit id="433a6ff8b314e9c198548ae00ba6fcecd1eee098" translate="yes" xml:space="preserve">
          <source>OnesCount returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c380e0ef7643051dda1d040515dc580f28605550" translate="yes" xml:space="preserve">
          <source>OnesCount16</source>
          <target state="translated">OnesCount16</target>
        </trans-unit>
        <trans-unit id="0999fcac9097d75e1573b11d0ffd816e52cf5855" translate="yes" xml:space="preserve">
          <source>OnesCount16 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount16은 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11a58244491d18b07e203d19e0549197d7478647" translate="yes" xml:space="preserve">
          <source>OnesCount32</source>
          <target state="translated">OnesCount32</target>
        </trans-unit>
        <trans-unit id="5f0db4433d3c95e463c6c2a1eadf16ccd1d19ea6" translate="yes" xml:space="preserve">
          <source>OnesCount32 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount32는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8bf5b0787d28b51c08417f12183c3a8050bbddf" translate="yes" xml:space="preserve">
          <source>OnesCount64</source>
          <target state="translated">OnesCount64</target>
        </trans-unit>
        <trans-unit id="f4aecef923e1b31d46e0ebe7b85940e72b4c07f4" translate="yes" xml:space="preserve">
          <source>OnesCount64 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount64는 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d82a2ce39ad5e48e37815f9f28a1215fe50fea08" translate="yes" xml:space="preserve">
          <source>OnesCount8</source>
          <target state="translated">OnesCount8</target>
        </trans-unit>
        <trans-unit id="cb4e53f8fd7e82903aefdeda2e2114c5812e0d65" translate="yes" xml:space="preserve">
          <source>OnesCount8 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount8은 x에서 1 비트 수 ( &quot;인구 수&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2a07178400736bcb7be81ae2feca4dcd008d7f5" translate="yes" xml:space="preserve">
          <source>Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:</source>
          <target state="translated">이러한 기준을 만족하는 방법 만 원격 액세스에 사용할 수 있습니다. 다른 방법은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f19caf46e787ec1b99d851f024d8d32d31c130ae" translate="yes" xml:space="preserve">
          <source>Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.</source>
          <target state="translated">한 번의 전화 걸기 만하면됩니다. 쓰기 실패시 syslog 클라이언트는 서버에 다시 연결을 시도하고 다시 쓰려고합니다.</target>
        </trans-unit>
        <trans-unit id="0bb2640773cf0b724d4c0f4b422833704c7b1dde" translate="yes" xml:space="preserve">
          <source>Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do.</source>
          <target state="translated">마감일 설정을 지원하는 파일 종류는 일부입니다. 마감일을 지원하지 않는 파일에 대해 SetDeadline을 호출하면 ErrNoDeadline이 반환됩니다. 대부분의 시스템에서 일반 파일은 마감일을 지원하지 않지만 파이프는 마감일을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1f2bc4d6c6973cdf7add1d2aa0d072a9bc333db3" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use NewGCM, which is faster and more resistant to misuse.</source>
          <target state="translated">비표준 nonce 길이를 사용하는 기존 암호화 시스템과의 호환성이 필요한 경우에만이 기능을 사용하십시오. 다른 모든 사용자는 NewGCM을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="15128cc4fc0390673cf1d5ff25c809ffa9a2a0a9" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use NewGCM, which is more resistant to misuse.</source>
          <target state="translated">비표준 태그 길이를 사용하는 기존 암호화 시스템과의 호환성이 필요한 경우에만이 기능을 사용하십시오. 다른 모든 사용자는 오용에 더 강한 NewGCM을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b727317ee1d6f8ec7fdb2282449eaeba440af19" translate="yes" xml:space="preserve">
          <source>Op is a Porter-Duff compositing operator.</source>
          <target state="translated">Op은 Porter-Duff 합성 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="5af1dc92a9e2658f3244c1615c860d1105099061" translate="yes" xml:space="preserve">
          <source>OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.</source>
          <target state="translated">OpError는 일반적으로 net 패키지의 함수에 의해 반환되는 오류 유형입니다. 작업, 네트워크 유형 및 오류 주소에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="18f672481765f9d884600846dfaa4fd9da765b39" translate="yes" xml:space="preserve">
          <source>Opaque scans the entire image and reports whether it is fully opaque.</source>
          <target state="translated">불투명은 전체 이미지를 스캔하여 완전히 불투명한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b7443a4b74ca4cfa1bcd5bba9250ca69f1869f28" translate="yes" xml:space="preserve">
          <source>Open implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d.</source>
          <target state="translated">Open은 os.Open을 사용하여 FileSystem을 구현하고 디렉토리를 기준으로 루트 및 루트를 읽기위한 파일을 엽니 다. d.</target>
        </trans-unit>
        <trans-unit id="6171c49e2bc16b1abb139c13c4d94d148a1c46f3" translate="yes" xml:space="preserve">
          <source>Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">Open은 데이터베이스에 연결하지 않고 인수의 유효성을 검사 할 수 있습니다. 데이터 소스 이름이 유효한지 확인하려면 Ping을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5020abe2d6e35be83ee66706a97f7b42a3cce7b0" translate="yes" xml:space="preserve">
          <source>Open opens a Go plugin. If a path has already been opened, then the existing *Plugin is returned. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Open은 Go 플러그인을 엽니 다. 경로가 이미 열려 있으면 기존 * Plugin이 반환됩니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="66a147f16950427bc220b36b7335c4430f2e435a" translate="yes" xml:space="preserve">
          <source>Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.</source>
          <target state="translated">Open은 데이터베이스 드라이버 이름과 드라이버 특정 데이터 소스 이름으로 지정된 데이터베이스를 엽니 다. 일반적으로 데이터베이스 이름과 연결 정보로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="37d7b9b7fb804765c0c890c3a9927f5e792e10c2" translate="yes" xml:space="preserve">
          <source>Open opens and returns the FileHeader's associated File.</source>
          <target state="translated">열기가 열리고 FileHeader의 관련 파일이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9f531c4cd3491cbb25cd300045e949a3c6a2f783" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError.</source>
          <target state="translated">열기는 명명 된 파일을 읽기 위해 엽니 다. 성공하면 리턴 된 파일의 메소드를 사용하여 읽을 수 있습니다. 연관된 파일 디스크립터는 O_RDONLY 모드를 갖습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="371cc608c2ba1c0990eaf9fb6894bbf2a52158f7" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Mach-O binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 Mach-O 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="7d04ca361fd4f73d2b0f9d528191bbbad4f3caa9" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a PE binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 PE 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="401e69358b39b00234c49cca571dfb25656931d2" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 Plan 9 a.out 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="9b1194bbc276659f78fdca3adfdc9b10d19c8660" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as an ELF binary.</source>
          <target state="translated">Open은 os.Open을 사용하여 명명 된 파일을 열고 ELF 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="f50055a1ded1f305ba4233bb037ec0d820624aa9" translate="yes" xml:space="preserve">
          <source>Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently.</source>
          <target state="translated">Open은 파일 내용에 액세스 할 수있는 ReadCloser를 반환합니다. 여러 파일을 동시에 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc15ea0e79b5a5fd3585bbb7eb793bc7927e0c43" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF program body.</source>
          <target state="translated">Open은 ELF 프로그램 본문을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb2948f8796f4e20787b4c3d93aa97d5e5dd5298" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.</source>
          <target state="translated">Open은 ELF 섹션을 읽는 새로운 ReadSeeker를 반환합니다. 섹션이 ELF 파일로 압축 저장되어 있어도 ReadSeeker는 압축되지 않은 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="21b5b726e4f4ade0871cc002a3334fa728428adc" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Mach-O section.</source>
          <target state="translated">Open은 Mach-O 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b61efb693d7cf70cb90d5aedf0d5a372c5aa6512" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the PE section s.</source>
          <target state="translated">Open은 PE 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84fc1af6d68e3cc755958db236fc07677794c372" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Plan 9 a.out section.</source>
          <target state="translated">Open은 Plan 9 a.out 섹션을 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="387b57706c30c22b6f03a484c6bd4b511d83f9ce" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the segment.</source>
          <target state="translated">Open은 세그먼트를 읽는 새로운 ReadSeeker를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1007daa5b98f8257c13edf3ea065301dd1ebaf2b" translate="yes" xml:space="preserve">
          <source>OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">OpenDB는 데이터베이스에 연결하지 않고 인수의 유효성을 검사 할 수 있습니다. 데이터 소스 이름이 유효한지 확인하려면 Ping을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="25e1b5a42de4942dfe6b4bfced8324ba7ad01162" translate="yes" xml:space="preserve">
          <source>OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name.</source>
          <target state="translated">OpenDB는 커넥터를 사용하여 데이터베이스를 열어 드라이버가 문자열 기반 데이터 소스 이름을 무시할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="02205221603211c0f70a26822c2a5ea1275e3176" translate="yes" xml:space="preserve">
          <source>OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary.</source>
          <target state="translated">OpenFat은 os.Open을 사용하여 명명 된 파일을 열고 Mach-O 범용 바이너리로 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="f89511e6449f4d72c17e5b2730171b3d593b5ed7" translate="yes" xml:space="preserve">
          <source>OpenFile</source>
          <target state="translated">OpenFile</target>
        </trans-unit>
        <trans-unit id="0c82063df1128e3daff7e360a09afecb32d7114a" translate="yes" xml:space="preserve">
          <source>OpenFile (Append)</source>
          <target state="translated">OpenFile (추가)</target>
        </trans-unit>
        <trans-unit id="4fc4a091591f11a5786d39de5a16c7ed7ce1eeab" translate="yes" xml:space="preserve">
          <source>OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.</source>
          <target state="translated">OpenFile은 일반화 된 공개 통화입니다. 대부분의 사용자는 Open 또는 Create를 대신 사용합니다. 지정된 플래그 (O_RDONLY 등)로 명명 된 파일을 엽니 다. 파일이 존재하지 않고 O_CREATE 플래그가 전달되면 모드 perm (umask 이전)으로 작성됩니다. 성공하면 리턴 된 파일의 메소드를 I / O에 사용할 수 있습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="154227f07677e156add449cf112307bf838866a9" translate="yes" xml:space="preserve">
          <source>OpenReader will open the Zip file specified by name and return a ReadCloser.</source>
          <target state="translated">OpenReader는 이름으로 지정된 Zip 파일을 열고 ReadCloser를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cbb449ad00bd956208ebf3bc7a9b2a9d9466e94" translate="yes" xml:space="preserve">
          <source>Operating systems provide both a &amp;ldquo;wall clock,&amp;rdquo; which is subject to changes for clock synchronization, and a &amp;ldquo;monotonic clock,&amp;rdquo; which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.</source>
          <target state="translated">운영 체제는 클럭 동기화를 위해 변경 될 수있는 &quot;월 클럭&quot;과 그렇지 않은 &quot;모노 닉 클럭&quot;을 모두 제공합니다. 일반적으로 벽시계는 시간을 알려주기위한 것이며 단조로운 시계는 시간을 측정하기위한 것입니다. 이 패키지에서 시간을 기준으로 반환 된 시간 인 API를 분할하는 대신 벽시계 판독 값과 단조로운 클록 판독 값을 모두 포함합니다. 나중에 시간을 알리는 작업은 벽시계 판독을 사용하지만 나중에 시간을 측정하는 작업, 특히 비교 및 ​​뺄셈은 단조로운 시계 판독을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f30cabbd8e785b594ba56b3801fd9d4f1260078a" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To &quot;copy&quot; a Float value, an existing (or newly allocated) Float must be set to a new value using the Float.Set method; shallow copies of Floats are not supported and may lead to errors.</source>
          <target state="translated">연산은 항상 Float 값 대신 포인터 인수 (* Float)를 사용하며 각 고유 Float 값에는 고유 한 * Float 포인터가 필요합니다. Float 값을 &quot;복사&quot;하려면 기존 (또는 새로 할당 된) Float를 Float.Set 메서드를 사용하여 새 값으로 설정해야합니다. 플로트의 얕은 복사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1165d6e4bac8282c929350a1919aee2062c5958" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To &quot;copy&quot; an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors.</source>
          <target state="translated">연산은 항상 Int 값 대신 포인터 인수 (* Int)를 사용하며 각 고유 Int 값에는 고유 한 * Int 포인터가 필요합니다. Int 값을 &quot;복사&quot;하려면 기존 (또는 새로 할당 된) Int를 Int.Set 메서드를 사용하여 새 값으로 설정해야합니다. 얕은 Ints 사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2237e984f46419a4f93c71fc7a1e90b45fca20" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To &quot;copy&quot; a Rat value, an existing (or newly allocated) Rat must be set to a new value using the Rat.Set method; shallow copies of Rats are not supported and may lead to errors.</source>
          <target state="translated">조작은 항상 Rat 값 대신 포인터 인수 (* Rat)를 사용하며 각 고유 한 Rat 값에는 고유 한 * Rat 포인터가 필요합니다. Rat 값을 &quot;복사&quot;하려면 기존 또는 새로 할당 된 Rat를 Rat.Set 메소드를 사용하여 새 값으로 설정해야합니다. 얕은 쥐의 복사본은 지원되지 않으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff98727eb74457bb348de0295d7fc660d04eb4a" translate="yes" xml:space="preserve">
          <source>Operations to set or modify these public variables are atomic.</source>
          <target state="translated">이러한 공용 변수를 설정하거나 수정하는 작업은 원 자성입니다.</target>
        </trans-unit>
        <trans-unit id="a344aa2f0644d620585ef6109d1a2e6c58d16a89" translate="yes" xml:space="preserve">
          <source>Option sets options for the template. Options are described by strings, either a simple string or &quot;key=value&quot;. There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.</source>
          <target state="translated">옵션은 템플릿의 옵션을 설정합니다. 옵션은 간단한 문자열 또는 &quot;key = value&quot;문자열로 설명됩니다. 옵션 문자열에는 최대 하나의 등호가있을 수 있습니다. 옵션 문자열이 인식되지 않거나 유효하지 않으면 옵션 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22bdd06043dd23aedf196f8c5aa67a749424f26f" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters.</source>
          <target state="translated">옵션은 인코딩 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="2ae1ba4c5551ccfa17f3cc4234e6c983b6c4a751" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.</source>
          <target state="translated">옵션은 인코딩 매개 변수입니다. 품질 범위는 1에서 100까지이며 높을수록 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3574245ef01db27c04b70bab947169f3717705e6" translate="yes" xml:space="preserve">
          <source>Options are the options for creating a new Jar.</source>
          <target state="translated">옵션은 새로운 Jar를 생성하기위한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="adec537139c73f02b553920372adc3c02c28272e" translate="yes" xml:space="preserve">
          <source>Or sets z = x | y and returns z.</source>
          <target state="translated">또는 z = x | y는 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b94d1371289b3526620aa944ef691c23c5e97" translate="yes" xml:space="preserve">
          <source>Or to collect a 5-second execution trace:</source>
          <target state="translated">또는 5 초 실행 추적을 수집하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="50c67b4d826544d33e4676d47eb11f1c27fb8432" translate="yes" xml:space="preserve">
          <source>Or to look at a 30-second CPU profile:</source>
          <target state="translated">또는 30 초 CPU 프로파일을 보려면</target>
        </trans-unit>
        <trans-unit id="b615664e9607d56a174a9eae8d3c5a2c6e80bd6a" translate="yes" xml:space="preserve">
          <source>Or to look at the goroutine blocking profile, after calling runtime.SetBlockProfileRate in your program:</source>
          <target state="translated">또는 프로그램에서 runtime.SetBlockProfileRate를 호출 한 후 고 루틴 차단 프로파일을 보려면 :</target>
        </trans-unit>
        <trans-unit id="9e825dc80cfaf2eaa80db6ce23de3b3fc8a8346c" translate="yes" xml:space="preserve">
          <source>Or to look at the holders of contended mutexes, after calling runtime.SetMutexProfileFraction in your program:</source>
          <target state="translated">또는 프로그램에서 runtime.SetMutexProfileFraction을 호출 한 후 컨텐트 된 뮤텍스의 홀더를 보려면 :</target>
        </trans-unit>
        <trans-unit id="8ab86bd1259ac4f40dd163dea09a395538c7b9f8" translate="yes" xml:space="preserve">
          <source>Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by</source>
          <target state="translated">또는 Value 인터페이스 (포인터 리시버 포함)를 만족시키는 커스텀 플래그를 생성하고이를 플래그 파싱에 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e10a8547b0d36316e030b08eda98a7d2a3b8233" translate="yes" xml:space="preserve">
          <source>Order specifies the bit ordering in an LZW data stream.</source>
          <target state="translated">순서는 LZW 데이터 스트림에서 비트 순서를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5cbea92714ef396bc3e8932074a0396b90c6e75c" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error.</source>
          <target state="translated">다른 ASN.1 유형은 지원되지 않습니다. 발견되면 Unmarshal은 구문 분석 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7ba1580fd9fc904fa02322480bcec7e07c54f2cc" translate="yes" xml:space="preserve">
          <source>Other definitions of spacing characters are set by category Z and property Pattern_White_Space.</source>
          <target state="translated">간격 문자의 다른 정의는 범주 Z 및 속성 Pattern_White_Space에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a56a76d64dcdb6eb16b696315251945b43a236" translate="yes" xml:space="preserve">
          <source>Other flags:</source>
          <target state="translated">다른 깃발 :</target>
        </trans-unit>
        <trans-unit id="bd1405bb0e6eee6e420fe2dfb40f43a986aa8880" translate="yes" xml:space="preserve">
          <source>Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.</source>
          <target state="translated">time.Since (start), time.Until (deadline) 및 time.Now (). Before (deadline)과 같은 다른 관용구는 벽시계 재설정에 대해 유사하게 강력합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d97b3571d62fa73ceb918bc9a47b9937e01e1" translate="yes" xml:space="preserve">
          <source>Other packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cf6fa65416b27793d90a051b00b5c18e902844" translate="yes" xml:space="preserve">
          <source>Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.</source>
          <target state="translated">다른 값 (숫자, 부울, 문자열 및 채널)은 Go의 == 연산자를 사용하여 같으면 깊이 같습니다.</target>
        </trans-unit>
        <trans-unit id="68cac93271438e6498e5c369aaaa0b2b44f4aa36" translate="yes" xml:space="preserve">
          <source>Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.</source>
          <target state="translated">그렇지 않으면 컨텍스트는 컨텍스트 함수에 대한 호출에 의해 이전에 리턴 된 값입니다. 역 추적 기능은 프로그램 실행의 저장된 지점에서 스택 추적을 수집해야합니다. 트레이스 백 함수는 컨텍스트를 기록한 스레드 이외의 실행 스레드에서 호출 될 수 있지만 컨텍스트가 유효하고 변경되지 않는 것으로 알려진 경우에만 가능합니다. 트레이스 백 함수는 컨텍스트를 기록한 동일한 스레드의 호출 스택에서 더 깊이 호출 될 수도 있습니다. 역 추적 함수는 동일한 컨텍스트 값으로 여러 번 호출 될 수 있습니다. 일반적으로 가능한 경우 특정 컨텍스트 값에 대해 처음 호출 할 때 결과를 캐시하는 것이 적절합니다.</target>
        </trans-unit>
        <trans-unit id="440873215b88a6b8697d85d1d64d02df4a4da93f" translate="yes" xml:space="preserve">
          <source>Otherwise, Marshal uses the following type-dependent default encodings:</source>
          <target state="translated">그렇지 않으면 Marshal은 다음과 같은 유형 종속 기본 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23286c7a365f916cfdea50d5123a3b0bcae1d4f3" translate="yes" xml:space="preserve">
          <source>Otherwise, the Scanner advances the input. If the token is not nil, the Scanner returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the Scanner returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a SplitFunc can return (0, nil, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.</source>
          <target state="translated">그렇지 않으면 스캐너가 입력을 진행시킵니다. 토큰이 0이 아닌 경우 스캐너는 사용자에게 토큰을 반환합니다. 토큰이 0이 아닌 경우 스캐너는 더 많은 데이터를 읽고 스캔을 계속합니다. atEOF가 true 인 경우 더 이상 데이터가 없으면 스캐너가 반환합니다. 데이터가 아직 완전한 토큰을 보유하지 않은 경우 (예 : 줄을 스캔하는 동안 줄 바꿈이없는 경우) SplitFunc는 (0, nil, nil)을 반환하여 스캐너가 슬라이스로 더 많은 데이터를 읽고 더 긴 시간 동안 다시 시도하도록 신호를 보냅니다. 입력에서 같은 지점에서 시작하는 슬라이스.</target>
        </trans-unit>
        <trans-unit id="c58abb3a56ad02906deb5ed411e41c1942d916f5" translate="yes" xml:space="preserve">
          <source>Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as &quot;America/New_York&quot;.</source>
          <target state="translated">그렇지 않으면 이름은 &quot;America / New_York&quot;와 같은 IANA 표준 시간대 데이터베이스의 파일에 해당하는 위치 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="074d0906fc55c8d6c513fa44707b8b377c627c79" translate="yes" xml:space="preserve">
          <source>Out may be used to retrieve OUTPUT value parameters from stored procedures.</source>
          <target state="translated">저장 프로 시저에서 OUTPUT 값 매개 변수를 검색하는 데 Out을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f29f77d6256848fed5f348aeadebd7d0572e5e" translate="yes" xml:space="preserve">
          <source>Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.</source>
          <target state="translated">출력은 사용법 및 오류 메시지의 대상을 반환합니다. 출력이 설정되지 않았거나 nil로 설정된 경우 os.Stderr가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e449133aa4e97be80abdfc0c46f50787b1e6cc66" translate="yes" xml:space="preserve">
          <source>Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr.</source>
          <target state="translated">출력은 명령을 실행하고 표준 출력을 반환합니다. 리턴 된 오류는 일반적으로 * ExitError 유형입니다. c.Stderr이 nil이면, Output은 ExitError.Stderr를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ecc8307c727787c0796f59aebc9997243dec020" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.</source>
          <target state="translated">출력은 로깅 이벤트에 대한 출력을 씁니다. 문자열 s에는 로거의 플래그로 지정된 접두사 뒤에 인쇄 할 텍스트가 포함됩니다. s의 마지막 문자가 이미 개행 문자가 아닌 경우 개행 문자가 추가됩니다. Calldepth는 Llongfile 또는 Lshortfile이 설정된 경우 파일 이름과 줄 번호를 계산할 때 건너 뛸 프레임 수입니다. 값이 1이면 출력 호출자에 대한 세부 사항이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c217d8994a3f1426d43eb0166f8c3a35d6d34515" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.</source>
          <target state="translated">출력은 로깅 이벤트에 대한 출력을 씁니다. 문자열 s에는 로거의 플래그로 지정된 접두사 뒤에 인쇄 할 텍스트가 포함됩니다. s의 마지막 문자가 이미 개행 문자가 아닌 경우 개행 문자가 추가됩니다. Calldepth는 PC를 복구하는 데 사용되며 일반적으로 제공되지만 모든 사전 정의 된 경로에서는 현재 2입니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4fa36fa9b33d97810f39e28fc36e995589f3d560" translate="yes" xml:space="preserve">
          <source>Output: &quot;ZgotmplZ&quot; Example:</source>
          <target state="translated">출력 : &quot;ZgotmplZ&quot;예 :</target>
        </trans-unit>
        <trans-unit id="75e718b4932f1994826e9ab2559b67ffd1e17df7" translate="yes" xml:space="preserve">
          <source>Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.</source>
          <target state="translated">이 두 가지 특별한 경우를 제외하고 ServeFile은 r.URL.Path를 사용하여 제공 할 파일이나 디렉토리를 선택하지 않습니다. name 인수에 제공된 파일 또는 디렉토리 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a7fdb472ac14ee470a8708bdbde30a747ecc04" translate="yes" xml:space="preserve">
          <source>OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.</source>
          <target state="translated">OverflowComplex는 complex128 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 Kind가 Complex64 또는 Complex128이 아닌 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ed609ef26db1230ec310f05f6a41e74b4a279d" translate="yes" xml:space="preserve">
          <source>OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.</source>
          <target state="translated">OverflowFloat는 float64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Float32 또는 Float64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7200bfe476f81acadc4a0ccf748e1684d1005b1a" translate="yes" xml:space="preserve">
          <source>OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">OverflowInt는 int64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Int, Int8, Int16, Int32 또는 Int64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b4b5d40028c4ba9e1027f58dcb6f18125d975d5" translate="yes" xml:space="preserve">
          <source>OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">OverflowUint는 uint64 x를 v의 유형으로 나타낼 수 없는지 여부를보고합니다. v의 종류가 Uint, Uintptr, Uint8, Uint16, Uint32 또는 Uint64가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f7f8328b596e3ddecd6faa4ad494433682975d9" translate="yes" xml:space="preserve">
          <source>Overlaps reports whether r and s have a non-empty intersection.</source>
          <target state="translated">겹침은 r과 s에 비어 있지 않은 교점이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="540bc829190ced5e9ba3735dc9ac84a0059b79f4" translate="yes" xml:space="preserve">
          <source>P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).</source>
          <target state="translated">P224는 P-224를 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.2 참조).</target>
        </trans-unit>
        <trans-unit id="f9ccdfec57f69f0c0af7d347e1e194be5e3da78a" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)</source>
          <target state="translated">P256은 P-256을 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.3 참조)</target>
        </trans-unit>
        <trans-unit id="0d2178f68bbde9fa3217033c113d8df97da47a28" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)</source>
          <target state="translated">P384는 P-384를 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.4 참조)</target>
        </trans-unit>
        <trans-unit id="c9a508dd7c665008acf0e38e607e3196bfcd6cf9" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)</source>
          <target state="translated">P521은 P-521을 구현하는 곡선을 반환합니다 (FIPS 186-3, 섹션 D.2.5 참조)</target>
        </trans-unit>
        <trans-unit id="39161099723c9e406b69587afd22627144ad7720" translate="yes" xml:space="preserve">
          <source>PCToFunc returns the function containing the program counter pc, or nil if there is no such function.</source>
          <target state="translated">PCToFunc는 프로그램 카운터 pc를 포함하는 함수를 반환하거나 그러한 함수가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aabe0db5b758e9cbc954a1f7a208c14d080cb6c6" translate="yes" xml:space="preserve">
          <source>PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil.</source>
          <target state="translated">PCToLine은 프로그램 카운터에 대한 라인 번호 정보를 찾습니다. 정보가 없으면 fn == nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="841d78ecc2d24b8758f6afc447a9a64df99960bb" translate="yes" xml:space="preserve">
          <source>PCToLine returns the line number for the given program counter.</source>
          <target state="translated">PCToLine은 주어진 프로그램 카운터의 줄 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8139323c6d19479f54e5ea9ba69d4546948a8d4" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="translated">PKCS1v15DecrypterOpts는 crypto.Decrypter 인터페이스를 사용하여 옵션을 PKCS # 1 v1.5 복호화로 전달하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3010ccb1954efdb7b7065a86234a1d7d460fba48" translate="yes" xml:space="preserve">
          <source>PSSOptions contains options for creating and verifying PSS signatures.</source>
          <target state="translated">PSSOptions에는 PSS 서명을 만들고 확인하기위한 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7431e3df243c5be33cffa0b28ca2a76b93f0538c" translate="yes" xml:space="preserve">
          <source>Package</source>
          <target state="translated">Package</target>
        </trans-unit>
        <trans-unit id="6de038894baa09edba875dcb5414f5284bdf18fd" translate="yes" xml:space="preserve">
          <source>Package (Autoescaping)</source>
          <target state="translated">패키지 (자동 이스케이프)</target>
        </trans-unit>
        <trans-unit id="efd760e5022b210b4ab3b28e3b7050f4cfe5597a" translate="yes" xml:space="preserve">
          <source>Package (Basic)</source>
          <target state="translated">패키지 (기본)</target>
        </trans-unit>
        <trans-unit id="2f75473a87f737dac84d4da0d9f9f7e3db9e0c4a" translate="yes" xml:space="preserve">
          <source>Package (BinaryMarshaler)</source>
          <target state="translated">패키지 (BinaryMarshaler)</target>
        </trans-unit>
        <trans-unit id="521cf6815d29f653ce707f251cb067182d8071f5" translate="yes" xml:space="preserve">
          <source>Package (ComplexNumbers)</source>
          <target state="translated">패키지 (복합 수)</target>
        </trans-unit>
        <trans-unit id="f1ea6c4ac2e70daab523cce5ae048f3dea0d83bb" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalJSON)</source>
          <target state="translated">패키지 (CustomMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="53c1354bffac6774daf658fbd5e85b47d709a40a" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalXML)</source>
          <target state="translated">패키지 (CustomMarshalXML)</target>
        </trans-unit>
        <trans-unit id="bf806559bf4e10f3c8039c45350fd1cd892af724" translate="yes" xml:space="preserve">
          <source>Package (DecodeConfig)</source>
          <target state="translated">패키지 (DecodeConfig)</target>
        </trans-unit>
        <trans-unit id="5c13dd8a74667052e5635f9f7455a54e1f9be1f3" translate="yes" xml:space="preserve">
          <source>Package (Dictionary)</source>
          <target state="translated">패키지 (사전)</target>
        </trans-unit>
        <trans-unit id="fcafbcc962aec3c3d83b146b18f61ef5463aef43" translate="yes" xml:space="preserve">
          <source>Package (EConvergents)</source>
          <target state="translated">패키지 (EConvergents)</target>
        </trans-unit>
        <trans-unit id="71630f752f5d0a16ab8b1a3c38461b76d37e5fed" translate="yes" xml:space="preserve">
          <source>Package (Elastic)</source>
          <target state="translated">패키지 (탄성)</target>
        </trans-unit>
        <trans-unit id="3dc381377e54ebe3f92f7916ec8fdf96578a8e4b" translate="yes" xml:space="preserve">
          <source>Package (EncodeDecode)</source>
          <target state="translated">패키지 (EncodeDecode)</target>
        </trans-unit>
        <trans-unit id="252573860775d14759f48467c37c1fc311083728" translate="yes" xml:space="preserve">
          <source>Package (Escape)</source>
          <target state="translated">패키지 (탈출)</target>
        </trans-unit>
        <trans-unit id="25f707cfdaffe7b9a529ff95591583c8c03bc6af" translate="yes" xml:space="preserve">
          <source>Package (Fibonacci)</source>
          <target state="translated">패키지 (피보나치)</target>
        </trans-unit>
        <trans-unit id="338a17f2623ba97dc73fc6452b147c9a5a0e8298" translate="yes" xml:space="preserve">
          <source>Package (Formats)</source>
          <target state="translated">패키지 (포맷)</target>
        </trans-unit>
        <trans-unit id="426c20e3d54491dcaa33e4dd0bebe004b79c0135" translate="yes" xml:space="preserve">
          <source>Package (IntHeap)</source>
          <target state="translated">패키지 (IntHeap)</target>
        </trans-unit>
        <trans-unit id="0c999d293b130996c88c6f0ebf97cfecc7e78201" translate="yes" xml:space="preserve">
          <source>Package (Interface)</source>
          <target state="translated">패키지 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="dd11444f3f52c88a7e33585300bd5ea9526ef9c4" translate="yes" xml:space="preserve">
          <source>Package (Is)</source>
          <target state="translated">패키지</target>
        </trans-unit>
        <trans-unit id="24d024864b73227ebe67578e60455dbd5c73297f" translate="yes" xml:space="preserve">
          <source>Package (IsIdentRune)</source>
          <target state="translated">패키지 (IsIdentRune)</target>
        </trans-unit>
        <trans-unit id="748caafd5bbe2c55ebabfb05417c48bc6922ffcf" translate="yes" xml:space="preserve">
          <source>Package (Minimal)</source>
          <target state="translated">패키지 (최소)</target>
        </trans-unit>
        <trans-unit id="4c4a86eeb8002b47d70510d7c23e7eb0eeebd8db" translate="yes" xml:space="preserve">
          <source>Package (Mode)</source>
          <target state="translated">패키지 (모드)</target>
        </trans-unit>
        <trans-unit id="be479fe7812a33e53549975551961ada92e137a5" translate="yes" xml:space="preserve">
          <source>Package (OpenDBCLI)</source>
          <target state="translated">패키지 (OpenDBCLI)</target>
        </trans-unit>
        <trans-unit id="afacd609e03942d0e0a9efefefa3cc27d29c774c" translate="yes" xml:space="preserve">
          <source>Package (OpenDBService)</source>
          <target state="translated">패키지 (OpenDBService)</target>
        </trans-unit>
        <trans-unit id="867dd5ed3ca2062c464faebd1a831d2ea55231a1" translate="yes" xml:space="preserve">
          <source>Package (Printers)</source>
          <target state="translated">패키지 (프린터)</target>
        </trans-unit>
        <trans-unit id="944f7ea8e45283f6aee9c663f196d84201347430" translate="yes" xml:space="preserve">
          <source>Package (PriorityQueue)</source>
          <target state="translated">패키지 (PriorityQueue)</target>
        </trans-unit>
        <trans-unit id="e76c0b4be64237d4de2b6bc5f73a9204c1c70fde" translate="yes" xml:space="preserve">
          <source>Package (Rand)</source>
          <target state="translated">패키지 (랜드)</target>
        </trans-unit>
        <trans-unit id="a8e65e58fc97f49428772dd3c9910ec49b3603a7" translate="yes" xml:space="preserve">
          <source>Package (Reset)</source>
          <target state="translated">패키지 (재설정)</target>
        </trans-unit>
        <trans-unit id="0676e5f7c44f1428abe1688347a4a67985619798" translate="yes" xml:space="preserve">
          <source>Package (RetrievePositionInfo)</source>
          <target state="translated">패키지 (RetrievePositionInfo)</target>
        </trans-unit>
        <trans-unit id="3918e789c00aa71d83a0d25f288c82afb2e9dc19" translate="yes" xml:space="preserve">
          <source>Package (SortKeys)</source>
          <target state="translated">패키지 (SortKeys)</target>
        </trans-unit>
        <trans-unit id="fc31bf6d702c41d4e65fa2c8464a648d0253335d" translate="yes" xml:space="preserve">
          <source>Package (SortMultiKeys)</source>
          <target state="translated">패키지 (SortMultiKeys)</target>
        </trans-unit>
        <trans-unit id="be587b9c8d7d28588b076a30e4390f166b763389" translate="yes" xml:space="preserve">
          <source>Package (SortWrapper)</source>
          <target state="translated">패키지 (SortWrapper)</target>
        </trans-unit>
        <trans-unit id="039d4d77bcfce9ea65f0437ee2733cacb35d30d2" translate="yes" xml:space="preserve">
          <source>Package (Sqrt2)</source>
          <target state="translated">패키지 (Sqrt2)</target>
        </trans-unit>
        <trans-unit id="978d6874fbbc2bbed5f65358c7eadec1499de368" translate="yes" xml:space="preserve">
          <source>Package (Synchronization)</source>
          <target state="translated">패키지 (동기화)</target>
        </trans-unit>
        <trans-unit id="d74eef6782bc61ea34233345eec7439ddb2209f0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalJSON)</source>
          <target state="translated">패키지 (TextMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="00ea20ac0a3062f6e781d5f03ac4f931f7e664e0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalXML)</source>
          <target state="translated">패키지 (TextMarshalXML)</target>
        </trans-unit>
        <trans-unit id="9d3479f34953d267211484567770a976cf5f7423" translate="yes" xml:space="preserve">
          <source>Package (TrailingTab)</source>
          <target state="translated">패키지 (TrailingTab)</target>
        </trans-unit>
        <trans-unit id="db41f4bcaa84e2ad0f8ea9b730005966564c99d0" translate="yes" xml:space="preserve">
          <source>Package (Whitespace)</source>
          <target state="translated">패키지 (공백)</target>
        </trans-unit>
        <trans-unit id="3fb9a413fc3704254de1eb68fffddbb472a23f33" translate="yes" xml:space="preserve">
          <source>Package (WriterReader)</source>
          <target state="translated">패키지 (WriterReader)</target>
        </trans-unit>
        <trans-unit id="92c0af89beed6181e00c988e8e650e8fbbda5fcb" translate="yes" xml:space="preserve">
          <source>Package adler32</source>
          <target state="translated">패키지 adler32</target>
        </trans-unit>
        <trans-unit id="d6bd7681a9453e693c6a651037643ef4b5bef6e4" translate="yes" xml:space="preserve">
          <source>Package adler32 implements the Adler-32 checksum.</source>
          <target state="translated">패키지 adler32는 Adler-32 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e90a3804ce06c2050a2cae1b40859d0d4b3dc725" translate="yes" xml:space="preserve">
          <source>Package aes</source>
          <target state="translated">패키지 AES</target>
        </trans-unit>
        <trans-unit id="d496233c286ca50cea980f949b6ce9d0a2fbee51" translate="yes" xml:space="preserve">
          <source>Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.</source>
          <target state="translated">패키지 aes는 미국 연방 정보 처리 표준 간행물 197에 정의 된대로 AES 암호화 (이전의 Rijndael)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0d926b729b85354785bc0db2b7d8a423a023029c" translate="yes" xml:space="preserve">
          <source>Package ascii85</source>
          <target state="translated">패키지 ascii85</target>
        </trans-unit>
        <trans-unit id="e3765c8a35f98ca3f4cb583e00d1c90614882045" translate="yes" xml:space="preserve">
          <source>Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.</source>
          <target state="translated">패키지 ascii85는 btoa 도구 및 Adobe의 PostScript 및 PDF 문서 형식에 사용되는 ascii85 데이터 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="180c9a93d5ae7703f2646b742a79d37379696e26" translate="yes" xml:space="preserve">
          <source>Package asn1</source>
          <target state="translated">asn1 패키지</target>
        </trans-unit>
        <trans-unit id="cb9e56c303fa3f867a92e5ec0e898886f01abb4e" translate="yes" xml:space="preserve">
          <source>Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.</source>
          <target state="translated">패키지 asn1은 ITU-T Rec X.690에 정의 된대로 DER로 인코딩 된 ASN.1 데이터 구조의 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c08d789dfd150c497744e5eae59ce25bf42b161c" translate="yes" xml:space="preserve">
          <source>Package ast</source>
          <target state="translated">ast 패키지</target>
        </trans-unit>
        <trans-unit id="93ce17c079d14adf086a4a91c618dc024db4dcea" translate="yes" xml:space="preserve">
          <source>Package ast declares the types used to represent syntax trees for Go packages.</source>
          <target state="translated">Package ast는 Go 패키지의 구문 트리를 나타내는 데 사용되는 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="abc4155f0dfe705449b74dd36086fa20264918b2" translate="yes" xml:space="preserve">
          <source>Package atomic</source>
          <target state="translated">패키지 원자</target>
        </trans-unit>
        <trans-unit id="6ccbd2fd52492c5f3e2a1a498498664cb5ffa588" translate="yes" xml:space="preserve">
          <source>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.</source>
          <target state="translated">패키지 원자는 동기화 알고리즘을 구현하는 데 유용한 저수준 원자 메모리 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ae1e53a5fe2ac3a3b380e5791057e84bdf2fcee" translate="yes" xml:space="preserve">
          <source>Package base32</source>
          <target state="translated">패키지 base32</target>
        </trans-unit>
        <trans-unit id="3b12a0015b14e3cc130f8b62c8c17d7c8624a97a" translate="yes" xml:space="preserve">
          <source>Package base32 implements base32 encoding as specified by RFC 4648.</source>
          <target state="translated">패키지 base32는 RFC 4648에 지정된 base32 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="38a49427af734eb5994d226888d46a2e48a7e089" translate="yes" xml:space="preserve">
          <source>Package base64</source>
          <target state="translated">패키지 base64</target>
        </trans-unit>
        <trans-unit id="2daca13cb62da6b7b33a641f5439803312f106f9" translate="yes" xml:space="preserve">
          <source>Package base64 implements base64 encoding as specified by RFC 4648.</source>
          <target state="translated">패키지 base64는 RFC 4648에 지정된대로 base64 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="03b1336c942a57d9960d475b8b394ed19dde9d0c" translate="yes" xml:space="preserve">
          <source>Package big</source>
          <target state="translated">큰 패키지</target>
        </trans-unit>
        <trans-unit id="b4e5fa3ccf50e02964b74ff445efc105e444e505" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers).</source>
          <target state="translated">패키지 big은 임의 정밀도 산술 (큰 숫자)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4e4c386fba82f93790e8829cc10da0258293e392" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:</source>
          <target state="translated">큰 패키지는 임의의 정밀도 산술 (큰 숫자)을 구현합니다. 다음과 같은 숫자 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c20a791c17d35561b3248e9f4e27c1fc641c805c" translate="yes" xml:space="preserve">
          <source>Package binary</source>
          <target state="translated">패키지 바이너리</target>
        </trans-unit>
        <trans-unit id="a02abb66bca85bad533ac6ecbbd5730f265b40da" translate="yes" xml:space="preserve">
          <source>Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.</source>
          <target state="translated">패키지 바이너리는 숫자와 바이트 시퀀스 간의 간단한 변환과 varint의 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b4585c8f5f16a7a3bbd64f720869325930c04b14" translate="yes" xml:space="preserve">
          <source>Package bits</source>
          <target state="translated">패키지 비트</target>
        </trans-unit>
        <trans-unit id="f121f6160680c1e9d47eb4f125af85e968cef0c7" translate="yes" xml:space="preserve">
          <source>Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.</source>
          <target state="translated">패키지 비트는 미리 선언 된 부호없는 정수 유형에 대한 비트 계산 및 조작 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="83caad2c4e72c3c320f775fbd8a1a35e735677a9" translate="yes" xml:space="preserve">
          <source>Package bufio</source>
          <target state="translated">패키지 bufio</target>
        </trans-unit>
        <trans-unit id="880f9f9e86187c3ab9594c87162508890d92b1e0" translate="yes" xml:space="preserve">
          <source>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.</source>
          <target state="translated">패키지 bufio는 버퍼링 된 I / O를 구현합니다. io.Reader 또는 io.Writer 객체를 래핑하여 인터페이스를 구현하지만 버퍼링 및 텍스트 I / O에 대한 일부 도움말을 제공하는 다른 객체 (Reader 또는 Writer)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8f54827014010e49f148fc60f5174298cb86d1a9" translate="yes" xml:space="preserve">
          <source>Package build</source>
          <target state="translated">패키지 빌드</target>
        </trans-unit>
        <trans-unit id="044aa6ad5cb13105de3d1dfe1e14ba517afc7dc8" translate="yes" xml:space="preserve">
          <source>Package build gathers information about Go packages.</source>
          <target state="translated">패키지 빌드는 Go 패키지에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="47ff1a6f77a6fab0a4ec0e7b02acecd8b23bea55" translate="yes" xml:space="preserve">
          <source>Package builtin</source>
          <target state="translated">내장 패키지</target>
        </trans-unit>
        <trans-unit id="bc6082d4c1ffc50e8646c383c442de7a0853f3b7" translate="yes" xml:space="preserve">
          <source>Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.</source>
          <target state="translated">패키지 내장은 Go의 사전 선언 된 식별자에 대한 설명서를 제공합니다. 여기에 문서화 된 항목은 실제로 패키지 내장으로되어 있지 않지만 여기에서 설명하면 godoc이 언어의 특수 식별자에 대한 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18adabe10f881275c2b2d516cabb008577c2f65" translate="yes" xml:space="preserve">
          <source>Package bytes</source>
          <target state="translated">패키지 바이트</target>
        </trans-unit>
        <trans-unit id="48c486630207fb1f7940fbb120ac097a31665a2b" translate="yes" xml:space="preserve">
          <source>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</source>
          <target state="translated">패키지 바이트는 바이트 슬라이스 조작을위한 기능을 구현합니다. 문자열 패키지의 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="406c2304145d14ae40562458c269fc1090a1b790" translate="yes" xml:space="preserve">
          <source>Package bzip2</source>
          <target state="translated">패키지 bzip2</target>
        </trans-unit>
        <trans-unit id="8eb7c863e2530f3f68b4ee1a3003e658910e2132" translate="yes" xml:space="preserve">
          <source>Package bzip2 implements bzip2 decompression.</source>
          <target state="translated">패키지 bzip2는 bzip2 압축 해제를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="872b31b797dd9ef4b907e19e6db917bdf3d1c013" translate="yes" xml:space="preserve">
          <source>Package cgi</source>
          <target state="translated">패키지 CGI</target>
        </trans-unit>
        <trans-unit id="25ac46feb1a43e83003062fe9e6ccdab9ea2b191" translate="yes" xml:space="preserve">
          <source>Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</source>
          <target state="translated">패키지 cgi는 RFC 3875에 지정된대로 CGI (Common Gateway Interface)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="25e89bccb479aa882a9bfc5409a3323ae38e9e25" translate="yes" xml:space="preserve">
          <source>Package cgo</source>
          <target state="translated">패키지 CGO</target>
        </trans-unit>
        <trans-unit id="0e3e2e5c14219e52219e14faf9778f4b602d6c0d" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool.</source>
          <target state="translated">패키지 cgo에는 cgo 도구로 생성 된 코드에 대한 런타임 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e62ea60a0dd1e82f411152a3d6419b7bf76fb06" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool. See the documentation for the cgo command for details on using cgo.</source>
          <target state="translated">패키지 cgo에는 cgo 도구로 생성 된 코드에 대한 런타임 지원이 포함되어 있습니다. cgo 사용에 대한 자세한 내용은 cgo 명령 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="012f0d22cbfff5b4121f59681774b6bcdc6c8bf7" translate="yes" xml:space="preserve">
          <source>Package cipher</source>
          <target state="translated">패키지 암호</target>
        </trans-unit>
        <trans-unit id="30f3e7b90bc36d4a04ee0c6ee4fede5b412b7a90" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.</source>
          <target state="translated">패키지 암호는 저수준 블록 암호 구현으로 감싸 질 수있는 표준 블록 암호 모드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="991a9a7de6b61fdec46bfd3e8877fa7f538b6fb2" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; and NIST Special Publication 800-38A.</source>
          <target state="translated">패키지 암호는 낮은 수준의 블록 암호 구현으로 감쌀 수있는 표준 블록 암호 모드를 구현합니다. &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; 및 NIST Special Publication 800-38A를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b6816262bb29ee185f0f48249d8bc3daaf55582" translate="yes" xml:space="preserve">
          <source>Package cmplx</source>
          <target state="translated">패키지 cmplx</target>
        </trans-unit>
        <trans-unit id="baf57dd7a6b5ac4706888aba9eb1258cba96f27c" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers.</source>
          <target state="translated">패키지 cmplx는 복소수에 대한 기본 상수 및 수학 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37d8c891f48030e536dd7b758ded3702c02139dc" translate="yes" xml:space="preserve">
          <source>Package color</source>
          <target state="translated">패키지 색상</target>
        </trans-unit>
        <trans-unit id="0c0c35fbc62909ad60418ab34664b2ed01195fb4" translate="yes" xml:space="preserve">
          <source>Package color implements a basic color library.</source>
          <target state="translated">패키지 색상은 기본 색상 라이브러리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1bcb3d15e235264a42cb3594781e34e58e7e4025" translate="yes" xml:space="preserve">
          <source>Package constant</source>
          <target state="translated">패키지 상수</target>
        </trans-unit>
        <trans-unit id="cc9ee19fe4a55fca4b94e371e7f50f3a89a325d9" translate="yes" xml:space="preserve">
          <source>Package constant implements Values representing untyped Go constants and their corresponding operations.</source>
          <target state="translated">패키지 상수는 형식화되지 않은 Go 상수 및 해당 작업을 나타내는 값을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f37b57ba6586f71a43fafcb43910fbb2fb02fc3b" translate="yes" xml:space="preserve">
          <source>Package context</source>
          <target state="translated">패키지 컨텍스트</target>
        </trans-unit>
        <trans-unit id="d3934777ec3c952a9b50c31b8ba59b107a7a5d55" translate="yes" xml:space="preserve">
          <source>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</source>
          <target state="translated">패키지 컨텍스트는 API 유형 및 프로세스 간 마감일, 취소 신호 및 기타 요청 범위 값을 전달하는 컨텍스트 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2959c61a1310320ade48360831ded95782ef16b3" translate="yes" xml:space="preserve">
          <source>Package cookiejar</source>
          <target state="translated">패키지 쿠키</target>
        </trans-unit>
        <trans-unit id="8c90ea9e027ef93e3a9e5e3949e57755bbbd286c" translate="yes" xml:space="preserve">
          <source>Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.</source>
          <target state="translated">패키지 cookiejar는 메모리 내 RFC 6265 호환 http.CookieJar를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9b8215374e5e8361fe90b06ebf351541009e3e3e" translate="yes" xml:space="preserve">
          <source>Package crc32</source>
          <target state="translated">패키지 crc32</target>
        </trans-unit>
        <trans-unit id="b3a9ccd429f36d4cdadd48a9085d7744e115a2de" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum.</source>
          <target state="translated">패키지 crc32는 32 비트 순환 중복 검사 (CRC-32) 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e7dea81d74d4673657a098152e4028683fa05c21" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">패키지 crc32는 32 비트 순환 중복 검사 (CRC-32) 체크섬을 구현합니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd8911118f577811f18d0e59d8eb3416d753ee3d" translate="yes" xml:space="preserve">
          <source>Package crc64</source>
          <target state="translated">패키지 crc64</target>
        </trans-unit>
        <trans-unit id="3f711a93350858163dc7138684052f433c0da645" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum.</source>
          <target state="translated">패키지 crc64는 64 비트 순환 중복 검사 (CRC-64) 체크섬을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ddff3dc011b09fe55bbaec41ef9b74c6f1146846" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">패키지 crc64는 64 비트 순환 중복 검사 (CRC-64) 체크섬을 구현합니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f6d2ede86f313691ef17454cdcdea04be0dbbb5" translate="yes" xml:space="preserve">
          <source>Package crypto</source>
          <target state="translated">패키지 암호화</target>
        </trans-unit>
        <trans-unit id="50dd6822d044a230766309da5791bbd273ba8e97" translate="yes" xml:space="preserve">
          <source>Package crypto collects common cryptographic constants.</source>
          <target state="translated">패키지 암호화는 일반적인 암호화 상수를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5f5b5df462bd32a5711f5f5fa215ca1b166ed" translate="yes" xml:space="preserve">
          <source>Package csv</source>
          <target state="translated">패키지 CSV</target>
        </trans-unit>
        <trans-unit id="40dd7303701bdcc70dc0c5df42eb5d6ee214e250" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files.</source>
          <target state="translated">csv 패키지는 CSV (쉼표로 구분 된 값) 파일을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="d150a0359eb47f620b34dee9c311dced79bcede8" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180.</source>
          <target state="translated">csv 패키지는 CSV (쉼표로 구분 된 값) 파일을 읽고 씁니다. CSV 파일에는 여러 종류가 있습니다. 이 패키지는 RFC 4180에 설명 된 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c161780a1f5eed6cb5eacae516343d9cf53f40a2" translate="yes" xml:space="preserve">
          <source>Package debug</source>
          <target state="translated">패키지 디버그</target>
        </trans-unit>
        <trans-unit id="e18c0cfe3c81fb4f011a9c8574f9e5713e35fc2f" translate="yes" xml:space="preserve">
          <source>Package debug contains facilities for programs to debug themselves while they are running.</source>
          <target state="translated">패키지 디버그에는 프로그램이 실행되는 동안 스스로 디버깅하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="923e094a4a23dcbdaf9a79a349be666ee4da178a" translate="yes" xml:space="preserve">
          <source>Package des</source>
          <target state="translated">패키지 데</target>
        </trans-unit>
        <trans-unit id="f4273b555bae00c756bb38c4bdb36871d156fde9" translate="yes" xml:space="preserve">
          <source>Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.</source>
          <target state="translated">패키지 des는 미국 연방 정보 처리 표준 간행물 46-3에 정의 된 DES (데이터 암호화 표준) 및 TDEA (Triple Data Encryption Algorithm)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6bf60b0613abca5907226299b84a4808f25c054a" translate="yes" xml:space="preserve">
          <source>Package doc</source>
          <target state="translated">패키지 문서</target>
        </trans-unit>
        <trans-unit id="994d342a4898c4785e34e9db0e04a8dc47ee5ddc" translate="yes" xml:space="preserve">
          <source>Package doc extracts source code documentation from a Go AST.</source>
          <target state="translated">패키지 문서는 Go AST에서 소스 코드 문서를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5069be6dcffa96eefcc7e1232c85b45e87fe235f" translate="yes" xml:space="preserve">
          <source>Package draw</source>
          <target state="translated">패키지 추첨</target>
        </trans-unit>
        <trans-unit id="969fe7ec8173399610653b077ab51865992b53af" translate="yes" xml:space="preserve">
          <source>Package draw provides image composition functions.</source>
          <target state="translated">패키지 드로우는 이미지 합성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b15191fdde73d73923a18606c1904389361bc1f7" translate="yes" xml:space="preserve">
          <source>Package driver</source>
          <target state="translated">패키지 드라이버</target>
        </trans-unit>
        <trans-unit id="5c56f884cb2d5a4829273b5f372f47a0c56fc3c2" translate="yes" xml:space="preserve">
          <source>Package driver defines interfaces to be implemented by database drivers as used by package sql.</source>
          <target state="translated">패키지 드라이버는 sql 패키지에서 사용되는 데이터베이스 드라이버로 구현할 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="75bfd93d536faf5b82f79c9e4a6af54202df462f" translate="yes" xml:space="preserve">
          <source>Package dsa</source>
          <target state="translated">패키지 dsa</target>
        </trans-unit>
        <trans-unit id="1e5b1f9060cf17d69c4113c4252756af952bfee1" translate="yes" xml:space="preserve">
          <source>Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">패키지 dsa는 FIPS 186-3에 정의 된대로 디지털 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bba8e43639aa6507cfdd4c58cc34c9fb8b2cf7ed" translate="yes" xml:space="preserve">
          <source>Package dwarf</source>
          <target state="translated">패키지 난쟁이</target>
        </trans-unit>
        <trans-unit id="14e7ceae4640d2c62b637a66be95977203616d50" translate="yes" xml:space="preserve">
          <source>Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</source>
          <target state="translated">패키지 dwarf는 DWARF 2.0 표준 ( &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf)에&lt;/a&gt; 정의 된 실행 파일에서로드 된 DWARF 디버깅 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ccd56c1dfed1c041a4d12453cec3b05cda768eb7" translate="yes" xml:space="preserve">
          <source>Package ecdsa</source>
          <target state="translated">패키지 ecdsa</target>
        </trans-unit>
        <trans-unit id="352bd4aa5e4bbbc282580a9c214c315f78762a78" translate="yes" xml:space="preserve">
          <source>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">ecdsa 패키지는 FIPS 186-3에 정의 된대로 타원 곡선 디지털 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="22f041b9e4b005e5e63601ee047c6784ff58304a" translate="yes" xml:space="preserve">
          <source>Package ed25519</source>
          <target state="translated">패키지 ed25519</target>
        </trans-unit>
        <trans-unit id="fb8453c2683c8a0379237947977a4025115b54f4" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm.</source>
          <target state="translated">패키지 ed25519는 Ed25519 서명 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="59626533c02e37a4826df5b84fcfc9afa7203b79" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm. See &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;.</source>
          <target state="translated">패키지 ed25519는 Ed25519 서명 알고리즘을 구현합니다. &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="22876ea6aba1d18293913d0db2521ad8767018c8" translate="yes" xml:space="preserve">
          <source>Package elf</source>
          <target state="translated">패키지 엘프</target>
        </trans-unit>
        <trans-unit id="e380ec79714ca14aed830146e07f72516490e0b8" translate="yes" xml:space="preserve">
          <source>Package elf implements access to ELF object files.</source>
          <target state="translated">Package elf는 ELF 객체 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c011316b96f999a9e3cf849a36b3fc15797d8e99" translate="yes" xml:space="preserve">
          <source>Package elliptic</source>
          <target state="translated">타원 패키지</target>
        </trans-unit>
        <trans-unit id="3bab3655adc3a192a092b071bc83e45652e1d476" translate="yes" xml:space="preserve">
          <source>Package elliptic implements several standard elliptic curves over prime fields.</source>
          <target state="translated">패키지 타원은 소수 필드에 여러 표준 타원 곡선을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e1b2d294cf9a0cfac69d667bd45e68644ccbf3c6" translate="yes" xml:space="preserve">
          <source>Package encoding</source>
          <target state="translated">패키지 인코딩</target>
        </trans-unit>
        <trans-unit id="ed189180f83e61e5ab517f381324404e9d31f4c0" translate="yes" xml:space="preserve">
          <source>Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.</source>
          <target state="translated">패키지 인코딩은 데이터를 바이트 수준 및 텍스트 표현으로 변환하거나 변환하는 다른 패키지와 공유되는 인터페이스를 정의합니다. 이러한 인터페이스를 확인하는 패키지에는 인코딩 / 고브, 인코딩 / json 및 인코딩 / xml이 포함됩니다. 결과적으로 인터페이스를 한 번 구현하면 여러 인코딩에서 유형을 유용하게 만들 수 있습니다. 이러한 인터페이스를 구현하는 표준 유형에는 time.Time 및 net.IP가 있습니다. 인터페이스는 인코딩 된 데이터를 생성하고 소비하는 쌍으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee23de7e1e5b835e55c54376bdadcfebe218831" translate="yes" xml:space="preserve">
          <source>Package errors</source>
          <target state="translated">패키지 오류</target>
        </trans-unit>
        <trans-unit id="4a3bda8668f0f7be8e4653eb9de5b1df5a4b72ae" translate="yes" xml:space="preserve">
          <source>Package errors implements functions to manipulate errors.</source>
          <target state="translated">패키지 오류는 오류를 조작하는 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7627f68608d0501d49a4083a780c7eb361e07f6d" translate="yes" xml:space="preserve">
          <source>Package exec</source>
          <target state="translated">패키지 exec</target>
        </trans-unit>
        <trans-unit id="ee030f10ad063000193fa361b43cfffc1bcc3c8c" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands.</source>
          <target state="translated">패키지 exec는 외부 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7b3a0dfc0fae8cd217bc6e25080e713ad98645d6" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments.</source>
          <target state="translated">패키지 exec는 외부 명령을 실행합니다. os.StartProcess를 래핑하여 stdin 및 stdout을 쉽게 다시 매핑하고 I / O를 파이프와 연결하며 다른 조정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d612eb4d8eb6cceb1e7052a93aac6c0e863c13" translate="yes" xml:space="preserve">
          <source>Package expvar</source>
          <target state="translated">패키지 expvar</target>
        </trans-unit>
        <trans-unit id="8556b9ff068352b9cd4f96c39543b774957282c2" translate="yes" xml:space="preserve">
          <source>Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format.</source>
          <target state="translated">패키지 expvar은 서버의 작업 카운터와 같은 공용 변수에 대한 표준화 된 인터페이스를 제공합니다. JSON 형식의 / debug / vars에서 HTTP를 통해 이러한 변수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="7753afb6ef13a60250c22070f9d8cb74aca0cdd9" translate="yes" xml:space="preserve">
          <source>Package fcgi</source>
          <target state="translated">패키지 FCGI</target>
        </trans-unit>
        <trans-unit id="2130ff15a15a985590dbae853cbc6bd5f16bc412" translate="yes" xml:space="preserve">
          <source>Package fcgi implements the FastCGI protocol.</source>
          <target state="translated">패키지 fcgi는 FastCGI 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2f468670b5944c845b0cba8a76b0cc4bc25c4814" translate="yes" xml:space="preserve">
          <source>Package filepath</source>
          <target state="translated">패키지 파일 경로</target>
        </trans-unit>
        <trans-unit id="aad84fa78fc1a5621f1a8d48a9f041dd752165f9" translate="yes" xml:space="preserve">
          <source>Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.</source>
          <target state="translated">패키지 파일 경로는 대상 운영 체제 정의 파일 경로와 호환되는 방식으로 파일 이름 경로를 조작하기위한 유틸리티 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="20c64fec5374a451273360446201779aff8c1424" translate="yes" xml:space="preserve">
          <source>Package files</source>
          <target state="translated">패키지 파일</target>
        </trans-unit>
        <trans-unit id="e5471378272dfaa2efadcd1f53861518b9f099f7" translate="yes" xml:space="preserve">
          <source>Package flag</source>
          <target state="translated">패키지 플래그</target>
        </trans-unit>
        <trans-unit id="e7d9cd955d937c95fcd6a1739c4bfae5a8cbabd2" translate="yes" xml:space="preserve">
          <source>Package flag implements command-line flag parsing.</source>
          <target state="translated">패키지 플래그는 명령 줄 플래그 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a337ebb67872d5c06c8e204854b5aa24937ec53e" translate="yes" xml:space="preserve">
          <source>Package flate</source>
          <target state="translated">패키지 플랫</target>
        </trans-unit>
        <trans-unit id="cd21214e87a49e1d6a376d93be54459975506452" translate="yes" xml:space="preserve">
          <source>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</source>
          <target state="translated">패키지 플랫은 RFC 1951에 설명 된 DEFLATE 압축 데이터 형식을 구현합니다. gzip 및 zlib 패키지는 DEFLATE 기반 파일 형식에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="803b763e8c63b8639017426b9ddb6efdb2934c44" translate="yes" xml:space="preserve">
          <source>Package fmt</source>
          <target state="translated">패키지 fmt</target>
        </trans-unit>
        <trans-unit id="d4c2ac9d05c1a7be572af9a00f7d2ee2c86ace0b" translate="yes" xml:space="preserve">
          <source>Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.</source>
          <target state="translated">패키지 fmt는 C의 printf 및 scanf와 유사한 기능을 가진 형식화 된 I / O를 구현합니다. '동사'형식은 C에서 파생되지만 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d7f1bbda6df0adc48225339cb988bf008c879f32" translate="yes" xml:space="preserve">
          <source>Package fnv</source>
          <target state="translated">패키지 fnv</target>
        </trans-unit>
        <trans-unit id="1ed450736ae5a7fac5851c4ce48e5c295154cd82" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo.</source>
          <target state="translated">패키지 fnv는 Glenn Fowler, Landon Curt Noll 및 Phong Vo가 만든 비 암호 해시 함수 인 FNV-1 및 FNV-1a를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3bfeda77f81e7eb63d4ceaa90d61b0d8cdf6c313" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;.</source>
          <target state="translated">패키지 fnv는 Glenn Fowler, Landon Curt Noll 및 Phong Vo가 만든 비 암호 해시 함수 인 FNV-1 및 FNV-1a를 구현합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e1e99b0cea0f06b1bed3052795d0456203e66ac" translate="yes" xml:space="preserve">
          <source>Package format</source>
          <target state="translated">패키지 형식</target>
        </trans-unit>
        <trans-unit id="44b5a52572ad981c0279cfa1b8249c656292c37c" translate="yes" xml:space="preserve">
          <source>Package format implements standard formatting of Go source.</source>
          <target state="translated">패키지 형식은 Go 소스의 표준 형식을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b91f9f521a74becec1958e73da770098048f55a7" translate="yes" xml:space="preserve">
          <source>Package gif</source>
          <target state="translated">패키지 gif</target>
        </trans-unit>
        <trans-unit id="10af1984ddf2d910dc561741c129eaf2fb3d93fc" translate="yes" xml:space="preserve">
          <source>Package gif implements a GIF image decoder and encoder.</source>
          <target state="translated">패키지 gif는 GIF 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e3be21e16b230bb3bdb8bf1710ba144ad69deeeb" translate="yes" xml:space="preserve">
          <source>Package gob</source>
          <target state="translated">패키지 덩어리</target>
        </trans-unit>
        <trans-unit id="a418c33843d2c062092d6d7c6a4b5816c45727d5" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).</source>
          <target state="translated">패키지 gob는 gob의 스트림을 관리합니다-인코더 (송신기)와 디코더 (수신기)간에 교환 된 이진 값.</target>
        </trans-unit>
        <trans-unit id="44cd01d964bb483f352db2a1b5d4abe8f1b01e5e" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by package &quot;net/rpc&quot;.</source>
          <target state="translated">패키지 gob는 gob의 스트림을 관리합니다-인코더 (송신기)와 디코더 (수신기)간에 교환 된 이진 값. 일반적으로 &quot;net / rpc&quot;패키지에서 제공하는 것과 같은 인수 및 RPC (원격 프로 시저 호출) 결과를 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="00c000f3850e24bf28c662891a897dac5381ac6c" translate="yes" xml:space="preserve">
          <source>Package gosym</source>
          <target state="translated">패키지 gosym</target>
        </trans-unit>
        <trans-unit id="2e38d0f781b2d46a7d764ec5db29147877b83b80" translate="yes" xml:space="preserve">
          <source>Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.</source>
          <target state="translated">패키지 gosym은 gc 컴파일러가 생성 한 Go 바이너리에 포함 된 Go 기호 및 행 번호 테이블에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7a918ba298748f37d152f5cb60e30e14a28d12c9" translate="yes" xml:space="preserve">
          <source>Package gzip</source>
          <target state="translated">패키지 gzip</target>
        </trans-unit>
        <trans-unit id="29dec348206cd4001b61a9c9f0a5d0e43fd7f769" translate="yes" xml:space="preserve">
          <source>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</source>
          <target state="translated">패키지 gzip은 RFC 1952에 지정된 gzip 형식 압축 파일 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="14ea7753f344ada7c0aa1963e2baed63cdc13331" translate="yes" xml:space="preserve">
          <source>Package hash</source>
          <target state="translated">패키지 해시</target>
        </trans-unit>
        <trans-unit id="a85d6200368ac18f684b218608b5fa8afb33d33f" translate="yes" xml:space="preserve">
          <source>Package hash provides interfaces for hash functions.</source>
          <target state="translated">패키지 해시는 해시 함수를위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a59626485ffbd81c7d5e90634cb6e93e7c34e5b" translate="yes" xml:space="preserve">
          <source>Package heap</source>
          <target state="translated">패키지 힙</target>
        </trans-unit>
        <trans-unit id="e93c407a24d497fcea18deaab136750e41bee04c" translate="yes" xml:space="preserve">
          <source>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</source>
          <target state="translated">패키지 힙은 heap.Interface를 구현하는 모든 유형에 대해 힙 작업을 제공합니다. 힙은 각 노드가 하위 트리에서 최소값 노드라는 속성이있는 트리입니다.</target>
        </trans-unit>
        <trans-unit id="7b0d8dd93b6da00a5a3853f6a8971b11d3be119a" translate="yes" xml:space="preserve">
          <source>Package hex</source>
          <target state="translated">패키지 헥스</target>
        </trans-unit>
        <trans-unit id="7413aef6d1364ce17833992530bdefe998ac3dba" translate="yes" xml:space="preserve">
          <source>Package hex implements hexadecimal encoding and decoding.</source>
          <target state="translated">패키지 16 진수는 16 진 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1ae2b94353abc10afddd7e75ff8292b5ec664627" translate="yes" xml:space="preserve">
          <source>Package hmac</source>
          <target state="translated">패키지 hmac</target>
        </trans-unit>
        <trans-unit id="5862414bf4e6f484aa549d995a6f4852a7f9b0df" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.</source>
          <target state="translated">패키지 hmac은 US Federal Information Processing Standards Publication 198에 정의 된 HMAC (Keyed-Hash Message Authentication Code)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="993a4c7f2aa0bc17bb821bd77a5cdca08736959a" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.</source>
          <target state="translated">패키지 hmac는 US Federal Information Processing Standards Publication 198에 정의 된 HMAC (Keyed-Hash Message Authentication Code)를 구현합니다. HMAC는 키를 사용하여 메시지에 서명하는 암호화 해시입니다. 수신자는 동일한 키를 사용하여 해시를 재 계산하여 해시를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fb848edc1bb28a05f8c5d03e75ae2933d6b8c193" translate="yes" xml:space="preserve">
          <source>Package html</source>
          <target state="translated">패키지 HTML</target>
        </trans-unit>
        <trans-unit id="ee6e4064cc07f14cce23003d26486bcbe481c4c8" translate="yes" xml:space="preserve">
          <source>Package html provides functions for escaping and unescaping HTML text.</source>
          <target state="translated">패키지 html은 HTML 텍스트를 이스케이프 및 이스케이프 해제하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93aded6e94d278e605519fd733984fb105ebc8cb" translate="yes" xml:space="preserve">
          <source>Package http</source>
          <target state="translated">패키지 http</target>
        </trans-unit>
        <trans-unit id="565f53df2ba05962d275cc2ddb64a0ff5b302111" translate="yes" xml:space="preserve">
          <source>Package http provides HTTP client and server implementations.</source>
          <target state="translated">패키지 http는 HTTP 클라이언트 및 서버 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="60c2fddc445e71feb989d0582a02f4947d2d457d" translate="yes" xml:space="preserve">
          <source>Package httptest</source>
          <target state="translated">패키지 httptest</target>
        </trans-unit>
        <trans-unit id="aa8780d1e29dd261a3c2246607eef7a72b8bbb1d" translate="yes" xml:space="preserve">
          <source>Package httptest provides utilities for HTTP testing.</source>
          <target state="translated">패키지 httptest는 HTTP 테스트를위한 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f537d98dbab242ca895592a50db6e67fd272c97" translate="yes" xml:space="preserve">
          <source>Package httptrace</source>
          <target state="translated">패키지 httptrace</target>
        </trans-unit>
        <trans-unit id="813e220dd05ef49b41ec90a3fc88de9ec143f032" translate="yes" xml:space="preserve">
          <source>Package httptrace provides mechanisms to trace the events within HTTP client requests.</source>
          <target state="translated">패키지 httptrace는 HTTP 클라이언트 요청 내에서 이벤트를 추적하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9613bdf01a4050ee78eaddb84e11fc64ec270990" translate="yes" xml:space="preserve">
          <source>Package httputil</source>
          <target state="translated">패키지 httputil</target>
        </trans-unit>
        <trans-unit id="76d80a4fa32f388098c8efd95fe330b71ff09bd9" translate="yes" xml:space="preserve">
          <source>Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</source>
          <target state="translated">httputil 패키지는 HTTP 유틸리티 기능을 제공하여 net / http 패키지에서 가장 일반적인 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="421a469bd8c6ddf7b1af341ec45254a3934f90ed" translate="yes" xml:space="preserve">
          <source>Package image</source>
          <target state="translated">패키지 이미지</target>
        </trans-unit>
        <trans-unit id="4aa8ef8dbcca06a643631802f3d7a141211d42b0" translate="yes" xml:space="preserve">
          <source>Package image implements a basic 2-D image library.</source>
          <target state="translated">패키지 이미지는 기본 2D 이미지 라이브러리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2dc8e28a838b11d0551b3a0d88ebb2a4408dab5b" translate="yes" xml:space="preserve">
          <source>Package importer</source>
          <target state="translated">패키지 수입</target>
        </trans-unit>
        <trans-unit id="420252f85bc81d5c6c24a04bcbd00100b4357969" translate="yes" xml:space="preserve">
          <source>Package importer provides access to export data importers.</source>
          <target state="translated">패키지 임포터는 익스포트 데이터 임포터에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93b91053c7ffebf57a4a0530d2af3609eb527706" translate="yes" xml:space="preserve">
          <source>Package internal</source>
          <target state="translated">내부 패키지</target>
        </trans-unit>
        <trans-unit id="ae4bbcb538c3d4b00aa18c51e1cf94d759fc3060" translate="yes" xml:space="preserve">
          <source>Package internal contains HTTP internals shared by net/http and net/http/httputil.</source>
          <target state="translated">내부 패키지에는 net / http 및 net / http / httputil이 공유하는 HTTP 내부가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9636058f09cfb43189cb98a195789b7f0f244da" translate="yes" xml:space="preserve">
          <source>Package io</source>
          <target state="translated">패키지 io</target>
        </trans-unit>
        <trans-unit id="32668f487482a47ba7dcd798b007284f2070596c" translate="yes" xml:space="preserve">
          <source>Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.</source>
          <target state="translated">패키지 io는 I / O 프리미티브에 대한 기본 인터페이스를 제공합니다. 주요 작업은 패키지 os에있는 것과 같은 기본 요소의 기존 구현을 기능을 추상화하는 공유 공용 인터페이스와 기타 관련 기본 요소로 랩핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30cb02e7eab55914ca42d64df94b0246f5f91b46" translate="yes" xml:space="preserve">
          <source>Package iotest</source>
          <target state="translated">패키지 iotest</target>
        </trans-unit>
        <trans-unit id="2188f45ca7e2af66c7f08124940a486765a3a1d3" translate="yes" xml:space="preserve">
          <source>Package iotest implements Readers and Writers useful mainly for testing.</source>
          <target state="translated">패키지 iotest는 주로 테스트에 유용한 리더 및 라이터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f634706aadf3538974af07a1962d2af1e6651011" translate="yes" xml:space="preserve">
          <source>Package ioutil</source>
          <target state="translated">패키지 ioutil</target>
        </trans-unit>
        <trans-unit id="b7b8fc12300546d76dd9c8e4af13cff6a6ad7548" translate="yes" xml:space="preserve">
          <source>Package ioutil implements some I/O utility functions.</source>
          <target state="translated">패키지 ioutil은 일부 I / O 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c9fe1f4196a35af3e90e6bd308c01296038ce831" translate="yes" xml:space="preserve">
          <source>Package is the documentation for an entire package.</source>
          <target state="translated">패키지는 전체 패키지에 대한 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="4c1d637bde171a0a8b7330b1b7e32fbe44f587a8" translate="yes" xml:space="preserve">
          <source>Package jpeg</source>
          <target state="translated">jpeg 패키지</target>
        </trans-unit>
        <trans-unit id="be891878e9ef59cdb50913b5ceb2d5944c8960f6" translate="yes" xml:space="preserve">
          <source>Package jpeg implements a JPEG image decoder and encoder.</source>
          <target state="translated">jpeg 패키지는 JPEG 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5232feffa0151247920dae06a9ddd5d55973aeb8" translate="yes" xml:space="preserve">
          <source>Package js</source>
          <target state="translated">패키지 js</target>
        </trans-unit>
        <trans-unit id="8dacbfd07dd845e3d61f3d13d059dcc9341b5c76" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture.</source>
          <target state="translated">패키지 js는 js / wasm 아키텍처를 사용할 때 WebAssembly 호스트 환경에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="455c332edf437e87334e708fb429cc6e36a5ac4c" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.</source>
          <target state="translated">패키지 js는 js / wasm 아키텍처를 사용할 때 WebAssembly 호스트 환경에 대한 액세스를 제공합니다. API는 JavaScript 의미를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3857092de217368375e6707dd2db2ce13bf5c6d4" translate="yes" xml:space="preserve">
          <source>Package json</source>
          <target state="translated">패키지 JSON</target>
        </trans-unit>
        <trans-unit id="7ba30886d6ae888888da2bc78eb7b020f20e938d" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159.</source>
          <target state="translated">패키지 json은 RFC 7159에 정의 된대로 JSON 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="87906380a06bba048f9b4e8bd43cd1fc7f064c58" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.</source>
          <target state="translated">패키지 json은 RFC 7159에 정의 된대로 JSON 인코딩 및 디코딩을 구현합니다. JSON과 Go 값 사이의 맵핑은 마셜 및 비 정렬 함수에 대한 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d676dca8ece21fde225b9a51b937ba3f6ad6a6" translate="yes" xml:space="preserve">
          <source>Package jsonrpc</source>
          <target state="translated">jsonrpc 패키지</target>
        </trans-unit>
        <trans-unit id="1c78124a6a4761b03c5384a07f14a75cc4666f38" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.</source>
          <target state="translated">패키지 jsonrpc는 rpc 패키지 용 JSON-RPC 1.0 ClientCodec 및 ServerCodec를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="09af982985244ee30f92c80e2ab36bc0138d5a7f" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</source>
          <target state="translated">패키지 jsonrpc는 rpc 패키지 용 JSON-RPC 1.0 ClientCodec 및 ServerCodec를 구현합니다. JSON-RPC 2.0 지원에 대해서는 &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="329023972d7b1c502617105ef48cde0a78cc6333" translate="yes" xml:space="preserve">
          <source>Package list</source>
          <target state="translated">패키지 목록</target>
        </trans-unit>
        <trans-unit id="e56f44c63fe9d6afdfff2ff8bc53c3b472803b64" translate="yes" xml:space="preserve">
          <source>Package list implements a doubly linked list.</source>
          <target state="translated">패키지 목록은 이중 연결 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="39f07fcf96398e5964be22f3a7e100e6e4714031" translate="yes" xml:space="preserve">
          <source>Package log</source>
          <target state="translated">패키지 로그</target>
        </trans-unit>
        <trans-unit id="c01d2cd8db1d9fe6fc80ae05326ed0052a2926ca" translate="yes" xml:space="preserve">
          <source>Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message.</source>
          <target state="translated">패키지 로그는 간단한 로깅 패키지를 구현합니다. 출력 형식을 지정하는 메소드를 사용하여 로거 유형을 정의합니다. 또한 헬퍼 기능 Print [f | ln], Fatal [f | ln] 및 Panic [f | ln]을 통해 액세스 할 수있는 사전 정의 된 '표준'로거가 있으며, 이는 로거를 수동으로 작성하는 것보다 사용하기가 더 쉽습니다. 해당 로거는 표준 오류에 기록하고 기록 된 각 메시지의 날짜와 시간을 인쇄합니다. 모든 로그 메시지는 별도의 줄에 출력됩니다. 인쇄중인 메시지가 줄 바꿈으로 끝나지 않으면 로거가 추가합니다. 치명적 함수는 로그 메시지를 작성한 후 os.Exit (1)을 호출합니다. 패닉 함수는 로그 메시지를 작성한 후 패닉을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2736ca6dade93fff8e3bc211ddd7f28c53ea115b" translate="yes" xml:space="preserve">
          <source>Package lzw</source>
          <target state="translated">패키지 lzw</target>
        </trans-unit>
        <trans-unit id="c4777021f1dd4b6564d1ec41e7d3abc076b6187e" translate="yes" xml:space="preserve">
          <source>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, &amp;ldquo;A Technique for High-Performance Data Compression&amp;rdquo;, Computer, 17(6) (June 1984), pp 8-19.</source>
          <target state="translated">패키지 lzw는 TA Welch,&amp;ldquo;고성능 데이터 압축 기술&amp;rdquo;, 컴퓨터, 17 (6) (1984 년 6 월), pp 8-19에 설명 된 Lempel-Ziv-Welch 압축 데이터 형식을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0e8e7d95f57fe8be09d8faaa0ea86acf1a5fc077" translate="yes" xml:space="preserve">
          <source>Package macho</source>
          <target state="translated">패키지 사나이</target>
        </trans-unit>
        <trans-unit id="92e8c827c8c83c12e1e7b7f121d38fd11d3d6bba" translate="yes" xml:space="preserve">
          <source>Package macho implements access to Mach-O object files.</source>
          <target state="translated">패키지 macho는 Mach-O 객체 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6fe93114653da182b59c5cf973ab0a06ef574c15" translate="yes" xml:space="preserve">
          <source>Package mail</source>
          <target state="translated">패키지 메일</target>
        </trans-unit>
        <trans-unit id="6f8e8eb862b5bec7f5c8edcb6c15137f3e2e3084" translate="yes" xml:space="preserve">
          <source>Package mail implements parsing of mail messages.</source>
          <target state="translated">패키지 메일은 메일 메시지의 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="383fe77ace45b295ad208a38e47b35209b6b894f" translate="yes" xml:space="preserve">
          <source>Package math</source>
          <target state="translated">패키지 수학</target>
        </trans-unit>
        <trans-unit id="b6130e3233ca7fa326fe0f65160f4609452fcc5c" translate="yes" xml:space="preserve">
          <source>Package math provides basic constants and mathematical functions.</source>
          <target state="translated">패키지 수학은 기본 상수와 수학 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91905953ed9b218a4bdf61f1b0e37fe7e7362ece" translate="yes" xml:space="preserve">
          <source>Package md5</source>
          <target state="translated">패키지 md5</target>
        </trans-unit>
        <trans-unit id="91e121cc95845f0e275412a014e511801fa15c71" translate="yes" xml:space="preserve">
          <source>Package md5 implements the MD5 hash algorithm as defined in RFC 1321.</source>
          <target state="translated">패키지 md5는 RFC 1321에 정의 된대로 MD5 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6e452f6ff2b6f89e6e2fddfc0bc47cc6ea9d38e3" translate="yes" xml:space="preserve">
          <source>Package mime</source>
          <target state="translated">패키지 마임</target>
        </trans-unit>
        <trans-unit id="fb5b7d35717be7356677497c60f984d8bae7427b" translate="yes" xml:space="preserve">
          <source>Package mime implements parts of the MIME spec.</source>
          <target state="translated">패키지 MIME은 MIME 사양의 일부를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a4afe7ca5ec65b45429532cb822f68e7b1f969e3" translate="yes" xml:space="preserve">
          <source>Package multipart</source>
          <target state="translated">패키지 멀티 파트</target>
        </trans-unit>
        <trans-unit id="0975c17eab222919880be81a12a600e92a6d534f" translate="yes" xml:space="preserve">
          <source>Package multipart implements MIME multipart parsing, as defined in RFC 2046.</source>
          <target state="translated">패키지 멀티 파트는 RFC 2046에 정의 된대로 MIME 멀티 파트 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="30c5d58023a5520f3b07d9da146a5ed1519a8f7c" translate="yes" xml:space="preserve">
          <source>Package net</source>
          <target state="translated">패키지 네트</target>
        </trans-unit>
        <trans-unit id="43d696099850d935770e8f7b1c038c883c0137cb" translate="yes" xml:space="preserve">
          <source>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.</source>
          <target state="translated">패키지 net은 TCP / IP, UDP, 도메인 이름 확인 및 Unix 도메인 소켓을 포함하여 네트워크 I / O를위한 휴대용 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ab70b00aa79e1b268257a5e997962ee78d287d2" translate="yes" xml:space="preserve">
          <source>Package os</source>
          <target state="translated">패키지 OS</target>
        </trans-unit>
        <trans-unit id="c733a9fd7f2534638a02811f5ea17d1a129c8b5c" translate="yes" xml:space="preserve">
          <source>Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.</source>
          <target state="translated">패키지 os는 운영 체제 기능에 플랫폼 독립적 인 인터페이스를 제공합니다. 오류 처리는 Go와 비슷하지만 디자인은 Unix와 유사합니다. 실패한 호출은 오류 번호가 아닌 오류 유형의 값을 반환합니다. 종종 오류 내에서 추가 정보를 사용할 수 있습니다. 예를 들어, 파일 이름을 사용하는 호출 (예 : Open 또는 Stat)에 실패하면 오류가 인쇄 될 때 실패한 파일 이름이 포함되며 * PathError 유형이며 자세한 정보를 위해 압축이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04c8aee5e23a788ea2bcb38b074f985eac2786a8" translate="yes" xml:space="preserve">
          <source>Package palette</source>
          <target state="translated">패키지 팔레트</target>
        </trans-unit>
        <trans-unit id="cf2f1921f30936ace0261b5025892d44ffab8eb3" translate="yes" xml:space="preserve">
          <source>Package palette provides standard color palettes.</source>
          <target state="translated">패키지 팔레트는 표준 색상 팔레트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0242c171ef1c568c8ae1ca39756ba02bb57c4a9d" translate="yes" xml:space="preserve">
          <source>Package parse</source>
          <target state="translated">패키지 파싱</target>
        </trans-unit>
        <trans-unit id="417bd6bafe4778a0805898be461125c5d876274b" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template.</source>
          <target state="translated">패키지 구문 분석은 text / template 및 html / template에 의해 정의 된 템플리트에 대한 구문 분석 트리를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="9c526058ffd19e7a03ef67d38acb87f2af58bf19" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.</source>
          <target state="translated">패키지 구문 분석은 text / template 및 html / template에 의해 정의 된 템플리트에 대한 구문 분석 트리를 빌드합니다. 클라이언트는이 패키지 대신이 패키지를 사용하여 템플릿을 구성해야합니다.이 패키지는 일반적인 용도로 사용되지 않는 공유 내부 데이터 구조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66cc9b613eb8bc3269dbf5d021ee51da1590e18b" translate="yes" xml:space="preserve">
          <source>Package parser</source>
          <target state="translated">패키지 파서</target>
        </trans-unit>
        <trans-unit id="6de3fe85bffa2dfbd3030929ab437e9f7594c3fc" translate="yes" xml:space="preserve">
          <source>Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse* functions.</source>
          <target state="translated">패키지 파서는 Go 소스 파일에 대한 파서를 구현합니다. 입력은 다양한 형태로 제공 될 수 있습니다 (다양한 구문 분석 * 기능 참조). 출력은 Go 소스를 나타내는 추상 구문 트리 (AST)입니다. 파서는 Parse * 함수 중 하나를 통해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3373a46035bdd1245ec67bf0a2c65e10dfd0f4ad" translate="yes" xml:space="preserve">
          <source>Package path</source>
          <target state="translated">패키지 경로</target>
        </trans-unit>
        <trans-unit id="db836e38d040774081537fe657365110292aec91" translate="yes" xml:space="preserve">
          <source>Package path implements utility routines for manipulating slash-separated paths.</source>
          <target state="translated">패키지 경로는 슬래시로 구분 된 경로를 조작하기위한 유틸리티 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9d24a47a68584686a4df522a7f5e3f005ddc259f" translate="yes" xml:space="preserve">
          <source>Package pe</source>
          <target state="translated">패키지 PE</target>
        </trans-unit>
        <trans-unit id="ce301de224be1f8c3d1c1c5dfcb12d983b03bd77" translate="yes" xml:space="preserve">
          <source>Package pe implements access to PE (Microsoft Windows Portable Executable) files.</source>
          <target state="translated">패키지 pe는 PE (Microsoft Windows Portable Executable) 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e152e56cf87bc67e469bb5da6106c6e936b14368" translate="yes" xml:space="preserve">
          <source>Package pem</source>
          <target state="translated">패키지 pem</target>
        </trans-unit>
        <trans-unit id="f41f7d23d767dfe9afe9b6e7dfc54ee5c677365e" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.</source>
          <target state="translated">패키지 pem은 Privacy Enhanced Mail에서 시작된 PEM 데이터 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0d4c900b99f74302177b2bea20055842f0e52c09" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421.</source>
          <target state="translated">패키지 pem은 Privacy Enhanced Mail에서 시작된 PEM 데이터 인코딩을 구현합니다. 오늘날 PEM 인코딩의 가장 일반적인 용도는 TLS 키 및 인증서입니다. RFC 1421을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38d910b9de0ef4ae8b19f042eb74647af6042913" translate="yes" xml:space="preserve">
          <source>Package pkix</source>
          <target state="translated">패키지 pkix</target>
        </trans-unit>
        <trans-unit id="dc33e58126376b6213633925214424947582c3a3" translate="yes" xml:space="preserve">
          <source>Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</source>
          <target state="translated">패키지 pkix에는 X.509 인증서, CRL 및 OCSP의 ASN.1 구문 분석 및 직렬화에 사용되는 공유 하위 레벨 구조가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b226d60325490b566c70691138cd1c6d21b193" translate="yes" xml:space="preserve">
          <source>Package plan9obj</source>
          <target state="translated">패키지 계획</target>
        </trans-unit>
        <trans-unit id="4665855b57b9b8af3bee702ebd462244986f00bf" translate="yes" xml:space="preserve">
          <source>Package plan9obj implements access to Plan 9 a.out object files.</source>
          <target state="translated">패키지 plan9obj는 Plan 9 a.out 오브젝트 파일에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3cd1d7122e8b0e42817d81ce5dc7226d253ae194" translate="yes" xml:space="preserve">
          <source>Package plugin</source>
          <target state="translated">패키지 플러그인</target>
        </trans-unit>
        <trans-unit id="723391b754af075d19bf19a6d72b4aca8b612706" translate="yes" xml:space="preserve">
          <source>Package plugin implements loading and symbol resolution of Go plugins.</source>
          <target state="translated">패키지 플러그인은 Go 플러그인의 로딩 및 심볼 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="18f40a30c66d89382a5e8d5c5fa97aad2d850e59" translate="yes" xml:space="preserve">
          <source>Package png</source>
          <target state="translated">패키지 png</target>
        </trans-unit>
        <trans-unit id="7d75e3a56a64d92564c27a07179bd65f150fd42a" translate="yes" xml:space="preserve">
          <source>Package png implements a PNG image decoder and encoder.</source>
          <target state="translated">패키지 png는 PNG 이미지 디코더 및 인코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bbb9e684e1674ad5ea70ff8d94149cfba70c0322" translate="yes" xml:space="preserve">
          <source>Package pprof</source>
          <target state="translated">패키지 pprof</target>
        </trans-unit>
        <trans-unit id="6b696f2047997085f203f8e5ea4ab96764716e57" translate="yes" xml:space="preserve">
          <source>Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">pprof 패키지는 HTTP 서버 런타임 프로파일 링 데이터를 통해 pprof 시각화 도구에 필요한 형식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f35eefcb5de07eee157ab4d725a5a9c718348ce1" translate="yes" xml:space="preserve">
          <source>Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">pprof 패키지는 pprof 시각화 도구가 예상하는 형식으로 런타임 프로파일 링 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="bd0a361bc1df19412b2288989fa693bf033d1e94" translate="yes" xml:space="preserve">
          <source>Package printer</source>
          <target state="translated">패키지 프린터</target>
        </trans-unit>
        <trans-unit id="7508f680f0bd7ace72d4e37d8bf4124dd8618769" translate="yes" xml:space="preserve">
          <source>Package printer implements printing of AST nodes.</source>
          <target state="translated">패키지 프린터는 AST 노드의 인쇄를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5a2f6f777ac49a0a6e1a6283c8172aaf45ada261" translate="yes" xml:space="preserve">
          <source>Package quick</source>
          <target state="translated">빠른 패키지</target>
        </trans-unit>
        <trans-unit id="b11b2a9f0787ff668038fd60730c27709091efd5" translate="yes" xml:space="preserve">
          <source>Package quick implements utility functions to help with black box testing.</source>
          <target state="translated">패키지 빠른 기능은 블랙 박스 테스트에 도움이되는 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5a939d420f6017187bd02b98ed377adb9120365c" translate="yes" xml:space="preserve">
          <source>Package quotedprintable</source>
          <target state="translated">인용 가능한 패키지</target>
        </trans-unit>
        <trans-unit id="195c159d436820f6a7d39ac4579d1905b0c74821" translate="yes" xml:space="preserve">
          <source>Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.</source>
          <target state="translated">패키지 인용 인쇄 가능은 RFC 2045에 의해 지정된 인용 인쇄 가능 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d7dd09c477f4383baa2235b2b5f02beab77e4389" translate="yes" xml:space="preserve">
          <source>Package race</source>
          <target state="translated">패키지 레이스</target>
        </trans-unit>
        <trans-unit id="a5c1c2be3bea40e10437334b0813837bf205008a" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic.</source>
          <target state="translated">패키지 레이스는 데이터 레이스 감지 로직을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="96ff3f6524e366a1f85999a9889633b5758b7e5b" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic. No public interface is provided. For details about the race detector see &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</source>
          <target state="translated">패키지 레이스는 데이터 레이스 감지 로직을 구현합니다. 공개 인터페이스가 제공되지 않습니다. 레이스 탐지기에 대한 자세한 내용은 &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="83c163892e45f479d6597f9c22d2df740381ff44" translate="yes" xml:space="preserve">
          <source>Package rand</source>
          <target state="translated">패키지 랜드</target>
        </trans-unit>
        <trans-unit id="cc752fea52bb25978322b7eaf4569384e9741709" translate="yes" xml:space="preserve">
          <source>Package rand implements a cryptographically secure random number generator.</source>
          <target state="translated">패키지 랜드는 암호로 안전한 난수 생성기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b3b18e540dfae96ee4bfa44eff2fe6364db2a649" translate="yes" xml:space="preserve">
          <source>Package rand implements pseudo-random number generators.</source>
          <target state="translated">패키지 랜드는 의사 난수 생성기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d31a1689b285cdf109ef7adc6ecc82f9e08e66cb" translate="yes" xml:space="preserve">
          <source>Package rc4</source>
          <target state="translated">패키지 rc4</target>
        </trans-unit>
        <trans-unit id="9d9070b30c94fbd8ece92c972cff45482e84ea73" translate="yes" xml:space="preserve">
          <source>Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.</source>
          <target state="translated">패키지 rc4는 Bruce Schneier의 Applied Cryptography에 정의 된대로 RC4 암호화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="16eeac7c41dd94aba1ce95ebc38efce516d7ede5" translate="yes" xml:space="preserve">
          <source>Package reflect</source>
          <target state="translated">패키지 반영</target>
        </trans-unit>
        <trans-unit id="ea99463dc27a541bcea8f216ce8b537d53c786f4" translate="yes" xml:space="preserve">
          <source>Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.</source>
          <target state="translated">패키지 반영은 런타임 반영을 구현하여 프로그램이 임의 유형의 객체를 조작 할 수 있도록합니다. 일반적으로 정적 유형 인터페이스 {}로 값을 가져 와서 TypeOf를 호출하여 동적 유형 정보를 추출하여 Type을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6906a6b73a6d72eeebe325c95a7fd2b66657106" translate="yes" xml:space="preserve">
          <source>Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing &quot;unsafe&quot;. However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:</source>
          <target state="translated">Package reflect의 Pointer 및 UnsafeAddr라는 Value 메소드는 unsafe 대신 uintptr 유형을 반환합니다. 그러나 이것은 결과가 깨지기 쉬우 며 같은 식으로 호출 한 직후에 포인터로 변환되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="296c31de17cebe68d7ff50dd54df6ff57cb7cdbd" translate="yes" xml:space="preserve">
          <source>Package regexp</source>
          <target state="translated">정규식 패키지</target>
        </trans-unit>
        <trans-unit id="8db88ff2fae80db5efc49abe986d69219c995b2a" translate="yes" xml:space="preserve">
          <source>Package regexp implements regular expression search.</source>
          <target state="translated">패키지 정규 표현식은 정규 표현식 검색을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8f3fe52956764f5ab5a7617348d70f67990e27be" translate="yes" xml:space="preserve">
          <source>Package ring</source>
          <target state="translated">패키지 링</target>
        </trans-unit>
        <trans-unit id="24781dde0d3396b2f7a5d8de96bf17e6c6511838" translate="yes" xml:space="preserve">
          <source>Package ring implements operations on circular lists.</source>
          <target state="translated">패키지 링은 순환 목록에 대한 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4ac8d28b6f5f90e5f57c49bd02cae6ff1cc3103e" translate="yes" xml:space="preserve">
          <source>Package rpc</source>
          <target state="translated">패키지 RPC</target>
        </trans-unit>
        <trans-unit id="29c7a976ba21e5e3d539285fcef131a0900d481a" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection.</source>
          <target state="translated">패키지 rpc는 네트워크 또는 다른 I / O 연결을 통해 객체의 내 보낸 메소드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89036cae903feb95d9bf22ecb370849d3856aa14" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.</source>
          <target state="translated">패키지 rpc는 네트워크 또는 다른 I / O 연결을 통해 객체의 내 보낸 메소드에 대한 액세스를 제공합니다. 서버는 객체를 등록하여 객체 유형의 이름을 가진 서비스로 표시합니다. 등록 후 객체의 내 보낸 메소드에 원격으로 액세스 할 수 있습니다. 서버가 다른 유형의 여러 객체 (서비스)를 등록 할 수 있지만 동일한 유형의 여러 객체를 등록하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3dd9b23cfd1948413bbf148dd0474b59ad766e9f" translate="yes" xml:space="preserve">
          <source>Package rsa</source>
          <target state="translated">패키지 RSA</target>
        </trans-unit>
        <trans-unit id="9ba02848b97a1b268666b78b127c28a6770b462d" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS#1.</source>
          <target state="translated">패키지 rsa는 PKCS # 1에 지정된 RSA 암호화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4ebd8f5b99b65c7601e3f5f2bad88bd7ec2de054" translate="yes" xml:space="preserve">
          <source>Package runtime</source>
          <target state="translated">패키지 런타임</target>
        </trans-unit>
        <trans-unit id="469b95dee031c267f910a82eae21961d70838630" translate="yes" xml:space="preserve">
          <source>Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system.</source>
          <target state="translated">패키지 런타임에는 고 루틴을 제어하는 ​​기능과 같은 Go의 런타임 시스템과 상호 작용하는 작업이 포함되어 있습니다. 또한 reflect 패키지가 사용하는 하위 레벨 유형 정보도 포함합니다. 런타임 유형 시스템에 대한 프로그래밍 가능 인터페이스에 대한 reflect 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82776b2ed593a3609079c4ab84f51091ff8daaf8" translate="yes" xml:space="preserve">
          <source>Package scanner</source>
          <target state="translated">패키지 스캐너</target>
        </trans-unit>
        <trans-unit id="37829fd57a47182e751d5d54158a385e61ab833d" translate="yes" xml:space="preserve">
          <source>Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method.</source>
          <target state="translated">패키지 스캐너는 Go 소스 텍스트 용 스캐너를 구현합니다. [] 바이트를 소스로 사용하여 Scan 메소드를 반복해서 호출하여 토큰화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cff89fb02b03b32b0811fa214e2e7a1126ee135b" translate="yes" xml:space="preserve">
          <source>Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded.</source>
          <target state="translated">패키지 스캐너는 UTF-8로 인코딩 된 텍스트를위한 스캐너 및 토크 나이저를 제공합니다. 소스를 제공하는 io.Reader가 필요하며 스캔 기능에 대한 반복 호출을 통해 토큰화할 수 있습니다. 기존 도구와의 호환성을 위해 NUL 문자는 허용되지 않습니다. 소스의 첫 번째 문자가 UTF-8 인코딩 된 바이트 순서 표시 (BOM) 인 경우 버려집니다.</target>
        </trans-unit>
        <trans-unit id="6e0759392e3584cd8a2a3d2a6c4931673b5e35b2" translate="yes" xml:space="preserve">
          <source>Package sha1</source>
          <target state="translated">패키지 sha1</target>
        </trans-unit>
        <trans-unit id="db1a6662e07e0565a4b3c55f6347a0baeacc49fb" translate="yes" xml:space="preserve">
          <source>Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.</source>
          <target state="translated">패키지 sha1은 RFC 3174에 정의 된 SHA-1 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f6ad23ee3ab99920af8ac5cfc82080a0e1b3b09f" translate="yes" xml:space="preserve">
          <source>Package sha256</source>
          <target state="translated">패키지 sha256</target>
        </trans-unit>
        <trans-unit id="c9317efee8c5fefb81226a055344cf996daf2874" translate="yes" xml:space="preserve">
          <source>Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">sha256 패키지는 FIPS 180-4에 정의 된 SHA224 및 SHA256 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4e4623212d4095d72a62997c9796888b7d1b95c9" translate="yes" xml:space="preserve">
          <source>Package sha512</source>
          <target state="translated">패키지 sha512</target>
        </trans-unit>
        <trans-unit id="65d83f8c0979c324f75579653a6e20dcc05fc8a1" translate="yes" xml:space="preserve">
          <source>Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">패키지 sha512는 FIPS 180-4에 정의 된 SHA-384, SHA-512, SHA-512 / 224 및 SHA-512 / 256 해시 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="80e54559e475073190cfed119c9847e346d01634" translate="yes" xml:space="preserve">
          <source>Package signal</source>
          <target state="translated">패키지 신호</target>
        </trans-unit>
        <trans-unit id="59f2e9e157e5e2c56d4bb35edf223ce0a7c75cdf" translate="yes" xml:space="preserve">
          <source>Package signal implements access to incoming signals.</source>
          <target state="translated">패키지 신호는 들어오는 신호에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0e49eafb9bb1f34b1ff3d2c9a1f4a0ec52ecdba3" translate="yes" xml:space="preserve">
          <source>Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.</source>
          <target state="translated">패키지 신호는 c 로의 전송을 차단하지 않습니다. 호출자는 c에 예상 신호 속도를 유지할 수있는 충분한 버퍼 공간이 있는지 확인해야합니다. 단 하나의 신호 값을 알리는 데 사용되는 채널의 경우 크기 1의 버퍼로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fc75b3c455c2cde737da3fcce8266dd282fe7922" translate="yes" xml:space="preserve">
          <source>Package smtp</source>
          <target state="translated">smtp 패키지</target>
        </trans-unit>
        <trans-unit id="b50b30b8ea306091fbb446aaa4ed61109401fff0" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</source>
          <target state="translated">smtp 패키지는 RFC 5321에 정의 된대로 단순 메일 전송 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1fe6e79dac787b0d56b7abea30c16ebab918d57e" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions:</source>
          <target state="translated">smtp 패키지는 RFC 5321에 정의 된대로 Simple Mail Transfer Protocol을 구현합니다. 또한 다음 확장을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="71f7fab9acf61b6109216266ded759b751fdf3ba" translate="yes" xml:space="preserve">
          <source>Package sort</source>
          <target state="translated">패키지 정렬</target>
        </trans-unit>
        <trans-unit id="0962324992fa79918c2dd6cf47c8b372c511e5ff" translate="yes" xml:space="preserve">
          <source>Package sort provides primitives for sorting slices and user-defined collections.</source>
          <target state="translated">패키지 정렬은 슬라이스 및 사용자 정의 컬렉션을 정렬하기위한 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9bd1b867b8811e4a5059325426012d1ac3fbe070" translate="yes" xml:space="preserve">
          <source>Package sql</source>
          <target state="translated">패키지 SQL</target>
        </trans-unit>
        <trans-unit id="9e262166973b441cf1a6b45fe03044818008c94a" translate="yes" xml:space="preserve">
          <source>Package sql provides a generic interface around SQL (or SQL-like) databases.</source>
          <target state="translated">패키지 sql은 SQL (또는 SQL과 같은) 데이터베이스에 대한 일반적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b57c7d54ee7ea7e0a45d8c13b8a29358c7a1a59" translate="yes" xml:space="preserve">
          <source>Package strconv</source>
          <target state="translated">패키지 strconv</target>
        </trans-unit>
        <trans-unit id="3c44c13248967ffe512eec5e12e0ac2d83aaabcb" translate="yes" xml:space="preserve">
          <source>Package strconv implements conversions to and from string representations of basic data types.</source>
          <target state="translated">패키지 strconv는 기본 데이터 유형의 문자열 표현과의 변환을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="28ec3487bac9bff1cd40dd5bfdaac3e5f0f7e66b" translate="yes" xml:space="preserve">
          <source>Package strings</source>
          <target state="translated">패키지 문자열</target>
        </trans-unit>
        <trans-unit id="30f2d5d3c8bcd3201c529ed7194820953f047942" translate="yes" xml:space="preserve">
          <source>Package strings implements simple functions to manipulate UTF-8 encoded strings.</source>
          <target state="translated">패키지 문자열은 UTF-8로 인코딩 된 문자열을 조작하는 간단한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5f3a2aafe35539648afeeb350719fa852f88f7f2" translate="yes" xml:space="preserve">
          <source>Package subtle</source>
          <target state="translated">미묘한 패키지</target>
        </trans-unit>
        <trans-unit id="af533feda0fe1c8229caece2fdfd190444424ea5" translate="yes" xml:space="preserve">
          <source>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.</source>
          <target state="translated">미묘한 패키지는 종종 암호화 코드에 유용하지만 올바르게 사용하려면 신중한 생각이 필요한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="39d17df25323190f4cc53202e597d56f35dfee6b" translate="yes" xml:space="preserve">
          <source>Package suffixarray</source>
          <target state="translated">패키지 접미사</target>
        </trans-unit>
        <trans-unit id="7980bb666cc38cba6c4aaf92417db33415ccfaa1" translate="yes" xml:space="preserve">
          <source>Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.</source>
          <target state="translated">패키지 접미사는 메모리 내 접미사 배열을 사용하여 로그 시간에 하위 문자열 검색을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="346a1d63b09ad3c0b05c14691bf67091b87cabe5" translate="yes" xml:space="preserve">
          <source>Package sync</source>
          <target state="translated">패키지 동기화</target>
        </trans-unit>
        <trans-unit id="aea6d23bbc4ed584bf5042d03479be247cbf1087" translate="yes" xml:space="preserve">
          <source>Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.</source>
          <target state="translated">패키지 동기화는 상호 배제 잠금과 같은 기본 동기화 기본 요소를 제공합니다. Once 및 WaitGroup 유형 이외의 대부분은 하위 수준 라이브러리 루틴에서 사용하기위한 것입니다. 높은 수준의 동기화는 채널과 통신을 통해 더 잘 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4c913bf7c7c5e8773000f095ebe490accad3a2" translate="yes" xml:space="preserve">
          <source>Package syntax</source>
          <target state="translated">패키지 구문</target>
        </trans-unit>
        <trans-unit id="a713eae229dc7c92d21e8a224e10ceffb09512c2" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs.</source>
          <target state="translated">패키지 구문은 정규식을 구문 분석 트리로 구문 분석하고 구문 분석 트리를 프로그램으로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a70c7eb9cc685b98a0a5536eddbf6dbc0cba4ac8" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package.</source>
          <target state="translated">패키지 구문은 정규식을 구문 분석 트리로 구문 분석하고 구문 분석 트리를 프로그램으로 컴파일합니다. 대부분의 정규 표현식 클라이언트는이 패키지 대신 정규식 패키지 (예 : 컴파일 및 일치) 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11e76797e8363318c05ceb15b2d2b47e39353883" translate="yes" xml:space="preserve">
          <source>Package sys</source>
          <target state="translated">패키지 시스템</target>
        </trans-unit>
        <trans-unit id="d21a124cf49a1b492319130693efdb9b8a34c61d" translate="yes" xml:space="preserve">
          <source>Package syscall</source>
          <target state="translated">패키지 시스템 콜</target>
        </trans-unit>
        <trans-unit id="0f53f1418ab827df34bf754bfae7d8d0c010c7cc" translate="yes" xml:space="preserve">
          <source>Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as &quot;os&quot;, &quot;time&quot; and &quot;net&quot;. Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type syscall.Errno.</source>
          <target state="translated">패키지 syscall에는 저수준 운영 체제 프리미티브에 대한 인터페이스가 포함되어 있습니다. 세부 사항은 기본 시스템에 따라 다르며 기본적으로 godoc은 현재 시스템에 대한 syscall 문서를 표시합니다. godoc이 다른 시스템에 대한 syscall 문서를 표시하도록하려면 $ GOOS 및 $ GOARCH를 원하는 시스템으로 설정하십시오. 예를 들어 linux / amd64에서 freebsd / arm에 대한 설명서를 보려면 $ GOOS를 freebsd로, $ GOARCH를 arm으로 설정하십시오. syscall은 주로 &quot;os&quot;, &quot;time&quot;및 &quot;net&quot;과 같이 시스템에보다 이식 가능한 인터페이스를 제공하는 다른 패키지 내부에서 사용됩니다. 가능하면이 패키지 대신 해당 패키지를 사용하십시오. 이 패키지의 기능 및 데이터 유형에 대한 자세한 내용은 해당 운영 체제의 설명서를 참조하십시오. 이 호출은 성공을 표시하기 위해 err == nil을 리턴합니다.그렇지 않으면 err는 실패를 설명하는 운영 체제 오류입니다. 대부분의 시스템에서이 오류는 syscall.Errno 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f90ba2ae4e2d681143f3d41fb43a2f79b7c3197e" translate="yes" xml:space="preserve">
          <source>Package syslog</source>
          <target state="translated">패키지 syslog</target>
        </trans-unit>
        <trans-unit id="396038b0a959cfae15beae20a0f48bc80b80cf43" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service.</source>
          <target state="translated">패키지 syslog는 시스템 로그 서비스에 대한 간단한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1f55ec1734bdf22b075380ad35ee09a577ec002" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.</source>
          <target state="translated">패키지 syslog는 시스템 로그 서비스에 대한 간단한 인터페이스를 제공합니다. UNIX 도메인 소켓, UDP 또는 TCP를 사용하여 syslog 디먼에 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007cb2c9dc06f8f699c331e9716d599817f048b5" translate="yes" xml:space="preserve">
          <source>Package tabwriter</source>
          <target state="translated">패키지 타자기</target>
        </trans-unit>
        <trans-unit id="f7841eb33056b73d4a3597207ce6dc7e384c846d" translate="yes" xml:space="preserve">
          <source>Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.</source>
          <target state="translated">패키지 탭 작성기는 입력의 탭 열을 올바르게 정렬 된 텍스트로 변환하는 쓰기 필터 (tabwriter.Writer)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bec4ed72f4fd10dfa620d0e5687ebc626dc193a1" translate="yes" xml:space="preserve">
          <source>Package tar</source>
          <target state="translated">패키지 타르</target>
        </trans-unit>
        <trans-unit id="b3d0f0f238631cf9655cf5816e9f94b6db370098" translate="yes" xml:space="preserve">
          <source>Package tar implements access to tar archives.</source>
          <target state="translated">패키지 tar는 tar 아카이브에 대한 액세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7ac2ec5b1841ff39f85ad1d4687cc3abfa906a39" translate="yes" xml:space="preserve">
          <source>Package template</source>
          <target state="translated">패키지 템플릿</target>
        </trans-unit>
        <trans-unit id="aba87a8492b37ccf916bdea97ed3b469ce8125f0" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection.</source>
          <target state="translated">패키지 템플릿 (html / template)은 코드 삽입에 대해 안전한 HTML 출력을 생성하기 위해 데이터 기반 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9776451c8a221b1dfd29d6efbaff6d2de3fbf0aa" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML.</source>
          <target state="translated">패키지 템플릿 (html / template)은 코드 삽입에 대해 안전한 HTML 출력을 생성하기 위해 데이터 기반 템플릿을 구현합니다. 패키지 텍스트 / 템플릿과 동일한 인터페이스를 제공하며 출력이 HTML 일 때마다 텍스트 / 템플릿 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12fb252e998414c68ff5f9998dbcdff046a0fe8f" translate="yes" xml:space="preserve">
          <source>Package template implements data-driven templates for generating textual output.</source>
          <target state="translated">패키지 템플릿은 텍스트 출력을 생성하기위한 데이터 기반 템플릿을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8f2f8d22daa6bdd34d84049e31c95592348695b8" translate="yes" xml:space="preserve">
          <source>Package testing</source>
          <target state="translated">패키지 테스트</target>
        </trans-unit>
        <trans-unit id="9c91ae9ffc226daabd50a55612fc0b4ce9280216" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &amp;ldquo;go test&amp;rdquo; command, which automates execution of any function of the form</source>
          <target state="translated">패키지 테스트는 Go 패키지의 자동 테스트를 지원합니다. &quot;go test&quot;명령과 함께 사용하여 양식의 모든 기능을 자동으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="10fa2d9109fabc6fd9b96730e5f6c29a2ec7c36f" translate="yes" xml:space="preserve">
          <source>Package textproto</source>
          <target state="translated">패키지 텍스트</target>
        </trans-unit>
        <trans-unit id="3dc8f07b5e53239f3d16cf68abc4c177c52d10af" translate="yes" xml:space="preserve">
          <source>Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</source>
          <target state="translated">패키지 textproto는 HTTP, NNTP 및 SMTP 스타일의 텍스트 기반 요청 / 응답 프로토콜에 대한 일반적인 지원을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e0896056124ecab0339d61326880bfb542bc907f" translate="yes" xml:space="preserve">
          <source>Package time</source>
          <target state="translated">패키지 시간</target>
        </trans-unit>
        <trans-unit id="5305dc12a988a4ce552cf3341269cdd34206dbc0" translate="yes" xml:space="preserve">
          <source>Package time provides functionality for measuring and displaying time.</source>
          <target state="translated">패키지 시간은 시간을 측정하고 표시하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2870bb3df8e650dbc1e60be06a2c5ae58d30789e" translate="yes" xml:space="preserve">
          <source>Package tls</source>
          <target state="translated">패키지 tls</target>
        </trans-unit>
        <trans-unit id="7f75931d43fdfef0a07153ddf14ad51258da3f69" translate="yes" xml:space="preserve">
          <source>Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.</source>
          <target state="translated">패키지 tls는 RFC 5246에 지정된대로 TLS 1.2 및 RFC 8446에 지정된대로 TLS 1.3을 부분적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="71cf571a2e2d9b69987d70384e5e0a349bbf13f6" translate="yes" xml:space="preserve">
          <source>Package token</source>
          <target state="translated">패키지 토큰</target>
        </trans-unit>
        <trans-unit id="3de5e73d48412b9fa410e9f04a2075f5ec3be3f1" translate="yes" xml:space="preserve">
          <source>Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).</source>
          <target state="translated">패키지 토큰은 Go 프로그래밍 언어의 어휘 토큰 및 토큰에 대한 기본 연산 (인쇄, 술어)을 나타내는 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7e450a321c355f3612aca2e34d0a073905f6e6ac" translate="yes" xml:space="preserve">
          <source>Package trace</source>
          <target state="translated">패키지 추적</target>
        </trans-unit>
        <trans-unit id="025720b70dde0a472ee8ed25e4b132eb460e89d0" translate="yes" xml:space="preserve">
          <source>Package trace contains facilities for programs to generate traces for the Go execution tracer.</source>
          <target state="translated">패키지 추적에는 Go 실행 추적 프로그램에 대한 추적을 생성하는 프로그램 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e63d422df1350bbdcfb3a251a3dd0dcdbbc02d1" translate="yes" xml:space="preserve">
          <source>Package trace provides user annotation APIs that can be used to log interesting events during execution.</source>
          <target state="translated">패키지 추적은 실행 중에 흥미로운 이벤트를 기록하는 데 사용할 수있는 사용자 주석 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b954397c4a071e1cc2e5aec57815cae94675ccf5" translate="yes" xml:space="preserve">
          <source>Package types</source>
          <target state="translated">패키지 유형</target>
        </trans-unit>
        <trans-unit id="046779ebad1597aa59c89817459594972c347086" translate="yes" xml:space="preserve">
          <source>Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files.</source>
          <target state="translated">패키지 유형은 데이터 유형을 선언하고 Go 패키지의 유형 확인 알고리즘을 구현합니다. Config.Check를 사용하여 패키지의 유형 검사기를 호출하십시오. 또는 NewChecker로 새 유형 검사기를 작성하고 Checker.Files를 호출하여 점진적으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ab9e4b9642ec1eafa3034c351ee1c61944a1812d" translate="yes" xml:space="preserve">
          <source>Package unicode</source>
          <target state="translated">패키지 유니 코드</target>
        </trans-unit>
        <trans-unit id="1d363f9997c96fdcfdb92764e225e66454bc7d90" translate="yes" xml:space="preserve">
          <source>Package unicode provides data and functions to test some properties of Unicode code points.</source>
          <target state="translated">패키지 유니 코드는 유니 코드 코드 포인트의 일부 속성을 테스트하기위한 데이터 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ed360d93d2eb692bc3647fbb297fd557060587f2" translate="yes" xml:space="preserve">
          <source>Package unsafe</source>
          <target state="translated">안전하지 않은 패키지</target>
        </trans-unit>
        <trans-unit id="f3779d5060271e804458c7a976ac1ca5792c1c2a" translate="yes" xml:space="preserve">
          <source>Package unsafe contains operations that step around the type safety of Go programs.</source>
          <target state="translated">안전하지 않은 패키지에는 Go 프로그램의 유형 안전을 둘러싼 작업이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd4c1e0c59a537b7729289d4b67c4a3c1f81ee5" translate="yes" xml:space="preserve">
          <source>Package url</source>
          <target state="translated">패키지 URL</target>
        </trans-unit>
        <trans-unit id="4387dda0da368c99a229d78b0b38d344b8ddba79" translate="yes" xml:space="preserve">
          <source>Package url parses URLs and implements query escaping.</source>
          <target state="translated">패키지 URL은 URL을 구문 분석하고 쿼리 이스케이프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fa2e3df3b1c8d0f2ae6af8b9831692e368e35553" translate="yes" xml:space="preserve">
          <source>Package user</source>
          <target state="translated">패키지 사용자</target>
        </trans-unit>
        <trans-unit id="36a98acad58d4786ee6c07f69161ac71cff79f1c" translate="yes" xml:space="preserve">
          <source>Package user allows user account lookups by name or id.</source>
          <target state="translated">패키지 사용자는 이름 또는 ID별로 사용자 계정을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="950f17b07369b94da04e57b90cd290ee5b7ab329" translate="yes" xml:space="preserve">
          <source>Package utf16</source>
          <target state="translated">패키지 utf16</target>
        </trans-unit>
        <trans-unit id="a91481384b6ca45acef08e50a0a602f6b354aa0d" translate="yes" xml:space="preserve">
          <source>Package utf16 implements encoding and decoding of UTF-16 sequences.</source>
          <target state="translated">패키지 utf16은 UTF-16 시퀀스의 인코딩 및 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="82c84de36eee3827503136824453e15f86291f2b" translate="yes" xml:space="preserve">
          <source>Package utf8</source>
          <target state="translated">패키지 utf8</target>
        </trans-unit>
        <trans-unit id="2d558781d2038e750681faba06d532094ebcdee0" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8.</source>
          <target state="translated">패키지 utf8은 UTF-8로 인코딩 된 텍스트를 지원하기 위해 함수와 상수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c4336946f769b3e34f747cb0c522858f6f2bca8f" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.</source>
          <target state="translated">패키지 utf8은 UTF-8로 인코딩 된 텍스트를 지원하기 위해 함수와 상수를 구현합니다. 룬과 UTF-8 바이트 시퀀스 사이를 변환하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e005285bbb9f85e9b954bed4a6e12999ae03a672" translate="yes" xml:space="preserve">
          <source>Package x509</source>
          <target state="translated">패키지 x509</target>
        </trans-unit>
        <trans-unit id="90de220d2bc052deab02c2c4de98a3e71c3ef316" translate="yes" xml:space="preserve">
          <source>Package x509 parses X.509-encoded keys and certificates.</source>
          <target state="translated">패키지 x509는 X.509로 인코딩 된 키와 인증서를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="10ff4b7cfdffba3a4767c605c3ebace89b42f92c" translate="yes" xml:space="preserve">
          <source>Package xml</source>
          <target state="translated">패키지 XML</target>
        </trans-unit>
        <trans-unit id="93a9b657d94cd318e7ad743005d8b996f9595c6e" translate="yes" xml:space="preserve">
          <source>Package xml implements a simple XML 1.0 parser that understands XML name spaces.</source>
          <target state="translated">패키지 xml은 XML 네임 스페이스를 이해하는 간단한 XML 1.0 파서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c19f04e6d6be831ab25449a487f0756316b351f6" translate="yes" xml:space="preserve">
          <source>Package zip</source>
          <target state="translated">패키지 지퍼</target>
        </trans-unit>
        <trans-unit id="dfaad266283daad5d81fc0dfbfdf6760dc866668" translate="yes" xml:space="preserve">
          <source>Package zip provides support for reading and writing ZIP archives.</source>
          <target state="translated">패키지 zip은 ZIP 아카이브를 읽고 쓰는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="588377b14974d4da962ee44fcd3a951c7da0ddbc" translate="yes" xml:space="preserve">
          <source>Package zlib</source>
          <target state="translated">패키지 zlib</target>
        </trans-unit>
        <trans-unit id="b8d40d3cbcb305861fd98b2ba9ad33cfda1fe2f6" translate="yes" xml:space="preserve">
          <source>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</source>
          <target state="translated">패키지 zlib는 RFC 1950에 지정된대로 zlib 형식 압축 데이터 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e6ebfcdbe4d41913bba3eb021c5e2f7faa2a5af8" translate="yes" xml:space="preserve">
          <source>PackageExports reports whether there are exported declarations; it returns false otherwise.</source>
          <target state="translated">PackageExports는 내 보낸 선언이 있는지보고합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9ae56929a397151dd71c50540c8ba9f7a374f8b" translate="yes" xml:space="preserve">
          <source>PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">PackageExports는 내 보낸 노드 만 남아 있도록 Go 패키지의 AST를 잘라냅니다. pkg.Files 목록은 변경되지 않으므로 파일 이름과 최상위 패키지 주석이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74867f01a0f6f645509d530ed289df047c6ca5df" translate="yes" xml:space="preserve">
          <source>PackageName returns the package part of the symbol name, or the empty string if there is none.</source>
          <target state="translated">PackageName은 심볼 이름의 패키지 부분을 반환하거나 존재하지 않는 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17c03b27b19d3b24962032b7096b91392545e063" translate="yes" xml:space="preserve">
          <source>Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.</source>
          <target state="translated">안전하지 않은 패키지는 이식 할 수 없으며 Go 1 호환성 지침에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85b5ee2819eb33cd78762cf51c0b4a5dd5523cb8" translate="yes" xml:space="preserve">
          <source>PacketConn is a generic packet-oriented network connection.</source>
          <target state="translated">PacketConn은 일반적인 패킷 지향 네트워크 연결입니다.</target>
        </trans-unit>
        <trans-unit id="a0ac68089bb018405a8a46934512cae685b010b0" translate="yes" xml:space="preserve">
          <source>Palette is a palette of colors.</source>
          <target state="translated">팔레트는 색상 팔레트입니다.</target>
        </trans-unit>
        <trans-unit id="8345eec10c921c39ee65aec65372e629adf963d0" translate="yes" xml:space="preserve">
          <source>Paletted is an in-memory image of uint8 indices into a given palette.</source>
          <target state="translated">팔레트는 주어진 팔레트에 대한 uint8 인덱스의 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="811857fbbfb6bbe0a3457e5ca72c3cf06e353567" translate="yes" xml:space="preserve">
          <source>PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.</source>
          <target state="translated">PalettedImage는 색상이 제한된 팔레트에서 나올 수있는 이미지입니다. m이 PalettedImage이고 m.ColorModel ()이 color.Palette p를 반환하면 m.At (x, y)는 p [m.ColorIndexAt (x, y)]와 동일해야합니다. m의 색상 모델이 color.Palette가 아닌 경우 ColorIndexAt의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a512c7d0f9809b6517eee35249de666659ba9bfb" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to Print() followed by a call to panic().</source>
          <target state="translated">Panic은 Print ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="70327e98d175663a82976707da91eda94bf1b6a7" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to l.Print() followed by a call to panic().</source>
          <target state="translated">패닉은 l.Print ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="acc202ec50a5ea3772bacf3218be7877d69941fa" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to Printf() followed by a call to panic().</source>
          <target state="translated">Panicf는 Printf ()와 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="609a5ff18403fc4ba9beec643b7a217eafb712bf" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to l.Printf() followed by a call to panic().</source>
          <target state="translated">Panicf는 l.Printf () 다음에 panic ()을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de496f946eb01de54aacea36389a2930b2b5fea9" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to Println() followed by a call to panic().</source>
          <target state="translated">Panicln은 Println ()과 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="42b6fefdbb3fe1d6cc946346feb02780fc4954d4" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to l.Println() followed by a call to panic().</source>
          <target state="translated">Panicln은 l.Println ()과 동일하며 panic ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3f233f952852726c76f955efdb8cfad2984864f8" translate="yes" xml:space="preserve">
          <source>Panics if x is not one of the expected types.</source>
          <target state="translated">x가 예상 유형 중 하나가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2656e6fe95970497f2da4ae50b709bea0cd1bc5b" translate="yes" xml:space="preserve">
          <source>Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.</source>
          <target state="translated">이 테스트가 다른 병렬 테스트와 함께 병렬로 실행되어야한다는 병렬 신호. -test.count 또는 -test.cpu를 사용하여 테스트를 여러 번 실행하면 단일 테스트의 여러 인스턴스가 서로 병렬로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ff45dda694203612652ce58eb32539f9ea39636" translate="yes" xml:space="preserve">
          <source>ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.</source>
          <target state="translated">ParameterSizes는 소수의 DSA 매개 변수 세트에서 소수의 허용 가능한 비트 길이를 열거 한 것입니다. FIPS 186-3, 섹션 4.2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a38d6c7adf0ef721d51b09e9ef7d3dab505e3376" translate="yes" xml:space="preserve">
          <source>Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.</source>
          <target state="translated">매개 변수는 키의 도메인 매개 변수를 나타냅니다. 이러한 매개 변수는 많은 키에서 공유 할 수 있습니다. Q의 비트 길이는 8의 배수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a595a7d8c4b648ee6f267ac2a444e5bcc46523" translate="yes" xml:space="preserve">
          <source>Params returns the parameters of signature s, or nil.</source>
          <target state="translated">Params는 signatures 또는 nil의 매개 변수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="21b514799f92100d51f5995498a76d50a6591d7f" translate="yes" xml:space="preserve">
          <source>Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.</source>
          <target state="translated">Parent는 객체가 선언 된 범위를 반환합니다. 메소드 및 구조체 필드의 경우 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d2ab1d9170cbc23bb71b0003b207c4504e77bc1" translate="yes" xml:space="preserve">
          <source>Parent returns the scope's containing (parent) scope.</source>
          <target state="translated">Parent는 범위를 포함하는 (부모) 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7e45a36ff3610e06a3801fd14fa6c1e6b89312f" translate="yes" xml:space="preserve">
          <source>Parse</source>
          <target state="translated">Parse</target>
        </trans-unit>
        <trans-unit id="eadd3db51adcf33e03ef4c729d1f1d357ded94ad" translate="yes" xml:space="preserve">
          <source>Parse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files.</source>
          <target state="translated">다양한 관련 템플릿을 조립하기 위해 구문 분석을 여러 번 호출 할 수 있습니다. 파일에 저장된 관련 템플릿을 구문 분석하는 간단한 방법은 ParseFiles 및 ParseGlob 함수 및 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5c1289f5e01bfdc5e745aca9c64851f068edc1" translate="yes" xml:space="preserve">
          <source>Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference.</source>
          <target state="translated">구문 분석은 수신자의 컨텍스트에서 URL을 구문 분석합니다. 제공된 URL은 상대적이거나 절대적 일 수 있습니다. 구문 분석은 nil을 리턴하고 구문 분석 실패시 오류를 리턴합니다. 그렇지 않으면 리턴 값은 ResolveReference와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8516fe9b2b0e681b5f1a19c09c598e09f76c0a92" translate="yes" xml:space="preserve">
          <source>Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be</source>
          <target state="translated">구문 분석은 형식화 된 문자열을 구문 분석하고 해당 문자열이 나타내는 시간 값을 리턴합니다. 레이아웃은 기준 시간이 다음과 같이 정의 된 방식을 보여줌으로써 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="db84b44056db6c0589142cb550f7685b84290b5a" translate="yes" xml:space="preserve">
          <source>Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.</source>
          <target state="translated">구문 분석은 지정된 플래그에 의해 제어되는 정규식 문자열을 구문 분석하고 정규식 구문 분석 트리를 리턴합니다. 구문은 최상위 주석에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0cb24027bbf7f03a0c792dd455fd65c8a881c5" translate="yes" xml:space="preserve">
          <source>Parse parses a single RFC 5322 address of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">구문 분석은 &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot;또는 &quot;foo@example.com&quot;형식의 단일 RFC 5322 주소를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6329cd5d9d98d1f00f6752cb84cd2b25ccb27456" translate="yes" xml:space="preserve">
          <source>Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.</source>
          <target state="translated">구문 분석은 명령 이름을 포함하지 않아야하는 인수 목록에서 플래그 정의를 구문 분석합니다. FlagSet의 모든 플래그가 정의 된 후 그리고 프로그램이 플래그에 액세스하기 전에 호출해야합니다. -help 또는 -h가 설정되었지만 정의되지 않은 경우 리턴 값은 ErrHelp입니다.</target>
        </trans-unit>
        <trans-unit id="18bad4ea2cc97c8a9f4948e0f21e613e7890178a" translate="yes" xml:space="preserve">
          <source>Parse parses rawurl into a URL structure.</source>
          <target state="translated">구문 분석은 rawurl을 URL 구조로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="68237f10d24bed5fb80b0763ff0184c661ba1727" translate="yes" xml:space="preserve">
          <source>Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.</source>
          <target state="translated">구문 분석 제공된 변환 기준에서 가수가있는 부동 소수점 숫자 (지수는 항상 10 진수) 또는 무한 값을 나타내는 문자열의 텍스트 표현을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="36bbed9dac5fc81c047e065b17ee658b65e3a5a6" translate="yes" xml:space="preserve">
          <source>Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.</source>
          <target state="translated">구문 분석 텍스트를 t의 템플리트 본문으로 구문 분석합니다. 텍스트에서 명명 된 템플릿 정의 ({{define ...}} 또는 {{block ...}} 문)는 t와 관련된 추가 템플릿을 정의하며 t 자체의 정의에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0827d39a9b548f4f8b5bce9dee6cdaa918b52e5" translate="yes" xml:space="preserve">
          <source>Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.</source>
          <target state="translated">구문 분석은 os.Args [1 :]에서 명령 행 플래그를 구문 분석합니다. 모든 플래그가 정의되고 프로그램이 플래그에 액세스하기 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42efe8079bb64df560c33d7d830ca75ae8ed877" translate="yes" xml:space="preserve">
          <source>Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (&quot;{{&quot; or &quot;}}&quot;) is used. Embedded template definitions are added to the treeSet map.</source>
          <target state="translated">구문 분석은 템플리트 정의 문자열을 구문 분석하여 실행할 템플리트의 표현을 구성합니다. 조치 분리 문자 문자열이 비어 있으면 기본값 ( &quot;{{&quot;또는 &quot;}}&quot;)이 사용됩니다. 포함 된 템플릿 정의가 treeSet 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="45783abf61a9fbf7fb39991bfe339c1b46133bb7" translate="yes" xml:space="preserve">
          <source>Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.</source>
          <target state="translated">Parse는 템플릿 이름에서 parse.Tree 로의 맵을 반환하며 인수 문자열에 설명 된 템플릿을 구문 분석하여 생성됩니다. 최상위 템플릿에는 지정된 이름이 지정됩니다. 오류가 발생하면 구문 분석이 중지되고 오류와 함께 빈 맵이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="66daff607d3735d4a8218dfbf123ab6dbc3c14bd" translate="yes" xml:space="preserve">
          <source>ParseAddress</source>
          <target state="translated">ParseAddress</target>
        </trans-unit>
        <trans-unit id="845f64c05cb52df568c8a8ad63c74420b1248668" translate="yes" xml:space="preserve">
          <source>ParseAddress parses a single RFC 5322 address, e.g. &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;</source>
          <target state="translated">ParseAddress는 단일 RFC 5322 주소를 구문 분석합니다 (예 : &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="ff9201bea61c197b726cdbdba040febe1fb6e8d1" translate="yes" xml:space="preserve">
          <source>ParseAddressList</source>
          <target state="translated">ParseAddressList</target>
        </trans-unit>
        <trans-unit id="ac5ae9b34b3307e496577d3e37b7a87a645c4e1d" translate="yes" xml:space="preserve">
          <source>ParseAddressList parses the given string as a list of addresses.</source>
          <target state="translated">ParseAddressList는 주어진 문자열을 주소 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6a0560d771cdd8a3e81f49597b77c74c345d99ff" translate="yes" xml:space="preserve">
          <source>ParseBool</source>
          <target state="translated">ParseBool</target>
        </trans-unit>
        <trans-unit id="48e4dd268460af7ff4ba4ae65e2a683e5e2d3f52" translate="yes" xml:space="preserve">
          <source>ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.</source>
          <target state="translated">ParseBool은 문자열로 표시되는 부울 값을 반환합니다. 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False를 허용합니다. 다른 값은 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22e1b2e318d4e5834961059fa9d10ad0bddc3198" translate="yes" xml:space="preserve">
          <source>ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:</source>
          <target state="translated">ParseBool, ParseFloat, ParseInt 및 ParseUint는 문자열을 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b287ba3d9ab143c06c570eef216327abbf80cd22" translate="yes" xml:space="preserve">
          <source>ParseCIDR</source>
          <target state="translated">ParseCIDR</target>
        </trans-unit>
        <trans-unit id="753119985829ad20f5fb77b43aff8f713890c2d1" translate="yes" xml:space="preserve">
          <source>ParseCIDR parses s as a CIDR notation IP address and prefix length, like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/32&quot;, as defined in RFC 4632 and RFC 4291.</source>
          <target state="translated">ParseCIDR은 RFC 4632 및 RFC 4291에 정의 된대로 &quot;192.0.2.0/24&quot;또는 &quot;2001 : db8 :: / 32&quot;와 같은 CIDR 표기법 IP 주소 및 접두사 길이로 s를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="3db7887ddb0dc9836c9d867b0da11217386b066e" translate="yes" xml:space="preserve">
          <source>ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.</source>
          <target state="translated">ParseCRL은 주어진 바이트에서 CRL을 구문 분석합니다. PEM으로 인코딩 된 CRL이 DER로 인코딩되어야하는 곳에 나타나는 경우가 많으므로이 함수는 선행 가비지가없는 한 PEM 인코딩을 투명하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="13bcfda4565f496b59a919b4e59789ae5fb7deb1" translate="yes" xml:space="preserve">
          <source>ParseCertificate parses a single certificate from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificate는 지정된 ASN.1 DER 데이터에서 단일 인증서를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d4b98b2809a870dbc00f34abcb696de9660e20f1" translate="yes" xml:space="preserve">
          <source>ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificateRequest는 지정된 ASN.1 DER 데이터에서 단일 인증서 요청을 구문 분석합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
